<!DOCTYPE html><html><head><title>Help for package nlme</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlme}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.pdMat'><p>Subscript a pdMat Object</p></a></li>
<li><a href='#ACF'><p>Autocorrelation Function</p></a></li>
<li><a href='#ACF.gls'><p>Autocorrelation Function for gls Residuals</p></a></li>
<li><a href='#ACF.lme'><p>Autocorrelation Function for lme Residuals</p></a></li>
<li><a href='#Alfalfa'><p>Split-Plot Experiment on Varieties of Alfalfa</p></a></li>
<li><a href='#allCoef'><p>Extract Coefficients from a Set of Objects</p></a></li>
<li><a href='#anova.gls'><p>Compare Likelihoods of Fitted Objects</p></a></li>
<li><a href='#anova.lme'><p>Compare Likelihoods of Fitted Objects</p></a></li>
<li><a href='#as.matrix.corStruct'><p>Matrix of a corStruct Object</p></a></li>
<li><a href='#as.matrix.pdMat'><p>Matrix of a pdMat Object</p></a></li>
<li><a href='#as.matrix.reStruct'><p>Matrices of an reStruct Object</p></a></li>
<li><a href='#asOneFormula'><p>Combine Formulas of a Set of Objects</p></a></li>
<li><a href='#Assay'><p>Bioassay on Cell Culture Plate</p></a></li>
<li><a href='#asTable'><p>Convert groupedData to a matrix</p></a></li>
<li><a href='#augPred'><p>Augmented Predictions</p></a></li>
<li><a href='#balancedGrouped'><p>Create a groupedData object from a matrix</p></a></li>
<li><a href='#bdf'><p>Language scores</p></a></li>
<li><a href='#BodyWeight'><p>Rat weight over time for different diets</p></a></li>
<li><a href='#Cefamandole'><p>Pharmacokinetics of Cefamandole</p></a></li>
<li><a href='#Coef'><p>Assign Values to Coefficients</p></a></li>
<li><a href='#coef.corStruct'><p>Coefficients of a corStruct Object</p></a></li>
<li><a href='#coef.gnls'><p>Extract gnls Coefficients</p></a></li>
<li><a href='#coef.lme'><p>Extract lme Coefficients</p></a></li>
<li><a href='#coef.lmList'><p>Extract lmList Coefficients</p></a></li>
<li><a href='#coef.modelStruct'><p>Extract modelStruct Object Coefficients</p></a></li>
<li><a href='#coef.pdMat'><p>pdMat Object Coefficients</p></a></li>
<li><a href='#coef.reStruct'><p>reStruct Object Coefficients</p></a></li>
<li><a href='#coef.varFunc'><p>varFunc Object Coefficients</p></a></li>
<li><a href='#collapse'><p>Collapse According to Groups</p></a></li>
<li><a href='#collapse.groupedData'><p>Collapse a groupedData Object</p></a></li>
<li><a href='#compareFits'><p>Compare Fitted Objects</p></a></li>
<li><a href='#comparePred'><p>Compare Predictions</p></a></li>
<li><a href='#corAR1'><p>AR(1) Correlation Structure</p></a></li>
<li><a href='#corARMA'><p>ARMA(p,q) Correlation Structure</p></a></li>
<li><a href='#corCAR1'><p>Continuous AR(1) Correlation Structure</p></a></li>
<li><a href='#corClasses'><p>Correlation Structure Classes</p></a></li>
<li><a href='#corCompSymm'><p>Compound Symmetry Correlation Structure</p></a></li>
<li><a href='#corExp'><p>Exponential Correlation Structure</p></a></li>
<li><a href='#corFactor'><p>Factor of a Correlation Matrix</p></a></li>
<li><a href='#corFactor.corStruct'><p>Factor of a corStruct Object Matrix</p></a></li>
<li><a href='#corGaus'><p>Gaussian Correlation Structure</p></a></li>
<li><a href='#corLin'><p>Linear Correlation Structure</p></a></li>
<li><a href='#corMatrix'><p>Extract Correlation Matrix</p></a></li>
<li><a href='#corMatrix.corStruct'><p>Matrix of a corStruct Object</p></a></li>
<li><a href='#corMatrix.pdMat'><p>Extract Correlation Matrix from a pdMat Object</p></a></li>
<li><a href='#corMatrix.reStruct'><p>Extract Correlation Matrix from Components of an reStruct Object</p></a></li>
<li><a href='#corNatural'><p>General correlation in natural parameterization</p></a></li>
<li><a href='#corRatio'><p>Rational Quadratic Correlation Structure</p></a></li>
<li><a href='#corSpatial'><p>Spatial Correlation Structure</p></a></li>
<li><a href='#corSpher'><p>Spherical Correlation Structure</p></a></li>
<li><a href='#corSymm'><p>General Correlation Structure</p></a></li>
<li><a href='#Covariate'><p>Assign Covariate Values</p></a></li>
<li><a href='#Covariate.varFunc'><p>Assign varFunc Covariate</p></a></li>
<li><a href='#Dialyzer'><p>High-Flux Hemodialyzer</p></a></li>
<li><a href='#Dim'><p>Extract Dimensions from an Object</p></a></li>
<li><a href='#Dim.corSpatial'><p>Dimensions of a corSpatial Object</p></a></li>
<li><a href='#Dim.corStruct'><p>Dimensions of a corStruct Object</p></a></li>
<li><a href='#Dim.pdMat'><p>Dimensions of a pdMat Object</p></a></li>
<li><a href='#Earthquake'><p>Earthquake Intensity</p></a></li>
<li><a href='#ergoStool'><p>Ergometrics experiment with stool types</p></a></li>
<li><a href='#Fatigue'><p>Cracks caused by metal fatigue</p></a></li>
<li><a href='#fdHess'><p>Finite difference Hessian</p></a></li>
<li><a href='#fitted.glsStruct'><p>Calculate glsStruct Fitted Values</p></a></li>
<li><a href='#fitted.gnlsStruct'><p>Calculate gnlsStruct Fitted Values</p></a></li>
<li><a href='#fitted.lme'><p>Extract lme Fitted Values</p></a></li>
<li><a href='#fitted.lmeStruct'><p>Calculate lmeStruct Fitted Values</p></a></li>
<li><a href='#fitted.lmList'><p>Extract lmList Fitted Values</p></a></li>
<li><a href='#fitted.nlmeStruct'><p>Calculate nlmeStruct Fitted Values</p></a></li>
<li><a href='#fixed.effects'><p>Extract Fixed Effects</p></a></li>
<li><a href='#fixef.lmList'><p>Extract lmList Fixed Effects</p></a></li>
<li><a href='#formula.pdBlocked'><p>Extract pdBlocked Formula</p></a></li>
<li><a href='#formula.pdMat'><p>Extract pdMat Formula</p></a></li>
<li><a href='#formula.reStruct'><p>Extract reStruct Object Formula</p></a></li>
<li><a href='#gapply'><p>Apply a Function by Groups</p></a></li>
<li><a href='#Gasoline'><p>Refinery yield of gasoline</p></a></li>
<li><a href='#getCovariate'><p>Extract Covariate from an Object</p></a></li>
<li><a href='#getCovariate.corStruct'><p>Extract corStruct Object Covariate</p></a></li>
<li><a href='#getCovariate.data.frame'><p>Extract Data Frame Covariate</p></a></li>
<li><a href='#getCovariate.varFunc'><p>Extract varFunc Covariate</p></a></li>
<li><a href='#getCovariateFormula'><p>Extract Covariates Formula</p></a></li>
<li><a href='#getData'><p>Extract Data from an Object</p></a></li>
<li><a href='#getData.gls'><p>Extract gls Object Data</p></a></li>
<li><a href='#getData.lme'><p>Extract lme Object Data</p></a></li>
<li><a href='#getData.lmList'><p>Extract lmList Object Data</p></a></li>
<li><a href='#getGroups'><p>Extract Grouping Factors from an Object</p></a></li>
<li><a href='#getGroups.corStruct'><p>Extract corStruct Groups</p></a></li>
<li><a href='#getGroups.data.frame'><p>Extract Groups from a Data Frame</p></a></li>
<li><a href='#getGroups.gls'><p>Extract gls Object Groups</p></a></li>
<li><a href='#getGroups.lme'><p>Extract lme Object Groups</p></a></li>
<li><a href='#getGroups.lmList'><p>Extract lmList Object Groups</p></a></li>
<li><a href='#getGroups.varFunc'><p>Extract varFunc Groups</p></a></li>
<li><a href='#getGroupsFormula'><p>Extract Grouping Formula</p></a></li>
<li><a href='#getResponse'><p>Extract Response Variable from an Object</p></a></li>
<li><a href='#getResponseFormula'><p>Extract Formula Specifying Response Variable</p></a></li>
<li><a href='#getVarCov'><p>Extract variance-covariance matrix</p></a></li>
<li><a href='#gls'><p>Fit Linear Model Using Generalized Least Squares</p></a></li>
<li><a href='#gls-internal'><p>Auxiliary functions used by gls</p></a></li>
<li><a href='#glsControl'><p>Control Values for gls Fit</p></a></li>
<li><a href='#glsObject'><p>Fitted gls Object</p></a></li>
<li><a href='#glsStruct'><p>Generalized Least Squares Structure</p></a></li>
<li><a href='#Glucose'><p>Glucose levels over time</p></a></li>
<li><a href='#Glucose2'><p>Glucose Levels Following Alcohol Ingestion</p></a></li>
<li><a href='#gnls'><p>Fit Nonlinear Model Using Generalized Least Squares</p></a></li>
<li><a href='#gnlsControl'><p>Control Values for gnls Fit</p></a></li>
<li><a href='#gnlsObject'><p>Fitted gnls Object</p></a></li>
<li><a href='#gnlsStruct'><p>Generalized Nonlinear Least Squares Structure</p></a></li>
<li><a href='#groupedData'><p>Construct a groupedData Object</p></a></li>
<li><a href='#gsummary'><p>Summarize by Groups</p></a></li>
<li><a href='#Gun'><p>Methods for firing naval guns</p></a></li>
<li><a href='#IGF'><p>Radioimmunoassay of IGF-I Protein</p></a></li>
<li><a href='#Initialize'><p>Initialize Object</p></a></li>
<li><a href='#Initialize.corStruct'><p>Initialize corStruct Object</p></a></li>
<li><a href='#Initialize.glsStruct'><p>Initialize a glsStruct Object</p></a></li>
<li><a href='#Initialize.lmeStruct'><p>Initialize an lmeStruct Object</p></a></li>
<li><a href='#Initialize.reStruct'><p>Initialize reStruct Object</p></a></li>
<li><a href='#Initialize.varFunc'><p>Initialize varFunc Object</p></a></li>
<li><a href='#intervals'><p>Confidence Intervals on Coefficients</p></a></li>
<li><a href='#intervals.gls'><p>Confidence Intervals on gls Parameters</p></a></li>
<li><a href='#intervals.lme'><p>Confidence Intervals on lme Parameters</p></a></li>
<li><a href='#intervals.lmList'><p>Confidence Intervals on lmList Coefficients</p></a></li>
<li><a href='#isBalanced'><p>Check a Design for Balance</p></a></li>
<li><a href='#isInitialized'><p>Check if Object is Initialized</p></a></li>
<li><a href='#LDEsysMat'><p>Generate system matrix for LDEs</p></a></li>
<li><a href='#lme'><p>Linear Mixed-Effects Models</p></a></li>
<li><a href='#lme.groupedData'><p>LME fit from groupedData Object</p></a></li>
<li><a href='#lme.lmList'><p>LME fit from lmList Object</p></a></li>
<li><a href='#lmeControl'><p>Specifying Control Values for lme Fit</p></a></li>
<li><a href='#lmeObject'><p>Fitted lme Object</p></a></li>
<li><a href='#lmeStruct'><p>Linear Mixed-Effects Structure</p></a></li>
<li><a href='#lmList'><p>List of lm Objects with a Common Model</p></a></li>
<li><a href='#lmList.groupedData'><p>lmList Fit from a groupedData Object</p></a></li>
<li><a href='#logDet'><p>Extract the Logarithm of the Determinant</p></a></li>
<li><a href='#logDet.corStruct'><p>Extract corStruct Log-Determinant</p></a></li>
<li><a href='#logDet.pdMat'><p>Extract Log-Determinant from a pdMat Object</p></a></li>
<li><a href='#logDet.reStruct'><p>Extract reStruct Log-Determinants</p></a></li>
<li><a href='#logLik.corStruct'><p>Extract corStruct Log-Likelihood</p></a></li>
<li><a href='#logLik.glsStruct'><p>Log-Likelihood of a glsStruct Object</p></a></li>
<li><a href='#logLik.gnls'><p>Log-Likelihood of a gnls Object</p></a></li>
<li><a href='#logLik.gnlsStruct'><p>Log-Likelihood of a gnlsStruct Object</p></a></li>
<li><a href='#logLik.lme'><p>Log-Likelihood of an lme Object</p></a></li>
<li><a href='#logLik.lmeStruct'><p>Log-Likelihood of an lmeStruct Object</p></a></li>
<li><a href='#logLik.lmList'><p>Log-Likelihood of an lmList Object</p></a></li>
<li><a href='#logLik.reStruct'><p>Calculate reStruct Log-Likelihood</p></a></li>
<li><a href='#logLik.varFunc'><p>Extract varFunc logLik</p></a></li>
<li><a href='#Machines'><p>Productivity Scores for Machines and Workers</p></a></li>
<li><a href='#MathAchieve'><p>Mathematics achievement scores</p></a></li>
<li><a href='#MathAchSchool'><p>School demographic data for MathAchieve</p></a></li>
<li><a href='#Matrix'><p>Assign Matrix Values</p></a></li>
<li><a href='#Matrix.pdMat'><p>Assign Matrix to a pdMat or pdBlocked Object</p></a></li>
<li><a href='#Matrix.reStruct'><p>Assign reStruct Matrices</p></a></li>
<li><a href='#Meat'><p>Tenderness of meat</p></a></li>
<li><a href='#Milk'><p>Protein content of cows' milk</p></a></li>
<li><a href='#model.matrix.reStruct'><p>reStruct Model Matrix</p></a></li>
<li><a href='#Muscle'><p>Contraction of heart muscle sections</p></a></li>
<li><a href='#Names'><p>Names Associated with an Object</p></a></li>
<li><a href='#Names.formula'><p>Extract Names from a formula</p></a></li>
<li><a href='#Names.pdBlocked'><p>Names of a pdBlocked Object</p></a></li>
<li><a href='#Names.pdMat'><p>Names of a pdMat Object</p></a></li>
<li><a href='#Names.reStruct'><p>Names of an reStruct Object</p></a></li>
<li><a href='#needUpdate'><p>Check if Update is Needed</p></a></li>
<li><a href='#needUpdate.modelStruct'><p>Check if a modelStruct Object Needs Updating</p></a></li>
<li><a href='#Nitrendipene'><p>Assay of nitrendipene</p></a></li>
<li><a href='#nlme'><p>Nonlinear Mixed-Effects Models</p></a></li>
<li><a href='#nlme-deprecated'><p>Deprecated Functions in Package <span class="pkg">nlme</span></p></a></li>
<li><a href='#nlme.nlsList'><p>NLME fit from nlsList Object</p></a></li>
<li><a href='#nlmeControl'><p>Control Values for nlme Fit</p></a></li>
<li><a href='#nlmeObject'><p>Fitted nlme Object</p></a></li>
<li><a href='#nlmeStruct'><p>Nonlinear Mixed-Effects Structure</p></a></li>
<li><a href='#nlsList'><p>List of nls Objects with a Common Model</p></a></li>
<li><a href='#nlsList.selfStart'><p>nlsList Fit from a selfStart Function</p></a></li>
<li><a href='#Oats'><p>Split-plot Experiment on Varieties of Oats</p></a></li>
<li><a href='#Orthodont'><p>Growth curve data on an orthdontic measurement</p></a></li>
<li><a href='#Ovary'><p>Counts of Ovarian Follicles</p></a></li>
<li><a href='#Oxboys'><p>Heights of Boys in Oxford</p></a></li>
<li><a href='#Oxide'><p>Variability in Semiconductor Manufacturing</p></a></li>
<li><a href='#pairs.compareFits'><p>Pairs Plot of compareFits Object</p></a></li>
<li><a href='#pairs.lme'><p>Pairs Plot of an lme Object</p></a></li>
<li><a href='#pairs.lmList'><p>Pairs Plot of an lmList Object</p></a></li>
<li><a href='#PBG'><p>Effect of Phenylbiguanide on Blood Pressure</p></a></li>
<li><a href='#pdBlocked'><p>Positive-Definite Block Diagonal Matrix</p></a></li>
<li><a href='#pdClasses'><p>Positive-Definite Matrix Classes</p></a></li>
<li><a href='#pdCompSymm'><p>Positive-Definite Matrix with Compound Symmetry Structure</p></a></li>
<li><a href='#pdConstruct'><p>Construct pdMat Objects</p></a></li>
<li><a href='#pdConstruct.pdBlocked'><p>Construct pdBlocked Objects</p></a></li>
<li><a href='#pdDiag'><p>Diagonal Positive-Definite Matrix</p></a></li>
<li><a href='#pdFactor'><p>Square-Root Factor of a Positive-Definite Matrix</p></a></li>
<li><a href='#pdFactor.reStruct'><p>Extract Square-Root Factor from Components of an reStruct Object</p></a></li>
<li><a href='#pdIdent'><p>Multiple of the Identity Positive-Definite Matrix</p></a></li>
<li><a href='#pdLogChol'><p>General Positive-Definite Matrix</p></a></li>
<li><a href='#pdMat'><p>Positive-Definite Matrix</p></a></li>
<li><a href='#pdMatrix'><p>Extract Matrix or Square-Root Factor from a pdMat Object</p></a></li>
<li><a href='#pdMatrix.reStruct'><p>Extract Matrix or Square-Root Factor from Components of an</p>
reStruct Object</a></li>
<li><a href='#pdNatural'><p>General Positive-Definite Matrix in Natural Parametrization</p></a></li>
<li><a href='#pdSymm'><p>General Positive-Definite Matrix</p></a></li>
<li><a href='#Phenobarb'><p>Phenobarbitol Kinetics</p></a></li>
<li><a href='#phenoModel'><p>Model function for the Phenobarb data</p></a></li>
<li><a href='#Pixel'><p>X-ray pixel intensities over time</p></a></li>
<li><a href='#plot.ACF'><p>Plot an ACF Object</p></a></li>
<li><a href='#plot.augPred'><p>Plot an augPred Object</p></a></li>
<li><a href='#plot.compareFits'><p>Plot a compareFits Object</p></a></li>
<li><a href='#plot.gls'><p>Plot a gls Object</p></a></li>
<li><a href='#plot.intervals.lmList'><p>Plot lmList Confidence Intervals</p></a></li>
<li><a href='#plot.lme'><p>Plot an lme or nls object</p></a></li>
<li><a href='#plot.lmList'><p>Plot an lmList Object</p></a></li>
<li><a href='#plot.nffGroupedData'><p>Plot an nffGroupedData Object</p></a></li>
<li><a href='#plot.nfnGroupedData'><p>Plot an nfnGroupedData Object</p></a></li>
<li><a href='#plot.nmGroupedData'><p>Plot an nmGroupedData Object</p></a></li>
<li><a href='#plot.ranef.lme'><p>Plot a ranef.lme Object</p></a></li>
<li><a href='#plot.ranef.lmList'><p>Plot a ranef.lmList Object</p></a></li>
<li><a href='#plot.Variogram'><p>Plot a Variogram Object</p></a></li>
<li><a href='#pooledSD'><p>Extract Pooled Standard Deviation</p></a></li>
<li><a href='#predict.gls'><p>Predictions from a gls Object</p></a></li>
<li><a href='#predict.gnls'><p>Predictions from a gnls Object</p></a></li>
<li><a href='#predict.lme'><p>Predictions from an lme Object</p></a></li>
<li><a href='#predict.lmList'><p>Predictions from an lmList Object</p></a></li>
<li><a href='#predict.nlme'><p>Predictions from an nlme Object</p></a></li>
<li><a href='#print.summary.pdMat'><p>Print a summary.pdMat Object</p></a></li>
<li><a href='#print.varFunc'><p>Print a varFunc Object</p></a></li>
<li><a href='#qqnorm.gls'><p>Normal Plot of Residuals from a gls Object</p></a></li>
<li><a href='#qqnorm.lme'><p>Normal Plot of Residuals or Random Effects from an lme Object</p></a></li>
<li><a href='#Quinidine'><p>Quinidine Kinetics</p></a></li>
<li><a href='#quinModel'><p>Model function for the Quinidine data</p></a></li>
<li><a href='#Rail'><p>Evaluation of Stress in Railway Rails</p></a></li>
<li><a href='#random.effects'><p>Extract Random Effects</p></a></li>
<li><a href='#ranef.lme'><p>Extract lme Random Effects</p></a></li>
<li><a href='#ranef.lmList'><p>Extract lmList Random Effects</p></a></li>
<li><a href='#RatPupWeight'><p>The weight of rat pups</p></a></li>
<li><a href='#recalc'><p>Recalculate Condensed Linear Model Object</p></a></li>
<li><a href='#recalc.corStruct'><p>Recalculate for corStruct Object</p></a></li>
<li><a href='#recalc.modelStruct'><p>Recalculate for a modelStruct Object</p></a></li>
<li><a href='#recalc.reStruct'><p>Recalculate for an reStruct Object</p></a></li>
<li><a href='#recalc.varFunc'><p>Recalculate for varFunc Object</p></a></li>
<li><a href='#Relaxin'><p>Assay for Relaxin</p></a></li>
<li><a href='#Remifentanil'><p>Pharmacokinetics of Remifentanil</p></a></li>
<li><a href='#residuals.gls'><p>Extract gls Residuals</p></a></li>
<li><a href='#residuals.glsStruct'><p>Calculate glsStruct Residuals</p></a></li>
<li><a href='#residuals.gnlsStruct'><p>Calculate gnlsStruct Residuals</p></a></li>
<li><a href='#residuals.lme'><p>Extract lme Residuals</p></a></li>
<li><a href='#residuals.lmeStruct'><p>Calculate lmeStruct Residuals</p></a></li>
<li><a href='#residuals.lmList'><p>Extract lmList Residuals</p></a></li>
<li><a href='#residuals.nlmeStruct'><p>Calculate nlmeStruct Residuals</p></a></li>
<li><a href='#reStruct'><p>Random Effects Structure</p></a></li>
<li><a href='#simulate.lme'><p>Simulate Results from <code>lme</code> Models</p></a></li>
<li><a href='#solve.pdMat'><p>Calculate Inverse of a Positive-Definite Matrix</p></a></li>
<li><a href='#solve.reStruct'><p>Apply Solve to an reStruct Object</p></a></li>
<li><a href='#Soybean'><p>Growth of soybean plants</p></a></li>
<li><a href='#splitFormula'><p>Split a Formula</p></a></li>
<li><a href='#Spruce'><p>Growth of Spruce Trees</p></a></li>
<li><a href='#summary.corStruct'><p>Summarize a corStruct Object</p></a></li>
<li><a href='#summary.gls'><p>Summarize a Generalized Least Squares <code>gls</code> Object</p></a></li>
<li><a href='#summary.lme'><p>Summarize an lme Object</p></a></li>
<li><a href='#summary.lmList'><p>Summarize an lmList Object</p></a></li>
<li><a href='#summary.modelStruct'><p>Summarize a modelStruct Object</p></a></li>
<li><a href='#summary.nlsList'><p>Summarize an nlsList Object</p></a></li>
<li><a href='#summary.pdMat'><p>Summarize a pdMat Object</p></a></li>
<li><a href='#summary.varFunc'><p>Summarize &quot;varFunc&quot; Object</p></a></li>
<li><a href='#Tetracycline1'><p>Pharmacokinetics of tetracycline</p></a></li>
<li><a href='#Tetracycline2'><p>Pharmacokinetics of tetracycline</p></a></li>
<li><a href='#update.modelStruct'><p>Update a modelStruct Object</p></a></li>
<li><a href='#update.varFunc'><p>Update varFunc Object</p></a></li>
<li><a href='#varClasses'><p>Variance Function Classes</p></a></li>
<li><a href='#varComb'><p>Combination of Variance Functions</p></a></li>
<li><a href='#varConstPower'><p>Constant Plus Power Variance Function</p></a></li>
<li><a href='#varConstProp'><p>Constant Plus Proportion Variance Function</p></a></li>
<li><a href='#VarCorr'><p>Extract variance and correlation components</p></a></li>
<li><a href='#varExp'><p>Exponential Variance Function</p></a></li>
<li><a href='#varFixed'><p>Fixed Variance Function</p></a></li>
<li><a href='#varFunc'><p>Variance Function Structure</p></a></li>
<li><a href='#varIdent'><p>Constant Variance Function</p></a></li>
<li><a href='#Variogram'><p>Calculate Semi-variogram</p></a></li>
<li><a href='#Variogram.corExp'><p>Calculate Semi-variogram for a corExp Object</p></a></li>
<li><a href='#Variogram.corGaus'><p>Calculate Semi-variogram for a corGaus Object</p></a></li>
<li><a href='#Variogram.corLin'><p>Calculate Semi-variogram for a corLin Object</p></a></li>
<li><a href='#Variogram.corRatio'><p>Calculate Semi-variogram for a corRatio Object</p></a></li>
<li><a href='#Variogram.corSpatial'><p>Calculate Semi-variogram for a corSpatial Object</p></a></li>
<li><a href='#Variogram.corSpher'><p>Calculate Semi-variogram for a corSpher Object</p></a></li>
<li><a href='#Variogram.default'><p>Calculate Semi-variogram</p></a></li>
<li><a href='#Variogram.gls'><p>Calculate Semi-variogram for Residuals from a gls Object</p></a></li>
<li><a href='#Variogram.lme'><p>Calculate Semi-variogram for Residuals from an lme Object</p></a></li>
<li><a href='#varPower'><p>Power Variance Function</p></a></li>
<li><a href='#varWeights'><p>Extract Variance Function Weights</p></a></li>
<li><a href='#varWeights.glsStruct'><p>Variance Weights for glsStruct Object</p></a></li>
<li><a href='#varWeights.lmeStruct'><p>Variance Weights for lmeStruct Object</p></a></li>
<li><a href='#Wafer'><p>Modeling of Analog MOS Circuits</p></a></li>
<li><a href='#Wheat'><p>Yields by growing conditions</p></a></li>
<li><a href='#Wheat2'><p>Wheat Yield Trials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1-164</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Priority:</td>
<td>recommended</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear and Nonlinear Mixed Effects Models</td>
</tr>
<tr>
<td>Contact:</td>
<td>see 'MailingList'</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and compare Gaussian linear and nonlinear mixed-effects models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Hmisc, MASS, SASmixed</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bugs.r-project.org">https://bugs.r-project.org</a></td>
</tr>
<tr>
<td>MailingList:</td>
<td>R-help@r-project.org</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://svn.r-project.org/R-packages/trunk/nlme/">https://svn.r-project.org/R-packages/trunk/nlme/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 10:37:08 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>José Pinheiro [aut] (S version),
  Douglas Bates [aut] (up to 2007),
  Saikat DebRoy [ctb] (up to 2002),
  Deepayan Sarkar [ctb] (up to 2005),
  EISPACK authors [ctb] (src/rs.f),
  Siem Heisterkamp [ctb] (Author fixed sigma),
  Bert Van Willigen [ctb] (Programmer fixed sigma),
  Johannes Ranke [ctb] (varConstProp()),
  R Core Team [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R Core Team &lt;R-core@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 15:26:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.pdMat'>Subscript a pdMat Object</h2><span id='topic++5B.pdMat'></span><span id='topic++5B.pdBlocked'></span><span id='topic++5B+3C-.pdMat'></span>

<h3>Description</h3>

<p>This method function extracts sub-matrices from the positive-definite
matrix represented by <code>x</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
x[i, j, drop = TRUE]
## S3 replacement method for class 'pdMat'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.pdMat_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code> representing a
positive-definite matrix.</p>
</td></tr>
<tr><td><code id="+2B5B.pdMat_+3A_i">i</code>, <code id="+2B5B.pdMat_+3A_j">j</code></td>
<td>
<p>optional subscripts applying respectively to the rows
and columns of the positive-definite matrix represented by
<code>object</code>. When <code>i</code> (<code>j</code>) is omitted, all rows (columns)
are extracted.</p>
</td></tr>
<tr><td><code id="+2B5B.pdMat_+3A_drop">drop</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, single rows or columns are
converted to vectors. If <code>FALSE</code> the returned value retains its
matrix representation.</p>
</td></tr>
<tr><td><code id="+2B5B.pdMat_+3A_value">value</code></td>
<td>
<p>a vector, or matrix, with the replacement values for the
relevant piece of the matrix represented by <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>i</code> and <code>j</code> are identical, the returned value will be
<code>pdMat</code> object with the same class as <code>x</code>. Otherwise, the
returned value will be a matrix. In the case a single row (or column)
is selected, the returned value may be converted to a vector,
according to the rules above.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic++5B">[</a></code>, <code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(diag(3))
pd1[1, , drop = FALSE]
pd1[1:2, 1:2] &lt;- 3 * diag(2)
</code></pre>

<hr>
<h2 id='ACF'>Autocorrelation Function</h2><span id='topic+ACF'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>gls</code> and  <code>lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACF(object, maxLag, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACF_+3A_object">object</code></td>
<td>
<p>any object from which an autocorrelation function can be
obtained. Generally an object resulting from a model fit, from which
residuals can be extracted.</p>
</td></tr>
<tr><td><code id="ACF_+3A_maxlag">maxLag</code></td>
<td>
<p>maximum lag for which the autocorrelation should be
calculated.</p>
</td></tr> 
<tr><td><code id="ACF_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:Bates@stat.wisc.edu">Bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACF.gls">ACF.gls</a></code>,
<code><a href="#topic+ACF.lme">ACF.lme</a></code>,
<code><a href="#topic+plot.ACF">plot.ACF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='ACF.gls'>Autocorrelation Function for gls Residuals</h2><span id='topic+ACF.gls'></span>

<h3>Description</h3>

<p>This method function calculates the empirical autocorrelation function
for the residuals from a <code>gls</code> fit. If a grouping variable is
specified in <code>form</code>, the autocorrelation values
are calculated using pairs of residuals within the same group;
otherwise all possible residual pairs are used. The autocorrelation
function is useful for investigating serial correlation models for
equally spaced data.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
ACF(object, maxLag, resType, form, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACF.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted  model.</p>
</td></tr>
<tr><td><code id="ACF.gls_+3A_maxlag">maxLag</code></td>
<td>
<p>an optional integer giving the maximum lag for which the
autocorrelation should be calculated. Defaults to maximum lag in the
residuals.</p>
</td></tr>  
<tr><td><code id="ACF.gls_+3A_restype">resType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used. If <code>"response"</code>, the &quot;raw&quot; residuals
(observed - fitted) are used; else, if <code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided. Defaults to <code>"pearson"</code>.</p>
</td></tr> 
<tr><td><code id="ACF.gls_+3A_form">form</code></td>
<td>
<p>an optional one sided formula of the form <code>~ t</code>, or
<code>~ t | g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. The time covariate must be integer
valued. When a grouping factor is present in 
<code>form</code>, the autocorrelations are calculated using residual pairs
within the same group. Defaults to <code>~ 1</code>, which corresponds to
using the order of the observations in the data as a covariate, and
no groups.</p>
</td></tr>   
<tr><td><code id="ACF.gls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>ACF.gls</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="ACF.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>lag</code> and <code>ACF</code> representing,
respectively, the lag between residuals within a pair and the corresponding
empirical autocorrelation. The returned value inherits from class
<code>ACF</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACF.lme">ACF.lme</a></code>, <code><a href="#topic+plot.ACF">plot.ACF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary)
ACF(fm1, form = ~ 1 | Mare)

# Pinheiro and Bates, p. 255-257
fm1Dial.gls &lt;- gls(rate ~
  (pressure+I(pressure^2)+I(pressure^3)+I(pressure^4))*QB,
                   Dialyzer)

fm2Dial.gls &lt;- update(fm1Dial.gls,
                 weights = varPower(form = ~ pressure))

ACF(fm2Dial.gls, form = ~ 1 | Subject)
</code></pre>

<hr>
<h2 id='ACF.lme'>Autocorrelation Function for lme Residuals</h2><span id='topic+ACF.lme'></span>

<h3>Description</h3>

<p>This method function calculates the empirical autocorrelation function
for the within-group residuals from an <code>lme</code> fit. The
autocorrelation values are calculated using pairs of residuals within
the innermost group level. The autocorrelation function is  useful for
investigating serial correlation models for equally spaced data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
ACF(object, maxLag, resType, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ACF.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="ACF.lme_+3A_maxlag">maxLag</code></td>
<td>
<p>an optional integer giving the maximum lag for which the
autocorrelation should be calculated. Defaults to maximum lag in the
within-group residuals.</p>
</td></tr>  
<tr><td><code id="ACF.lme_+3A_restype">resType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used. If <code>"response"</code>, the &quot;raw&quot; residuals
(observed - fitted) are used; else, if <code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided. Defaults to <code>"pearson"</code>.</p>
</td></tr> 
<tr><td><code id="ACF.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments &ndash; not used.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>lag</code> and <code>ACF</code> representing,
respectively, the lag between residuals within a pair and the corresponding
empirical autocorrelation. The returned value inherits from class
<code>ACF</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACF.gls">ACF.gls</a></code>, <code><a href="#topic+plot.ACF">plot.ACF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time),
           Ovary, random = ~ sin(2*pi*Time) | Mare)
ACF(fm1, maxLag = 11)

# Pinheiro and Bates, p240-241
fm1Over.lme &lt;- lme(follicles  ~ sin(2*pi*Time) +
           cos(2*pi*Time), data=Ovary,
     random=pdDiag(~sin(2*pi*Time)) )
(ACF.fm1Over &lt;- ACF(fm1Over.lme, maxLag=10))
plot(ACF.fm1Over, alpha=0.01) 
</code></pre>

<hr>
<h2 id='Alfalfa'>Split-Plot Experiment on Varieties of Alfalfa</h2><span id='topic+Alfalfa'></span>

<h3>Description</h3>

<p>The <code>Alfalfa</code> data frame has 72 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Variety</dt><dd>
<p>a factor with levels
<code>Cossack</code>,
<code>Ladak</code>, and 
<code>Ranger</code> 
</p>
</dd>
<dt>Date</dt><dd>
<p>a factor with levels
<code>None</code> 
<code>S1</code> 
<code>S20</code> 
<code>O7</code> 
</p>
</dd>
<dt>Block</dt><dd>
<p>a factor with levels
<code>1</code> 
<code>2</code> 
<code>3</code> 
<code>4</code> 
<code>5</code> 
<code>6</code> 
</p>
</dd>
<dt>Yield</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are described in Snedecor and Cochran (1980) as
an example of a split-plot design. The treatment structure used in the
experiment was a 3<code class="reqn"> x </code>4 full factorial, with three varieties of
alfalfa and four dates of third cutting in 1943. The experimental
units were arranged into six blocks, each subdivided into four plots.
The varieties of alfalfa (<em>Cossac</em>, <em>Ladak</em>, and
<em>Ranger</em>) were assigned randomly to the blocks and the dates of
third cutting (<em>None</em>, <em>S1</em>&mdash;September 1,
<em>S20</em>&mdash;September 20, and <em>O7</em>&mdash;October 7) were randomly
assigned to the plots.  All four dates were used on each block.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.1)
</p>
<p>Snedecor, G. W. and Cochran, W. G. (1980), <em>Statistical Methods (7th
ed)</em>, Iowa State University Press, Ames, IA
</p>

<hr>
<h2 id='allCoef'>Extract Coefficients from a Set of Objects</h2><span id='topic+allCoef'></span>

<h3>Description</h3>

<p>The extractor function is applied to each object in <code>...</code>, with
the result being converted to a vector. A <code>map</code> attribute is
included to indicate which pieces of the returned vector correspond to
the original objects in <code>dots</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allCoef(..., extract)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allCoef_+3A_...">...</code></td>
<td>
<p>objects to which <code>extract</code> will be applied. Generally
these will be model components, such as <code>corStruct</code> and
<code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="allCoef_+3A_extract">extract</code></td>
<td>
<p>an optional extractor function. Defaults to <code>coef</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with all elements, generally coefficients, obtained by
applying <code>extract</code> to the objects in <code>...</code>. 
</p>


<h3>Author(s)</h3>

<p>José' Pinheiro and Douglas Bates</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmeStruct">lmeStruct</a></code>,<code><a href="#topic+nlmeStruct">nlmeStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(0.1)
vf1 &lt;- varPower(0.5)
allCoef(cs1, vf1)
</code></pre>

<hr>
<h2 id='anova.gls'>Compare Likelihoods of Fitted Objects</h2><span id='topic+anova.gls'></span>

<h3>Description</h3>

<p>When only one fitted model object is present, a data frame with the
numerator degrees of freedom, F-values, and P-values
for Wald tests for the terms in the model (when <code>Terms</code> and
<code>L</code> are <code>NULL</code>), a combination of model terms (when
<code>Terms</code> in not <code>NULL</code>), or linear combinations of the model
coefficients (when <code>L</code> is not <code>NULL</code>). Otherwise, when
multiple fitted objects are being compared, a data frame with
the degrees of freedom, the (restricted) log-likelihood, the 
Akaike Information Criterion (AIC), and the Bayesian Information
Criterion (BIC) of each object is returned. If <code>test=TRUE</code>,
whenever two consecutive  objects have different number of degrees of
freedom, a likelihood ratio statistic with the associated p-value is
included in the returned data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
anova(object, ..., test, type, adjustSigma, Terms, L, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>,
representing a generalized least squares fit.</p>
</td></tr>
<tr><td><code id="anova.gls_+3A_...">...</code></td>
<td>
<p>other optional fitted model objects inheriting from
classes <code>"gls"</code>, <code>"gnls"</code>, <code>"lm"</code>, <code>"lme"</code>,
<code>"lmList"</code>, <code>"nlme"</code>, <code>"nlsList"</code>, or <code>"nls"</code>.</p>
</td></tr>
<tr><td><code id="anova.gls_+3A_test">test</code></td>
<td>
<p>an optional logical value controlling whether likelihood
ratio tests should be used to compare the fitted models represented
by <code>object</code> and the objects in <code>...</code>. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anova.gls_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of sum of
squares to be used in F-tests for the terms in the model. If 
<code>"sequential"</code>, the sequential sum of squares obtained by
including the terms in the order they appear in the model is used;
else, if <code>"marginal"</code>, the marginal sum of squares
obtained by deleting a term from the model at a time is used. This
argument is only used when a single fitted object is passed to the
function. Partial matching of arguments is used, so only the first
character needs to be provided. Defaults to <code>"sequential"</code>.</p>
</td></tr>
<tr><td><code id="anova.gls_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> and the
estimation method used to obtain <code>object</code> was maximum
likelihood, the residual standard error is multiplied by
<code class="reqn">\sqrt{n_{obs}/(n_{obs} - n_{par})}</code>,
converting it to a REML-like estimate. This argument is only used
when a single fitted object is passed to the function. Default is
<code>TRUE</code>.</p>
</td></tr> 
<tr><td><code id="anova.gls_+3A_terms">Terms</code></td>
<td>
<p>an optional integer or character vector specifying which
terms in the model should be jointly tested to be zero using a Wald
F-test. If given as a character vector, its elements must correspond
to term names; else, if given as an integer vector, its elements must
correspond to the order in which terms are included in the
model. This argument is only used when a single fitted object is
passed to the function. Default is <code>NULL</code>.</p>
</td></tr> 
<tr><td><code id="anova.gls_+3A_l">L</code></td>
<td>
<p>an optional numeric vector or array specifying linear
combinations of the coefficients in the model that should be tested
to be zero. If given as an array, its rows define the linear
combinations to be tested. If names are assigned to the vector
elements (array columns), they must correspond to coefficients
names and will be used to map the linear combination(s) to the
coefficients; else, if no names are available, the vector elements
(array columns) are assumed in the same order as the coefficients
appear in the model. This argument is only used when a single fitted
object is passed to the function. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="anova.gls_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the calling
sequences for each fitted model object are printed with the rest of
the output, being omitted if <code>verbose = FALSE</code>. Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame inheriting from class <code>"anova.lme"</code>.
</p>


<h3>Note</h3>

<p>Likelihood comparisons are not meaningful for objects fit using
restricted maximum likelihood and with different fixed effects.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+gnls">gnls</a></code>, <code><a href="#topic+nlme">nlme</a></code>,
<code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+logLik.gls">logLik.gls</a></code>,
<code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>,
<code><a href="#topic+print.anova.lme">print.anova.lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR(1) errors within each Mare
fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
anova(fm1)
# variance changes with a power of the absolute fitted values?
fm2 &lt;- update(fm1, weights = varPower())
anova(fm1, fm2)

# Pinheiro and Bates, p. 251-252
fm1Orth.gls &lt;- gls(distance ~ Sex * I(age - 11), Orthodont,
                correlation = corSymm(form = ~ 1 | Subject),
                weights = varIdent(form = ~ 1 | age))
fm2Orth.gls &lt;- update(fm1Orth.gls,
                corr = corCompSymm(form = ~ 1 | Subject))
anova(fm1Orth.gls, fm2Orth.gls)

# Pinheiro and Bates, pp. 215-215, 255-260
#p. 215
fm1Dial.lme &lt;-
  lme(rate ~(pressure + I(pressure^2) + I(pressure^3) + I(pressure^4))*QB,
      Dialyzer, ~ pressure + I(pressure^2))
# p. 216
fm2Dial.lme &lt;- update(fm1Dial.lme,
                  weights = varPower(form = ~ pressure))
# p. 255
fm1Dial.gls &lt;- gls(rate ~ (pressure +
     I(pressure^2) + I(pressure^3) + I(pressure^4))*QB,
        Dialyzer)
fm2Dial.gls &lt;- update(fm1Dial.gls,
                 weights = varPower(form = ~ pressure))
anova(fm1Dial.gls, fm2Dial.gls)
fm3Dial.gls &lt;- update(fm2Dial.gls,
                    corr = corAR1(0.771, form = ~ 1 | Subject))
anova(fm2Dial.gls, fm3Dial.gls)
# anova.gls to compare a gls and an lme fit 
anova(fm3Dial.gls, fm2Dial.lme, test = FALSE)

# Pinheiro and Bates, pp. 261-266
fm1Wheat2 &lt;- gls(yield ~ variety - 1, Wheat2)
fm3Wheat2 &lt;- update(fm1Wheat2,
      corr = corRatio(c(12.5, 0.2),
        form = ~ latitude + longitude, nugget = TRUE))
# Test a specific contrast 
anova(fm3Wheat2, L = c(-1, 0, 1))

</code></pre>

<hr>
<h2 id='anova.lme'>Compare Likelihoods of Fitted Objects</h2><span id='topic+anova.lme'></span><span id='topic+print.anova.lme'></span>

<h3>Description</h3>

<p>When only one fitted model object is present, a data frame with the
numerator degrees of freedom, denominator degrees of
freedom, F-values, and P-values for Wald tests for the terms in the
model (when <code>Terms</code> and <code>L</code> are <code>NULL</code>), a combination
of model terms (when <code>Terms</code> in not <code>NULL</code>), or linear
combinations of the model coefficients (when <code>L</code> is not
<code>NULL</code>).  Otherwise, when multiple fitted objects are being
compared, a data frame with the degrees of freedom, the (restricted)
log-likelihood, the Akaike Information Criterion (AIC), and the
Bayesian Information Criterion (BIC) of each object is returned.  If
<code>test=TRUE</code>, whenever two consecutive  objects have different
number of degrees of freedom, a likelihood ratio statistic with the
associated p-value is included in the returned data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
anova(object, ..., test, type, adjustSigma, Terms, L, verbose)
## S3 method for class 'anova.lme'
print(x, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>,
representing a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_...">...</code></td>
<td>
<p>other optional fitted model objects inheriting from
classes <code>"gls"</code>, <code>"gnls"</code>, <code>"lm"</code>, <code>"lme"</code>,
<code>"lmList"</code>, <code>"nlme"</code>, <code>"nlsList"</code>, or <code>"nls"</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_test">test</code></td>
<td>
<p>an optional logical value controlling whether likelihood
ratio tests should be used to compare the fitted models represented
by <code>object</code> and the objects in <code>...</code>.  Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of sum of
squares to be used in F-tests for the terms in the model.  If
<code>"sequential"</code>, the sequential sum of squares obtained by
including the terms in the order they appear in the model is used;
else, if <code>"marginal"</code>, the marginal sum of squares
obtained by deleting a term from the model at a time is used.  This
argument is only used when a single fitted object is passed to the
function.  Partial matching of arguments is used, so only the first
character needs to be provided.  Defaults to <code>"sequential"</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> and the
estimation method used to obtain <code>object</code> was maximum
likelihood, the residual standard error is multiplied by
<code class="reqn">\sqrt{n_{obs}/(n_{obs} - n_{par})}</code>,
converting it to a REML-like estimate.  This argument is only used
when a single fitted object is passed to the function.  Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_terms">Terms</code></td>
<td>
<p>an optional integer or character vector specifying which
terms in the model should be jointly tested to be zero using a Wald
F-test.  If given as a character vector, its elements must correspond
to term names; else, if given as an integer vector, its elements must
correspond to the order in which terms are included in the
model.  This argument is only used when a single fitted object is
passed to the function.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_l">L</code></td>
<td>
<p>an optional numeric vector or array specifying linear
combinations of the coefficients in the model that should be tested
to be zero.  If given as an array, its rows define the linear
combinations to be tested.  If names are assigned to the vector
elements (array columns), they must correspond to coefficients
names and will be used to map the linear combination(s) to the
coefficients; else, if no names are available, the vector elements
(array columns) are assumed in the same order as the coefficients
appear in the model.  This argument is only used when a single fitted
object is passed to the function.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="anova.lme_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"anova.lme"</code></p>
</td></tr>
<tr><td><code id="anova.lme_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code>, the calling
sequences for each fitted model object are printed with the rest of
the output, being omitted if <code>verbose = FALSE</code>.  Defaults to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame inheriting from class <code>"anova.lme"</code>.
</p>


<h3>Note</h3>

<p>Likelihood comparisons are not meaningful for objects fit using
restricted maximum likelihood and with different fixed effects.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+gnls">gnls</a></code>, <code><a href="#topic+nlme">nlme</a></code>,
<code><a href="#topic+lme">lme</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>,
<code><a href="#topic+print.anova.lme">print.anova.lme</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
anova(fm1)
fm2 &lt;- update(fm1, random = pdDiag(~age))
anova(fm1, fm2)

## Pinheiro and Bates, pp. 251-254 ------------------------------------------
fm1Orth.gls &lt;- gls(distance ~ Sex * I(age - 11), Orthodont,
		   correlation = corSymm(form = ~ 1 | Subject),
		   weights = varIdent(form = ~ 1 | age))
fm2Orth.gls &lt;- update(fm1Orth.gls,
		      corr = corCompSymm(form = ~ 1 | Subject))
## anova.gls examples:
anova(fm1Orth.gls, fm2Orth.gls)
fm3Orth.gls &lt;- update(fm2Orth.gls, weights = NULL)
anova(fm2Orth.gls, fm3Orth.gls)
fm4Orth.gls &lt;- update(fm3Orth.gls, weights = varIdent(form = ~ 1 | Sex))
anova(fm3Orth.gls, fm4Orth.gls)
# not in book but needed for the following command
fm3Orth.lme &lt;- lme(distance ~ Sex*I(age-11), data = Orthodont,
                   random = ~ I(age-11) | Subject,
                   weights = varIdent(form = ~ 1 | Sex))
# Compare an "lme" object with a "gls" object (test would be non-sensical!)
anova(fm3Orth.lme, fm4Orth.gls, test = FALSE)

## Pinheiro and Bates, pp. 222-225 ------------------------------------------
op &lt;- options(contrasts = c("contr.treatment", "contr.poly"))
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight, random = ~ Time)
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# Test a specific contrast
anova(fm2BW.lme, L = c("Time:Diet2" = 1, "Time:Diet3" = -1))

## Pinheiro and Bates, pp. 352-365 ------------------------------------------
fm1Theo.lis &lt;- nlsList(
     conc ~ SSfol(Dose, Time, lKe, lKa, lCl), data=Theoph)
fm1Theo.lis
fm1Theo.nlme &lt;- nlme(fm1Theo.lis)
fm2Theo.nlme &lt;- update(fm1Theo.nlme, random= pdDiag(lKe+lKa+lCl~1) )
fm3Theo.nlme &lt;- update(fm2Theo.nlme, random= pdDiag(    lKa+lCl~1) )

# Comparing the 3 nlme models
anova(fm1Theo.nlme, fm3Theo.nlme, fm2Theo.nlme)

options(op) # (set back to previous state)
</code></pre>

<hr>
<h2 id='as.matrix.corStruct'>Matrix of a corStruct Object</h2><span id='topic+as.matrix.corStruct'></span>

<h3>Description</h3>

<p>This method function extracts the correlation matrix, or list of
correlation matrices, associated with <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.corStruct_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="as.matrix.corStruct_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the correlation structure includes a grouping factor, the returned
value will be a list with components given by the correlation
matrices for each group. Otherwise, the returned value will be a
matrix representing the correlation structure associated with
<code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>, <code><a href="#topic+corMatrix">corMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cst1 &lt;- corAR1(form = ~1|Subject)
cst1 &lt;- Initialize(cst1, data = Orthodont)
as.matrix(cst1)
</code></pre>

<hr>
<h2 id='as.matrix.pdMat'>Matrix of a pdMat Object</h2><span id='topic+as.matrix.pdMat'></span>

<h3>Description</h3>

<p>This method function extracts the positive-definite matrix represented
by <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.pdMat_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
representing a positive-definite matrix.</p>
</td></tr>
<tr><td><code id="as.matrix.pdMat_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix corresponding to the positive-definite matrix represented by
<code>x</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code>, <code><a href="#topic+corMatrix">corMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(pdSymm(diag(4)))
</code></pre>

<hr>
<h2 id='as.matrix.reStruct'>Matrices of an reStruct Object</h2><span id='topic+as.matrix.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts the positive-definite matrices
corresponding to the <code>pdMat</code> elements of <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.reStruct_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>, representing
a random effects structure and consisting of a list of <code>pdMat</code>
objects.</p>
</td></tr>
<tr><td><code id="as.matrix.reStruct_+3A_...">...</code></td>
<td>
<p>further arguments passed from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components given by the positive-definite matrices
corresponding to the elements of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>, <code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(pdSymm(diag(3), ~age+Sex, data = Orthodont))
as.matrix(rs1)
</code></pre>

<hr>
<h2 id='asOneFormula'>Combine Formulas of a Set of Objects</h2><span id='topic+asOneFormula'></span>

<h3>Description</h3>

<p>The names of all variables used in the formulas extracted from the
objects defined in <code>...</code> are converted into a single linear
formula, with the variables names separated by <code>+</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asOneFormula(..., omit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asOneFormula_+3A_...">...</code></td>
<td>
<p>objects, or lists of objects, from which a formula can be
extracted.</p>
</td></tr>
<tr><td><code id="asOneFormula_+3A_omit">omit</code></td>
<td>
<p>an optional character vector with the names of variables to
be omitted from the returned formula. Defaults to c(&quot;.&quot;, &quot;pi&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-sided linear formula with all variables named in the formulas
extracted from the objects in <code>...</code>, except the ones listed in
<code>omit</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="base.html#topic+all.vars">all.vars</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asOneFormula(y ~ x + z | g, list(~ w, ~ t * sin(2 * pi)))
</code></pre>

<hr>
<h2 id='Assay'>Bioassay on Cell Culture Plate</h2><span id='topic+Assay'></span>

<h3>Description</h3>

<p>The <code>Assay</code> data frame has 60 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Block</dt><dd>
<p>an ordered factor with levels
<code>2</code> &lt; <code>1</code> identifying the block where the wells
are measured.
</p>
</dd>
<dt>sample</dt><dd>
<p>a factor with levels <code>a</code> to <code>f</code> identifying the
sample corresponding to the well.
</p>
</dd>
<dt>dilut</dt><dd>
<p>a factor with levels
<code>1</code> to <code>5</code>
indicating the dilution applied to the well
</p>
</dd>
<dt>logDens</dt><dd>
<p>a numeric vector of the log-optical density
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data, courtesy of Rich Wolfe and David Lansky from Searle,
Inc., come from a bioassay run on a 96-well cell culture plate.  The
assay is performed using a split-block design.  The 8 rows on the
plate are labeled A&ndash;H from top to bottom and the 12 columns on the
plate are labeled 1&ndash;12 from left to right.  Only the central 60 wells
of the plate are used for the bioassay (the intersection of rows B&ndash;G
and columns 2&ndash;11).  There are two blocks in the design: Block 1
contains columns 2&ndash;6 and Block 2 contains columns 7&ndash;11. Within each
block, six samples are assigned randomly to rows and five (serial)
dilutions are assigned randomly to columns. The response variable is
the logarithm of the optical density. The cells are treated with a
compound that they metabolize to produce the stain.  Only live cells
can make the stain, so the optical density is a measure of the number
of cells that are alive and healthy.</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York. (Appendix A.2)
</p>

<hr>
<h2 id='asTable'>Convert groupedData to a matrix</h2><span id='topic+asTable'></span><span id='topic+asTable.groupedData'></span>

<h3>Description</h3>

<p>Create a tabular representation of the response in a balanced
groupedData object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asTable(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asTable_+3A_object">object</code></td>
<td>
<p>A balanced <code>groupedData</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A balanced groupedData object can be represented as a matrix or table
of response values corresponding to the values of a primary covariate
for each level of a grouping factor.  This function creates such a
matrix representation of the data in <code>object</code>.
</p>


<h3>Value</h3>

<p>A matrix.  The data in the matrix are the values of the response.  The
columns correspond to the distinct values of the primary covariate and
are labelled as such.  The rows correspond to the distinct levels of
the grouping factor and are labelled as such.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="#topic+isBalanced">isBalanced</a></code>,
<code><a href="#topic+balancedGrouped">balancedGrouped</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>asTable(Orthodont)

# Pinheiro and Bates, p. 109
ergoStool.mat &lt;- asTable(ergoStool)
</code></pre>

<hr>
<h2 id='augPred'>Augmented Predictions</h2><span id='topic+augPred'></span><span id='topic+augPred.gls'></span><span id='topic+augPred.lme'></span><span id='topic+augPred.lmList'></span>

<h3>Description</h3>

<p>Predicted values are obtained at the specified values of
<code>primary</code>.  If <code>object</code> has a grouping structure
(i.e. <code>getGroups(object)</code> is not <code>NULL</code>), predicted values
are obtained for each group.  If <code>level</code> has more than one
element, predictions are obtained for each level of the
<code>max(level)</code> grouping factor.  If other covariates besides
<code>primary</code> are used in the prediction model, their average
(numeric covariates) or most frequent value (categorical covariates)
are used to obtain the predicted values.  The original observations
are also included in the returned object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augPred(object, primary, minimum, maximum, length.out, ...)

## S3 method for class 'lme'
augPred(object, primary = NULL,
        minimum = min(primary), maximum = max(primary),
        length.out = 51, level = Q, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augPred_+3A_object">object</code></td>
<td>
<p>a fitted model object from which predictions can be
extracted, using a <code>predict</code> method.</p>
</td></tr>
<tr><td><code id="augPred_+3A_primary">primary</code></td>
<td>
<p>an optional one-sided formula specifying the primary
covariate to be used to generate the augmented predictions. By
default, if a  covariate can be extracted from the data used to generate
<code>object</code> (using <code>getCovariate</code>), it will be used as
<code>primary</code>.</p>
</td></tr>
<tr><td><code id="augPred_+3A_minimum">minimum</code></td>
<td>
<p>an optional lower limit for the primary
covariate. Defaults to <code>min(primary)</code>.</p>
</td></tr>
<tr><td><code id="augPred_+3A_maximum">maximum</code></td>
<td>
<p>an optional upper limit for the primary
covariate. Defaults to <code>max(primary)</code>.</p>
</td></tr>
<tr><td><code id="augPred_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer with the number of primary
covariate values at which to evaluate the predictions.  Defaults to
51.</p>
</td></tr>
<tr><td><code id="augPred_+3A_level">level</code></td>
<td>
<p>an optional integer vector specifying the desired
prediction levels.  Levels increase from outermost to innermost
grouping, with level 0 representing the population (fixed effects)
predictions.  Defaults to the innermost level.</p>
</td></tr>
<tr><td><code id="augPred_+3A_...">...</code></td>
<td>
<p>some methods for the generic may require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with four columns representing, respectively, the values
of the primary covariate, the groups (if <code>object</code> does not have a
grouping structure, all elements will be <code>1</code>), the predicted or
observed values, and the type of value in the third column:
<code>original</code> for the observed values and <code>predicted</code> (single
or no grouping factor) or <code>predict.groupVar</code> (multiple levels of
grouping), with <code>groupVar</code> replaced by the actual grouping
variable name (<code>fixed</code> is used for population predictions). The
returned object inherits from class <code>"augPred"</code>.
</p>


<h3>Note</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>gls</code>, <code>lme</code>, and <code>lmList</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.augPred">plot.augPred</a></code>, <code><a href="#topic+getGroups">getGroups</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(Orthodont, random = ~1)
augPred(fm1, length.out = 2, level = c(0,1))
</code></pre>

<hr>
<h2 id='balancedGrouped'>Create a groupedData object from a matrix</h2><span id='topic+balancedGrouped'></span>

<h3>Description</h3>

<p>Create a <code>groupedData</code> object from a data matrix.  This function
can be used only with balanced data.  The opposite conversion, from a
<code>groupedData</code> object to a <code>matrix</code>, is done with <code>asTable</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancedGrouped(form, data, labels=NULL, units=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancedGrouped_+3A_form">form</code></td>
<td>
<p>A formula of the form <code>y ~ x | g</code> giving the name of
the response, the primary covariate, and the grouping factor.</p>
</td></tr>
<tr><td><code id="balancedGrouped_+3A_data">data</code></td>
<td>
<p>A matrix or data frame containing the values of the
response grouped according to the levels of the grouping factor
(rows) and the distinct levels of the primary covariate (columns).
The <code>dimnames</code> of the matrix are used to construct the levels of
the grouping factor and the primary covariate.</p>
</td></tr>
<tr><td><code id="balancedGrouped_+3A_labels">labels</code></td>
<td>
<p>an optional list of character strings giving labels for
the response and the primary covariate.  The label for the primary
covariate is named <code>x</code> and that for the response is named
<code>y</code>.  Either label can be omitted.</p>
</td></tr>
<tr><td><code id="balancedGrouped_+3A_units">units</code></td>
<td>
<p>an optional list of character strings giving the units for
the response and the primary covariate.  The units string for the
primary covariate is named <code>x</code> and that for the response is
named <code>y</code>.  Either units string can be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A balanced <code>groupedData</code> object.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="#topic+isBalanced">isBalanced</a></code>, <code><a href="#topic+asTable">asTable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>OrthoMat &lt;- asTable( Orthodont )
Orth2 &lt;- balancedGrouped(distance ~ age | Subject, data = OrthoMat,
    labels = list(x = "Age",
                  y = "Distance from pituitary to pterygomaxillary fissure"),
    units = list(x = "(yr)", y = "(mm)"))
Orth2[ 1:10, ]        ## check the first few entries

# Pinheiro and Bates, p. 109
ergoStool.mat &lt;- asTable(ergoStool)
balancedGrouped(effort~Type|Subject,
                data=ergoStool.mat)
</code></pre>

<hr>
<h2 id='bdf'>Language scores</h2><span id='topic+bdf'></span>

<h3>Description</h3>

<p>The <code>bdf</code> data frame has 2287 rows and 25 columns of language
scores from grade 8 pupils in elementary schools in The Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bdf)</code></pre>


<h3>Format</h3>


<dl>
<dt>schoolNR</dt><dd><p>a factor denoting the school.</p>
</dd>
<dt>pupilNR</dt><dd><p>a factor denoting the pupil.</p>
</dd>
<dt>IQ.verb</dt><dd><p>a numeric vector of verbal IQ scores</p>
</dd>
<dt>IQ.perf</dt><dd><p>a numeric vector of IQ scores.</p>
</dd>
<dt>sex</dt><dd><p>Sex of the student.</p>
</dd>
<dt>Minority</dt><dd><p>a factor indicating if the student is a member of a
minority group.</p>
</dd>
<dt>repeatgr</dt><dd><p>an ordered factor indicating if one or more grades
have been repeated.</p>
</dd>
<dt>aritPRET</dt><dd><p>a numeric vector</p>
</dd>
<dt>classNR</dt><dd><p>a numeric vector</p>
</dd>
<dt>aritPOST</dt><dd><p>a numeric vector</p>
</dd>
<dt>langPRET</dt><dd><p>a numeric vector</p>
</dd>
<dt>langPOST</dt><dd><p>a numeric vector</p>
</dd>
<dt>ses</dt><dd><p>a numeric vector of socioeconomic status indicators.</p>
</dd>
<dt>denomina</dt><dd><p>a factor indicating of the school is a public
school, a Protestant private school, a Catholic private school, or
a non-denominational private school.</p>
</dd>
<dt>schoolSES</dt><dd><p>a numeric vector</p>
</dd>
<dt>satiprin</dt><dd><p>a numeric vector</p>
</dd>
<dt>natitest</dt><dd><p>a factor with levels <code>0</code> and <code>1</code></p>
</dd>
<dt>meetings</dt><dd><p>a numeric vector</p>
</dd>
<dt>currmeet</dt><dd><p>a numeric vector</p>
</dd>
<dt>mixedgra</dt><dd><p>a factor indicating if the class is a mixed-grade class.</p>
</dd>
<dt>percmino</dt><dd><p>a numeric vector</p>
</dd>
<dt>aritdiff</dt><dd><p>a numeric vector</p>
</dd>
<dt>homework</dt><dd><p>a numeric vector</p>
</dd>
<dt>classsiz</dt><dd><p>a numeric vector</p>
</dd>
<dt>groupsiz</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lsquo;<span class="samp">&#8288;http://stat.gamma.rug.nl/snijders/multilevel.htm&#8288;</span>&rsquo;, the first
edition of <a href="http://www.stats.ox.ac.uk/~snijders/mlbook.htm">http://www.stats.ox.ac.uk/~snijders/mlbook.htm</a>.
</p>


<h3>References</h3>

<p>Snijders, Tom and Bosker, Roel (1999), <em>Multilevel Analysis: An
Introduction to Basic and Advanced Multilevel Modeling</em>, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(bdf)

## More examples, including lme() fits  reproducing parts in the above
## book, are available in the R script files
system.file("mlbook", "ch04.R", package ="nlme") # and
system.file("mlbook", "ch05.R", package ="nlme")
</code></pre>

<hr>
<h2 id='BodyWeight'>Rat weight over time for different diets</h2><span id='topic+BodyWeight'></span>

<h3>Description</h3>

<p>The <code>BodyWeight</code> data frame has 176 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>weight</dt><dd>
<p>a numeric vector giving the body weight of the rat (grams).
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector giving the time at which the measurement is
made (days).
</p>
</dd>
<dt>Rat</dt><dd>
<p>an ordered factor with levels <code>2</code> &lt; <code>3</code> &lt; <code>4</code>
&lt; <code>1</code> &lt; <code>8</code> &lt; <code>5</code> &lt; <code>6</code> &lt; <code>7</code> &lt;
<code>11</code> &lt; <code>9</code> &lt; <code>10</code> &lt; <code>12</code> &lt; <code>13</code> &lt;
<code>15</code> &lt; <code>14</code> &lt; <code>16</code> identifying the rat whose
weight is measured.
</p>
</dd>
<dt>Diet</dt><dd>
<p>a factor with levels
<code>1</code> to <code>3</code> indicating the diet that the rat receives.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hand and Crowder (1996) describe data on the body weights of rats
measured over 64 days.  These data also appear in Table 2.4 of
Crowder and Hand (1990).  The body weights of the rats (in grams)
are measured on day 1 and every seven days thereafter until day 64,
with an extra measurement on day 44. The experiment started several
weeks before &ldquo;day 1.&rdquo;  There are three groups of rats, each on a
different diet.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York. (Appendix A.3)
</p>
<p>Crowder, M. and Hand, D. (1990), <em>Analysis of Repeated
Measures</em>, Chapman and Hall, London.
</p>
<p>Hand, D. and Crowder, M. (1996), <em>Practical Longitudinal Data
Analysis</em>, Chapman and Hall, London.
</p>

<hr>
<h2 id='Cefamandole'>Pharmacokinetics of Cefamandole</h2><span id='topic+Cefamandole'></span>

<h3>Description</h3>

<p>The <code>Cefamandole</code> data frame has 84 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>a factor giving the subject from which the sample was drawn.
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector giving the time at which the sample was drawn
(minutes post-injection).
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the observed plasma concentration of
cefamandole (mcg/ml).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Davidian and Giltinan (1995, 1.1, p. 2) describe data
obtained during a pilot study to investigate the pharmacokinetics of
the drug cefamandole. Plasma concentrations of the drug were measured
on six healthy volunteers at 14 time points following an intraveneous
dose of 15 mg/kg body weight of cefamandole.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.4)
</p>
<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Cefamandole)
fm1 &lt;- nlsList(SSbiexp, data = Cefamandole)
summary(fm1)
</code></pre>

<hr>
<h2 id='Coef'>Assign Values to Coefficients</h2><span id='topic+coef+3C-'></span><span id='topic+coefficients+3C-'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include all <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
<code>"<a href="#topic+corStruct">corStruct</a>"</code> and <code>"<a href="#topic+varFunc">varFunc</a>"</code> classes,
<code>"<a href="#topic+reStruct">reStruct</a>"</code>, and <code>"modelStruct"</code>.
</p>
<p><code>coefficients&lt;-</code> is an <em>alias</em> for <code>coef&lt;-</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...) &lt;- value

coefficients(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coef_+3A_object">object</code></td>
<td>
<p>any object representing a fitted model, or, by default,
any object with a <code>coef</code> component.</p>
</td></tr>
<tr><td><code id="Coef_+3A_...">...</code></td>
<td>
<p>some methods for this generic function may require
additional arguments.</p>
</td></tr>
<tr><td><code id="Coef_+3A_value">value</code></td>
<td>
<p>a value to be assigned to the coefficients associated with
<code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code></p>

<hr>
<h2 id='coef.corStruct'>Coefficients of a corStruct Object</h2><span id='topic+coef.corStruct'></span><span id='topic+coef.corAR1'></span><span id='topic+coef.corARMAd'></span><span id='topic+coef.corCAR1'></span><span id='topic+coef.corCompSymm'></span><span id='topic+coef.corHF'></span><span id='topic+coef.corLin'></span><span id='topic+coef.corNatural'></span><span id='topic+coef.corSpatial'></span><span id='topic+coef.corSpher'></span><span id='topic+coef.corSymm'></span><span id='topic+coef+3C-.corStruct'></span><span id='topic+coef+3C-.corAR1'></span><span id='topic+coef+3C-.corARMA'></span><span id='topic+coef+3C-.corCAR1'></span><span id='topic+coef+3C-.corCompSymm'></span><span id='topic+coef+3C-.corNatural'></span><span id='topic+coef+3C-.corHF'></span><span id='topic+coef+3C-.corLin'></span><span id='topic+coef+3C-.corSpatial'></span><span id='topic+coef+3C-.corSpher'></span><span id='topic+coef+3C-.corSymm'></span><span id='topic+coef.summary.nlsList'></span>

<h3>Description</h3>

<p>This method function extracts the coefficients associated with the
correlation structure represented by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
coef(object, unconstrained, ...)
## S3 replacement method for class 'corStruct'
coef(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="coef.corStruct_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the coefficients
are returned in unconstrained form (the same used in the optimization
algorithm). If <code>FALSE</code> the coefficients are returned in
&quot;natural&quot;, possibly constrained, form. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.corStruct_+3A_value">value</code></td>
<td>
<p>a vector with the replacement values for the coefficients
associated with <code>object</code>. It must be a vector with the same length
of <code>coef{object}</code> and must be given in unconstrained form.</p>
</td></tr>
<tr><td><code id="coef.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the coefficients corresponding to <code>object</code>.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the values of the coefficients
of <code>object</code> to <code>value</code>. <code>Object</code> must be initialized (using
<code>Initialize</code>) before new values can be assigned to its
coefficients. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corAR1">corAR1</a></code>, <code><a href="#topic+corARMA">corARMA</a></code>,
<code><a href="#topic+corCAR1">corCAR1</a></code>, <code><a href="#topic+corCompSymm">corCompSymm</a></code>,
<code><a href="#topic+corExp">corExp</a></code>, <code><a href="#topic+corGaus">corGaus</a></code>, <code><a href="#topic+corLin">corLin</a></code>,
<code><a href="#topic+corRatio">corRatio</a></code>, <code><a href="#topic+corSpatial">corSpatial</a></code>, <code><a href="#topic+corSpher">corSpher</a></code>,
<code><a href="#topic+corSymm">corSymm</a></code>,<code><a href="#topic+Initialize">Initialize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cst1 &lt;- corARMA(p = 1, q = 1)
coef(cst1)
</code></pre>

<hr>
<h2 id='coef.gnls'>Extract gnls Coefficients</h2><span id='topic+coef.gnls'></span>

<h3>Description</h3>

<p>The estimated coefficients for the nonlinear model represented by
<code>object</code> are extracted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnls'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gnls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gnls">gnls</a>"</code>, representing
a generalized nonlinear least squares fitted model.</p>
</td></tr>
<tr><td><code id="coef.gnls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the estimated coefficients for the nonlinear model
represented by <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean,
            weights = varPower())
coef(fm1)
</code></pre>

<hr>
<h2 id='coef.lme'>Extract lme Coefficients</h2><span id='topic+coef.lme'></span>

<h3>Description</h3>

<p>The estimated coefficients at level <code class="reqn">i</code> are obtained by adding
together the fixed effects estimates and the corresponding random
effects estimates at grouping levels less or equal to <code class="reqn">i</code>. The
resulting estimates are returned as a data frame, with rows
corresponding to groups and columns to coefficients. Optionally, the
returned data frame may be augmented with covariates summarized over
groups.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
coef(object, augFrame, level, data, which, FUN, 
       omitGroupingFactor, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_augframe">augFrame</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
data frame is augmented with variables defined in <code>data</code>; else,
if <code>FALSE</code>, only the coefficients are returned. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_level">level</code></td>
<td>
<p>an optional positive integer giving the level of grouping
to be used in extracting the coefficients from an object with
multiple nested grouping levels. Defaults to the highest or innermost
level of grouping.</p>
</td></tr> 
<tr><td><code id="coef.lme_+3A_data">data</code></td>
<td>
<p>an optional data frame with the variables to be used for
augmenting the returned data frame when <code>augFrame =
     TRUE</code>. Defaults to the data frame used to fit <code>object</code>.</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_which">which</code></td>
<td>
<p>an optional positive integer or character vector
specifying which columns of <code>data</code> should be used in the
augmentation of the returned data frame. Defaults to all columns in
<code>data</code>.</p>
</td></tr> 
<tr><td><code id="coef.lme_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be applied to group-varying variables, when collapsing <code>data</code>
by groups.  Group-invariant variables are always summarized by the
unique value that they assume within that group. If <code>FUN</code> is a
single function it will be applied to each non-invariant variable by
group to produce the summary for that variable.  If <code>FUN</code> is a
list of functions, the names in the list should designate classes of
variables in the frame such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
group-varying variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_omitgroupingfactor">omitGroupingFactor</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code>
the grouping factor itself will be omitted from the group-wise
summary of <code>data</code> but the levels of the grouping factor will
continue to be used as the row names for the returned data frame.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_subset">subset</code></td>
<td>
<p>an optional expression specifying a subset</p>
</td></tr>
<tr><td><code id="coef.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame inheriting from class <code>"coef.lme"</code> with the estimated
coefficients at level <code>level</code> and, optionally, other covariates
summarized over groups. The returned object also inherits from classes
<code>"ranef.lme"</code> and <code>"data.frame"</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York, esp. pp. 455-457.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, 
<code><a href="#topic+ranef.lme">ranef.lme</a></code>,
<code><a href="#topic+plot.ranef.lme">plot.ranef.lme</a></code>, <code><a href="#topic+gsummary">gsummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
coef(fm1)
coef(fm1, augFrame = TRUE)
</code></pre>

<hr>
<h2 id='coef.lmList'>Extract lmList Coefficients</h2><span id='topic+coef.lmList'></span>

<h3>Description</h3>

<p>The coefficients of each <code>lm</code> object in the <code>object</code> list are
extracted and organized into a data frame, with rows corresponding to
the <code>lm</code> components and columns corresponding to the
coefficients.  Optionally, the returned data frame may be augmented
with covariates summarized over the groups associated with the
<code>lm</code> components.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
coef(object, augFrame, data, which, FUN,
   omitGroupingFactor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_augframe">augFrame</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
data frame is augmented with variables defined in the data frame used
to produce <code>object</code>; else, if <code>FALSE</code>, only the coefficients
are returned. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_data">data</code></td>
<td>
<p>an optional data frame with the variables to be used for
augmenting the returned data frame when <code>augFrame =
     TRUE</code>. Defaults to the data frame used to fit <code>object</code>.</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_which">which</code></td>
<td>
<p>an optional positive integer or character vector
specifying which columns of the data frame used to produce <code>object</code>
should be used in the augmentation of the returned data
frame. Defaults to all variables in the data.
</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be applied to group-varying variables, when collapsing the data
by groups.  Group-invariant variables are always summarized by the
unique value that they assume within that group. If <code>FUN</code> is a
single function it will be applied to each non-invariant variable by
group to produce the summary for that variable.  If <code>FUN</code> is a
list of functions, the names in the list should designate classes of
variables in the frame such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
group-varying variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.
</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_omitgroupingfactor">omitGroupingFactor</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code>
the grouping factor itself will be omitted from the group-wise
summary of <code>data</code> but the levels of the grouping factor will
continue to be used as the row names for the returned data frame.
Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="coef.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame inheriting from class <code>"coef.lmList"</code> with the estimated
coefficients for each <code>"lm"</code> component of <code>object</code> and,
optionally, other covariates summarized over the groups corresponding
to the <code>"lm"</code> components. The returned object also inherits from
classes <code>"ranef.lmList"</code> and <code>"data.frame"</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York, esp. pp. 457-458.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="#topic+fixed.effects.lmList">fixed.effects.lmList</a></code>,
<code><a href="#topic+ranef.lmList">ranef.lmList</a></code>,
<code><a href="#topic+plot.ranef.lmList">plot.ranef.lmList</a></code>, <code><a href="#topic+gsummary">gsummary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age|Subject, data = Orthodont)
coef(fm1)
coef(fm1, augFrame = TRUE)
</code></pre>

<hr>
<h2 id='coef.modelStruct'>Extract modelStruct Object Coefficients</h2><span id='topic+coef.modelStruct'></span><span id='topic+coef+3C-.modelStruct'></span>

<h3>Description</h3>

<p>This method function extracts the coefficients associated with each
component of the <code>modelStruct</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelStruct'
coef(object, unconstrained, ...)
## S3 replacement method for class 'modelStruct'
coef(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.modelStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"modelStruct"</code>,
representing a list of model components, such as <code>"<a href="#topic+corStruct">corStruct</a>"</code> and
<code>"<a href="#topic+varFunc">varFunc</a>"</code> objects.</p>
</td></tr>
<tr><td><code id="coef.modelStruct_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the coefficients
are returned in unconstrained form (the same used in the optimization
algorithm). If <code>FALSE</code> the coefficients are returned in
&quot;natural&quot;, possibly constrained, form. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.modelStruct_+3A_value">value</code></td>
<td>
<p>a vector with the replacement values for the coefficients
associated with <code>object</code>. It must be a vector with the same length
of <code>coef{object}</code> and must be given in unconstrained form.</p>
</td></tr>
<tr><td><code id="coef.modelStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with all coefficients corresponding to the components of
<code>object</code>.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the values of the coefficients
of <code>object</code> to <code>value</code>. <code>Object</code> must be initialized (using
<code>Initialize</code>) before new values can be assigned to its
coefficients. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize">Initialize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lms1 &lt;- lmeStruct(reStruct = reStruct(pdDiag(diag(2), ~age)),
   corStruct = corAR1(0.3))
coef(lms1)
</code></pre>

<hr>
<h2 id='coef.pdMat'>pdMat Object Coefficients</h2><span id='topic+coef.pdMat'></span><span id='topic+coef.pdBlocked'></span><span id='topic+coef.pdCompSymm'></span><span id='topic+coef.pdDiag'></span><span id='topic+coef.pdIdent'></span><span id='topic+coef.pdNatural'></span><span id='topic+coef.pdSymm'></span><span id='topic+coef+3C-.pdMat'></span><span id='topic+coef+3C-.pdBlocked'></span>

<h3>Description</h3>

<p>This method function extracts the coefficients associated with the
positive-definite matrix represented by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
coef(object, unconstrained, ...)
## S3 replacement method for class 'pdMat'
coef(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
representing a positive-definite matrix.</p>
</td></tr>
<tr><td><code id="coef.pdMat_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the coefficients
are returned in unconstrained form (the same used in the optimization
algorithm). If <code>FALSE</code> the upper triangular elements of the
positive-definite matrix represented by <code>object</code> are
returned. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.pdMat_+3A_value">value</code></td>
<td>
<p>a vector with the replacement values for the coefficients
associated with <code>object</code>. It must be a vector with the same length
of <code>coef{object}</code> and must be given in unconstrained form.</p>
</td></tr>
<tr><td><code id="coef.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the coefficients corresponding to <code>object</code>.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the values of the coefficients
of <code>object</code> to <code>value</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>References</h3>

<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained Parametrizations
for Variance-Covariance Matrices&quot;, Statistics and Computing, 6, 289-296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>coef(pdSymm(diag(3)))
</code></pre>

<hr>
<h2 id='coef.reStruct'>reStruct Object Coefficients</h2><span id='topic+coef.reStruct'></span><span id='topic+coef+3C-.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts the coefficients associated with the
positive-definite matrix represented by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
coef(object, unconstrained, ...)
## S3 replacement method for class 'reStruct'
coef(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="coef.reStruct_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the coefficients
are returned in unconstrained form (the same used in the optimization
algorithm). If <code>FALSE</code> the coefficients are returned in
&quot;natural&quot;, possibly constrained, form. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.reStruct_+3A_value">value</code></td>
<td>
<p>a vector with the replacement values for the coefficients
associated with <code>object</code>. It must be a vector with the same length
of <code>coef(object)</code> and must be given in unconstrained form.</p>
</td></tr>
<tr><td><code id="coef.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the coefficients corresponding to <code>object</code>.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the values of the coefficients
of <code>object</code> to <code>value</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.pdMat">coef.pdMat</a></code>, <code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(A = pdSymm(diag(1:3), form = ~Score),
  B = pdDiag(2 * diag(4), form = ~Educ)))
coef(rs1)
</code></pre>

<hr>
<h2 id='coef.varFunc'>varFunc Object Coefficients</h2><span id='topic+coef.varFunc'></span><span id='topic+coef.varComb'></span><span id='topic+coef.varConstPower'></span><span id='topic+coef.varConstProp'></span><span id='topic+coef.varExp'></span><span id='topic+coef.varFixed'></span><span id='topic+coef.varIdent'></span><span id='topic+coef.varPower'></span><span id='topic+coef+3C-.varComb'></span><span id='topic+coef+3C-.varConstPower'></span><span id='topic+coef+3C-.varConstProp'></span><span id='topic+coef+3C-.varExp'></span><span id='topic+coef+3C-.varFixed'></span><span id='topic+coef+3C-.varIdent'></span><span id='topic+coef+3C-.varPower'></span>

<h3>Description</h3>

<p>This method function extracts the coefficients associated with the
variance function structure represented by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
coef(object, unconstrained, allCoef, ...)
## S3 replacement method for class 'varIdent'
coef(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>
representing a variance function structure.</p>
</td></tr>
<tr><td><code id="coef.varFunc_+3A_unconstrained">unconstrained</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the coefficients
are returned in unconstrained form (the same used in the optimization
algorithm). If <code>FALSE</code> the coefficients are returned in
&quot;natural&quot;, generally constrained form. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.varFunc_+3A_allcoef">allCoef</code></td>
<td>
<p>a logical value. If <code>FALSE</code> only the coefficients
which may vary during the optimization are returned. If <code>TRUE</code>
all coefficients are returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef.varFunc_+3A_value">value</code></td>
<td>
<p>a vector with the replacement values for the coefficients
associated with <code>object</code>. It must be have the same length of
<code>coef{object}</code> and must be given in unconstrained
form. <code>Object</code> must be initialized before new values can be
assigned to its coefficients.</p>
</td></tr>
<tr><td><code id="coef.varFunc_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the coefficients corresponding to <code>object</code>.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the values of the coefficients
of <code>object</code> to <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>See Also</h3>

<p><code><a href="#topic+varFunc">varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(1)
coef(vf1)

coef(vf1) &lt;- 2

</code></pre>

<hr>
<h2 id='collapse'>Collapse According to Groups</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Currently, only a <code>groupedData</code>
method is available. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_object">object</code></td>
<td>
<p>an object to be collapsed, usually a data frame.</p>
</td></tr>
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>some methods for the generic may require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+collapse.groupedData">collapse.groupedData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='collapse.groupedData'>Collapse a groupedData Object</h2><span id='topic+collapse.groupedData'></span>

<h3>Description</h3>

<p>If <code>object</code> has a single grouping factor, it is returned
unchanged. Else, it is summarized by the values of the
<code>displayLevel</code> grouping factor (or the combination of its values
and the values of the covariate indicated in <code>preserve</code>, if any is
present). The collapsed data is used to produce a new
<code>groupedData</code> object, with grouping factor given by the
<code>displayLevel</code> factor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupedData'
collapse(object, collapseLevel, displayLevel,
       outer, inner, preserve, FUN, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse.groupedData_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>groupedData</code>,
generally with multiple grouping factors.
</p>
</td></tr>
<tr><td><code id="collapse.groupedData_+3A_collapselevel">collapseLevel</code></td>
<td>
<p>an optional positive integer or character string
indicating the grouping level to use when collapsing the data. Level
values increase from outermost to innermost grouping. Default is the
highest or innermost level of grouping.
</p>
</td></tr>
<tr><td><code id="collapse.groupedData_+3A_displaylevel">displayLevel</code></td>
<td>
<p>an optional positive integer or character string
indicating the grouping level to use as the grouping factor for the
collapsed data. Default is <code>collapseLevel</code>.
</p>
</td></tr>
<tr><td><code id="collapse.groupedData_+3A_outer">outer</code></td>
<td>
<p>an optional logical value or one-sided formula,
indicating covariates that are outer to the <code>displayLevel</code>
grouping factor. If equal to <code>TRUE</code>, the <code>displayLevel</code>
element <code>attr(object, "outer")</code> is used to indicate the 
outer covariates. An outer covariate is invariant within the sets
of rows defined by the grouping factor.  Ordering of the groups is
done in such a way as to preserve adjacency of groups with the same
value of the outer variables. Defaults to <code>NULL</code>, meaning that
no outer covariates are to be used.
</p>
</td></tr>  
<tr><td><code id="collapse.groupedData_+3A_inner">inner</code></td>
<td>
<p>an optional logical value or one-sided formula, indicating
a covariate that is inner to the <code>displayLevel</code> grouping
factor. If equal to <code>TRUE</code>, <code>attr(object, "outer")</code> is used
to indicate the inner covariate. An inner covariate can change within
the sets of rows defined by the grouping  factor. Defaults to
<code>NULL</code>, meaning that no inner covariate is present.  
</p>
</td></tr> 
<tr><td><code id="collapse.groupedData_+3A_preserve">preserve</code></td>
<td>
<p>an optional one-sided formula indicating a covariate
whose levels should be preserved when collapsing the data according
to the <code>collapseLevel</code> grouping factor. The collapsing factor is
obtained by pasting together the levels of the <code>collapseLevel</code>
grouping factor and the values of the covariate to be
preserved. Default is <code>NULL</code>, meaning that no covariates need to
be preserved.
</p>
</td></tr>
<tr><td><code id="collapse.groupedData_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be used for collapsing the data.  The function or functions are
applied only to variables in <code>object</code> that vary within the
groups defined by <code>collapseLevel</code>.  Invariant variables are 
always summarized by group using the unique value that they assume
within that group.  If <code>FUN</code> is a single
function it will be applied to each non-invariant variable by group
to produce the summary for that variable.  If <code>FUN</code> is a list of
functions, the names in the list should designate classes of
variables in the data such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
non-invariant variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.</p>
</td></tr>
<tr><td><code id="collapse.groupedData_+3A_subset">subset</code></td>
<td>
<p>an optional named list. Names can be either positive
integers representing grouping levels, or names of grouping
factors. Each element in the list is a vector indicating the levels
of the corresponding grouping factor to be preserved in the collapsed
data. Default is <code>NULL</code>, meaning that all levels are
used.
</p>
</td></tr> 
<tr><td><code id="collapse.groupedData_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>groupedData</code> object with a single grouping factor given by the
<code>displayLevel</code> grouping factor, resulting from collapsing
<code>object</code> over the levels of the <code>collapseLevel</code> grouping
factor. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="#topic+plot.nmGroupedData">plot.nmGroupedData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># collapsing by Dog
collapse(Pixel, collapse = 1)  # same as collapse(Pixel, collapse = "Dog")
</code></pre>

<hr>
<h2 id='compareFits'>Compare Fitted Objects</h2><span id='topic+compareFits'></span><span id='topic+print.compareFits'></span>

<h3>Description</h3>

<p>The columns in <code>object1</code> and <code>object2</code> are put together in
matrices which allow direct comparison of the individual elements for
each object. Missing columns in either object are replaced by
<code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareFits(object1, object2, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareFits_+3A_object1">object1</code>, <code id="compareFits_+3A_object2">object2</code></td>
<td>
<p>data frames, or matrices, with the same
row names, but possibly different column names. These will usually
correspond to coefficients from fitted objects with a grouping
structure (e.g. <code>lme</code> and <code>lmList</code> objects).</p>
</td></tr>
<tr><td><code id="compareFits_+3A_which">which</code></td>
<td>
<p>an optional integer or character vector indicating which
columns in <code>object1</code> and <code>object2</code> are to be used in the
returned object. Defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a three-dimensional array, with the third dimension given by the number
of unique column names in either <code>object1</code> or <code>object2</code>. To
each column name there corresponds a matrix with as many rows as the
rows in <code>object1</code> and two columns, corresponding to <code>object1</code>
and <code>object2</code>. The returned object inherits from class
<code>compareFits</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.compareFits">plot.compareFits</a></code>,
<code><a href="#topic+pairs.compareFits">pairs.compareFits</a></code>,
<code><a href="#topic+comparePred">comparePred</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="#topic+random.effects">random.effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- lmList(Orthodont)
fm2 &lt;- lme(fm1)
(cF12 &lt;- compareFits(coef(fm1), coef(fm2)))
</code></pre>

<hr>
<h2 id='comparePred'>Compare Predictions</h2><span id='topic+comparePred'></span><span id='topic+comparePred.gls'></span><span id='topic+comparePred.lme'></span><span id='topic+comparePred.lmList'></span>

<h3>Description</h3>

<p>Predicted values are obtained at the specified values of
<code>primary</code> for each object. If either <code>object1</code> or
<code>object2</code> have a grouping structure
(i.e. <code>getGroups(object)</code> is not <code>NULL</code>), predicted values
are obtained for each group. When both objects determine groups, the
group levels must be the same. If other covariates besides
<code>primary</code> are used in the prediction model, their group-wise averages
(numeric covariates) or most frequent values (categorical covariates)
are used to obtain the predicted values. The original observations are
also included in the returned object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePred(object1, object2, primary, minimum, maximum,
    length.out, level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePred_+3A_object1">object1</code>, <code id="comparePred_+3A_object2">object2</code></td>
<td>
<p>fitted model objects, from which predictions can
be extracted using the <code>predict</code> method.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_primary">primary</code></td>
<td>
<p>an optional one-sided formula specifying the primary
covariate to be used to generate the augmented predictions. By
default, if a  covariate can be extracted from the data used to generate
the objects (using <code>getCovariate</code>), it will be used as
<code>primary</code>.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_minimum">minimum</code></td>
<td>
<p>an optional lower limit for the primary
covariate. Defaults to <code>min(primary)</code>, after <code>primary</code> is 
evaluated in the <code>data</code> used in fitting <code>object1</code>.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_maximum">maximum</code></td>
<td>
<p>an optional upper limit for the primary
covariate. Defaults to <code>max(primary)</code>, after <code>primary</code> is
evaluated in the <code>data</code> used in fitting <code>object1</code>.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer with the number of primary
covariate values at which to evaluate the predictions. Defaults to
51.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_level">level</code></td>
<td>
<p>an optional integer specifying the desired
prediction level. Levels increase from outermost to innermost
grouping, with level 0 representing the population (fixed effects)
predictions. Only one level can be specified. Defaults to the
innermost level.</p>
</td></tr>
<tr><td><code id="comparePred_+3A_...">...</code></td>
<td>
<p>some methods for the generic may require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with four columns representing, respectively, the values
of the primary covariate, the groups (if <code>object</code> does not have a
grouping structure, all elements will be <code>1</code>), the predicted or
observed values, and the type of value in the third column: the
objects' names are used to classify the predicted values and
<code>original</code> is used for the observed values. The returned object
inherits from classes <code>comparePred</code> and <code>augPred</code>.
</p>


<h3>Note</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>gls</code>, <code>lme</code>, and <code>lmList</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+augPred">augPred</a></code>, <code><a href="#topic+getGroups">getGroups</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age * Sex, data = Orthodont, random = ~ age)
fm2 &lt;- update(fm1, distance ~ age)
comparePred(fm1, fm2, length.out = 2)
</code></pre>

<hr>
<h2 id='corAR1'>AR(1) Correlation Structure</h2><span id='topic+corAR1'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corAR1</code> class,
representing an autocorrelation structure of order 1. Objects
created using this constructor must later be initialized using the
appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corAR1(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corAR1_+3A_value">value</code></td>
<td>
<p>the value of the lag 1 autocorrelation, which must be
between -1 and 1. Defaults to 0 (no autocorrelation).</p>
</td></tr>
<tr><td><code id="corAR1_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. A covariate for this correlation structure
must be integer valued. When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>
<tr><td><code id="corAR1_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corAR1</code>, representing an autocorrelation
structure of order 1. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 235, 397.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ACF.lme">ACF.lme</a></code>,
<code><a href="#topic+corARMA">corARMA</a></code>, 
<code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+Dim.corSpatial">Dim.corSpatial</a></code>, 
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>, 
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## covariate is observation order and grouping factor is Mare
cs1 &lt;- corAR1(0.2, form = ~ 1 | Mare)

# Pinheiro and Bates, p. 236
cs1AR1 &lt;- corAR1(0.8, form = ~ 1 | Subject)
cs1AR1. &lt;- Initialize(cs1AR1, data = Orthodont)
corMatrix(cs1AR1.)

# Pinheiro and Bates, p. 240
fm1Ovar.lme &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time),
                   data = Ovary, random = pdDiag(~sin(2*pi*Time)))
fm2Ovar.lme &lt;- update(fm1Ovar.lme, correlation = corAR1())

# Pinheiro and Bates, pp. 255-258:  use in gls
fm1Dial.gls &lt;-
  gls(rate ~(pressure + I(pressure^2) + I(pressure^3) + I(pressure^4))*QB,
      Dialyzer)
fm2Dial.gls &lt;- update(fm1Dial.gls,
                 weights = varPower(form = ~ pressure))
fm3Dial.gls &lt;- update(fm2Dial.gls,
                    corr = corAR1(0.771, form = ~ 1 | Subject))

# Pinheiro and Bates use in nlme:  
# from p. 240 needed on p. 396
fm1Ovar.lme &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time),
                   data = Ovary, random = pdDiag(~sin(2*pi*Time)))
fm5Ovar.lme &lt;- update(fm1Ovar.lme,
                corr = corARMA(p = 1, q = 1))
# p. 396
fm1Ovar.nlme &lt;- nlme(follicles~
     A+B*sin(2*pi*w*Time)+C*cos(2*pi*w*Time),
   data=Ovary, fixed=A+B+C+w~1,
   random=pdDiag(A+B+w~1),
   start=c(fixef(fm5Ovar.lme), 1) )
# p. 397
fm2Ovar.nlme &lt;- update(fm1Ovar.nlme,
         corr=corAR1(0.311) )
</code></pre>

<hr>
<h2 id='corARMA'>ARMA(p,q) Correlation Structure</h2><span id='topic+corARMA'></span><span id='topic+coef.corARMA'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corARMA</code> class,
representing an autocorrelation-moving average correlation structure
of order (p, q). Objects created using this constructor must later
be initialized using the appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corARMA(value, form, p, q, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corARMA_+3A_value">value</code></td>
<td>
<p>a vector with the values of the autoregressive and moving
average parameters, which must have length <code>p + q</code> and all
elements between -1 and 1. Defaults to a vector of zeros,
corresponding to uncorrelated observations.</p>
</td></tr>
<tr><td><code id="corARMA_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. A covariate for this correlation structure
must be integer valued. When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>  
<tr><td><code id="corARMA_+3A_p">p</code>, <code id="corARMA_+3A_q">q</code></td>
<td>
<p>non-negative integers specifying respectively the
autoregressive order and the moving average order of the <code>ARMA</code>
structure. Both default to 0.</p>
</td></tr>
<tr><td><code id="corARMA_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corARMA</code>, representing an
autocorrelation-moving average correlation structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 236, 397.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corAR1">corAR1</a></code>,
<code><a href="#topic+corClasses">corClasses</a></code>
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ARMA(1,2) structure, with observation order as a covariate and
## Mare as grouping factor
cs1 &lt;- corARMA(c(0.2, 0.3, -0.1), form = ~ 1 | Mare, p = 1, q = 2)

# Pinheiro and Bates, p. 237 
cs1ARMA &lt;- corARMA(0.4, form = ~ 1 | Subject, q = 1)
cs1ARMA &lt;- Initialize(cs1ARMA, data = Orthodont)
corMatrix(cs1ARMA)

cs2ARMA &lt;- corARMA(c(0.8, 0.4), form = ~ 1 | Subject, p=1, q=1)
cs2ARMA &lt;- Initialize(cs2ARMA, data = Orthodont)
corMatrix(cs2ARMA)

# Pinheiro and Bates use in nlme:  
# from p. 240 needed on p. 396
fm1Ovar.lme &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time),
                   data = Ovary, random = pdDiag(~sin(2*pi*Time)))
fm5Ovar.lme &lt;- update(fm1Ovar.lme,
                corr = corARMA(p = 1, q = 1))
# p. 396
fm1Ovar.nlme &lt;- nlme(follicles~
     A+B*sin(2*pi*w*Time)+C*cos(2*pi*w*Time),
   data=Ovary, fixed=A+B+C+w~1,
   random=pdDiag(A+B+w~1),
   start=c(fixef(fm5Ovar.lme), 1) )
# p. 397
fm3Ovar.nlme &lt;- update(fm1Ovar.nlme,
         corr=corARMA(p=0, q=2) )
</code></pre>

<hr>
<h2 id='corCAR1'>Continuous AR(1) Correlation Structure</h2><span id='topic+corCAR1'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corCAR1</code> class,
representing an autocorrelation structure of order 1, with a
continuous time covariate. Objects created using this constructor must
be later initialized using the appropriate <code>Initialize</code>
method.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corCAR1(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corCAR1_+3A_value">value</code></td>
<td>
<p>the correlation between two observations one unit of time
apart. Must be between 0 and 1. Defaults to 0.2.</p>
</td></tr>
<tr><td><code id="corCAR1_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. Covariates for this correlation structure
need not be integer valued.  When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>  
<tr><td><code id="corCAR1_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corCAR1</code>, representing an autocorrelation
structure of order 1, with a continuous time covariate. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day.
</p>
<p>Jones, R.H. (1993) &quot;Longitudinal Data with Serial Correlation: A
State-space Approach&quot;, Chapman and Hall.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 236, 243.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>, 
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## covariate is Time and grouping factor is Mare
cs1 &lt;- corCAR1(0.2, form = ~ Time | Mare)

# Pinheiro and Bates, pp. 240, 243
fm1Ovar.lme &lt;- lme(follicles ~
           sin(2*pi*Time) + cos(2*pi*Time),
   data = Ovary, random = pdDiag(~sin(2*pi*Time)))
fm4Ovar.lme &lt;- update(fm1Ovar.lme,
          correlation = corCAR1(form = ~Time))

</code></pre>

<hr>
<h2 id='corClasses'>Correlation Structure Classes</h2><span id='topic+corClasses'></span><span id='topic+corStruct'></span>

<h3>Description</h3>

<p>Standard classes of correlation structures (<code>corStruct</code>)
available in the <code>nlme</code> package.
</p>


<h3>Value</h3>

<p>Available standard classes:
</p>
<table>
<tr><td><code>corAR1</code></td>
<td>
<p>autoregressive process of order 1.</p>
</td></tr>
<tr><td><code>corARMA</code></td>
<td>
<p>autoregressive moving average process, with arbitrary
orders for the autoregressive and moving average components.</p>
</td></tr>
<tr><td><code>corCAR1</code></td>
<td>
<p>continuous autoregressive process (AR(1) process for a
continuous time covariate).</p>
</td></tr>
<tr><td><code>corCompSymm</code></td>
<td>
<p>compound symmetry structure corresponding to a
constant correlation.</p>
</td></tr>
<tr><td><code>corExp</code></td>
<td>
<p>exponential spatial correlation.</p>
</td></tr>
<tr><td><code>corGaus</code></td>
<td>
<p>Gaussian spatial correlation.</p>
</td></tr>

<tr><td><code>corLin</code></td>
<td>
<p>linear spatial correlation.</p>
</td></tr>
<tr><td><code>corRatio</code></td>
<td>
<p>Rational quadratics spatial correlation.</p>
</td></tr>
<tr><td><code>corSpher</code></td>
<td>
<p>spherical spatial correlation.</p>
</td></tr>
<tr><td><code>corSymm</code></td>
<td>
<p>general correlation matrix, with no additional
structure.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Users may define their own <code>corStruct</code> classes by specifying a
<code>constructor</code> function and, at a minimum, methods for the
functions <code>corMatrix</code> and <code>coef</code>. For
examples of these functions, see the methods for classes <code>corSymm</code>
and <code>corAR1</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corAR1">corAR1</a></code>, <code><a href="#topic+corARMA">corARMA</a></code>,
<code><a href="#topic+corCAR1">corCAR1</a></code>, <code><a href="#topic+corCompSymm">corCompSymm</a></code>,
<code><a href="#topic+corExp">corExp</a></code>, <code><a href="#topic+corGaus">corGaus</a></code>,
<code><a href="#topic+corLin">corLin</a></code>,
<code><a href="#topic+corRatio">corRatio</a></code>, <code><a href="#topic+corSpher">corSpher</a></code>,
<code><a href="#topic+corSymm">corSymm</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code></p>

<hr>
<h2 id='corCompSymm'>Compound Symmetry Correlation Structure</h2><span id='topic+corCompSymm'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corCompSymm</code> class,
representing a compound symmetry structure corresponding to uniform
correlation. Objects created using this constructor must later be
initialized using the appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corCompSymm(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corCompSymm_+3A_value">value</code></td>
<td>
<p>the correlation between any two correlated
observations. Defaults to 0.</p>
</td></tr> 
<tr><td><code id="corCompSymm_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>  
<tr><td><code id="corCompSymm_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corCompSymm</code>, representing a compound
symmetry correlation structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Milliken, G. A. and Johnson, D. E. (1992) &quot;Analysis of Messy Data,
Volume I: Designed Experiments&quot;, Van Nostrand Reinhold.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 233-234.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>, 
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## covariate is observation order and grouping factor is Subject
cs1 &lt;- corCompSymm(0.5, form = ~ 1 | Subject)

# Pinheiro and Bates, pp. 222-225 
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p. 225
cs1CompSymm &lt;- corCompSymm(value = 0.3, form = ~ 1 | Subject)
cs2CompSymm &lt;- corCompSymm(value = 0.3, form = ~ age | Subject)
cs1CompSymm &lt;- Initialize(cs1CompSymm, data = Orthodont)
corMatrix(cs1CompSymm)

## Print/Summary methods for the empty case:
(cCS &lt;- corCompSymm()) # Uninitialized correlation struc..
summary(cCS)           #    (ditto)
</code></pre>

<hr>
<h2 id='corExp'>Exponential Correlation Structure</h2><span id='topic+corExp'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>"corExp"</code> class,
representing an exponential spatial correlation structure. Letting
<code class="reqn">d</code> denote the range and <code class="reqn">n</code> denote the nugget
effect, the correlation between two observations a distance
<code class="reqn">r</code> apart is <code class="reqn">\exp(-r/d)</code> when no nugget effect
is present and <code class="reqn">(1-n) \exp(-r/d)</code> when a nugget
effect is assumed. Objects created using this constructor must later be
initialized using the appropriate <code>Initialize</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corExp(value, form, nugget, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corExp_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
exponential correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corExp_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corExp_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corExp_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corExp_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"corExp"</code>, also inheriting from class
<code>"corSpatial"</code>, representing an exponential spatial correlation
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp;
Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 238.      
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corExp(form = ~ x + y + z)

# Pinheiro and Bates, p. 238
spatDat &lt;- data.frame(x = (0:4)/4, y = (0:4)/4)

cs1Exp &lt;- corExp(1, form = ~ x + y)
cs1Exp &lt;- Initialize(cs1Exp, spatDat)
corMatrix(cs1Exp)

cs2Exp &lt;- corExp(1, form = ~ x + y, metric = "man")
cs2Exp &lt;- Initialize(cs2Exp, spatDat)
corMatrix(cs2Exp)

cs3Exp &lt;- corExp(c(1, 0.2), form = ~ x + y,
                 nugget = TRUE)
cs3Exp &lt;- Initialize(cs3Exp, spatDat)
corMatrix(cs3Exp)

# example lme(..., corExp ...)
# Pinheiro and Bates, pp. 222-247
# p. 222
options(contrasts = c("contr.treatment", "contr.poly"))
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p. 246
fm3BW.lme &lt;- update(fm2BW.lme,
           correlation = corExp(form = ~ Time))
# p. 247
fm4BW.lme &lt;-
      update(fm3BW.lme, correlation = corExp(form =  ~ Time,
                        nugget = TRUE))
anova(fm3BW.lme, fm4BW.lme)

</code></pre>

<hr>
<h2 id='corFactor'>Factor of a Correlation Matrix</h2><span id='topic+corFactor'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include all <code>corStruct</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corFactor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corFactor_+3A_object">object</code></td>
<td>
<p>an object from which a correlation matrix can be
extracted.</p>
</td></tr>
<tr><td><code id="corFactor_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate
documentation. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corFactor.corStruct">corFactor.corStruct</a></code>,
<code><a href="#topic+recalc.corStruct">recalc.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='corFactor.corStruct'>Factor of a corStruct Object Matrix</h2><span id='topic+corFactor.corCompSymm'></span><span id='topic+corFactor.corAR1'></span><span id='topic+corFactor.corARMA'></span><span id='topic+corFactor.corCAR1'></span><span id='topic+corFactor.corNatural'></span><span id='topic+corFactor.corSpatial'></span><span id='topic+corFactor.corStruct'></span><span id='topic+corFactor.corSymm'></span>

<h3>Description</h3>

<p>This method function extracts a transpose inverse square-root factor,
or a series of transpose inverse square-root factors, of the
correlation matrix, or list of correlation matrices,  represented by
<code>object</code>. Letting <code class="reqn">\Sigma</code> denote a correlation
matrix, a square-root factor of <code class="reqn">\Sigma</code> is any square
matrix <code class="reqn">L</code> such that <code class="reqn">\Sigma = L'L</code>. This method
extracts <code class="reqn">L^{-t}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
corFactor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corFactor.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>
representing a correlation structure, which must have been
initialized (using <code>Initialize</code>).</p>
</td></tr>
<tr><td><code id="corFactor.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>If the correlation structure does not include a grouping factor, the
returned value will be a vector with a transpose inverse square-root
factor of the correlation matrix associated with <code>object</code> stacked
column-wise.  If the correlation structure includes a grouping factor,
the returned value will be a vector with transpose inverse
square-root factors of the correlation matrices for each group, stacked
by group and stacked column-wise within each group.  
</p>


<h3>Note</h3>

<p>This method function is used intensively in optimization
algorithms and its value is returned as a vector for efficiency
reasons. The <code>corMatrix</code> method function can be used to obtain
transpose inverse square-root factors in matrix form.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and
Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corFactor">corFactor</a></code>,
<code><a href="#topic+corMatrix.corStruct">corMatrix.corStruct</a></code>,
<code><a href="#topic+recalc.corStruct">recalc.corStruct</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(form = ~1 | Subject)
cs1 &lt;- Initialize(cs1, data = Orthodont)
corFactor(cs1)
</code></pre>

<hr>
<h2 id='corGaus'>Gaussian Correlation Structure</h2><span id='topic+corGaus'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corGaus</code> class,
representing a Gaussian spatial correlation structure. Letting
<code class="reqn">d</code> denote the range and <code class="reqn">n</code> denote the nugget
effect, the correlation between two observations a distance
<code class="reqn">r</code> apart is <code class="reqn">\exp(-(r/d)^2)</code> when no nugget
effect is present and <code class="reqn">(1-n) \exp(-(r/d)^2)</code>
when a nugget effect is assumed. Objects created using this
constructor must later be initialized using the appropriate
'  <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corGaus(value, form, nugget, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corGaus_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
Gaussian correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corGaus_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corGaus_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corGaus_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corGaus_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corGaus</code>, also inheriting from class
<code>corSpatial</code>, representing a Gaussian spatial correlation
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp;
Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corGaus(form = ~ x + y + z)

# example lme(..., corGaus ...)
# Pinheiro and Bates, pp. 222-249
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p 246 
fm3BW.lme &lt;- update(fm2BW.lme,
           correlation = corExp(form = ~ Time))
# p. 249
fm8BW.lme &lt;- update(fm3BW.lme, correlation = corGaus(form = ~ Time))

</code></pre>

<hr>
<h2 id='corLin'>Linear Correlation Structure</h2><span id='topic+corLin'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corLin</code> class,
representing a linear spatial correlation structure. Letting
<code class="reqn">d</code> denote the range and <code class="reqn">n</code> denote the nugget
effect, the correlation between two observations a distance
<code class="reqn">r &lt; d</code> apart is <code class="reqn">1-(r/d)</code> when no nugget effect
is present and <code class="reqn">(1-n) (1 -(r/d))</code> when a nugget
effect is assumed. If <code class="reqn">r \geq d</code> the correlation is
zero. Objects created using this constructor must later be
initialized using the appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corLin(value, form, nugget, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corLin_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
linear correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corLin_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corLin_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corLin_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corLin_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corLin</code>, also inheriting from class
<code>corSpatial</code>, representing a linear spatial correlation
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corLin(form = ~ x + y)

# example lme(..., corLin ...)
# Pinheiro and Bates, pp. 222-249
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p 246 
fm3BW.lme &lt;- update(fm2BW.lme,
           correlation = corExp(form = ~ Time))
# p. 249
fm7BW.lme &lt;- update(fm3BW.lme, correlation = corLin(form = ~ Time))

</code></pre>

<hr>
<h2 id='corMatrix'>Extract Correlation Matrix</h2><span id='topic+corMatrix'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include all <code>corStruct</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMatrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMatrix_+3A_object">object</code></td>
<td>
<p>an object for which a correlation matrix can be
extracted.</p>
</td></tr> 
<tr><td><code id="corMatrix_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate
documentation. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corMatrix.corStruct">corMatrix.corStruct</a></code>,
<code><a href="#topic+corMatrix.pdMat">corMatrix.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='corMatrix.corStruct'>Matrix of a corStruct Object</h2><span id='topic+corMatrix.corStruct'></span><span id='topic+corMatrix.corCompSymm'></span><span id='topic+corMatrix.corAR1'></span><span id='topic+corMatrix.corARMA'></span><span id='topic+corMatrix.corCAR1'></span><span id='topic+corMatrix.corCompSymm'></span><span id='topic+corMatrix.corNatural'></span><span id='topic+corMatrix.corSpatial'></span><span id='topic+corMatrix.corSymm'></span>

<h3>Description</h3>

<p>This method function extracts the correlation matrix (or its transpose
inverse square-root factor), or list of correlation matrices (or their
transpose inverse square-root factors) corresponding to
<code>covariate</code> and <code>object</code>. Letting <code class="reqn">\Sigma</code> denote
a correlation matrix, a square-root factor of <code class="reqn">\Sigma</code> is
any square matrix <code class="reqn">L</code> such that <code class="reqn">\Sigma =  L'L</code>. When
<code>corr = FALSE</code>, this method extracts <code class="reqn">L^{-t}</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
corMatrix(object, covariate, corr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMatrix.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="corMatrix.corStruct_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of
covariate vectors (matrices), at which values the correlation matrix,
or list of correlation  matrices, are to be evaluated. Defaults to
<code>getCovariate(object)</code>.</p>
</td></tr> 
<tr><td><code id="corMatrix.corStruct_+3A_corr">corr</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the function returns the
correlation matrix, or list of correlation matrices, represented by
<code>object</code>. If <code>FALSE</code> the function returns a transpose
inverse square-root of the correlation matrix, or a list of transpose
inverse square-root factors of the correlation matrices.</p>
</td></tr>
<tr><td><code id="corMatrix.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>If <code>covariate</code> is a vector (matrix), the returned value will be
an array with the corresponding correlation matrix (or its transpose
inverse square-root factor). If the <code>covariate</code> is a list of
vectors (matrices), the returned value will be a list with the
correlation matrices (or their transpose inverse square-root factors)
corresponding to each component of <code>covariate</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corFactor.corStruct">corFactor.corStruct</a></code>, <code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(0.3)
corMatrix(cs1, covariate = 1:4)
corMatrix(cs1, covariate = 1:4, corr = FALSE)

# Pinheiro and Bates, p. 225
cs1CompSymm &lt;- corCompSymm(value = 0.3, form = ~ 1 | Subject)
cs1CompSymm &lt;- Initialize(cs1CompSymm, data = Orthodont)
corMatrix(cs1CompSymm)

# Pinheiro and Bates, p. 226
cs1Symm &lt;- corSymm(value = c(0.2, 0.1, -0.1, 0, 0.2, 0),
                   form = ~ 1 | Subject)
cs1Symm &lt;- Initialize(cs1Symm, data = Orthodont)
corMatrix(cs1Symm)

# Pinheiro and Bates, p. 236 
cs1AR1 &lt;- corAR1(0.8, form = ~ 1 | Subject)
cs1AR1 &lt;- Initialize(cs1AR1, data = Orthodont)
corMatrix(cs1AR1)

# Pinheiro and Bates, p. 237 
cs1ARMA &lt;- corARMA(0.4, form = ~ 1 | Subject, q = 1)
cs1ARMA &lt;- Initialize(cs1ARMA, data = Orthodont)
corMatrix(cs1ARMA)

# Pinheiro and Bates, p. 238 
spatDat &lt;- data.frame(x = (0:4)/4, y = (0:4)/4)
cs1Exp &lt;- corExp(1, form = ~ x + y)
cs1Exp &lt;- Initialize(cs1Exp, spatDat)
corMatrix(cs1Exp)
</code></pre>

<hr>
<h2 id='corMatrix.pdMat'>Extract Correlation Matrix from a pdMat Object</h2><span id='topic+corMatrix.pdBlocked'></span><span id='topic+corMatrix.pdCompSymm'></span><span id='topic+corMatrix.pdDiag'></span><span id='topic+corMatrix.pdIdent'></span><span id='topic+corMatrix.pdMat'></span><span id='topic+corMatrix.pdSymm'></span>

<h3>Description</h3>

<p>The correlation matrix corresponding to the positive-definite matrix
represented by <code>object</code> is obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
corMatrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMatrix.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>, representing
a positive definite matrix.</p>
</td></tr>
<tr><td><code id="corMatrix.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the correlation matrix corresponding to the positive-definite matrix
represented by <code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>, <code><a href="#topic+pdMatrix">pdMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(diag(1:4))
corMatrix(pd1)
</code></pre>

<hr>
<h2 id='corMatrix.reStruct'>Extract Correlation Matrix from Components of an reStruct Object</h2><span id='topic+corMatrix.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts the correlation matrices
corresponding to the <code>pdMat</code> elements of <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
corMatrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMatrix.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="corMatrix.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by the correlation matrices
corresponding to the elements of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.reStruct">as.matrix.reStruct</a></code>,
<code><a href="#topic+corMatrix">corMatrix</a></code>, <code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(pdSymm(diag(3), ~age+Sex, data = Orthodont))
corMatrix(rs1)
</code></pre>

<hr>
<h2 id='corNatural'>General correlation in natural parameterization</h2><span id='topic+corNatural'></span><span id='topic+print.corNatural'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corNatural</code> class,
representing a general correlation structure in the &ldquo;natural&rdquo;
parameterization, which is described under <code><a href="#topic+pdNatural">pdNatural</a></code>.
Objects created using this constructor must later be
initialized using the  appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corNatural(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corNatural_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values. Default is
<code>numeric(0)</code>, which results in a vector of zeros of appropriate
dimension being assigned to the parameters when <code>object</code> is
initialized (corresponding to an identity correlation structure).</p>
</td></tr> 
<tr><td><code id="corNatural_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. A covariate for this correlation structure
must be integer valued. When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>  
<tr><td><code id="corNatural_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corNatural</code> representing a general correlation
structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corNatural">Initialize.corNatural</a></code>,
<code><a href="#topic+pdNatural">pdNatural</a></code>, 
<code><a href="#topic+summary.corNatural">summary.corNatural</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## covariate is observation order and grouping factor is Subject
cs1 &lt;- corNatural(form = ~ 1 | Subject)
</code></pre>

<hr>
<h2 id='corRatio'>Rational Quadratic Correlation Structure</h2><span id='topic+corRatio'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corRatio</code> class,
representing a rational quadratic spatial correlation structure. Letting
<code class="reqn">d</code> denote the range and <code class="reqn">n</code> denote the nugget
effect, the correlation between two observations a distance
<code class="reqn">r</code> apart is <code class="reqn">1/(1+(r/d)^2)</code> when no nugget effect
is present and <code class="reqn">(1-n)/(1+(r/d)^2)</code> when a
nugget effect is  assumed. Objects created using this constructor need
to be later initialized using the appropriate <code>Initialize</code>
method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corRatio(value, form, nugget, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corRatio_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
rational quadratic correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corRatio_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corRatio_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corRatio_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corRatio_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corRatio</code>, also inheriting from class
<code>corSpatial</code>, representing a rational quadratic spatial correlation
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corRatio(form = ~ x + y + z)

# example lme(..., corRatio ...)
# Pinheiro and Bates, pp. 222-249
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p 246 
fm3BW.lme &lt;- update(fm2BW.lme,
           correlation = corExp(form = ~ Time))
# p. 249
fm5BW.lme &lt;- update(fm3BW.lme, correlation =
                   corRatio(form = ~ Time))

# example gls(..., corRatio ...)
# Pinheiro and Bates, pp. 261, 263
fm1Wheat2 &lt;- gls(yield ~ variety - 1, Wheat2)
# p. 263 
fm3Wheat2 &lt;- update(fm1Wheat2, corr = 
    corRatio(c(12.5, 0.2),
       form = ~ latitude + longitude,
             nugget = TRUE))

</code></pre>

<hr>
<h2 id='corSpatial'>Spatial Correlation Structure</h2><span id='topic+corSpatial'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corSpatial</code> class,
representing a spatial correlation structure. This class is &quot;virtual&quot;,
having four &quot;real&quot; classes, corresponding to specific spatial
correlation structures, associated with it: <code>corExp</code>,
<code>corGaus</code>, <code>corLin</code>, <code>corRatio</code>, and
<code>corSpher</code>. The returned object will inherit from one of these
&quot;real&quot; classes, determined by the <code>type</code> argument, and from the
&quot;virtual&quot; <code>corSpatial</code> class. Objects created using this
constructor must later be initialized using the appropriate
<code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corSpatial(value, form, nugget, type, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corSpatial_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
spatial correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corSpatial_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corSpatial_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corSpatial_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the desired type of
correlation structure. Available types include <code>"spherical"</code>,
<code>"exponential"</code>, <code>"gaussian"</code>, <code>"linear"</code>, and
<code>"rational"</code>. See the documentation on the functions
<code>corSpher</code>, <code>corExp</code>, <code>corGaus</code>, <code>corLin</code>, and
<code>corRatio</code> for a description of these correlation
structures. Partial matching of arguments is used, so only the first
character needs to be provided.Defaults to <code>"spherical"</code>.</p>
</td></tr> 
<tr><td><code id="corSpatial_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corSpatial_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class determined by the <code>type</code> argument and also
inheriting from class <code>corSpatial</code>, representing a spatial
correlation structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corExp">corExp</a></code>,
<code><a href="#topic+corGaus">corGaus</a></code>,
<code><a href="#topic+corLin">corLin</a></code>,
<code><a href="#topic+corRatio">corRatio</a></code>,
<code><a href="#topic+corSpher">corSpher</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corSpatial(form = ~ x + y + z, type = "g", metric = "man")
</code></pre>

<hr>
<h2 id='corSpher'>Spherical Correlation Structure</h2><span id='topic+corSpher'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corSpher</code> class,
representing a spherical spatial correlation structure. Letting
<code class="reqn">d</code> denote the range and <code class="reqn">n</code> denote the nugget
effect, the correlation between two observations a distance
<code class="reqn">r &lt; d</code> apart is <code class="reqn">1-1.5(r/d)+0.5(r/d)^3</code> when no
nugget effect is present and <code class="reqn">(1-n)
    (1-1.5(r/d)+0.5(r/d)^3)</code>  
when a nugget effect is assumed. If <code class="reqn">r \geq d</code> the
correlation is zero. Objects created using this constructor must later
be initialized using the appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corSpher(value, form, nugget, metric, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corSpher_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values in
constrained form. If <code>nugget</code> is <code>FALSE</code>, <code>value</code> can
have only one element, corresponding to the &quot;range&quot; of the
spherical correlation structure, which must be greater than
zero. If <code>nugget</code> is <code>TRUE</code>, meaning that a nugget effect
is present, <code>value</code> can contain one or two elements, the first
being the &quot;range&quot; and the second the &quot;nugget effect&quot; (one minus the
correlation between two observations taken arbitrarily close
together); the first must be greater than zero and the second must be
between zero and one. Defaults to <code>numeric(0)</code>, which results in
a range of 90% of the minimum distance and a nugget effect of 0.1
being assigned to the parameters when <code>object</code> is initialized.</p>
</td></tr>
<tr><td><code id="corSpher_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ S1+...+Sp</code>, or
<code>~ S1+...+Sp | g</code>, specifying spatial covariates <code>S1</code>
through <code>Sp</code> and,  optionally, a grouping factor <code>g</code>. 
When a grouping factor is present in <code>form</code>, the correlation
structure is assumed to apply only to observations within the same
grouping level; observations with different grouping levels are
assumed to be uncorrelated. Defaults to <code>~ 1</code>, which corresponds
to using the order of the observations in the data as a covariate,
and no groups.</p>
</td></tr>   
<tr><td><code id="corSpher_+3A_nugget">nugget</code></td>
<td>
<p>an optional logical value indicating whether a nugget
effect is present. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="corSpher_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="corSpher_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corSpher</code>, also inheriting from class
<code>corSpatial</code>, representing a spherical spatial correlation
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Littel, Milliken, Stroup, and Wolfinger (1996) &quot;SAS Systems for Mixed
Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+summary.corStruct">summary.corStruct</a></code>,
<code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sp1 &lt;- corSpher(form = ~ x + y)

# example lme(..., corSpher ...)
# Pinheiro and Bates, pp. 222-249
fm1BW.lme &lt;- lme(weight ~ Time * Diet, BodyWeight,
                   random = ~ Time)
# p. 223
fm2BW.lme &lt;- update(fm1BW.lme, weights = varPower())
# p 246 
fm3BW.lme &lt;- update(fm2BW.lme,
           correlation = corExp(form = ~ Time))
# p. 249
fm6BW.lme &lt;- update(fm3BW.lme,
          correlation = corSpher(form = ~ Time))

# example gls(..., corSpher ...)
# Pinheiro and Bates, pp. 261, 263
fm1Wheat2 &lt;- gls(yield ~ variety - 1, Wheat2)
# p. 262 
fm2Wheat2 &lt;- update(fm1Wheat2, corr =
   corSpher(c(28, 0.2),
     form = ~ latitude + longitude, nugget = TRUE))

</code></pre>

<hr>
<h2 id='corSymm'>General Correlation Structure</h2><span id='topic+corSymm'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corSymm</code> class,
representing a general correlation structure. The internal
representation of this structure, in terms of unconstrained
parameters, uses the spherical parametrization defined in Pinheiro and
Bates (1996).  Objects created using this constructor must later be
initialized using the  appropriate <code>Initialize</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corSymm(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corSymm_+3A_value">value</code></td>
<td>
<p>an optional vector with the parameter values. Default is
<code>numeric(0)</code>, which results in a vector of zeros of appropriate
dimension being assigned to the parameters when <code>object</code> is
initialized (corresponding to an identity correlation structure).</p>
</td></tr> 
<tr><td><code id="corSymm_+3A_form">form</code></td>
<td>
<p>a one sided formula of the form <code>~ t</code>, or <code>~ t |
     g</code>, specifying a time covariate <code>t</code> and,  optionally, a
grouping factor <code>g</code>. A covariate for this correlation structure
must be integer valued. When a grouping factor is present in
<code>form</code>, the correlation structure is assumed to apply only
to observations within the same grouping level; observations with
different grouping levels are assumed to be uncorrelated. Defaults to
<code>~ 1</code>, which corresponds to using the order of the observations
in the data as a covariate, and no groups.</p>
</td></tr>  
<tr><td><code id="corSymm_+3A_fixed">fixed</code></td>
<td>
<p>an optional logical value indicating whether the
coefficients should be allowed to vary in the optimization, or kept
fixed at their initial value. Defaults to <code>FALSE</code>, in which case
the coefficients are allowed to vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>corSymm</code> representing a general correlation
structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

 
<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289-296.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corSymm">Initialize.corSymm</a></code>, 
<code><a href="#topic+summary.corSymm">summary.corSymm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## covariate is observation order and grouping factor is Subject
cs1 &lt;- corSymm(form = ~ 1 | Subject)

# Pinheiro and Bates, p. 225 
cs1CompSymm &lt;- corCompSymm(value = 0.3, form = ~ 1 | Subject)
cs1CompSymm &lt;- Initialize(cs1CompSymm, data = Orthodont)
corMatrix(cs1CompSymm)

# Pinheiro and Bates, p. 226
cs1Symm &lt;- corSymm(value =
        c(0.2, 0.1, -0.1, 0, 0.2, 0),
                   form = ~ 1 | Subject)
cs1Symm &lt;- Initialize(cs1Symm, data = Orthodont)
corMatrix(cs1Symm)

# example gls(..., corSpher ...)
# Pinheiro and Bates, pp. 261, 263
fm1Wheat2 &lt;- gls(yield ~ variety - 1, Wheat2)
# p. 262 
fm2Wheat2 &lt;- update(fm1Wheat2, corr =
   corSpher(c(28, 0.2),
     form = ~ latitude + longitude, nugget = TRUE))

# example gls(..., corSymm ... )
# Pinheiro and Bates, p. 251
fm1Orth.gls &lt;- gls(distance ~ Sex * I(age - 11), Orthodont,
                   correlation = corSymm(form = ~ 1 | Subject),
                   weights = varIdent(form = ~ 1 | age))

</code></pre>

<hr>
<h2 id='Covariate'>Assign Covariate Values</h2><span id='topic+covariate+3C-'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include all <code>"<a href="#topic+varFunc">varFunc</a>"</code> classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariate(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Covariate_+3A_object">object</code></td>
<td>
<p>any object with a <code>covariate</code> component.</p>
</td></tr>
<tr><td><code id="Covariate_+3A_value">value</code></td>
<td>
<p>a value to be assigned to the covariate associated with
<code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariate">getCovariate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='Covariate.varFunc'>Assign varFunc Covariate</h2><span id='topic+covariate+3C-.varFunc'></span>

<h3>Description</h3>

<p>The covariate(s) used in the calculation of the weights of the
variance function represented by <code>object</code> is (are) replaced by
<code>value</code>. If <code>object</code> has been initialized, <code>value</code> must
have the same dimensions as <code>getCovariate(object)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'varFunc'
covariate(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Covariate.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr> 
<tr><td><code id="Covariate.varFunc_+3A_value">value</code></td>
<td>
<p>a value to be assigned to the covariate associated with
<code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varFunc</code> object similar to <code>object</code>, but with its
<code>covariate</code> attribute replaced by <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariate.varFunc">getCovariate.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(1.1, form = ~age)
covariate(vf1) &lt;- Orthodont[["age"]]
</code></pre>

<hr>
<h2 id='Dialyzer'>High-Flux Hemodialyzer</h2><span id='topic+Dialyzer'></span>

<h3>Description</h3>

<p>The <code>Dialyzer</code> data frame has 140 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>an ordered factor with levels
<code>10</code> &lt; <code>8</code> &lt; <code>2</code> &lt; <code>6</code> &lt; <code>3</code> &lt;
<code>5</code> &lt; <code>9</code> &lt; <code>7</code> &lt; <code>1</code> &lt; <code>4</code> &lt;
<code>17</code> &lt; <code>20</code> &lt; <code>11</code> &lt; <code>12</code> &lt; <code>16</code> &lt;
<code>13</code> &lt; <code>14</code> &lt; <code>18</code> &lt; <code>15</code> &lt; <code>19</code>
giving the unique identifier for each subject
</p>
</dd>
<dt>QB</dt><dd>
<p>a factor with levels
<code>200</code> and 
<code>300</code> giving the bovine blood flow rate (dL/min).
</p>
</dd>
<dt>pressure</dt><dd>
<p>a numeric vector giving the transmembrane pressure (dmHg).
</p>
</dd>
<dt>rate</dt><dd>
<p>the hemodialyzer ultrafiltration rate (mL/hr).
</p>
</dd>
<dt>index</dt><dd>
<p>index of observation within subject&mdash;1 through 7.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Vonesh and Carter (1992) describe data measured on high-flux
hemodialyzers to assess their <em>in vivo</em> ultrafiltration
characteristics. The ultrafiltration rates (in mL/hr) of 20 high-flux
dialyzers were measured at seven different transmembrane pressures (in
dmHg). The <em>in vitro</em> evaluation of the dialyzers used bovine
blood at flow rates of either 200~dl/min or 300~dl/min. The data,
are also analyzed in Littell, Milliken, Stroup, and Wolfinger (1996).
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York. (Appendix A.6)
</p>
<p>Vonesh, E. F. and Carter, R. L. (1992), Mixed-effects nonlinear
regression for unbalanced repeated measures, <em>Biometrics</em>,
<b>48</b>, 1-18.
</p>
<p>Littell, R. C., Milliken, G. A., Stroup, W. W. and Wolfinger,
R. D. (1996), <em>SAS System for Mixed Models</em>, SAS Institute,
Cary, NC.
</p>

<hr>
<h2 id='Dim'>Extract Dimensions from an Object</h2><span id='topic+Dim'></span><span id='topic+Dim.default'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>"<a href="#topic+corSpatial">corSpatial</a>"</code>, <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
<code>"pdCompSymm"</code>, <code>"pdDiag"</code>, <code>"pdIdent"</code>, <code>"pdMat"</code>,
and <code>"pdSymm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dim(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dim_+3A_object">object</code></td>
<td>
<p>any object for which dimensions can be extracted.</p>
</td></tr>
<tr><td><code id="Dim_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Note</h3>

<p>If <code>dim</code> allowed more than one argument, there would be no
need for this generic function.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dim.pdMat">Dim.pdMat</a></code>, <code><a href="#topic+Dim.corStruct">Dim.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='Dim.corSpatial'>Dimensions of a corSpatial Object</h2><span id='topic+Dim.corSpatial'></span>

<h3>Description</h3>

<p>if <code>groups</code> is missing, it returns the <code>Dim</code> attribute of
<code>object</code>; otherwise, calculates the dimensions associated with
the grouping factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corSpatial'
Dim(object, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dim.corSpatial_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corSpatial">corSpatial</a>"</code>,
representing a spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Dim.corSpatial_+3A_groups">groups</code></td>
<td>
<p>an optional factor defining the grouping of the
observations; observations within a group are correlated and
observations in different groups are uncorrelated.</p>
</td></tr>
<tr><td><code id="Dim.corSpatial_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>length of <code>groups</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code>spClass</code></td>
<td>
<p>an integer representing the spatial correlation class;
0 = user defined class, 1 = <code>corSpher</code>, 2 = <code>corExp</code>, 3 =
<code>corGaus</code>, 4 = <code>corLin</code></p>
</td></tr>
<tr><td><code>sumLenSq</code></td>
<td>
<p>sum of the squares of the number of observations per
group</p>
</td></tr> 
<tr><td><code>len</code></td>
<td>
<p>an integer vector with the number of observations per
group</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>an integer vector with the starting position for the
distance vectors in each group, beginning from zero</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dim">Dim</a></code>,
<code><a href="#topic+Dim.corStruct">Dim.corStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Dim(corGaus(), getGroups(Orthodont))

cs1ARMA &lt;- corARMA(0.4, form = ~ 1 | Subject, q = 1)
cs1ARMA &lt;- Initialize(cs1ARMA, data = Orthodont)
Dim(cs1ARMA)
</code></pre>

<hr>
<h2 id='Dim.corStruct'>Dimensions of a corStruct Object</h2><span id='topic+Dim.corStruct'></span>

<h3>Description</h3>

<p>if <code>groups</code> is missing, it returns the <code>Dim</code> attribute of
<code>object</code>; otherwise, calculates the dimensions associated with
the grouping factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
Dim(object, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dim.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="Dim.corStruct_+3A_groups">groups</code></td>
<td>
<p>an optional factor defining the grouping of the
observations; observations within a group are correlated and
observations in different groups are uncorrelated.</p>
</td></tr>
<tr><td><code id="Dim.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>length of <code>groups</code></p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>number of groups</p>
</td></tr>
<tr><td><code>maxLen</code></td>
<td>
<p>maximum number of observations in a group</p>
</td></tr>
<tr><td><code>sumLenSq</code></td>
<td>
<p>sum of the squares of the number of observations per
group</p>
</td></tr> 
<tr><td><code>len</code></td>
<td>
<p>an integer vector with the number of observations per
group</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>an integer vector with the starting position for the
observations in each group, beginning from zero</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dim">Dim</a></code>, <code><a href="#topic+Dim.corSpatial">Dim.corSpatial</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Dim(corAR1(), getGroups(Orthodont))
</code></pre>

<hr>
<h2 id='Dim.pdMat'>Dimensions of a pdMat Object</h2><span id='topic+Dim.pdMat'></span><span id='topic+Dim.pdCompSymm'></span><span id='topic+Dim.pdDiag'></span><span id='topic+Dim.pdIdent'></span><span id='topic+Dim.pdNatural'></span><span id='topic+Dim.pdSymm'></span>

<h3>Description</h3>

<p>This method function returns the dimensions of the matrix represented
by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
Dim(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dim.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
representing a positive-definite matrix.</p>
</td></tr>
<tr><td><code id="Dim.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an integer vector with the number of rows and columns of the
matrix represented by <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Dim">Dim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Dim(pdSymm(diag(3)))
</code></pre>

<hr>
<h2 id='Earthquake'>Earthquake Intensity</h2><span id='topic+Earthquake'></span>

<h3>Description</h3>

<p>The <code>Earthquake</code> data frame has 182 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Quake</dt><dd>
<p>an ordered factor with levels
<code>20</code> &lt; <code>16</code> &lt; <code>14</code> &lt; <code>10</code> &lt; <code>3</code> &lt;
<code>8</code> &lt; <code>23</code> &lt; <code>22</code> &lt; <code>6</code> &lt; <code>13</code> &lt;
<code>7</code> &lt; <code>21</code> &lt; <code>18</code> &lt; <code>15</code> &lt; <code>4</code> &lt;
<code>12</code> &lt; <code>19</code> &lt; <code>5</code> &lt; <code>9</code> &lt; <code>1</code> &lt;
<code>2</code> &lt; <code>17</code> &lt; <code>11</code> indicating the earthquake
on which the measurements were made.
</p>
</dd>
<dt>Richter</dt><dd>
<p>a numeric vector giving the intensity of the earthquake on
the Richter scale.
</p>
</dd>
<dt>distance</dt><dd>
<p>the distance from the seismological measuring station to the
epicenter of the earthquake (km).
</p>
</dd>
<dt>soil</dt><dd>
<p>a factor with levels <code>0</code> and <code>1</code>
giving the soil condition at the measuring station, either
soil or rock.
</p>
</dd>
<dt>accel</dt><dd>
<p>maximum horizontal acceleration observed (g).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Measurements recorded at available seismometer locations for 23
large earthquakes in western North America between 1940 and 1980.
They were originally given in Joyner and Boore (1981); are
mentioned in Brillinger (1987); and are analyzed in Davidian
and Giltinan (1995).
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.8)
</p>
<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.
</p>
<p>Joyner and Boore (1981), Peak horizontal acceleration and velocity from
strong-motion records including records from the 1979 Imperial
Valley, California, earthquake, <em>Bulletin of the Seismological
Society of America</em>, <b>71</b>, 2011-2038.
</p>
<p>Brillinger, D. (1987), Comment on a paper by C. R. Rao,
<em>Statistical Science</em>, <b>2</b>, 448-450.
</p>

<hr>
<h2 id='ergoStool'>Ergometrics experiment with stool types</h2><span id='topic+ergoStool'></span>

<h3>Description</h3>

<p>The <code>ergoStool</code> data frame has 36 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>effort</dt><dd>
<p>a numeric vector giving the effort (Borg scale) required to
arise from a stool.
</p>
</dd>
<dt>Type</dt><dd>
<p>a factor with levels
<code>T1</code>, 
<code>T2</code>, 
<code>T3</code>, and 
<code>T4</code> giving the stool type.
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor giving a unique identifier for the subject
in the experiment.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Devore (2000) cites data from an article in <em>Ergometrics</em> (1993,
pp. 519-535) on &ldquo;The Effects of a Pneumatic Stool and a One-Legged
Stool on Lower Limb Joint Load and Muscular Activity.&rdquo;
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.9)
</p>
<p>Devore, J. L. (2000), <em>Probability and Statistics for
Engineering and the Sciences (5th ed)</em>, Duxbury, Boston, MA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;-
   lme(effort ~ Type, data = ergoStool, random = ~ 1 | Subject)
anova( fm1 )
</code></pre>

<hr>
<h2 id='Fatigue'>Cracks caused by metal fatigue</h2><span id='topic+Fatigue'></span>

<h3>Description</h3>

<p>The <code>Fatigue</code> data frame has 262 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Path</dt><dd>
<p>an ordered factor with levels
<code>1</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code> &lt;
<code>6</code> &lt; <code>7</code> &lt; <code>8</code> &lt; <code>9</code> &lt; <code>10</code> &lt;
<code>11</code> &lt; <code>12</code> &lt; <code>13</code> &lt; <code>14</code> &lt; <code>15</code> &lt;
<code>16</code> &lt; <code>17</code> &lt; <code>18</code> &lt; <code>19</code> &lt; <code>20</code> &lt;
<code>21</code> giving the test path (or test unit) number.  The
order is in terms of increasing failure time or decreasing
terminal crack length.
</p>
</dd>
<dt>cycles</dt><dd>
<p>number of test cycles at which the measurement is made
(millions of cycles).
</p>
</dd>
<dt>relLength</dt><dd>
<p>relative crack length (dimensionless).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are given in Lu and Meeker (1993) where they state
&ldquo;We obtained the data in Table 1 visually from figure 4.5.2 on page 242
of Bogdanoff and Kozin (1985).&rdquo;
The data represent the growth of cracks in metal for 21 test units.
An initial notch of length 0.90 inches was made on each unit which then
was subjected to several thousand test cycles.  After every 10,000
test cycles the crack length was measured.  Testing was stopped if the
crack length exceeded 1.60 inches, defined as a failure, or at 120,000
cycles.
</p>


<h3>Source</h3>

<p>Lu, C. Joséph , and Meeker, William Q. (1993), Using degradation
measures to estimate a time-to-failure distribution,
<em>Technometrics</em>, <b>35</b>, 161-174 
</p>

<hr>
<h2 id='fdHess'>Finite difference Hessian</h2><span id='topic+fdHess'></span>

<h3>Description</h3>

<p>Evaluate an approximate Hessian and gradient of a scalar function
using finite differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdHess(pars, fun, ...,
       .relStep = .Machine$double.eps^(1/3), minAbsPar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdHess_+3A_pars">pars</code></td>
<td>
<p>the numeric values of the parameters at which to evaluate the
function <code>fun</code> and its derivatives.</p>
</td></tr>
<tr><td><code id="fdHess_+3A_fun">fun</code></td>
<td>
<p>a function depending on the parameters <code>pars</code> that
returns a numeric scalar.</p>
</td></tr>
<tr><td><code id="fdHess_+3A_...">...</code></td>
<td>
<p>Optional additional arguments to <code>fun</code></p>
</td></tr>
<tr><td><code id="fdHess_+3A_.relstep">.relStep</code></td>
<td>
<p>The relative step size to use in the finite
differences.  It defaults to the cube root of <code>.Machine$double.eps</code></p>
</td></tr>
<tr><td><code id="fdHess_+3A_minabspar">minAbsPar</code></td>
<td>
<p>The minimum magnitude of a parameter value that is
considered non-zero.  It defaults to zero meaning that any non-zero
value will be considered different from zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a second-order response surface design known as a
&ldquo;Koschal design&rdquo; to determine the parameter values at which the
function is evaluated.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>the value of function <code>fun</code> evaluated at the
parameter values <code>pars</code></p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>an approximate gradient (of length <code>length(pars)</code>).</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>a matrix whose upper triangle contains an approximate Hessian.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>(fdH &lt;- fdHess(c(12.3, 2.34), function(x) x[1]*(1-exp(-0.4*x[2]))))
stopifnot(length(fdH$ mean) == 1,
          length(fdH$ gradient) == 2,
          identical(dim(fdH$ Hessian), c(2L, 2L)))
</code></pre>

<hr>
<h2 id='fitted.glsStruct'>Calculate glsStruct Fitted Values</h2><span id='topic+fitted.glsStruct'></span>

<h3>Description</h3>

<p>The fitted values for the linear model represented by <code>object</code>
are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsStruct'
fitted(object, glsFit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.glsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+glsStruct">glsStruct</a>"</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>"<a href="#topic+varFunc">varFunc</a>"</code> objects.</p>
</td></tr>
<tr><td><code id="fitted.glsStruct_+3A_glsfit">glsFit</code></td>
<td>
<p>an optional list with components <code>logLik</code>
(log-likelihood), <code>beta</code> (coefficients), <code>sigma</code> (standard
deviation for error term), <code>varBeta</code> (coefficients' covariance
matrix), <code>fitted</code> (fitted values), and <code>residuals</code>
(residuals). Defaults to <code>attr(object, "glsFit")</code>.</p>
</td></tr>
<tr><td><code id="fitted.glsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the fitted values for the linear model represented by
<code>object</code>. 
</p>


<h3>Note</h3>

<p>This method function is generally only used inside <code>gls</code> and 
<code>fitted.gls</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, 
<code><a href="#topic+residuals.glsStruct">residuals.glsStruct</a></code> </p>

<hr>
<h2 id='fitted.gnlsStruct'>Calculate gnlsStruct Fitted Values</h2><span id='topic+fitted.gnlsStruct'></span>

<h3>Description</h3>

<p>The fitted values for the nonlinear model represented by <code>object</code>
are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnlsStruct'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.gnlsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gnlsStruct">gnlsStruct</a>"</code>,
representing a list of model components, such as
<code>corStruct</code> and <code>varFunc</code> objects, and attributes
specifying the underlying nonlinear model and the response variable.</p>
</td></tr>
<tr><td><code id="fitted.gnlsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the fitted values for the nonlinear model represented by
<code>object</code>. 
</p>


<h3>Note</h3>

<p>This method function is generally only used inside <code>gnls</code> and 
<code>fitted.gnls</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>, 
<code><a href="#topic+residuals.gnlsStruct">residuals.gnlsStruct</a></code> </p>

<hr>
<h2 id='fitted.lme'>Extract lme Fitted Values</h2><span id='topic+fitted.lme'></span>

<h3>Description</h3>

<p>The fitted values at level <code class="reqn">i</code> are obtained by adding together the
population fitted values (based only on the fixed effects estimates)
and the estimated contributions of the random effects to the fitted
values at grouping levels less or equal to <code class="reqn">i</code>. The resulting
values estimate the best linear unbiased predictions (BLUPs) at level
<code class="reqn">i</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
fitted(object, level, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="fitted.lme_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the fitted values from <code>object</code>. Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population fitted values. Defaults to
the highest or innermost level of grouping.</p>
</td></tr> 
<tr><td><code id="fitted.lme_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> and a single
value is given in <code>level</code>, the returned object is a list with
the fitted values split by groups; else the returned value is
either a vector or a data frame, according to the length of
<code>level</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fitted.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>If a single level of grouping is specified in <code>level</code>, the
returned value is either a list with the fitted values split by groups
(<code>asList = TRUE</code>) or a vector with the fitted values
(<code>asList = FALSE</code>); else, when multiple grouping levels are
specified in <code>level</code>, the returned object is a data frame with
columns given by the fitted values at different levels and the
grouping factors.  For a vector or data frame result the
<code><a href="stats.html#topic+napredict">napredict</a></code> method is applied.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1998) &quot;Computational methods for
multilevel models&quot; available in PostScript or PDF formats at
http://nlme.stat.wisc.edu/pub/NLME/
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 235, 397.    
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+residuals.lme">residuals.lme</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1)
fitted(fm1, level = 0:1)
</code></pre>

<hr>
<h2 id='fitted.lmeStruct'>Calculate lmeStruct Fitted Values</h2><span id='topic+fitted.lmeStruct'></span>

<h3>Description</h3>

<p>The fitted values at level <code class="reqn">i</code> are obtained by adding together the
population fitted values (based only on the fixed effects estimates)
and the estimated contributions of the random effects to the fitted
values at grouping levels less or equal to <code class="reqn">i</code>. The resulting
values estimate the best linear unbiased predictions (BLUPs) at level
<code class="reqn">i</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmeStruct'
fitted(object, level, conLin, lmeFit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmeStruct">lmeStruct</a>"</code>,
representing a list of linear mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="fitted.lmeStruct_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the fitted values from <code>object</code>. Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population fitted values. Defaults to
the highest or innermost level of grouping.</p>
</td></tr> 
<tr><td><code id="fitted.lmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying lme model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="fitted.lmeStruct_+3A_lmefit">lmeFit</code></td>
<td>
<p>an optional list with components <code>beta</code> and <code>b</code>
containing respectively the fixed effects estimates and the random
effects estimates to be used to calculate the fitted values. Defaults
to <code>attr(object, "lmeFit")</code>.</p>
</td></tr>
<tr><td><code id="fitted.lmeStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic accept other optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>,
the returned value is a vector with the fitted values at the desired
level; else, when multiple grouping levels are specified in
<code>level</code>, the returned object is a matrix with 
columns given by the fitted values at different levels. 
</p>


<h3>Note</h3>

<p>This method function is generally only used inside <code>lme</code> and 
<code>fitted.lme</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+fitted.lme">fitted.lme</a></code>,
<code><a href="#topic+residuals.lmeStruct">residuals.lmeStruct</a></code> </p>

<hr>
<h2 id='fitted.lmList'>Extract lmList Fitted Values</h2><span id='topic+fitted.lmList'></span>

<h3>Description</h3>

<p>The fitted values are extracted from each <code>lm</code> component of
<code>object</code> and arranged into a list with as many components as
<code>object</code>, or combined into a single vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
fitted(object, subset, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="fitted.lmList_+3A_subset">subset</code></td>
<td>
<p>an optional character or integer vector naming the
<code>lm</code> components of <code>object</code> from which the fitted values
are to be extracted. Default is <code>NULL</code>, in which case all
components are used.
</p>
</td></tr>
<tr><td><code id="fitted.lmList_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
object is a list with the fitted values split by groups; else the
returned value is a vector. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="fitted.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by the fitted values of each <code>lm</code>
component of <code>object</code>, or a vector with the fitted values for all
<code>lm</code> components of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="#topic+residuals.lmList">residuals.lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
fitted(fm1)
</code></pre>

<hr>
<h2 id='fitted.nlmeStruct'>Calculate nlmeStruct Fitted Values</h2><span id='topic+fitted.nlmeStruct'></span>

<h3>Description</h3>

<p>The fitted values at level <code class="reqn">i</code> are obtained by adding together the
contributions from the estimated fixed effects and the estimated
random effects at levels less or equal to <code class="reqn">i</code> and evaluating the
model function at the resulting estimated parameters. The resulting
values estimate the predictions at level <code class="reqn">i</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlmeStruct'
fitted(object, level, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.nlmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+nlmeStruct">nlmeStruct</a>"</code>,
representing a list of mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects, plus
attributes  specifying the underlying nonlinear model and the
response variable.</p>
</td></tr> 
<tr><td><code id="fitted.nlmeStruct_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the fitted values from <code>object</code>. Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population fitted values. Defaults to
the highest or innermost level of grouping.</p>
</td></tr> 
<tr><td><code id="fitted.nlmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying nlme model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="fitted.nlmeStruct_+3A_...">...</code></td>
<td>
<p>additional arguments that could be given to this method.
None are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>,
the returned value is a vector with the fitted values at the desired
level; else, when multiple grouping levels are specified in
<code>level</code>, the returned object is a matrix with 
columns given by the fitted values at different levels. 
</p>


<h3>Note</h3>

<p>This method function is generally only used inside <code>nlme</code> and 
<code>fitted.nlme</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1998) &quot;Computational methods for
multilevel models&quot; available in PostScript or PDF formats at
http://nlme.stat.wisc.edu/pub/NLME/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>, <code><a href="#topic+residuals.nlmeStruct">residuals.nlmeStruct</a></code></p>

<hr>
<h2 id='fixed.effects'>Extract Fixed Effects</h2><span id='topic+fixed.effects'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>lmList</code> and <code>lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed.effects(object, ...)
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed.effects_+3A_object">object</code></td>
<td>
<p>any fitted model object from which fixed effects
estimates can be extracted.</p>
</td></tr>
<tr><td><code id="fixed.effects_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.lmList">fixef.lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='fixef.lmList'>Extract lmList Fixed Effects</h2><span id='topic+fixed.effects.lmList'></span><span id='topic+fixef.lmList'></span>

<h3>Description</h3>

<p>The average of the coefficients corresponding to the <code>lm</code>
components of <code>object</code> is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="fixef.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the average of the individual <code>lm</code> coefficients in
<code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="#topic+random.effects.lmList">random.effects.lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
fixed.effects(fm1)
</code></pre>

<hr>
<h2 id='formula.pdBlocked'>Extract pdBlocked Formula</h2><span id='topic+formula.pdBlocked'></span>

<h3>Description</h3>

<p>The <code>formula</code> attributes of the <code>pdMat</code> elements of
<code>x</code> are extracted and returned as a list, in case
<code>asList=TRUE</code>, or converted to a single one-sided formula when
<code>asList=FALSE</code>. If the <code>pdMat</code> elements do not have a
<code>formula</code> attribute, a <code>NULL</code> value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdBlocked'
formula(x, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.pdBlocked_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"pdBlocked"</code>,
representing a positive definite block diagonal matrix.</p>
</td></tr> 
<tr><td><code id="formula.pdBlocked_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, a list with
the formulas for the individual block diagonal elements of
<code>x</code> is returned; else, if <code>FALSE</code>, a one-sided formula
combining all individual formulas is returned. Defaults to
<code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="formula.pdBlocked_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list of one-sided formulas, or a single one-sided formula, or
<code>NULL</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdBlocked">pdBlocked</a></code>, <code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdBlocked(list(~ age, ~ Sex - 1))
formula(pd1)
formula(pd1, asList = TRUE)
</code></pre>

<hr>
<h2 id='formula.pdMat'>Extract pdMat Formula</h2><span id='topic+formula.pdMat'></span>

<h3>Description</h3>

<p>This method function extracts the formula associated with a
<code>pdMat</code> object, in which the column and row names are specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
formula(x, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.pdMat_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>, representing
a positive definite matrix.</p>
</td></tr>
<tr><td><code id="formula.pdMat_+3A_aslist">asList</code></td>
<td>
<p>logical.  Should the asList argument be applied to each
of the components?  Never used.</p>
</td></tr>
<tr><td><code id="formula.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>x</code> has a <code>formula</code> attribute, its value is
returned, else <code>NULL</code> is returned.
</p>


<h3>Note</h3>

<p>Because factors may be present in <code>formula(x)</code>, the
<code>pdMat</code> object needs to have access to a data frame where the
variables named in the formula can be evaluated, before it can resolve
its row and column names from the formula.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(~Sex*age)
formula(pd1)
</code></pre>

<hr>
<h2 id='formula.reStruct'>Extract reStruct Object Formula</h2><span id='topic+formula.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts a formula from each of the 
components of <code>x</code>, returning a list of formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
formula(x, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.reStruct_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr>
<tr><td><code id="formula.reStruct_+3A_aslist">asList</code></td>
<td>
<p>logical.  Should the asList argument be applied to each
of the components?</p>
</td></tr>
<tr><td><code id="formula.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with the formulas of each component of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(A = pdDiag(diag(2), ~age), B = ~1))
formula(rs1)
</code></pre>

<hr>
<h2 id='gapply'>Apply a Function by Groups</h2><span id='topic+gapply'></span>

<h3>Description</h3>

<p>Applies the function to the distinct sets of rows of the data frame
defined by <code>groups</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gapply(object, which, FUN, form, level, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gapply_+3A_object">object</code></td>
<td>
<p>an object to which the function will be applied - usually
a <code>groupedData</code> object or a <code>data.frame</code>. Must inherit from
class <code>"data.frame"</code>.
</p>
</td></tr>
<tr><td><code id="gapply_+3A_which">which</code></td>
<td>
<p>an optional character or positive integer vector
specifying which columns of <code>object</code> should be used with
<code>FUN</code>. Defaults to all columns in <code>object</code>.
</p>
</td></tr>
<tr><td><code id="gapply_+3A_fun">FUN</code></td>
<td>
<p>function to apply to the distinct sets of rows
of the data frame <code>object</code> defined by the values of
<code>groups</code>.
</p>
</td></tr> 
<tr><td><code id="gapply_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula that defines the groups.
When this formula is given the right-hand side is evaluated in
<code>object</code>, converted to a factor if necessary, and the unique
levels are used to define the groups.  Defaults to
<code>formula(object)</code>.
</p>
</td></tr>
<tr><td><code id="gapply_+3A_level">level</code></td>
<td>
<p>an optional positive integer giving the level of grouping
to be used in an object with multiple nested grouping levels.
Defaults to the highest or innermost level of grouping.
</p>
</td></tr>
<tr><td><code id="gapply_+3A_groups">groups</code></td>
<td>
<p>an optional factor that will be used to split the 
rows into groups.  Defaults to <code>getGroups(object, form, level)</code>.
</p>
</td></tr>
<tr><td><code id="gapply_+3A_...">...</code></td>
<td>
<p>optional additional arguments to the summary function
<code>FUN</code>.  Often it is helpful to specify <code>na.rm = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with as many rows as there are levels in the
<code>groups</code> argument.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. sec. 3.4.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gsummary">gsummary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Find number of non-missing "conc" observations for each Subject
gapply( Phenobarb, FUN = function(x) sum(!is.na(x$conc)) )

# Pinheiro and Bates, p. 127 
table( gapply(Quinidine, "conc", function(x) sum(!is.na(x))) )
changeRecords &lt;- gapply( Quinidine, FUN = function(frm)
    any(is.na(frm[["conc"]]) &amp; is.na(frm[["dose"]])) )
</code></pre>

<hr>
<h2 id='Gasoline'>Refinery yield of gasoline</h2><span id='topic+Gasoline'></span>

<h3>Description</h3>

<p>The <code>Gasoline</code> data frame has 32 rows and 6 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>yield</dt><dd>
<p>a numeric vector giving the percentage of crude oil converted to
gasoline after distillation and fractionation
</p>
</dd>
<dt>endpoint</dt><dd>
<p>a numeric vector giving the temperature (degrees F) at which all
the gasoline is vaporized
</p>
</dd>
<dt>Sample</dt><dd>
<p>an ordered factor giving the inferred crude oil sample number
</p>
</dd>
<dt>API</dt><dd>
<p>a numeric vector giving the crude oil gravity (degrees API)
</p>
</dd>
<dt>vapor</dt><dd>
<p>a numeric vector giving the vapor pressure of the crude oil
<code class="reqn">(\mathrm{lbf}/\mathrm{in}^2)</code>
</p>
</dd>
<dt>ASTM</dt><dd>
<p>a numeric vector giving the crude oil 10% point ASTM&mdash;the
temperature at which 10% of the crude oil has become vapor. 
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Prater (1955) provides data on crude oil properties and
gasoline yields.  Atkinson (1985)
uses these data to illustrate the use of diagnostics in multiple
regression analysis.  Three of the covariates&mdash;<code>API</code>,
<code>vapor</code>, and <code>ASTM</code>&mdash;measure characteristics of the
crude oil used to produce the gasoline.  The other covariate &mdash;
<code>endpoint</code>&mdash;is a characteristic of the refining process.
Daniel and Wood (1980) notice that the covariates characterizing
the crude oil occur in only ten distinct groups and conclude that the
data represent responses measured on ten different crude oil samples.
</p>


<h3>Source</h3>

<p>Prater, N. H. (1955), Estimate gasoline yields from crudes,
<em>Petroleum Refiner</em>, <b>35</b> (5).
</p>
<p>Atkinson, A. C. (1985), <em>Plots, Transformations, and
Regression</em>, Oxford Press, New York.
</p>
<p>Daniel, C. and Wood, F. S. (1980), <em>Fitting Equations to Data</em>,
Wiley, New York
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S (4th ed)</em>, Springer, New York.
</p>

<hr>
<h2 id='getCovariate'>Extract Covariate from an Object</h2><span id='topic+getCovariate'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>corStruct</code>, <code>corSpatial</code>,
<code>data.frame</code>, and <code>varFunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovariate(object, form, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovariate_+3A_object">object</code></td>
<td>
<p>any object with a <code>covariate</code> component</p>
</td></tr>
<tr><td><code id="getCovariate_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the covariate(s)
to be extracted. Defaults to <code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="getCovariate_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>form</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 100.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariate.corStruct">getCovariate.corStruct</a></code>,
<code><a href="#topic+getCovariate.data.frame">getCovariate.data.frame</a></code>,
<code><a href="#topic+getCovariate.varFunc">getCovariate.varFunc</a></code>,
<code><a href="#topic+getCovariateFormula">getCovariateFormula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='getCovariate.corStruct'>Extract corStruct Object Covariate</h2><span id='topic+getCovariate.corStruct'></span><span id='topic+getCovariate.corSpatial'></span>

<h3>Description</h3>

<p>This method function extracts the covariate(s) associated with
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
getCovariate(object, form, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovariate.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>corStruct</code>
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="getCovariate.corStruct_+3A_form">form</code></td>
<td>
<p>this argument is included to make the method function
compatible with the generic. It will be assigned the value of
<code>formula(object)</code> and should not be modified.</p>
</td></tr>
<tr><td><code id="getCovariate.corStruct_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
defined in <code>form</code>, in case <code>object</code> is not initialized and
the covariate needs to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when the correlation structure does not include a grouping factor, the
returned value will be a vector or a matrix with the covariate(s)
associated with <code>object</code>. If a grouping factor is present, the
returned value will be a list of vectors or matrices with the
covariate(s) corresponding to each grouping level.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariate">getCovariate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(form = ~ 1 | Subject)
getCovariate(cs1, data = Orthodont)
</code></pre>

<hr>
<h2 id='getCovariate.data.frame'>Extract Data Frame Covariate</h2><span id='topic+getCovariate.data.frame'></span>

<h3>Description</h3>

<p>The right hand side of <code>form</code>, stripped of any conditioning
expression (i.e. an expression following a <code>|</code> operator), is
evaluated in <code>object</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
getCovariate(object, form, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovariate.data.frame_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="getCovariate.data.frame_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the covariate to be
evaluated in <code>object</code>. Defaults to <code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="getCovariate.data.frame_+3A_data">data</code></td>
<td>
<p>some methods for this generic require a separate data
frame. Not used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the right hand side of <code>form</code>, stripped of
any conditional expression, evaluated in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariateFormula">getCovariateFormula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getCovariate(Orthodont)
</code></pre>

<hr>
<h2 id='getCovariate.varFunc'>Extract varFunc Covariate</h2><span id='topic+getCovariate.varFunc'></span>

<h3>Description</h3>

<p>This method function extracts the covariate(s) associated with the
variance function represented by <code>object</code>, if any is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
getCovariate(object, form, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovariate.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>varFunc</code>,
representing a variance function structure.</p>
</td></tr>
<tr><td><code id="getCovariate.varFunc_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the covariate to be
evaluated in <code>object</code>. Defaults to <code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="getCovariate.varFunc_+3A_data">data</code></td>
<td>
<p>some methods for this generic require a <code>data</code>
object.  Not used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>object</code> has a <code>covariate</code> attribute, its value is
returned; else <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+covariate+3C-.varFunc">covariate&lt;-.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(1.1, form = ~age)
covariate(vf1) &lt;- Orthodont[["age"]]
getCovariate(vf1)
</code></pre>

<hr>
<h2 id='getCovariateFormula'>Extract Covariates Formula</h2><span id='topic+getCovariateFormula'></span>

<h3>Description</h3>

<p>The right hand side of <code>formula(object)</code>, without any
conditioning expressions (i.e. any expressions after a <code>|</code>
operator) is returned as a one-sided formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovariateFormula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovariateFormula_+3A_object">object</code></td>
<td>
<p>any object from which a formula can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-sided formula describing the covariates associated with
<code>formula(object)</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getCovariate">getCovariate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getCovariateFormula(y ~ x | g)
getCovariateFormula(y ~ x)
</code></pre>

<hr>
<h2 id='getData'>Extract Data from an Object</h2><span id='topic+getData'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>gls</code>, <code>lme</code>,
and <code>lmList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData_+3A_object">object</code></td>
<td>
<p>an object from which a data.frame can be extracted,
generally a fitted model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getData.gls">getData.gls</a></code>,
<code><a href="#topic+getData.lme">getData.lme</a></code>,
<code><a href="#topic+getData.lmList">getData.lmList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='getData.gls'>Extract gls Object Data</h2><span id='topic+getData.gls'></span><span id='topic+getData.gnls'></span>

<h3>Description</h3>

<p>If present in the calling sequence used to produce <code>object</code>, the
data frame used to fit the model is obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
getData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>gls</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a <code>data</code> argument is present in the calling sequence that
produced <code>object</code>, the corresponding data frame (with
<code>na.action</code> and <code>subset</code> applied to it, if also present in
the call that produced <code>object</code>) is returned;
else, <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, 
<code><a href="#topic+getData">getData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), data = Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
getData(fm1)
</code></pre>

<hr>
<h2 id='getData.lme'>Extract lme Object Data</h2><span id='topic+getData.lme'></span><span id='topic+getData.nlme'></span><span id='topic+getData.nls'></span>

<h3>Description</h3>

<p>If present in the calling sequence used to produce <code>object</code>, the
data frame used to fit the model is obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
getData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lme</code>, representing
a linear mixed-effects fitted model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a <code>data</code> argument is present in the calling sequence that
produced <code>object</code>, the corresponding data frame (with
<code>na.action</code> and <code>subset</code> applied to it, if also present in
the call that produced <code>object</code>) is returned;
else, <code>NULL</code> is returned.
</p>
<p>Note that as from version 3.1-102, this only omits rows omitted in the
fit if <code>na.action = na.omit</code>, and does not omit at all if
<code>na.action = na.exclude</code>.  That is generally what is wanted for
plotting, the main use of this function.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, 
<code><a href="#topic+getData">getData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), data = Ovary,
           random = ~ sin(2*pi*Time))
getData(fm1)
</code></pre>

<hr>
<h2 id='getData.lmList'>Extract lmList Object Data</h2><span id='topic+getData.lmList'></span>

<h3>Description</h3>

<p>If present in the calling sequence used to produce <code>object</code>, the
data frame used to fit the model is obtained. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
getData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getData.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lmList</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a <code>data</code> argument is present in the calling sequence that
produced <code>object</code>, the corresponding data frame (with
<code>na.action</code> and <code>subset</code> applied to it, if also present in
the call that produced <code>object</code>) is returned;
else, <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, 
<code><a href="#topic+getData">getData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
getData(fm1)
</code></pre>

<hr>
<h2 id='getGroups'>Extract Grouping Factors from an Object</h2><span id='topic+getGroups'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>corStruct</code>, <code>data.frame</code>,
<code>gls</code>, <code>lme</code>, <code>lmList</code>, and <code>varFunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups_+3A_object">object</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="getGroups_+3A_form">form</code></td>
<td>
<p>an optional formula with a conditioning expression on its
right hand side (i.e. an expression involving the <code>|</code>
operator). Defaults to <code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="getGroups_+3A_level">level</code></td>
<td>
<p>a positive integer vector with the level(s) of grouping to
be used when multiple nested levels of grouping are present. This
argument is optional for most methods of this generic function and
defaults to all levels of nesting.</p>
</td></tr>
<tr><td><code id="getGroups_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
<code>form</code>. Optional for most methods.</p>
</td></tr>
<tr><td><code id="getGroups_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getGroupsFormula">getGroupsFormula</a></code>, <code><a href="#topic+getGroups.data.frame">getGroups.data.frame</a></code>,
<code><a href="#topic+getGroups.gls">getGroups.gls</a></code>, <code><a href="#topic+getGroups.lmList">getGroups.lmList</a></code>,
<code><a href="#topic+getGroups.lme">getGroups.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='getGroups.corStruct'>Extract corStruct Groups</h2><span id='topic+getGroups.corStruct'></span>

<h3>Description</h3>

<p>This method function extracts the grouping factor associated with
<code>object</code>, if any is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>corStruct</code>
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="getGroups.corStruct_+3A_form">form</code></td>
<td>
<p>this argument is included to make the method function
compatible with the generic. It will be assigned the value of
<code>formula(object)</code> and should not be modified.</p>
</td></tr>
<tr><td><code id="getGroups.corStruct_+3A_level">level</code></td>
<td>
<p>this argument is included to make the method function
compatible with the generic and is not used.</p>
</td></tr>
<tr><td><code id="getGroups.corStruct_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
defined in <code>form</code>, in case <code>object</code> is not initialized and
the grouping factor needs to be evaluated.</p>
</td></tr>
<tr><td><code id="getGroups.corStruct_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a grouping factor is present in the correlation structure
represented by <code>object</code>, the function returns the corresponding
factor vector; else the function returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getGroups">getGroups</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(form = ~ 1 | Subject)
getGroups(cs1, data = Orthodont)
</code></pre>

<hr>
<h2 id='getGroups.data.frame'>Extract Groups from a Data Frame</h2><span id='topic+getGroups.data.frame'></span>

<h3>Description</h3>

<p>Each variable named in the expression after the <code>|</code> operator on
the right hand side of <code>form</code> is evaluated in <code>object</code>. If
more than one variable is indicated in <code>level</code> they are combined
into a data frame; else the selected variable is returned as a vector.
When multiple grouping levels are defined in <code>form</code> and
<code>level &gt; 1</code>, the levels of the returned factor are obtained by
pasting together the levels of the grouping factors of level greater
or equal to <code>level</code>, to ensure their uniqueness. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.data.frame_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="getGroups.data.frame_+3A_form">form</code></td>
<td>
<p>an optional formula with a conditioning expression on its
right hand side (i.e. an expression involving the <code>|</code>
operator). Defaults to <code>formula(object)</code>.</p>
</td></tr>  
<tr><td><code id="getGroups.data.frame_+3A_level">level</code></td>
<td>
<p>a positive integer vector with the level(s) of grouping to
be used when multiple nested levels of grouping are present. Defaults
to all levels of nesting.</p>
</td></tr>
<tr><td><code id="getGroups.data.frame_+3A_data">data</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="getGroups.data.frame_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a data frame with columns given by the grouping factors
indicated in <code>level</code>, from outer to inner, or, when a single
level is requested, a factor representing the selected grouping
factor. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getGroupsFormula">getGroupsFormula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroups(Pixel)
getGroups(Pixel, level = 2)
</code></pre>

<hr>
<h2 id='getGroups.gls'>Extract gls Object Groups</h2><span id='topic+getGroups.gls'></span>

<h3>Description</h3>

<p>If present, the grouping factor associated to the correlation
structure for the linear model represented by <code>object</code> is extracted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>gls</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="getGroups.gls_+3A_form">form</code></td>
<td>
<p>an optional formula with a conditioning expression on its
right hand side (i.e. an expression involving the <code>|</code>
operator). Defaults to <code>formula(object)</code>.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.gls_+3A_level">level</code></td>
<td>
<p>a positive integer vector with the level(s) of grouping to
be used when multiple nested levels of grouping are present. This
argument is optional for most methods of this generic function and
defaults to all levels of nesting.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.gls_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
<code>form</code>. Optional for most methods.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.gls_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.  Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if the linear model represented by <code>object</code> incorporates a
correlation structure and the corresponding <code>corStruct</code> object
has a grouping factor, a vector with the group values is returned;
else, <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+corClasses">corClasses</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
getGroups(fm1)
</code></pre>

<hr>
<h2 id='getGroups.lme'>Extract lme Object Groups</h2><span id='topic+getGroups.lme'></span>

<h3>Description</h3>

<p>The grouping factors corresponding to the linear mixed-effects model
represented by <code>object</code> are extracted. If more than one level is
indicated in <code>level</code>, the corresponding grouping factors are
combined  into a data frame; else the selected grouping factor is
returned as a vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lme</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="getGroups.lme_+3A_form">form</code></td>
<td>
<p>this argument is included to make the method function
compatible with the generic and is ignored in this method.</p>
</td></tr>
<tr><td><code id="getGroups.lme_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be extracted from <code>object</code>. Defaults to the highest or
innermost level of grouping.</p>
</td></tr>  
<tr><td><code id="getGroups.lme_+3A_data">data</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="getGroups.lme_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a data frame with columns given by the grouping factors
indicated in <code>level</code>, or, when a single level is requested, a
factor representing the selected grouping factor. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(pixel ~ day + day^2, Pixel,
  random = list(Dog = ~day, Side = ~1))
getGroups(fm1, level = 1:2)
</code></pre>

<hr>
<h2 id='getGroups.lmList'>Extract lmList Object Groups</h2><span id='topic+getGroups.lmList'></span>

<h3>Description</h3>

<p>The grouping factor determining the partitioning of the observations
used to produce the <code>lm</code> components of <code>object</code> is
extracted.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lmList</code>, representing
a list of <code>lm</code> objects with a common model.</p>
</td></tr>
<tr><td><code id="getGroups.lmList_+3A_form">form</code></td>
<td>
<p>an optional formula with a conditioning expression on its
right hand side (i.e. an expression involving the <code>|</code>
operator). Defaults to <code>formula(object)</code>.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.lmList_+3A_level">level</code></td>
<td>
<p>a positive integer vector with the level(s) of grouping to
be used when multiple nested levels of grouping are present. This
argument is optional for most methods of this generic function and
defaults to all levels of nesting.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.lmList_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
<code>form</code>. Optional for most methods.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.lmList_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.  Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the grouping factor corresponding to the <code>lm</code>
components of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
getGroups(fm1)
</code></pre>

<hr>
<h2 id='getGroups.varFunc'>Extract varFunc Groups</h2><span id='topic+getGroups.varFunc'></span>

<h3>Description</h3>

<p>This method function extracts the grouping factor associated with the
variance function represented by <code>object</code>, if any is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
getGroups(object, form, level, data, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroups.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>varFunc</code>,
representing a variance function structure.</p>
</td></tr>
<tr><td><code id="getGroups.varFunc_+3A_form">form</code></td>
<td>
<p>an optional formula with a conditioning expression on its
right hand side (i.e. an expression involving the <code>|</code>
operator). Defaults to <code>formula(object)</code>.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.varFunc_+3A_level">level</code></td>
<td>
<p>a positive integer vector with the level(s) of grouping to
be used when multiple nested levels of grouping are present. This
argument is optional for most methods of this generic function and
defaults to all levels of nesting.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.varFunc_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
<code>form</code>. Optional for most methods.  Not used.</p>
</td></tr>
<tr><td><code id="getGroups.varFunc_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.  Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>object</code> has a <code>groups</code> attribute, its value is
returned; else <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(form = ~ age | Sex)
vf1 &lt;- Initialize(vf1, Orthodont)
getGroups(vf1)
</code></pre>

<hr>
<h2 id='getGroupsFormula'>Extract Grouping Formula</h2><span id='topic+getGroupsFormula'></span><span id='topic+getGroupsFormula.default'></span><span id='topic+getGroupsFormula.gls'></span><span id='topic+getGroupsFormula.lmList'></span><span id='topic+getGroupsFormula.lme'></span><span id='topic+getGroupsFormula.reStruct'></span>

<h3>Description</h3>

<p>The conditioning expression associated with <code>formula(object)</code>
(i.e. the expression after the <code>|</code> operator) is returned either as
a named list of one-sided formulas, or a single one-sided formula,
depending on the value of <code>asList</code>. The components of the
returned list are ordered from outermost to innermost level and are
named after the grouping factor expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupsFormula(object, asList, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGroupsFormula_+3A_object">object</code></td>
<td>
<p>any object from which a formula can be extracted.</p>
</td></tr>
<tr><td><code id="getGroupsFormula_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> the returned
value with be a list of formulas; else, if <code>FALSE</code> the returned
value will be a one-sided formula. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getGroupsFormula_+3A_sep">sep</code></td>
<td>
<p>character, the separator to use between group levels when
multiple levels are collapsed.  The default is <code>'/'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-sided formula, or a list of one-sided formulas, with the
grouping structure associated with <code>formula(object)</code>. If no
conditioning expression is present in <code>formula(object)</code> a
<code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getGroupsFormula.gls">getGroupsFormula.gls</a></code>,
<code><a href="#topic+getGroupsFormula.lmList">getGroupsFormula.lmList</a></code>,
<code><a href="#topic+getGroupsFormula.lme">getGroupsFormula.lme</a></code>,
<code><a href="#topic+getGroupsFormula.reStruct">getGroupsFormula.reStruct</a></code>,
<code><a href="#topic+getGroups">getGroups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getGroupsFormula(y ~ x | g1/g2)
</code></pre>

<hr>
<h2 id='getResponse'>Extract Response Variable from an Object</h2><span id='topic+getResponse'></span><span id='topic+getResponse.data.frame'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>data.frame</code>, <code>gls</code>, <code>lme</code>,
and <code>lmList</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResponse(object, form)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResponse_+3A_object">object</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="getResponse_+3A_form">form</code></td>
<td>
<p>an optional two-sided formula. Defaults to
<code>formula(object)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getResponseFormula">getResponseFormula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getResponse(Orthodont)
</code></pre>

<hr>
<h2 id='getResponseFormula'>Extract Formula Specifying Response Variable</h2><span id='topic+getResponseFormula'></span>

<h3>Description</h3>

<p>The left hand side of <code>formula{object}</code> is returned as a
one-sided formula. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResponseFormula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResponseFormula_+3A_object">object</code></td>
<td>
<p>any object from which a formula can be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-sided formula with the response variable associated with
<code>formula{object}</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getResponse">getResponse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>getResponseFormula(y ~ x | g)
</code></pre>

<hr>
<h2 id='getVarCov'>Extract variance-covariance matrix</h2><span id='topic+getVarCov'></span><span id='topic+getVarCov.lme'></span><span id='topic+getVarCov.gls'></span><span id='topic+print.VarCov'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix from a fitted model, such as a
mixed-effects model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVarCov(obj, ...)
## S3 method for class 'lme'
getVarCov(obj, individuals,
    type = c("random.effects", "conditional", "marginal"), ...)
## S3 method for class 'gls'
getVarCov(obj, individual = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVarCov_+3A_obj">obj</code></td>
<td>
<p>A fitted model.  Methods are available for models fit by
<code><a href="#topic+lme">lme</a></code> and by <code><a href="#topic+gls">gls</a></code></p>
</td></tr>
<tr><td><code id="getVarCov_+3A_individuals">individuals</code></td>
<td>
<p>For models fit by <code><a href="#topic+lme">lme</a></code> a vector of
levels of the grouping factor can be specified for the conditional
or marginal variance-covariance matrices.</p>
</td></tr>
<tr><td><code id="getVarCov_+3A_individual">individual</code></td>
<td>
<p>For models fit by <code><a href="#topic+gls">gls</a></code> the only type of
variance-covariance matrix provided is the marginal
variance-covariance of the responses by group.  The
optional argument <code>individual</code> specifies the group of responses.</p>
</td></tr>
<tr><td><code id="getVarCov_+3A_type">type</code></td>
<td>
<p>For models fit by <code><a href="#topic+lme">lme</a></code> the <code>type</code>
argument specifies the type of variance-covariance matrix, either
<code>"random.effects"</code> for the random-effects variance-covariance
(the default), or <code>"conditional"</code> for the conditional.
variance-covariance of the responses or <code>"marginal"</code> for the
the marginal variance-covariance of the responses.</p>
</td></tr>
<tr><td><code id="getVarCov_+3A_...">...</code></td>
<td>
<p>Optional arguments for some methods, as described above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix or a list of variance-covariance matrices.
</p>


<h3>Author(s)</h3>

<p>Mary Lindstrom <a href="mailto:lindstro@biostat.wisc.edu">lindstro@biostat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+gls">gls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, data = Orthodont, subset = Sex == "Female")
getVarCov(fm1)
getVarCov(fm1, individual = "F01", type = "marginal")
getVarCov(fm1, type = "conditional")
fm2 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
getVarCov(fm2)
</code></pre>

<hr>
<h2 id='gls'>Fit Linear Model Using Generalized Least Squares</h2><span id='topic+gls'></span><span id='topic+update.gls'></span>

<h3>Description</h3>

<p>This function fits a linear model using generalized least
squares. The errors are allowed to be correlated and/or have unequal
variances.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gls(model, data, correlation, weights, subset, method, na.action,
    control, verbose)
## S3 method for class 'gls'
update(object, model., ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"gls"</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="gls_+3A_model">model</code></td>
<td>
<p>a two-sided linear formula object describing the
model, with the response on the left of a <code>~</code> operator and the
terms, separated by <code>+</code> operators, on the right.</p>
</td></tr>
<tr><td><code id="gls_+3A_model.">model.</code></td>
<td>
<p>Changes to the model &ndash; see <code><a href="stats.html#topic+update.formula">update.formula</a></code> for
details.</p>
</td></tr>
<tr><td><code id="gls_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>model</code>, <code>correlation</code>, <code>weights</code>, and
<code>subset</code>. By default the variables are taken from the
environment from which <code>gls</code> is called.</p>
</td></tr>
<tr><td><code id="gls_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code><a href="#topic+corStruct">corStruct</a></code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. If a grouping variable is to be used, it must be specified in
the <code>form</code> argument to the <code>corStruct</code>
constructor. Defaults to <code>NULL</code>, corresponding to uncorrelated 
errors.</p>
</td></tr>  
<tr><td><code id="gls_+3A_weights">weights</code></td>
<td>
<p>an optional <code><a href="#topic+varFunc">varFunc</a></code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code><a href="#topic+varFixed">varFixed</a></code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code><a href="#topic+varFunc">varFunc</a></code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
errors.</p>
</td></tr> 
<tr><td><code id="gls_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating which subset of the rows of
<code>data</code> should  be  used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="gls_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="gls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code><a href="stats.html#topic+na.fail">na.fail</a></code>) causes
<code>gls</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="gls_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code><a href="#topic+glsControl">glsControl</a></code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="gls_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
<tr><td><code id="gls_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code> evaluate the new call else return the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stats.html#topic+offset">offset</a></code> terms in <code>model</code> are an error since 3.1-157
(2022-03): previously they were silently ignored.
</p>


<h3>Value</h3>

<p>an object of class <code>"gls"</code> representing the linear model
fit. Generic functions such as <code>print</code>, <code>plot</code>, and 
<code>summary</code> have methods to show the results of the fit. See
<code><a href="#topic+glsObject">glsObject</a></code> for the components of the fit. The functions
<code><a href="stats.html#topic+resid">resid</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+fitted">fitted</a></code>,
can be used to extract some of its components. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The different correlation structures available for the
<code>correlation</code> argument are described in Box, G.E.P., Jenkins,
G.M., and Reinsel G.C. (1994), Littel, R.C., Milliken, G.A., Stroup,
W.W., and Wolfinger, R.D. (1996), and Venables, W.N. and Ripley,
B.D. (2002). The use of variance functions for linear 
and nonlinear models is presented in detail in Carroll, R.J. and Ruppert,
D. (1988) and Davidian, M. and Giltinan, D.M. (1995).  
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Carroll, R.J. and Ruppert, D. (1988) &quot;Transformation and Weighting in
Regression&quot;, Chapman and Hall.
</p>
<p>Davidian, M. and Giltinan, D.M. (1995) &quot;Nonlinear Mixed Effects Models
for Repeated Measurement Data&quot;, Chapman and Hall.
</p>
<p>Littel, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996)
&quot;SAS Systems for Mixed Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+glsControl">glsControl</a></code>,
<code><a href="#topic+glsObject">glsObject</a></code>,
<code><a href="#topic+glsStruct">glsStruct</a></code>,
<code><a href="#topic+plot.gls">plot.gls</a></code>, 
<code><a href="#topic+predict.gls">predict.gls</a></code>, 
<code><a href="#topic+qqnorm.gls">qqnorm.gls</a></code>, 
<code><a href="#topic+residuals.gls">residuals.gls</a></code>, 
<code><a href="#topic+summary.gls">summary.gls</a></code>, 
<code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR(1) errors within each Mare
fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
# variance increases as a power of the absolute fitted values
fm2 &lt;- update(fm1, weights = varPower())
</code></pre>

<hr>
<h2 id='gls-internal'>Auxiliary functions used by gls</h2><span id='topic+glsApVar'></span><span id='topic+glsEstimate'></span>

<h3>Description</h3>

<p>These are functions used by <code>gls</code> to call its compiled C
code. They are exported to allow experimentation with modified versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsApVar(glsSt, sigma, conLin = attr(glsSt, "conLin"),
         .relStep = .Machine$double.eps^(1/3), minAbsPar = 0, natural = TRUE)
glsEstimate(object, conLin = attr(object, "conLin"),
            control = list(singular.ok = FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gls-internal_+3A_glsst">glsSt</code>, <code id="gls-internal_+3A_object">object</code></td>
<td>
<p>An object inheriting from  class
<code>"<a href="#topic+glsStruct">glsStruct</a>"</code>.</p>
</td></tr>
<tr><td><code id="gls-internal_+3A_sigma">sigma</code></td>
<td>
<p>the estimated residual standard error: see
<code><a href="#topic+glsObject">glsObject</a></code>.</p>
</td></tr>
<tr><td><code id="gls-internal_+3A_conlin">conLin</code></td>
<td>
<p>A &lsquo;condensed linear model&rsquo;: see
<code><a href="#topic+logLik.glsStruct">logLik.glsStruct</a></code>.</p>
</td></tr>
<tr><td><code id="gls-internal_+3A_.relstep">.relStep</code>, <code id="gls-internal_+3A_minabspar">minAbsPar</code>, <code id="gls-internal_+3A_natural">natural</code></td>
<td>
<p>Control values: see 
<code><a href="#topic+glsControl">glsControl</a></code>.</p>
</td></tr>
<tr><td><code id="gls-internal_+3A_control">control</code></td>
<td>
<p>The relevant part of a <code><a href="#topic+glsControl">glsControl</a></code> return value.</p>
</td></tr>
</table>

<hr>
<h2 id='glsControl'>Control Values for gls Fit</h2><span id='topic+glsControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a
list with all possible arguments is returned. The returned list is
used as the <code>control</code> argument to the <code>gls</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsControl(maxIter, msMaxIter, tolerance, msTol, msVerbose,
           singular.ok, returnObject = FALSE, apVar, .relStep,
           opt = c("nlminb", "optim"), optimMethod,
           minAbsParApVar, natural, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glsControl_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the <code>gls</code>
optimization algorithm. Default is 50.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations
for the <code>opt</code>imization step inside the <code>gls</code>
optimization. Default is 50.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the convergence criterion in the
<code>gls</code> algorithm. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_mstol">msTol</code></td>
<td>
<p>tolerance for the convergence criterion of the first outer
iteration when <code>optim</code> is used.  Default is 1e-7.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_msverbose">msVerbose</code></td>
<td>
<p>a logical value passed as the <code>trace</code> control value to
the chosen <code>opt</code>imizer (see documentation on that function). Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_singular.ok">singular.ok</code></td>
<td>
<p>a logical value indicating whether non-estimable
coefficients (resulting from linear dependencies among the columns of
the regression matrix) should be allowed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_returnobject">returnObject</code></td>
<td>
<p>a logical value indicating whether the fitted
object should be returned when the maximum number of iterations is
reached without convergence of the algorithm. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_apvar">apVar</code></td>
<td>
<p>a logical value indicating whether the approximate
covariance matrix of the variance-covariance parameters should be
calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_.relstep">.relStep</code></td>
<td>
<p>relative step for numerical derivatives
calculations. Default is <code>.Machine$double.eps^(1/3)</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_opt">opt</code></td>
<td>
<p>the optimizer to be used, either <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code> (the
current default) or <code>"<a href="stats.html#topic+optim">optim</a>"</code> (the previous default).</p>
</td></tr>
<tr><td><code id="glsControl_+3A_optimmethod">optimMethod</code></td>
<td>
<p>character - the optimization method to be used with
the <code><a href="stats.html#topic+optim">optim</a></code> optimizer. The default is
<code>"BFGS"</code>.  An alternative is <code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_minabsparapvar">minAbsParApVar</code></td>
<td>
<p>numeric value - minimum absolute parameter value
in the approximate variance calculation.  The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_natural">natural</code></td>
<td>
<p>logical.  Should the natural parameterization be used
for the approximate variance calculations?  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="glsControl_+3A_sigma">sigma</code></td>
<td>
<p>optionally a positive number to fix the residual error at.
If <code>NULL</code>, as by default, or <code>0</code>, sigma is estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>; the
<code>sigma</code> option: Siem Heisterkamp and Bert van Willigen.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># decrease the maximum number of iterations and request tracing
glsControl(msMaxIter = 20, msVerbose = TRUE)
</code></pre>

<hr>
<h2 id='glsObject'>Fitted gls Object</h2><span id='topic+glsObject'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+gls">gls</a></code> function, inheriting from class
<code>"gls"</code> and representing a generalized least squares fitted linear 
model. Objects of this class have methods for the generic functions 
<code>anova</code>, <code>coef</code>, <code>fitted</code>, <code>formula</code>,
<code>getGroups</code>, <code>getResponse</code>, <code>intervals</code>, <code>logLik</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>residuals</code>,
<code>summary</code>, and <code>update</code>.   
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>"gls"</code>
object. 
</p>
<table>
<tr><td><code>apVar</code></td>
<td>
<p>an approximate covariance matrix for the
variance-covariance coefficients. If <code>apVar = FALSE</code> in the list
of control values used in the call to <code>gls</code>, this
component is equal to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>gls</code> call that
produced the object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a vector with the estimated linear model
coefficients.</p>
</td></tr> 
<tr><td><code>contrasts</code></td>
<td>
<p>a list of the contrast matrices used to represent factors
in the model formula. This information is important for making
predictions from a new data frame in which not all levels of the
original factors are observed. If no factors are used in the model,
this component will be an empty list.</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>a list with basic dimensions used in the model fit,
including the components <code>N</code> - the number of observations in
the data and <code>p</code> - the number of coefficients in the linear
model.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector with the fitted values.</p>
</td></tr>
<tr><td><code>modelStruct</code></td>
<td>
<p>an object inheriting from class <code>glsStruct</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector with the correlation structure grouping factor,
if any is present.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the estimation method: either <code>"ML"</code> for maximum
likelihood, or <code>"REML"</code> for restricted maximum likelihood.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>the number of iterations used in the iterative
algorithm.</p>
</td></tr> 
<tr><td><code>residuals</code></td>
<td>
<p>a vector with the residuals.</p>
</td></tr> 
<tr><td><code>sigma</code></td>
<td>
<p>the estimated residual standard error.</p>
</td></tr>
<tr><td><code>varBeta</code></td>
<td>
<p>an approximate covariance matrix of the
coefficients estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+glsStruct">glsStruct</a></code></p>

<hr>
<h2 id='glsStruct'>Generalized Least Squares Structure</h2><span id='topic+glsStruct'></span>

<h3>Description</h3>

<p>A generalized least squares structure is a list of model components
representing different sets of parameters in the linear 
model. A <code>glsStruct</code>  may contain <code>corStruct</code> and
<code>varFunc</code> objects. <code>NULL</code> arguments are not included in the
<code>glsStruct</code> list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsStruct(corStruct, varStruct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glsStruct_+3A_corstruct">corStruct</code></td>
<td>
<p>an optional <code>corStruct</code> object, representing a
correlation structure. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="glsStruct_+3A_varstruct">varStruct</code></td>
<td>
<p>an optional <code>varFunc</code> object, representing a
variance function structure. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of model variance-covariance components determining the
parameters to be estimated for the associated linear model.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+residuals.glsStruct">residuals.glsStruct</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>gls1 &lt;- glsStruct(corAR1(), varPower())
</code></pre>

<hr>
<h2 id='Glucose'>Glucose levels over time</h2><span id='topic+Glucose'></span>

<h3>Description</h3>

<p>The <code>Glucose</code> data frame has 378 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>an ordered factor with levels
<code>6</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>5</code> &lt; <code>1</code> &lt; <code>4</code>
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector of glucose levels
</p>
</dd>
<dt>Meal</dt><dd>
<p>an ordered factor with levels
<code>2am</code> &lt; <code>6am</code> &lt; <code>10am</code> &lt; <code>2pm</code> &lt; <code>6pm</code> &lt; <code>10pm</code>
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Hand, D. and Crowder, M. (1996), <em>Practical Longitudinal Data
Analysis</em>, Chapman and Hall, London.
</p>

<hr>
<h2 id='Glucose2'>Glucose Levels Following Alcohol Ingestion</h2><span id='topic+Glucose2'></span>

<h3>Description</h3>

<p>The <code>Glucose2</code> data frame has 196 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>a factor with levels
<code>1</code> to <code>7</code> identifying the subject whose glucose
level is measured. 
</p>
</dd>
<dt>Date</dt><dd>
<p>a factor with levels
<code>1</code> 
<code>2</code>
indicating the occasion in which the experiment was conducted.
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector giving the time since alcohol ingestion (in min/10).
</p>
</dd>
<dt>glucose</dt><dd>
<p>a numeric vector giving the blood glucose level (in mg/dl).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hand and Crowder (Table A.14, pp. 180-181, 1996) describe data on
the blood glucose levels measured at 14 time points over 5 hours for 7
volunteers who took alcohol at time 0. The same experiment was
repeated on a second date with the same subjects but with a dietary
additive used for all subjects.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.10)
</p>
<p>Hand, D. and Crowder, M. (1996), <em>Practical Longitudinal Data
Analysis</em>, Chapman and Hall, London.
</p>

<hr>
<h2 id='gnls'>Fit Nonlinear Model Using Generalized Least Squares</h2><span id='topic+gnls'></span>

<h3>Description</h3>

<p>This function fits a nonlinear model using generalized least
squares. The errors are allowed to be correlated and/or have unequal
variances.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnls(model, data, params, start, correlation, weights, subset,
     na.action, naPattern, control, verbose)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnls_+3A_model">model</code></td>
<td>
<p>a two-sided formula object describing the
model, with the response on the left of a <code>~</code> operator and 
a nonlinear expression involving parameters and covariates on the
right. If <code>data</code> is given, all names used in the formula should
be defined as parameters or variables in the data frame.</p>
</td></tr> 
<tr><td><code id="gnls_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>model</code>, <code>correlation</code>, <code>weights</code>, 
<code>subset</code>, and <code>naPattern</code>. By default the variables are 
taken from the environment from which <code>gnls</code> is called.</p>
</td></tr>
<tr><td><code id="gnls_+3A_params">params</code></td>
<td>
<p>an optional two-sided linear formula of the form
<code>p1+...+pn~x1+...+xm</code>, or list of two-sided formulas of the form
<code>p1~x1+...+xm</code>, with possibly different models for each
parameter. The <code>p1,...,pn</code> represent parameters included on the
right hand side of <code>model</code> and <code>x1+...+xm</code> define a linear
model for the parameters (when the left hand side of the formula
contains several parameters, they are all assumed to follow the same
linear model described by the right hand side expression). A <code>1</code>
on the right hand side of the formula(s) indicates a single fixed
effects for the corresponding parameter(s). By default, the
parameters are obtained from the names of <code>start</code>.</p>
</td></tr> 
<tr><td><code id="gnls_+3A_start">start</code></td>
<td>
<p>an optional named list, or numeric vector, with the
initial values for the parameters in <code>model</code>. It can be omitted
when a <code>selfStarting</code> function is used in <code>model</code>, in which
case the starting estimates will be obtained from a single call to the
<code>nls</code> function.</p>
</td></tr>
<tr><td><code id="gnls_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code>corStruct</code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. If a grouping variable is to be used, it must be specified
in the <code>form</code> argument to the <code>corStruct</code>
constructor. Defaults to <code>NULL</code>, corresponding to uncorrelated 
errors.</p>
</td></tr>  
<tr><td><code id="gnls_+3A_weights">weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
errors.</p>
</td></tr> 
<tr><td><code id="gnls_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating which subset of the rows of
<code>data</code> should  be  used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="gnls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>gnls</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="gnls_+3A_napattern">naPattern</code></td>
<td>
<p>an expression or formula object, specifying which returned
values are to be regarded as missing.</p>
</td></tr>
<tr><td><code id="gnls_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code>gnlsControl</code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="gnls_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.</p>
</td></tr>


</table>


<h3>Value</h3>

<p>an object of class <code>gnls</code>, also inheriting from class <code>gls</code>,
representing the nonlinear model fit. Generic functions such as
<code>print</code>, <code>plot</code> and  <code>summary</code> have methods to show the
results of the fit. See <code>gnlsObject</code> for the components of the
fit. The functions <code>resid</code>, <code>coef</code>, and <code>fitted</code> can be
used to extract some of its components.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The different correlation structures available for the
<code>correlation</code> argument are described in Box, G.E.P., Jenkins,
G.M., and Reinsel G.C. (1994), Littel, R.C., Milliken, G.A., Stroup,
W.W., and Wolfinger, R.D. (1996), and Venables, W.N. and Ripley,
B.D. (2002). The use of variance functions for linear 
and nonlinear models is presented in detail in Carrol, R.J. and Rupert,
D. (1988) and Davidian, M. and Giltinan, D.M. (1995).  
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Carrol, R.J. and Rupert, D. (1988) &quot;Transformation and Weighting in
Regression&quot;, Chapman and Hall.
</p>
<p>Davidian, M. and Giltinan, D.M. (1995) &quot;Nonlinear Mixed Effects Models
for Repeated Measurement Data&quot;, Chapman and Hall.
</p>
<p>Littel, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996)
&quot;SAS Systems for Mixed Models&quot;, SAS Institute.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+gnlsControl">gnlsControl</a></code>, <code><a href="#topic+gnlsObject">gnlsObject</a></code>,
<code><a href="#topic+gnlsStruct">gnlsStruct</a></code>,
<code><a href="#topic+predict.gnls">predict.gnls</a></code>,
<code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># variance increases with a power of the absolute fitted values
fm1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean,
            weights = varPower())
summary(fm1)
</code></pre>

<hr>
<h2 id='gnlsControl'>Control Values for gnls Fit</h2><span id='topic+gnlsControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a
list with all possible arguments is returned. The returned list is
used as the <code>control</code> argument to the <code>gnls</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlsControl(maxIter = 50, nlsMaxIter = 7, msMaxIter = 50, minScale = 0.001,
            tolerance = 1e-6, nlsTol = 0.001, msTol = 1e-7,
            returnObject = FALSE, msVerbose = FALSE,
            apVar = TRUE, .relStep =,
            opt = c("nlminb", "optim"), optimMethod = "BFGS",
            minAbsParApVar = 0.05, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlsControl_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the <code>gnls</code>
optimization algorithm.  Default is 50.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_nlsmaxiter">nlsMaxIter</code></td>
<td>
<p>maximum number of iterations
for the <code>nls</code> optimization step <em>inside</em> the <code>gnls</code>
optimization.  Default is 7.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations
for the <code>opt</code>imization step inside the <code>gnls</code>
optimization.  Default is 50.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_minscale">minScale</code></td>
<td>
<p>minimum factor by which to shrink the default step size
in an attempt to decrease the sum of squares in the <code>nls</code> step.
Default 0.001.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the convergence criterion in the
<code>gnls</code> algorithm. Default is 1e-6.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_nlstol">nlsTol</code></td>
<td>
<p>tolerance for the convergence criterion in <code>nls</code>
step. Default is 1e-3.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_mstol">msTol</code></td>
<td>
<p>tolerance for the convergence criterion of the first outer
iteration when <code>optim</code> is used.  Default is 1e-7.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_returnobject">returnObject</code></td>
<td>
<p>a logical value indicating whether the fitted
object should be returned with a <code><a href="base.html#topic+warning">warning</a></code> (instead of an
error via <code><a href="base.html#topic+stop">stop</a>()</code>) when the maximum number of
iterations is reached without convergence of the algorithm.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_msverbose">msVerbose</code></td>
<td>
<p>a logical value passed as the <code>trace</code> argument to
the optimizer chosen by <code>opt</code>; see documentation on that.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_apvar">apVar</code></td>
<td>
<p>a logical value indicating whether the approximate
covariance matrix of the variance-covariance parameters should be
calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_.relstep">.relStep</code></td>
<td>
<p>relative step for numerical derivatives
calculations.  Default is <code>.Machine$double.eps^(1/3)</code> (about 6e-6).</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_opt">opt</code></td>
<td>
<p>the optimizer to be used, either <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code> (the
current default) or <code>"<a href="stats.html#topic+optim">optim</a>"</code> (the previous default).</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_optimmethod">optimMethod</code></td>
<td>
<p>character - the optimization method to be used with
the <code><a href="stats.html#topic+optim">optim</a></code> optimizer. The default is
<code>"BFGS"</code>.  An alternative is <code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_minabsparapvar">minAbsParApVar</code></td>
<td>
<p>numeric value - minimum absolute parameter value
in the approximate variance calculation.  The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="gnlsControl_+3A_sigma">sigma</code></td>
<td>
<p>optionally a positive number to fix the residual error at.
If <code>NULL</code>, as by default, or <code>0</code>, sigma is estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>; the
<code>sigma</code> option: Siem Heisterkamp and Bert van Willigen.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># decrease the maximum number of iterations and request tracing
gnlsControl(msMaxIter = 20, msVerbose = TRUE)
</code></pre>

<hr>
<h2 id='gnlsObject'>Fitted gnls Object</h2><span id='topic+gnlsObject'></span>

<h3>Description</h3>

<p>An object returned by the <code>gnls</code> function, inheriting from class
<code>"gnls"</code> and also from class <code>"gls"</code>, and representing a
generalized nonlinear least squares fitted model. Objects of this
class have methods for the generic functions  <code>anova</code>,
<code>coef</code>, <code>fitted</code>, <code>formula</code>, <code>getGroups</code>,
<code>getResponse</code>, <code>intervals</code>, <code>logLik</code>, <code>plot</code>,
<code>predict</code>, <code>print</code>, <code>residuals</code>, <code>summary</code>, and
<code>update</code>.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>"gnls"</code>
object.
</p>
<table>
<tr><td><code>apVar</code></td>
<td>
<p>an approximate covariance matrix for the
variance-covariance coefficients.  If <code>apVar = FALSE</code> in the
control values used in the call to <code>gnls</code>, this
component is equal to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>gnls</code> call that
produced the object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a vector with the estimated nonlinear model
coefficients.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list of the contrast matrices used to represent factors
in the model formula. This information is important for making
predictions from a new data frame in which not all levels of the
original factors are observed. If no factors are used in the model,
this component will be an empty list.</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>a list with basic dimensions used in the model fit,
including the components <code>N</code> - the number of observations used in
the fit and <code>p</code> - the number of coefficients in the nonlinear
model.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a vector with the fitted values.</p>
</td></tr>
<tr><td><code>modelStruct</code></td>
<td>
<p>an object inheriting from class <code>gnlsStruct</code>,
representing a list of model components, such as <code>corStruct</code> and
<code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a vector with the correlation structure grouping factor,
if any is present.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>the number of iterations used in the iterative
algorithm.</p>
</td></tr>
<tr><td><code>plist</code></td>
<td>
</td></tr>
<tr><td><code>pmap</code></td>
<td>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector with the residuals.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the estimated residual standard error.</p>
</td></tr>
<tr><td><code>varBeta</code></td>
<td>
<p>an approximate covariance matrix of the
coefficients estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>, <code>gnlsStruct</code></p>

<hr>
<h2 id='gnlsStruct'>Generalized Nonlinear Least Squares Structure</h2><span id='topic+gnlsStruct'></span><span id='topic+Initialize.gnlsStruct'></span>

<h3>Description</h3>

<p>A generalized nonlinear least squares structure is a list of model
components representing different sets of parameters in the nonlinear 
model. A <code>gnlsStruct</code>  may contain <code>corStruct</code> and
<code>varFunc</code> objects. <code>NULL</code> arguments are not included in the
<code>gnlsStruct</code> list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlsStruct(corStruct, varStruct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlsStruct_+3A_corstruct">corStruct</code></td>
<td>
<p>an optional <code>corStruct</code> object, representing a
correlation structure. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gnlsStruct_+3A_varstruct">varStruct</code></td>
<td>
<p>an optional <code>varFunc</code> object, representing a
variance function structure. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of model variance-covariance components determining the
parameters to be estimated for the associated nonlinear model.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>, <code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+residuals.gnlsStruct">residuals.gnlsStruct</a></code>
<code><a href="#topic+varFunc">varFunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnls1 &lt;- gnlsStruct(corAR1(), varPower())
</code></pre>

<hr>
<h2 id='groupedData'>Construct a groupedData Object</h2><span id='topic+groupedData'></span><span id='topic++5B.groupedData'></span><span id='topic+as.data.frame.groupedData'></span><span id='topic+update.groupedData'></span>

<h3>Description</h3>

<p>An object of the <code>groupedData</code> class is constructed from the
<code>formula</code> and <code>data</code> by attaching the <code>formula</code> as an
attribute of the data, along with any of <code>outer</code>, <code>inner</code>,
<code>labels</code>, and <code>units</code> that are given.  If
<code>order.groups</code> is <code>TRUE</code> the grouping factor is converted to
an ordered factor with the ordering determined by
<code>FUN</code>. Depending on the number of grouping levels and the type of
primary covariate, the returned object will be of one of three
classes: <code>nfnGroupedData</code> - numeric covariate, single level of
nesting; <code>nffGroupedData</code> - factor covariate, single level of
nesting; and <code>nmGroupedData</code> - multiple levels of
nesting. Several modeling and plotting functions can use the formula
stored with a <code>groupedData</code> object to construct default plots and
models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupedData(formula, data, order.groups, FUN, outer, inner,
            labels, units)

## S3 method for class 'groupedData'
update(object, formula, data, order.groups, FUN,
       outer, inner, labels, units, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupedData_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>groupedData</code>.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>resp ~ cov | group</code> where
<code>resp</code> is the response, <code>cov</code> is the primary covariate, and
<code>group</code> is the grouping factor.  The expression <code>1</code> can be
used for the primary covariate when there is no other suitable
candidate.  Multiple nested grouping factors can be listed separated
by the <code>/</code> symbol as in <code>fact1/fact2</code>.  In an expression
like this the <code>fact2</code> factor is nested within the <code>fact1</code>
factor.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_data">data</code></td>
<td>
<p>a data frame in which the expressions in <code>formula</code> can
be evaluated.  The resulting <code>groupedData</code> object will consist
of the same data values in the same order but with additional
attributes.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_order.groups">order.groups</code></td>
<td>
<p>an optional logical value, or list of logical
values, indicating if the grouping factors should be converted to
ordered factors according to the function <code>FUN</code> applied to the
response from each group. If multiple levels of grouping are present,
this argument can be either a single logical value (which will be
repeated for all grouping levels) or a list of logical values. If no
names are assigned to the list elements, they are assumed in the same
order as the group levels (outermost to innermost grouping). Ordering
within a level of grouping is done within the levels of the grouping
factors which are outer to it. Changing the grouping factor to an
ordered factor does not affect the ordering of the rows in the data
frame but it does affect the order of the panels in a trellis display
of the data or models fitted to the data.  Defaults to <code>TRUE</code>.</p>
</td></tr>  
<tr><td><code id="groupedData_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function that will be applied to the
values of the response for each level of the grouping factor, when
<code>order.groups = TRUE</code>, to determine the ordering.  Defaults to
the <code>max</code> function.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_outer">outer</code></td>
<td>
<p>an optional one-sided formula, or list of one-sided
formulas, indicating covariates that are outer to the grouping
factor(s).  If multiple levels of grouping are present,
this argument can be either a single one-sided formula, or a list of
one-sided formulas. If no names are assigned to the list elements,
they are assumed in the same order as the group levels (outermost to
innermost grouping). An outer covariate is invariant within the sets
of rows defined by the grouping factor.  Ordering of the groups is
done in such a way as to preserve adjacency of groups with the same
value of the outer variables.  When plotting a  groupedData object,
the argument <code>outer = TRUE</code> causes the panels to be determined
by the <code>outer</code> formula.  The points within the panels are 
associated by level of the grouping factor. Defaults to <code>NULL</code>,
meaning that no outer covariates are present.</p>
</td></tr> 
<tr><td><code id="groupedData_+3A_inner">inner</code></td>
<td>
<p>an optional one-sided formula, or list of one-sided
formulas, indicating covariates that are inner to the grouping
factor(s). If multiple levels of grouping are present,
this argument can be either a single one-sided formula, or a list of
one-sided formulas. If no names are assigned to the list elements,
they are assumed in the same order as the group levels (outermost to
innermost grouping). An inner covariate can change 
within the sets of rows defined by the grouping factor.  An inner
formula can be used to associate points in a plot of a groupedData
object.  Defaults to <code>NULL</code>, meaning that no inner covariates
are present.</p>
</td></tr> 
<tr><td><code id="groupedData_+3A_labels">labels</code></td>
<td>
<p>an optional list of character strings giving labels for
the response and the primary covariate.  The label for the primary
covariate is named <code>x</code> and that for the response is named
<code>y</code>.  Either label can be omitted.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_units">units</code></td>
<td>
<p>an optional list of character strings giving the units for
the response and the primary covariate.  The units string for the
primary covariate is named <code>x</code> and that for the response is
named <code>y</code>.  Either units string can be omitted.</p>
</td></tr>
<tr><td><code id="groupedData_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object of one of the classes <code>nfnGroupedData</code>,
<code>nffGroupedData</code>, or <code>nmGroupedData</code>, and also inheriting
from  classes <code>groupedData</code> and <code>data.frame</code>. 
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and José Pinheiro</p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1997), &quot;Software Design for Longitudinal
Data&quot;, in &quot;Modelling Longitudinal and Spatially Correlated Data:
Methods, Applications and Future Directions&quot;, T.G. Gregoire (ed.),
Springer-Verlag, New York.
</p>
<p>Pinheiro, J.C. and Bates, D.M. (1997) &quot;Future Directions in
Mixed-Effects Software: Design of NLME 3.0&quot; available at
http://nlme.stat.wisc.edu/ 
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="#topic+gapply">gapply</a></code>,
<code><a href="#topic+gsummary">gsummary</a></code>,
<code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+plot.nffGroupedData">plot.nffGroupedData</a></code>,
<code><a href="#topic+plot.nfnGroupedData">plot.nfnGroupedData</a></code>,
<code><a href="#topic+plot.nmGroupedData">plot.nmGroupedData</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Orth.new &lt;-  # create a new copy of the groupedData object
  groupedData( distance ~ age | Subject,
              data = as.data.frame( Orthodont ),
              FUN = mean,
              outer = ~ Sex,
              labels = list( x = "Age",
                y = "Distance from pituitary to pterygomaxillary fissure" ),
              units = list( x = "(yr)", y = "(mm)") )
plot( Orth.new )         # trellis plot by Subject
formula( Orth.new )      # extractor for the formula
gsummary( Orth.new )     # apply summary by Subject
fm1 &lt;- lme( Orth.new )   # fixed and groups formulae extracted from object
Orthodont2 &lt;- update(Orthodont, FUN = mean)
</code></pre>

<hr>
<h2 id='gsummary'>Summarize by Groups</h2><span id='topic+gsummary'></span>

<h3>Description</h3>

<p>Provide a summary of the variables in a data frame by groups of rows.
This is most useful with a <code>groupedData</code> object to examine the
variables by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsummary(object, FUN, omitGroupingFactor, form, level,
   groups, invariantsOnly, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsummary_+3A_object">object</code></td>
<td>
<p>an object to be summarized - usually a <code>groupedData</code>
object or a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="gsummary_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be applied to each variable in the frame.  The function or
functions are applied only to variables in <code>object</code> that vary
within the groups defined by <code>groups</code>.  Invariant variables are
always summarized by group using the unique value that they assume
within that group.  If <code>FUN</code> is a single
function it will be applied to each non-invariant variable by group
to produce the summary for that variable.  If <code>FUN</code> is a list of
functions, the names in the list should designate classes of
variables in the frame such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
non-invariant variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.
</p>
</td></tr>
<tr><td><code id="gsummary_+3A_omitgroupingfactor">omitGroupingFactor</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code>
the grouping factor itself will be omitted from the group-wise
summary but the levels of the grouping factor will continue to be
used as the row names for the data frame that is produced by the
summary. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gsummary_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula that defines the groups.
When this formula is given, the right-hand side is evaluated in
<code>object</code>, converted to a factor if necessary, and the unique
levels are used to define the groups.  Defaults to
<code>formula(object)</code>.
</p>
</td></tr> 
<tr><td><code id="gsummary_+3A_level">level</code></td>
<td>
<p>an optional positive integer giving the level of grouping
to be used in an object with multiple nested grouping levels.
Defaults to the highest or innermost level of grouping.</p>
</td></tr>
<tr><td><code id="gsummary_+3A_groups">groups</code></td>
<td>
<p>an optional factor that will be used to split the 
rows into groups.  Defaults to <code>getGroups(object, form, level)</code>.
</p>
</td></tr>
<tr><td><code id="gsummary_+3A_invariantsonly">invariantsOnly</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code> only 
those covariates that are invariant within each group will be
summarized.  The summary value for the group is always the unique
value taken on by that covariate within the group.  The columns in
the summary are of the same class as the corresponding columns in
<code>object</code>. By definition, the grouping factor itself must be an
invariant.   When combined with <code>omitGroupingFactor = TRUE</code>,
this option can be used to discover is there are invariant covariates 
in the data frame.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gsummary_+3A_...">...</code></td>
<td>
<p>optional additional arguments to the summary functions
that are invoked on the variables by group.  Often it is helpful to
specify <code>na.rm = TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row for each level of the grouping
factor.  The number of columns is at most the number of columns in
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+groupedData">groupedData</a></code>,
<code><a href="#topic+getGroups">getGroups</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>gsummary(Orthodont)  # default summary by Subject
## gsummary with invariantsOnly = TRUE and omitGroupingFactor = TRUE
## determines whether there are covariates like Sex that are invariant
## within the repeated observations on the same Subject.
gsummary(Orthodont, inv = TRUE, omit = TRUE)
</code></pre>

<hr>
<h2 id='Gun'>Methods for firing naval guns</h2><span id='topic+Gun'></span>

<h3>Description</h3>

<p>The <code>Gun</code> data frame has 36 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>rounds</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Method</dt><dd>
<p>a factor with levels
<code>M1</code> 
<code>M2</code> 
</p>
</dd>
<dt>Team</dt><dd>
<p>an ordered factor with levels
<code>T1S</code> &lt; <code>T3S</code> &lt; <code>T2S</code> &lt; <code>T1A</code> &lt;
<code>T2A</code> &lt; <code>T3A</code> &lt; <code>T1H</code> &lt; <code>T3H</code> &lt;
<code>T2H</code>
</p>
</dd>
<dt>Physique</dt><dd>
<p>an ordered factor with levels
<code>Slight</code> &lt; <code>Average</code> &lt; <code>Heavy</code>
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Hicks (p.180, 1993) reports data from an experiment on
methods for firing naval guns. Gunners of three different physiques
(slight, average, and heavy) tested two firing methods. Both methods
were tested twice by each of nine teams of three gunners with
identical physique. The response was the number of rounds fired per
minute.</p>


<h3>Source</h3>

<p>Hicks, C. R. (1993), <em>Fundamental Concepts in the Design of
Experiments (4th ed)</em>, Harcourt Brace, New York.
</p>

<hr>
<h2 id='IGF'>Radioimmunoassay of IGF-I Protein</h2><span id='topic+IGF'></span>

<h3>Description</h3>

<p>The <code>IGF</code> data frame has 237 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Lot</dt><dd>
<p>an ordered factor giving the radioactive tracer lot.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector giving the age (in days) of the radioactive
tracer.
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the estimated concentration of IGF-I
protein (ng/ml)
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Davidian and Giltinan (1995) describe data obtained during quality
control radioimmunoassays for ten different lots of radioactive
tracer used to calibrate the Insulin-like Growth Factor (IGF-I)
protein concentration measurements. 
</p>


<h3>Source</h3>

<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.
</p>
<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.11)
</p>

<hr>
<h2 id='Initialize'>Initialize Object</h2><span id='topic+Initialize'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>corStruct</code>, <code>lmeStruct</code>,
<code>reStruct</code>, and <code>varFunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Initialize(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize_+3A_object">object</code></td>
<td>
<p>any object requiring initialization, e.g. &quot;plug-in&quot;
structures such as <code>corStruct</code> and <code>varFunc</code> objects. </p>
</td></tr>
<tr><td><code id="Initialize_+3A_data">data</code></td>
<td>
<p>a data frame to be used in the initialization procedure.</p>
</td></tr>
<tr><td><code id="Initialize_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an initialized object with the same class as <code>object</code>. Changes
introduced by the initialization procedure will depend on the method
function used; see the appropriate documentation. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+Initialize.lmeStruct">Initialize.lmeStruct</a></code>,
<code><a href="#topic+Initialize.glsStruct">Initialize.glsStruct</a></code>, 
<code><a href="#topic+Initialize.varFunc">Initialize.varFunc</a></code>, 
<code><a href="#topic+isInitialized">isInitialized</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='Initialize.corStruct'>Initialize corStruct Object</h2><span id='topic+Initialize.corStruct'></span><span id='topic+Initialize.corAR1'></span><span id='topic+Initialize.corARMA'></span><span id='topic+Initialize.corCAR1'></span><span id='topic+Initialize.corCompSymm'></span><span id='topic+Initialize.corHF'></span><span id='topic+Initialize.corLin'></span><span id='topic+Initialize.corNatural'></span><span id='topic+Initialize.corSpatial'></span><span id='topic+Initialize.corSpher'></span><span id='topic+Initialize.corSymm'></span>

<h3>Description</h3>

<p>This method initializes <code>object</code> by evaluating its associated
covariate(s) and grouping factor, if any is present, in <code>data</code>,
calculating various dimensions and constants used by optimization
algorithms involving <code>corStruct</code> objects (see the appropriate
<code>Dim</code> method documentation), and assigning initial values for
the coefficients in <code>object</code>, if none were present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
Initialize(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="Initialize.corStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="Initialize.corStruct_+3A_...">...</code></td>
<td>
<p>this argument is included to make this method compatible
with the generic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an initialized object with the same class as <code>object</code>
representing a correlation structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dim.corStruct">Dim.corStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(form = ~ 1 | Subject)
cs1 &lt;- Initialize(cs1, data = Orthodont)
</code></pre>

<hr>
<h2 id='Initialize.glsStruct'>Initialize a glsStruct Object</h2><span id='topic+Initialize.glsStruct'></span>

<h3>Description</h3>

<p>The individual linear model components of the <code>glsStruct</code> list
are initialized.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsStruct'
Initialize(object, data, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.glsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+glsStruct">glsStruct</a>"</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="Initialize.glsStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="Initialize.glsStruct_+3A_control">control</code></td>
<td>
<p>an optional list with control parameters for the
initialization and optimization algorithms used in
<code>gls</code>. Defaults to <code>list(singular.ok = FALSE)</code>, implying that linear dependencies are not allowed in the model.</p>
</td></tr>
<tr><td><code id="Initialize.glsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>glsStruct</code> object similar to <code>object</code>, but with
initialized model components. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+Initialize.varFunc">Initialize.varFunc</a></code>,
<code><a href="#topic+Initialize">Initialize</a></code></p>

<hr>
<h2 id='Initialize.lmeStruct'>Initialize an lmeStruct Object</h2><span id='topic+Initialize.lmeStruct'></span>

<h3>Description</h3>

<p>The individual linear mixed-effects model components of the
<code>lmeStruct</code> list are initialized. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmeStruct'
Initialize(object, data, groups, conLin, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.lmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmeStruct">lmeStruct</a>"</code>,
representing a list of linear mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="Initialize.lmeStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="Initialize.lmeStruct_+3A_groups">groups</code></td>
<td>
<p>a data frame with the grouping factors corresponding to
the lme model associated with <code>object</code> as columns, sorted from
innermost to outermost grouping level.</p>
</td></tr>
<tr><td><code id="Initialize.lmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying lme model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="Initialize.lmeStruct_+3A_control">control</code></td>
<td>
<p>an optional list with control parameters for the
initialization and optimization algorithms used in
<code>lme</code>. Defaults to <code>list(niterEM=20, gradHess=TRUE)</code>,
implying that 20 EM iterations are to be used in the derivation of
initial estimates for the coefficients of the <code>reStruct</code>
component of <code>object</code> and, if possible, numerical gradient
vectors and Hessian matrices for the log-likelihood function are to
be used in the optimization algorithm.</p>
</td></tr>
<tr><td><code id="Initialize.lmeStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an <code>lmeStruct</code> object similar to <code>object</code>, but with
initialized model components. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+Initialize.reStruct">Initialize.reStruct</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="#topic+Initialize.varFunc">Initialize.varFunc</a></code>, <code><a href="#topic+Initialize">Initialize</a></code>
</p>

<hr>
<h2 id='Initialize.reStruct'>Initialize reStruct Object</h2><span id='topic+Initialize.reStruct'></span>

<h3>Description</h3>

<p>Initial estimates for the parameters in the <code>pdMat</code> objects
forming <code>object</code>, which have not yet been initialized, are
obtained using the methodology described in Bates and Pinheiro
(1998). These estimates may be refined using a series of EM
iterations, as described in Bates and Pinheiro (1998). The number of
EM iterations to be used is defined in <code>control</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
Initialize(object, data, conLin, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="Initialize.reStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="Initialize.reStruct_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr> 
<tr><td><code id="Initialize.reStruct_+3A_control">control</code></td>
<td>
<p>an optional list with a single component <code>niterEM</code>
controlling the number of iterations for the EM algorithm used to
refine initial parameter estimates. It is given as a list for
compatibility with other <code>Initialize</code> methods. Defaults to
<code>list(niterEM = 20)</code>.</p>
</td></tr>
<tr><td><code id="Initialize.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an <code>reStruct</code> object similar to <code>object</code>, but with all
<code>pdMat</code> components initialized.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>, <code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+Initialize">Initialize</a></code>
</p>

<hr>
<h2 id='Initialize.varFunc'>Initialize varFunc Object</h2><span id='topic+Initialize.varFunc'></span><span id='topic+Initialize.varComb'></span><span id='topic+Initialize.varConstPower'></span><span id='topic+Initialize.varConstProp'></span><span id='topic+Initialize.varExp'></span><span id='topic+Initialize.varFixed'></span><span id='topic+Initialize.varIdent'></span><span id='topic+Initialize.varPower'></span>

<h3>Description</h3>

<p>This method initializes <code>object</code> by evaluating its associated
covariate(s) and grouping factor, if any is present, in <code>data</code>;
determining if the covariate(s) need to be updated when the
values of the coefficients associated with <code>object</code> change;
initializing the log-likelihood and the weights associated with
<code>object</code>; and assigning initial values for the coefficients in
<code>object</code>, if none were present. The covariate(s) will only be
initialized if no update is needed when <code>coef(object)</code> changes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
Initialize(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr> 
<tr><td><code id="Initialize.varFunc_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables named in
<code>formula(object)</code>. </p>
</td></tr>
<tr><td><code id="Initialize.varFunc_+3A_...">...</code></td>
<td>
<p>this argument is included to make this method compatible
with the generic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an initialized object with the same class as <code>object</code>
representing a variance function structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize">Initialize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower( form = ~ age | Sex )
vf1 &lt;- Initialize( vf1, Orthodont )
</code></pre>

<hr>
<h2 id='intervals'>Confidence Intervals on Coefficients</h2><span id='topic+intervals'></span>

<h3>Description</h3>

<p>Confidence intervals on the parameters associated with the model
represented by <code>object</code> are obtained. This function is generic;
method functions can be written to handle specific classes of
objects. Classes which already have methods for this function include:
<code>gls</code>, <code>lme</code>, and <code>lmList</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervals(object, level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals_+3A_object">object</code></td>
<td>
<p>a fitted model object from which parameter estimates can
be extracted.</p>
</td></tr>
<tr><td><code id="intervals_+3A_level">level</code></td>
<td>
<p>an optional numeric value for the interval confidence
level. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="intervals_+3A_...">...</code></td>
<td>
<p>some methods for the generic may require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervals.lme">intervals.lme</a></code>,
<code><a href="#topic+intervals.lmList">intervals.lmList</a></code>,
<code><a href="#topic+intervals.gls">intervals.gls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method documentation
</code></pre>

<hr>
<h2 id='intervals.gls'>Confidence Intervals on gls Parameters</h2><span id='topic+intervals.gls'></span><span id='topic+print.intervals.gls'></span>

<h3>Description</h3>

<p>Approximate confidence intervals for the parameters in the linear
model represented by <code>object</code> are obtained, using
a normal approximation to the distribution of the (restricted)
maximum likelihood estimators (the estimators are assumed to have a
normal distribution centered at the true parameter values and with
covariance matrix equal to the negative inverse Hessian matrix of the
(restricted) log-likelihood evaluated at the estimated parameters).
Confidence intervals are obtained in an unconstrained scale first,
using the normal approximation, and, if necessary, transformed to the
constrained scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
intervals(object, level, which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="intervals.gls_+3A_level">level</code></td>
<td>
<p>an optional numeric value for the interval confidence
level. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="intervals.gls_+3A_which">which</code></td>
<td>
<p>an optional character string specifying the subset
of parameters for which to construct the confidence
intervals. Possible values are <code>"all"</code> for all parameters,
<code>"var-cov"</code> for the variance-covariance parameters only, and
<code>"coef"</code> for the linear model coefficients  only. Defaults to
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="intervals.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by data frames with rows corresponding to
parameters and columns <code>lower</code>, <code>est.</code>, and <code>upper</code>
representing respectively lower confidence limits, the estimated
values, and upper confidence limits for the parameters. Possible
components are:
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>linear model coefficients, only present when <code>which</code>
is not equal to <code>"var-cov"</code>.</p>
</td></tr>
<tr><td><code>corStruct</code></td>
<td>
<p>correlation parameters, only present when
<code>which</code> is not equal to <code>"coef"</code> and a 
correlation structure is used in <code>object</code>.</p>
</td></tr>
<tr><td><code>varFunc</code></td>
<td>
<p>variance function parameters, only present when
<code>which</code> is not equal to <code>"coef"</code> and a variance function
structure is used in <code>object</code>.</p>
</td></tr> 
<tr><td><code>sigma</code></td>
<td>
<p>residual standard error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+intervals">intervals</a></code>,
<code><a href="#topic+print.intervals.gls">print.intervals.gls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
intervals(fm1)
</code></pre>

<hr>
<h2 id='intervals.lme'>Confidence Intervals on lme Parameters</h2><span id='topic+intervals.lme'></span><span id='topic+print.intervals.lme'></span>

<h3>Description</h3>

<p>Approximate confidence intervals for the parameters in the linear
mixed-effects model represented by <code>object</code> are obtained, using
a normal approximation to the distribution of the (restricted)
maximum likelihood estimators (the estimators are assumed to have a
normal distribution centered at the true parameter values and with
covariance matrix equal to the negative inverse Hessian matrix of the
(restricted) log-likelihood evaluated at the estimated parameters).
Confidence intervals are obtained in an unconstrained scale first,
using the normal approximation, and, if necessary, transformed to the
constrained scale. The <code>pdNatural</code> parametrization is used for
general positive-definite matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
intervals(object, level = 0.95,
          which = c("all", "var-cov", "fixed"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="intervals.lme_+3A_level">level</code></td>
<td>
<p>an optional numeric value with the confidence level for
the intervals.  Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="intervals.lme_+3A_which">which</code></td>
<td>
<p>an optional character string specifying the  subset
of parameters for which to construct the confidence
intervals. Possible values are <code>"all"</code> for all parameters,
<code>"var-cov"</code> for the variance-covariance parameters only, and
<code>"fixed"</code> for the fixed effects only.  Defaults to <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="intervals.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components given by data frames with rows corresponding to
parameters and columns <code>lower</code>, <code>est.</code>, and <code>upper</code>
representing respectively lower confidence limits, the estimated
values, and upper confidence limits for the parameters. Possible
components are:
</p>
<table>
<tr><td><code>fixed</code></td>
<td>
<p>fixed effects, only present when <code>which</code> is not
equal to <code>"var-cov"</code>.</p>
</td></tr>
<tr><td><code>reStruct</code></td>
<td>
<p>random effects variance-covariance parameters, only
present when <code>which</code> is not equal to <code>"fixed"</code>.</p>
</td></tr>
<tr><td><code>corStruct</code></td>
<td>
<p>within-group correlation parameters, only
present when <code>which</code> is not equal to <code>"fixed"</code> and a
correlation structure is used in <code>object</code>.</p>
</td></tr>
<tr><td><code>varFunc</code></td>
<td>
<p>within-group variance function parameters, only
present when <code>which</code> is not equal to <code>"fixed"</code> and a
variance function structure is used in <code>object</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>within-group standard deviation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+intervals">intervals</a></code>,
<code><a href="#topic+print.intervals.lme">print.intervals.lme</a></code>,
<code><a href="#topic+pdNatural">pdNatural</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
intervals(fm1)
</code></pre>

<hr>
<h2 id='intervals.lmList'>Confidence Intervals on lmList Coefficients</h2><span id='topic+intervals.lmList'></span><span id='topic+print.intervals.lmList'></span>

<h3>Description</h3>

<p>Confidence intervals on the linear model coefficients are obtained for
each <code>lm</code> component of <code>object</code> and organized into a three
dimensional array. The first dimension corresponding to the names
of the <code>object</code> components. The second dimension is given by
<code>lower</code>, <code>est.</code>, and <code>upper</code> corresponding,
respectively, to the lower confidence limit, estimated coefficient,
and upper confidence limit. The third dimension is given by the
coefficients names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
intervals(object, level = 0.95, pool = attr(object, "pool"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervals.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="intervals.lmList_+3A_level">level</code></td>
<td>
<p>an optional numeric value with the confidence level for
the intervals.  Defaults to 0.95.
</p>
</td></tr>
<tr><td><code id="intervals.lmList_+3A_pool">pool</code></td>
<td>
<p>an optional logical value indicating whether a pooled
estimate of the residual standard error should be used. Default is
<code>attr(object, "pool")</code>.
</p>
</td></tr>
<tr><td><code id="intervals.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a three dimensional array with the confidence intervals and estimates
for the coefficients of each <code>lm</code> component of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="#topic+intervals">intervals</a></code>,
<code><a href="#topic+plot.intervals.lmList">plot.intervals.lmList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
intervals(fm1)
</code></pre>

<hr>
<h2 id='isBalanced'>Check a Design for Balance</h2><span id='topic+isBalanced'></span><span id='topic+isBalanced.groupedData'></span>

<h3>Description</h3>

<p>Check the design of the experiment or study for balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isBalanced(object, countOnly, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isBalanced_+3A_object">object</code></td>
<td>
<p>A <code>groupedData</code> object containing a data frame and a
formula that describes the roles of variables in the data frame.  The
object will have one or more nested grouping factors and a primary
covariate.</p>
</td></tr>
<tr><td><code id="isBalanced_+3A_countonly">countOnly</code></td>
<td>
<p>A logical value indicating if the check for balance
should only consider the number of observations at each level of the
grouping factor(s).  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="isBalanced_+3A_level">level</code></td>
<td>
<p>an optional integer vector specifying the desired
prediction levels. Levels increase from outermost to innermost
grouping, with level 0 representing the population (fixed effects)
predictions. Defaults to the innermost level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A design is
balanced with respect to the grouping factor(s) if there are the same
number of observations at each distinct value of the grouping factor or
each combination of distinct levels of the nested grouping factors.  If
<code>countOnly</code> is <code>FALSE</code> the design is also checked for balance
with respect to the primary covariate, which is often the time of the
observation.  A design is balanced with respect to the grouping factor
and the covariate if the number of observations at each distinct level
(or combination of levels for nested factors) is constant and the times
at which the observations are taken (in general, the values of the
primary covariates) also are constant.
</p>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> according to whether the data are balanced
or not
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="#topic+groupedData">groupedData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>isBalanced(Orthodont)                    # should return TRUE
isBalanced(Orthodont, countOnly = TRUE)  # should return TRUE
isBalanced(Pixel)                        # should return FALSE
isBalanced(Pixel, level = 1)             # should return FALSE
</code></pre>

<hr>
<h2 id='isInitialized'>Check if Object is Initialized</h2><span id='topic+isInitialized'></span><span id='topic+isInitialized.pdMat'></span><span id='topic+isInitialized.pdBlocked'></span>

<h3>Description</h3>

<p>Checks if <code>object</code> has been initialized (generally through a call
to <code>Initialize</code>), by searching for components and attributes
which are modified during initialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isInitialized(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isInitialized_+3A_object">object</code></td>
<td>
<p>any object requiring initialization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether <code>object</code> has been
initialized. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>See Also</h3>

<p><code><a href="#topic+Initialize">Initialize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdDiag(~age)
isInitialized(pd1)
</code></pre>

<hr>
<h2 id='LDEsysMat'>Generate system matrix for LDEs</h2><span id='topic+LDEsysMat'></span>

<h3>Description</h3>

<p>Generate the system matrix for the linear differential equations
determined by a compartment model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDEsysMat(pars, incidence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDEsysMat_+3A_pars">pars</code></td>
<td>
<p>a numeric vector of parameter values.</p>
</td></tr>
<tr><td><code id="LDEsysMat_+3A_incidence">incidence</code></td>
<td>
<p>an integer matrix with columns named <code>From</code>,
<code>To</code>, and <code>Par</code>.  Values in the <code>Par</code> column must
be in the range 1 to <code>length(pars)</code>.  
Values in the <code>From</code>
column must be between 1 and the number of compartments.
Values in the <code>To</code>
column must be between 0 and the number of compartments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A compartment model describes material transfer between <code>k</code>
in a system of <code>k</code> compartments to a linear system of differential
equations. Given a description of the system and a vector of parameter
values this function returns the system matrix.
</p>
<p>This function is intended for use in a general system for solving
compartment models, as described in Bates and Watts (1988).
</p>


<h3>Value</h3>

<p>A <code>k</code> by <code>k</code> numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D. M. and Watts, D. G. (1988), <em>Nonlinear Regression
Analysis and Its Applications</em>, Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># incidence matrix for a two compartment open system
incidence &lt;-
  matrix(c(1,1,2,2,2,1,3,2,0), ncol = 3, byrow = TRUE,
   dimnames = list(NULL, c("Par", "From", "To")))
incidence
LDEsysMat(c(1.2, 0.3, 0.4), incidence)
</code></pre>

<hr>
<h2 id='lme'>Linear Mixed-Effects Models</h2><span id='topic+lme'></span><span id='topic+lme.formula'></span><span id='topic+update.lme'></span>

<h3>Description</h3>

<p>This generic function fits a linear mixed-effects model in the
formulation described in Laird and Ware (1982) but allowing for nested
random effects. The within-group errors are allowed to be correlated
and/or have unequal variances.
</p>
<p>This page describes the formula method;
the methods <code><a href="#topic+lme.lmList">lme.lmList</a></code> and <code><a href="#topic+lme.groupedData">lme.groupedData</a></code>
are documented separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lme(fixed, data, random, correlation, weights, subset, method,
    na.action, control, contrasts = NULL, keep.data = TRUE)

## S3 method for class 'formula'
lme(fixed, data, random, correlation, weights, subset, method,
    na.action, control, contrasts = NULL, keep.data = TRUE)

## S3 method for class 'lme'
update(object, fixed., ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lme</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="lme_+3A_fixed">fixed</code></td>
<td>
<p>a two-sided linear formula object describing the
fixed-effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on
the right, an <code>"<a href="#topic+lmList">lmList</a>"</code> object, or a
<code>"<a href="#topic+groupedData">groupedData</a>"</code> object.
</p>
<p>There is limited support for formulae such as <code>resp ~ 1</code> and
<code>resp ~ 0</code>, and less prior to version &lsquo;<span class="samp">&#8288;3.1-112&#8288;</span>&rsquo;.
</p>
</td></tr>
<tr><td><code id="lme_+3A_fixed.">fixed.</code></td>
<td>
<p>Changes to the fixed-effects formula &ndash; see
<code><a href="stats.html#topic+update.formula">update.formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="lme_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>fixed</code>, <code>random</code>, <code>correlation</code>, <code>weights</code>, and
<code>subset</code>.  By default the variables are taken from the
environment from which <code>lme</code> is called.</p>
</td></tr>
<tr><td><code id="lme_+3A_random">random</code></td>
<td>
<p>optionally, any of the following: (i) a one-sided formula
of the form <code>~ x1 + ... + xn | g1/.../gm</code>, with <code>x1 + ... + xn</code>
specifying the model for the random effects and <code>g1/.../gm</code> the
grouping structure (<code>m</code> may be equal to 1, in which case no
<code>/</code> is required). The random effects formula will be repeated
for all levels of grouping, in the case of multiple levels of
grouping; (ii) a list of one-sided formulas of the form
<code>~ x1 + ... + xn | g</code>, with possibly different random effects models
for each grouping level. The order of nesting will be assumed the
same as the order of the elements in the list; (iii) a one-sided
formula of the form <code>~ x1 + ... + xn</code>, or a <code><a href="#topic+pdMat">pdMat</a></code> object with
a formula (i.e. a non-<code>NULL</code> value for <code>formula(object)</code>),
or a list of such formulas or <code><a href="#topic+pdMat">pdMat</a></code> objects. In this case, the
grouping structure formula will be derived from the data used to
fit the linear mixed-effects model, which should inherit from class
<code>"<a href="#topic+groupedData">groupedData</a>"</code>; (iv) a named list of formulas or <code><a href="#topic+pdMat">pdMat</a></code>
objects as in (iii), with the grouping factors as names. The order of
nesting will be assumed the same as the order of the order of the
elements in the list; (v) an <code><a href="#topic+reStruct">reStruct</a></code> object. See the
documentation on <code>pdClasses</code> for a description of the available
<code><a href="#topic+pdMat">pdMat</a></code> classes. Defaults to a formula consisting of the right
hand side of <code>fixed</code>.</p>
</td></tr>
<tr><td><code id="lme_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code><a href="#topic+corStruct">corStruct</a></code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. Defaults to <code>NULL</code>,
corresponding to no within-group correlations.</p>
</td></tr>
<tr><td><code id="lme_+3A_weights">weights</code></td>
<td>
<p>an optional <code><a href="#topic+varFunc">varFunc</a></code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code><a href="#topic+varFixed">varFixed</a></code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code><a href="#topic+varFunc">varFunc</a></code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td></tr>
<tr><td><code id="lme_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lme_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="lme_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code><a href="stats.html#topic+na.fail">na.fail</a></code>) causes
<code>lme</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="lme_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code><a href="#topic+lmeControl">lmeControl</a></code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="lme_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="lme_+3A_keep.data">keep.data</code></td>
<td>
<p>logical: should the <code>data</code> argument (if supplied
and a data frame) be saved as part of the model object?</p>
</td></tr>
<tr><td><code id="lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
<tr><td><code id="lme_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code> evaluate the new call else return the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stats.html#topic+offset">offset</a></code> terms in <code>fixed</code> are an error since 3.1-157
(2022-03): previously they were silently ignored.
</p>


<h3>Value</h3>

<p>An object of class <code>"lme"</code> representing the linear mixed-effects
model fit. Generic functions such as <code>print</code>, <code>plot</code> and
<code>summary</code> have methods to show the results of the fit. See
<code><a href="#topic+lmeObject">lmeObject</a></code> for the components of the fit. The functions
<code><a href="stats.html#topic+resid">resid</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="#topic+fixed.effects">fixed.effects</a></code>, and
<code><a href="#topic+random.effects">random.effects</a></code>  can be used to extract some of its components.
</p>


<h3>Note</h3>

<p>The function does not do any scaling internally: the optimization will
work best when the response is scaled so its variance is of the order
of one.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The computational methods follow the general framework of Lindstrom
and Bates (1988). The model formulation is described in Laird and Ware
(1982).  The variance-covariance parametrizations are described in
Pinheiro and Bates (1996).  The different correlation structures
available for the <code>correlation</code> argument are described in Box,
Jenkins and Reinsel (1994), Littell <em>et al</em> (1996), and Venables and
Ripley (2002). The use of variance functions for linear and nonlinear
mixed effects models is presented in detail in Davidian and Giltinan
(1995).
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994).
<em>Time Series Analysis: Forecasting and Control</em>, 3rd Edition, Holden&ndash;Day.

</p>
<p>Davidian, M. and Giltinan, D.M. (1995).
<em>Nonlinear Mixed Effects Models for Repeated Measurement Data</em>, Chapman and Hall.
<a href="https://doi.org/10.1201/9780203745502">doi:10.1201/9780203745502</a>.
</p>
<p>Laird, N.M. and Ware, J.H. (1982).
Random-Effects Models for Longitudinal Data.
<em>Biometrics</em> <b>38</b>, 963&ndash;974.
<a href="https://doi.org/10.2307/2529876">doi:10.2307/2529876</a>.
</p>
<p>Lindstrom, M.J. and Bates, D.M. (1988).
Newton-Raphson and EM Algorithms for Linear Mixed-Effects Models for Repeated-Measures Data.
<em>Journal of the American Statistical Association</em> <b>83</b>, 1014&ndash;1022.
<a href="https://doi.org/10.2307/2290128">doi:10.2307/2290128</a>.
</p>
<p>Littell, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996).
<em>SAS Systems for Mixed Models</em>, SAS Institute.
</p>
<p>Pinheiro, J.C. and Bates., D.M. (1996).
Unconstrained Parametrizations for Variance-Covariance Matrices.
<em>Statistics and Computing</em> <b>6</b>, 289&ndash;296.
<a href="https://doi.org/10.1007/BF00140873">doi:10.1007/BF00140873</a>.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000).
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer.
<a href="https://doi.org/10.1007/b98882">doi:10.1007/b98882</a>.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002).
<em>Modern Applied Statistics with S</em>, 4th Edition, Springer-Verlag.
<a href="https://doi.org/10.1007/978-0-387-21706-2">doi:10.1007/978-0-387-21706-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+lme.lmList">lme.lmList</a></code>,
<code><a href="#topic+lme.groupedData">lme.groupedData</a></code>,
<code><a href="#topic+lmeControl">lmeControl</a></code>,
<code><a href="#topic+lmeObject">lmeObject</a></code>,
<code><a href="#topic+lmeStruct">lmeStruct</a></code>,
<code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+plot.lme">plot.lme</a></code>,
<code><a href="#topic+predict.lme">predict.lme</a></code>,
<code><a href="#topic+qqnorm.lme">qqnorm.lme</a></code>,
<code><a href="#topic+residuals.lme">residuals.lme</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+simulate.lme">simulate.lme</a></code>,
<code><a href="#topic+summary.lme">summary.lme</a></code>,
<code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, data = Orthodont) # random is ~ age
fm2 &lt;- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1)
summary(fm1)
summary(fm2)
</code></pre>

<hr>
<h2 id='lme.groupedData'>LME fit from groupedData Object</h2><span id='topic+lme.groupedData'></span>

<h3>Description</h3>

<p>The response variable and primary covariate in <code>formula(fixed)</code>
are used to construct the fixed effects model formula. This formula
and the   <code>groupedData</code> object are passed as the <code>fixed</code> and
<code>data</code> arguments to <code>lme.formula</code>, together with any other
additional arguments in the function call. See the documentation on
<code><a href="#topic+lme.formula">lme.formula</a></code> for a description of that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupedData'
lme(fixed, data, random, correlation, weights, 
    subset, method, na.action, control, contrasts, keep.data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lme.groupedData_+3A_fixed">fixed</code></td>
<td>
<p>a data frame inheriting from class <code>"<a href="#topic+groupedData">groupedData</a>"</code>.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_data">data</code></td>
<td>
<p>this argument is included for consistency with the generic
function. It is ignored in this method function.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_random">random</code></td>
<td>
<p>optionally, any of the following: (i) a one-sided formula
of the form <code>~x1+...+xn | g1/.../gm</code>, with <code>x1+...+xn</code>
specifying the model for the random effects and <code>g1/.../gm</code> the
grouping structure (<code>m</code> may be equal to 1, in which case no
<code>/</code> is required). The random effects formula will be repeated
for all levels of grouping, in the case of multiple levels of
grouping; (ii) a list of one-sided formulas of the form
<code>~x1+...+xn | g</code>, with possibly different random effects models
for each grouping level. The order of nesting will be assumed the
same as the order of the elements in the list; (iii) a one-sided
formula of the form <code>~x1+...+xn</code>, or a <code>pdMat</code> object with
a formula (i.e. a non-<code>NULL</code> value for <code>formula(object)</code>),
or a list of such formulas or <code>pdMat</code> objects. In this case, the
grouping structure formula will be derived from the data used to
fit the linear mixed-effects model, which should inherit from class
<code>groupedData</code>; (iv) a named list of formulas or <code>pdMat</code>
objects as in (iii), with the grouping factors as names. The order of
nesting will be assumed the same as the order of the order of the
elements in the list; (v) an <code>reStruct</code> object. See the
documentation on <code>pdClasses</code> for a description of the available
<code>pdMat</code> classes. Defaults to a formula consisting of the right
hand side of <code>fixed</code>.</p>
</td></tr>  
<tr><td><code id="lme.groupedData_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code>corStruct</code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. Defaults to <code>NULL</code>,
corresponding to no within-group correlations.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_weights">weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td></tr> 
<tr><td><code id="lme.groupedData_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>lme</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code>lmeControl</code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="lme.groupedData_+3A_keep.data">keep.data</code></td>
<td>
<p>logical: should the <code>data</code> argument (if supplied
and a data frame) be saved as part of the model object?</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object of class <code>lme</code> representing the linear mixed-effects
model fit. Generic functions such as <code>print</code>, <code>plot</code> and
<code>summary</code> have methods to show the results of the fit. See
<code>lmeObject</code> for the components of the fit. The functions
<code>resid</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>, and
<code>random.effects</code>  can be used to extract some of its components.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The computational methods follow on the general framework of Lindstrom,
M.J. and Bates, D.M. (1988). The model formulation is described in
Laird, N.M. and Ware, J.H. (1982).  The variance-covariance
parametrizations are described in Pinheiro, J.C. and Bates., D.M.
(1996).  The different correlation structures available for the
<code>correlation</code> argument are described in Box, G.E.P., Jenkins,
G.M., and Reinsel G.C. (1994), Littel, R.C., Milliken, G.A., Stroup,
W.W., and Wolfinger, R.D. (1996), and Venables, W.N. and Ripley,
B.D. (2002). The use of variance functions for linear and nonlinear
mixed effects models is presented in detail in Davidian, M. and
Giltinan, D.M. (1995).
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Davidian, M. and Giltinan, D.M. (1995) &quot;Nonlinear Mixed Effects Models
for Repeated Measurement Data&quot;, Chapman and Hall.
</p>
<p>Laird, N.M. and Ware, J.H. (1982) &quot;Random-Effects Models for
Longitudinal Data&quot;, Biometrics, 38, 963-974.  
</p>
<p>Lindstrom, M.J. and Bates, D.M. (1988) &quot;Newton-Raphson and EM
Algorithms for Linear Mixed-Effects Models for Repeated-Measures
Data&quot;, Journal of the American Statistical Association, 83,
1014-1022. 
</p>
<p>Littel, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996)
&quot;SAS Systems for Mixed Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289-296.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+groupedData">groupedData</a></code>,
<code><a href="#topic+lmeObject">lmeObject</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(Orthodont)
summary(fm1)
</code></pre>

<hr>
<h2 id='lme.lmList'>LME fit from lmList Object</h2><span id='topic+lme.lmList'></span>

<h3>Description</h3>

<p>If the random effects names defined in <code>random</code> are a subset of
the <code>lmList</code> object coefficient names, initial estimates for the
covariance matrix of the random effects are obtained (overwriting any
values given in <code>random</code>). <code>formula(fixed)</code> and the
<code>data</code> argument in the calling sequence used to obtain
<code>fixed</code> are passed as the <code>fixed</code> and <code>data</code> arguments
to <code>lme.formula</code>, together with any other additional arguments in
the function call. See the documentation on <code><a href="#topic+lme.formula">lme.formula</a></code> for a
description of that function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
lme(fixed, data, random, correlation, weights, subset, method,
    na.action, control, contrasts, keep.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lme.lmList_+3A_fixed">fixed</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>."</code>,
representing a list of <code>lm</code> fits with a common model.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_data">data</code></td>
<td>
<p>this argument is included for consistency with the generic
function. It is ignored in this method function.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_random">random</code></td>
<td>
<p>an optional one-sided linear formula with no conditioning
expression, or a <code>pdMat</code> object with a <code>formula</code>
attribute. Multiple levels of grouping are not allowed with this
method function.  Defaults to a formula consisting of the right hand
side of <code>formula(fixed)</code>.</p>
</td></tr> 
<tr><td><code id="lme.lmList_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code>corStruct</code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. Defaults to <code>NULL</code>,
corresponding to no within-group correlations.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_weights">weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td></tr> 
<tr><td><code id="lme.lmList_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"REML"</code>.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>lme</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code>lmeControl</code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="lme.lmList_+3A_keep.data">keep.data</code></td>
<td>
<p>logical: should the <code>data</code> argument (if supplied
and a data frame) be saved as part of the model object?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>lme</code> representing the linear mixed-effects
model fit. Generic functions such as <code>print</code>, <code>plot</code> and
<code>summary</code> have methods to show the results of the fit. See
<code>lmeObject</code> for the components of the fit. The functions
<code>resid</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>, and
<code>random.effects</code>  can be used to extract some of its components.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas
Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>
</p>


<h3>References</h3>

<p>The computational methods follow the general framework of Lindstrom
and Bates (1988). The model formulation is described in Laird and Ware
(1982).  The variance-covariance parametrizations are described in
Pinheiro and Bates (1996).  The different correlation structures
available for the <code>correlation</code> argument are described in Box,
Jenkins and Reinse (1994), Littel <em>et al</em> (1996), and Venables and
Ripley, (2002). The use of variance functions for linear and nonlinear
mixed effects models is presented in detail in Davidian and Giltinan
(1995).
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden&ndash;Day. 
</p>
<p>Davidian, M. and Giltinan, D.M. (1995) &quot;Nonlinear Mixed Effects Models
for Repeated Measurement Data&quot;, Chapman and Hall.
</p>
<p>Laird, N.M. and Ware, J.H. (1982) &quot;Random-Effects Models for
Longitudinal Data&quot;, Biometrics, 38, 963&ndash;974.  
</p>
<p>Lindstrom, M.J. and Bates, D.M. (1988) &quot;Newton-Raphson and EM
Algorithms for Linear Mixed-Effects Models for Repeated-Measures
Data&quot;, Journal of the American Statistical Association, 83,
1014&ndash;1022. 
</p>
<p>Littel, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996)
&quot;SAS Systems for Mixed Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289&ndash;296.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+lmeObject">lmeObject</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(Orthodont)
fm2 &lt;- lme(fm1)
summary(fm1)
summary(fm2)
</code></pre>

<hr>
<h2 id='lmeControl'>Specifying Control Values for lme Fit</h2><span id='topic+lmeControl'></span>

<h3>Description</h3>

<p>The values supplied in the <code>lmeControl()</code> call replace the
defaults, and a <code><a href="base.html#topic+list">list</a></code> with all settings (i.e., values for
all possible arguments) is returned.  The returned list is
used as the <code>control</code> argument to the <code>lme</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmeControl(maxIter = 50, msMaxIter = 50, tolerance = 1e-6, niterEM = 25,
           msMaxEval = 200,
	   msTol = 1e-7, msVerbose = FALSE,
           returnObject = FALSE, gradHess = TRUE, apVar = TRUE,
	   .relStep = .Machine$double.eps^(1/3), minAbsParApVar = 0.05,
           opt = c("nlminb", "optim"),
	   optimMethod = "BFGS", natural = TRUE,
	   sigma = NULL,
           allow.n.lt.q = FALSE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmeControl_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the <code>lme</code>
optimization algorithm.  Default is <code>50</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations
for the optimization step inside the <code>lme</code> optimization.
Default is <code>50</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the convergence criterion in the
<code>lme</code> algorithm. Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_niterem">niterEM</code></td>
<td>
<p>number of iterations for the EM algorithm used to refine
the initial estimates of the random effects variance-covariance
coefficients.  Default is <code>25</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_msmaxeval">msMaxEval</code></td>
<td>
<p>maximum number of evaluations of the objective
function permitted for nlminb.  Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_mstol">msTol</code></td>
<td>
<p>tolerance for the convergence criterion on the first
iteration when <code>optim</code> is used.  Default is <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_msverbose">msVerbose</code></td>
<td>
<p>a logical value passed as the <code>trace</code> argument to
<code><a href="stats.html#topic+nlminb">nlminb</a></code> or <code><a href="stats.html#topic+optim">optim</a></code>.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_returnobject">returnObject</code></td>
<td>
<p>a logical value indicating whether the fitted
object should be returned with a <code><a href="base.html#topic+warning">warning</a></code> (instead of an
error via <code><a href="base.html#topic+stop">stop</a>()</code>) when the maximum number of
iterations is reached without convergence of the algorithm.  Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_gradhess">gradHess</code></td>
<td>
<p>a logical value indicating whether numerical gradient
vectors and Hessian matrices of the log-likelihood function should
be used in the internal optimization.  This option is only available
when the correlation structure (<code>corStruct</code>) and the variance
function structure (<code>varFunc</code>) have no &quot;varying&quot; parameters and
the <code>pdMat</code> classes used in the random effects structure are
<code>pdSymm</code> (general positive-definite), <code>pdDiag</code> (diagonal),
<code>pdIdent</code> (multiple of the identity),  or
<code>pdCompSymm</code> (compound symmetry).  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_apvar">apVar</code></td>
<td>
<p>a logical value indicating whether the approximate
covariance matrix of the variance-covariance parameters should be
calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_.relstep">.relStep</code></td>
<td>
<p>relative step for numerical derivatives
calculations.  Default is <code>.Machine$double.eps^(1/3)</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_opt">opt</code></td>
<td>
<p>the optimizer to be used, either <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code> (the
default) or <code>"<a href="stats.html#topic+optim">optim</a>"</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_optimmethod">optimMethod</code></td>
<td>
<p>character - the optimization method to be used with
the <code><a href="stats.html#topic+optim">optim</a></code> optimizer.  The default is
<code>"BFGS"</code>.  An alternative is <code>"L-BFGS-B"</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_minabsparapvar">minAbsParApVar</code></td>
<td>
<p>numeric value - minimum absolute parameter value
in the approximate variance calculation.  The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_natural">natural</code></td>
<td>
<p>a logical value indicating whether the <code>pdNatural</code>
parametrization should be used for general positive-definite matrices
(<code>pdSymm</code>) in <code>reStruct</code>, when the approximate covariance
matrix of the estimators is calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_sigma">sigma</code></td>
<td>
<p>optionally a positive number to fix the residual error at.
If <code>NULL</code>, as by default, or <code>0</code>, sigma is estimated.</p>
</td></tr>
<tr><td><code id="lmeControl_+3A_allow.n.lt.q">allow.n.lt.q</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if it is ok to have
less observations than random effects for each group.  The default,
<code>FALSE</code> signals an error; if <code>NA</code>, such a situation only gives
a warning, as in <span class="pkg">nlme</span> versions prior to 2019; if true, no message
is given at all.</p>
</td></tr>

<tr><td><code id="lmeControl_+3A_...">...</code></td>
<td>
<p>further named control arguments to be passed, depending on
<code>opt</code>, to <code><a href="stats.html#topic+nlminb">nlminb</a></code> (those from <code>abs.tol</code> down)
or <code><a href="stats.html#topic+optim">optim</a></code> (those except <code>trace</code> and <code>maxit</code>;
<code>reltol</code> is used only from the second iteration).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>; the
<code>sigma</code> option: Siem Heisterkamp and Bert van Willigen.</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># decrease the maximum number iterations in the ms call and
# request that information on the evolution of the ms iterations be printed
str(lCtr &lt;- lmeControl(msMaxIter = 20, msVerbose = TRUE))
## This should always work:
do.call(lmeControl, lCtr)
</code></pre>

<hr>
<h2 id='lmeObject'>Fitted lme Object</h2><span id='topic+lmeObject'></span>

<h3>Description</h3>

<p>An object returned by the <code>lme</code> function, inheriting from class
<code>"lme"</code> and representing a fitted linear mixed-effects
model.  Objects of this class have methods for the generic functions
<code>anova</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>,
<code>formula</code>, <code>getGroups</code>, <code>getResponse</code>,
<code>intervals</code>, <code>logLik</code>, <code>pairs</code>, <code>plot</code>,
<code>predict</code>, <code>print</code>, <code>random.effects</code>, <code>residuals</code>,
<code>sigma</code>, <code>summary</code>, <code>update</code>, and <code>vcov</code>.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>"lme"</code>
object.
</p>
<table>
<tr><td><code>apVar</code></td>
<td>
<p>an approximate covariance matrix for the
variance-covariance coefficients.  If <code>apVar = FALSE</code> in the
control values used in the call to <code>lme</code>, this component is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>lme</code> call that
produced the object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with two components, <code>fixed</code> and
<code>random</code>, where the first is a vector containing the estimated
fixed effects and the second is a list of matrices with the estimated
random effects for each level of grouping. For each matrix in the
<code>random</code> list, the columns refer to the random effects and the
rows to the groups.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list of the contrast matrices used to represent factors
in the fixed effects formula  and/or random effects formula. This
information is important for making predictions from a new data
frame in which not all levels of the original factors are
observed. If no factors are used in the lme model, this component
will be an empty list.</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>a list with basic dimensions used in the lme fit,
including the components <code>N</code> - the number of observations in
the data, <code>Q</code> - the number of grouping levels, <code>qvec</code> -
the number of random effects at each level from innermost to
outermost (last two values are equal to zero and correspond to the
fixed effects and the response), <code>ngrps</code> - the number of groups
at each level from innermost to outermost (last two values are one
and correspond to the fixed effects and the response), and
<code>ncol</code> - the number of columns in the model matrix for each
level of grouping from innermost to outermost (last two values are
equal to the number of fixed effects and one).</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a data frame with the fitted values as columns. The
leftmost column corresponds to the population fixed effects
(corresponding to the fixed effects only) and successive columns
from left to right correspond to increasing levels of grouping.</p>
</td></tr>
<tr><td><code>fixDF</code></td>
<td>
<p>a list with components <code>X</code> and <code>terms</code>
specifying the denominator degrees of freedom for, respectively,
t-tests for the individual fixed effects and F-tests for the
fixed-effects terms in the models.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a data frame with the grouping factors as
columns. The grouping level increases from left to right.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the (restricted) log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the estimation method: either <code>"ML"</code> for maximum
likelihood, or <code>"REML"</code> for restricted maximum likelihood.</p>
</td></tr>
<tr><td><code>modelStruct</code></td>
<td>
<p>an object inheriting from class <code>lmeStruct</code>,
representing a list of mixed-effects model components, such
as <code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>the number of iterations used in the iterative
algorithm.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a data frame with the residuals as columns. The
leftmost column corresponds to the population residuals
and successive columns from left to right correspond to increasing
levels of grouping.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code>, including <code><a href="stats.html#topic+formula">formula</a></code>,
see also <a href="stats.html#topic+terms.object">terms.object</a>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the estimated within-group error standard deviation.</p>
</td></tr>
<tr><td><code>varFix</code></td>
<td>
<p>an approximate covariance matrix of the
fixed effects estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code>lmeStruct</code></p>

<hr>
<h2 id='lmeStruct'>Linear Mixed-Effects Structure</h2><span id='topic+lmeStruct'></span>

<h3>Description</h3>

<p>A linear mixed-effects structure is a list of model components
representing different sets of parameters in the linear mixed-effects
model. An <code>lmeStruct</code> list must contain at least a
<code>reStruct</code> object, but may also contain <code>corStruct</code> and
<code>varFunc</code> objects. <code>NULL</code> arguments are not included in the
<code>lmeStruct</code> list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmeStruct(reStruct, corStruct, varStruct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmeStruct_+3A_restruct">reStruct</code></td>
<td>
<p>a <code>reStruct</code> representing a random effects
structure.</p>
</td></tr>
<tr><td><code id="lmeStruct_+3A_corstruct">corStruct</code></td>
<td>
<p>an optional <code>corStruct</code> object, representing a
correlation structure. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lmeStruct_+3A_varstruct">varStruct</code></td>
<td>
<p>an optional <code>varFunc</code> object, representing a
variance function structure. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of model components determining the parameters to be estimated
for the associated linear mixed-effects model.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+residuals.lmeStruct">residuals.lmeStruct</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>lms1 &lt;- lmeStruct(reStruct(~age), corAR1(), varPower())
</code></pre>

<hr>
<h2 id='lmList'>List of lm Objects with a Common Model</h2><span id='topic+lmList'></span><span id='topic+lmList.formula'></span><span id='topic+print.lmList'></span><span id='topic+update.lmList'></span>

<h3>Description</h3>

<p><code>Data</code> is partitioned according to the levels of the grouping
factor <code>g</code> and individual <code>lm</code> fits are obtained for each
<code>data</code> partition, using the model defined in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmList(object, data, level, subset, na.action = na.fail,
       pool = TRUE, warn.lm = TRUE)

## S3 method for class 'formula'
lmList(object, data, level, subset, na.action = na.fail,
       pool = TRUE, warn.lm = TRUE)

## S3 method for class 'lmList'
update(object, formula., ..., evaluate = TRUE)
## S3 method for class 'lmList'
print(x, pool, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmList_+3A_object">object</code></td>
<td>
<p>For <code>lmList</code>,
either a linear formula object of the form <code>y ~ x1+...+xn | g</code>
or a <code>groupedData</code> object. In the formula object, <code>y</code>
represents the response, <code>x1,...,xn</code> the covariates, and
<code>g</code> the grouping factor specifying the partitioning of the data
according to which different <code>lm</code> fits should be performed. The
grouping factor <code>g</code> may be omitted from the formula, in which
case the grouping structure will be obtained from <code>data</code>, which
must inherit from class <code>groupedData</code>.  The method function
<code><a href="#topic+lmList.groupedData">lmList.groupedData</a></code> is documented separately.
For the method <code>update.lmList</code>, <code>object</code> is an object
inheriting from class <code>lmList</code>.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_formula">formula</code></td>
<td>
<p>(used in <code>update.lmList</code> only)
a two-sided linear formula with the common model for the individuals
<code>lm</code> fits.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula &ndash; see <code>update.formula</code> for
details.</p>
</td></tr>
<tr><td><code id="lmList_+3A_data">data</code></td>
<td>

<p>a data frame in which to interpret the variables named in
<code>object</code>.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_level">level</code></td>
<td>

<p>an optional integer specifying the level of grouping to be used when
multiple nested levels of grouping are present.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating which subset of the rows of
<code>data</code> should  be  used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lmList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>lmList</code> to print an error message and terminate if there are any
incomplete observations.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_pool">pool</code></td>
<td>

<p>an optional logical value indicating whether a pooled
estimate of the residual standard error should be used
in calculations of standard deviations or standard errors for
summaries.
</p>
</td></tr>
<tr><td><code id="lmList_+3A_warn.lm">warn.lm</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if <code><a href="stats.html#topic+lm">lm</a>()</code>
errors (all of which are caught by <code><a href="base.html#topic+tryCatch">tryCatch</a></code>) should be
signalled as a &ldquo;summarizing&rdquo; <code><a href="base.html#topic+warning">warning</a></code>.</p>
</td></tr>
<tr><td><code id="lmList_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>lmList</code> to be printed.</p>
</td></tr>
<tr><td><code id="lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
<tr><td><code id="lmList_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code> evaluate the new call else return the call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>lm</code> objects with as many components as the number of
groups defined by the grouping factor. Generic functions such as
<code>coef</code>, <code>fixed.effects</code>, <code>lme</code>, <code>pairs</code>,
<code>plot</code>, <code>predict</code>, <code>random.effects</code>, <code>summary</code>,
and <code>update</code> have methods that can be applied to an <code>lmList</code>
object.
</p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="#topic+lme.lmList">lme.lmList</a></code>,
<code><a href="#topic+plot.lmList">plot.lmList</a></code>,
<code><a href="#topic+pooledSD">pooledSD</a></code>,
<code><a href="#topic+predict.lmList">predict.lmList</a></code>,
<code><a href="#topic+residuals.lmList">residuals.lmList</a></code>,
<code><a href="#topic+summary.lmList">summary.lmList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
summary(fm1)
</code></pre>

<hr>
<h2 id='lmList.groupedData'>lmList Fit from a groupedData Object</h2><span id='topic+lmList.groupedData'></span>

<h3>Description</h3>

<p>The response variable and primary covariate in <code>formula(object)</code>
are used to construct the linear model formula. This formula
and the <code>groupedData</code> object are passed as the <code>object</code> and
<code>data</code> arguments to <code>lmList.formula</code>, together with any other
additional arguments in the function call. See the documentation on
<code><a href="#topic+lmList.formula">lmList.formula</a></code> for a description of that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'groupedData'
lmList(object, data, level, subset, na.action = na.fail,
       pool = TRUE, warn.lm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmList.groupedData_+3A_object">object</code></td>
<td>
<p>a data frame inheriting from class <code>"<a href="#topic+groupedData">groupedData</a>"</code>.</p>
</td></tr>
<tr><td><code id="lmList.groupedData_+3A_data">data</code></td>
<td>
<p>this argument is included for consistency with the generic
function. It is ignored in this method function.</p>
</td></tr>
<tr><td><code id="lmList.groupedData_+3A_level">level</code></td>
<td>

<p>an optional integer specifying the level of grouping to be used when
multiple nested levels of grouping are present.
</p>
</td></tr>
<tr><td><code id="lmList.groupedData_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating which subset of the rows of
<code>data</code> should  be  used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lmList.groupedData_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>lmList</code> to print an error message and terminate if there are any
incomplete observations.
</p>
</td></tr>
<tr><td><code id="lmList.groupedData_+3A_pool">pool</code>, <code id="lmList.groupedData_+3A_warn.lm">warn.lm</code></td>
<td>
<p>optional <code><a href="base.html#topic+logical">logical</a></code>s, see <code><a href="#topic+lmList">lmList</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>lm</code> objects with as many components as the number of
groups defined by the grouping factor. Generic functions such as
<code>coef</code>, <code>fixed.effects</code>, <code>lme</code>, <code>pairs</code>,
<code>plot</code>, <code>predict</code>, <code>random.effects</code>, <code>summary</code>,
and <code>update</code> have methods that can be applied to an <code>lmList</code>
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="#topic+lme.lmList">lme.lmList</a></code>, <code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+lmList.formula">lmList.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(Orthodont)
summary(fm1)
</code></pre>

<hr>
<h2 id='logDet'>Extract the Logarithm of the Determinant</h2><span id='topic+logDet'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>corStruct</code>, several <code>pdMat</code> classes,
and <code>reStruct</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logDet(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDet_+3A_object">object</code></td>
<td>
<p>any object from which a matrix, or list of matrices, can
be extracted</p>
</td></tr>
<tr><td><code id="logDet_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate
documentation. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="#topic+logDet.corStruct">logDet.corStruct</a></code>,
<code><a href="#topic+logDet.pdMat">logDet.pdMat</a></code>,
<code><a href="#topic+logDet.reStruct">logDet.reStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='logDet.corStruct'>Extract corStruct Log-Determinant</h2><span id='topic+logDet.corStruct'></span>

<h3>Description</h3>

<p>This method function extracts the logarithm of the determinant of a
square-root factor of the correlation matrix associated with
<code>object</code>, or the sum of the log-determinants of square-root
factors of the list of correlation matrices associated with
<code>object</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
logDet(object, covariate, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDet.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="logDet.corStruct_+3A_covariate">covariate</code></td>
<td>
<p>an optional covariate vector (matrix), or list of
covariate vectors (matrices), at which values the correlation matrix,
or list of correlation  matrices, are to be evaluated. Defaults to
<code>getCovariate(object)</code>.</p>
</td></tr> 
<tr><td><code id="logDet.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the log-determinant of a square-root factor of the correlation matrix
associated with <code>object</code>, or the sum of the log-determinants of
square-root factors of the list of correlation matrices associated
with <code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.corStruct">logLik.corStruct</a></code>,
<code><a href="#topic+corMatrix.corStruct">corMatrix.corStruct</a></code>,
<code><a href="#topic+logDet">logDet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(0.3)
logDet(cs1, covariate = 1:4)
</code></pre>

<hr>
<h2 id='logDet.pdMat'>Extract Log-Determinant from a pdMat Object</h2><span id='topic+logDet.pdMat'></span><span id='topic+logDet.pdBlocked'></span><span id='topic+logDet.pdCompSymm'></span><span id='topic+logDet.pdDiag'></span><span id='topic+logDet.pdIdent'></span><span id='topic+logDet.pdNatural'></span><span id='topic+logDet.pdSymm'></span>

<h3>Description</h3>

<p>This method function extracts the logarithm of the determinant of a
square-root factor of the positive-definite matrix represented by
<code>object</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
logDet(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDet.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>, representing
a positive definite matrix.</p>
</td></tr> 
<tr><td><code id="logDet.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the log-determinant of a square-root factor of the positive-definite
matrix represented by <code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+logDet">logDet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(diag(1:3))
logDet(pd1)
</code></pre>

<hr>
<h2 id='logDet.reStruct'>Extract reStruct Log-Determinants</h2><span id='topic+logDet.reStruct'></span>

<h3>Description</h3>

<p>Calculates, for each of the <code>pdMat</code> components of <code>object</code>,
the logarithm of the determinant of a square-root factor.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
logDet(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logDet.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="logDet.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the log-determinants of square-root factors of the
<code>pdMat</code> components of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro</p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>, <code><a href="#topic+logDet">logDet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(A = pdSymm(diag(1:3), form = ~Score),
  B = pdDiag(2 * diag(4), form = ~Educ)))
logDet(rs1)
</code></pre>

<hr>
<h2 id='logLik.corStruct'>Extract corStruct Log-Likelihood</h2><span id='topic+logLik.corStruct'></span>

<h3>Description</h3>

<p>This method function extracts the component of a Gaussian
log-likelihood associated with the correlation structure, which is
equal to the negative of the logarithm of the determinant (or sum of
the logarithms of the determinants) of the matrix (or matrices)
represented by <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
logLik(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="logLik.corStruct_+3A_data">data</code></td>
<td>
<p>this argument is included to make this method function
compatible with other <code>logLik</code> methods and will be ignored.</p>
</td></tr> 
<tr><td><code id="logLik.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the negative of the logarithm of the determinant (or sum of
the logarithms of the determinants) of the correlation matrix (or
matrices) represented by <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+logDet.corStruct">logDet.corStruct</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(0.2)
cs1 &lt;- Initialize(cs1, data = Orthodont)
logLik(cs1)
</code></pre>

<hr>
<h2 id='logLik.glsStruct'>Log-Likelihood of a glsStruct Object</h2><span id='topic+logLik.glsStruct'></span>

<h3>Description</h3>

<p><code>Pars</code> is used to update the coefficients of the model components
of <code>object</code> and the individual (restricted) log-likelihood
contributions of each component are added together. The type of
log-likelihood (restricted or not) is determined by the
<code>settings</code> attribute of <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsStruct'
logLik(object, Pars, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.glsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+glsStruct">glsStruct</a>"</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>"<a href="#topic+varFunc">varFunc</a>"</code> objects.</p>
</td></tr>
<tr><td><code id="logLik.glsStruct_+3A_pars">Pars</code></td>
<td>
<p>the parameter values at which the (restricted)
log-likelihood is to be evaluated.</p>
</td></tr>
<tr><td><code id="logLik.glsStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying linear model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="logLik.glsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the (restricted) log-likelihood for the linear model described by
<code>object</code>, evaluated at <code>Pars</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+glsStruct">glsStruct</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>
</p>

<hr>
<h2 id='logLik.gnls'>Log-Likelihood of a gnls Object</h2><span id='topic+logLik.gnls'></span>

<h3>Description</h3>

<p>Returns the log-likelihood value of the nonlinear model represented by
<code>object</code> evaluated at the estimated coefficients.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnls'
logLik(object, REML, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gnls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gnls">gnls</a>"</code>, representing
a generalized nonlinear least squares fitted model.</p>
</td></tr>
<tr><td><code id="logLik.gnls_+3A_reml">REML</code></td>
<td>
<p>an logical value for consistency with <code>logLik,gls</code>,
but only <code>FALSE</code> is accepted.. </p>
</td></tr>
<tr><td><code id="logLik.gnls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the log-likelihood of the linear model represented by
<code>object</code> evaluated at the estimated coefficients.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean,
            weights = varPower())
logLik(fm1)
</code></pre>

<hr>
<h2 id='logLik.gnlsStruct'>Log-Likelihood of a gnlsStruct Object</h2><span id='topic+logLik.gnlsStruct'></span>

<h3>Description</h3>

<p><code>Pars</code> is used to update the coefficients of the model components
of <code>object</code> and the individual log-likelihood
contributions of each component are added together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnlsStruct'
logLik(object, Pars, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.gnlsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>gnlsStruct</code>,
representing a list of model components, such as
<code>corStruct</code> and <code>varFunc</code> objects, and attributes
specifying the underlying nonlinear model and the response variable.</p>
</td></tr>
<tr><td><code id="logLik.gnlsStruct_+3A_pars">Pars</code></td>
<td>
<p>the parameter values at which the log-likelihood is to be
evaluated.</p>
</td></tr> 
<tr><td><code id="logLik.gnlsStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying nonlinear model. Defaults to <code>attr(object,
     "conLin")</code>.</p>
</td></tr> 
<tr><td><code id="logLik.gnlsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the log-likelihood for the linear model described by <code>object</code>,
evaluated at <code>Pars</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>, <code><a href="#topic+gnlsStruct">gnlsStruct</a></code>,
<code><a href="#topic+logLik.gnls">logLik.gnls</a></code>
</p>

<hr>
<h2 id='logLik.lme'>Log-Likelihood of an lme Object</h2><span id='topic+logLik.lme'></span><span id='topic+logLik.gls'></span>

<h3>Description</h3>

<p>If <code>REML=FALSE</code>, returns the log-likelihood value of the linear
mixed-effects model represented by <code>object</code> evaluated at the
estimated  coefficients; else, the restricted log-likelihood evaluated
at the estimated coefficients is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
logLik(object, REML, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="logLik.lme_+3A_reml">REML</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> the restricted
log-likelihood is returned, else, if <code>FALSE</code>, the log-likelihood
is returned. Defaults to the method of estimation used, that is
<code>TRUE</code> if and only <code>object</code> was fitted with <code>method =
     "REML"</code> (the default for these fitting functions) . </p>
</td></tr>
<tr><td><code id="logLik.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the (restricted) log-likelihood of the model represented by
<code>object</code> evaluated at the estimated coefficients.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates</p>


<h3>References</h3>

<p>Harville, D.A. (1974) &ldquo;Bayesian Inference for Variance Components
Using Only Error Contrasts&rdquo;, <em>Biometrika</em>, <b>61</b>, 383&ndash;385.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>,<code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+logLik.corStruct">logLik.corStruct</a></code>,
<code><a href="#topic+logLik.glsStruct">logLik.glsStruct</a></code>,
<code><a href="#topic+logLik.lmeStruct">logLik.lmeStruct</a></code>,
<code><a href="#topic+logLik.lmList">logLik.lmList</a></code>,
<code><a href="#topic+logLik.reStruct">logLik.reStruct</a></code>,
<code><a href="#topic+logLik.varFunc">logLik.varFunc</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ Sex * age, Orthodont, random = ~ age, method = "ML")
logLik(fm1)
logLik(fm1, REML = TRUE)
</code></pre>

<hr>
<h2 id='logLik.lmeStruct'>Log-Likelihood of an lmeStruct Object</h2><span id='topic+logLik.lmeStruct'></span><span id='topic+logLik.lmeStructInt'></span>

<h3>Description</h3>

<p><code>Pars</code> is used to update the coefficients of the model components
of <code>object</code> and the individual (restricted) log-likelihood
contributions of each component are added together. The type of
log-likelihood (restricted or not) is determined by the
<code>settings</code> attribute of <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmeStruct'
logLik(object, Pars, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmeStruct">lmeStruct</a>"</code>,
representing a list of linear mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="logLik.lmeStruct_+3A_pars">Pars</code></td>
<td>
<p>the parameter values at which the (restricted)
log-likelihood is to be evaluated.</p>
</td></tr>
<tr><td><code id="logLik.lmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying lme model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="logLik.lmeStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the (restricted) log-likelihood for the linear mixed-effects model
described by <code>object</code>, evaluated at <code>Pars</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+lmeStruct">lmeStruct</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>
</p>

<hr>
<h2 id='logLik.lmList'>Log-Likelihood of an lmList Object</h2><span id='topic+logLik.lmList'></span>

<h3>Description</h3>

<p>If <code>pool=FALSE</code>, the (restricted) log-likelihoods of the <code>lm</code>
components of <code>object</code> are summed together. Else, the (restricted)
log-likelihood of the <code>lm</code> fit with different coefficients for
each level of the grouping factor associated with the partitioning of
the <code>object</code> components is obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
logLik(object, REML, pool, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="logLik.lmList_+3A_reml">REML</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> the restricted
log-likelihood is returned, else, if <code>FALSE</code>, the log-likelihood
is returned. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="logLik.lmList_+3A_pool">pool</code></td>
<td>
<p>an optional logical value indicating whether all <code>lm</code>
components of <code>object</code> may be assumed to have the same error
variance. Default is <code>attr(object, "pool")</code>.
</p>
</td></tr>
<tr><td><code id="logLik.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>either the sum of the (restricted) log-likelihoods of each <code>lm</code>
component in <code>object</code>, or the (restricted) log-likelihood for the
<code>lm</code> fit with separate coefficients for each component of
<code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
logLik(fm1)   # returns NA when it should not
</code></pre>

<hr>
<h2 id='logLik.reStruct'>Calculate reStruct Log-Likelihood</h2><span id='topic+logLik.reStruct'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood, or restricted log-likelihood, of the
Gaussian linear mixed-effects model represented by <code>object</code> and
<code>conLin</code> (assuming spherical within-group covariance structure),
evaluated at <code>coef(object)</code>. The <code>settings</code> attribute of
<code>object</code> determines whether the log-likelihood, or the restricted
log-likelihood, is to be calculated. The computational methods are 
described in Bates and Pinheiro (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
logLik(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="logLik.reStruct_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr> 
<tr><td><code id="logLik.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the log-likelihood, or restricted log-likelihood, of linear
mixed-effects model represented by <code>object</code> and <code>conLin</code>,
evaluated at <code>coef{object}</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+logLik.lme">logLik.lme</a></code>
</p>

<hr>
<h2 id='logLik.varFunc'>Extract varFunc logLik</h2><span id='topic+logLik.varFunc'></span><span id='topic+logLik.varComb'></span>

<h3>Description</h3>

<p>This method function extracts the component of a Gaussian
log-likelihood associated with the variance function structure
represented by <code>object</code>, which is equal to the sum of the
logarithms of the corresponding weights. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
logLik(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr> 
<tr><td><code id="logLik.varFunc_+3A_data">data</code></td>
<td>
<p>this argument is included to make this method function
compatible with other <code>logLik</code> methods and will be ignored.</p>
</td></tr> 
<tr><td><code id="logLik.varFunc_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the sum of the logarithms of the weights corresponding to the variance
function structure represented by <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.lme">logLik.lme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(form = ~age)
vf1 &lt;- Initialize(vf1, Orthodont)
coef(vf1) &lt;- 0.1
logLik(vf1)
</code></pre>

<hr>
<h2 id='Machines'>Productivity Scores for Machines and Workers</h2><span id='topic+Machines'></span>

<h3>Description</h3>

<p>The <code>Machines</code> data frame has 54 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Worker</dt><dd>
<p>an ordered factor giving the unique identifier for the worker.
</p>
</dd>
<dt>Machine</dt><dd>
<p>a factor with levels
<code>A</code>, 
<code>B</code>, and 
<code>C</code> identifying the machine brand.
</p>
</dd>
<dt>score</dt><dd>
<p>a productivity score.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data on an experiment to compare three brands of machines used in an
industrial process are presented in Milliken and Johnson (p. 285,
1992). Six workers were chosen randomly among the
employees of a factory to operate each machine three times. The
response is an overall productivity score taking into account the
number and quality of components produced.</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models
in S and S-PLUS</em>, Springer, New York.  (Appendix A.14)
</p>
<p>Milliken, G. A. and Johnson, D. E. (1992), <em>Analysis of Messy Data,
Volume I: Designed Experiments</em>, Chapman and Hall, London.
</p>

<hr>
<h2 id='MathAchieve'>Mathematics achievement scores</h2><span id='topic+MathAchieve'></span>

<h3>Description</h3>

<p>The <code>MathAchieve</code> data frame has 7185 rows and 6 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>School</dt><dd>
<p>an ordered factor identifying the school that the student attends
</p>
</dd>
<dt>Minority</dt><dd>
<p>a factor with levels
<code>No</code> 
<code>Yes</code>
indicating if the student is a member of a minority racial group.
</p>
</dd>
<dt>Sex</dt><dd>
<p>a factor with levels
<code>Male</code> 
<code>Female</code> 
</p>
</dd>
<dt>SES</dt><dd>
<p>a numeric vector of socio-economic status.
</p>
</dd>
<dt>MathAch</dt><dd>
<p>a numeric vector of mathematics achievement scores.
</p>
</dd>
<dt>MEANSES</dt><dd>
<p>a numeric vector of the mean SES for the school.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each row in this data frame contains the data for one student.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(MathAchieve)
</code></pre>

<hr>
<h2 id='MathAchSchool'>School demographic data for MathAchieve</h2><span id='topic+MathAchSchool'></span>

<h3>Description</h3>

<p>The <code>MathAchSchool</code> data frame has 160 rows and 7 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>School</dt><dd>
<p>a factor giving the school on which the measurement is made.
</p>
</dd>
<dt>Size</dt><dd>
<p>a numeric vector giving the number of students in the school
</p>
</dd>
<dt>Sector</dt><dd>
<p>a factor with levels
<code>Public</code> 
<code>Catholic</code> 
</p>
</dd>
<dt>PRACAD</dt><dd>
<p>a numeric vector giving the percentage of students on the
academic track
</p>
</dd>
<dt>DISCLIM</dt><dd>
<p>a numeric vector measuring the discrimination climate
</p>
</dd>
<dt>HIMINTY</dt><dd>
<p>a factor with levels
<code>0</code> 
<code>1</code> 
</p>
</dd>
<dt>MEANSES</dt><dd>
<p>a numeric vector giving the mean SES score.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These variables give the school-level demographic data to accompany
the <code>MathAchieve</code> data.
</p>

<hr>
<h2 id='Matrix'>Assign Matrix Values</h2><span id='topic+matrix+3C-'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects.  Classes which already have methods for
this function include <code>pdMat</code>, <code>pdBlocked</code>, and
<code>reStruct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix_+3A_object">object</code></td>
<td>
<p>any object to which <code>as.matrix</code> can be applied.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_value">value</code></td>
<td>
<p>a matrix, or list of matrices, with the same dimensions as
<code>as.matrix(object)</code> with the new values to be assigned to the
matrix associated with <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.matrix">as.matrix</a></code>, also for examples,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code>,
<code><a href="#topic+matrix+3C-.reStruct">matrix&lt;-.reStruct</a></code>.
</p>

<hr>
<h2 id='Matrix.pdMat'>Assign Matrix to a pdMat or pdBlocked Object</h2><span id='topic+matrix+3C-.pdMat'></span><span id='topic+matrix+3C-.pdBlocked'></span>

<h3>Description</h3>

<p>The positive-definite matrix represented by <code>object</code> is replaced
by <code>value</code>.  If the original matrix had row and/or column names,
the corresponding names for <code>value</code> can either be <code>NULL</code>, or
a permutation of the original names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'pdMat'
matrix(object) &lt;- value
## S3 replacement method for class 'pdBlocked'
matrix(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
representing a positive definite matrix.</p>
</td></tr>
<tr><td><code id="Matrix.pdMat_+3A_value">value</code></td>
<td>
<p>a matrix with the new values to be assigned to the
positive-definite matrix represented by <code>object</code>.  Must have the
same dimensions as <code>as.matrix(object)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdMat</code> or <code>pdBlocked</code> object similar to <code>object</code>,
but with its coefficients modified to produce the matrix in
<code>value</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code>, <code>"<a href="#topic+matrix+3C-">matrix&lt;-</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(pd1 &lt;- pdSymm(diag(3))) # "pdSymm" "pdMat"
matrix(pd1) &lt;- diag(1:3)
pd1
</code></pre>

<hr>
<h2 id='Matrix.reStruct'>Assign reStruct Matrices</h2><span id='topic+matrix+3C-.reStruct'></span>

<h3>Description</h3>

<p>The individual matrices in <code>value</code> are assigned to each
<code>pdMat</code> component of <code>object</code>, in the order they are listed. The
new matrices must have the same dimensions as the matrices they are
meant to replace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'reStruct'
matrix(object) &lt;-  value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="Matrix.reStruct_+3A_value">value</code></td>
<td>
<p>a matrix, or list of matrices, with the new values to be
assigned to the matrices associated with the <code>pdMat</code> components
of <code>object</code>.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>an <code>reStruct</code> object similar to <code>object</code>, but with the
coefficients of the individual <code>pdMat</code> components modified to
produce the matrices listed in <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>, <code><a href="#topic+pdMat">pdMat</a></code>, <code>"<a href="#topic+matrix+3C-">matrix&lt;-</a>"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(Dog = ~day, Side = ~1), data = Pixel)
matrix(rs1) &lt;- list(diag(2), 3)
</code></pre>

<hr>
<h2 id='Meat'>Tenderness of meat</h2><span id='topic+Meat'></span>

<h3>Description</h3>

<p>The <code>Meat</code> data frame has 30 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Storage</dt><dd>
<p>an ordered factor specifying the storage treatment - 1 (0
days), 2 (1 day),  3 (2 days), 4 (4 days), 5 (9 days), and 6
(18 days)
</p>
</dd>
<dt>score</dt><dd>
<p>a numeric vector giving the tenderness score of beef roast.
</p>
</dd>
<dt>Block</dt><dd>
<p>an ordered factor identifying the muscle from which the
roast was extracted with levels 
<code>II</code> &lt; <code>V</code> &lt; <code>I</code> &lt; <code>III</code> &lt; <code>IV</code>
</p>
</dd>
<dt>Pair</dt><dd>
<p>an ordered factor giving the unique identifier for each pair
of beef roasts with levels <code>II-1</code> &lt; ... &lt; <code>IV-1</code>
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Cochran and Cox (section 11.51, 1957) describe data from an
experiment conducted at Iowa State College (Paul, 1943) to
compare the effects of length of cold storage on the tenderness of
beef roasts.  Six storage periods ranging from 0 to 18 days were used.
Thirty roasts were scored by four judges on a scale from 0 to 10, with
the score increasing with tenderness. The response was the sum of all
four scores. Left and right roasts from the same animal were grouped
into pairs, which were further grouped into five blocks, according to
the muscle from which they were extracted. Different storage periods
were applied to each roast within a pair according to a balanced
incomplete block design.</p>


<h3>Source</h3>

<p>Cochran, W. G. and Cox, G. M. (1957), <em>Experimental Designs</em>,
Wiley, New York.
</p>

<hr>
<h2 id='Milk'>Protein content of cows' milk</h2><span id='topic+Milk'></span>

<h3>Description</h3>

<p>The <code>Milk</code> data frame has 1337 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>protein</dt><dd>
<p>a numeric vector giving the protein content of the milk.
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector giving the time since calving (weeks).
</p>
</dd>
<dt>Cow</dt><dd>
<p>an ordered factor giving a unique identifier for each cow.
</p>
</dd>
<dt>Diet</dt><dd>
<p>a factor with levels
<code>barley</code>, 
<code>barley+lupins</code>, and 
<code>lupins</code> identifying the diet for each cow.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Diggle, Liang, and Zeger (1994) describe data on the protein content
of cows' milk in the weeks following calving.  The cattle are grouped
according to whether they are fed a diet with barley alone, with
barley and lupins, or with lupins alone. 
</p>


<h3>Source</h3>

<p>Diggle, Peter J., Liang, Kung-Yee and Zeger, Scott L. (1994),
<em>Analysis of longitudinal data</em>, Oxford University Press,
Oxford.
</p>

<hr>
<h2 id='model.matrix.reStruct'>reStruct Model Matrix</h2><span id='topic+model.matrix.reStruct'></span>

<h3>Description</h3>

<p>The model matrices for each element of <code>formula(object)</code>,
calculated using <code>data</code>, are bound together column-wise. When
multiple grouping levels are present (i.e. when <code>length(object) &gt;
    1</code>), the individual model matrices are combined from innermost (at
the leftmost position) to outermost (at the rightmost position). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
model.matrix(object, data, contrast, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="model.matrix.reStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables defined in
<code>formula(object)</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.reStruct_+3A_contrast">contrast</code></td>
<td>
<p>an optional named list specifying the contrasts to be used
for representing the <code>factor</code> variables in <code>data</code>. The
components names should match the names of the variables in
<code>data</code> for which the contrasts are to be specified. The
components of this list will be used as the <code>contrasts</code>
attribute of the corresponding factor. If missing, the default
contrast specification is used.</p>
</td></tr>  
<tr><td><code id="model.matrix.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a matrix obtained by binding together, column-wise, the model matrices
for each element of <code>formula(object)</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+contrasts">contrasts</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>, <code><a href="#topic+formula.reStruct">formula.reStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(Dog = ~day, Side = ~1), data = Pixel)
model.matrix(rs1, Pixel)
</code></pre>

<hr>
<h2 id='Muscle'>Contraction of heart muscle sections</h2><span id='topic+Muscle'></span>

<h3>Description</h3>

<p>The <code>Muscle</code> data frame has 60 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Strip</dt><dd>
<p>an ordered factor indicating the strip of muscle being measured.
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the concentration of CaCl2
</p>
</dd>
<dt>length</dt><dd>
<p>a numeric vector giving the shortening of the heart muscle strip.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Baumann and Waldvogel (1963) describe data on the shortening of heart
muscle strips dipped in a <code class="reqn">\mbox{CaCl}{}_2</code> solution.
The muscle strips are taken from the left auricle of a rat's heart.</p>


<h3>Source</h3>

<p>Baumann, F. and Waldvogel, F. (1963), La restitution pastsystolique
de la contraction de l'oreillette gauche du rat. Effets de divers
ions et de l'acetylcholine, <em>Helvetica Physiologica Acta</em>,
<b>21</b>.
</p>

<hr>
<h2 id='Names'>Names Associated with an Object</h2><span id='topic+Names'></span><span id='topic+Names+3C-'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>formula</code>, <code>modelStruct</code>,
<code>pdBlocked</code>, <code>pdMat</code>, and <code>reStruct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Names(object, ...)
Names(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names_+3A_object">object</code></td>
<td>
<p>any object for which names can be extracted and/or assigned.</p>
</td></tr>
<tr><td><code id="Names_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
<tr><td><code id="Names_+3A_value">value</code></td>
<td>
<p>names to be assigned to <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the names associated with
<code>object</code> to <code>value</code>, which must have an appropriate length. 
</p>


<h3>Note</h3>

<p>If <code>names</code> were generic, there would be no need for this generic
function. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Names.formula">Names.formula</a></code>,
<code><a href="#topic+Names.pdMat">Names.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='Names.formula'>Extract Names from a formula</h2><span id='topic+Names.formula'></span><span id='topic+Names.listForm'></span>

<h3>Description</h3>

<p>This method function returns the names of the terms corresponding to
the right hand side of <code>object</code> (treated as a linear formula),
obtained as the column names of the corresponding
<code>model.matrix</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
Names(object, data, exclude, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names.formula_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="stats.html#topic+formula">formula</a>"</code>.</p>
</td></tr>
<tr><td><code id="Names.formula_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables specified
in <code>object</code>. By default the variables are taken from the
environment from which <code>Names.formula</code> is called.</p>
</td></tr>
<tr><td><code id="Names.formula_+3A_exclude">exclude</code></td>
<td>
<p>an optional character vector with names to be excluded
from the returned value. Default is <code>c("pi",".")</code>.</p>
</td></tr>
<tr><td><code id="Names.formula_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a character vector with the column names of the <code>model.matrix</code>
corresponding to the right hand side of <code>object</code> which are not
listed in <code>excluded</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="#topic+Names">Names</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Names(distance ~ Sex * age, data = Orthodont)
</code></pre>

<hr>
<h2 id='Names.pdBlocked'>Names of a pdBlocked Object</h2><span id='topic+Names.pdBlocked'></span><span id='topic+Names+3C-.pdBlocked'></span>

<h3>Description</h3>

<p>This method function extracts the first element of the <code>Dimnames</code>
attribute, which contains the column names, for each block diagonal
element in the matrix represented by <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdBlocked'
Names(object, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names.pdBlocked_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdBlocked">pdBlocked</a>"</code>
representing a positive-definite matrix with block diagonal
structure</p>
</td></tr> 
<tr><td><code id="Names.pdBlocked_+3A_aslist">asList</code></td>
<td>
<p>a logical value. If <code>TRUE</code> a <code>list</code> with the
names for each block diagonal element is returned. If <code>FALSE</code>
a character vector with all column names is returned. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Names.pdBlocked_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>asList</code> is <code>FALSE</code>, a character vector with column names
of the matrix represented by <code>object</code>; otherwise, if
<code>asList</code> is <code>TRUE</code>, a list with components given by the
column names of the individual block diagonal elements in the matrix
represented by <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Names">Names</a></code>,
<code><a href="#topic+Names.pdMat">Names.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdBlocked(list(~Sex - 1, ~age - 1), data = Orthodont)
Names(pd1)
</code></pre>

<hr>
<h2 id='Names.pdMat'>Names of a pdMat Object</h2><span id='topic+Names.pdMat'></span><span id='topic+Names+3C-.pdMat'></span>

<h3>Description</h3>

<p>This method function returns the fist element of the <code>Dimnames</code>
attribute of <code>object</code>, which contains the column names of the
matrix represented by <code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
Names(object, ...)
## S3 replacement method for class 'pdMat'
Names(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>,
representing a positive-definite matrix.</p>
</td></tr>
<tr><td><code id="Names.pdMat_+3A_value">value</code></td>
<td>
<p>a character vector with the replacement values for the
column and row names of the matrix represented by <code>object</code>. It
must have length equal to the dimension of the matrix
represented by <code>object</code> and, if names have been previously
assigned to <code>object</code>, it must correspond to a permutation of the
original names.</p>
</td></tr>
<tr><td><code id="Names.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>object</code> has a <code>Dimnames</code> attribute then the first
element of this attribute is returned; otherwise <code>NULL</code>. 
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the <code>Dimnames</code> attribute
of <code>object</code> to <code>list(value, value)</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Names">Names</a></code>, <code><a href="#topic+Names.pdBlocked">Names.pdBlocked</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(~age, data = Orthodont)
Names(pd1)
</code></pre>

<hr>
<h2 id='Names.reStruct'>Names of an reStruct Object</h2><span id='topic+Names.reStruct'></span><span id='topic+Names+3C-.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts the column names of each of the
positive-definite matrices represented the <code>pdMat</code>
elements of <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
Names(object, ...)
## S3 replacement method for class 'reStruct'
Names(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="Names.reStruct_+3A_value">value</code></td>
<td>
<p>a list of character vectors with the replacement values
for the names of the individual <code>pdMat</code> objects that form
<code>object</code>. It must have the same length as <code>object</code>.</p>
</td></tr>
<tr><td><code id="Names.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list containing the column names of each of the positive-definite
matrices represented by the <code>pdMat</code> elements of <code>object</code>. 
</p>


<h3>SIDE EFFECTS</h3>

<p>On the left side of an assignment, sets the <code>Names</code> of the
<code>pdMat</code> elements of <code>object</code> to the corresponding element of
<code>value</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>, <code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+Names.pdMat">Names.pdMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(Dog = ~day, Side = ~1), data = Pixel)
Names(rs1)
</code></pre>

<hr>
<h2 id='needUpdate'>Check if Update is Needed</h2><span id='topic+needUpdate'></span><span id='topic+needUpdate.default'></span><span id='topic+needUpdate.varComb'></span><span id='topic+needUpdate.varIdent'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. By default, it tries to extract a
<code>needUpdate</code> attribute of <code>object</code>. If this is <code>NULL</code>
or <code>FALSE</code> it returns <code>FALSE</code>; else it returns <code>TRUE</code>.
Updating of objects usually takes place in iterative algorithms in
which auxiliary quantities associated with the object, and not being
optimized over, may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needUpdate(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="needUpdate_+3A_object">object</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether <code>object</code> needs to be updated. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+needUpdate.modelStruct">needUpdate.modelStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varExp()
vf1 &lt;- Initialize(vf1, data = Orthodont)
needUpdate(vf1)
</code></pre>

<hr>
<h2 id='needUpdate.modelStruct'>Check if a modelStruct Object Needs Updating</h2><span id='topic+needUpdate.modelStruct'></span><span id='topic+needUpdate.corStruct'></span><span id='topic+needUpdate.reStruct'></span>

<h3>Description</h3>

<p>This method function checks if any of the elements of <code>object</code>
needs to be updated. Updating of objects usually takes place in
iterative algorithms in which auxiliary quantities associated with the
object, and not being optimized over, may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelStruct'
needUpdate(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="needUpdate.modelStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"modelStruct"</code>,
representing a list of model components, such as <code>corStruct</code> and
<code>varFunc</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating whether any element of <code>object</code> needs
to be updated.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+needUpdate">needUpdate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lms1 &lt;- lmeStruct(reStruct = reStruct(pdDiag(diag(2), ~age)),
   varStruct = varPower(form = ~age))
needUpdate(lms1)
</code></pre>

<hr>
<h2 id='Nitrendipene'>Assay of nitrendipene</h2><span id='topic+Nitrendipene'></span>

<h3>Description</h3>

<p>The <code>Nitrendipene</code> data frame has 89 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>activity</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>NIF</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Tissue</dt><dd>
<p>an ordered factor with levels
<code>2</code> &lt; <code>1</code> &lt; <code>3</code> &lt; <code>4</code>
</p>
</dd>
<dt>log.NIF</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bates, D. M. and Watts, D. G. (1988), <em>Nonlinear Regression
Analysis and Its Applications</em>, Wiley, New York.
</p>

<hr>
<h2 id='nlme'>Nonlinear Mixed-Effects Models</h2><span id='topic+nlme'></span><span id='topic+nlme.formula'></span>

<h3>Description</h3>

<p>This generic function fits a nonlinear mixed-effects model in the
formulation described in Lindstrom and Bates (1990) but allowing for nested
random effects. The within-group errors are allowed to be correlated
and/or have unequal variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlme(model, data, fixed, random, groups, start, correlation, weights,
     subset, method, na.action, naPattern, control, verbose)

## S3 method for class 'formula'
nlme(model, data, fixed, random, groups, start, correlation, weights,
     subset, method, na.action, naPattern, control, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlme_+3A_model">model</code></td>
<td>
<p>a nonlinear model formula, with the response on the left
of a <code>~</code> operator and an expression involving parameters and
covariates on the right, or an <code>nlsList</code> object.  If
<code>data</code> is given, all names used in the formula should be
defined as parameters or variables in the data frame. The method
function <code><a href="#topic+nlme.nlsList">nlme.nlsList</a></code> is documented separately.</p>
</td></tr>
<tr><td><code id="nlme_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>model</code>, <code>fixed</code>, <code>random</code>, <code>correlation</code>,
<code>weights</code>, <code>subset</code>, and <code>naPattern</code>.  By default the
variables are taken from the environment from which <code>nlme</code> is
called.</p>
</td></tr>
<tr><td><code id="nlme_+3A_fixed">fixed</code></td>
<td>
<p>a two-sided linear formula of the form
<code>f1+...+fn~x1+...+xm</code>, or a list of two-sided formulas of the form
<code>f1~x1+...+xm</code>, with possibly different models for different
parameters. The <code>f1,...,fn</code> are the names of parameters included on
the right hand side of <code>model</code> and the <code>x1+...+xm</code>
expressions define linear models for these parameters (when the left
hand side of the formula contains several parameters, they all are
assumed to follow the same linear model, described by the right hand
side expression).
A <code>1</code> on the right hand side of the formula(s) indicates a single
fixed effects for the corresponding parameter(s).</p>
</td></tr>
<tr><td><code id="nlme_+3A_random">random</code></td>
<td>
<p>optionally, any of the following: (i) a two-sided formula
of the form <code>r1+...+rn~x1+...+xm | g1/.../gQ</code>, with
<code>r1,...,rn</code> naming parameters included on the right
hand side of <code>model</code>, <code>x1+...+xm</code> specifying the
random-effects model for
these parameters and <code>g1/.../gQ</code> the grouping structure
(<code>Q</code> may be equal to 1, in which case no <code>/</code> is
required). The random effects formula will be repeated
for all levels of grouping, in the case of multiple levels of
grouping; (ii) a two-sided formula of the form
<code>r1+...+rn~x1+..+xm</code>, a list of two-sided formulas of the form
<code>r1~x1+...+xm</code>, with possibly different random-effects models
for different parameters, a <code>pdMat</code> object with a two-sided
formula, or list of two-sided formulas (i.e. a non-<code>NULL</code> value for
<code>formula(random)</code>), or a list of pdMat objects with two-sided
formulas, or lists of two-sided formulas. In this case, the grouping
structure formula will be given in <code>groups</code>, or derived from the
data used to fit the nonlinear mixed-effects model, which should
inherit from class  <code>groupedData</code>,; (iii) a named list
of formulas, lists of formulas, or <code>pdMat</code> objects as in (ii),
with the grouping factors as names. The order of nesting will be
assumed the same as the order of the order of the elements in the
list; (iv) an <code>reStruct</code> object. See the documentation on
<code><a href="#topic+pdClasses">pdClasses</a></code> for a description of the available <code>pdMat</code>
classes. Defaults to <code>fixed</code>,
resulting in all fixed effects having also random effects.</p>
</td></tr>
<tr><td><code id="nlme_+3A_groups">groups</code></td>
<td>
<p>an optional one-sided formula of the form <code>~g1</code>
(single level of nesting) or <code>~g1/.../gQ</code> (multiple levels of
nesting), specifying the partitions of the data over which the random
effects vary. <code>g1,...,gQ</code> must evaluate to factors in
<code>data</code>. The order of nesting, when multiple levels are present,
is taken from left to right (i.e. <code>g1</code> is the first level,
<code>g2</code> the second, etc.).</p>
</td></tr>
<tr><td><code id="nlme_+3A_start">start</code></td>
<td>
<p>an optional numeric vector, or list of initial estimates
for the fixed effects and random effects. If declared as a numeric
vector, it is converted internally to a list with a single component
<code>fixed</code>, given by the vector. The <code>fixed</code> component
is required, unless the model function inherits from class
<code>selfStart</code>, in which case initial values will be derived from a
call to <code>nlsList</code>. An optional <code>random</code> component is used to specify
initial values for the random effects and should consist of a matrix,
or a list of matrices with length equal to the number of grouping
levels. Each matrix should have as many rows as the number of groups
at the corresponding level and as many columns as the number of
random effects in that level.</p>
</td></tr>
<tr><td><code id="nlme_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code>corStruct</code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. Defaults to <code>NULL</code>, corresponding to no within-group
correlations.</p>
</td></tr>
<tr><td><code id="nlme_+3A_weights">weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td></tr>
<tr><td><code id="nlme_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="nlme_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"ML"</code>.</p>
</td></tr>
<tr><td><code id="nlme_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>nlme</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="nlme_+3A_napattern">naPattern</code></td>
<td>
<p>an expression or formula object, specifying which returned
values are to be regarded as missing.</p>
</td></tr>
<tr><td><code id="nlme_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code>nlmeControl</code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="nlme_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>nlme</code> representing the nonlinear
mixed-effects model fit. Generic functions such as <code>print</code>,
<code>plot</code> and <code>summary</code> have methods to show the results of the
fit. See <code>nlmeObject</code> for the components of the fit. The functions
<code>resid</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>, and
<code>random.effects</code>  can be used to extract some of its components.
</p>


<h3>Note</h3>

<p>The function does not do any scaling internally: the optimization will
work best when the response is scaled so its variance is of the order
of one.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The model formulation and computational methods are described in
Lindstrom, M.J. and Bates, D.M. (1990). The variance-covariance
parametrizations are described in Pinheiro and Bates (1996).
</p>
<p>Lindstrom, M.J. and Bates, D.M. (1990) &quot;Nonlinear Mixed Effects Models
for Repeated Measures Data&quot;, Biometrics, 46, 673-687.
</p>
<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289-296.
</p>
<p>For the different correlation structures, variance functions and links,
see &lsquo;References&rsquo; in <code><a href="#topic+lme">lme</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlmeControl">nlmeControl</a></code>, <code><a href="#topic+nlme.nlsList">nlme.nlsList</a></code>,
<code><a href="#topic+nlmeObject">nlmeObject</a></code>, <code><a href="#topic+nlsList">nlsList</a></code>,
<code><a href="#topic+nlmeStruct">nlmeStruct</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>, <code><a href="#topic+varFunc">varFunc</a></code>,
<code><a href="#topic+corClasses">corClasses</a></code>, <code><a href="#topic+varClasses">varClasses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- nlme(height ~ SSasymp(age, Asym, R0, lrc),
            data = Loblolly,
            fixed = Asym + R0 + lrc ~ 1,
            random = Asym ~ 1,
            start = c(Asym = 103, R0 = -8.5, lrc = -3.3))
summary(fm1)
fm2 &lt;- update(fm1, random = pdDiag(Asym + lrc ~ 1))
summary(fm2)
</code></pre>

<hr>
<h2 id='nlme-deprecated'>Deprecated Functions in Package <span class="pkg">nlme</span></h2><span id='topic+nlme-deprecated'></span><span id='topic+nfGroupedData'></span><span id='topic+nmGroupedData'></span><span id='topic+corIdent'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of
<span class="pkg">nlme</span> only, and may be defunct as soon as the next release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## internal functions wrapped by groupedData()
nfGroupedData(formula, data, order.groups, FUN, outer, inner,
              labels, units)
nmGroupedData(formula, data, order.groups, FUN, outer, inner,
              labels, units)

## trivial "identity" correlation, never usefully implemented:
corIdent(form = NULL)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>assertDeprecation &lt;- function(expr)
  tools::assertCondition(expr, verbose = TRUE,
    if(getRversion() &gt;= "3.6.0") "deprecatedWarning" else "warning")

assertDeprecation(
  nlme::nfGroupedData(height ~ age | Subject, as.data.frame(Oxboys))
)
assertDeprecation( csId &lt;-  corIdent(~ 1 | Subject) )
assertDeprecation( csI. &lt;- Initialize(csId, data = Orthodont) )
assertDeprecation( corMatrix(csI.) )  # actually errors
</code></pre>

<hr>
<h2 id='nlme.nlsList'>NLME fit from nlsList Object</h2><span id='topic+nlme.nlsList'></span>

<h3>Description</h3>

<p>If the random effects names defined in <code>random</code> are a subset of
the <code>lmList</code> object coefficient names, initial estimates for the
covariance matrix of the random effects are obtained (overwriting any
values given in <code>random</code>). <code>formula(fixed)</code> and the
<code>data</code> argument in the calling sequence used to obtain
<code>fixed</code> are passed as the <code>fixed</code> and <code>data</code> arguments
to <code>nlme.formula</code>, together with any other additional arguments in
the function call. See the documentation on <code><a href="#topic+nlme.formula">nlme.formula</a></code> for a
description of that function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsList'
nlme(model, data, fixed, random, groups, start, correlation, weights,
     subset, method, na.action, naPattern, control, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlme.nlsList_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+nlsList">nlsList</a>"</code>,
representing a list of <code>nls</code> fits with a common model.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_data">data</code></td>
<td>
<p>this argument is included for consistency with the generic
function. It is ignored in this method function.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_fixed">fixed</code></td>
<td>
<p>this argument is included for consistency with the generic
function. It is ignored in this method function.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_random">random</code></td>
<td>
<p>an optional one-sided linear formula with no conditioning
expression, or a <code>pdMat</code> object with a <code>formula</code>
attribute. Multiple levels of grouping are not allowed with this
method function.  Defaults to a formula consisting of the right hand
side of <code>formula(fixed)</code>.</p>
</td></tr> 
<tr><td><code id="nlme.nlsList_+3A_groups">groups</code></td>
<td>
<p>an optional one-sided formula of the form <code>~g1</code>
(single level of nesting) or <code>~g1/.../gQ</code> (multiple levels of
nesting), specifying the partitions of the data over which the random
effects vary. <code>g1,...,gQ</code> must evaluate to factors in
<code>data</code>. The order of nesting, when multiple levels are present,
is taken from left to right (i.e. <code>g1</code> is the first level,
<code>g2</code> the second, etc.).</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_start">start</code></td>
<td>
<p>an optional numeric vector, or list of initial estimates
for the fixed effects and random effects. If declared as a numeric
vector, it is converted internally to a list with a single component
<code>fixed</code>, given by the vector. The <code>fixed</code> component
is required, unless the model function inherits from class
<code>selfStart</code>, in which case initial values will be derived from a
call to <code>nlsList</code>. An optional <code>random</code> component is used to specify
initial values for the random effects and should consist of a matrix,
or a list of matrices with length equal to the number of grouping
levels. Each matrix should have as many rows as the number of groups
at the corresponding level and as many columns as the number of
random effects in that level.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_correlation">correlation</code></td>
<td>
<p>an optional <code>corStruct</code> object describing the
within-group correlation structure. See the documentation of
<code><a href="#topic+corClasses">corClasses</a></code> for a description of the available <code>corStruct</code>
classes. Defaults to <code>NULL</code>, corresponding to no within-group
correlations.</p>
</td></tr> 
<tr><td><code id="nlme.nlsList_+3A_weights">weights</code></td>
<td>
<p>an optional <code>varFunc</code> object or one-sided formula
describing the within-group heteroscedasticity structure. If given as
a formula, it is used as the argument to <code>varFixed</code>,
corresponding to fixed variance weights. See the documentation on
<code><a href="#topic+varClasses">varClasses</a></code> for a description of the available <code>varFunc</code>
classes. Defaults to <code>NULL</code>, corresponding to homoscedastic
within-group errors.</p>
</td></tr> 
<tr><td><code id="nlme.nlsList_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_method">method</code></td>
<td>
<p>a character string.  If <code>"REML"</code> the model is fit by
maximizing the restricted log-likelihood.  If <code>"ML"</code> the
log-likelihood is maximized.  Defaults to <code>"ML"</code>.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>nlme</code> to print an error message and terminate if there are any
incomplete observations.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_napattern">naPattern</code></td>
<td>
<p>an expression or formula object, specifying which returned
values are to be regarded as missing.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_control">control</code></td>
<td>
<p>a list of control values for the estimation algorithm to
replace the default values returned by the function <code>nlmeControl</code>.
Defaults to an empty list.</p>
</td></tr>
<tr><td><code id="nlme.nlsList_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> information on
the evolution of the iterative algorithm is printed. Default is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>nlme</code> representing the linear mixed-effects
model fit. Generic functions such as <code>print</code>, <code>plot</code> and
<code>summary</code> have methods to show the results of the fit. See
<code>nlmeObject</code> for the components of the fit. The functions
<code>resid</code>, <code>coef</code>, <code>fitted</code>, <code>fixed.effects</code>, and
<code>random.effects</code>  can be used to extract some of its components.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>The computational methods follow on the general framework of Lindstrom,
M.J. and Bates, D.M. (1988). The model formulation is described in
Laird, N.M. and Ware, J.H. (1982).  The variance-covariance
parametrizations are described in &lt;Pinheiro, J.C. and Bates., D.M.
(1996).  The different correlation structures available for the
<code>correlation</code> argument are described in Box, G.E.P., Jenkins,
G.M., and Reinsel G.C. (1994), Littel, R.C., Milliken, G.A., Stroup,
W.W., and Wolfinger, R.D. (1996), and Venables, W.N. and Ripley,
B.D. (2002). The use of variance functions for linear and nonlinear
mixed effects models is presented in detail in Davidian, M. and
Giltinan, D.M. (1995).
</p>
<p>Box, G.E.P., Jenkins, G.M., and Reinsel G.C. (1994) &quot;Time Series
Analysis: Forecasting and Control&quot;, 3rd Edition, Holden-Day. 
</p>
<p>Davidian, M. and Giltinan, D.M. (1995) &quot;Nonlinear Mixed Effects Models
for Repeated Measurement Data&quot;, Chapman and Hall.
</p>
<p>Laird, N.M. and Ware, J.H. (1982) &quot;Random-Effects Models for
Longitudinal Data&quot;, Biometrics, 38, 963-974.  
</p>
<p>Lindstrom, M.J. and Bates, D.M. (1988) &quot;Newton-Raphson and EM
Algorithms for Linear Mixed-Effects Models for Repeated-Measures
Data&quot;, Journal of the American Statistical Association, 83,
1014-1022. 
</p>
<p>Littel, R.C., Milliken, G.A., Stroup, W.W., and Wolfinger, R.D. (1996)
&quot;SAS Systems for Mixed Models&quot;, SAS Institute.
</p>
<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289-296.
</p>
<p>Venables, W.N. and Ripley, B.D. (2002) &quot;Modern Applied Statistics with
S&quot;, 4th Edition, Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>, <code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+nlmeObject">nlmeObject</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- nlsList(SSasymp, data = Loblolly)
fm2 &lt;- nlme(fm1, random = Asym ~ 1)
summary(fm1)
summary(fm2)
</code></pre>

<hr>
<h2 id='nlmeControl'>Control Values for nlme Fit</h2><span id='topic+nlmeControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a
list with all possible arguments is returned.  The returned list is
used as the <code>control</code> argument to the <code>nlme</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmeControl(maxIter, pnlsMaxIter, msMaxIter, minScale,
            tolerance, niterEM, pnlsTol, msTol,
            returnObject, msVerbose, msWarnNoConv,
            gradHess, apVar, .relStep, minAbsParApVar = 0.05,
            opt = c("nlminb", "nlm"), natural = TRUE, sigma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeControl_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum number of iterations for the <code>nlme</code>
optimization algorithm.  Default is 50.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_pnlsmaxiter">pnlsMaxIter</code></td>
<td>
<p>maximum number of iterations
for the <code>PNLS</code> optimization step inside the <code>nlme</code>
optimization.  Default is 7.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_msmaxiter">msMaxIter</code></td>
<td>
<p>maximum number of iterations for <code><a href="stats.html#topic+nlminb">nlminb</a></code>
(<code>iter.max</code>) or the <code><a href="stats.html#topic+nlm">nlm</a></code> (<code>iterlim</code>, from the
10-th step) optimization step inside the <code>nlme</code>
optimization.  Default is 50 (which may be too small for e.g. for
overparametrized cases).</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_minscale">minScale</code></td>
<td>
<p>minimum factor by which to shrink the default step size
in an attempt to decrease the sum of squares in the <code>PNLS</code> step.
Default <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the convergence criterion in the
<code>nlme</code> algorithm.  Default is <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_niterem">niterEM</code></td>
<td>
<p>number of iterations for the EM algorithm used to refine
the initial estimates of the random effects variance-covariance
coefficients.  Default is 25.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_pnlstol">pnlsTol</code></td>
<td>
<p>tolerance for the convergence criterion in <code>PNLS</code>
step.  Default is <code>1e-3</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_mstol">msTol</code></td>
<td>
<p>tolerance for the convergence criterion in <code>nlm</code>,
passed as the <code>gradtol</code> argument to the function (see
documentation on <code>nlm</code>).  Default is <code>1e-7</code>. </p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_returnobject">returnObject</code></td>
<td>
<p>a logical value indicating whether the fitted
object should be returned when the maximum number of iterations is
reached without convergence of the algorithm.  Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_msverbose">msVerbose</code></td>
<td>
<p>a logical value passed as the <code>trace</code> to
<code><a href="stats.html#topic+nlminb">nlminb</a>(.., control= list(trace = *, ..))</code> or
as argument <code>print.level</code> to <code><a href="stats.html#topic+nlm">nlm</a>()</code>.  Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_mswarnnoconv">msWarnNoConv</code></td>
<td>
<p>logical indicating if a <code><a href="base.html#topic+warning">warning</a></code>
should be signalled whenever the minimization (by <code>opt</code>) in the
LME step does not converge; defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_gradhess">gradHess</code></td>
<td>
<p>a logical value indicating whether numerical gradient
vectors and Hessian matrices of the log-likelihood function should
be used in the <code>nlm</code> optimization. This option is only available
when the correlation structure (<code>corStruct</code>) and the variance
function structure (<code>varFunc</code>) have no &quot;varying&quot; parameters and
the <code>pdMat</code> classes used in the random effects structure are
<code>pdSymm</code> (general positive-definite), <code>pdDiag</code> (diagonal),
<code>pdIdent</code> (multiple of the identity),  or
<code>pdCompSymm</code> (compound symmetry).  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_apvar">apVar</code></td>
<td>
<p>a logical value indicating whether the approximate
covariance matrix of the variance-covariance parameters should be
calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_.relstep">.relStep</code></td>
<td>
<p>relative step for numerical derivatives
calculations.  Default is <code>.Machine$double.eps^(1/3)</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_minabsparapvar">minAbsParApVar</code></td>
<td>
<p>numeric value - minimum absolute parameter value
in the approximate variance calculation.  The default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_opt">opt</code></td>
<td>
<p>the optimizer to be used, either <code>"<a href="stats.html#topic+nlminb">nlminb</a>"</code> (the
default) or <code>"<a href="stats.html#topic+nlm">nlm</a>"</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_natural">natural</code></td>
<td>
<p>a logical value indicating whether the <code>pdNatural</code>
parametrization should be used for general positive-definite matrices
(<code>pdSymm</code>) in <code>reStruct</code>, when the approximate covariance
matrix of the estimators is calculated.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_sigma">sigma</code></td>
<td>
<p>optionally a positive number to fix the residual error at.
If <code>NULL</code>, as by default, or <code>0</code>, sigma is estimated.</p>
</td></tr>
<tr><td><code id="nlmeControl_+3A_...">...</code></td>
<td>
<p>Further, named control arguments to be passed to
<code><a href="stats.html#topic+nlminb">nlminb</a></code> (apart from <code>trace</code> and <code>iter.max</code>
mentioned above), where used (<code>eval.max</code> and those from
<code>abs.tol</code> down).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>; the
<code>sigma</code> option: Siem Heisterkamp and Bert van Willigen.</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+nlmeStruct">nlmeStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># decrease the maximum number of iterations and request tracing
nlmeControl(msMaxIter = 20, msVerbose = TRUE)
</code></pre>

<hr>
<h2 id='nlmeObject'>Fitted nlme Object</h2><span id='topic+nlmeObject'></span>

<h3>Description</h3>

<p>An object returned by the <code><a href="#topic+nlme">nlme</a></code> function, inheriting from class
<code>"nlme"</code>, also inheriting from class <code>"lme"</code>, and representing a
fitted nonlinear mixed-effects model. Objects of this class have
methods for the generic functions  <code>anova</code>, <code>coef</code>,
<code>fitted</code>, <code>fixed.effects</code>, <code>formula</code>, <code>getGroups</code>,
<code>getResponse</code>, <code>intervals</code>, <code>logLik</code>, <code>pairs</code>,
<code>plot</code>, <code>predict</code>, <code>print</code>, <code>random.effects</code>,
<code>residuals</code>, <code>summary</code>, and <code>update</code>.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>"nlme"</code>
object.
</p>
<table>
<tr><td><code>apVar</code></td>
<td>
<p>an approximate covariance matrix for the
variance-covariance coefficients. If <code>apVar = FALSE</code> in the
control values used in the call to <code>nlme</code>, this component is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>nlme</code> call that
produced the object.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with two components, <code>fixed</code> and
<code>random</code>, where the first is a vector containing the estimated
fixed effects and the second is a list of matrices with the estimated
random effects for each level of grouping. For each matrix in the
<code>random</code> list, the columns refer to the random effects and the
rows to the groups.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list of the contrast matrices used to represent factors
in the fixed effects formula  and/or random effects formula. This
information is important for making predictions from a new data
frame in which not all levels of the original factors are
observed. If no factors are used in the nlme model, this component
will be an empty list.</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>a list with basic dimensions used in the nlme fit,
including the components <code>N</code> - the number of observations in
the data, <code>Q</code> - the number of grouping levels, <code>qvec</code> -
the number of random effects at each level from innermost to
outermost (last two values are equal to zero and correspond to the
fixed effects and the response), <code>ngrps</code> - the number of groups
at each level from innermost to outermost (last two values are one
and correspond to the fixed effects and the response), and
<code>ncol</code> - the number of columns in the model matrix for each
level of grouping from innermost to outermost (last two values are
equal to the number of fixed effects and one).</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a data frame with the fitted values as columns. The
leftmost column corresponds to the population fixed effects
(corresponding to the fixed effects only) and successive columns
from left to right correspond to increasing levels of grouping.</p>
</td></tr>
<tr><td><code>fixDF</code></td>
<td>
<p>a list with components <code>X</code> and <code>terms</code>
specifying the denominator degrees of freedom for, respectively,
t-tests for the individual fixed effects and F-tests for the
fixed-effects terms in the models.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>a data frame with the grouping factors as
columns. The grouping level increases from left to right.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the (restricted) log-likelihood at convergence.</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>a list with components <code>fmap</code>, <code>rmap</code>,
<code>rmapRel</code>, and <code>bmap</code>, specifying various mappings for the
fixed and random effects, used to generate predictions from the
fitted object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the estimation method: either <code>"ML"</code> for maximum
likelihood, or <code>"REML"</code> for restricted maximum likelihood.</p>
</td></tr>
<tr><td><code>modelStruct</code></td>
<td>
<p>an object inheriting from class <code>nlmeStruct</code>,
representing a list of mixed-effects model components, such
as <code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code>numIter</code></td>
<td>
<p>the number of iterations used in the iterative
algorithm.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a data frame with the residuals as columns. The
leftmost column corresponds to the population residuals
and successive columns from left to right correspond to increasing
levels of grouping.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the estimated within-group error standard deviation.</p>
</td></tr>
<tr><td><code>varFix</code></td>
<td>
<p>an approximate covariance matrix of the
fixed effects estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>, <code>nlmeStruct</code></p>

<hr>
<h2 id='nlmeStruct'>Nonlinear Mixed-Effects Structure</h2><span id='topic+nlmeStruct'></span>

<h3>Description</h3>

<p>A nonlinear mixed-effects structure is a list of model components
representing different sets of parameters in the nonlinear mixed-effects
model. An <code>nlmeStruct</code> list must contain at least a
<code>reStruct</code> object, but may also contain <code>corStruct</code> and
<code>varFunc</code> objects. <code>NULL</code> arguments are not included in the
<code>nlmeStruct</code> list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlmeStruct(reStruct, corStruct, varStruct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlmeStruct_+3A_restruct">reStruct</code></td>
<td>
<p>a <code>reStruct</code> representing a random effects
structure.</p>
</td></tr>
<tr><td><code id="nlmeStruct_+3A_corstruct">corStruct</code></td>
<td>
<p>an optional <code>corStruct</code> object, representing a
correlation structure. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nlmeStruct_+3A_varstruct">varStruct</code></td>
<td>
<p>an optional <code>varFunc</code> object, representing a
variance function structure. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of model components determining the parameters to be estimated
for the associated nonlinear mixed-effects model.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+nlme">nlme</a></code>,
<code><a href="#topic+residuals.nlmeStruct">residuals.nlmeStruct</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>nlms1 &lt;- nlmeStruct(reStruct(~age), corAR1(), varPower())
</code></pre>

<hr>
<h2 id='nlsList'>List of nls Objects with a Common Model</h2><span id='topic+nlsList'></span><span id='topic+nlsList.formula'></span><span id='topic+update.nlsList'></span>

<h3>Description</h3>

<p><code>Data</code> is partitioned according to the levels of the grouping
factor defined in <code>model</code> and individual <code>nls</code> fits are
obtained for each <code>data</code> partition, using the model defined in
<code>model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsList(model, data, start, control, level, subset,
        na.action = na.fail, pool = TRUE, warn.nls = NA)

## S3 method for class 'formula'
nlsList(model, data, start, control, level, subset,
        na.action = na.fail, pool = TRUE, warn.nls = NA)

## S3 method for class 'nlsList'
update(object, model., ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>nlsList</code>, representing
a list of fitted <code>nls</code> objects.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_model">model</code></td>
<td>
<p>either a nonlinear model formula, with the response on
the left of a <code>~</code> operator and an expression involving
parameters, covariates, and a grouping factor separated by the
<code>|</code> operator on the right, or a <code>selfStart</code> function.  The
method function <code><a href="#topic+nlsList.selfStart">nlsList.selfStart</a></code> is documented separately.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_model.">model.</code></td>
<td>
<p>changes to the model &ndash; see <code><a href="stats.html#topic+update.formula">update.formula</a></code>
for details.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
<code>model</code>.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_start">start</code></td>
<td>
<p>an optional named list with initial values for the
parameters to be estimated in <code>model</code>. It is passed as the
<code>start</code> argument to each <code>nls</code> call and is required when
the nonlinear function in <code>model</code> does not inherit from class
<code>selfStart</code>.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_control">control</code></td>
<td>
<p>a list of control values passed as the <code>control</code>
argument to <code>nls</code>.  Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_level">level</code></td>
<td>
<p>an optional integer specifying the level of grouping to
be used when multiple nested levels of grouping are present.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>nlsList</code> to print an error message and terminate if there are any
incomplete observations.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_pool">pool</code></td>
<td>

<p>an optional logical value that is preserved as an attribute of the
returned value.  This will be used as the default for <code>pool</code> in
calculations of standard deviations or standard errors for summaries.
</p>
</td></tr>
<tr><td><code id="nlsList_+3A_warn.nls">warn.nls</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if <code><a href="stats.html#topic+nls">nls</a>()</code>
errors (all of which are caught by <code><a href="base.html#topic+tryCatch">tryCatch</a></code>) should be
signalled as a &ldquo;summarizing&rdquo; <code><a href="base.html#topic+warning">warning</a></code>.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
<tr><td><code id="nlsList_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code> evaluate the new call else return the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As <code><a href="stats.html#topic+nls">nls</a>(.)</code> is called on each sub group, and convergence
of these may be problematic, these calls happen with error catching.
</p>
<p>Since <span class="pkg">nlme</span> version <code>3.1-127</code> (2016-04), all the errors are
caught (via <code><a href="base.html#topic+tryCatch">tryCatch</a></code>) and if present, a &ldquo;summarizing&rdquo;
<code><a href="base.html#topic+warning">warning</a></code> is stored as attribute of the resulting
<code>"nlsList"</code> object and signalled unless suppressed by
<code>warn.nls = FALSE</code> or currently also when <code>warn.nls = NA</code>
(default) <em>and</em> <code><a href="base.html#topic+getOption">getOption</a>("show.error.messages")</code> is
false.
</p>
<p><code>nlsList()</code> originally had used <code><a href="base.html#topic+try">try</a>(*)</code> (with its default
<code>silent=FALSE)</code> and hence all errors were printed to the console
<em>unless</em> the global option <code>show.error.messages</code> was set to true.
This still works, but has been <em>deprecated</em>.
</p>


<h3>Value</h3>

<p>a list of <code>nls</code> objects with as many components as the number of
groups defined by the grouping factor.  Generic functions such as
<code>coef</code>, <code>fixed.effects</code>, <code>lme</code>, <code>pairs</code>,
<code>plot</code>, <code>predict</code>, <code>random.effects</code>, <code>summary</code>,
and <code>update</code> have methods that can be applied to an <code>nlsList</code>
object.
</p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000), <em>Mixed-Effects Models
in S and S-PLUS</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="#topic+nlme.nlsList">nlme.nlsList</a></code>,
<code><a href="#topic+nlsList.selfStart">nlsList.selfStart</a></code>,
<code><a href="#topic+summary.nlsList">summary.nlsList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- nlsList(uptake ~ SSasympOff(conc, Asym, lrc, c0),
   data = CO2, start = c(Asym = 30, lrc = -4.5, c0 = 52))
summary(fm1)
cfm1 &lt;- confint(fm1) # via profiling each % FIXME: only *one* message instead of one *each*
mat.class &lt;- class(matrix(1)) # ("matrix", "array") for R &gt;= 4.0.0;  ("matrix" in older R)
i.ok &lt;- which(vapply(cfm1,
                function(r) identical(class(r), mat.class), NA))
stopifnot(length(i.ok) &gt; 0, !anyNA(match(c(2:4, 6:9, 12), i.ok)))
## where as (some of) the others gave errors during profile re-fitting :
str(cfm1[- i.ok])
</code></pre>

<hr>
<h2 id='nlsList.selfStart'>nlsList Fit from a selfStart Function</h2><span id='topic+nlsList.selfStart'></span>

<h3>Description</h3>

<p>The response variable and primary covariate in <code>formula(data)</code>
are used together with <code>model</code> to construct the nonlinear model
formula. This is used in the <code>nls</code> calls and, because a
selfStarting model function can calculate initial estimates for its
parameters from the data, no starting estimates need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selfStart'
nlsList(model, data, start, control, level, subset,
        na.action = na.fail, pool = TRUE, warn.nls = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsList.selfStart_+3A_model">model</code></td>
<td>
<p>a <code>"<a href="stats.html#topic+selfStart">selfStart</a>"</code> model function, which calculates
initial estimates for the model parameters from <code>data</code>.</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables in
<code>model</code>. Because no grouping factor can be specified in
<code>model</code>, <code>data</code> must inherit from class
<code>"<a href="#topic+groupedData">groupedData</a>"</code>.
</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_start">start</code></td>
<td>
<p>an optional named list with initial values for the
parameters to be estimated in <code>model</code>. It is passed as the
<code>start</code> argument to each <code>nls</code> call and is required when
the nonlinear function in <code>model</code> does not inherit from class
<code>selfStart</code>.
</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_control">control</code></td>
<td>
<p>a list of control values passed as the <code>control</code>
argument to <code>nls</code>. Defaults to an empty list.
</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_level">level</code></td>
<td>
<p>an optional integer specifying the level of grouping to
be used when multiple nested levels of grouping are present.</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows of
<code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a  character  vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.fail</code>) causes
<code>nlsList</code> to print an error message and terminate if there are any
incomplete observations.
</p>
</td></tr>
<tr><td><code id="nlsList.selfStart_+3A_pool">pool</code>, <code id="nlsList.selfStart_+3A_warn.nls">warn.nls</code></td>
<td>
<p>optional <code><a href="base.html#topic+logical">logical</a></code>s, see <code><a href="#topic+nlsList">nlsList</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>nls</code> objects with as many components as the number of
groups defined by the grouping factor. A <code>NULL</code> value is assigned
to the components corresponding to clusters for which the <code>nls</code>
algorithm failed to converge. Generic functions such as <code>coef</code>,
<code>fixed.effects</code>, <code>lme</code>, <code>pairs</code>, <code>plot</code>,
<code>predict</code>, <code>random.effects</code>, <code>summary</code>, and
<code>update</code> have methods that can be applied to an <code>nlsList</code>
object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+selfStart">selfStart</a></code>, <code><a href="#topic+groupedData">groupedData</a></code>,
<code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="#topic+nlsList">nlsList</a></code>,
<code><a href="#topic+nlme.nlsList">nlme.nlsList</a></code>, <code><a href="#topic+nlsList.formula">nlsList.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- nlsList(SSasympOff, CO2)
summary(fm1)
</code></pre>

<hr>
<h2 id='Oats'>Split-plot Experiment on Varieties of Oats</h2><span id='topic+Oats'></span>

<h3>Description</h3>

<p>The <code>Oats</code> data frame has 72 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Block</dt><dd>
<p>an ordered factor with levels
<code>VI</code> &lt; <code>V</code> &lt; <code>III</code> &lt; <code>IV</code> &lt; <code>II</code> &lt; <code>I</code>
</p>
</dd>
<dt>Variety</dt><dd>
<p>a factor with levels
<code>Golden Rain</code> 
<code>Marvellous</code> 
<code>Victory</code> 
</p>
</dd>
<dt>nitro</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>yield</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data have been introduced by Yates (1935) as an example of a
split-plot design. The treatment structure used in the experiment was
a <code class="reqn">3 \times 4</code> full factorial, with three varieties of oats
and four concentrations of nitrogen. The experimental units were
arranged into six blocks, each with three whole-plots subdivided into
four subplots. The varieties of oats were assigned randomly to the
whole-plots and the concentrations of nitrogen to the subplots.  All
four concentrations of nitrogen were used on each whole-plot.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.15)
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S. (4th ed)</em>, Springer, New York.
</p>

<hr>
<h2 id='Orthodont'>Growth curve data on an orthdontic measurement</h2><span id='topic+Orthodont'></span>

<h3>Description</h3>

<p>The <code>Orthodont</code> data frame has 108 rows and 4 columns of the
change in an orthdontic measurement over time for several young subjects.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>distance</dt><dd>
<p>a numeric vector of distances from the pituitary to the
pterygomaxillary fissure (mm).  These distances are measured
on x-ray images of the skull.
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector of ages of the subject (yr).
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor indicating the subject on which the
measurement was made.  The levels are labelled <code>M01</code>
to <code>M16</code> for the males and <code>F01</code> to <code>F13</code> for
the females.  The ordering is by increasing average distance
within sex.
</p>
</dd>
<dt>Sex</dt><dd>
<p>a factor with levels
<code>Male</code> and
<code>Female</code> 
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Investigators at the University of North Carolina Dental School
followed the growth of 27 children (16 males, 11 females) from age 8
until age 14.  Every two years they measured the distance between the
pituitary and the pterygomaxillary fissure, two points that are easily
identified on x-ray exposures of the side of the head.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.17)
</p>
<p>Potthoff, R. F. and Roy,  S. N. (1964), &ldquo;A generalized multivariate
analysis of variance model useful especially for growth curve
problems&rdquo;, <em>Biometrika</em>, <b>51</b>, 313&ndash;326.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formula(Orthodont)
plot(Orthodont)
</code></pre>

<hr>
<h2 id='Ovary'>Counts of Ovarian Follicles</h2><span id='topic+Ovary'></span>

<h3>Description</h3>

<p>The <code>Ovary</code> data frame has 308 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Mare</dt><dd>
<p>an ordered factor indicating the mare on which the
measurement is made.
</p>
</dd>
<dt>Time</dt><dd>
<p>time in the estrus cycle.  The data were recorded daily from 3
days before ovulation until 3 days after the next ovulation. The
measurement times for each mare are scaled so that the ovulations for
each mare occur at times 0 and 1.
</p>
</dd>
<dt>follicles</dt><dd>
<p>the number of ovarian follicles greater than 10 mm in diameter.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Pierson and Ginther (1987) report on a study of the number of large
ovarian follicles detected in different mares at several times in
their estrus cycles.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.18)
</p>
<p>Pierson, R. A. and Ginther, O. J. (1987), Follicular population
dynamics during the estrus cycle of the mare, <em>Animal
Reproduction Science</em>, <b>14</b>, 219-231.
</p>

<hr>
<h2 id='Oxboys'>Heights of Boys in Oxford</h2><span id='topic+Oxboys'></span>

<h3>Description</h3>

<p>The <code>Oxboys</code> data frame has 234 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>an ordered factor giving a unique identifier for each boy in
the experiment
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector giving the standardized age (dimensionless)
</p>
</dd>
<dt>height</dt><dd>
<p>a numeric vector giving the height of the boy (cm)
</p>
</dd>
<dt>Occasion</dt><dd>
<p>an ordered factor - the result of converting <code>age</code> from a
continuous variable to a count so these slightly unbalanced
data can be analyzed as balanced.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are described in Goldstein (1987) as data on the
height of a selection of boys from Oxford, England versus a
standardized age.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in
S and S-PLUS</em>, Springer, New York.  (Appendix A.19)
</p>

<hr>
<h2 id='Oxide'>Variability in Semiconductor Manufacturing</h2><span id='topic+Oxide'></span>

<h3>Description</h3>

<p>The <code>Oxide</code> data frame has 72 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Source</dt><dd>
<p>a factor with levels
<code>1</code> and
<code>2</code> 
</p>
</dd>
<dt>Lot</dt><dd>
<p>a factor giving a unique identifier for each lot.
</p>
</dd>
<dt>Wafer</dt><dd>
<p>a factor giving a unique identifier for each wafer within a lot.
</p>
</dd>
<dt>Site</dt><dd>
<p>a factor with levels
<code>1</code>, 
<code>2</code>, and 
<code>3</code> 
</p>
</dd>
<dt>Thickness</dt><dd>
<p>a numeric vector giving the thickness of the oxide layer.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are described in Littell et al. (1996, p. 155) as coming
&ldquo;from a passive data collection study in the semiconductor industry
where the objective is to estimate the variance components to
determine the assignable causes of the observed variability.&rdquo; The
observed response is the thickness of the oxide layer on silicon
wafers, measured at three different sites of each of three wafers
selected from each of eight lots sampled from the population of
lots.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.20)
</p>
<p>Littell, R. C., Milliken, G. A., Stroup, W. W. and Wolfinger,
R. D. (1996), <em>SAS System for Mixed Models</em>, SAS Institute,
Cary, NC.
</p>

<hr>
<h2 id='pairs.compareFits'>Pairs Plot of compareFits Object</h2><span id='topic+pairs.compareFits'></span>

<h3>Description</h3>

<p>Scatter plots of the values being compared are generated for each pair
of coefficients in <code>x</code>. Different symbols (colors) are used
for each object being compared and values corresponding to the same
group are joined by a line, to facilitate comparison of fits. If only
two coefficients are present, the <code>trellis</code> function
<code>xyplot</code> is used; otherwise the <code>trellis</code> function <code>splom</code>
is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compareFits'
pairs(x, subset, key, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.compareFits_+3A_x">x</code></td>
<td>
<p>an object of class <code>compareFits</code>.</p>
</td></tr>
<tr><td><code id="pairs.compareFits_+3A_subset">subset</code></td>
<td>
<p>an optional logical or integer vector specifying which
rows of <code>x</code> should be used in the plots. If missing, all
rows are used.</p>
</td></tr>
<tr><td><code id="pairs.compareFits_+3A_key">key</code></td>
<td>
<p>an optional logical value, or list. If <code>TRUE</code>, a legend
is included at the top of the plot indicating which symbols (colors)
correspond to which objects being compared. If <code>FALSE</code>, no legend
is included. If given as a list, <code>key</code> is passed down as an
argument to the <code>trellis</code> function generating the plots
(<code>splom</code> or  <code>xyplot</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="pairs.compareFits_+3A_...">...</code></td>
<td>
<p>optional arguments passed down to the <code>trellis</code>
function generating the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pairwise scatter plots of the values being compared, with different
symbols (colors) used for each object under comparison.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>See Also</h3>

<p><code><a href="#topic+compareFits">compareFits</a></code>,
<code><a href="#topic+plot.compareFits">plot.compareFits</a></code>,
<code><a href="#topic+pairs.lme">pairs.lme</a></code>,
<code><a href="#topic+pairs.lmList">pairs.lmList</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+splom">splom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(compareFits) # cF12 &lt;- compareFits(coef(lmList(Orthodont)), .. lme(*))
pairs(cF12)
</code></pre>

<hr>
<h2 id='pairs.lme'>Pairs Plot of an lme Object</h2><span id='topic+pairs.lme'></span>

<h3>Description</h3>

<p>Diagnostic plots for the linear mixed-effects fit are obtained. The
<code>form</code> argument gives considerable flexibility in the type of
plot specification. A conditioning expression (on the right side of a
<code>|</code> operator) always implies that different panels are used for
each level of the conditioning factor, according to a Trellis
display. The expression on the right hand side of the formula, before
a <code>|</code> operator, must evaluate to a data frame with at least two
columns. If the data frame has two columns, a scatter plot of the two
variables is displayed (the Trellis function <code>xyplot</code> is
used). Otherwise, if more than two columns are present, a scatter plot
matrix with pairwise scatter plots of the columns in the data frame is
displayed (the Trellis function <code>splom</code> is used). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
pairs(x, form, label, id, idLabels, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.lme_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="pairs.lme_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>x</code> can be referenced. In addition, <code>x</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. The expression on the right hand side of <code>form</code>, and to
the left of the <code>|</code> operator, must evaluate to a data frame with
at least two columns. Default is <code>~ coef(.) </code>, corresponding to
a pairs plot of the coefficients evaluated at the innermost level of
nesting.</p>
</td></tr>    
<tr><td><code id="pairs.lme_+3A_label">label</code></td>
<td>
<p>an optional character vector of labels for the variables
in the pairs plot.</p>
</td></tr>
<tr><td><code id="pairs.lme_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for an outlier
test based on the Mahalanobis distances of the estimated random
effects. Groups with random effects distances greater than the
<code class="reqn">1-value</code> percentile of the appropriate chi-square distribution
are identified in the plot using <code>idLabels</code>. If given as a
one-sided formula, its right hand side must evaluate to a  logical,
integer, or character vector which is used to identify points in the
plot. If missing, no points are identified.</p>
</td></tr>
<tr><td><code id="pairs.lme_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
points identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
points. Default is the innermost grouping factor. 
</p>
</td></tr>
<tr><td><code id="pairs.lme_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairs.lme_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+pairs.compareFits">pairs.compareFits</a></code>, 
<code><a href="#topic+pairs.lmList">pairs.lmList</a></code>, 
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+splom">splom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)

# scatter plot of coefficients by gender, identifying unusual subjects
pairs(fm1, ~coef(., augFrame = TRUE) | Sex, id = 0.1, adj = -0.5)    

# scatter plot of estimated random effects :
pairs(fm1, ~ranef(.))
</code></pre>

<hr>
<h2 id='pairs.lmList'>Pairs Plot of an lmList Object</h2><span id='topic+pairs.lmList'></span>

<h3>Description</h3>

<p>Diagnostic plots for the linear model fits corresponding to the
<code>x</code>  components  are obtained. The <code>form</code> argument
gives considerable  flexibility in the type of plot specification. A
conditioning  expression (on the right side of a <code>|</code> operator)
always implies  that different panels are used for  each level of the
conditioning  factor, according to a Trellis display. The expression
on the right  hand side of the formula, before a <code>|</code> operator,
must evaluate to  a data frame with at least two columns. If the data
frame has two  columns, a scatter plot of the two variables is
displayed (the Trellis  function <code>xyplot</code> is used). Otherwise, if
more than two columns  are present, a scatter plot matrix with
pairwise scatter plots of the  columns in the data frame is displayed
(the Trellis function  <code>splom</code> is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
pairs(x, form, label, id, idLabels, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.lmList_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>x</code> can be referenced. In addition, <code>x</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. The expression on the right hand side of <code>form</code>, and to
the left of the <code>|</code> operator, must evaluate to a data frame with
at least two columns. Default is <code>~ coef(.) </code>, corresponding to
a pairs plot of the coefficients of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_label">label</code></td>
<td>
<p>an optional character vector of labels for the variables
in the pairs plot.</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for an outlier
test based on the Mahalanobis distances of the estimated random
effects. Groups with random effects distances greater than the
<code class="reqn">1-value</code> percentile of the appropriate chi-square distribution
are identified in the plot using <code>idLabels</code>. If given as a
one-sided formula, its right hand side must evaluate to a  logical,
integer, or character vector which is used to identify points in the
plot. If missing, no points are identified.
</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
points identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
points. Default is the innermost grouping factor.
</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairs.lmList_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>,
<code><a href="#topic+pairs.lme">pairs.lme</a></code>,
<code><a href="#topic+pairs.compareFits">pairs.compareFits</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+splom">splom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)

# scatter plot of coefficients by gender, identifying unusual subjects
pairs(fm1, ~coef(.) | Sex, id = 0.1, adj = -0.5)

# scatter plot of estimated random effects -- "bivariate Gaussian (?)"
pairs(fm1, ~ranef(.))
</code></pre>

<hr>
<h2 id='PBG'>Effect of Phenylbiguanide on Blood Pressure</h2><span id='topic+PBG'></span>

<h3>Description</h3>

<p>The <code>PBG</code> data frame has 60 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>deltaBP</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>dose</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Run</dt><dd>
<p>an ordered factor with levels
<code>T5</code> &lt; <code>T4</code> &lt; <code>T3</code> &lt; <code>T2</code> &lt; <code>T1</code> &lt; <code>P5</code> &lt; <code>P3</code> &lt; <code>P2</code> &lt; <code>P4</code> &lt; <code>P1</code>
</p>
</dd>
<dt>Treatment</dt><dd>
<p>a factor with levels
<code>MDL 72222</code> 
<code>Placebo</code> 
</p>
</dd>
<dt>Rabbit</dt><dd>
<p>an ordered factor with levels
<code>5</code> &lt; <code>3</code> &lt; <code>2</code> &lt; <code>4</code> &lt; <code>1</code>
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data on an experiment to examine the effect of a antagonist MDL 72222
on the change in blood pressure experienced with increasing dosage of
phenylbiguanide are described in Ludbrook (1994) and analyzed
in Venables and Ripley (2002, section 10.3).  Each of five rabbits was exposed to
increasing doses of phenylbiguanide after having either a placebo or
the HD5-antagonist MDL 72222 administered.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.21)
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied
Statistics with S (4th ed)</em>, Springer, New York.
</p>
<p>Ludbrook, J. (1994), Repeated measurements and multiple comparisons
in cardiovascular research, <em>Cardiovascular Research</em>,
<b>28</b>, 303-311.
</p>

<hr>
<h2 id='pdBlocked'>Positive-Definite Block Diagonal Matrix</h2><span id='topic+pdBlocked'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdBlocked</code> class,
representing a positive-definite block-diagonal matrix. Each
block-diagonal element of the underlying  matrix is itself a
positive-definite matrix and is represented internally as an
individual <code>pdMat</code> object. When <code>value</code> is
<code>numeric(0)</code>, a list of uninitialized <code>pdMat</code> objects, a
list of one-sided formulas, or a list of vectors 
of character strings,  <code>object</code> is returned
as an uninitialized <code>pdBlocked</code> object (with just some of its
attributes and its class defined) and needs to have its coefficients
assigned later, generally using the <code>coef</code> or <code>matrix</code> replacement
functions. If <code>value</code> is a list of  initialized <code>pdMat</code>
objects, <code>object</code> will be constructed from the list obtained by
applying <code>as.matrix</code> to each of the <code>pdMat</code> elements of
<code>value</code>. Finally, if <code>value</code> is a list of numeric vectors,
they are assumed to represent the unrestricted coefficients
of the block-diagonal elements of the  underlying positive-definite
matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdBlocked(value, form, nam, data, pdClass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdBlocked_+3A_value">value</code></td>
<td>
<p>an optional list with elements to be used as the
<code>value</code> argument to other <code>pdMat</code> constructors. These
include: <code>pdMat</code> objects, positive-definite
matrices, one-sided linear formulas, vectors of character strings, or
numeric vectors. All elements in the list must be similar (e.g. all
one-sided formulas, or all numeric vectors). Defaults to
<code>numeric(0)</code>, corresponding to an uninitialized object.</p>
</td></tr>
<tr><td><code id="pdBlocked_+3A_form">form</code></td>
<td>
<p>an optional list of one-sided linear formulas specifying the
row/column names for the block-diagonal elements of the matrix
represented by <code>object</code>. Because factors may be present in
<code>form</code>, the formulas needs to be evaluated on a data.frame to
resolve the names they define. This argument is ignored when
<code>value</code> is a list of one-sided formulas. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdBlocked_+3A_nam">nam</code></td>
<td>
<p>an optional list of vector of character strings specifying the
row/column names for the block-diagonal elements of the matrix
represented by object. Each of its components must have  
length equal to the dimension of the corresponding block-diagonal
element and unreplicated elements. This argument is ignored when 
<code>value</code> is a list of vector of character strings. Defaults to 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdBlocked_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on any
<code>factors</code> appearing in the formulas. Defaults to the parent
frame from which the function was called.</p>
</td></tr>
<tr><td><code id="pdBlocked_+3A_pdclass">pdClass</code></td>
<td>
<p>an optional vector of character strings naming the
<code>pdMat</code> classes to be assigned to the individual blocks in the
underlying matrix. If a single class is specified, it is used for all
block-diagonal elements. This argument will only be used when
<code>value</code> is missing, or its elements are not <code>pdMat</code>
objects. Defaults to <code>"pdSymm"</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>pdBlocked</code> object representing a positive-definite
block-diagonal matrix, also inheriting from class <code>pdMat</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 162.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdBlocked(list(diag(1:2), diag(c(0.1, 0.2, 0.3))),
                 nam = list(c("A","B"), c("a1", "a2", "a3")))
pd1
</code></pre>

<hr>
<h2 id='pdClasses'>Positive-Definite Matrix Classes</h2><span id='topic+pdClasses'></span>

<h3>Description</h3>

<p>Standard classes of positive-definite matrices (<code>pdMat</code>)
structures  available in the <code>nlme</code> package. 
</p>


<h3>Value</h3>

<p>Available standard classes:
</p>
<table>
<tr><td><code>pdSymm</code></td>
<td>
<p>general positive-definite matrix, with no additional
structure</p>
</td></tr>
<tr><td><code>pdLogChol</code></td>
<td>
<p>general positive-definite matrix, with no additional
structure, using a log-Cholesky parameterization</p>
</td></tr>
<tr><td><code>pdDiag</code></td>
<td>
<p>diagonal</p>
</td></tr>
<tr><td><code>pdIdent</code></td>
<td>
<p>multiple of an identity</p>
</td></tr>
<tr><td><code>pdCompSymm</code></td>
<td>
<p>compound symmetry structure (constant diagonal and
constant off-diagonal elements)</p>
</td></tr>
<tr><td><code>pdBlocked</code></td>
<td>
<p>block-diagonal matrix, with diagonal blocks of any
&quot;atomic&quot; <code>pdMat</code> class</p>
</td></tr>
<tr><td><code>pdNatural</code></td>
<td>
<p>general positive-definite matrix in natural
parametrization (i.e. parametrized in terms of standard deviations
and correlations). The underlying coefficients are not unrestricted,
so this class should NOT be used for optimization.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Users may define their own <code>pdMat</code> classes by specifying a
<code>constructor</code> function and, at a minimum, methods for the
functions <code>pdConstruct</code>, <code>pdMatrix</code> and <code>coef</code>. For
examples of these functions, see the methods for classes <code>pdSymm</code>
and <code>pdDiag</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdBlocked">pdBlocked</a></code>,
<code><a href="#topic+pdCompSymm">pdCompSymm</a></code>,
<code><a href="#topic+pdDiag">pdDiag</a></code>,
<code><a href="#topic+pdFactor">pdFactor</a></code>, 
<code><a href="#topic+pdIdent">pdIdent</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+pdMatrix">pdMatrix</a></code>,
<code><a href="#topic+pdNatural">pdNatural</a></code>,
<code><a href="#topic+pdSymm">pdSymm</a></code>,
<code><a href="#topic+pdLogChol">pdLogChol</a></code>
</p>

<hr>
<h2 id='pdCompSymm'>Positive-Definite Matrix with Compound Symmetry Structure</h2><span id='topic+pdCompSymm'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdCompSymm</code> class,
representing a positive-definite matrix with compound symmetry
structure (constant diagonal and constant off-diagonal elements). The
underlying matrix is represented by 2 unrestricted parameters.
When <code>value</code> is <code>numeric(0)</code>, an uninitialized <code>pdMat</code>
object, a one-sided formula, or a vector of character strings,
<code>object</code> is returned  as an uninitialized <code>pdCompSymm</code>
object (with just some of its  attributes and its class defined) and
needs to have its coefficients assigned later, generally using the
<code>coef</code> or <code>matrix</code> replacement functions. If <code>value</code> is
an initialized
<code>pdMat</code> object, <code>object</code> will be constructed from 
<code>as.matrix(value)</code>. Finally, if <code>value</code> is a numeric vector
of length 2, it is assumed to represent the unrestricted coefficients
of the underlying positive-definite matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdCompSymm(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdCompSymm_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector of length 2. Defaults to <code>numeric(0)</code>, corresponding to
an uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdCompSymm_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdCompSymm_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdCompSymm_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdCompSymm</code> object representing a positive-definite
matrix with compound symmetry structure, also inheriting from class
<code>pdMat</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 161.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdCompSymm(diag(3) + 1, nam = c("A","B","C"))
pd1
</code></pre>

<hr>
<h2 id='pdConstruct'>Construct pdMat Objects</h2><span id='topic+pdConstruct'></span><span id='topic+pdConstruct.pdCompSymm'></span><span id='topic+pdConstruct.pdDiag'></span><span id='topic+pdConstruct.pdIdent'></span><span id='topic+pdConstruct.pdMat'></span><span id='topic+pdConstruct.pdNatural'></span><span id='topic+pdConstruct.pdSymm'></span><span id='topic+pdConstruct.pdLogChol'></span>

<h3>Description</h3>

<p>This function is an alternative constructor for the <code>pdMat</code>
class associated with <code>object</code> and is mostly used internally in other
functions. See the documentation on the principal constructor
function, generally with the same name as the <code>pdMat</code> class of
object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdConstruct(object, value, form, nam, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdConstruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>pdMat</code>, representing
a positive definite matrix.</p>
</td></tr> 
<tr><td><code id="pdConstruct_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector. Defaults to <code>numeric(0)</code>, corresponding to an
uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdConstruct_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdConstruct_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdConstruct_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
<tr><td><code id="pdConstruct_+3A_...">...</code></td>
<td>
<p>optional arguments for some methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdMat</code> object representing a positive-definite matrix,
inheriting from the same classes as <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdCompSymm">pdCompSymm</a></code>, <code><a href="#topic+pdDiag">pdDiag</a></code>,
<code><a href="#topic+pdIdent">pdIdent</a></code>, <code><a href="#topic+pdNatural">pdNatural</a></code>, <code><a href="#topic+pdSymm">pdSymm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm()
pdConstruct(pd1, diag(1:4))
</code></pre>

<hr>
<h2 id='pdConstruct.pdBlocked'>Construct pdBlocked Objects</h2><span id='topic+pdConstruct.pdBlocked'></span>

<h3>Description</h3>

<p>This function give an alternative constructor for the <code>pdBlocked</code>
class, representing a positive-definite block-diagonal matrix. Each
block-diagonal element of the underlying  matrix is itself a
positive-definite matrix and is represented internally as an
individual <code>pdMat</code> object. When <code>value</code> is
<code>numeric(0)</code>, a list of uninitialized <code>pdMat</code> objects, a
list of one-sided formulas, or a list of vectors of character strings,
<code>object</code> is returned as an uninitialized <code>pdBlocked</code> object
(with just some of its attributes and its class defined) and needs to
have its coefficients assigned later, generally using the <code>coef</code>
or <code>matrix</code> replacement functions. If <code>value</code> is a list of  initialized
<code>pdMat</code> objects, <code>object</code> will be constructed from the list
obtained by applying <code>as.matrix</code> to each of the <code>pdMat</code>
elements of <code>value</code>. Finally, if <code>value</code> is a list of
numeric vectors, they are assumed to represent the unrestricted
coefficients of the block-diagonal elements of the  underlying
positive-definite matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdBlocked'
pdConstruct(object, value, form, nam, data, pdClass,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdConstruct.pdBlocked_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"pdBlocked"</code>,
representing a positive definite block-diagonal matrix.</p>
</td></tr> 
<tr><td><code id="pdConstruct.pdBlocked_+3A_value">value</code></td>
<td>
<p>an optional list with elements to be used as the
<code>value</code> argument to other <code>pdMat</code> constructors. These
include: <code>pdMat</code> objects, positive-definite
matrices, one-sided linear formulas, vectors of character strings, or
numeric vectors. All elements in the list must be similar (e.g. all
one-sided formulas, or all numeric vectors). Defaults to
<code>numeric(0)</code>, corresponding to an uninitialized object.</p>
</td></tr>
<tr><td><code id="pdConstruct.pdBlocked_+3A_form">form</code></td>
<td>
<p>an optional list of one-sided linear formula specifying the
row/column names for the block-diagonal elements of the matrix
represented by <code>object</code>. Because factors may be present in
<code>form</code>, the formulas needs to be evaluated on a data.frame to
resolve the names they defines. This argument is ignored when
<code>value</code> is a list of one-sided formulas. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdConstruct.pdBlocked_+3A_nam">nam</code></td>
<td>
<p>an optional list of vector of character strings specifying the
row/column names for the block-diagonal elements of the matrix
represented by object. Each of its components must have  
length equal to the dimension of the corresponding block-diagonal
element and unreplicated elements. This argument is ignored when 
<code>value</code> is a list of vector of character strings. Defaults to 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdConstruct.pdBlocked_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
<tr><td><code id="pdConstruct.pdBlocked_+3A_pdclass">pdClass</code></td>
<td>
<p>an optional vector of character strings naming the
<code>pdMat</code> classes to be assigned to the individual blocks in the
underlying matrix. If a single class is specified, it is used for all
block-diagonal elements. This argument will only be used when
<code>value</code> is missing, or its elements are not <code>pdMat</code>
objects. Defaults to <code>"pdSymm"</code>.</p>
</td></tr> 
<tr><td><code id="pdConstruct.pdBlocked_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>pdBlocked</code> object representing a positive-definite
block-diagonal matrix, also inheriting from class <code>pdMat</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdBlocked">pdBlocked</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+pdConstruct">pdConstruct</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdBlocked(list(c("A","B"), c("a1", "a2", "a3")))
pdConstruct(pd1, list(diag(1:2), diag(c(0.1, 0.2, 0.3))))
</code></pre>

<hr>
<h2 id='pdDiag'>Diagonal Positive-Definite Matrix</h2><span id='topic+pdDiag'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdDiag</code> class,
representing a diagonal positive-definite matrix. If the matrix
associated with <code>object</code> is of dimension <code class="reqn">n</code>, it is
represented by <code class="reqn">n</code> unrestricted parameters, given by the logarithm
of the square-root of the diagonal values. When <code>value</code> is
<code>numeric(0)</code>, an uninitialized <code>pdMat</code> object, a one-sided
formula, or a vector of character strings, <code>object</code> is returned
as an uninitialized <code>pdDiag</code> object (with just some of its
attributes and its class defined) and needs to have its coefficients
assigned later, generally using the <code>coef</code> or <code>matrix</code> replacement
functions. If <code>value</code> is an initialized <code>pdMat</code> object,
<code>object</code> will be constructed from
<code>as.matrix(value)</code>. Finally, if <code>value</code> is a numeric vector,
it is assumed to represent the unrestricted coefficients of the
underlying positive-definite
matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdDiag(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdDiag_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector of length equal to the dimension of the underlying
positive-definite matrix. Defaults to <code>numeric(0)</code>, corresponding
to an uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdDiag_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdDiag_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdDiag_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdDiag</code> object representing a diagonal positive-definite
matrix, also inheriting from class <code>pdMat</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdDiag(diag(1:3), nam = c("A","B","C"))
pd1
</code></pre>

<hr>
<h2 id='pdFactor'>Square-Root Factor of a Positive-Definite Matrix</h2><span id='topic+pdFactor'></span><span id='topic+pdFactor.pdBlocked'></span><span id='topic+pdFactor.pdCompSymm'></span><span id='topic+pdFactor.pdDiag'></span><span id='topic+pdFactor.pdIdent'></span><span id='topic+pdFactor.pdMat'></span><span id='topic+pdFactor.pdNatural'></span><span id='topic+pdFactor.pdSymm'></span><span id='topic+pdFactor.pdLogChol'></span>

<h3>Description</h3>

<p>A square-root factor of the positive-definite matrix represented by
<code>object</code> is obtained. Letting <code class="reqn">\Sigma</code> denote a
positive-definite matrix, a square-root factor of <code class="reqn">\Sigma</code> is
any square matrix <code class="reqn">L</code> such that <code class="reqn">\Sigma = L'L</code>. This function extracts <code class="reqn">L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdFactor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdFactor_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>pdMat</code>, representing
a positive definite matrix, which must have been initialized
(i.e. <code>length(coef(object)) &gt; 0</code>).</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with a square-root factor of the positive-definite matrix
associated with <code>object</code> stacked column-wise.
</p>


<h3>Note</h3>

<p>This function is used intensively in optimization
algorithms and its value is returned as a vector for efficiency
reasons. The <code>pdMatrix</code> function can be used to obtain
square-root factors in matrix form.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMatrix">pdMatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdCompSymm(4 * diag(3) + 1)
pdFactor(pd1)
</code></pre>

<hr>
<h2 id='pdFactor.reStruct'>Extract Square-Root Factor from Components of an reStruct Object</h2><span id='topic+pdFactor.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts square-root factors of the
positive-definite matrices corresponding to the <code>pdMat</code> elements
of <code>object</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
pdFactor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdFactor.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with square-root factors of the positive-definite matrices
corresponding to the elements of <code>object</code> stacked column-wise.
</p>


<h3>Note</h3>

<p>This function is used intensively in optimization
algorithms and its value is returned as a vector for efficiency
reasons. The <code>pdMatrix</code> function can be used to obtain
square-root factors in matrix form.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdFactor">pdFactor</a></code>,
<code><a href="#topic+pdMatrix.reStruct">pdMatrix.reStruct</a></code>,
<code><a href="#topic+pdFactor.pdMat">pdFactor.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(pdSymm(diag(3), ~age+Sex, data = Orthodont))
pdFactor(rs1)
</code></pre>

<hr>
<h2 id='pdIdent'>Multiple of the Identity Positive-Definite Matrix</h2><span id='topic+pdIdent'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdIdent</code> class,
representing a multiple of the identity positive-definite matrix. 
The matrix associated with <code>object</code> is represented by 1
unrestricted parameter, given by the logarithm of the square-root of
the diagonal value. When <code>value</code> is 
<code>numeric(0)</code>, an uninitialized <code>pdMat</code> object, a one-sided
formula, or a vector of character strings, <code>object</code> is returned
as an uninitialized <code>pdIdent</code> object (with just some of its
attributes and its class defined) and needs to have its coefficients
assigned later, generally using the <code>coef</code> or <code>matrix</code> replacement
functions. If <code>value</code> is an initialized <code>pdMat</code> object,
<code>object</code> will be constructed from
<code>as.matrix(value)</code>. Finally, if <code>value</code> is a numeric value,
it is assumed to represent the unrestricted coefficient of the
underlying positive-definite  matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdIdent(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdIdent_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
value. Defaults to <code>numeric(0)</code>, corresponding
to an uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdIdent_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdIdent_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdIdent_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdIdent</code> object representing a multiple of the identity
positive-definite matrix, also inheriting from class <code>pdMat</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdIdent(4 * diag(3), nam = c("A","B","C"))
pd1
</code></pre>

<hr>
<h2 id='pdLogChol'>General Positive-Definite Matrix</h2><span id='topic+pdLogChol'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdLogChol</code> class,
representing a general positive-definite matrix.  If the matrix
associated with <code>object</code> is of dimension <code class="reqn">n</code>, it is
represented by <code class="reqn">n(n+1)/2</code> unrestricted parameters,
using the log-Cholesky parametrization described in Pinheiro and
Bates (1996).
</p>

<ul>
<li><p> When <code>value</code> is <code>numeric(0)</code>, an uninitialized <code>pdMat</code>
object, a one-sided formula, or a character vector, <code>object</code> is
returned as an <em>uninitialized</em> <code>pdLogChol</code> object (with just
some of its attributes and its class defined) and needs to have its
coefficients assigned later, generally using the <code>coef</code> or
<code>matrix</code> replacement functions.
</p>
</li>
<li><p> If <code>value</code> is an <em>initialized</em> <code>pdMat</code> object,
<code>object</code> will be constructed from <code>as.matrix(value)</code>.
</p>
</li>
<li><p> Finally, if <code>value</code> is a numeric vector, it is assumed to
represent the unrestricted coefficients of the matrix-logarithm
parametrization of the underlying positive-definite matrix.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pdLogChol(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdLogChol_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector.  Defaults to <code>numeric(0)</code>, corresponding to an
uninitialized object.</p>
</td></tr>
<tr><td><code id="pdLogChol_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>.  Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data frame to resolve the names it defines.  This
argument is ignored when <code>value</code> is a one-sided
formula.  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdLogChol_+3A_nam">nam</code></td>
<td>
<p>an optional character vector specifying the row/column names
for the matrix represented by object.  It must have length equal to
the dimension of the underlying positive-definite matrix and
unreplicated elements.  This argument is ignored when
<code>value</code> is a character vector.  Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdLogChol_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>.  It is used to obtain the
levels for <code>factors</code>, which affect the dimensions and the
row/column names of the underlying matrix.  If <code>NULL</code>, no
attempt is made to obtain information on <code>factor</code>s appearing in
the formulas.  Defaults to the parent frame from which the function
was called.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, the <code>pdLogChol</code> representation of a symmetric
positive definite matrix is a vector starting with the logarithms of
the diagonal of the Choleski factorization of that matrix followed by
its upper triangular portion.
</p>


<h3>Value</h3>

<p>a <code>pdLogChol</code> object representing a general positive-definite
matrix, also inheriting from class <code>pdMat</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C. and Bates., D.M. (1996)
Unconstrained Parametrizations for Variance-Covariance Matrices,
<em>Statistics and Computing</em> <b>6</b>, 289&ndash;296.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000)
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>(pd1 &lt;- pdLogChol(diag(1:3), nam = c("A","B","C")))

(pd4 &lt;- pdLogChol(1:6))
(pd4c &lt;- chol(pd4)) # -&gt; upper-tri matrix with off-diagonals  4 5 6
pd4c[upper.tri(pd4c)]
log(diag(pd4c)) # 1 2 3
</code></pre>

<hr>
<h2 id='pdMat'>Positive-Definite Matrix</h2><span id='topic+pdMat'></span><span id='topic+plot.pdMat'></span>

<h3>Description</h3>

<p>This function gives an alternative way of constructing an object
inheriting from the <code>pdMat</code> class named in <code>pdClass</code>, or
from <code>data.class(object)</code> if <code>object</code> inherits from
<code>pdMat</code>,  and is mostly used internally in other functions. See
the documentation on the principal constructor function, generally
with the same name as the <code>pdMat</code> class of object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdMat(value, form, nam, data, pdClass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdMat_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector. Defaults to <code>numeric(0)</code>, corresponding to an
uninitialized object.</p>
</td></tr>
<tr><td><code id="pdMat_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdMat_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdMat_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
<tr><td><code id="pdMat_+3A_pdclass">pdClass</code></td>
<td>
<p>an optional character string naming the
<code>pdMat</code> class to be assigned to the returned object. This
argument will only be used when <code>value</code> is not a <code>pdMat</code>
object. Defaults to <code>"pdSymm"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdMat</code> object representing a positive-definite matrix,
inheriting from the class named in <code>pdClass</code>, or from
<code>class(object)</code>, if <code>object</code> inherits from <code>pdMat</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+pdCompSymm">pdCompSymm</a></code>, <code><a href="#topic+pdDiag">pdDiag</a></code>,
<code><a href="#topic+pdIdent">pdIdent</a></code>, <code><a href="#topic+pdNatural">pdNatural</a></code>,
<code><a href="#topic+pdSymm">pdSymm</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+solve.pdMat">solve.pdMat</a></code>,
<code><a href="#topic+summary.pdMat">summary.pdMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdMat(diag(1:4), pdClass = "pdDiag")
pd1
str(pd1)
</code></pre>

<hr>
<h2 id='pdMatrix'>Extract Matrix or Square-Root Factor from a pdMat Object</h2><span id='topic+pdMatrix'></span><span id='topic+pdMatrix.pdBlocked'></span><span id='topic+pdMatrix.pdCompSymm'></span><span id='topic+pdMatrix.pdDiag'></span><span id='topic+pdMatrix.pdIdent'></span><span id='topic+pdMatrix.pdMat'></span><span id='topic+pdMatrix.pdSymm'></span><span id='topic+pdMatrix.pdNatural'></span>

<h3>Description</h3>

<p>The positive-definite matrix represented by <code>object</code>, or a
square-root factor of it is obtained. Letting <code class="reqn">\Sigma</code> denote a
positive-definite matrix, a square-root factor of <code class="reqn">\Sigma</code> is
any square matrix <code class="reqn">L</code> such that <code class="reqn">\Sigma = L'L</code>. This function extracts <code class="reqn">\Sigma</code> or <code class="reqn">L</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdMatrix(object, factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdMatrix_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>pdMat</code>, representing
a positive definite matrix.</p>
</td></tr>
<tr><td><code id="pdMatrix_+3A_factor">factor</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, a square-root
factor of the positive-definite matrix represented by <code>object</code>
is returned; else, if <code>FALSE</code>, the positive-definite matrix is
returned. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>factor</code> is <code>FALSE</code> the positive-definite matrix
represented by <code>object</code> is returned; else a square-root of the
positive-definite matrix is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 162.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+pdFactor">pdFactor</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+pdMatrix.reStruct">pdMatrix.reStruct</a></code>,
<code><a href="#topic+corMatrix">corMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(diag(1:4))
pdMatrix(pd1)
</code></pre>

<hr>
<h2 id='pdMatrix.reStruct'>Extract Matrix or Square-Root Factor from Components of an
reStruct Object</h2><span id='topic+pdMatrix.reStruct'></span>

<h3>Description</h3>

<p>This method function extracts the positive-definite  matrices
corresponding to the <code>pdMat</code> elements of <code>object</code>, or
square-root factors of the positive-definite matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
pdMatrix(object, factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdMatrix.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="pdMatrix.reStruct_+3A_factor">factor</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, square-root
factors of the positive-definite matrices represented by the elements
of <code>object</code> are returned; else, if <code>FALSE</code>, the
positive-definite matrices are returned. Defaults to <code>FALSE</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by the positive-definite matrices
corresponding to the elements of <code>object</code>, or square-root factors
of the positive-definite matrices.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 162.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.reStruct">as.matrix.reStruct</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>, 
<code><a href="#topic+pdMatrix">pdMatrix</a></code>, 
<code><a href="#topic+pdMatrix.pdMat">pdMatrix.pdMat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(pdSymm(diag(3), ~age+Sex, data = Orthodont))
pdMatrix(rs1)
</code></pre>

<hr>
<h2 id='pdNatural'>General Positive-Definite Matrix in Natural Parametrization</h2><span id='topic+pdNatural'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdNatural</code> class,
representing a general positive-definite matrix, using a natural
parametrization . If the matrix associated with <code>object</code> is of
dimension <code class="reqn">n</code>, it is represented by <code class="reqn">n(n+1)/2</code>
parameters. Letting <code class="reqn">\sigma_{ij}</code> denote the <code class="reqn">ij</code>-th
element of the underlying positive definite matrix and
<code class="reqn">\rho_{ij}=\sigma_{i}/\sqrt{\sigma_{ii}\sigma_{jj}},\;i\neq j</code> denote the associated
&quot;correlations&quot;, the &quot;natural&quot; parameters are given by
<code class="reqn">\sqrt{\sigma_{ii}}, \;i=1,\ldots,n</code> and
<code class="reqn">\log((1+\rho_{ij})/(1-\rho_{ij})),\; i \neq
    j</code>. Note that all
natural parameters are individually unrestricted, but not jointly
unrestricted (meaning that not all unrestricted vectors would give
positive-definite matrices). Therefore, this parametrization should
NOT be used for optimization. It is mostly used for deriving
approximate confidence intervals on parameters following the
optimization of an objective function. When <code>value</code> is
<code>numeric(0)</code>, an uninitialized <code>pdMat</code> object, a one-sided
formula, or a vector of character strings, <code>object</code> is returned
as an uninitialized <code>pdSymm</code> object (with just some of its
attributes and its class defined) and needs to have its coefficients
assigned later, generally using the <code>coef</code> or <code>matrix</code> replacement
functions. If <code>value</code> is an initialized <code>pdMat</code> object,
<code>object</code> will be constructed from
<code>as.matrix(value)</code>. Finally, if <code>value</code> is a numeric 
vector, it is assumed to represent the natural parameters of the
underlying positive-definite matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdNatural(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdNatural_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector. Defaults to <code>numeric(0)</code>, corresponding to an
uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdNatural_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdNatural_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdNatural_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdNatural</code> object representing a general positive-definite
matrix in natural parametrization, also inheriting from class
<code>pdMat</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. p. 162.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pdNatural(diag(1:3))
</code></pre>

<hr>
<h2 id='pdSymm'>General Positive-Definite Matrix</h2><span id='topic+pdSymm'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>pdSymm</code> class,
representing a general positive-definite matrix. If the matrix
associated with <code>object</code> is of dimension <code class="reqn">n</code>, it is
represented by <code class="reqn">n(n+1)/2</code> unrestricted parameters,
using the matrix-logarithm parametrization described in Pinheiro and
Bates (1996). When <code>value</code> is <code>numeric(0)</code>, an uninitialized
<code>pdMat</code> object, a one-sided
formula, or a vector of character strings, <code>object</code> is returned
as an uninitialized <code>pdSymm</code> object (with just some of its
attributes and its class defined) and needs to have its coefficients
assigned later, generally using the <code>coef</code> or <code>matrix</code> replacement
functions. If <code>value</code> is an initialized <code>pdMat</code> object,
<code>object</code> will be constructed from
<code>as.matrix(value)</code>. Finally, if <code>value</code> is a numeric vector,
it is assumed to represent the unrestricted coefficients of the
matrix-logarithm parametrization of the underlying positive-definite
matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdSymm(value, form, nam, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdSymm_+3A_value">value</code></td>
<td>
<p>an optional initialization value, which can be any of the
following: a <code>pdMat</code> object, a positive-definite
matrix, a one-sided linear formula (with variables separated by
<code>+</code>), a vector of character strings, or a numeric
vector. Defaults to <code>numeric(0)</code>, corresponding to an
uninitialized object.</p>
</td></tr> 
<tr><td><code id="pdSymm_+3A_form">form</code></td>
<td>
<p>an optional one-sided linear formula specifying the
row/column names for the matrix represented by <code>object</code>. Because
factors may be present in <code>form</code>, the formula needs to be
evaluated on a data.frame to resolve the names it defines. This
argument is ignored when <code>value</code> is a one-sided
formula. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdSymm_+3A_nam">nam</code></td>
<td>
<p>an optional vector of character strings specifying the
row/column names for the matrix represented by object. It must have 
length equal to the dimension of the underlying positive-definite
matrix and unreplicated elements. This argument is ignored when
<code>value</code> is a vector of character strings. Defaults to
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pdSymm_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
named in <code>value</code> and <code>form</code>. It is used to
obtain the levels for <code>factors</code>, which affect the
dimensions and the row/column names of the underlying matrix. If
<code>NULL</code>, no attempt is made to obtain information on 
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>pdSymm</code> object representing a general positive-definite
matrix, also inheriting from class <code>pdMat</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C. and Bates., D.M.  (1996) &quot;Unconstrained
Parametrizations for Variance-Covariance Matrices&quot;, Statistics and
Computing, 6, 289-296.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.pdMat">as.matrix.pdMat</a></code>,
<code><a href="#topic+coef.pdMat">coef.pdMat</a></code>,
<code><a href="#topic+pdClasses">pdClasses</a></code>,
<code><a href="#topic+matrix+3C-.pdMat">matrix&lt;-.pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdSymm(diag(1:3), nam = c("A","B","C"))
pd1
</code></pre>

<hr>
<h2 id='Phenobarb'>Phenobarbitol Kinetics</h2><span id='topic+Phenobarb'></span>

<h3>Description</h3>

<p>The <code>Phenobarb</code> data frame has 744 rows and 7 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>an ordered factor identifying the infant.
</p>
</dd>
<dt>Wt</dt><dd>
<p>a numeric vector giving the birth weight of the infant (kg).
</p>
</dd>
<dt>Apgar</dt><dd>
<p>an ordered factor giving the 5-minute Apgar score for
the infant.  This is an indication of health of the newborn
infant.
</p>
</dd>
<dt>ApgarInd</dt><dd>
<p>a factor indicating whether the 5-minute Apgar score is <code>&lt; 5</code>
or <code>&gt;= 5</code>. 
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time when the sample is drawn or
drug administered (hr).
</p>
</dd>
<dt>dose</dt><dd>
<p>a numeric vector giving the dose of drug administered
(<code class="reqn">u</code>g/kg).
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the phenobarbital concentration in
the serum (<code class="reqn">u</code>g/L).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from a pharmacokinetics study of phenobarbital in neonatal
infants.  During the first few days of life the infants receive
multiple doses of phenobarbital for prevention of seizures.  At
irregular intervals blood samples are drawn and serum phenobarbital
concentrations are determined.  The data
were originally given in Grasela and Donn(1985) and are analyzed
in Boeckmann, Sheiner and Beal (1994), in
Davidian and Giltinan (1995), and in Littell et al. (1996).
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.23)
</p>
<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.  (section 6.6)
</p>
<p>Grasela and Donn (1985), Neonatal population pharmacokinetics of
phenobarbital derived from routine clinical data,
<em>Developmental Pharmacology and Therapeutics</em>, <b>8</b>,
374-383.
</p>
<p>Boeckmann, A. J., Sheiner, L. B., and Beal, S. L. (1994),
<em>NONMEM Users Guide: Part V</em>, University of California, San
Francisco.
</p>
<p>Littell, R. C., Milliken, G. A., Stroup, W. W. and Wolfinger,
R. D. (1996), <em>SAS System for Mixed Models</em>, SAS Institute,
Cary, NC.
</p>

<hr>
<h2 id='phenoModel'>Model function for the Phenobarb data</h2><span id='topic+phenoModel'></span>

<h3>Description</h3>

<p>A model function for a model used with the <code>Phenobarb</code> data.
This function uses compiled C code to improve execution speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoModel(Subject, time, dose, lCl, lV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoModel_+3A_subject">Subject</code></td>
<td>
<p>an integer vector of subject identifiers.  These should
be sorted in increasing order.</p>
</td></tr>
<tr><td><code id="phenoModel_+3A_time">time</code></td>
<td>
<p>numeric. A vector of the times at which the sample was drawn or
the drug administered (hr).
</p>
</td></tr>
<tr><td><code id="phenoModel_+3A_dose">dose</code></td>
<td>
<p>numeric. A vector of doses of drug administered
(<code class="reqn">u</code>g/kg).
</p>
</td></tr>
<tr><td><code id="phenoModel_+3A_lcl">lCl</code></td>
<td>
<p>numeric.  A vector of values of the natural log of the
clearance parameter according to <code>Subject</code> and <code>time</code>.</p>
</td></tr>
<tr><td><code id="phenoModel_+3A_lv">lV</code></td>
<td>
<p>numeric.  A vector of values of the natural log of the
effective volume of distribution according to <code>Subject</code> and
<code>time</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details section of <code><a href="#topic+Phenobarb">Phenobarb</a></code> for a description
of the model function that <code>phenoModel</code> evaluates.
</p>


<h3>Value</h3>

<p>a numeric vector of predicted phenobarbital concentrations.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000) <em>Mixed-effects Models in
S and S-PLUS</em>, Springer. (section 6.4)
</p>

<hr>
<h2 id='Pixel'>X-ray pixel intensities over time</h2><span id='topic+Pixel'></span>

<h3>Description</h3>

<p>The <code>Pixel</code> data frame has 102 rows and 4 columns of data on the
pixel intensities of CT scans of dogs over time
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Dog</dt><dd>
<p>a factor with levels <code>1</code> to <code>10</code> designating the dog
on which the scan was made
</p>
</dd>
<dt>Side</dt><dd>
<p>a factor with levels <code>L</code> and <code>R</code> designating the side
of the dog being scanned
</p>
</dd>
<dt>day</dt><dd>
<p>a numeric vector giving the day post injection of the contrast
on which the scan was made
</p>
</dd>
<dt>pixel</dt><dd>
<p>a numeric vector of pixel intensities
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000) <em>Mixed-effects Models in
S and S-PLUS</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(pixel ~ day + I(day^2), data = Pixel,
           random = list(Dog = ~ day, Side = ~ 1))
summary(fm1)
VarCorr(fm1)
</code></pre>

<hr>
<h2 id='plot.ACF'>Plot an ACF Object</h2><span id='topic+plot.ACF'></span>

<h3>Description</h3>

<p>an <code>xyplot</code> of the autocorrelations versus the lags, with
<code>type = "h"</code>, is produced. If <code>alpha &gt; 0</code>, curves
representing the critical limits for a two-sided test of level
<code>alpha</code> for the autocorrelations are added to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ACF'
plot(x, alpha, xlab, ylab, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ACF_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>ACF</code>,
consisting of a data frame with two columns named <code>lag</code> and
<code>ACF</code>, representing the autocorrelation values and the
corresponding lags. 
</p>
</td></tr>
<tr><td><code id="plot.ACF_+3A_alpha">alpha</code></td>
<td>
<p>an optional numeric value with the significance level for
testing if the autocorrelations are zero. Lines corresponding to the
lower and upper critical values for a test of level <code>alpha</code> are
added to the plot. Default is <code>0</code>, in which case no lines are
plotted.
</p>
</td></tr>
<tr><td><code id="plot.ACF_+3A_xlab">xlab</code>, <code id="plot.ACF_+3A_ylab">ylab</code></td>
<td>
<p>optional character strings with the x- and y-axis
labels. Default respectively to <code>"Lag"</code> and 
<code>"Autocorrelation"</code>. 
</p>
</td></tr>
<tr><td><code id="plot.ACF_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ACF_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>xyplot</code> function.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an <code>xyplot</code> Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ACF">ACF</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary)
plot(ACF(fm1, maxLag = 10), alpha = 0.01)
</code></pre>

<hr>
<h2 id='plot.augPred'>Plot an augPred Object</h2><span id='topic+plot.augPred'></span>

<h3>Description</h3>

<p>A Trellis <code>xyplot</code> of predictions versus the primary covariate is
generated, with a different panel for each value of the grouping
factor. Predicted values are joined by lines, with  
different line types (colors) being used for each level of
grouping. Original observations are represented by circles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'augPred'
plot(x, key, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.augPred_+3A_x">x</code></td>
<td>
<p>an object of class <code>"<a href="#topic+augPred">augPred</a>"</code>.</p>
</td></tr>
<tr><td><code id="plot.augPred_+3A_key">key</code></td>
<td>
<p>an optional logical value, or list. If <code>TRUE</code>, a legend
is included at the top of the plot indicating which symbols (colors)
correspond to which prediction levels. If <code>FALSE</code>, no legend
is included. If given as a list, <code>key</code> is passed down as an
argument to the <code>trellis</code> function generating the plots
(<code>xyplot</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.augPred_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.augPred_+3A_...">...</code></td>
<td>
<p>optional arguments passed down to the <code>trellis</code>
function generating the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Trellis plot of predictions versus the primary covariate, with panels
determined by the grouping factor.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+augPred">augPred</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(Orthodont)
plot(augPred(fm1, level = 0:1, length.out = 2))
</code></pre>

<hr>
<h2 id='plot.compareFits'>Plot a compareFits Object</h2><span id='topic+plot.compareFits'></span>

<h3>Description</h3>

<p>A Trellis <code>dotplot</code> of the values being compared, with different
rows per group, is generated, with a different panel for each
coefficient. Different symbols (colors) are used for each object being
compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compareFits'
plot(x, subset, key, mark, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.compareFits_+3A_x">x</code></td>
<td>
<p>an object of class <code>"<a href="#topic+compareFits">compareFits</a>"</code>.</p>
</td></tr>
<tr><td><code id="plot.compareFits_+3A_subset">subset</code></td>
<td>
<p>an optional logical or integer vector specifying which
rows of <code>x</code> should be used in the plots. If missing, all
rows are used.</p>
</td></tr>
<tr><td><code id="plot.compareFits_+3A_key">key</code></td>
<td>
<p>an optional logical value, or list. If <code>TRUE</code>, a legend
is included at the top of the plot indicating which symbols (colors)
correspond to which objects being compared. If <code>FALSE</code>, no legend
is included. If given as a list, <code>key</code> is passed down as an
argument to the <code>trellis</code> function generating the plots
(<code>dotplot</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.compareFits_+3A_mark">mark</code></td>
<td>
<p>an optional numeric vector, of length equal to the number of
coefficients being compared, indicating where vertical lines should
be drawn in the plots. If missing, no lines are drawn.</p>
</td></tr> 
<tr><td><code id="plot.compareFits_+3A_...">...</code></td>
<td>
<p>optional arguments passed down to the <code>trellis</code>
function generating the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Trellis <code>dotplot</code> of the values being compared, with rows
determined by the groups and panels by the coefficients.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+compareFits">compareFits</a></code>, <code><a href="#topic+pairs.compareFits">pairs.compareFits</a></code>,
<code><a href="lattice.html#topic+dotplot">dotplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(compareFits) # cF12 &lt;- compareFits(coef(lmList(Orthodont)), .. lme(*))
plot(cF12)
</code></pre>

<hr>
<h2 id='plot.gls'>Plot a gls Object</h2><span id='topic+plot.gls'></span>

<h3>Description</h3>

<p>Diagnostic plots for the linear model fit are obtained. The
<code>form</code> argument gives considerable flexibility in the type of
plot specification. A conditioning expression (on the right side of a
<code>|</code> operator) always implies that different panels are used for
each level of the conditioning factor, according to a Trellis
display. If <code>form</code> is a one-sided formula, histograms of the
variable on the right hand side of the formula, before a <code>|</code>
operator, are displayed (the Trellis function <code>histogram</code> is
used). If <code>form</code> is two-sided and both its left and
right hand side variables are numeric, scatter plots are displayed
(the Trellis function <code>xyplot</code> is used). Finally, if <code>form</code>
is two-sided and its left had side variable is a factor, box-plots of
the right hand side variable by the levels of the left hand side
variable are displayed (the Trellis function  <code>bwplot</code> is used). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
plot(x, form, abline, id, idLabels, idResType, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gls_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>x</code> can be referenced. In addition, <code>x</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. Default is <code>resid(., type = "p") ~ fitted(.) </code>,
corresponding to a plot of the standardized residuals versus fitted
values, both evaluated at the innermost level of nesting.</p>
</td></tr> 
<tr><td><code id="plot.gls_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric vector of length
two. If given as a single value, a horizontal line will be added to the
plot at that coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the plot. If
missing, no lines are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for a two-sided outlier
test for the standardized residuals. Observations with
absolute standardized residuals greater than the <code class="reqn">1 - value/2</code>
quantile of the standard normal distribution are identified in the
plot using <code>idLabels</code>. If given as a one-sided formula, its
right hand side must evaluate to a  logical, integer, or character
vector which is used to identify observations in the plot. If
missing, no observations are identified.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character mode and used to label the
observations identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character mode and used to label the identified
observations. Default is the innermost grouping factor.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_idrestype">idResType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used in identifying outliers, when <code>id</code> is a
numeric value. If <code>"pearson"</code>, the standardized residuals (raw 
residuals divided by the corresponding standard errors) are used;
else, if <code>"normalized"</code>, the normalized residuals (standardized
residuals pre-multiplied by the inverse square-root factor of the
estimated error correlation matrix) are used. Partial matching of
arguments is used, so only the first character needs to be
provided. Defaults to <code>"pearson"</code>.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default depends on the type of Trellis plot used:
if <code>xyplot</code> defaults to <code>TRUE</code>, else defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.gls_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+histogram">histogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
# standardized residuals versus fitted values by Mare
plot(fm1, resid(., type = "p") ~ fitted(.) | Mare, abline = 0)
# box-plots of residuals by Mare
plot(fm1, Mare ~ resid(.))
# observed versus fitted values by Mare
plot(fm1, follicles ~ fitted(.) | Mare, abline = c(0,1))
</code></pre>

<hr>
<h2 id='plot.intervals.lmList'>Plot lmList Confidence Intervals</h2><span id='topic+plot.intervals.lmList'></span>

<h3>Description</h3>

<p>A Trellis dot-plot of the confidence intervals on the linear model
coefficients is generated, with a different panel for each
coefficient. Rows in the dot-plot correspond to the names of the
<code>lm</code> components of the <code>lmList</code> object used to produce
<code>x</code>. The lower and upper confidence limits are connected by
a line segment and the estimated coefficients are marked with a
<code>"+"</code>. 
</p>
<p>This is based on function <code><a href="lattice.html#topic+xyplot">dotplot</a>()</code> from
package <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'intervals.lmList'
plot(x, xlab = "", ylab = attr(x, "groupsName"),
     strip = function(...) strip.default(..., style = 1),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.intervals.lmList_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+intervals.lmList">intervals.lmList</a>"</code>,
representing confidence intervals and estimates for the coefficients
in the <code>lm</code> components of the <code>lmList</code> object used to
produce <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.intervals.lmList_+3A_xlab">xlab</code>, <code id="plot.intervals.lmList_+3A_ylab">ylab</code></td>
<td>
<p>axis labels, each with a sensible default.</p>
</td></tr>
<tr><td><code id="plot.intervals.lmList_+3A_strip">strip</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> or <code>FALSE</code>, see
<code><a href="lattice.html#topic+xyplot">dotplot</a>()</code> from package <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>.</p>
</td></tr>
<tr><td><code id="plot.intervals.lmList_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>dotplot</code> function
(see above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Trellis plot with the confidence intervals on the coefficients of
the individual <code>lm</code> components of the <code>lmList</code> that
generated <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+intervals.lmList">intervals.lmList</a></code>,
<code><a href="#topic+lmList">lmList</a></code>,
<code><a href="lattice.html#topic+dotplot">dotplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
plot(intervals(fm1))
</code></pre>

<hr>
<h2 id='plot.lme'>Plot an lme or nls object</h2><span id='topic+plot.lme'></span><span id='topic+plot.nls'></span>

<h3>Description</h3>

<p>Diagnostic plots for the linear mixed-effects fit are obtained. The
<code>form</code> argument gives considerable flexibility in the type of
plot specification. A conditioning expression (on the right side of a
<code>|</code> operator) always implies that different panels are used for
each level of the conditioning factor, according to a Trellis
display. If <code>form</code> is a one-sided formula, histograms of the
variable on the right hand side of the formula, before a <code>|</code>
operator, are displayed (the Trellis function <code>histogram</code> is
used). If <code>form</code> is two-sided and both its left and
right hand side variables are numeric, scatter plots are displayed
(the Trellis function <code>xyplot</code> is used). Finally, if <code>form</code>
is two-sided and its left had side variable is a factor, box-plots of
the right hand side variable by the levels of the left hand side
variable are displayed (the Trellis function  <code>bwplot</code> is used). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
plot(x, form, abline, id, idLabels, idResType, grid, ...)
## S3 method for class 'nls'
plot(x, form, abline, id, idLabels, idResType, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lme_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model, or from <code>nls</code>, representing
an fitted nonlinear least squares model.</p>
</td></tr>
<tr><td><code id="plot.lme_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>x</code> can be referenced. In addition, <code>x</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. Default is <code>resid(., type = "p") ~ fitted(.) </code>,
corresponding to a plot of the standardized residuals versus fitted
values, both evaluated at the innermost level of nesting.</p>
</td></tr> 
<tr><td><code id="plot.lme_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric vector of length
two. If given as a single value, a horizontal line will be added to the
plot at that coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the plot. If
missing, no lines are added to the plot.</p>
</td></tr>
<tr><td><code id="plot.lme_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for a two-sided outlier
test for the standardized, or normalized residuals. Observations with
absolute standardized (normalized) residuals greater than the <code class="reqn">1
     - value/2</code> quantile of the standard normal distribution are
identified in the plot using <code>idLabels</code>. If given as a one-sided
formula, its right hand side must evaluate to a  logical, integer, or
character vector which is used to identify observations in the
plot. If missing, no observations are identified.</p>
</td></tr>
<tr><td><code id="plot.lme_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
observations identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
observations. Default is the innermost grouping factor.</p>
</td></tr>
<tr><td><code id="plot.lme_+3A_idrestype">idResType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used in identifying outliers, when <code>id</code> is a
numeric value. If <code>"pearson"</code>, the standardized residuals (raw 
residuals divided by the corresponding standard errors) are used;
else, if <code>"normalized"</code>, the normalized residuals (standardized
residuals pre-multiplied by the inverse square-root factor of the
estimated error correlation matrix) are used. Partial matching of
arguments is used, so only the first character needs to be
provided. Defaults to <code>"pearson"</code>.</p>
</td></tr>  
<tr><td><code id="plot.lme_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default depends on the type of Trellis plot used:
if <code>xyplot</code> defaults to <code>TRUE</code>, else defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lme_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
<code><a href="lattice.html#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+histogram">histogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
# standardized residuals versus fitted values by gender
plot(fm1, resid(., type = "p") ~ fitted(.) | Sex, abline = 0)
# box-plots of residuals by Subject
plot(fm1, Subject ~ resid(.))
# observed versus fitted values by Subject
plot(fm1, distance ~ fitted(.) | Subject, abline = c(0,1))
</code></pre>

<hr>
<h2 id='plot.lmList'>Plot an lmList Object</h2><span id='topic+plot.lmList'></span>

<h3>Description</h3>

<p>Diagnostic plots for the linear model fits corresponding to the
<code>x</code>  components are obtained. The <code>form</code> argument gives
considerable flexibility in the type of  plot specification. A
conditioning expression (on the right side of a  <code>|</code> operator)
always implies that different panels are used for  each level of the
conditioning factor, according to a Trellis  display. If <code>form</code>
is a one-sided formula, histograms of the  variable on the right hand
side of the formula, before a <code>|</code>  operator, are displayed (the
Trellis function <code>histogram</code> is  used). If <code>form</code> is
two-sided and both its left and  right hand side variables are
numeric, scatter plots are displayed  (the Trellis function
<code>xyplot</code> is used). Finally, if <code>form</code>  is two-sided and its
left had side variable is a factor, box-plots of  the right hand side
variable by the levels of the left hand side  variable are displayed
(the Trellis function  <code>bwplot</code> is used).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
plot(x, form, abline, id, idLabels, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lmList_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.</p>
</td></tr>
<tr><td><code id="plot.lmList_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>x</code> can be referenced. In addition, <code>x</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. Default is <code>resid(., type = "pool") ~ fitted(.) </code>,
corresponding to a plot of the standardized residuals (using a pooled
estimate for the residual standard error) versus fitted values.
</p>
</td></tr> 
<tr><td><code id="plot.lmList_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric vector of length
two. If given as a single value, a horizontal line will be added to the
plot at that coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the plot. If
missing, no lines are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.lmList_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for a two-sided outlier
test for the standardized residuals. Observations with
absolute standardized residuals greater than the <code class="reqn">1 - value/2</code>
quantile of the standard normal distribution are identified in the
plot using <code>idLabels</code>. If given as a one-sided formula, its
right hand side must evaluate to a  logical, integer, or character
vector which is used to identify observations in the plot. If
missing, no observations are identified.
</p>
</td></tr>
<tr><td><code id="plot.lmList_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
observations identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
observations. Default is <code>getGroups(x)</code>. 
</p>
</td></tr>
<tr><td><code id="plot.lmList_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default depends on the type of Trellis plot used:
if <code>xyplot</code> defaults to <code>TRUE</code>, else defaults to
<code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.lmList_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>,<code><a href="stats.html#topic+predict.lm">predict.lm</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="lattice.html#topic+bwplot">bwplot</a></code>, <code><a href="lattice.html#topic+histogram">histogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
# standardized residuals versus fitted values by gender
plot(fm1, resid(., type = "pool") ~ fitted(.) | Sex, abline = 0, id = 0.05)
# box-plots of residuals by Subject
plot(fm1, Subject ~ resid(.))
# observed versus fitted values by Subject
plot(fm1, distance ~ fitted(.) | Subject, abline = c(0,1))
</code></pre>

<hr>
<h2 id='plot.nffGroupedData'>Plot an nffGroupedData Object</h2><span id='topic+plot.nffGroupedData'></span>

<h3>Description</h3>

<p>A Trellis dot-plot of the response by group is generated. If outer
variables are specified, the combination of their levels are used to
determine the panels of the Trellis display. The Trellis function
<code>dotplot</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nffGroupedData'
plot(x, outer, inner, innerGroups, xlab, ylab, strip, panel, key,
     grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nffGroupedData_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>nffGroupedData</code>,
representing a <code>groupedData</code> object with a factor primary
covariate and a single grouping level.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_outer">outer</code></td>
<td>
<p>an optional logical value or one-sided formula,
indicating covariates that are outer to the grouping factor, which
are used to determine the panels of the Trellis plot. If
equal to <code>TRUE</code>, <code>attr(object, "outer")</code> is used to indicate the
outer covariates. An outer covariate is invariant within the sets
of rows defined by the grouping factor.  Ordering of the groups is
done in such a way as to preserve adjacency of groups with the same
value of the outer variables. Defaults to <code>NULL</code>, meaning that
no outer covariates are to be used.
</p>
</td></tr>  
<tr><td><code id="plot.nffGroupedData_+3A_inner">inner</code></td>
<td>
<p>an optional logical value or one-sided formula, indicating
a covariate that is inner to the grouping factor, which is used to
associate points within each panel of the Trellis plot. If
equal to <code>TRUE</code>, <code>attr(object, "inner")</code> is used to indicate the
inner covariate. An inner covariate can change within the sets of
rows defined by the grouping  factor. Defaults to <code>NULL</code>,
meaning that no inner covariate  is present. 
</p>
</td></tr> 
<tr><td><code id="plot.nffGroupedData_+3A_innergroups">innerGroups</code></td>
<td>
<p>an optional one-sided formula specifying a factor
to be used for grouping the levels of the <code>inner</code>
covariate. Different colors, or symbols, are used for each level
of the <code>innerGroups</code> factor. Default is <code>NULL</code>, meaning
that no <code>innerGroups</code> covariate is present.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_xlab">xlab</code></td>
<td>
<p>an optional character string with the label for the
horizontal axis. Default is the <code>y</code> elements of <code>attr(object,
     "labels")</code> and <code>attr(object, "units")</code> pasted together.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_ylab">ylab</code></td>
<td>
<p>an optional character string with the label for the
vertical axis. Default is the grouping factor name.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_strip">strip</code></td>
<td>
<p>an optional function passed as the <code>strip</code> argument to
the <code>dotplot</code> function. Default is <code>strip.default(..., style
     = 1)</code> (see <code>trellis.args</code>).
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_panel">panel</code></td>
<td>
<p>an optional function used to generate the individual
panels in the Trellis display, passed as the <code>panel</code> argument
to the <code>dotplot</code> function.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_key">key</code></td>
<td>
<p>an optional logical function or function. If <code>TRUE</code>
and either <code>inner</code> or <code>innerGroups</code> are non-<code>NULL</code>, a
legend for the different <code>inner</code> (<code>innerGroups</code>) levels is 
included at the top of the plot. If given as a function, it is passed
as the <code>key</code> argument to the <code>dotplot</code> function. Default is
<code>TRUE</code> is either <code>inner</code> or <code>innerGroups</code> are
non-<code>NULL</code> and <code>FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code id="plot.nffGroupedData_+3A_grid">grid</code></td>
<td>
<p>this argument is included for consistency with the
<code>plot.nfnGroupedData</code> method calling sequence. It is
ignored in this method function.</p>
</td></tr> 
<tr><td><code id="plot.nffGroupedData_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>dotplot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Trellis dot-plot of the response by group.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1997), &quot;Software Design for Longitudinal
Data&quot;, in &quot;Modelling Longitudinal and Spatially Correlated Data:
Methods, Applications and Future Directions&quot;, T.G. Gregoire (ed.),
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="lattice.html#topic+dotplot">dotplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Machines)
plot(Machines, inner = TRUE)
</code></pre>

<hr>
<h2 id='plot.nfnGroupedData'>Plot an nfnGroupedData Object</h2><span id='topic+plot.nfnGroupedData'></span>

<h3>Description</h3>

<p>A Trellis plot of the response versus the primary covariate is
generated. If outer variables are specified, the combination of their
levels are used to determine the panels of the Trellis
display. Otherwise, the levels of the grouping variable determine the
panels. A scatter plot of the response versus the primary covariate is
displayed in each panel, with observations corresponding to same
inner group joined by line segments. The Trellis function
<code>xyplot</code> is used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nfnGroupedData'
plot(x, outer, inner, innerGroups, xlab, ylab, strip, aspect, panel,
     key, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nfnGroupedData_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>nfnGroupedData</code>,
representing a <code>groupedData</code> object with a numeric primary
covariate and a single grouping level.
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_outer">outer</code></td>
<td>
<p>an optional logical value or one-sided formula,
indicating covariates that are outer to the grouping factor, which
are used to determine the panels of the Trellis plot. If
equal to <code>TRUE</code>, <code>attr(object, "outer")</code> is used to
indicate the outer covariates. An outer covariate is invariant within
the sets of rows defined by the grouping factor.  Ordering of the
groups is done in such a way as to preserve adjacency of groups with
the same value of the outer variables. Defaults to <code>NULL</code>,
meaning that no outer covariates are to be used.
</p>
</td></tr>  
<tr><td><code id="plot.nfnGroupedData_+3A_inner">inner</code></td>
<td>
<p>an optional logical value or one-sided formula, indicating
a covariate that is inner to the grouping factor, which is used to
associate points within each panel of the Trellis plot. If
equal to <code>TRUE</code>, <code>attr(object, "inner")</code> is used to
indicate the inner covariate. An inner covariate can change within
the sets of rows defined by the grouping  factor. Defaults to
<code>NULL</code>, meaning that no inner covariate  is present. 
</p>
</td></tr> 
<tr><td><code id="plot.nfnGroupedData_+3A_innergroups">innerGroups</code></td>
<td>
<p>an optional one-sided formula specifying a factor
to be used for grouping the levels of the <code>inner</code>
covariate. Different colors, or line types, are used for each level
of the <code>innerGroups</code> factor. Default is <code>NULL</code>, meaning
that no <code>innerGroups</code> covariate is present.
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_xlab">xlab</code>, <code id="plot.nfnGroupedData_+3A_ylab">ylab</code></td>
<td>
<p>optional character strings with the labels for the
plot. Default is the corresponding elements of <code>attr(object,
     "labels")</code> and <code>attr(object, "units")</code> pasted together.
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_strip">strip</code></td>
<td>
<p>an optional function passed as the <code>strip</code> argument to
the <code>xyplot</code> function. Default is <code>strip.default(..., style
     = 1)</code> (see <code>trellis.args</code>).
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_aspect">aspect</code></td>
<td>
<p>an optional character string indicating the aspect ratio
for the plot passed as the <code>aspect</code> argument to the
<code>xyplot</code> function. Default is <code>"xy"</code> (see
<code>trellis.args</code>). 
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_panel">panel</code></td>
<td>
<p>an optional function used to generate the individual
panels in the Trellis display, passed as the <code>panel</code> argument
to the <code>xyplot</code> function.</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_key">key</code></td>
<td>
<p>an optional logical function or function. If <code>TRUE</code>
and <code>innerGroups</code> is non-<code>NULL</code>, a legend for the
different <code>innerGroups</code> levels is included at the top of the
plot. If given as a function, it is passed as the <code>key</code> argument
to the <code>xyplot</code> function.  Default is <code>TRUE</code> if
<code>innerGroups</code> is non-<code>NULL</code> and <code>FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.nfnGroupedData_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>xyplot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Trellis plot of the response versus the primary covariate.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1997), &quot;Software Design for Longitudinal
Data&quot;, in &quot;Modelling Longitudinal and Spatially Correlated Data:
Methods, Applications and Future Directions&quot;, T.G. Gregoire (ed.),
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># different panels per Subject
plot(Orthodont)
# different panels per gender
plot(Orthodont, outer = TRUE)
</code></pre>

<hr>
<h2 id='plot.nmGroupedData'>Plot an nmGroupedData Object</h2><span id='topic+plot.nmGroupedData'></span>

<h3>Description</h3>

<p>The <code>groupedData</code> object is summarized by the values of the
<code>displayLevel</code> grouping factor (or the combination of its values
and the values of the covariate indicated in <code>preserve</code>, if any is
present). The collapsed data is used to produce a new
<code>groupedData</code> object, with grouping factor given by the
<code>displayLevel</code> factor, which is plotted using the
appropriate <code>plot</code> method for <code>groupedData</code> objects with
single level of grouping. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nmGroupedData'
plot(x, collapseLevel, displayLevel, outer, inner,
    preserve, FUN, subset, key, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nmGroupedData_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>nmGroupedData</code>,
representing a <code>groupedData</code> object with multiple grouping
factors.
</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_collapselevel">collapseLevel</code></td>
<td>
<p>an optional positive integer or character string
indicating the grouping level to use when collapsing the data. Level
values increase from outermost to innermost grouping. Default is the
highest or innermost level of grouping.
</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_displaylevel">displayLevel</code></td>
<td>
<p>an optional positive integer or character string
indicating the grouping level to use for determining the panels in
the Trellis display, when <code>outer</code> is missing. Default is
<code>collapseLevel</code>.
</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_outer">outer</code></td>
<td>
<p>an optional logical value or one-sided formula,
indicating covariates that are outer to the <code>displayLevel</code>
grouping factor, which are used to determine the panels of the
Trellis plot. If equal to <code>TRUE</code>, the <code>displayLevel</code>
element <code>attr(object, "outer")</code> is used to indicate the 
outer covariates. An outer covariate is invariant within the sets
of rows defined by the grouping factor.  Ordering of the groups is
done in such a way as to preserve adjacency of groups with the same
value of the outer variables. Defaults to <code>NULL</code>, meaning that
no outer covariates are to be used.
</p>
</td></tr>  
<tr><td><code id="plot.nmGroupedData_+3A_inner">inner</code></td>
<td>
<p>an optional logical value or one-sided formula, indicating
a covariate that is inner to the <code>displayLevel</code> grouping factor,
which is used to associate points within each panel of the Trellis
plot. If equal to <code>TRUE</code>, <code>attr(object, "outer")</code> is used
to indicate the inner covariate. An inner covariate can change within
the sets of rows defined by the grouping  factor. Defaults to
<code>NULL</code>, meaning that no inner covariate  is present.  
</p>
</td></tr> 
<tr><td><code id="plot.nmGroupedData_+3A_preserve">preserve</code></td>
<td>
<p>an optional one-sided formula indicating a covariate
whose levels should be preserved when collapsing the data according
to the <code>collapseLevel</code> grouping factor. The collapsing factor is
obtained by pasting together the levels of the <code>collapseLevel</code>
grouping factor and the values of the covariate to be
preserved. Default is <code>NULL</code>, meaning that no covariates need to
be preserved.
</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be used for collapsing the data.  The function or functions are
applied only to variables in <code>object</code> that vary within the
groups defined by <code>collapseLevel</code>.  Invariant variables are 
always summarized by group using the unique value that they assume
within that group.  If <code>FUN</code> is a single
function it will be applied to each non-invariant variable by group
to produce the summary for that variable.  If <code>FUN</code> is a list of
functions, the names in the list should designate classes of
variables in the data such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
non-invariant variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_subset">subset</code></td>
<td>
<p>an optional named list. Names can be either positive
integers representing grouping levels, or names of grouping
factors. Each element in the list is a vector indicating the levels
of the corresponding grouping factor to be used for plotting the
data. Default is <code>NULL</code>, meaning that all levels are
used.</p>
</td></tr> 
<tr><td><code id="plot.nmGroupedData_+3A_key">key</code></td>
<td>
<p>an optional logical value, or list. If <code>TRUE</code>, a legend
is included at the top of the plot indicating which symbols (colors)
correspond to which prediction levels. If <code>FALSE</code>, no legend
is included. If given as a list, <code>key</code> is passed down as an
argument to the <code>trellis</code> function generating the plots
(<code>xyplot</code>). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.nmGroupedData_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Trellis display of the data collapsed over the values of the
<code>collapseLevel</code> grouping factor and grouped according to the
<code>displayLevel</code> grouping factor. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1997), &quot;Software Design for Longitudinal
Data&quot;, in &quot;Modelling Longitudinal and Spatially Correlated Data:
Methods, Applications and Future Directions&quot;, T.G. Gregoire (ed.),
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, <code><a href="#topic+collapse.groupedData">collapse.groupedData</a></code>,
<code><a href="#topic+plot.nfnGroupedData">plot.nfnGroupedData</a></code>, <code><a href="#topic+plot.nffGroupedData">plot.nffGroupedData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no collapsing, panels by Dog
plot(Pixel, display = "Dog", inner = ~Side)
# collapsing by Dog, preserving day
plot(Pixel, collapse = "Dog", preserve = ~day)
</code></pre>

<hr>
<h2 id='plot.ranef.lme'>Plot a ranef.lme Object</h2><span id='topic+plot.ranef.lme'></span>

<h3>Description</h3>

<p>Plots (class <code>"Trellis"</code> from package <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>) of the
random effects from linear mixed effects model, i.e., the result of
<code><a href="#topic+ranef">ranef</a>(<a href="#topic+lme">lme</a>(*))</code> (of class <code>"<a href="#topic+ranef.lme">ranef.lme</a>"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranef.lme'
plot(x, form = NULL, omitFixed = TRUE, level = Q,
     grid = TRUE, control, xlab, ylab, strip,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ranef.lme_+3A_x">x</code></td>
<td>
<p>an object inheriting from class
<code>"<a href="#topic+ranef.lme">ranef.lme</a>"</code>, representing the estimated coefficients or
estimated random effects for the <code>lme</code> object from which it was
produced.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired type of plot.
</p>

<ul>
<li><p> If given as a one-sided formula, a <code><a href="lattice.html#topic+xyplot">dotplot</a>()</code>
of the estimated random effects (coefficients) grouped according to
all combinations of the levels of the factors named in <code>form</code>
is returned.
</p>
</li>
<li><p> If given as a two-sided formula (or by default, <code>NULL</code>),
an <code><a href="lattice.html#topic+xyplot">xyplot</a>()</code> Trellis display of the random
effect (coefficient) versus the named covariates is returned.  In
<code>NULL</code> case the row names of the random effects (coefficients)
are used (as covariates).
</p>
</li></ul>

<p>See also &lsquo;Details:&rsquo;.
</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_omitfixed">omitFixed</code></td>
<td>
<p>an optional logical value indicating whether
columns with values that are constant across groups should be
omitted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_level">level</code></td>
<td>
<p>an optional integer value giving the level of grouping
to be used for <code>x</code>. Only used when <code>x</code> is a list
with different components for each grouping level. Defaults to the
highest or innermost level of grouping.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot.  Only applies to plots associated with two-sided
formulas in <code>form</code>.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_control">control</code></td>
<td>
<p>an optional list with control values for the
plot, when <code>form</code> is given as a two-sided formula. The control
values are referenced by name in the <code>control</code> list and  only
the ones to be modified from the default need to be
specified. Available values include: <code>drawLine</code>, a logical
value indicating whether a <code>loess</code> smoother should be added to
the scatter plots and a line connecting the medians should be added
to the boxplots (default is <code>TRUE</code>); <code>span.loess</code>, used
as the <code>span</code> argument in the call to <code>panel.loess</code>
(default is <code>2/3</code>); <code>degree.loess</code>, used as the
<code>degree</code> argument in the call to <code>panel.loess</code> (default
is <code>1</code>); <code>cex.axis</code>, the character expansion factor for
the x-axis (default is <code>0.8</code>); <code>srt.axis</code>, the rotation
factor for the x-axis (default is <code>0</code>); and <code>mgp.axis</code>, the
margin parameters for the x-axis (default is <code>c(2, 0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_xlab">xlab</code>, <code id="plot.ranef.lme_+3A_ylab">ylab</code></td>
<td>
<p>axis labels, each with a sensible default.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_strip">strip</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> or <code>FALSE</code>, see
<code><a href="lattice.html#topic+xyplot">dotplot</a>()</code> from package <a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>.</p>
</td></tr>
<tr><td><code id="plot.ranef.lme_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis <code>dotplot</code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>form</code> is missing, or is given as a one-sided formula, a
Trellis dot-plot (via <code><a href="lattice.html#topic+xyplot">dotplot</a>()</code> from pkg
<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>) of the random effects is generated, with a different
panel for each random effect (coefficient).  Rows in the dot-plot are
determined by the <code>form</code> argument (if not missing) or by the row
names of the random effects (coefficients).  Single factors (<code>~g</code>)
or crossed factors (<code>~g1*g2</code>) are allowed.  For a single factor,
its levels determine the dot-plot rows (with possibly multiple dots
per row); otherwise, if <code>form</code>
specifies a crossing of factors, the dot-plot rows are determined by
all combinations of the levels of the individual factors in the
formula.
</p>
<p>If <code>form</code> is a two-sided formula, the left hand side must
be a single random effect (coefficient) and the right hand side is
formed by covariates in <code>x</code> separated by <code>+</code>.
An <code><a href="lattice.html#topic+xyplot">xyplot</a>()</code> Trellis display is generated,
with a different panel for each variable listed in the right hand side
of <code>form</code>.  Scatter plots are generated for numeric variables and
boxplots are generated for categorical (<code>factor</code> or
<code>ordered</code>) variables.
</p>


<h3>Value</h3>

<p>a Trellis plot of the estimated random-effects (coefficients) versus
covariates, or groups.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.lme">ranef.lme</a></code>, <code><a href="#topic+lme">lme</a></code>,
<code><a href="lattice.html#topic+dotplot">dotplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
plot(ranef(fm1))
fm1RE &lt;- ranef(fm1, aug = TRUE)
plot(fm1RE, form = ~ Sex)
plot(fm1RE, form = age ~ Sex) # "connected" boxplots
</code></pre>

<hr>
<h2 id='plot.ranef.lmList'>Plot a ranef.lmList Object</h2><span id='topic+plot.ranef.lmList'></span>

<h3>Description</h3>

<p>If <code>form</code> is missing, or is given as a one-sided formula, a
Trellis dot-plot of the random effects is generated, with a different
panel for each random effect (coefficient). Rows in the dot-plot are
determined by the <code>form</code> argument (if not missing) or by the row
names of the random effects (coefficients). If a single factor is
specified in <code>form</code>, its levels determine the dot-plot rows
(with possibly multiple dots per row); otherwise, if <code>form</code>
specifies a crossing of factors, the dot-plot rows are determined by
all combinations of the levels of the individual factors in the
formula. The Trellis function <code>dotplot</code> is used in this method
function.
</p>
<p>If <code>form</code> is a two-sided formula, a Trellis display is generated,
with a different panel for each variable listed in the right hand side
of <code>form</code>. Scatter plots are generated for numeric variables and
boxplots are generated for categorical (<code>factor</code> or
<code>ordered</code>) variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranef.lmList'
plot(x, form, grid, control, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ranef.lmList_+3A_x">x</code></td>
<td>
<p>an object inheriting from class
<code>"<a href="#topic+ranef.lmList">ranef.lmList</a>"</code>, representing the estimated coefficients or
estimated random effects for the <code>lmList</code> object from which it was
produced.
</p>
</td></tr>
<tr><td><code id="plot.ranef.lmList_+3A_form">form</code></td>
<td>
<p>an optional formula specifying the desired type of plot. If
given as a one-sided formula, a <code>dotplot</code> of the estimated
random effects (coefficients) grouped according to all combinations of
the levels of the factors named in <code>form</code> is returned. Single
factors (<code>~g</code>) or crossed factors (<code>~g1*g2</code>) are
allowed. If given as a two-sided formula, the left hand side must
be a single random effects (coefficient) and the right hand side
is formed by covariates in <code>x</code> separated by <code>+</code>. A
Trellis display of the random effect (coefficient) versus the named
covariates is returned in this case. Default is <code>NULL</code>, in
which case  the row names of the random effects (coefficients) are
used.</p>
</td></tr>
<tr><td><code id="plot.ranef.lmList_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Only applies to plots associated with two-sided
formulas in <code>form</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ranef.lmList_+3A_control">control</code></td>
<td>
<p>an optional list with control values for the
plot, when <code>form</code> is given as a two-sided formula. The control
values are referenced by name in the <code>control</code> list and  only
the ones to be modified from the default need to be
specified. Available values include: <code>drawLine</code>, a logical
value indicating whether a <code>loess</code> smoother should be added to
the scatter plots and a line connecting the medians should be added
to the boxplots (default is <code>TRUE</code>); <code>span.loess</code>, used
as the <code>span</code> argument in the call to <code>panel.loess</code>
(default is <code>2/3</code>); <code>degree.loess</code>, used as the
<code>degree</code> argument in the call to <code>panel.loess</code> (default
is <code>1</code>); <code>cex.axis</code>, the character expansion factor for
the x-axis (default is <code>0.8</code>); <code>srt.axis</code>, the rotation
factor for the x-axis (default is <code>0</code>); and <code>mgp.axis</code>, the
margin parameters for the x-axis (default is <code>c(2, 0.5, 0)</code>).</p>
</td></tr>
<tr><td><code id="plot.ranef.lmList_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis <code>dotplot</code>
function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Trellis plot of the estimated random-effects (coefficients) versus
covariates, or groups.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="lattice.html#topic+dotplot">dotplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
plot(ranef(fm1))
fm1RE &lt;- ranef(fm1, aug = TRUE)
plot(fm1RE, form = ~ Sex)
plot(fm1RE, form = age ~ Sex)
</code></pre>

<hr>
<h2 id='plot.Variogram'>Plot a Variogram Object</h2><span id='topic+plot.Variogram'></span>

<h3>Description</h3>

<p>an <code>xyplot</code> of the semi-variogram versus the distances is
produced. If <code>smooth = TRUE</code>, a <code>loess</code> smoother is added to
the plot. If <code>showModel = TRUE</code> and <code>x</code> includes an
<code>"modelVariog"</code> attribute, the corresponding semi-variogram
is added to the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Variogram'
plot(x, smooth, showModel, sigma, span, xlab,
     ylab, type, ylim, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Variogram_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+Variogram">Variogram</a>"</code>,
consisting of a data frame with two columns named <code>variog</code> and
<code>dist</code>, representing the semi-variogram values and the corresponding
distances.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_smooth">smooth</code></td>
<td>
<p>an optional logical value controlling whether a
<code>loess</code> smoother should be added to the plot. Defaults to
<code>TRUE</code>, when <code>showModel</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_showmodel">showModel</code></td>
<td>
<p>an optional logical value controlling whether the
semi-variogram corresponding to an <code>"modelVariog"</code> attribute of
<code>x</code>, if any is present, should be added to the
plot. Defaults to <code>TRUE</code>, when the <code>"modelVariog"</code>
attribute is present.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as the height of a
horizontal line displayed in the plot. Can be used to represent the
process standard deviation. Default is <code>NULL</code>, implying that no
horizontal line is drawn. 
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_span">span</code></td>
<td>
<p>an optional numeric value with the smoothing parameter for
the <code>loess</code> fit. Default is 0.6.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_xlab">xlab</code>, <code id="plot.Variogram_+3A_ylab">ylab</code></td>
<td>
<p>optional character strings with the x- and y-axis
labels. Default respectively to <code>"Distance"</code> and
<code>"SemiVariogram"</code>. 
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_type">type</code></td>
<td>
<p>an optional character indicating the type of plot. Defaults
to <code>"p"</code>.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_ylim">ylim</code></td>
<td>
<p>an optional numeric vector with the limits for the
y-axis. Defaults to <code>c(0, max(x$variog))</code>.
</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Variogram_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis <code>xyplot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>xyplot</code> Trellis plot.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Variogram">Variogram</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>, <code><a href="stats.html#topic+loess">loess</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary)
plot(Variogram(fm1, form = ~ Time | Mare, maxDist = 0.7))
</code></pre>

<hr>
<h2 id='pooledSD'>Extract Pooled Standard Deviation</h2><span id='topic+pooledSD'></span>

<h3>Description</h3>

<p>The pooled estimated standard deviation is obtained by adding together
the residual sum of squares for each non-null element of
<code>object</code>, dividing by the sum of the corresponding residual
degrees-of-freedom, and taking the square-root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledSD(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledSD_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>lmList</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the pooled standard deviation for the non-null elements of
<code>object</code>, with an attribute <code>df</code> with the number of
degrees-of-freedom used in the estimation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="stats.html#topic+lm">lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(Orthodont)
pooledSD(fm1)
</code></pre>

<hr>
<h2 id='predict.gls'>Predictions from a gls Object</h2><span id='topic+predict.gls'></span>

<h3>Description</h3>

<p>The predictions for the linear model represented by <code>object</code> are
obtained at the covariate values defined in <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
predict(object, newdata, na.action, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="predict.gls_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions. All variables used in the linear model must be present
in the data frame. If missing, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.gls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when
<code>newdata</code> contains <code>NA</code>s.  The default action
(<code>na.fail</code>) causes the function to print an error message and
terminate if there are any incomplete observations.</p>
</td></tr>
<tr><td><code id="predict.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the predicted values.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
newOvary &lt;- data.frame(Time = c(-0.75, -0.5, 0, 0.5, 0.75))
predict(fm1, newOvary)
</code></pre>

<hr>
<h2 id='predict.gnls'>Predictions from a gnls Object</h2><span id='topic+predict.gnls'></span>

<h3>Description</h3>

<p>The predictions for the nonlinear model represented by <code>object</code> are
obtained at the covariate values defined in <code>newdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnls'
predict(object, newdata, na.action, naPattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gnls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gnls">gnls</a>"</code>, representing
a generalized nonlinear least squares fitted model.</p>
</td></tr>
<tr><td><code id="predict.gnls_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions. All variables used in the nonlinear model must be present
in the data frame. If missing, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.gnls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when
<code>newdata</code> contains <code>NA</code>s.  The default action
(<code>na.fail</code>) causes the function to print an error message and
terminate if there are any incomplete observations.</p>
</td></tr>
<tr><td><code id="predict.gnls_+3A_napattern">naPattern</code></td>
<td>
<p>an expression or formula object, specifying which returned
values are to be regarded as missing.</p>
</td></tr>
<tr><td><code id="predict.gnls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the predicted values.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean,
            weights = varPower())
newSoybean &lt;- data.frame(Time = c(10,30,50,80,100))
predict(fm1, newSoybean)
</code></pre>

<hr>
<h2 id='predict.lme'>Predictions from an lme Object</h2><span id='topic+predict.lme'></span>

<h3>Description</h3>

<p>The predictions at level <code class="reqn">i</code> are obtained by adding together the
population predictions (based only on the fixed effects estimates)
and the estimated contributions of the random effects to the
predictions at grouping levels less or equal to <code class="reqn">i</code>.  The resulting
values estimate the best linear unbiased predictions (BLUPs) at level
<code class="reqn">i</code>.  If group values not included in the original grouping factors
are present in <code>newdata</code>, the corresponding predictions will be
set to <code>NA</code> for levels greater or equal to the level at which the
unknown groups occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
predict(object, newdata, level = Q, asList = FALSE,
        na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="predict.lme_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions.  All variables used in the fixed and random effects
models, as well as the grouping factors, must be present in the data
frame.  If missing, the fitted values are returned.</p>
</td></tr>
<tr><td><code id="predict.lme_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in obtaining the predictions.  Level values increase from
outermost to innermost grouping, with level zero corresponding to the
population predictions.  Defaults to the highest or innermost level of
grouping.</p>
</td></tr>
<tr><td><code id="predict.lme_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> and a single
value is given in <code>level</code>, the returned object is a list with
the predictions split by groups; else the returned value is
either a vector or a data frame, according to the length of
<code>level</code>. </p>
</td></tr>
<tr><td><code id="predict.lme_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when
<code>newdata</code> contains <code>NA</code>s.  The default action
(<code>na.fail</code>) causes the function to print an error message and
terminate if there are any incomplete observations.</p>
</td></tr>
<tr><td><code id="predict.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>, the
returned value is either a list with the predictions split by groups
(<code>asList = TRUE</code>) or a vector with the predictions
(<code>asList = FALSE</code>); else, when multiple grouping levels are
specified in <code>level</code>, the returned object is a data frame with
columns given by the predictions at different levels and the grouping
factors.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+fitted.lme">fitted.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
newOrth &lt;- data.frame(Sex = c("Male","Male","Female","Female","Male","Male"),
                      age = c(15, 20, 10, 12, 2, 4),
                      Subject = c("M01","M01","F30","F30","M04","M04"))
## The 'Orthodont' data has *no* 'F30', so predict  NA  at level 1 :
predict(fm1, newOrth, level = 0:1)
</code></pre>

<hr>
<h2 id='predict.lmList'>Predictions from an lmList Object</h2><span id='topic+predict.lmList'></span>

<h3>Description</h3>

<p>If the grouping factor corresponding to <code>object</code> is included
in <code>newdata</code>, the data frame is partitioned according to the
grouping factor levels; else, <code>newdata</code> is repeated for all
<code>lm</code> components. The predictions and, optionally, the standard
errors for the predictions, are obtained for each <code>lm</code>
component of <code>object</code>, using the corresponding element of the
partitioned <code>newdata</code>, and arranged into a list with as many
components as <code>object</code>, or combined into a single vector or data
frame (if <code>se.fit=TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
predict(object, newdata, subset, pool, asList, se.fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="predict.lmList_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions. All variables used in the <code>object</code> model formula
must be present in the data frame. If missing, the same data frame
used to produce <code>object</code> is used.
</p>
</td></tr> 
<tr><td><code id="predict.lmList_+3A_subset">subset</code></td>
<td>
<p>an optional character or integer vector naming the
<code>lm</code> components of <code>object</code> from which the predictions
are to be extracted. Default is <code>NULL</code>, in which case all
components are used.
</p>
</td></tr>
<tr><td><code id="predict.lmList_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
object is a list with the predictions split by groups; else the
returned value is a vector. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="predict.lmList_+3A_pool">pool</code></td>
<td>
<p>an optional logical value indicating whether a pooled
estimate of the residual standard error should be used. Default is
<code>attr(object, "pool")</code>.
</p>
</td></tr>
<tr><td><code id="predict.lmList_+3A_se.fit">se.fit</code></td>
<td>
<p>an optional logical value indicating whether pointwise
standard errors should be computed along with the
predictions. Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="predict.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by the predictions (and, optionally, the
standard errors for the predictions) from each <code>lm</code>
component of <code>object</code>,  a vector with the predictions from all 
<code>lm</code> components of <code>object</code>, or a data frame with columns
given by the predictions and their corresponding standard errors.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
predict(fm1, se.fit = TRUE)
</code></pre>

<hr>
<h2 id='predict.nlme'>Predictions from an nlme Object</h2><span id='topic+predict.nlme'></span>

<h3>Description</h3>

<p>The predictions at level <code class="reqn">i</code> are obtained by adding together the
contributions from the estimated fixed effects and the estimated
random effects at levels less or equal to <code class="reqn">i</code> and evaluating the
model function at the resulting estimated parameters.  If group values
not included in the original grouping factors  are present in
<code>newdata</code>, the corresponding predictions will be  set to
<code>NA</code> for levels greater or equal to the level at which the
unknown groups occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlme'
predict(object, newdata, level = Q, asList = FALSE,
        na.action = na.fail, naPattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.nlme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+nlme">nlme</a>"</code>,
representing a fitted nonlinear mixed-effects model.</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame to be used for obtaining the
predictions.  All variables used in the nonlinear model, the fixed and
the random effects models, as well as the grouping factors, must be
present in the data frame.  If missing, the fitted values are
returned.</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in obtaining the predictions.  Level values increase from
outermost to innermost grouping, with level zero corresponding to the
population predictions.  Defaults to the highest or innermost level of
grouping (and is <code>object$dims$Q</code>).</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> and a single
value is given in <code>level</code>, the returned object is a list with
the predictions split by groups; else the returned value is
either a vector or a data frame, according to the length of
<code>level</code>.</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when
<code>newdata</code> contains <code>NA</code>s.  The default action
(<code>na.fail</code>) causes the function to print an error message and
terminate if there are any incomplete observations.</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_napattern">naPattern</code></td>
<td>
<p>an expression or formula object, specifying which returned
values are to be regarded as missing.</p>
</td></tr>
<tr><td><code id="predict.nlme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>, the
returned value is either a list with the predictions split by groups
(<code>asList = TRUE</code>) or a vector with the predictions
(<code>asList = FALSE</code>); else, when multiple grouping levels are
specified in <code>level</code>, the returned object is a data frame with
columns given by the predictions at different levels and the grouping
factors.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>, <code><a href="#topic+fitted.lme">fitted.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>head(Loblolly) # groupedData  w/  'Seed' is grouping variable :
## Grouped Data: height ~ age | Seed
##    height age Seed
## 1    4.51   3  301
## 15  10.89   5  301
## ..  .....   .  ...

fm1 &lt;- nlme(height ~ SSasymp(age, Asym, R0, lrc),  data = Loblolly,
            fixed = Asym + R0 + lrc ~ 1,
            random = Asym ~ 1, ## &lt;---grouping---&gt;  Asym ~ 1 | Seed
            start = c(Asym = 103, R0 = -8.5, lrc = -3.3))
fm1

age. &lt;- seq(from = 2, to = 30, by = 2)
newLL.301 &lt;- data.frame(age = age., Seed = 301)
newLL.329 &lt;- data.frame(age = age., Seed = 329)
(p301 &lt;- predict(fm1, newLL.301, level = 0:1))
(p329 &lt;- predict(fm1, newLL.329, level = 0:1))
## Prediction are the same at level 0 :
all.equal(p301[,"predict.fixed"],
          p329[,"predict.fixed"])
## and differ by the 'Seed' effect at level 1 :
p301[,"predict.Seed"] -
p329[,"predict.Seed"]
</code></pre>

<hr>
<h2 id='print.summary.pdMat'>Print a summary.pdMat Object</h2><span id='topic+print.summary.pdMat'></span>

<h3>Description</h3>

<p>The standard deviations and correlations associated with the
positive-definite matrix represented by <code>object</code> (considered as a
variance-covariance matrix) are printed, together with the formula and
the grouping level associated <code>object</code>, if any are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pdMat'
print(x, sigma, rdig, Level, resid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pdMat_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+summary.pdMat">summary.pdMat</a>"</code>,
generally resulting from applying <code><a href="base.html#topic+summary">summary</a></code> to an object
inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>.</p>
</td></tr>
<tr><td><code id="print.summary.pdMat_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as a multiplier for
the square-root factor of the positive-definite matrix represented by
<code>object</code> (usually the estimated within-group standard deviation
from a mixed-effects model). Defaults to 1.</p>
</td></tr> 
<tr><td><code id="print.summary.pdMat_+3A_rdig">rdig</code></td>
<td>
<p>an optional integer value with the number of significant
digits to be used in printing correlations. Defaults to 3.</p>
</td></tr>
<tr><td><code id="print.summary.pdMat_+3A_level">Level</code></td>
<td>
<p>an optional character string with a description of the
grouping level associated with <code>object</code> (generally corresponding
to levels of grouping in a mixed-effects model). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="print.summary.pdMat_+3A_resid">resid</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> an extra row
with the <code>"residual"</code> standard deviation given in <code>sigma</code>
will be included in the output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.summary.pdMat_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>print.default</code>; see
the documentation on that method function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.pdMat">summary.pdMat</a></code>,<code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdCompSymm(3 * diag(2) + 1, form = ~age + age^2,
         data = Orthodont)
print(summary(pd1), sigma = 1.2, resid = TRUE)
</code></pre>

<hr>
<h2 id='print.varFunc'>Print a varFunc Object</h2><span id='topic+print.varFunc'></span><span id='topic+print.varComb'></span>

<h3>Description</h3>

<p>The class and the coefficients associated with <code>x</code> are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.varFunc_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr>
<tr><td><code id="print.varFunc_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code>print.default</code>; see
the documentation on that method function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.varFunc">summary.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(0.3, form = ~age)
vf1 &lt;- Initialize(vf1, Orthodont)
print(vf1)
</code></pre>

<hr>
<h2 id='qqnorm.gls'>Normal Plot of Residuals from a gls Object</h2><span id='topic+qqnorm.gls'></span>

<h3>Description</h3>

<p>Diagnostic plots for assessing the normality of residuals the
generalized least squares fit are obtained. The <code>form</code> argument
gives considerable flexibility in the type of plot specification. A
conditioning expression (on the right side of a <code>|</code> operator)
always implies that different panels are used for each level of the
conditioning factor, according to a Trellis display. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
qqnorm(y, form, abline, id, idLabels, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqnorm.gls_+3A_y">y</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted model.</p>
</td></tr>
<tr><td><code id="qqnorm.gls_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>y</code> can be referenced. In addition, <code>y</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. The expression on the right hand side of <code>form</code> and to
the left of a <code>|</code> operator must evaluate to a residuals
vector. Default is <code>~ resid(., type = "p")</code>, 
corresponding to a normal plot of the standardized residuals.</p>
</td></tr>  
<tr><td><code id="qqnorm.gls_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric vector of length
two. If given as a single value, a horizontal line will be added to the
plot at that coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the plot. If
missing, no lines are added to the plot.</p>
</td></tr>
<tr><td><code id="qqnorm.gls_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for a two-sided outlier
test for the standardized residuals (random effects). Observations with
absolute standardized residuals (random effects) greater than the
<code class="reqn">1 - value/2</code> quantile of the standard normal distribution are
identified in the plot using <code>idLabels</code>. If given as a one-sided
formula, its right hand side must evaluate to a  logical, integer, or
character vector which is used to identify observations in the
plot. If missing, no observations are identified.</p>
</td></tr>
<tr><td><code id="qqnorm.gls_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
observations identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
observations. Default is the innermost grouping factor.</p>
</td></tr>
<tr><td><code id="qqnorm.gls_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default depends on the type of Trellis plot used:
if <code>xyplot</code> defaults to <code>TRUE</code>, else defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qqnorm.gls_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot for assessing normality of residuals.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>, <code><a href="#topic+plot.gls">plot.gls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
qqnorm(fm1, abline = c(0,1))
</code></pre>

<hr>
<h2 id='qqnorm.lme'>Normal Plot of Residuals or Random Effects from an lme Object</h2><span id='topic+qqnorm.lm'></span><span id='topic+qqnorm.lme'></span><span id='topic+qqnorm.lmList'></span><span id='topic+qqnorm.nls'></span>

<h3>Description</h3>

<p>Diagnostic plots for assessing the normality of residuals and random
effects in the linear mixed-effects fit are obtained. The
<code>form</code> argument gives considerable flexibility in the type of
plot specification. A conditioning expression (on the right side of a
<code>|</code> operator) always implies that different panels are used for
each level of the conditioning factor, according to a Trellis
display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
qqnorm(y, form, abline, id, idLabels, grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqnorm.lme_+3A_y">y</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model or from class <code>"<a href="#topic+lmList">lmList</a>"</code>,
representing a list of <code>lm</code> objects, or from class <code>"lm"</code>,
representing a fitted linear model, or from class <code>"nls"</code>,
representing a nonlinear least squares fitted model.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the desired type of
plot. Any variable present in the original data frame used to obtain
<code>y</code> can be referenced. In addition, <code>y</code> itself
can be referenced in the formula using the symbol
<code>"."</code>. Conditional expressions on the right of a <code>|</code>
operator can be used to define separate panels in a Trellis
display. The expression on the right hand side of <code>form</code> and to
the left of a <code>|</code> operator must evaluate to a residuals vector,
or a random effects matrix. Default is <code>~ resid(., type = "p")</code>,
corresponding to a normal plot of the standardized residuals
evaluated at the innermost level of nesting.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_abline">abline</code></td>
<td>
<p>an optional numeric value, or numeric vector of length
two. If given as a single value, a horizontal line will be added to the
plot at that coordinate; else, if given as a vector, its values are
used as the intercept and slope for a line added to the plot. If
missing, no lines are added to the plot.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_id">id</code></td>
<td>
<p>an optional numeric value, or one-sided formula. If given as
a value, it is used as a significance level for a two-sided outlier
test for the standardized residuals (random effects). Observations with
absolute standardized residuals (random effects) greater than the
<code class="reqn">1 - value/2</code> quantile of the standard normal distribution are
identified in the plot using <code>idLabels</code>. If given as a one-sided
formula, its right hand side must evaluate to a  logical, integer, or
character vector which is used to identify observations in the
plot. If missing, no observations are identified.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_idlabels">idLabels</code></td>
<td>
<p>an optional vector, or one-sided formula. If given as a
vector, it is converted to character and used to label the
observations identified according to <code>id</code>. If given as a
one-sided formula, its right hand side must evaluate to a vector
which is converted to character and used to label the identified
observations. Default is the innermost grouping factor.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_grid">grid</code></td>
<td>
<p>an optional logical value indicating whether a grid should
be added to plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="qqnorm.lme_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the Trellis plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a diagnostic Trellis plot for assessing normality of residuals or
random effects.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+plot.lme">plot.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
## normal plot of standardized residuals by gender
qqnorm(fm1, ~ resid(., type = "p") | Sex, abline = c(0, 1))
## normal plots of random effects
qqnorm(fm1, ~ranef(.))
</code></pre>

<hr>
<h2 id='Quinidine'>Quinidine Kinetics</h2><span id='topic+Quinidine'></span>

<h3>Description</h3>

<p>The <code>Quinidine</code> data frame has 1471 rows and 14 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Subject</dt><dd>
<p>a factor identifying the patient on whom the data were collected.
</p>
</dd>
<dt>time</dt><dd>
<p>a numeric vector giving the time (hr) at which the drug was
administered or the blood sample drawn.  This is measured
from the time the patient entered the study.
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector giving the serum quinidine concentration (mg/L).
</p>
</dd>
<dt>dose</dt><dd>
<p>a numeric vector giving the dose of drug administered (mg).
Although there were two different forms of quinidine
administered, the doses were adjusted for differences in
salt content by conversion to milligrams of quinidine base.
</p>
</dd>
<dt>interval</dt><dd>
<p>a numeric vector giving the when the drug has been given at
regular intervals for a sufficiently long period of time to
assume steady state behavior, the interval is recorded.
</p>
</dd>
<dt>Age</dt><dd>
<p>a numeric vector giving the age of the subject on entry to
the study (yr).
</p>
</dd>
<dt>Height</dt><dd>
<p>a numeric vector giving the height of the subject on entry
to the study (in.).
</p>
</dd>
<dt>Weight</dt><dd>
<p>a numeric vector giving the body weight of the subject (kg).
</p>
</dd>
<dt>Race</dt><dd>
<p>a factor with levels
<code>Caucasian</code>, 
<code>Latin</code>, and
<code>Black</code> identifying the race of the subject.
</p>
</dd>
<dt>Smoke</dt><dd>
<p>a factor with levels
<code>no</code> and
<code>yes</code> giving smoking status at the time of the
measurement.
</p>
</dd>
<dt>Ethanol</dt><dd>
<p>a factor with levels
<code>none</code>, 
<code>current</code>,
<code>former</code> giving ethanol (alcohol) abuse status at the
time of the measurement.
</p>
</dd>
<dt>Heart</dt><dd>
<p>a factor with levels
<code>No/Mild</code>, 
<code>Moderate</code>, and 
<code>Severe</code> indicating congestive heart failure for the subject.
</p>
</dd>
<dt>Creatinine</dt><dd>
<p>an ordered factor with levels
<code>&lt; 50</code> &lt; <code>&gt;= 50</code> indicating the creatinine clearance (mg/min).
</p>
</dd>
<dt>glyco</dt><dd>
<p>a numeric vector giving the alpha-1 acid glycoprotein
concentration (mg/dL).  Often measured at the same time as
the quinidine concentration.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Verme et al. (1992) analyze routine clinical data on
patients receiving the drug quinidine as a treatment for cardiac
arrhythmia (atrial fibrillation or ventricular arrhythmias).  All
patients were receiving oral quinidine doses.  At irregular intervals
blood samples were drawn and serum concentrations of quinidine were
determined.  These data are
analyzed in several publications, including Davidian and Giltinan (1995,
section 9.3).
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.25)
</p>
<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.
</p>
<p>Verme, C. N., Ludden,  T. M., Clementi, W. A. and Harris,
S. C. (1992), Pharmacokinetics of quinidine in male patients: A
population analysis, <em>Clinical Pharmacokinetics</em>, <b>22</b>,
468-480.
</p>

<hr>
<h2 id='quinModel'>Model function for the Quinidine data</h2><span id='topic+quinModel'></span>

<h3>Description</h3>

<p>A model function for a model used with the <code>Quinidine</code> data.
This function calls compiled C code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quinModel(Subject, time, conc, dose, interval, lV, lKa, lCl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quinModel_+3A_subject">Subject</code></td>
<td>

<p>a factor identifying the patient on whom the data were collected.
</p>
</td></tr>
<tr><td><code id="quinModel_+3A_time">time</code></td>
<td>

<p>a numeric vector giving the time (hr) at which the drug was
administered or the blood sample drawn.  This is measured
from the time the patient entered the study.
</p>
</td></tr>
<tr><td><code id="quinModel_+3A_conc">conc</code></td>
<td>

<p>a numeric vector giving the serum quinidine concentration (mg/L).
</p>
</td></tr>
<tr><td><code id="quinModel_+3A_dose">dose</code></td>
<td>

<p>a numeric vector giving the dose of drug administered (mg).
Although there were two different forms of quinidine
administered, the doses were adjusted for differences in
salt content by conversion to milligrams of quinidine base.
</p>
</td></tr>
<tr><td><code id="quinModel_+3A_interval">interval</code></td>
<td>

<p>a numeric vector giving the when the drug has been given at
regular intervals for a sufficiently long period of time to
assume steady state behavior, the interval is recorded.
</p>
</td></tr>
<tr><td><code id="quinModel_+3A_lv">lV</code></td>
<td>
<p>numeric.  A vector of values of the natural log of the
effective volume of distribution according to <code>Subject</code> and
<code>time</code>.</p>
</td></tr>
<tr><td><code id="quinModel_+3A_lka">lKa</code></td>
<td>
<p>numeric.  A vector of values of the natural log of the
absorption rate constant according to <code>Subject</code> and <code>time</code>.</p>
</td></tr>
<tr><td><code id="quinModel_+3A_lcl">lCl</code></td>
<td>
<p>numeric.  A vector of values of the natural log of the
clearance parameter according to <code>Subject</code> and <code>time</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details section of <code><a href="#topic+Quinidine">Quinidine</a></code> for a description
of the model function that <code>quinModel</code> evaluates.
</p>


<h3>Value</h3>

<p>a numeric vector of predicted quinidine concentrations.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a>
</p>


<h3>References</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000) <em>Mixed-effects Models in
S and S-PLUS</em>, Springer. (section 8.2)
</p>

<hr>
<h2 id='Rail'>Evaluation of Stress in Railway Rails</h2><span id='topic+Rail'></span>

<h3>Description</h3>

<p>The <code>Rail</code> data frame has 18 rows and 2 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Rail</dt><dd>
<p>an ordered factor identifying the rail on which the
measurement was made.
</p>
</dd>
<dt>travel</dt><dd>
<p>a numeric vector giving the travel time for ultrasonic
head-waves in the rail (nanoseconds).  The value given is the
original travel time minus 36,100 nanoseconds.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Devore (2000, Example 10.10, p. 427) cites data from an article in
<em>Materials Evaluation</em> on &ldquo;a study of travel time for a certain
type of wave that results from longitudinal stress of rails used for
railroad track.&rdquo;
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.26)
</p>
<p>Devore, J. L. (2000), <em>Probability and Statistics for
Engineering and the Sciences (5th ed)</em>, Duxbury, Boston, MA.
</p>

<hr>
<h2 id='random.effects'>Extract Random Effects</h2><span id='topic+random.effects'></span><span id='topic+ranef'></span><span id='topic+print.ranef'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>lmList</code> and <code>lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.effects(object, ...)
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.effects_+3A_object">object</code></td>
<td>
<p>any fitted model object from which random effects
estimates can be extracted.</p>
</td></tr>
<tr><td><code id="random.effects_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.lmList">ranef.lmList</a></code>,<code><a href="#topic+ranef.lme">ranef.lme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='ranef.lme'>Extract lme Random Effects</h2><span id='topic+ranef.lme'></span><span id='topic+random.effects.lme'></span><span id='topic+print.ranef.lme'></span>

<h3>Description</h3>

<p>The estimated random effects at level <code class="reqn">i</code> are represented as a
data frame with rows given by the different groups at that level and
columns given by the random effects. If a single level of
grouping is specified, the returned object is a data frame; else, the
returned object is a list of such data frames. Optionally, the
returned data frame(s) may be augmented with covariates summarized
over groups.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
ranef(object, augFrame, level, data, which, FUN,
      standard, omitGroupingFactor, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_augframe">augFrame</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
data frame is augmented with variables defined in <code>data</code>; else,
if <code>FALSE</code>, only the coefficients are returned. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_level">level</code></td>
<td>
<p>an optional vector of positive integers giving the levels
of grouping to be used in extracting the random effects from an
object with multiple nested grouping levels. Defaults to all levels
of grouping.</p>
</td></tr> 
<tr><td><code id="ranef.lme_+3A_data">data</code></td>
<td>
<p>an optional data frame with the variables to be used for
augmenting the returned data frame when <code>augFrame =
     TRUE</code>. Defaults to the data frame used to fit <code>object</code>.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_which">which</code></td>
<td>
<p>an optional positive integer vector specifying which
columns of <code>data</code> should be used in the augmentation of the
returned data frame. Defaults to all columns in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be applied to group-varying variables, when collapsing <code>data</code>
by groups.  Group-invariant variables are always summarized by the
unique value that they assume within that group. If <code>FUN</code> is a
single function it will be applied to each non-invariant variable by
group to produce the summary for that variable.  If <code>FUN</code> is a
list of functions, the names in the list should designate classes of
variables in the frame such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
group-varying variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_standard">standard</code></td>
<td>
<p>an optional logical value indicating whether the
estimated random effects should be &quot;standardized&quot; (i.e. divided by
the estimate of the standard deviation of that group of random
effects). Defaults to <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="ranef.lme_+3A_omitgroupingfactor">omitGroupingFactor</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code>
the grouping factor itself will be omitted from the group-wise
summary of <code>data</code> but the levels of the grouping factor will
continue to be used as the row names for the returned data frame.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating for which rows the
random effects should be extracted.</p>
</td></tr>
<tr><td><code id="ranef.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame, or list of data frames, with the estimated 
random effects at the grouping level(s) specified in <code>level</code> and,
optionally, other covariates  summarized over groups. The returned
object inherits from classes <code>random.effects.lme</code> and
<code>data.frame</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.lme">coef.lme</a></code>,
<code><a href="#topic+gsummary">gsummary</a></code>,
<code><a href="#topic+lme">lme</a></code>, 
<code><a href="#topic+plot.ranef.lme">plot.ranef.lme</a></code>, 
<code><a href="#topic+random.effects">random.effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
ranef(fm1)
random.effects(fm1)             # same as above
random.effects(fm1, augFrame = TRUE)
</code></pre>

<hr>
<h2 id='ranef.lmList'>Extract lmList Random Effects</h2><span id='topic+random.effects.lmList'></span><span id='topic+ranef.lmList'></span>

<h3>Description</h3>

<p>The difference between the individual <code>lm</code> components
coefficients and their average is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
ranef(object, augFrame, data, which, FUN, standard,
                 omitGroupingFactor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_augframe">augFrame</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
data frame is augmented with variables defined in <code>data</code>; else,
if <code>FALSE</code>, only the coefficients are returned. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_data">data</code></td>
<td>
<p>an optional data frame with the variables to be used for
augmenting the returned data frame when <code>augFrame =
     TRUE</code>. Defaults to the data frame used to fit <code>object</code>.</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_which">which</code></td>
<td>
<p>an optional positive integer vector specifying which
columns of <code>data</code> should be used in the augmentation of the
returned data frame. Defaults to all columns in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_fun">FUN</code></td>
<td>
<p>an optional summary function or a list of summary functions
to be applied to group-varying variables, when collapsing <code>data</code>
by groups.  Group-invariant variables are always summarized by the
unique value that they assume within that group. If <code>FUN</code> is a
single function it will be applied to each non-invariant variable by
group to produce the summary for that variable.  If <code>FUN</code> is a
list of functions, the names in the list should designate classes of
variables in the frame such as <code>ordered</code>, <code>factor</code>, or
<code>numeric</code>.  The indicated function will be applied to any
group-varying variables of that class.  The default functions to be
used are <code>mean</code> for numeric factors, and <code>Mode</code> for both
<code>factor</code> and <code>ordered</code>.  The <code>Mode</code> function, defined
internally in <code>gsummary</code>, returns the modal or most popular
value of the variable.  It is different from the <code>mode</code> function
that returns the S-language mode of the variable.</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_standard">standard</code></td>
<td>
<p>an optional logical value indicating whether the
estimated random effects should be &quot;standardized&quot; (i.e. divided by
the corresponding estimated standard error). Defaults to
<code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="ranef.lmList_+3A_omitgroupingfactor">omitGroupingFactor</code></td>
<td>
<p>an optional logical value.  When <code>TRUE</code>
the grouping factor itself will be omitted from the group-wise
summary of <code>data</code> but the levels of the grouping factor will
continue to be used as the row names for the returned data frame.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranef.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the differences between the individual <code>lm</code>
coefficients in <code>object</code> and their average. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer, esp. pp. 100, 461.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed.effects.lmList">fixed.effects.lmList</a></code>, 
<code><a href="#topic+lmList">lmList</a></code>, 
<code><a href="#topic+random.effects">random.effects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
ranef(fm1)
random.effects(fm1)              # same as above
</code></pre>

<hr>
<h2 id='RatPupWeight'>The weight of rat pups</h2><span id='topic+RatPupWeight'></span>

<h3>Description</h3>

<p>The <code>RatPupWeight</code> data frame has 322 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>weight</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>sex</dt><dd>
<p>a factor with levels
<code>Male</code> 
<code>Female</code> 
</p>
</dd>
<dt>Litter</dt><dd>
<p>an ordered factor with levels
<code>9</code> &lt; <code>8</code> &lt; <code>7</code> &lt; <code>4</code> &lt; <code>2</code> &lt; <code>10</code> &lt; <code>1</code> &lt; <code>3</code> &lt; <code>5</code> &lt; <code>6</code> &lt; <code>21</code> &lt; <code>22</code> &lt; <code>24</code> &lt; <code>27</code> &lt; <code>26</code> &lt; <code>25</code> &lt; <code>23</code> &lt; <code>17</code> &lt; <code>11</code> &lt; <code>14</code> &lt; <code>13</code> &lt; <code>15</code> &lt; <code>16</code> &lt; <code>20</code> &lt; <code>19</code> &lt; <code>18</code> &lt; <code>12</code>
</p>
</dd>
<dt>Lsize</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Treatment</dt><dd>
<p>an ordered factor with levels
<code>Control</code> &lt; <code>Low</code> &lt; <code>High</code>
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='recalc'>Recalculate Condensed Linear Model Object</h2><span id='topic+recalc'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include: <code>corStruct</code>, <code>modelStruct</code>,
<code>reStruct</code>, and <code>varFunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalc(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc_+3A_object">object</code></td>
<td>
<p>any object which induces a recalculation of the condensed
linear model object <code>conLin</code>.</p>
</td></tr>
<tr><td><code id="recalc_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr>
<tr><td><code id="recalc_+3A_...">...</code></td>
<td>
<p>some methods for this generic can take additional
arguments.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the recalculated condensed linear model object.
</p>


<h3>Note</h3>

<p>This function is only used inside model fitting functions, such as
<code>lme</code> and <code>gls</code>, that require recalculation of a condensed
linear model object.</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+recalc.corStruct">recalc.corStruct</a></code>,
<code><a href="#topic+recalc.modelStruct">recalc.modelStruct</a></code>,
<code><a href="#topic+recalc.reStruct">recalc.reStruct</a></code>,
<code><a href="#topic+recalc.varFunc">recalc.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='recalc.corStruct'>Recalculate for corStruct Object</h2><span id='topic+recalc.corStruct'></span><span id='topic+recalc.corAR1'></span><span id='topic+recalc.corARMA'></span><span id='topic+recalc.corCAR1'></span><span id='topic+recalc.corCompSymm'></span><span id='topic+recalc.corHF'></span><span id='topic+recalc.corNatural'></span><span id='topic+recalc.corSpatial'></span><span id='topic+recalc.corSymm'></span>

<h3>Description</h3>

<p>This method function pre-multiples the <code>"Xy"</code> component of
<code>conLin</code> by the transpose square-root factor(s) of the
correlation matrix (matrices) associated with <code>object</code> and adds
the log-likelihood contribution of <code>object</code>, given by
<code>logLik(object)</code>, to the <code>"logLik"</code> component of
<code>conLin</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
recalc(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="recalc.corStruct_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr> 
<tr><td><code id="recalc.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the recalculated condensed linear model object.
</p>


<h3>Note</h3>

<p>This method function is only used inside model
fitting functions, such as <code>lme</code> and <code>gls</code>,
that allow correlated error terms.</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+corFactor">corFactor</a></code>,
<code><a href="#topic+logLik.corStruct">logLik.corStruct</a></code>
</p>

<hr>
<h2 id='recalc.modelStruct'>Recalculate for a modelStruct Object</h2><span id='topic+recalc.modelStruct'></span>

<h3>Description</h3>

<p>This method function recalculates the condensed linear model object
using each element of <code>object</code> sequentially from last to first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelStruct'
recalc(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc.modelStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"modelStruct"</code>,
representing a list of model components, such as <code>corStruct</code> and
<code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="recalc.modelStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional  condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="recalc.modelStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the recalculated condensed linear model object.
</p>


<h3>Note</h3>

<p>This method function is generally only used inside model fitting
functions, such as <code>lme</code> and <code>gls</code>, that allow model
components, such as correlated error terms and variance functions.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+recalc.corStruct">recalc.corStruct</a></code>,
<code><a href="#topic+recalc.reStruct">recalc.reStruct</a></code>,
<code><a href="#topic+recalc.varFunc">recalc.varFunc</a></code></p>

<hr>
<h2 id='recalc.reStruct'>Recalculate for an reStruct Object</h2><span id='topic+recalc.reStruct'></span>

<h3>Description</h3>

<p>The log-likelihood, or restricted log-likelihood, of the
Gaussian linear mixed-effects model represented by <code>object</code> and
<code>conLin</code> (assuming spherical within-group covariance structure),
evaluated at <code>coef(object)</code> is calculated and added to the
<code>logLik</code> component of <code>conLin</code>. The <code>settings</code>
attribute of <code>object</code> determines whether the log-likelihood, or
the restricted log-likelihood, is to be calculated. The computational
methods for the (restricted) log-likelihood calculations are described
in Bates and Pinheiro (1998). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
recalc(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc.reStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="recalc.reStruct_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr> 
<tr><td><code id="recalc.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the condensed linear model with its <code>logLik</code> component updated.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="#topic+lme">lme</a></code>, 
<code><a href="#topic+recalc">recalc</a></code>,
<code><a href="#topic+reStruct">reStruct</a></code>
</p>

<hr>
<h2 id='recalc.varFunc'>Recalculate for varFunc Object</h2><span id='topic+recalc.varFunc'></span><span id='topic+recalc.varIdent'></span>

<h3>Description</h3>

<p>This method function pre-multiples the <code>"Xy"</code> component of
<code>conLin</code> by a diagonal matrix with diagonal elements given by the
weights corresponding to the variance structure represented by
<code>object</code>e and adds the log-likelihood contribution of
<code>object</code>, given by <code>logLik(object)</code>, to the <code>"logLik"</code>
component of <code>conLin</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
recalc(object, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recalc.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr> 
<tr><td><code id="recalc.varFunc_+3A_conlin">conLin</code></td>
<td>
<p>a condensed linear model object, consisting of a list
with components <code>"Xy"</code>, corresponding to a regression matrix
(<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying model.</p>
</td></tr> 
<tr><td><code id="recalc.varFunc_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>the recalculated condensed linear model object.
</p>


<h3>Note</h3>

<p>This method function is only used inside model fitting functions,
such as <code>lme</code> and <code>gls</code>, that allow heteroscedastic error
terms.</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+recalc">recalc</a></code>,
<code><a href="#topic+varWeights">varWeights</a></code>,
<code><a href="#topic+logLik.varFunc">logLik.varFunc</a></code></p>

<hr>
<h2 id='Relaxin'>Assay for Relaxin</h2><span id='topic+Relaxin'></span>

<h3>Description</h3>

<p>The <code>Relaxin</code> data frame has 198 rows and 3 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Run</dt><dd>
<p>an ordered factor with levels
<code>5</code> &lt; <code>8</code> &lt; <code>9</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>2</code> &lt; <code>7</code> &lt; <code>1</code> &lt; <code>6</code>
</p>
</dd>
<dt>conc</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>cAMP</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='Remifentanil'>Pharmacokinetics of Remifentanil</h2><span id='topic+Remifentanil'></span>

<h3>Description</h3>

<p>Intravenous infusion of remifentanil (a strong analgesic) in different
rates over varying time periods was applied to a total of 65 patients.
Concentration measurements of remifentanil were taken along with several
covariates resulting in the <code>Remifentanil</code> data frame with 2107 rows
and 12 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Remifentanil", package = "nlme")
</code></pre>


<h3>Format</h3>

<p>This data frame (of class <code>"<a href="#topic+groupedData">groupedData</a>"</code>, specifically
<code>"nfnGroupedData"</code>) contains the following columns:
</p>

<dl>
<dt><code>ID</code>:</dt><dd><p>numerical (patient) IDs.</p>
</dd>
<dt><code>Subject</code>:</dt><dd><p>an <code><a href="base.html#topic+ordered">ordered</a></code> factor with 65 levels (of the
<code>ID</code>s): <code>30</code> &lt; <code>21</code> &lt; <code>25</code> &lt; <code>23</code> &lt;
<code>29</code> &lt; ... ... &lt; <code>36</code> &lt; <code>6</code> &lt; <code>5</code> &lt; <code>10</code> &lt; <code>9</code>.</p>
</dd>
<dt><code>Time</code>:</dt><dd><p>time from beginning of infusion in minutes (<code><a href="base.html#topic+numeric">numeric</a></code>).</p>
</dd>
<dt><code>conc</code>:</dt><dd><p>remifentanil concentration in [ng / ml] (numeric).</p>
</dd>
<dt><code>Rate</code>:</dt><dd><p>infusion rate in [µg / min].</p>
</dd>
<dt><code>Amt</code>:</dt><dd><p>amount of remifentanil given in the current time interval in [µg].</p>
</dd>
<dt><code>Age</code>:</dt><dd><p>age of the patient in years.</p>
</dd>
<dt><code>Sex</code>:</dt><dd><p>gender of the patient, a <code><a href="base.html#topic+factor">factor</a></code> with levels
<code>Female</code> and <code>Male</code>.</p>
</dd>
<dt><code>Ht</code>:</dt><dd><p>height of the patient in cm.</p>
</dd>
<dt><code>Wt</code>:</dt><dd><p>weight of the patient in kg.</p>
</dd>
<dt><code>BSA</code>:</dt><dd><p>body surface area (DuBois and DuBois 1916): <code class="reqn">%
	BSA := Wt^{0.425} \cdot Ht^{0.725} \cdot 0.007184</code>.</p>
</dd>
<dt><code>LBM</code>:</dt><dd><p>lean body mass (James 1976), with slightly different
formula for
men <code class="reqn">LBM_m := 1.1  Wt - 128 (Wt/Ht)^2</code>, and
women <code class="reqn">LBM_f := 1.07 Wt - 148 (Wt/Ht)^2</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>of this help page: Niels Hagenbuch and Martin Maechler, SfS ETH Zurich.</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000).
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer, New York.
</p>


<h3>References</h3>

<p>Minto CF, Schnider TW, Egan TD, Youngs E, Lemmens HJM, Gambus PL, Billard
V, Hoke JF, Moore KHP, Hermann DJ, Muir KT, Mandema JW, Shafer SL (1997).
Influence of age and gender on the pharmacokinetics and pharmacodynamics
of remifentanil: I. Model development.
<em>Anesthesiology</em> <b>86</b> 1, 10&ndash;23.
<a href="https://pubs.asahq.org/anesthesiology/article/86/1/10/35947/Influence-of-Age-and-Gender-on-the">https://pubs.asahq.org/anesthesiology/article/86/1/10/35947/Influence-of-Age-and-Gender-on-the</a>
</p>
<p>Charles F. Minto, Thomas W. Schnider and Steven L. Shafer (1997).
Pharmacokinetics and Pharmacodynamics of Remifentanil: II. Model Application.
<em>Anesthesiology</em> <b>86</b> 1, 24&ndash;33.
<a href="https://pubs.asahq.org/anesthesiology/article/86/1/24/35925/Pharmacokinetics-and-Pharmacodynamics-of">https://pubs.asahq.org/anesthesiology/article/86/1/24/35925/Pharmacokinetics-and-Pharmacodynamics-of</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Remifentanil, type = "l", lwd = 2) # shows the 65 patients' remi profiles

## The same on  log-log  scale  (*more* sensible for modeling ?):
plot(Remifentanil, type = "l", lwd = 2, scales = list(log=TRUE))

str(Remifentanil)
summary(Remifentanil)

plot(xtabs(~Subject, Remifentanil))
summary(unclass(table(Remifentanil$Subject)))
## between 20 and 54 measurements per patient (median: 24; mean: 32.42)

## Only first measurement of each patient :
dim(Remi.1 &lt;- Remifentanil[!duplicated(Remifentanil[,"ID"]),]) #  65 x 12

LBMfn &lt;- function(Wt, Ht, Sex) ifelse(Sex == "Female",
                                        1.07 * Wt - 148*(Wt/Ht)^2,
                                        1.1  * Wt - 128*(Wt/Ht)^2)
with(Remi.1,
    stopifnot(all.equal(BSA, Wt^{0.425} * Ht^{0.725} * 0.007184, tol = 1.5e-5),
              all.equal(LBM, LBMfn(Wt, Ht, Sex),                 tol = 7e-7)
))

## Rate: typically  3 µg / kg body weight, but :
sunflowerplot(Rate ~ Wt, Remifentanil)
abline(0,3, lty=2, col=adjustcolor("black", 0.5))
</code></pre>

<hr>
<h2 id='residuals.gls'>Extract gls Residuals</h2><span id='topic+residuals.gls'></span><span id='topic+residuals.gnls'></span>

<h3>Description</h3>

<p>The residuals for the linear model represented by <code>object</code>
are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
residuals(object, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted linear model, or from class
<code>gnls</code>, representing a generalized nonlinear least squares
fitted linear model.</p>
</td></tr>
<tr><td><code id="residuals.gls_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used. If <code>"response"</code>, the &quot;raw&quot; residuals
(observed - fitted) are used; else, if <code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided.  Defaults to <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="residuals.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the residuals for the linear model represented by
<code>object</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
residuals(fm1)
</code></pre>

<hr>
<h2 id='residuals.glsStruct'>Calculate glsStruct Residuals</h2><span id='topic+residuals.glsStruct'></span>

<h3>Description</h3>

<p>The residuals for the linear model represented by <code>object</code>
are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsStruct'
residuals(object, glsFit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.glsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+glsStruct">glsStruct</a>"</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>"<a href="#topic+varFunc">varFunc</a>"</code> objects.</p>
</td></tr>
<tr><td><code id="residuals.glsStruct_+3A_glsfit">glsFit</code></td>
<td>
<p>an optional list with components <code>logLik</code>   
(log-likelihood), <code>beta</code> (coefficients), <code>sigma</code> (standard
deviation for error term), <code>varBeta</code> (coefficients' covariance
matrix), <code>fitted</code> (fitted values), and <code>residuals</code>
(residuals). Defaults to <code>attr(object, "glsFit")</code>.</p>
</td></tr>
<tr><td><code id="residuals.glsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the residuals for the linear model represented by
<code>object</code>. 
</p>


<h3>Note</h3>

<p>This method function is primarily used inside <code>gls</code> and 
<code>residuals.gls</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+glsStruct">glsStruct</a></code>,
<code><a href="#topic+residuals.gls">residuals.gls</a></code>,
<code><a href="#topic+fitted.glsStruct">fitted.glsStruct</a></code> </p>

<hr>
<h2 id='residuals.gnlsStruct'>Calculate gnlsStruct Residuals</h2><span id='topic+residuals.gnlsStruct'></span>

<h3>Description</h3>

<p>The residuals for the nonlinear model represented by <code>object</code>
are extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnlsStruct'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gnlsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gnlsStruct">gnlsStruct</a>"</code>,
representing a list of model components, such as
<code>corStruct</code> and <code>varFunc</code> objects, and attributes
specifying the underlying nonlinear model and the response variable.</p>
</td></tr>
<tr><td><code id="residuals.gnlsStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a vector with the residuals for the nonlinear model represented by
<code>object</code>. 
</p>


<h3>Note</h3>

<p>This method function is primarily used inside <code>gnls</code> and 
<code>residuals.gnls</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+gnls">gnls</a></code>,
<code><a href="#topic+residuals.gnls">residuals.gnls</a></code>,
<code><a href="#topic+fitted.gnlsStruct">fitted.gnlsStruct</a></code> </p>

<hr>
<h2 id='residuals.lme'>Extract lme Residuals</h2><span id='topic+residuals.lme'></span>

<h3>Description</h3>

<p>The residuals at level <code class="reqn">i</code> are obtained by subtracting the fitted
levels at that level from the response vector (and dividing
by the estimated within-group standard error, if
<code>type="pearson"</code>). The fitted values at level <code class="reqn">i</code> are obtained
by adding together the population fitted values (based only on the
fixed effects estimates) and the estimated contributions of the random
effects to the fitted values at grouping levels less or equal to
<code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
residuals(object, level = Q,
          type = c("response", "pearson", "normalized"), asList = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="residuals.lme_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the residuals from <code>object</code>. Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population residuals. Defaults to
the highest or innermost level of grouping.</p>
</td></tr>
<tr><td><code id="residuals.lme_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used.  If <code>"response"</code>, as by default, the
&ldquo;raw&rdquo; residuals (observed - fitted) are used; else, if
<code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided.</p>
</td></tr>
<tr><td><code id="residuals.lme_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code> and a single
value is given in <code>level</code>, the returned object is a list with
the residuals split by groups; else the returned value is
either a vector or a data frame, according to the length of
<code>level</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="residuals.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>, the
returned value is either a list with the residuals split by groups
(<code>asList = TRUE</code>) or a vector with the residuals
(<code>asList = FALSE</code>); else, when multiple grouping levels are
specified in <code>level</code>, the returned object is a data frame with
columns given by the residuals at different levels and the grouping
factors.  For a vector or data frame result the <code><a href="stats.html#topic+naresid">naresid</a></code>
method is applied.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+fitted.lme">fitted.lme</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age + Sex, data = Orthodont, random = ~ 1)
head(residuals(fm1, level = 0:1))
summary(residuals(fm1) /
        residuals(fm1, type = "p")) # constant scaling factor 1.432
</code></pre>

<hr>
<h2 id='residuals.lmeStruct'>Calculate lmeStruct Residuals</h2><span id='topic+residuals.lmeStruct'></span>

<h3>Description</h3>

<p>The residuals at level <code class="reqn">i</code> are obtained by subtracting the fitted
values at that level from the response vector.  The fitted values at
level <code class="reqn">i</code> are obtained by adding together the population fitted
values (based only on the fixed effects estimates) and the estimated
contributions of the random effects to the fitted values at grouping
levels less or equal to <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmeStruct'
residuals(object, level, conLin, lmeFit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.lmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmeStruct">lmeStruct</a>"</code>,
representing a list of linear mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="residuals.lmeStruct_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the residuals from <code>object</code>.  Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population fitted values.  Defaults to
the highest or innermost level of grouping.</p>
</td></tr>
<tr><td><code id="residuals.lmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying lme model.  Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="residuals.lmeStruct_+3A_lmefit">lmeFit</code></td>
<td>
<p>an optional list with components <code>beta</code> and <code>b</code>
containing respectively the fixed effects estimates and the random
effects estimates to be used to calculate the residuals.  Defaults
to <code>attr(object, "lmeFit")</code>.</p>
</td></tr>
<tr><td><code id="residuals.lmeStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic accept optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>,
the returned value is a vector with the residuals at the desired
level; else, when multiple grouping levels are specified in
<code>level</code>, the returned object is a matrix with
columns given by the residuals at different levels.
</p>


<h3>Note</h3>

<p>This method function is primarily used within the <code><a href="#topic+lme">lme</a></code>
function.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+residuals.lme">residuals.lme</a></code>,
<code><a href="#topic+fitted.lmeStruct">fitted.lmeStruct</a></code> </p>

<hr>
<h2 id='residuals.lmList'>Extract lmList Residuals</h2><span id='topic+residuals.lmList'></span>

<h3>Description</h3>

<p>The residuals are extracted from each <code>lm</code> component of
<code>object</code> and arranged into a list with as many components as
<code>object</code>, or combined into a single vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
residuals(object, type, subset, asList, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> objects with a common model.
</p>
</td></tr>
<tr><td><code id="residuals.lmList_+3A_subset">subset</code></td>
<td>
<p>an optional character or integer vector naming the
<code>lm</code> components of <code>object</code> from which the residuals 
are to be extracted. Default is <code>NULL</code>, in which case all
components are used.
</p>
</td></tr>
<tr><td><code id="residuals.lmList_+3A_type">type</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be extracted. Options include <code>"response"</code> for the
&quot;raw&quot; residuals (observed - fitted), <code>"pearson"</code> for the
standardized residuals (raw residuals divided by the estimated
residual standard error) using different standard errors for each
<code>lm</code> fit, and <code>"pooled.pearson"</code> for the standardized
residuals using a pooled estimate of the residual standard
error. Partial matching of arguments is used, so only the first 
character needs to be provided. Defaults to <code>"response"</code>.
</p>
</td></tr>
<tr><td><code id="residuals.lmList_+3A_aslist">asList</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the returned
object is a list with the residuals split by groups; else the
returned value is a vector. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="residuals.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with components given by the residuals of each <code>lm</code>
component of <code>object</code>, or a vector with the residuals for all
<code>lm</code> components of <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>, <code><a href="#topic+fitted.lmList">fitted.lmList</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
residuals(fm1)
</code></pre>

<hr>
<h2 id='residuals.nlmeStruct'>Calculate nlmeStruct Residuals</h2><span id='topic+residuals.nlmeStruct'></span>

<h3>Description</h3>

<p>The residuals at level <code class="reqn">i</code> are obtained by subtracting the fitted
values at that level from the response vector. The fitted values at
level <code class="reqn">i</code> are obtained by adding together the contributions from
the estimated fixed effects and the estimated random effects at levels
less or equal to <code class="reqn">i</code> and evaluating the model function at the
resulting estimated parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlmeStruct'
residuals(object, level, conLin, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.nlmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+nlmeStruct">nlmeStruct</a>"</code>,
representing a list of mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="residuals.nlmeStruct_+3A_level">level</code></td>
<td>
<p>an optional integer vector giving the level(s) of grouping
to be used in extracting the residuals from <code>object</code>. Level
values increase from outermost to innermost grouping, with
level zero corresponding to the population fitted values. Defaults to
the highest or innermost level of grouping.</p>
</td></tr> 
<tr><td><code id="residuals.nlmeStruct_+3A_conlin">conLin</code></td>
<td>
<p>an optional condensed linear model object, consisting of
a list with components <code>"Xy"</code>, corresponding to a regression
matrix (<code>X</code>) combined with a response vector (<code>y</code>), and 
<code>"logLik"</code>, corresponding to the log-likelihood of the
underlying nlme model. Defaults to <code>attr(object, "conLin")</code>.</p>
</td></tr>
<tr><td><code id="residuals.nlmeStruct_+3A_...">...</code></td>
<td>
<p>optional arguments to the residuals generic.  Not
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if a single level of grouping is specified in <code>level</code>,
the returned value is a vector with the residuals at the desired
level; else, when multiple grouping levels are specified in
<code>level</code>, the returned object is a matrix with 
columns given by the residuals at different levels. 
</p>


<h3>Note</h3>

<p>This method function is primarily used within the <code>nlme</code>
function. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Bates, D.M. and Pinheiro, J.C. (1998) &quot;Computational methods for
multilevel models&quot; available in PostScript or PDF formats at
http://nlme.stat.wisc.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlme">nlme</a></code>,
<code><a href="#topic+fitted.nlmeStruct">fitted.nlmeStruct</a></code> </p>

<hr>
<h2 id='reStruct'>Random Effects Structure</h2><span id='topic+reStruct'></span><span id='topic++5B.reStruct'></span><span id='topic+print.reStruct'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>reStruct</code> class,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects, plus a <code>settings</code> attribute containing
information for the optimization algorithm used to fit the associated
mixed-effects model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reStruct(object, pdClass, REML, data)
## S3 method for class 'reStruct'
print(x, sigma, reEstimates, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reStruct_+3A_object">object</code></td>
<td>
<p>any of the following: (i) a one-sided formula of the form
<code>~x1+...+xn | g1/.../gm</code>, with <code>x1+...+xn</code> specifying the
model for the random effects and <code>g1/.../gm</code> the grouping
structure (<code>m</code> may be equal to 1, in which case no <code>/</code> is
required). The random effects formula will be repeated for all levels
of grouping, in the case of multiple levels of grouping; (ii) a list of
one-sided formulas of the form <code>~x1+...+xn | g</code>, with possibly
different random effects models for each grouping level. The order of
nesting will be assumed the same as the order of the elements in the
list; (iii) a one-sided formula of the form <code>~x1+...+xn</code>, or a
<code>pdMat</code> object with a formula (i.e. a non-<code>NULL</code> value for
<code>formula(object)</code>), or a list of such formulas or <code>pdMat</code>
objects. In this case, the grouping structure formula will be derived
from the data used to to fit the mixed-effects model, which should
inherit from class <code>groupedData</code>; (iv) a named list of formulas or
<code>pdMat</code> objects as in (iii), with the grouping factors as
names. The order of nesting will be assumed the same as the order of
the order of the elements in the list; (v) an <code>reStruct</code> object.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_pdclass">pdClass</code></td>
<td>
<p>an optional character string with the name of the
<code>pdMat</code> class to be used for the formulas in
<code>object</code>. Defaults to <code>"pdLogChol"</code> which corresponds to a
general positive-definite matrix (Log-Cholesky parametrization).</p>
</td></tr>
<tr><td><code id="reStruct_+3A_reml">REML</code></td>
<td>
<p>an optional logical value. If <code>TRUE</code>, the associated
mixed-effects model will be fitted using restricted maximum
likelihood; else, if <code>FALSE</code>, maximum likelihood will be
used. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables
used in the random effects formulas in <code>object</code>. It is used to
obtain the levels for <code>factors</code>, which affect the dimensions and
the row/column names of the underlying <code>pdMat</code> objects. If
<code>NULL</code>, no attempt is made to obtain information on
<code>factors</code> appearing in the formulas. Defaults to the
parent frame from which the function was called.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>reStruct</code> to be printed.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as a multiplier for
the square-root factors of the <code>pdMat</code> components (usually the
estimated within-group standard deviation from a mixed-effects
model). Defaults to 1.</p>
</td></tr> 
<tr><td><code id="reStruct_+3A_reestimates">reEstimates</code></td>
<td>
<p>an optional list with the random effects estimates
for each level of grouping. Only used when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value determining if the random
effects estimates should be printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reStruct_+3A_...">...</code></td>
<td>
<p>Optional arguments can be given to other methods for this
generic.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from class <code>reStruct</code>, representing a random
effects structure.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+groupedData">groupedData</a></code>, 
<code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code>,
<code><a href="#topic+solve.reStruct">solve.reStruct</a></code>,
<code><a href="#topic+summary.reStruct">summary.reStruct</a></code>,
<code><a href="#topic+update.reStruct">update.reStruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(Dog = ~day, Side = ~1), data = Pixel)
rs1 # 2 entries "Uninitialized"
str(rs1) # a bit more
</code></pre>

<hr>
<h2 id='simulate.lme'>Simulate Results from <code>lme</code> Models</h2><span id='topic+simulate.lme'></span><span id='topic+plot.simulate.lme'></span><span id='topic+print.simulate.lme'></span>

<h3>Description</h3>

<p>The model <code>object</code> is fit to the data.  Using
the fitted values of the parameters, <code>nsim</code> new data vectors from
this model are simulated.  Both <code>object</code> and <code>m2</code> are fit by
maximum likelihood (ML) and/or by restricted maximum likelihood (REML)
to each of the simulated data vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
simulate(object, nsim = 1, seed = , m2,
         method = c("REML", "ML"), niterEM = c(40, 200), useGen, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.lme_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing a fitted
linear mixed-effects model, or a list containing an <code>lme</code> model
specification.  If given as a list, it should contain
components <code>fixed</code>, <code>data</code>, and <code>random</code>
with values suitable for a call to <code><a href="#topic+lme">lme</a></code>.  This argument
defines the null model.
</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_m2">m2</code></td>
<td>
<p>an <code>"<a href="#topic+lme">lme</a>"</code> object or a list, like <code>object</code>
containing a second lme model specification.  This argument defines
the alternative model.  If given as a list, only those parts of the
specification that change between model <code>object</code> and <code>m2</code>
need to be specified.</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_seed">seed</code></td>
<td>

<p>an optional integer that is passed to <code>set.seed</code>.  Defaults to
a random integer.
</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_method">method</code></td>
<td>
<p>an optional character array.  If it includes
<code>"REML"</code> the models are fit by maximizing the restricted
log-likelihood.  If it includes <code>"ML"</code> the log-likelihood is
maximized.  Defaults to <code>c("REML", "ML")</code>, in which case both
methods are used.</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_nsim">nsim</code></td>
<td>
<p>an optional positive integer specifying the number of
simulations to perform.  Defaults to <code>1</code>. <b>This has
changed.  Previously the default was 1000.</b>
</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_niterem">niterEM</code></td>
<td>
<p>an optional integer vector of length 2 giving the number of
iterations of the EM algorithm to apply when fitting the <code>object</code>
and <code>m2</code> to each simulated set of data.  Defaults to <code>c(40,200)</code>.
</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_usegen">useGen</code></td>
<td>

<p>an optional logical value.  If <code>TRUE</code>, the <code><a href="stats.html#topic+nlminb">nlminb</a></code>
optimizer is used with numerical derivatives of the log-likelihood. If
<code>FALSE</code>, the <code><a href="stats.html#topic+nlm">nlm</a></code> algorithm is used with an
analytic gradient.  The default
depends on the <code>"<a href="#topic+pdMat">pdMat</a>"</code> classes used in <code>object</code> and <code>m2</code>:
if both are standard classes (see <code><a href="#topic+pdClasses">pdClasses</a></code>) then
defaults to <code>FALSE</code>, otherwise defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="simulate.lme_+3A_...">...</code></td>
<td>
<p>optional additional arguments.  None are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>simulate.lme</code> with components <code>null</code> and
<code>alt</code>.  Each of these has components <code>ML</code> and/or <code>REML</code>
which are matrices.  An attribute called <code>seed</code> contains
the seed that was used for the random number generator.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000)
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="base.html#topic+set.seed">set.seed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
orthSim &lt;-
   simulate.lme(list(fixed = distance ~ age, data = Orthodont,
                     random = ~ 1 | Subject), nsim = 200,
                m2 = list(random = ~ age | Subject))

</code></pre>

<hr>
<h2 id='solve.pdMat'>Calculate Inverse of a Positive-Definite Matrix</h2><span id='topic+solve.pdMat'></span><span id='topic+solve.pdBlocked'></span><span id='topic+solve.pdDiag'></span><span id='topic+solve.pdIdent'></span><span id='topic+solve.pdLogChol'></span><span id='topic+solve.pdNatural'></span><span id='topic+solve.pdSymm'></span>

<h3>Description</h3>

<p>The positive-definite matrix represented by <code>a</code> is inverted and
assigned to <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve.pdMat_+3A_a">a</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>, representing
a positive definite matrix.</p>
</td></tr> 
<tr><td><code id="solve.pdMat_+3A_b">b</code></td>
<td>
<p>this argument is only included for consistency with the generic
function and is not used in this method function.</p>
</td></tr>
<tr><td><code id="solve.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>pdMat</code> object similar to <code>a</code>, but with coefficients
corresponding to the inverse of the positive-definite matrix
represented by <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pd1 &lt;- pdCompSymm(3 * diag(3) + 1)
solve(pd1)
</code></pre>

<hr>
<h2 id='solve.reStruct'>Apply Solve to an reStruct Object</h2><span id='topic+solve.reStruct'></span>

<h3>Description</h3>

<p><code>Solve</code> is applied to each <code>pdMat</code> component of <code>a</code>,
which results in inverting the positive-definite matrices they
represent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reStruct'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve.reStruct_+3A_a">a</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+reStruct">reStruct</a>"</code>,
representing a random effects structure and consisting of a list of
<code>pdMat</code> objects.</p>
</td></tr> 
<tr><td><code id="solve.reStruct_+3A_b">b</code></td>
<td>
<p>this argument is only included for consistency with the
generic function and is not used in this method function.</p>
</td></tr>
<tr><td><code id="solve.reStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an <code>reStruct</code> object similar to <code>a</code>, but with the
<code>pdMat</code> components representing the inverses of the
matrices represented by the components of <code>a</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+solve.pdMat">solve.pdMat</a></code>, <code><a href="#topic+reStruct">reStruct</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rs1 &lt;- reStruct(list(A = pdSymm(diag(1:3), form = ~Score),
  B = pdDiag(2 * diag(4), form = ~Educ)))
solve(rs1)
</code></pre>

<hr>
<h2 id='Soybean'>Growth of soybean plants</h2><span id='topic+Soybean'></span>

<h3>Description</h3>

<p>The <code>Soybean</code> data frame has 412 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Plot</dt><dd>
<p>a factor giving a unique identifier for each plot.
</p>
</dd>
<dt>Variety</dt><dd>
<p>a factor indicating the variety; Forrest (F) or Plant
Introduction #416937 (P).
</p>
</dd>
<dt>Year</dt><dd>
<p>a factor indicating the year the plot was planted.
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector giving the time the sample was taken (days
after planting).
</p>
</dd>
<dt>weight</dt><dd>
<p>a numeric vector giving the average leaf weight per plant (g).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are described in
Davidian and Giltinan (1995, 1.1.3, p.7) as &ldquo;Data from an
experiment to compare growth patterns of two genotypes of soybeans:
Plant Introduction #416937 (P), an experimental strain, and Forrest
(F), a commercial variety.&rdquo;
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.27)
</p>
<p>Davidian, M. and Giltinan, D. M. (1995), <em>Nonlinear Models for
Repeated Measurement Data</em>,  Chapman and Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(fm1 &lt;- nlsList(SSlogis, data = Soybean))
</code></pre>

<hr>
<h2 id='splitFormula'>Split a Formula</h2><span id='topic+splitFormula'></span>

<h3>Description</h3>

<p>Splits the right hand side of <code>form</code> into a list of subformulas
according to the presence of <code>sep</code>. The left hand side of
<code>form</code>, if present, will be ignored. The length of the returned
list will be equal to the number of occurrences of <code>sep</code> in
<code>form</code> plus one. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitFormula(form, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitFormula_+3A_form">form</code></td>
<td>
<p>a <code>formula</code> object.</p>
</td></tr>
<tr><td><code id="splitFormula_+3A_sep">sep</code></td>
<td>
<p>an optional character string specifying the separator to be
used for splitting the formula. Defaults to <code>"/"</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of formulas, corresponding to the split of <code>form</code>
according to <code>sep</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>splitFormula(~ g1/g2/g3)
</code></pre>

<hr>
<h2 id='Spruce'>Growth of Spruce Trees</h2><span id='topic+Spruce'></span>

<h3>Description</h3>

<p>The <code>Spruce</code> data frame has 1027 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Tree</dt><dd>
<p>a factor giving a unique identifier for each tree.
</p>
</dd>
<dt>days</dt><dd>
<p>a numeric vector giving the number of days since the
beginning of the experiment.
</p>
</dd>
<dt>logSize</dt><dd>
<p>a numeric vector giving the logarithm of an estimate of the
volume of the tree trunk.
</p>
</dd>
<dt>plot</dt><dd>
<p>a factor identifying the plot in which the tree was grown.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Diggle, Liang, and Zeger (1994, Example 1.3, page 5)
describe data on the growth of spruce trees that have been exposed to
an ozone-rich atmosphere or to a normal atmosphere.
</p>


<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.  (Appendix A.28)
</p>
<p>Diggle, Peter J., Liang, Kung-Yee and Zeger, Scott L. (1994),
<em>Analysis of longitudinal data</em>, Oxford University Press,
Oxford.
</p>

<hr>
<h2 id='summary.corStruct'>Summarize a corStruct Object</h2><span id='topic+summary.corStruct'></span><span id='topic+summary.corAR1'></span><span id='topic+summary.corARMA'></span><span id='topic+summary.corCAR1'></span><span id='topic+summary.corCompSymm'></span><span id='topic+summary.corExp'></span><span id='topic+summary.corGaus'></span><span id='topic+summary.corLin'></span><span id='topic+summary.corNatural'></span><span id='topic+summary.corRatio'></span><span id='topic+summary.corSpher'></span><span id='topic+summary.corSymm'></span>

<h3>Description</h3>

<p>This method function prepares <code>object</code> to be printed using the
<code>print.summary</code> method, by changing its class and adding a
<code>structName</code> attribute to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corStruct'
summary(object, structName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.corStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corStruct">corStruct</a>"</code>,
representing a correlation structure.</p>
</td></tr>
<tr><td><code id="summary.corStruct_+3A_structname">structName</code></td>
<td>
<p>an optional character string defining the type of
correlation structure associated with <code>object</code>, to be used in
the <code>print.summary</code> method. Defaults to
<code>class(object)[1]</code>.</p>
</td></tr>
<tr><td><code id="summary.corStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object identical to <code>object</code>, but with its class changed to
<code>summary.corStruct</code> and an additional attribute
<code>structName</code>. The returned value inherits from the same classes
as <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates </p>


<h3>See Also</h3>

<p><code><a href="#topic+corClasses">corClasses</a></code>,
<code><a href="#topic+corNatural">corNatural</a></code>,
<code><a href="#topic+Initialize.corStruct">Initialize.corStruct</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corAR1(0.2)
summary(cs1)
</code></pre>

<hr>
<h2 id='summary.gls'>Summarize a Generalized Least Squares <code>gls</code> Object</h2><span id='topic+summary.gls'></span>

<h3>Description</h3>

<p>Additional information about the linear model fit represented
by <code>object</code> is extracted and included as components of
<code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
summary(object, verbose, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted linear model.</p>
</td></tr>
<tr><td><code id="summary.gls_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value used to control the amount of
output when the object is printed. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from class <code>summary.gls</code> with all components
included in <code>object</code> (see <code><a href="#topic+glsObject">glsObject</a></code> for a full
description of the components) plus the following components:
</p>
<table>
<tr><td><code>corBeta</code></td>
<td>
<p>approximate correlation matrix for the coefficients
estimates</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>a matrix with columns <code>Value</code>,
<code>Std. Error</code>, <code>t-value</code>, and <code>p-value</code> representing
respectively the coefficients estimates, their approximate standard
errors, the ratios between the estimates and their standard errors,
and the associated p-value under a <code class="reqn">t</code> approximation.  Rows
correspond to the different coefficients.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>if more than five observations are used in the
<code>gls</code> fit, a vector with the minimum, first quartile, median, third
quartile, and maximum of the residuals distribution; else the
residuals.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion corresponding to
<code>object</code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion corresponding to
<code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>,
<code><a href="stats.html#topic+BIC">BIC</a></code>,
<code><a href="#topic+gls">gls</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
           correlation = corAR1(form = ~ 1 | Mare))
summary(fm1)
coef(summary(fm1)) # "the matrix"
</code></pre>

<hr>
<h2 id='summary.lme'>Summarize an lme Object</h2><span id='topic+summary.lme'></span><span id='topic+print.summary.lme'></span>

<h3>Description</h3>

<p>Additional information about the linear mixed-effects fit represented
by <code>object</code> is extracted and included as components of
<code>object</code>.  The returned object has a <code><a href="base.html#topic+print">print</a></code> and a
<code><a href="stats.html#topic+coef">coef</a></code> method, the latter returning the coefficient's
<code>tTtable</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
summary(object, adjustSigma, verbose, ...)
## S3 method for class 'summary.lme'
print(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="summary.lme_+3A_adjustsigma">adjustSigma</code></td>
<td>
<p>an optional logical value.  If <code>TRUE</code> and the
estimation method used to obtain <code>object</code> was maximum
likelihood, the residual standard error is multiplied by
<code class="reqn">\sqrt{n_{obs}/(n_{obs} - n_{par})}</code>,
converting it to a REML-like estimate.  This argument is only used
when a single fitted object is passed to the function.  Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.lme_+3A_verbose">verbose</code></td>
<td>
<p>an optional logical value used to control the amount of
output in the <code>print.summary.lme</code> method.  Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.lme_+3A_...">...</code></td>
<td>
<p>additional optional arguments passed to methods, mainly
for the <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
<tr><td><code id="summary.lme_+3A_x">x</code></td>
<td>
<p>a <code>"summary.lme"</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object inheriting from class <code>summary.lme</code> with all components
included in <code>object</code> (see <code><a href="#topic+lmeObject">lmeObject</a></code> for a full
description of the components) plus the following components:
</p>
<table>
<tr><td><code>corFixed</code></td>
<td>
<p>approximate correlation matrix for the fixed effects
estimates.</p>
</td></tr>
<tr><td><code>tTable</code></td>
<td>
<p>a matrix with columns named <code>Value</code>,
<code>Std. Error</code>, <code>DF</code>, <code>t-value</code>, and <code>p-value</code>
representing respectively the fixed effects estimates, their
approximate standard errors, the denominator degrees of freedom, the
ratios between the estimates and their standard errors, and the
associated p-value from a t distribution.  Rows correspond to the
different fixed effects.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>if more than five observations are used in the
<code>lme</code> fit, a vector with the minimum, first quartile, median, third
quartile, and maximum of the innermost grouping level residuals
distribution; else the innermost grouping level residuals.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion corresponding to
<code>object</code>.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian Information Criterion corresponding to
<code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+BIC">BIC</a></code>,
<code><a href="#topic+lme">lme</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, Orthodont, random = ~ age | Subject)
(s1 &lt;- summary(fm1))
coef(s1) # the (coef | Std.E | t | P-v ) matrix

</code></pre>

<hr>
<h2 id='summary.lmList'>Summarize an lmList Object</h2><span id='topic+summary.lmList'></span>

<h3>Description</h3>

<p>The <code>summary.lm</code> method is applied to each <code>lm</code> component of
<code>object</code> to produce summary information on the individual fits,
which is organized into a list of summary statistics. The returned
object is suitable for printing with the <code>print.summary.lmList</code>
method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmList'
summary(object, pool, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmList">lmList</a>"</code>, representing
a list of <code>lm</code> fitted objects.
</p>
</td></tr>
<tr><td><code id="summary.lmList_+3A_pool">pool</code></td>
<td>
<p>an optional logical value indicating whether a pooled
estimate of the residual standard error should be used. Default is
<code>attr(object, "pool")</code>.
</p>
</td></tr>
<tr><td><code id="summary.lmList_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with summary statistics obtained by applying <code>summary.lm</code>
to the elements of <code>object</code>, inheriting from class
<code>summary.lmList</code>. The components of <code>value</code> are:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>lmList</code> call that
produced <code>object</code>.
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a three dimensional array with summary information
on the <code>lm</code> coefficients. The first dimension corresponds to
the names of the <code>object</code> components, the second dimension is
given by   <code>"Value"</code>, <code>"Std. Error"</code>, <code>"t value"</code>,
and <code>"Pr(&gt;|t|)"</code>, corresponding, respectively, to the
coefficient estimates and their associated standard errors,
t-values, and p-values. The third dimension is given by the
coefficients names.
</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>a three dimensional array with the 
correlations between the individual <code>lm</code> coefficient
estimates. The first dimension corresponds to the names of the
<code>object</code> components. The third dimension is given by the
coefficients names. For each coefficient, the rows of the associated
array give the correlations between that coefficient and the
remaining coefficients, by <code>lm</code> component.
</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a three dimensional array with the unscaled
variances/covariances for the individual <code>lm</code> coefficient
estimates (giving the estimated variance/covariance for the
coefficients, when multiplied by the estimated residual errors). The
first dimension corresponds to the names of the <code>object</code>
components. The third dimension is given by the
coefficients names. For each coefficient, the rows of the associated
array give the unscaled covariances between that coefficient and the
remaining coefficients, by <code>lm</code> component.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>an array with the number of degrees of freedom for the model
and for residuals, for each <code>lm</code> component.
</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the total number of degrees of freedom for
residuals, corresponding to the sum of residuals df of all <code>lm</code>
components.
</p>
</td></tr>
<tr><td><code>fstatistics</code></td>
<td>
<p>an array with the F test statistics and
corresponding degrees of freedom, for each <code>lm</code> component.
</p>
</td></tr>
<tr><td><code>pool</code></td>
<td>
<p>the value of the <code>pool</code> argument to the function.
</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>a vector with the multiple R-squared statistics for
each <code>lm</code> component.
</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a list with components given by the residuals from
individual <code>lm</code> fits.
</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>the pooled estimate of the residual standard error.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector with the residual standard error estimates for
the individual <code>lm</code> fits.
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used in fitting the individual <code>lm</code>
components.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmList">lmList</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lmList(distance ~ age | Subject, Orthodont)
summary(fm1)
</code></pre>

<hr>
<h2 id='summary.modelStruct'>Summarize a modelStruct Object</h2><span id='topic+summary.modelStruct'></span><span id='topic+summary.reStruct'></span>

<h3>Description</h3>

<p>This method function applies <code>summary</code> to each element of
<code>object</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelStruct'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.modelStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"modelStruct"</code>,
representing a list of model components, such as <code>reStruct</code>,
<code>corStruct</code> and <code>varFunc</code> objects.
</p>
</td></tr>
<tr><td><code id="summary.modelStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a list with elements given by the summarized components of
<code>object</code>. The returned value is of class
<code>summary.modelStruct</code>, also inheriting from the same classes as
<code>object</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lms1 &lt;- lmeStruct(reStruct = reStruct(pdDiag(diag(2), ~age)),
   corStruct = corAR1(0.3))
summary(lms1)
</code></pre>

<hr>
<h2 id='summary.nlsList'>Summarize an nlsList Object</h2><span id='topic+summary.nlsList'></span>

<h3>Description</h3>

<p>The <code>summary</code> function is applied to each <code>nls</code> component of
<code>object</code> to produce summary information on the individual fits,
which is organized into a list of summary statistics. The returned
object is suitable for printing with the <code>print.summary.nlsList</code>
method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsList'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.nlsList_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+nlsList">nlsList</a>"</code>,
representing a list of <code>nls</code> fitted objects.
</p>
</td></tr>
<tr><td><code id="summary.nlsList_+3A_...">...</code></td>
<td>
<p>optional arguments to the <code>summary.lmList</code> method.
One such optional argument is <code>pool</code>, a logical value indicating
whether a pooled estimate of the residual standard error should be
used. Default is <code>attr(object, "pool")</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with summary statistics obtained by applying <code>summary</code>
to the elements of <code>object</code>, inheriting from class
<code>summary.nlsList</code>. The components of <code>value</code> are:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>a list containing an image of the <code>nlsList</code> call that
produced <code>object</code>.
</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a three dimensional array with summary information
on the <code>nls</code> coefficients. The first dimension corresponds to
the names of the <code>object</code> components, the second dimension is
given by   <code>"Value"</code>, <code>"Std. Error"</code>, <code>"t value"</code>,
and <code>"Pr(&gt;|t|)"</code>, corresponding, respectively, to the
coefficient estimates and their associated standard errors,
t-values, and p-values. The third dimension is given by the
coefficients names.
</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>a three dimensional array with the 
correlations between the individual <code>nls</code> coefficient
estimates. The first dimension corresponds to the names of the
<code>object</code> components. The third dimension is given by the
coefficients names. For each coefficient, the rows of the associated
array give the correlations between that coefficient and the
remaining coefficients, by <code>nls</code> component.
</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a three dimensional array with the unscaled
variances/covariances for the individual <code>lm</code> coefficient
estimates (giving the estimated variance/covariance for the
coefficients, when multiplied by the estimated residual errors). The
first dimension corresponds to the names of the <code>object</code>
components. The third dimension is given by the
coefficients names. For each coefficient, the rows of the associated
array give the unscaled covariances between that coefficient and the
remaining coefficients, by <code>nls</code> component.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>an array with the number of degrees of freedom for the model
and for residuals, for each <code>nls</code> component.
</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the total number of degrees of freedom for
residuals, corresponding to the sum of residuals df of all <code>nls</code>
components.
</p>
</td></tr>
<tr><td><code>pool</code></td>
<td>
<p>the value of the <code>pool</code> argument to the function.
</p>
</td></tr>
<tr><td><code>RSE</code></td>
<td>
<p>the pooled estimate of the residual standard error.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector with the residual standard error estimates for
the individual <code>lm</code> fits.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+nlsList">nlsList</a></code>, <code><a href="base.html#topic+summary">summary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- nlsList(SSasymp, Loblolly)
summary(fm1)
</code></pre>

<hr>
<h2 id='summary.pdMat'>Summarize a pdMat Object</h2><span id='topic+summary.pdMat'></span><span id='topic+summary.pdBlocked'></span><span id='topic+summary.pdCompSymm'></span><span id='topic+summary.pdDiag'></span><span id='topic+summary.pdIdent'></span><span id='topic+summary.pdNatural'></span><span id='topic+summary.pdSymm'></span><span id='topic+summary.pdLogChol'></span>

<h3>Description</h3>

<p>Attributes <code>structName</code> and <code>noCorrelation</code>, with the values
of the corresponding arguments to the method function, are appended to
<code>object</code> and its class is changed to <code>summary.pdMat</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdMat'
summary(object, structName, noCorrelation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pdMat_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+pdMat">pdMat</a>"</code>, representing
a positive definite matrix.</p>
</td></tr> 
<tr><td><code id="summary.pdMat_+3A_structname">structName</code></td>
<td>
<p>an optional character string with a description of
the <code>pdMat</code> class. Default depends on the method function:
<code>"Blocked"</code> for <code>pdBlocked</code>,
<code>"Compound Symmetry"</code> for <code>pdCompSymm</code>, <code>"Diagonal"</code>
for <code>pdDiag</code>, <code>"Multiple of an Identity"</code> for
<code>pdIdent</code>,
<code>"General Positive-Definite, Natural Parametrization"</code>
for <code>pdNatural</code>, <code>"General Positive-Definite"</code>
for <code>pdSymm</code>, and <code>data.class(object)</code> for <code>pdMat</code>.</p>
</td></tr>
<tr><td><code id="summary.pdMat_+3A_nocorrelation">noCorrelation</code></td>
<td>
<p>an optional logical value indicating whether
correlations are to be printed in <code>print.summary.pdMat</code>. Default
depends on the method function: <code>FALSE</code> for <code>pdDiag</code> and
<code>pdIdent</code>, and <code>TRUE</code> for all other classes.</p>
</td></tr>
<tr><td><code id="summary.pdMat_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object similar to <code>object</code>, with additional attributes
<code>structName</code> and <code>noCorrelation</code>, inheriting from class
<code>summary.pdMat</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+print.summary.pdMat">print.summary.pdMat</a></code>,
<code><a href="#topic+pdMat">pdMat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(pdSymm(diag(4)))
</code></pre>

<hr>
<h2 id='summary.varFunc'>Summarize &quot;varFunc&quot; Object</h2><span id='topic+summary.varFunc'></span><span id='topic+summary.varComb'></span><span id='topic+summary.varConstPower'></span><span id='topic+summary.varConstProp'></span><span id='topic+summary.varExp'></span><span id='topic+summary.varFixed'></span><span id='topic+summary.varIdent'></span><span id='topic+summary.varPower'></span>

<h3>Description</h3>

<p>A <code>structName</code> attribute, with the value of corresponding
argument, is appended to <code>object</code> and its class is changed to
<code>summary.varFunc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
summary(object, structName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr>
<tr><td><code id="summary.varFunc_+3A_structname">structName</code></td>
<td>
<p>an optional character string with a description of
the <code>varFunc</code> class.  Default depends on the method function:
</p>

<dl>
<dt>for <code>varComb</code>:</dt><dd><p><code>"Combination of variance functions"</code>,</p>
</dd>
<dt>for <code>varConstPower</code>:</dt><dd><p><code>"Constant plus power of variance covariate"</code>,</p>
</dd>
<dt>for <code>varConstProp</code>:</dt><dd><p><code>"Constant plus proportion of variance covariate"</code>,</p>
</dd>
<dt>for <code>varExp</code>:</dt><dd><p><code>"Exponential of variance covariate"</code>,</p>
</dd>
<dt>for <code>varIdent</code>:</dt><dd><p><code>"Different standard deviations per stratum"</code>,</p>
</dd>
<dt>for <code>varPower</code>:</dt><dd><p><code>"Power of variance covariate"</code>,</p>
</dd>
<dt>for <code>varFunc</code>:</dt><dd><p><code>data.class(object)</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="summary.varFunc_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object similar to <code>object</code>, with an additional attribute
<code>structName</code>, inheriting from class <code>summary.varFunc</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(0.3, form = ~age)
vf1 &lt;- Initialize(vf1, Orthodont)
summary(vf1)
</code></pre>

<hr>
<h2 id='Tetracycline1'>Pharmacokinetics of tetracycline</h2><span id='topic+Tetracycline1'></span>

<h3>Description</h3>

<p>The <code>Tetracycline1</code> data frame has 40 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>conc</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor with levels
<code>5</code> &lt; <code>3</code> &lt; <code>2</code> &lt; <code>4</code> &lt; <code>1</code>
</p>
</dd>
<dt>Formulation</dt><dd>
<p>a factor with levels
<code>tetrachel</code> 
<code>tetracyn</code> 
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='Tetracycline2'>Pharmacokinetics of tetracycline</h2><span id='topic+Tetracycline2'></span>

<h3>Description</h3>

<p>The <code>Tetracycline2</code> data frame has 40 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>conc</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Time</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>Subject</dt><dd>
<p>an ordered factor with levels
<code>4</code> &lt; <code>5</code> &lt; <code>2</code> &lt; <code>1</code> &lt; <code>3</code>
</p>
</dd>
<dt>Formulation</dt><dd>
<p>a factor with levels
<code>Berkmycin</code> 
<code>tetramycin</code> 
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='update.modelStruct'>Update a modelStruct Object</h2><span id='topic+update.modelStruct'></span><span id='topic+update.corStruct'></span><span id='topic+update.reStruct'></span>

<h3>Description</h3>

<p>This method function updates each element of <code>object</code>, allowing
the access to <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelStruct'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.modelStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"modelStruct"</code>,
representing a list of model components, such as <code>corStruct</code> and
<code>varFunc</code> objects.</p>
</td></tr>
<tr><td><code id="update.modelStruct_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate the variables needed for
updating the elements of <code>object</code>.</p>
</td></tr>
<tr><td><code id="update.modelStruct_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object similar to <code>object</code> (same class, length, and names),
but with updated elements.
</p>


<h3>Note</h3>

<p>This method function is primarily used within model fitting
functions, such as <code>lme</code> and <code>gls</code>, that allow model
components such as variance functions.</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reStruct">reStruct</a></code>
</p>

<hr>
<h2 id='update.varFunc'>Update varFunc Object</h2><span id='topic+update.varExp'></span><span id='topic+update.varFunc'></span><span id='topic+update.varComb'></span><span id='topic+update.varConstPower'></span><span id='topic+update.varConstProp'></span><span id='topic+update.varExpon'></span><span id='topic+update.varPower'></span>

<h3>Description</h3>

<p>If the <code>formula(object)</code> includes a <code>"."</code> term, representing
a fitted object, the variance covariate needs to be updated upon
completion of an optimization cycle (in which the variance function
weights are kept fixed). This method function allows a reevaluation of
the variance covariate using the current fitted object and,
optionally, other variables in the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varFunc'
update(object, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.varFunc_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+varFunc">varFunc</a>"</code>,
representing a variance function structure.</p>
</td></tr> 
<tr><td><code id="update.varFunc_+3A_data">data</code></td>
<td>
<p>a list with a component named <code>"."</code> with the current
version of the fitted object (from which fitted values, coefficients,
and residuals can be extracted) and, if necessary, other variables
used to evaluate the variance covariate(s).</p>
</td></tr>
<tr><td><code id="update.varFunc_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>formula(object)</code> includes a <code>"."</code> term, an
<code>varFunc</code> object similar to <code>object</code>, but with the 
variance covariate reevaluated at the current fitted object value;
else <code>object</code> is returned unchanged.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+needUpdate">needUpdate</a></code>,
<code><a href="#topic+covariate+3C-.varFunc">covariate&lt;-.varFunc</a></code>
</p>

<hr>
<h2 id='varClasses'>Variance Function Classes</h2><span id='topic+varClasses'></span>

<h3>Description</h3>

<p>Standard classes of variance function structures (<code>varFunc</code>) 
available in the <code>nlme</code> package. Covariates included in the
variance function, denoted by variance covariates, may involve
functions of the fitted model object, such as the fitted values and
the residuals. Different coefficients may be assigned to the levels of
a classification factor.
</p>


<h3>Value</h3>

<p>Available standard classes:
</p>
<table>
<tr><td><code>varExp</code></td>
<td>
<p>exponential of a variance covariate.</p>
</td></tr>
<tr><td><code>varPower</code></td>
<td>
<p>power of a variance covariate.</p>
</td></tr>
<tr><td><code>varConstPower</code></td>
<td>
<p>constant plus power of a variance covariate.</p>
</td></tr>
<tr><td><code>varConstProp</code></td>
<td>
<p>constant plus proportion of a variance covariate.</p>
</td></tr>
<tr><td><code>varIdent</code></td>
<td>
<p>constant variance(s), generally used to allow
different variances according to the levels of a classification
factor.</p>
</td></tr> 
<tr><td><code>varFixed</code></td>
<td>
<p>fixed weights, determined by a variance covariate.</p>
</td></tr>
<tr><td><code>varComb</code></td>
<td>
<p>combination of variance functions.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Users may define their own <code>varFunc</code> classes by specifying a
<code>constructor</code> function and, at a minimum, methods for the
functions <code>coef</code>, <code>coef&lt;-</code>, and <code>initialize</code>. For
examples of these functions, see the methods for class
<code>varPower</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varComb">varComb</a></code>,
<code><a href="#topic+varConstPower">varConstPower</a></code>,
<code><a href="#topic+varConstProp">varConstProp</a></code>,
<code><a href="#topic+varExp">varExp</a></code>,
<code><a href="#topic+varFixed">varFixed</a></code>,
<code><a href="#topic+varIdent">varIdent</a></code>,
<code><a href="#topic+varPower">varPower</a></code>,
<code><a href="#topic+summary.varFunc">summary.varFunc</a></code>
</p>

<hr>
<h2 id='varComb'>Combination of Variance Functions</h2><span id='topic+varComb'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varComb</code> class,
representing a combination of variance functions. The corresponding
variance function is equal to the product of the variance functions of
the <code>varFunc</code> objects listed in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varComb(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varComb_+3A_...">...</code></td>
<td>
<p>objects inheriting from class <code>varFunc</code> representing
variance function structures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varComb</code> object representing a combination of variance
functions, also inheriting from class <code>varFunc</code>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varComb">varWeights.varComb</a></code>,
<code><a href="#topic+coef.varComb">coef.varComb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varComb(varIdent(form = ~1|Sex), varPower())
</code></pre>

<hr>
<h2 id='varConstPower'>Constant Plus Power Variance Function</h2><span id='topic+varConstPower'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varConstPower</code> class,
representing a constant plus power variance function
structure. Letting <code class="reqn">v</code> denote the variance covariate and
<code class="reqn">\sigma^2(v)</code> denote the variance function evaluated at
<code class="reqn">v</code>, the constant plus power variance function is defined as
<code class="reqn">\sigma^2(v) = (\theta_1 + |v|^\theta_2)^2</code>, where <code class="reqn">\theta_1,\theta_2</code> are the variance  
function coefficients. When a grouping factor is present, different
<code class="reqn">\theta_1,\theta_2</code> are used for each factor level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varConstPower(const, power, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varConstPower_+3A_const">const</code>, <code id="varConstPower_+3A_power">power</code></td>
<td>
<p>optional numeric vectors, or lists of numeric
values, with, respectively, the coefficients for the constant 
and the power terms. Both arguments must have length one, unless a
grouping factor is specified in <code>form</code>. If either argument has
length greater than one, it must have names which identify its
elements to the levels of the grouping factor defined in
<code>form</code>. If a grouping factor is present in 
<code>form</code> and the argument has length one, its value will be
assigned to all grouping levels. Only positive values are allowed
for <code>const</code>. Default is <code>numeric(0)</code>, which
results in a vector of zeros of appropriate length being assigned to
the coefficients when <code>object</code> is initialized (corresponding
to constant variance equal to one).</p>
</td></tr>
<tr><td><code id="varConstPower_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula of the form <code>~ v</code>, or
<code>~ v | g</code>, specifying a variance covariate <code>v</code> and,
optionally, a grouping factor <code>g</code> for the coefficients. The
variance covariate must evaluate to a numeric vector and may involve
expressions using <code>"."</code>, representing  a fitted model object
from which fitted values (<code>fitted(.)</code>) and residuals
(<code>resid(.)</code>) can be extracted (this allows the variance
covariate to be updated during the optimization of an object
function). When a grouping factor is present in <code>form</code>,
a different coefficient value is used for each of its
levels. Several grouping variables may be
simultaneously specified, separated by the <code>*</code> operator, as
in <code>~ v | g1 * g2 * g3</code>. In this case, the levels of each
grouping variable are pasted together and the resulting factor is
used to group the observations. Defaults to <code>~ fitted(.)</code>
representing a variance covariate given by the fitted values of a
fitted model object and no grouping factor. </p>
</td></tr>
<tr><td><code id="varConstPower_+3A_fixed">fixed</code></td>
<td>
<p>an optional list with components <code>const</code> and/or
<code>power</code>, consisting of numeric vectors, or lists of numeric
values, specifying the values at which some or all of the
coefficients in the variance function should be fixed. If a grouping
factor is specified in <code>form</code>, the components of <code>fixed</code>
must have names identifying which coefficients are to be
fixed. Coefficients included in <code>fixed</code> are not allowed to vary
during the optimization of an objective function. Defaults to
<code>NULL</code>, corresponding to no fixed coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varConstPower</code> object representing a constant plus power
variance function structure, also inheriting from class
<code>varFunc</code>.  
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varConstPower">coef.varConstPower</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varConstPower(1.2, 0.2, form = ~age|Sex)
</code></pre>

<hr>
<h2 id='varConstProp'>Constant Plus Proportion Variance Function</h2><span id='topic+varConstProp'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varConstProp</code> class,
representing a variance function structure corresponding to
a two-component error model (additive and proportional error). Letting
<code class="reqn">v</code> denote the variance covariate and <code class="reqn">\sigma^2(v)</code>
denote the variance function evaluated at <code class="reqn">v</code>, the two-component variance
function is defined as
<code class="reqn">\sigma^2(v) = a^2 + b^2 * v^{2}</code>, where a is
the additive component and b is the relative error component.  In order
to avoid overparameterisation of the model, it is recommended to use
the possibility to fix sigma, preferably to a value of 1 (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varConstProp(const, prop, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varConstProp_+3A_const">const</code>, <code id="varConstProp_+3A_prop">prop</code></td>
<td>
<p>optional numeric vectors, or lists of numeric
values, with, respectively, the coefficients for the constant
and the proportional error terms. Both arguments must have length one,
unless a grouping factor is specified in <code>form</code>. If either argument
has length greater than one, it must have names which identify its
elements to the levels of the grouping factor defined in
<code>form</code>. If a grouping factor is present in
<code>form</code> and the argument has length one, its value will be
assigned to all grouping levels. Only positive values are allowed
for <code>const</code>. Default is 0.1 for both <code>const</code> and
<code>prop</code>. </p>
</td></tr>
<tr><td><code id="varConstProp_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula of the form <code>~ v</code>, or
<code>~ v | g</code>, specifying a variance covariate <code>v</code> and,
optionally, a grouping factor <code>g</code> for the coefficients. The
variance covariate must evaluate to a numeric vector and may involve
expressions using <code>"."</code>, representing  a fitted model object
from which fitted values (<code>fitted(.)</code>) and residuals
(<code>resid(.)</code>) can be extracted (this allows the variance
covariate to be updated during the optimization of an object
function). When a grouping factor is present in <code>form</code>,
a different coefficient value is used for each of its
levels. Several grouping variables may be
simultaneously specified, separated by the <code>*</code> operator, as
in <code>~ v | g1 * g2 * g3</code>. In this case, the levels of each
grouping variable are pasted together and the resulting factor is
used to group the observations. Defaults to <code>~ fitted(.)</code>
representing a variance covariate given by the fitted values of a
fitted model object and no grouping factor. </p>
</td></tr>
<tr><td><code id="varConstProp_+3A_fixed">fixed</code></td>
<td>
<p>an optional list with components <code>const</code> and/or
<code>power</code>, consisting of numeric vectors, or lists of numeric
values, specifying the values at which some or all of the
coefficients in the variance function should be fixed. If a grouping
factor is specified in <code>form</code>, the components of <code>fixed</code>
must have names identifying which coefficients are to be
fixed. Coefficients included in <code>fixed</code> are not allowed to vary
during the optimization of an objective function. Defaults to
<code>NULL</code>, corresponding to no fixed coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varConstProp</code> object representing a constant plus proportion variance
function structure, also inheriting from class <code>varFunc</code>.
</p>


<h3>Note</h3>

<p>The error model underlying this variance function structure can be understood
to result from two uncorrelated sequences of standardized random variables
(Lavielle(2015), p. 55) and has been proposed for use in analytical chemistry
(Werner et al. (1978), Wilson et al. (2004)) and chemical degradation
kinetics (Ranke and Meinecke (2019)).  Note that the two-component error
model proposed by Rocke and Lorenzato (1995) assumed a log-normal
distribution of residuals at high absolute values, which is not
compatible with the <code><a href="#topic+varFunc">varFunc</a></code> structures in package <span class="pkg">nlme</span>.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates (for <code><a href="#topic+varConstPower">varConstPower</a></code>) and
Johannes Ranke (adaptation to <code>varConstProp()</code>).
</p>


<h3>References</h3>

<p>Lavielle, M. (2015)
<em>Mixed Effects Models for the Population Approach: Models, Tasks,
Methods and Tools</em>, Chapman and Hall/CRC.
<a href="https://doi.org/10.1201/b17203">doi:10.1201/b17203</a>
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000)
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer.
<a href="https://doi.org/10.1007/b98882">doi:10.1007/b98882</a>
</p>
<p>Ranke, J., and Meinecke, S. (2019)
Error Models for the Kinetic Evaluation of Chemical Degradation Data.
<em>Environments</em> <b>6</b>(12), 124
<a href="https://doi.org/10.3390/environments6120124">doi:10.3390/environments6120124</a>
</p>
<p>Rocke, David M. and Lorenzato, Stefan (1995)
A Two-Component Model for Measurement Error in Analytical Chemistry.
<em>Technometrics</em> <b>37</b>(2), 176&ndash;184.
<a href="https://doi.org/10.1080/00401706.1995.10484302">doi:10.1080/00401706.1995.10484302</a>
</p>
<p>Werner, Mario, Brooks, Samuel H., and Knott, Lancaster B. (1978)
Additive, Multiplicative, and Mixed Analytical Errors.
<em>Clinical Chemistry</em> <b>24</b>(11), 1895&ndash;1898.
<a href="https://doi.org/10.1093/clinchem/24.11.1895">doi:10.1093/clinchem/24.11.1895</a>
</p>
<p>Wilson, M.D., Rocke, D.M., Durbin, B. and Kahn, H.D (2004)
Detection Limits and Goodness-of-Fit Measures for the Two-Component Model
of Chemical Analytical Error.
<em>Analytica Chimica Acta</em> 2004, 509, 197&ndash;208
<a href="https://doi.org/10.1016/j.aca.2003.12.047">doi:10.1016/j.aca.2003.12.047</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varFunc">coef.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some synthetic data using the two-component error model and use
# different variance functions, also with fixed sigma in order to avoid
# overparameterisation in the case of a constant term in the variance function
times &lt;- c(0, 1, 3, 7, 14, 28, 56, 120)
pred &lt;- 100 * exp(- 0.03 * times)
sd_pred &lt;- sqrt(3^2 + 0.07^2 * pred^2)
n_replicates &lt;- 2

set.seed(123456)
syn_data &lt;- data.frame(
  time = rep(times, each = n_replicates),
  value = rnorm(length(times) * n_replicates,
    rep(pred, each = n_replicates),
    rep(sd_pred, each = n_replicates)))
syn_data$value &lt;- ifelse(syn_data$value &lt; 0, NA, syn_data$value)

f_const &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3))
f_varPower &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3),
  weights = varPower())
f_varConstPower &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3),
  weights = varConstPower())
f_varConstPower_sf &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  control = list(sigma = 1),
  start = list(parent_0 = 100, lrc = -3),
  weights = varConstPower())
f_varConstProp &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3),
  weights = varConstProp())
f_varConstProp_sf &lt;- gnls(value ~ SSasymp(time, 0, parent_0, lrc),
  data = syn_data, na.action = na.omit,
  start = list(parent_0 = 100, lrc = -3),
  control = list(sigma = 1),
  weights = varConstProp())

AIC(f_const, f_varPower, f_varConstPower, f_varConstPower_sf,
  f_varConstProp, f_varConstProp_sf)

# The error model parameters 3 and 0.07 are approximately recovered
intervals(f_varConstProp_sf)
</code></pre>

<hr>
<h2 id='VarCorr'>Extract variance and correlation components</h2><span id='topic+VarCorr'></span><span id='topic+VarCorr.lme'></span><span id='topic+VarCorr.pdMat'></span><span id='topic+VarCorr.pdBlocked'></span><span id='topic+print.VarCorr.lme'></span>

<h3>Description</h3>

<p>This function calculates the estimated variances, standard
deviations, and correlations between the random-effects terms in a
linear mixed-effects model, of class <code>"<a href="#topic+lme">lme</a>"</code>, or a nonlinear
mixed-effects model, of class <code>"<a href="#topic+nlme">nlme</a>"</code>.  The within-group error
variance and standard deviation are also calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarCorr(x, sigma = 1, ...)
## S3 method for class 'lme'
VarCorr(x, sigma = x$sigma, rdig = 3, ...)

## S3 method for class 'pdMat'
VarCorr(x, sigma = 1, rdig = 3, ...)
## S3 method for class 'pdBlocked'
VarCorr(x, sigma = 1, rdig = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr_+3A_x">x</code></td>
<td>
<p>a fitted model object, usually an object inheriting from
class <code>"<a href="#topic+lme">lme</a>"</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_sigma">sigma</code></td>
<td>
<p>an optional numeric value used as a multiplier for the
standard deviations.  The default is <code>x$sigma</code> or <code>1</code>
depending on <code><a href="base.html#topic+class">class</a>(x)</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_rdig">rdig</code></td>
<td>
<p>an optional integer value specifying the number of digits
used to represent correlation estimates.  Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="VarCorr_+3A_...">...</code></td>
<td>
<p>further optional arguments passed to other methods (none
for the methods documented here).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the estimated variances, standard deviations, and
correlations for the random effects.  The first two columns, named
<code>Variance</code> and <code>StdDev</code>, give, respectively, the variance
and the standard deviations.  If there are correlation components in
the random effects model, the third column, named <code>Corr</code>,
and the remaining unnamed columns give the estimated correlations
among random effects within the same level of grouping.  The
within-group error variance and standard deviation are included as
the last row in the matrix.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000)
<em>Mixed-Effects Models in S and S-PLUS</em>, Springer, esp. pp. 100, 461.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>, <code><a href="#topic+nlme">nlme</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(distance ~ age, data = Orthodont, random = ~age)
VarCorr(fm1)
</code></pre>

<hr>
<h2 id='varExp'>Exponential Variance Function</h2><span id='topic+varExp'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varExp</code> class,
representing an exponential variance function structure. Letting
<code class="reqn">v</code> denote the variance covariate and <code class="reqn">\sigma^2(v)</code>
denote the variance function evaluated at <code class="reqn">v</code>, the exponential
variance function is defined as <code class="reqn">\sigma^2(v) = \exp(2\theta
    v)</code>, where <code class="reqn">\theta</code> is the variance
function coefficient. When a grouping factor is present, a different
<code class="reqn">\theta</code> is used for each factor level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varExp(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varExp_+3A_value">value</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
with the variance function coefficients. <code>Value</code> must have
length one, unless a grouping factor is specified in <code>form</code>.
If <code>value</code> has length greater than one, it must have names
which identify its elements to the levels of the grouping factor
defined in <code>form</code>. If a grouping factor is present in
<code>form</code> and <code>value</code> has length one, its value will be
assigned to all grouping levels. Default is <code>numeric(0)</code>, which
results in a vector of zeros of appropriate length being assigned to
the coefficients when <code>object</code> is initialized (corresponding
to constant variance equal to one).</p>
</td></tr>
<tr><td><code id="varExp_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula of the form <code>~ v</code>, or
<code>~ v | g</code>, specifying a variance covariate <code>v</code> and,
optionally, a grouping factor <code>g</code> for the coefficients. The
variance covariate must evaluate to a numeric vector and may involve
expressions using <code>"."</code>, representing  a fitted model object
from which fitted values (<code>fitted(.)</code>) and residuals
(<code>resid(.)</code>) can be extracted (this allows the variance
covariate to be updated during the optimization of an object
function). When a grouping factor is present in <code>form</code>,
a different coefficient value is used for each of its
levels. Several grouping variables may be
simultaneously specified, separated by the <code>*</code> operator, like
in <code>~ v | g1 * g2 * g3</code>. In this case, the levels of each
grouping variable are pasted together and the resulting factor is
used to group the observations. Defaults to <code>~ fitted(.)</code>
representing a variance covariate given by the fitted values of a
fitted model object and no grouping factor. </p>
</td></tr>
<tr><td><code id="varExp_+3A_fixed">fixed</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
specifying the values at which some or all of the  coefficients in
the variance function should be fixed. If a grouping factor is
specified in <code>form</code>, <code>fixed</code> must have names identifying
which coefficients are to be fixed. Coefficients included in
<code>fixed</code> are not allowed to vary during the optimization of an
objective function. Defaults to <code>NULL</code>, corresponding to no
fixed coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varExp</code> object representing an exponential variance function
structure, also inheriting from class <code>varFunc</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varExp">coef.varExp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varExp(0.2, form = ~age|Sex)
</code></pre>

<hr>
<h2 id='varFixed'>Fixed Variance Function</h2><span id='topic+varFixed'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varFixed</code> class,
representing a variance function with fixed variances. Letting <code class="reqn">v</code>
denote the variance covariate defined in <code>value</code>, the variance
function <code class="reqn">\sigma^2(v)</code> for this class is
<code class="reqn">\sigma^2(v)=|v|</code>. The variance covariate <code class="reqn">v</code> is
evaluated once at initialization and remains fixed thereafter. No
coefficients are required to represent this variance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varFixed(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varFixed_+3A_value">value</code></td>
<td>
<p>a one-sided formula of the form <code>~ v</code> specifying a
variance covariate <code>v</code>. Grouping factors are ignored.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a <code>varFixed</code> object representing a fixed variance function
structure, also inheriting from class <code>varFunc</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+varFunc">varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varFixed(~age)
</code></pre>

<hr>
<h2 id='varFunc'>Variance Function Structure</h2><span id='topic+varFunc'></span>

<h3>Description</h3>

<p>If <code>object</code> is a one-sided formula, it is used as the argument to
<code>varFixed</code> and the resulting object is returned. Else, if
<code>object</code> inherits from class <code>varFunc</code>, it is returned
unchanged. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varFunc_+3A_object">object</code></td>
<td>
<p>either an one-sided formula specifying a variance
covariate, or an object inheriting from class <code>varFunc</code>,
representing a variance function structure.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>an object from class <code>varFunc</code>, representing a variance function
structure. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.varFunc">summary.varFunc</a></code>,
<code><a href="#topic+varFixed">varFixed</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varFunc">coef.varFunc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varFunc(~age)
</code></pre>

<hr>
<h2 id='varIdent'>Constant Variance Function</h2><span id='topic+varIdent'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varIdent</code> class,
representing a constant variance function structure. If no grouping
factor is present in <code>form</code>, the variance function is constant
and equal to one, and no coefficients required to represent it. When
<code>form</code> includes a grouping factor with <code class="reqn">M &gt; 1</code> levels, the
variance function allows M different variances, one  for each level of
the factor. For identifiability reasons, the coefficients of the
variance function represent the ratios between the variances and a
reference variance (corresponding to a reference group
level). Therefore, only <code class="reqn">M-1</code> coefficients are needed to represent
the variance function. By default, if the elements in <code>value</code> are
unnamed, the first group level is taken as the reference level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varIdent(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varIdent_+3A_value">value</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
with the variance function coefficients. If no grouping factor is
present in <code>form</code>, this argument is ignored, as the resulting
variance function contains no coefficients. If <code>value</code> has
length one, its value is repeated for all coefficients in the
variance function. If <code>value</code> has length greater than one, it
must have length equal to the number of grouping levels minus one
and names which identify its elements to the levels of the grouping
factor. Only positive values are allowed for this argument. Default
is <code>numeric(0)</code>, which results in a vector of zeros of
appropriate length being assigned to the coefficients when
<code>object</code> is initialized (corresponding to constant variance 
equal to one).</p>
</td></tr>  
<tr><td><code id="varIdent_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula of the form <code>~ v</code>, or
<code>~ v | g</code>, specifying a variance covariate <code>v</code> and,
optionally, a grouping factor <code>g</code> for the coefficients. The
variance covariate is ignored in this variance function. When a
grouping factor is present in <code>form</code>, a different coefficient
value is used for each of its levels less one reference level (see
description section below). Several grouping variables may be
simultaneously specified, separated by the <code>*</code> operator, like
in <code>~ v | g1 * g2 * g3</code>. In this case, the levels of each
grouping variable are pasted together and the resulting factor is
used to group the observations. Defaults to <code>~ 1</code>. </p>
</td></tr>
<tr><td><code id="varIdent_+3A_fixed">fixed</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
specifying the values at which some or all of the  coefficients in
the variance function should be fixed. It must have names
identifying which coefficients are to be fixed. Coefficients
included in <code>fixed</code> are not allowed to vary during the
optimization of an objective function. Defaults to <code>NULL</code>,
corresponding to no fixed coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varIdent</code> object representing a constant variance function
structure, also inheriting from class <code>varFunc</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varClasses">varClasses</a></code>,
<code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varIdent">coef.varIdent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varIdent(c(Female = 0.5), form = ~ 1 | Sex)
</code></pre>

<hr>
<h2 id='Variogram'>Calculate Semi-variogram</h2><span id='topic+Variogram'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to handle
specific classes of objects. Classes which already have methods for
this function include <code>default</code>, <code>gls</code> and <code>lme</code>. See
the appropriate method documentation for a description of the
arguments. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Variogram(object, distance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram_+3A_object">object</code></td>
<td>
<p>a numeric vector with the values to be used for
calculating the semi-variogram, usually a residual vector from a
fitted model.</p>
</td></tr>
<tr><td><code id="Variogram_+3A_distance">distance</code></td>
<td>
<p>a numeric vector with the pairwise distances
corresponding to the elements of <code>object</code>. The order of the
elements in <code>distance</code> must correspond to the pairs
<code>(1,2), (1,3), ..., (n-1,n)</code>, with <code>n</code> representing the
length of <code>object</code>, and must have length <code>n(n-1)/2</code>.</p>
</td></tr>
<tr><td><code id="Variogram_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will depend on the method function used; see the appropriate documentation.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp;
Sons.
</p>
<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Variogram.corExp">Variogram.corExp</a></code>,
<code><a href="#topic+Variogram.corGaus">Variogram.corGaus</a></code>,
<code><a href="#topic+Variogram.corLin">Variogram.corLin</a></code>,
<code><a href="#topic+Variogram.corRatio">Variogram.corRatio</a></code>,
<code><a href="#topic+Variogram.corSpatial">Variogram.corSpatial</a></code>,
<code><a href="#topic+Variogram.corSpher">Variogram.corSpher</a></code>,
<code><a href="#topic+Variogram.default">Variogram.default</a></code>,
<code><a href="#topic+Variogram.gls">Variogram.gls</a></code>,
<code><a href="#topic+Variogram.lme">Variogram.lme</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the method function documentation
</code></pre>

<hr>
<h2 id='Variogram.corExp'>Calculate Semi-variogram for a corExp Object</h2><span id='topic+Variogram.corExp'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the Exponential correlation model, using the estimated
coefficients corresponding to <code>object</code>, at the distances defined
by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corExp'
Variogram(object, distance, sig2, length.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corExp_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corExp">corExp</a>"</code>,
representing an exponential spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corExp_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corExp_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corExp_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corExp_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corExp">corExp</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(require("stats", quietly = TRUE))
cs1 &lt;- corExp(3, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1)[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.corGaus'>Calculate Semi-variogram for a corGaus Object</h2><span id='topic+Variogram.corGaus'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the Gaussian correlation model, using the estimated
coefficients corresponding to <code>object</code>, at the distances defined
by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corGaus'
Variogram(object, distance, sig2, length.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corGaus_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corGaus">corGaus</a>"</code>,
representing an Gaussian spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corGaus_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corGaus_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corGaus_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corGaus_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corGaus">corGaus</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corGaus(3, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1)[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.corLin'>Calculate Semi-variogram for a corLin Object</h2><span id='topic+Variogram.corLin'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the Linear correlation model, using the estimated
coefficients corresponding to <code>object</code>, at the distances defined
by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corLin'
Variogram(object, distance, sig2, length.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corLin_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corLin">corLin</a>"</code>,
representing an Linear spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corLin_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corLin_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corLin_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corLin_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corLin">corLin</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corLin(15, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1)[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.corRatio'>Calculate Semi-variogram for a corRatio Object</h2><span id='topic+Variogram.corRatio'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the Rational Quadratic correlation model, using the
estimated coefficients corresponding to <code>object</code>, at the
distances defined by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corRatio'
Variogram(object, distance, sig2, length.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corRatio_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corRatio">corRatio</a>"</code>,
representing an Rational Quadratic spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corRatio_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corRatio_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corRatio_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corRatio_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corRatio">corRatio</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>
<code><a href="#topic+Variogram">Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corRatio(7, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1)[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.corSpatial'>Calculate Semi-variogram for a corSpatial Object</h2><span id='topic+Variogram.corSpatial'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the model defined in <code>FUN</code>, using the estimated
coefficients corresponding to <code>object</code>, at the distances defined
by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corSpatial'
Variogram(object, distance, sig2, length.out, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corSpatial_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corSpatial">corSpatial</a>"</code>,
representing spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corSpatial_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corSpatial_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corSpatial_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corSpatial_+3A_fun">FUN</code></td>
<td>
<p>a function of two arguments, the distance and the range
corresponding to <code>object</code>, specifying the semi-variogram
model.</p>
</td></tr> 
<tr><td><code id="Variogram.corSpatial_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corSpatial">corSpatial</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>,
<code><a href="#topic+Variogram.default">Variogram.default</a></code>,
<code><a href="#topic+Variogram.corExp">Variogram.corExp</a></code>,
<code><a href="#topic+Variogram.corGaus">Variogram.corGaus</a></code>,
<code><a href="#topic+Variogram.corLin">Variogram.corLin</a></code>,
<code><a href="#topic+Variogram.corRatio">Variogram.corRatio</a></code>,
<code><a href="#topic+Variogram.corSpher">Variogram.corSpher</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corExp(3, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1, FUN = function(x, y) (1 - exp(-x/y)))[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.corSpher'>Calculate Semi-variogram for a corSpher Object</h2><span id='topic+Variogram.corSpher'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram values
corresponding to the Spherical correlation model, using the estimated
coefficients corresponding to <code>object</code>, at the distances defined
by <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'corSpher'
Variogram(object, distance, sig2, length.out, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.corSpher_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+corSpher">corSpher</a>"</code>,
representing an Spherical spatial correlation structure.</p>
</td></tr>
<tr><td><code id="Variogram.corSpher_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances at
which the semi-variogram is to be calculated. Defaults to
<code>NULL</code>, in which case a sequence of length <code>length.out</code>
between the minimum and maximum values of
<code>getCovariate(object)</code> is used.</p>
</td></tr>
<tr><td><code id="Variogram.corSpher_+3A_sig2">sig2</code></td>
<td>
<p>an optional numeric value representing the process
variance. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corSpher_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer specifying the length of the
sequence of distances to be used for calculating the semi-variogram,
when <code>distance = NULL</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.corSpher_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corSpher">corSpher</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs1 &lt;- corSpher(15, form = ~ Time | Rat)
cs1 &lt;- Initialize(cs1, BodyWeight)
Variogram(cs1)[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.default'>Calculate Semi-variogram</h2><span id='topic+Variogram.default'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram for an arbitrary
vector <code>object</code>, according to the distances in <code>distance</code>.
For each pair of elements <code class="reqn">x,y</code> in <code>object</code>, the
corresponding semi-variogram is <code class="reqn">(x-y)^2/2</code>. The semi-variogram is
useful for identifying and modeling spatial correlation structures in
observations with constant expectation and constant variance.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
Variogram(object, distance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.default_+3A_object">object</code></td>
<td>
<p>a numeric vector with the values to be used for
calculating the semi-variogram, usually a residual vector from a
fitted model.</p>
</td></tr>
<tr><td><code id="Variogram.default_+3A_distance">distance</code></td>
<td>
<p>a numeric vector with the pairwise distances
corresponding to the elements of <code>object</code>. The order of the
elements in <code>distance</code> must correspond to the pairs
<code>(1,2), (1,3), ..., (n-1,n)</code>, with <code>n</code> representing the
length of <code>object</code>, and must have length <code>n(n-1)/2</code>.</p>
</td></tr>
<tr><td><code id="Variogram.default_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. The returned value inherits from class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Variogram">Variogram</a></code>,
<code><a href="#topic+Variogram.gls">Variogram.gls</a></code>,
<code><a href="#topic+Variogram.lme">Variogram.lme</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lm(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), Ovary,
          subset = Mare == 1)
Variogram(resid(fm1), dist(1:29))[1:10,]
</code></pre>

<hr>
<h2 id='Variogram.gls'>Calculate Semi-variogram for Residuals from a gls Object</h2><span id='topic+Variogram.gls'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram for the residuals
from a <code>gls</code> fit. The semi-variogram values are calculated for
pairs of residuals within the same group level, if a grouping factor
is present. If <code>collapse</code> is different from <code>"none"</code>, the
individual semi-variogram values are collapsed using either a robust
estimator (<code>robust = TRUE</code>) defined in Cressie (1993), or the
average of the values within the same distance interval. The
semi-variogram is useful for modeling the error term correlation
structure.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gls'
Variogram(object, distance, form, resType, data,
      na.action, maxDist, length.out, collapse, nint, breaks,
      robust, metric, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.gls_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+gls">gls</a>"</code>, representing
a generalized least squares fitted model.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances between
residual pairs. If a grouping variable is present, only the
distances between residual pairs within the same group should be
given. If missing, the distances are calculated based on the
values of the arguments <code>form</code>, <code>data</code>, and
<code>metric</code>, unless <code>object</code> includes a <code>corSpatial</code>
element, in which case the associated covariate (obtained with the
<code>getCovariate</code> method) is used.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the covariate(s)
to be used for calculating the distances between residual pairs and,
optionally, a grouping factor for partitioning the residuals (which
must appear to the right of a <code>|</code> operator in
<code>form</code>). Default is <code>~1</code>, implying that the observation 
order within the groups is used to obtain the distances.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_restype">resType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used. If <code>"response"</code>, the &quot;raw&quot; residuals
(observed - fitted) are used; else, if <code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided. Defaults to <code>"pearson"</code>.</p>
</td></tr> 
<tr><td><code id="Variogram.gls_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables
in <code>form</code>. By default, the same data used to fit <code>object</code>
is used.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s. The default action (<code>na.fail</code>) causes
an error message to be printed and the function to terminate, if there
are any incomplete observations.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_maxdist">maxDist</code></td>
<td>
<p>an optional numeric value for the maximum distance used
for calculating the semi-variogram between two residuals. By default
all residual pairs are included.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer value. When <code>object</code>
includes a <code>corSpatial</code> element, its semi-variogram values are
calculated and this argument is used as the <code>length.out</code>
argument to the corresponding <code>Variogram</code> method. Defaults to
<code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_collapse">collapse</code></td>
<td>
<p>an optional character string specifying the type of
collapsing to be applied to the individual semi-variogram values. If
equal to <code>"quantiles"</code>, the semi-variogram values are split
according to quantiles of the distance distribution, with equal
number of observations per group, with possibly varying distance
interval lengths. Else, if <code>"fixed"</code>, the semi-variogram values
are divided according to distance intervals of equal lengths, with
possibly different number of observations per interval. Else, if
<code>"none"</code>, no collapsing is used and the individual
semi-variogram values are returned. Defaults to <code>"quantiles"</code>.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_nint">nint</code></td>
<td>
<p>an optional integer with the number of intervals to be
used when collapsing the semi-variogram values. Defaults to <code>20</code>.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_robust">robust</code></td>
<td>
<p>an optional logical value specifying if a robust
semi-variogram estimator should be used when collapsing the
individual values. If <code>TRUE</code> the robust estimator is
used. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_breaks">breaks</code></td>
<td>
<p>an optional numeric vector with the breakpoints for the
distance intervals to be used in collapsing the semi-variogram
values. If not missing, the option specified in <code>collapse</code> is
ignored.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="Variogram.gls_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. If the semi-variogram values are collapsed, an extra
column, <code>n.pairs</code>, with the number of residual pairs used in each
semi-variogram calculation, is included in the returned data frame. If
<code>object</code> includes a <code>corSpatial</code> element, a data frame with
its corresponding semi-variogram is included in the returned value, as
an attribute <code>"modelVariog"</code>. The returned value inherits from
class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gls">gls</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>,
<code><a href="#topic+Variogram.default">Variogram.default</a></code>,
<code><a href="#topic+Variogram.lme">Variogram.lme</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- gls(weight ~ Time * Diet, BodyWeight)
Vm1 &lt;- Variogram(fm1, form = ~ Time | Rat)
print(head(Vm1), digits = 3)
</code></pre>

<hr>
<h2 id='Variogram.lme'>Calculate Semi-variogram for Residuals from an lme Object</h2><span id='topic+Variogram.lme'></span>

<h3>Description</h3>

<p>This method function calculates the semi-variogram for the
within-group residuals from an <code>lme</code> fit. The semi-variogram
values are calculated for pairs of residuals within the same group. If
<code>collapse</code> is different from <code>"none"</code>, the individual
semi-variogram values are collapsed using either a robust estimator
(<code>robust = TRUE</code>) defined in Cressie (1993), or the average of
the values within the same distance interval. The semi-variogram is
useful for modeling the error term correlation structure.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
Variogram(object, distance, form, resType, data,
       na.action, maxDist, length.out, collapse, nint, breaks,
       robust, metric, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Variogram.lme_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lme">lme</a>"</code>, representing
a fitted linear mixed-effects model.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_distance">distance</code></td>
<td>
<p>an optional numeric vector with the distances between
residual pairs. If a grouping variable is present, only the
distances between residual pairs within the same group should be
given. If missing, the distances are calculated based on the
values of the arguments <code>form</code>, <code>data</code>, and
<code>metric</code>, unless <code>object</code> includes a <code>corSpatial</code>
element, in which case the associated covariate (obtained with the
<code>getCovariate</code> method) is used.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula specifying the covariate(s)
to be used for calculating the distances between residual pairs and,
optionally, a grouping factor for partitioning the residuals (which
must appear to the right of a <code>|</code> operator in
<code>form</code>). Default is <code>~1</code>, implying that the observation 
order within the groups is used to obtain the distances.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_restype">resType</code></td>
<td>
<p>an optional character string specifying the type of
residuals to be used. If <code>"response"</code>, the &quot;raw&quot; residuals
(observed - fitted) are used; else, if <code>"pearson"</code>, the
standardized residuals (raw residuals divided by the corresponding
standard errors) are used; else, if <code>"normalized"</code>, the
normalized residuals (standardized residuals pre-multiplied by the
inverse square-root factor of the estimated error correlation
matrix) are used. Partial matching of arguments is used, so only the
first character needs to be provided. Defaults to <code>"pearson"</code>.</p>
</td></tr> 
<tr><td><code id="Variogram.lme_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables
in <code>form</code>. By default, the same data used to fit <code>object</code>
is used.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s. The default action (<code>na.fail</code>) causes
an error message to be printed and the function to terminate, if there
are any incomplete observations.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_maxdist">maxDist</code></td>
<td>
<p>an optional numeric value for the maximum distance used
for calculating the semi-variogram between two residuals. By default
all residual pairs are included.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_length.out">length.out</code></td>
<td>
<p>an optional integer value. When <code>object</code>
includes a <code>corSpatial</code> element, its semi-variogram values are
calculated and this argument is used as the <code>length.out</code>
argument to the corresponding <code>Variogram</code> method. Defaults to
<code>50</code>.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_collapse">collapse</code></td>
<td>
<p>an optional character string specifying the type of
collapsing to be applied to the individual semi-variogram values. If
equal to <code>"quantiles"</code>, the semi-variogram values are split
according to quantiles of the distance distribution, with equal
number of observations per group, with possibly varying distance
interval lengths. Else, if <code>"fixed"</code>, the semi-variogram values
are divided according to distance intervals of equal lengths, with
possibly different number of observations per interval. Else, if
<code>"none"</code>, no collapsing is used and the individual
semi-variogram values are returned. Defaults to <code>"quantiles"</code>.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_nint">nint</code></td>
<td>
<p>an optional integer with the number of intervals to be
used when collapsing the semi-variogram values. Defaults to <code>20</code>.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_robust">robust</code></td>
<td>
<p>an optional logical value specifying if a robust
semi-variogram estimator should be used when collapsing the
individual values. If <code>TRUE</code> the robust estimator is
used. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_breaks">breaks</code></td>
<td>
<p>an optional numeric vector with the breakpoints for the
distance intervals to be used in collapsing the semi-variogram
values. If not missing, the option specified in <code>collapse</code> is
ignored.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_metric">metric</code></td>
<td>
<p>an optional character string specifying the distance
metric to be used. The currently available options are
<code>"euclidean"</code> for the root sum-of-squares of distances;
<code>"maximum"</code> for the maximum difference; and <code>"manhattan"</code>
for the sum of the absolute differences. Partial matching of
arguments is used, so only the first three characters need to be
provided. Defaults to <code>"euclidean"</code>.</p>
</td></tr>
<tr><td><code id="Variogram.lme_+3A_...">...</code></td>
<td>
<p>some methods for this generic require additional
arguments.  None are used in this method.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>a data frame with columns <code>variog</code> and <code>dist</code> representing,
respectively, the semi-variogram values and the corresponding
distances. If the semi-variogram values are collapsed, an extra
column, <code>n.pairs</code>, with the number of residual pairs used in each
semi-variogram calculation, is included in the returned data frame. If
<code>object</code> includes a <code>corSpatial</code> element, a data frame with
its corresponding semi-variogram is included in the returned value, as
an attribute <code>"modelVariog"</code>. The returned value inherits from
class <code>Variogram</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1993), &quot;Statistics for Spatial Data&quot;, J. Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lme">lme</a></code>,
<code><a href="#topic+Variogram">Variogram</a></code>,
<code><a href="#topic+Variogram.default">Variogram.default</a></code>,
<code><a href="#topic+Variogram.gls">Variogram.gls</a></code>,
<code><a href="#topic+plot.Variogram">plot.Variogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fm1 &lt;- lme(weight ~ Time * Diet, data=BodyWeight, ~ Time | Rat)
Variogram(fm1, form = ~ Time | Rat, nint = 10, robust = TRUE)
</code></pre>

<hr>
<h2 id='varPower'>Power Variance Function</h2><span id='topic+varPower'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>varPower</code> class,
representing a power variance function structure. Letting
<code class="reqn">v</code> denote the variance covariate and <code class="reqn">\sigma^2(v)</code>
denote the variance function evaluated at <code class="reqn">v</code>, the power
variance function is defined as <code class="reqn">\sigma^2(v) = |v|^{2\theta}</code>, where <code class="reqn">\theta</code> is the variance 
function coefficient. When a grouping factor is present, a different
<code class="reqn">\theta</code> is used for each factor level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varPower(value, form, fixed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varPower_+3A_value">value</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
with the variance function coefficients. <code>Value</code> must have
length one, unless a grouping factor is specified in <code>form</code>.
If <code>value</code> has length greater than one, it must have names
which identify its elements to the levels of the grouping factor
defined in <code>form</code>. If a grouping factor is present in
<code>form</code> and <code>value</code> has length one, its value will be
assigned to all grouping levels. Default is <code>numeric(0)</code>, which
results in a vector of zeros of appropriate length being assigned to
the coefficients when <code>object</code> is initialized (corresponding
to constant variance equal to one).</p>
</td></tr>
<tr><td><code id="varPower_+3A_form">form</code></td>
<td>
<p>an optional one-sided formula of the form <code>~ v</code>, or
<code>~ v | g</code>, specifying a variance covariate <code>v</code> and,
optionally, a grouping factor <code>g</code> for the coefficients. The
variance covariate must evaluate to a numeric vector and may involve
expressions using <code>"."</code>, representing  a fitted model object
from which fitted values (<code>fitted(.)</code>) and residuals
(<code>resid(.)</code>) can be extracted (this allows the variance
covariate to be updated during the optimization of an object
function). When a grouping factor is present in <code>form</code>,
a different coefficient value is used for each of its
levels. Several grouping variables may be
simultaneously specified, separated by the <code>*</code> operator, like
in <code>~ v | g1 * g2 * g3</code>. In this case, the levels of each
grouping variable are pasted together and the resulting factor is
used to group the observations. Defaults to <code>~ fitted(.)</code>
representing a variance covariate given by the fitted values of a
fitted model object and no grouping factor. </p>
</td></tr>
<tr><td><code id="varPower_+3A_fixed">fixed</code></td>
<td>
<p>an optional numeric vector, or list of numeric values,
specifying the values at which some or all of the  coefficients in
the variance function should be fixed. If a grouping factor is
specified in <code>form</code>, <code>fixed</code> must have names identifying
which coefficients are to be fixed. Coefficients included in
<code>fixed</code> are not allowed to vary during the optimization of an
objective function. Defaults to <code>NULL</code>, corresponding to no
fixed coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>varPower</code> object representing a power variance function
structure, also inheriting from class <code>varFunc</code>. 
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varWeights.varFunc">varWeights.varFunc</a></code>,
<code><a href="#topic+coef.varPower">coef.varPower</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(0.2, form = ~age|Sex)
</code></pre>

<hr>
<h2 id='varWeights'>Extract Variance Function Weights</h2><span id='topic+varWeights'></span><span id='topic+varWeights.varComb'></span><span id='topic+varWeights.varFunc'></span>

<h3>Description</h3>

<p>The inverse of the standard deviations corresponding to the variance
function structure represented by <code>object</code> are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varWeights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varWeights_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>varFunc</code>,
representing a variance function structure.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>if <code>object</code> has a <code>weights</code> attribute, its value is
returned; else <code>NULL</code> is returned.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik.varFunc">logLik.varFunc</a></code>, 
<code><a href="#topic+varWeights">varWeights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vf1 &lt;- varPower(form=~age)
vf1 &lt;- Initialize(vf1, Orthodont)
coef(vf1) &lt;- 0.3
varWeights(vf1)[1:10]
</code></pre>

<hr>
<h2 id='varWeights.glsStruct'>Variance Weights for glsStruct Object</h2><span id='topic+varWeights.glsStruct'></span>

<h3>Description</h3>

<p>If <code>object</code> includes a <code>varStruct</code> component, the inverse of
the standard deviations of the variance function structure represented
by the corresponding <code>varFunc</code> object are returned; else, a
vector of ones of length equal to the number of observations in the
data frame used to fit the associated linear model is returned. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsStruct'
varWeights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varWeights.glsStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+glsStruct">glsStruct</a>"</code>,
representing a list of linear model components, such as
<code>corStruct</code> and <code>"<a href="#topic+varFunc">varFunc</a>"</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>object</code> includes a <code>varStruct</code> component, a vector with
the corresponding variance weights; else, or a vector of ones.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varWeights">varWeights</a></code></p>

<hr>
<h2 id='varWeights.lmeStruct'>Variance Weights for lmeStruct Object</h2><span id='topic+varWeights.lmeStruct'></span>

<h3>Description</h3>

<p>If <code>object</code> includes a <code>varStruct</code> component, the inverse of
the standard deviations of the variance function structure represented
by the corresponding <code>varFunc</code> object are returned; else, a
vector of ones of length equal to the number of observations in the
data frame used to fit the associated linear mixed-effects model is
returned. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmeStruct'
varWeights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varWeights.lmeStruct_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"<a href="#topic+lmeStruct">lmeStruct</a>"</code>,
representing a list of linear mixed-effects model components, such as
<code>reStruct</code>, <code>corStruct</code>, and <code>varFunc</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>object</code> includes a <code>varStruct</code> component, a vector with
the corresponding variance weights; else, or a vector of ones.
</p>


<h3>Author(s)</h3>

<p>José Pinheiro and Douglas Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a></p>


<h3>References</h3>

<p>Pinheiro, J.C., and Bates, D.M. (2000) &quot;Mixed-Effects Models
in S and S-PLUS&quot;, Springer.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varWeights">varWeights</a></code></p>

<hr>
<h2 id='Wafer'>Modeling of Analog MOS Circuits</h2><span id='topic+Wafer'></span>

<h3>Description</h3>

<p>The <code>Wafer</code> data frame has 400 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Wafer</dt><dd>
<p>a factor with levels
<code>1</code> 
<code>2</code> 
<code>3</code> 
<code>4</code> 
<code>5</code> 
<code>6</code> 
<code>7</code> 
<code>8</code> 
<code>9</code> 
<code>10</code> 
</p>
</dd>
<dt>Site</dt><dd>
<p>a factor with levels
<code>1</code> 
<code>2</code> 
<code>3</code> 
<code>4</code> 
<code>5</code> 
<code>6</code> 
<code>7</code> 
<code>8</code> 
</p>
</dd>
<dt>voltage</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>current</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='Wheat'>Yields by growing conditions</h2><span id='topic+Wheat'></span>

<h3>Description</h3>

<p>The <code>Wheat</code> data frame has 48 rows and 4 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Tray</dt><dd>
<p>an ordered factor with levels
<code>3</code> &lt; <code>1</code> &lt; <code>2</code> &lt; <code>4</code> &lt; <code>5</code> &lt; <code>6</code> &lt; <code>8</code> &lt; <code>9</code> &lt; <code>7</code> &lt; <code>12</code> &lt; <code>11</code> &lt; <code>10</code>
</p>
</dd>
<dt>Moisture</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>fertilizer</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>DryMatter</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

<hr>
<h2 id='Wheat2'>Wheat Yield Trials</h2><span id='topic+Wheat2'></span>

<h3>Description</h3>

<p>The <code>Wheat2</code> data frame has 224 rows and 5 columns.
</p>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Block</dt><dd>
<p>an ordered factor with levels
<code>4</code> &lt; <code>2</code> &lt; <code>3</code> &lt; <code>1</code>
</p>
</dd>
<dt>variety</dt><dd>
<p>a factor with levels
<code>ARAPAHOE</code> 
<code>BRULE</code> 
<code>BUCKSKIN</code> 
<code>CENTURA</code> 
<code>CENTURK78</code> 
<code>CHEYENNE</code> 
<code>CODY</code> 
<code>COLT</code> 
<code>GAGE</code> 
<code>HOMESTEAD</code> 
<code>KS831374</code> 
<code>LANCER</code> 
<code>LANCOTA</code> 
<code>NE83404</code> 
<code>NE83406</code> 
<code>NE83407</code> 
<code>NE83432</code> 
<code>NE83498</code> 
<code>NE83T12</code> 
<code>NE84557</code> 
<code>NE85556</code> 
<code>NE85623</code> 
<code>NE86482</code> 
<code>NE86501</code> 
<code>NE86503</code> 
<code>NE86507</code> 
<code>NE86509</code> 
<code>NE86527</code> 
<code>NE86582</code> 
<code>NE86606</code> 
<code>NE86607</code> 
<code>NE86T666</code> 
<code>NE87403</code> 
<code>NE87408</code> 
<code>NE87409</code> 
<code>NE87446</code> 
<code>NE87451</code> 
<code>NE87457</code> 
<code>NE87463</code> 
<code>NE87499</code> 
<code>NE87512</code> 
<code>NE87513</code> 
<code>NE87522</code> 
<code>NE87612</code> 
<code>NE87613</code> 
<code>NE87615</code> 
<code>NE87619</code> 
<code>NE87627</code> 
<code>NORKAN</code> 
<code>REDLAND</code> 
<code>ROUGHRIDER</code> 
<code>SCOUT66</code> 
<code>SIOUXLAND</code> 
<code>TAM107</code> 
<code>TAM200</code> 
<code>VONA</code> 
</p>
</dd>
<dt>yield</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>latitude</dt><dd>
<p>a numeric vector
</p>
</dd>
<dt>longitude</dt><dd>
<p>a numeric vector
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Pinheiro, J. C. and Bates, D. M. (2000), <em>Mixed-Effects Models in S
and S-PLUS</em>, Springer, New York.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
