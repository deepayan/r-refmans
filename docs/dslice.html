<!DOCTYPE html><html lang="en"><head><title>Help for package dslice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dslice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bfslice_c'>
<p>Dependency and conditional dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.</p></a></li>
<li><a href='#bfslice_eqp_c'>
<p>Dependency and conditional dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.</p></a></li>
<li><a href='#bfslice_eqp_u'>
<p>Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor with given size of each group.</p></a></li>
<li><a href='#bfslice_u'>
<p>Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.</p></a></li>
<li><a href='#ds_1'>
<p>Non-parametric one-sample hypothesis testing via dynamic slicing</p></a></li>
<li><a href='#ds_eqp_1'>
<p>Non-parametric one-sample hypothesis testing via dynamic slicing</p></a></li>
<li><a href='#ds_eqp_k'>
<p>Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable</p></a></li>
<li><a href='#ds_gsa'>
<p>Gene set analysis via dynamic slicing</p></a></li>
<li><a href='#ds_k'>
<p>Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable</p></a></li>
<li><a href='#ds_test'>
<p>Hypothesis testing via dynamic slicing</p></a></li>
<li><a href='#ds_type_one_error'>
<p>Relationship between penalty and Type I error</p></a></li>
<li><a href='#export_res'>
<p>Export gene set analysis result</p></a></li>
<li><a href='#gsa_exp'>
<p>Gene expression matrix in gene set analysis</p></a></li>
<li><a href='#gsa_label'>
<p>Sample labels in gene set analysis</p></a></li>
<li><a href='#gsa_set'>
<p>Gene set list in gene set analysis</p></a></li>
<li><a href='#load_cls'>
<p>Load phenotype file</p></a></li>
<li><a href='#load_gct'>
<p>Load gene expression file</p></a></li>
<li><a href='#load_gmt'>
<p>Load gene set file</p></a></li>
<li><a href='#rank_by_s2n'>
<p>Ranking genes by signal to noise ratio</p></a></li>
<li><a href='#relabel'>
<p>Reassigning values of categorical variable</p></a></li>
<li><a href='#slice_show'>
<p>Show the slicing result</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Slicing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chao Ye &lt;yechao1009@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Dynamic slicing is a method designed for dependency detection between a categorical variable and a continuous variable. It could be applied for non-parametric hypothesis testing and gene set enrichment analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), stats, utils, Rcpp (&ge; 0.11.1), ggplot2 (&ge;
0.9.3.1), scales</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 16:53:11 UTC; yechao</td>
</tr>
<tr>
<td>Author:</td>
<td>Chao Ye [aut, cre],
  Bo Jiang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bfslice_c'>
Dependency and conditional dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.
</h2><span id='topic+bfslice_c'></span>

<h3>Description</h3>

 
<p>Conditional dependency detection between a level <code class="reqn">k_x</code> (<code class="reqn">k_x &gt; 1</code>) categorical variable <code>x</code> and a continuous variable <code>y</code> via Bayes factor given a level <code class="reqn">k_z</code> categorical variable <code>z</code>. If <code class="reqn">k_z = 1</code>, it is unconditional dependency detection method. It could be applied for non-parametric variable selecltion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bfslice_c(z, x, zdim, xdim, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bfslice_c_+3A_z">z</code></td>
<td>
<p>Vector: observations of given (preselected) categorical variable, <code class="reqn">0,1,\ldots,k_z-1</code> for level <code class="reqn">k_z</code> categorical variable, should be ranked according to values of continuous variable <code>y</code> with <code>x</code> in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_c_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k_x-1</code> for level <code class="reqn">k_x</code> categorical variable, should be ranked according to values of continuous variable <code>y</code> with <code>z</code> in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_c_+3A_zdim">zdim</code></td>
<td>
<p>Level of <code>z</code>, equals <code class="reqn">k_z</code>.</p>
</td></tr>
<tr><td><code id="bfslice_c_+3A_xdim">xdim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k_x</code>.</p>
</td></tr>  
<tr><td><code id="bfslice_c_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> corresponds to the probability that makes slice in each possible position. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="bfslice_c_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> is hyper-parameter of the prior distribution of frequency in each slice. <code>alpha</code> should be greater than 0 and less equal than <code class="reqn">k_x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of Bayes factor (nonnegative). Bayes factor could be treated as a statistic and one can take some threshold then calculates the corresponded Type I error rate. One can also take the value of Bayes factor for judgement.
</p>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Bayesian nonparametric tests via sliced inverse modeling. <em>Bayesian Analysis</em>, 12(1): 89-112, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfslice_u">bfslice_u</a>, <a href="#topic+bfslice_eqp_c">bfslice_eqp_c</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5

## Unconditional test
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n), rep(1, n))
z &lt;- rep(0, 2*n)

## Conditional test
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n/5), rep(1, n), rep(0, 4*n/5))
z &lt;- c(rep(0, n), rep(1, n))
z &lt;- z[order(y)]

x &lt;- x[order(y)]
zdim &lt;- max(z) + 1
xdim &lt;- max(x) + 1
lambda &lt;- 1.0
alpha &lt;- 1.0
bfval &lt;- bfslice_c(z, x, zdim, xdim, lambda, alpha)
</code></pre>

<hr>
<h2 id='bfslice_eqp_c'>
Dependency and conditional dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.
</h2><span id='topic+bfslice_eqp_c'></span>

<h3>Description</h3>

 
<p>Conditional dependency detection between a level <code class="reqn">k_x</code> (<code class="reqn">k_x &gt; 1</code>) categorical variable <code>x</code> and a continuous variable <code>y</code> via Bayes factor given a level <code class="reqn">k_z</code> categorical variable <code>z</code> with <code class="reqn">O(n^{1/2})</code>-resolution. The basic idea is almost the same as <code><a href="#topic+bfslice_c">bfslice_c</a></code>. The only different is that <code><a href="#topic+bfslice_eqp_c">bfslice_eqp_c</a></code> groups samples into approximate <code class="reqn">O(n^{1/2})</code> groups which contain approximate <code class="reqn">O(n^{1/2})</code> samples and treat the groups as a sample to calculate Bayes facor. If <code class="reqn">k_z = 1</code>, it is unconditional dependency detection method. It could be applied for non-parametric variable selecltion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bfslice_eqp_c(z, x, zdim, xdim, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bfslice_eqp_c_+3A_z">z</code></td>
<td>
<p>Vector: observations of given (preselected) categorical variable, <code class="reqn">0,1,\ldots,k_z-1</code> for level <code class="reqn">k_z</code> categorical variable, should be ranked according to values of continuous variable <code>y</code> with <code>x</code> in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_c_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k_x-1</code> for level <code class="reqn">k_x</code> categorical variable, should be ranked according to values of continuous variable <code>y</code> with <code>z</code> in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_c_+3A_zdim">zdim</code></td>
<td>
<p>Level of <code>z</code>, equals <code class="reqn">k_z</code>.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_c_+3A_xdim">xdim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k_x</code>.</p>
</td></tr>  
<tr><td><code id="bfslice_eqp_c_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> corresponds to the probability that makes slice in each possible position. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_c_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> is hyper-parameter of the prior distribution of frequency in each slice. <code>alpha</code> should be greater than 0 and less equal than <code class="reqn">k_x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of Bayes factor (nonnegative). Bayes factor could be treated as a statistic and one can take some threshold then calculates the corresponded Type I error rate. One can also take the value of Bayes factor for judgement.
</p>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Bayesian nonparametric tests via sliced inverse modeling. <em>Bayesian Analysis</em>, 12(1): 89-112, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfslice_c">bfslice_c</a>, <a href="#topic+bfslice_eqp_u">bfslice_eqp_u</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
mu &lt;- 0.2

## Unconditional test
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n), rep(1, n))
z &lt;- rep(0, 2*n)

## Conditional test
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n/5), rep(1, n), rep(0, 4*n/5))
z &lt;- c(rep(0, n), rep(1, n))
z &lt;- z[order(y)]

x &lt;- x[order(y)]
zdim &lt;- max(z) + 1
xdim &lt;- max(x) + 1
lambda &lt;- 1.0
alpha &lt;- 1.0
bfval &lt;- bfslice_eqp_c(z, x, zdim, xdim, lambda, alpha)
</code></pre>

<hr>
<h2 id='bfslice_eqp_u'>
Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor with given size of each group.
</h2><span id='topic+bfslice_eqp_u'></span>

<h3>Description</h3>

 
<p>Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable <code>x</code> and a continuous variable <code>y</code> via Bayes factor with <code class="reqn">O(n^{1/2})</code>-resolution. The basic idea is almost the same as <code><a href="#topic+bfslice_u">bfslice_u</a></code>. The only different is that <code><a href="#topic+bfslice_eqp_u">bfslice_eqp_u</a></code> groups samples into approximate <code class="reqn">O(n^{1/2})</code> groups which contain approximate <code class="reqn">O(n^{1/2})</code> samples and treat the groups as a sample to calculate Bayes facor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bfslice_eqp_u(x, dim, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bfslice_eqp_u_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k-1</code> for level <code class="reqn">k</code> categorical variable, should be ranked according to values of continuous variable <code>y</code>, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_u_+3A_dim">dim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k</code>.</p>
</td></tr>  
<tr><td><code id="bfslice_eqp_u_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> corresponds to the probability that makes slice in each possible position. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="bfslice_eqp_u_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> is hyper-parameter of the prior distribution of frequency in each slice. <code>alpha</code> should be greater than 0 and less equal than <code class="reqn">k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of Bayes factor (nonnegative). Bayes factor could be treated as a statistic and one can take some threshold then calculates the corresponded Type I error rate. One can also take the value of Bayes factor for judgement.
</p>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Bayesian nonparametric tests via sliced inverse modeling. <em>Bayesian Analysis</em>, 12(1): 89-112, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfslice_u">bfslice_u</a>, <a href="#topic+bfslice_eqp_c">bfslice_eqp_c</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
mu &lt;- 0.2
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n), rep(1, n))
x &lt;- x[order(y)]
dim &lt;- max(x) + 1
lambda &lt;- 1.0
alpha &lt;- 1.0
bfval &lt;- bfslice_eqp_u(x, dim, lambda, alpha)
</code></pre>

<hr>
<h2 id='bfslice_u'>
Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and a continuous variable via Bayes factor.
</h2><span id='topic+bfslice_u'></span>

<h3>Description</h3>

 
<p>Dependency detection between a level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable <code>x</code> and a continuous variable <code>y</code> via Bayes factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bfslice_u(x, dim, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bfslice_u_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k-1</code> for level <code class="reqn">k</code> categorical variable, should be ranked according to values of continuous variable <code>y</code>, either ascending or descending.</p>
</td></tr>
<tr><td><code id="bfslice_u_+3A_dim">dim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k</code>.</p>
</td></tr>  
<tr><td><code id="bfslice_u_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> corresponds to the probability that makes slice in each possible position. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="bfslice_u_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> is hyper-parameter of the prior distribution of frequency in each slice. <code>alpha</code> should be greater than 0 and less equal than <code class="reqn">k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of Bayes factor (nonnegative). Bayes factor could be treated as a statistic and one can take some threshold then calculates the corresponded Type I error rate. One can also take the value of Bayes factor for judgement.
</p>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Bayesian nonparametric tests via sliced inverse modeling. <em>Bayesian Analysis</em>, 12(1): 89-112, 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfslice_c">bfslice_c</a>, <a href="#topic+bfslice_eqp_u">bfslice_eqp_u</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n), rep(1, n))
x &lt;- x[order(y)]
dim &lt;- max(x) + 1
lambda &lt;- 1.0
alpha &lt;- 1.0
bfval &lt;- bfslice_u(x, dim, lambda, alpha)
</code></pre>

<hr>
<h2 id='ds_1'>
Non-parametric one-sample hypothesis testing via dynamic slicing
</h2><span id='topic+ds_1'></span>

<h3>Description</h3>

<p>Non-parametric one-sample hypothesis testing via dynamic slicing. By mapping sample values to the quantile of null distribution, <code>ds_1</code> test whether they follow uniform distribution on [0, 1] via a regularized likelihood-ratio. Its calculated is based on a dynamic programming procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_1(y, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_1_+3A_y">y</code></td>
<td>
<p>Vector: quantiles of observations according to null distribution.</p>
</td></tr>
<tr><td><code id="ds_1_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> penalizes the number of slices to avoid too many slices. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="ds_1_+3A_alpha">alpha</code></td>
<td>
<p><code>alpha</code> penalizes both the width and the number of slices to avoid too many slices and degenerate slice (interval). <code>alpha</code> should be greater than 1.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Value of dynamic slicing statistic for one-sample test. It is nonnegative. The null hypothesis that observations are from the null distribution is rejected if this statistic is greater than zero, otherwise accept the null hypothesis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_eqp_1">ds_eqp_1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
x &lt;- rnorm(n, mu, 1)
y &lt;- pnorm(sort(x), 0, 1) 
lambda &lt;- 1.0
alpha &lt;- 1.0
dsres &lt;- ds_1(y, lambda, alpha)
</code></pre>

<hr>
<h2 id='ds_eqp_1'>
Non-parametric one-sample hypothesis testing via dynamic slicing
</h2><span id='topic+ds_eqp_1'></span>

<h3>Description</h3>

<p>Non-parametric one-sample hypothesis testing via dynamic slicing with <code class="reqn">O(n)</code>-resolution. The basic idea of <code>ds_eqp_1</code> is almost the same as <code><a href="#topic+ds_1">ds_1</a></code>. Difference between these two functions is that <code>ds_eqp_1</code> considers an equal partition on [0, 1] but <code><a href="#topic+ds_1">ds_1</a></code> does not. Candidate slicing boundaries in <code>ds_eqp_1</code> only depend on the total number of samples and are unrelated to sample quantiles. In <code><a href="#topic+ds_1">ds_1</a></code> they are immediately to the left or right of sample quantile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_eqp_1(y, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_eqp_1_+3A_y">y</code></td>
<td>
<p>Vector: quantiles of observations according to null distribution.</p>
</td></tr>
<tr><td><code id="ds_eqp_1_+3A_lambda">lambda</code></td>
<td>
<p><code>lambda</code> penalizes the number of slices to avoid too many slices. Since the interval [0, 1] is divided into <code class="reqn">n</code> equal size element-slice and slicing strategy only consider boundaries of them, this version of dynamic slicing does not require penlaty <code>lambda</code> as <code>ds_1</code>. <code>lambda</code> should be greater than 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of dynamic slicing statistic for one-sample test. It is nonnegative. The null hypothesis that observations are from the null distribution is rejected if this statistic is greater than zero, otherwise accept the null hypothesis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_1">ds_1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
x &lt;- rnorm(n, mu, 1)
y &lt;- pnorm(sort(x), 0, 1) 
lambda &lt;- 1.0
dsres &lt;- ds_eqp_1(y, lambda)
</code></pre>

<hr>
<h2 id='ds_eqp_k'>
Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable
</h2><span id='topic+ds_eqp_k'></span>

<h3>Description</h3>

<p>Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable via dynamic slicing with <code class="reqn">O(n^{1/2})</code>-resolution. The basic idea is almost the same as <code><a href="#topic+ds_k">ds_k</a></code>. The only different is that <code><a href="#topic+ds_eqp_k">ds_eqp_k</a></code> groups samples into approximate <code class="reqn">O(n^{1/2})</code> groups which contain approximate <code class="reqn">O(n^{1/2})</code> samples and performs dynamic slicing on their boundaries. This much faster version could reduce computation time substantially without too much power loss. Based on the strategy of <code>ds_eqp_k</code>, we recommend to apply it in large sample size problem and use <code><a href="#topic+ds_k">ds_k</a></code> for ordinary problem. For more details please refer to Jiang, Ye &amp; Liu (2015). Results contains value of dynamic slicing statistic and slicing strategy. It could be applied for non-parametric <em>K</em>-sample hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_eqp_k(x, xdim, lambda, slice = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_eqp_k_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k-1</code> for level <code class="reqn">k</code> categorical variable, should be ranked according to values of continuous variable in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="ds_eqp_k_+3A_xdim">xdim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="ds_eqp_k_+3A_lambda">lambda</code></td>
<td>
<p>Penalty for introducing an additional slice, which is used to avoid making too many slices. It corresponds to the type I error under the scenario that the two variables are independent. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="ds_eqp_k_+3A_slice">slice</code></td>
<td>
<p>Indicator for reporting slicing strategy or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dsval</code></td>
<td>
<p>Value of dynamic slicing statistic. It is nonnegative. If it equals zero, the categorical variable and continuous variable will be treated as independent of each other, otherwise they will be treated as dependent.</p>
</td></tr>
<tr><td><code>slices</code></td>
<td>
<p>Slicing strategy that maximize dynamic slicing statistic based on currently ranked vector <code>x</code>. It will be reported if <code>slice</code> is true. Each row stands for a slice. Each column except the last one stands for the number of observations take each value in each slice. The last column is the number of observations in each slice <em>i.e.</em>, the sum of the first column to the <em>k</em>th column.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Non-parametric <em>K</em>-sample tests via dynamic slicing. <em>Journal of the American Statistical Association</em>, 110(510): 642-653, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_k">ds_k</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep("1", n), rep("2", n))
x &lt;- relabel(x)
x &lt;- x[order(y)]
xdim &lt;- max(x) + 1
lambda &lt;- 1.0
dsres &lt;- ds_eqp_k(x, xdim, lambda, slice = TRUE)	
</code></pre>

<hr>
<h2 id='ds_gsa'>
Gene set analysis via dynamic slicing
</h2><span id='topic+ds_gsa'></span>

<h3>Description</h3>

<p>Gene set analysis via dynamic slicing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_gsa(expdat, geneset, label, generank, ..., lambda = 1, bycol = FALSE,
         minsize = 15, maxsize = 500, randseed = 11235, rounds = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_gsa_+3A_expdat">expdat</code></td>
<td>
<p>Either a character string of gene expression file name (.gct file), or an expression matrix with rownames, each row is a gene and each column is a sample.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_geneset">geneset</code></td>
<td>
<p>Either a character string of gene set file name (.gmt file), or a list contains a vector of gene set names, a vector of gene set description and a list of gene symbols in each gene set.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_label">label</code></td>
<td>
<p>Either a character string of phenotypes file (.cls file), or a list contains a vector of types of pheotype and a vector of encoded pheotypes of samples. It should match gene expression matrix.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_generank">generank</code></td>
<td>
<p>Either an integer vector of rank of each gene according to some statistic, or a character string naming a function which takes gene expression matrix as input and returns a vector of gene rank (not tie).</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_...">...</code></td>
<td>
<p>Parameters of the function specified (as a character string) by <code>generank</code>.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_lambda">lambda</code></td>
<td>
<p>Penalty for introducing an additional slice in dynamic slicing procedure, which is used to avoid making too many slices. It corresponds to the type I error under the scenario that the two variables are independent. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_bycol">bycol</code></td>
<td>
<p>Type of permutation, by row (default) or by column. Permutation by row means shuffling the gene rank. Permutation by column means shuffling pheotypes then obtain gene rank.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_minsize">minsize</code></td>
<td>
<p>Minimum number of genes in genesets to be considered.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_maxsize">maxsize</code></td>
<td>
<p>Maximum number of genes in genesets to be considered.</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_randseed">randseed</code></td>
<td>
<p>Optional initial seed for random number generator (integer).</p>
</td></tr>
<tr><td><code id="ds_gsa_+3A_rounds">rounds</code></td>
<td>
<p>Number of permutations for estimating significant level of results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ds_gsa</code> performs gene set analysis via dynamic slicing. It returns the DS statistics and slicing strategy of each gene set.
<code>ds_gsa</code> does not attempt to integrate the ranking method into it. It requires ranking method or directly the gene rank as a parameter. Leaving ranking method as an optional input parameter is convenience for users who would like to use any ranking methods they want.
</p>


<h3>Value</h3>

<p>A list with informations of gene sets whose size satisfy the minimum and maximum size thresholds. Its contains the following components:
</p>
<table role = "presentation">
<tr><td><code>set_name</code></td>
<td>
<p>A vector of gene set names.</p>
</td></tr>
<tr><td><code>set_size</code></td>
<td>
<p>A vector of gene set sizes.</p>
</td></tr>
<tr><td><code>DS_value</code></td>
<td>
<p>A vector of dynamic slicing statistic of each gene set.</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>A vector of <em>p</em>-value of each gene set.</p>
</td></tr>
<tr><td><code>FDR</code></td>
<td>
<p>A vector of FDR of each gene set.</p>
</td></tr>
<tr><td><code>slices</code></td>
<td>
<p>A list of slicing strategy of each gene set. Each component is a matrix of slices.</p>
</td></tr>  
</table>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Non-parametric <em>K</em>-sample tests via dynamic slicing. <em>Journal of the American Statistical Association</em>, 110(510): 642-653, 2015.
</p>
<p>Subramanian, A., Tamayo, P., Mootha, V. K., <em>et al</em>. Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, 2005, 102(43): 15545-15550.
</p>
<p>Benjamini, Y. and Hochberg, Y. Controlling the false discovery rate: a practical and powerful approach to multiple testing. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, 1995, 57(1): 289-300.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_k">ds_k</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Loading data from files
## Not run: 
gctpath &lt;- "P53.gct"
clspath &lt;- "P53.cls"
gmtpath &lt;- "C2.gmt"
expdat &lt;- load_gct(gctpath)
label &lt;- load_cls(clspath)
geneset &lt;- load_gmt(gmtpath)
fc &lt;- function(x, label)
{
  d0 &lt;- apply(x[,which(label == 0)], 1, mean)
  d1 &lt;- apply(x[,which(label == 1)], 1, mean)
  d &lt;- d1 / d0
  return(order(d))
}
ds_gsa_obj &lt;- ds_gsa(expdat, geneset, label, "fc", lambda = 1.2, bycol = TRUE,
                     minsize = 15, maxsize = 500, randseed = 11235, rounds = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='ds_k'>
Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable
</h2><span id='topic+ds_k'></span>

<h3>Description</h3>

<p>Dependency detection between level <code class="reqn">k</code> (<code class="reqn">k &gt; 1</code>) categorical variable and continuous variable. The basic idea is that the different values of categorical variable correspond to different distribution of continuous variable if there exist dependency between this two varibles, otherwise the distributions of continuous variable do not show difference conditioning on the values of categorical variable. Statistic for this dynamic slicing method is a regularized likelihood-ratio calculated via a dynamic programming procedure. For more details please refer to Jiang, Ye &amp; Liu (2015). Results contains value of dynamic slicing statistic and slicing strategy. It could be applied for non-parametric <em>K</em>-sample hypothesis testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_k(x, xdim, lambda, slice = FALSE)	
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_k_+3A_x">x</code></td>
<td>
<p>Vector: observations of categorical variable, <code class="reqn">0,1,\ldots,k-1</code> for level <code class="reqn">k</code> categorical variable, should be ranked according to values of continuous variable in advanced, either ascending or descending.</p>
</td></tr>
<tr><td><code id="ds_k_+3A_xdim">xdim</code></td>
<td>
<p>Level of <code>x</code>, equals <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="ds_k_+3A_lambda">lambda</code></td>
<td>
<p>Penalty for introducing an additional slice, which is used to avoid making too many slices. It corresponds to the type I error under the scenario that the two variables are independent. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="ds_k_+3A_slice">slice</code></td>
<td>
<p>Indicator for reporting slicing strategy or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dsval</code></td>
<td>
<p>Value of dynamic slicing statistic. It is nonnegative. If it equals zero, the categorical variable and continuous variable will be treated as independent of each other, otherwise they will be treated as dependent.</p>
</td></tr>
<tr><td><code>slices</code></td>
<td>
<p>Slicing strategy that maximize dynamic slicing statistic based on currently ranked vector <code>x</code>. It will be reported if <code>slice</code> is true. Each row stands for a slice. Each column except the last one stands for the number of observations take each value in each slice. The last column is the number of observations in each slice <em>i.e.</em>, the sum of the first column to the <em>k</em>th column.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Non-parametric <em>K</em>-sample tests via dynamic slicing. <em>Journal of the American Statistical Association</em>, 110(510): 642-653, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_eqp_k">ds_eqp_k</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep("1", n), rep("2", n))
x &lt;- relabel(x)
x &lt;- x[order(y)]
xdim &lt;- max(x) + 1
lambda &lt;- 1.0
dsres &lt;- ds_k(x, xdim, lambda, slice = TRUE)
</code></pre>

<hr>
<h2 id='ds_test'>
Hypothesis testing via dynamic slicing
</h2><span id='topic+ds_test'></span>

<h3>Description</h3>

<p>Perform a one- or <em>K</em>-sample (<code class="reqn">K &gt; 1</code>) hypothesis testing via dynamic slicing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ds_test(y, x, ..., type = c("ds", "eqp"), lambda = 1, alpha = 1, rounds = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds_test_+3A_y">y</code></td>
<td>
<p>A numeric vector of data values.</p>
</td></tr>
<tr><td><code id="ds_test_+3A_x">x</code></td>
<td>
<p>Either an integer vector of data values, from 0 to <code class="reqn">K-1</code>, or a character string naming a cumulative distribution function or an actual cumulative distribution function such as <code>pnorm</code>. Only continuous CDFs are valid.</p>
</td></tr>
<tr><td><code id="ds_test_+3A_...">...</code></td>
<td>
<p>Parameters of the distribution specified (as a character string) by <code>x</code>.</p>
</td></tr>
<tr><td><code id="ds_test_+3A_type">type</code></td>
<td>
<p>Methods applied for dynamic slicing. &quot;<code>ds</code>&quot; (default) stands for original dynamic slicing scheme. &quot;<code>eqp</code>&quot; stands for dynamic slicing scheme with <code class="reqn">n^{1/2}</code>-resolution (for <em>K</em>-sample test, <code class="reqn">K &gt; 1</code>) or <code class="reqn">n</code>-resolution (for one-sample test).</p>
</td></tr>
<tr><td><code id="ds_test_+3A_lambda">lambda</code></td>
<td>
<p>Penalty for introducing an additional slice, which is used to avoid making too many slices. It corresponds to the type I error under the scenario that the two variables are independent. <code>lambda</code> should be greater than 0.</p>
</td></tr>
<tr><td><code id="ds_test_+3A_alpha">alpha</code></td>
<td>
<p>Penalty required for &quot;<code>ds</code>&quot; type in one-sample test. It penalizes both the width and the number of slices to avoid too many slices and degenerate slice (interval). <code>alpha</code> should be greater than 1.</p>
</td></tr>
<tr><td><code id="ds_test_+3A_rounds">rounds</code></td>
<td>
<p>Number of permutations for estimating empirical <em>p</em>-value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is an integer vector, <code>ds_test</code> performs <em>K</em>-sample test (<code class="reqn">K &gt; 1</code>).
</p>
<p>Under this scenario, suppose that there are observations <code>y</code> drawn from some <em>continuous</em> populations. Let <code>x</code> be a vector that stores values of indicator of samples from different populations, <em>i.e.</em>, <code>x</code> has values <code class="reqn">0, 1, \ldots, K-1</code>. The null hypothesis is that these populations have the same distribution.
</p>
<p>If <code>x</code> is a character string naming a continuous (cumulative) distribution function, <code>ds_test</code> performs one-sample test with the null hypothesis that the distribution function which generated <code>y</code> is distribution <code>x</code> with parameters specified by <code class="reqn">\ldots</code>. The parameters specified in <code class="reqn">\ldots</code> must be pre-specified and not estimated from the data.
</p>
<p>Only empirical <em>p</em>-values are available by specifying the value of parameter <code>rounds</code>, the number of permutation. <code>lambda</code> and <code>alpha</code> (for one-sample test with type &quot;<code>ds</code>&quot;) contributes to <em>p</em>-value.
</p>
<p>The procedure of choosing parameter <code>lambda</code> was described in Jiang, Ye &amp; Liu (2015). Refer to dataset <code>ds_type_one_error</code> in this package for the empirical relationship of <code>lambda</code>, sample size and type I error.
</p>


<h3>Value</h3>

<p>A list with class &quot;<code>htest</code>&quot; containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>The value of the dynamic slicing statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <em>p</em>-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A character string giving the name(s) of the data.</p>
</td></tr>
<tr><td><code>slices</code></td>
<td>
<p>Slicing strategy that maximize dynamic slicing statistic in <em>K</em>-sample test. Each row stands for a slice. Each column except the last one stands for the number of observations take each value in each slice. The last column is the number of observations in each slice <em>i.e.</em>, the sum of the first column to the <em>k</em>th column.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jiang, B., Ye, C. and Liu, J.S. Non-parametric <em>K</em>-sample tests via dynamic slicing. <em>Journal of the American Statistical Association</em>, 110(510): 642-653, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  One-sample test
n &lt;- 100
mu &lt;- 0.5
y &lt;- rnorm(n, mu, 1)
lambda &lt;- 1.0
alpha &lt;- 1.0
dsres &lt;- ds_test(y, "pnorm", 0, 1, lambda = 1, alpha = 1, rounds = 100)
dsres &lt;- ds_test(y, "pnorm", 0, 1, type = "ds", lambda = 1, alpha = 1)
dsres &lt;- ds_test(y, "pnorm", 0, 1, type = "eqp", lambda = 1, rounds = 100)
dsres &lt;- ds_test(y, "pnorm", 0, 1, type = "eqp", lambda = 1)

##  K-sample test
n &lt;- 100
mu &lt;- 0.5
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))

##  generate x in this way:
x &lt;- c(rep(0, n), rep(1, n))
x &lt;- as.integer(x)

##  or in this way:
x &lt;- c(rep("G1", n), rep("G2", n))
x &lt;- relabel(x)

lambda &lt;- 1.0
dsres &lt;- ds_test(y, x, lambda = 1, rounds = 100)
dsres &lt;- ds_test(y, x, type = "eqp", lambda = 1, rounds = 100)
</code></pre>

<hr>
<h2 id='ds_type_one_error'>
Relationship between penalty and Type I error
</h2><span id='topic+ds_type_one_error'></span>

<h3>Description</h3>

<p>Because there are not close form relationship between the value of slicing penalty and Type-I error rate of dynamic slicing. Empirical relationship between them is provided in this dataset. Each row corresponds to the value of penalty. Each column corresponds to the total number of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ds_type_one_error)</code></pre>


<h3>Format</h3>

<p>A list on the following 2 variables.
</p>

<dl>
<dt><code>two_sample</code></dt><dd><p>a matrix.</p>
</dd>
<dt><code>three_sample</code></dt><dd><p>a matrix.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ds_type_one_error)
</code></pre>

<hr>
<h2 id='export_res'>
Export gene set analysis result
</h2><span id='topic+export_res'></span>

<h3>Description</h3>

<p>Export gene set analysis result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  export_res(ds_gsa_obj, file = "", ..., cutoff = 1, decreasing = FALSE, 
             type = c("name", "size", "DS", "p-value", "FDR", "slice"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_res_+3A_ds_gsa_obj">ds_gsa_obj</code></td>
<td>
<p>Object returned by <code>ds_gsa</code> function.</p>
</td></tr>
<tr><td><code id="export_res_+3A_file">file</code></td>
<td>
<p>Either a character string naming a file or a connection open for writing. &quot;&quot; indicates output to the console.</p>
</td></tr>
<tr><td><code id="export_res_+3A_...">...</code></td>
<td>
<p>Parameters of <code>write.table</code>.</p>
</td></tr>
<tr><td><code id="export_res_+3A_cutoff">cutoff</code></td>
<td>
<p>threshold for selecting gene set analysis result according to parameter <code>type</code>.</p>
</td></tr>
<tr><td><code id="export_res_+3A_decreasing">decreasing</code></td>
<td>
<p>Ranking results decreasingly (default) or ascendingly.</p>
</td></tr>
<tr><td><code id="export_res_+3A_type">type</code></td>
<td>
<p>Opitons for ranking results by gene set name (&ldquo;name&rdquo;), gene set size (&ldquo;size&rdquo;), value of dynamic slicing statistic (&quot;<code>DS</code>&quot;), <em>p</em>-value (&quot;<code>p-value</code>&quot;), false discovery rate (&quot;<code>FDR</code>&quot;) or number of slices (&quot;<code>slice</code>&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usage of <code>export_res</code> is similar to <code>write.table</code>.
</p>


<h3>See Also</h3>

<p>The &lsquo;R Data Import/Export&rsquo; manual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ds_gsa_obj &lt;- ds_gsa(expdat, geneset, label, fc, lambda = 1.2, bycol = TRUE,
                 minsize = 15, maxsize = 500, randseed = 11235, rounds = 100)
export_res(ds_gsa_obj, "ds_gsa_res.txt", sep = "\t", type = "DS", cutoff = 0,
           row.names = F, col.names = T, quote = F, append = F)

## End(Not run)
</code></pre>

<hr>
<h2 id='gsa_exp'>
Gene expression matrix in gene set analysis
</h2><span id='topic+gsa_exp'></span>

<h3>Description</h3>

<p>P53 NCI-60 data set provided by Subramanian <em>et al</em>., (2005). A gene expression matrix whose rows correspond to genes and column correspond to samples. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gsa_exp)</code></pre>


<h3>Format</h3>

<p>A matrix.
</p>


<h3>Source</h3>

<p>http://www.broadinstitute.org/gsea
</p>


<h3>References</h3>

<p>Subramanian, A., Tamayo, P., Mootha, V. K., <em>et al</em>. Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, 2005, 102(43): 15545-15550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gsa_exp)
</code></pre>

<hr>
<h2 id='gsa_label'>
Sample labels in gene set analysis
</h2><span id='topic+gsa_label'></span>

<h3>Description</h3>

<p>P53 NCI-60 data set provided by Subramanian <em>et al</em>., (2005). A list with phenotypes vector and a vector of sample label values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gsa_label)</code></pre>


<h3>Format</h3>

<p>A list on the following 2 variables.
</p>

<dl>
<dt><code>pheotype</code></dt><dd><p>a character vector contains two genotypes.</p>
</dd>
<dt><code>value</code></dt><dd><p>a numeric vector contains sample label 0 and 1, where 0 and 1 stands for &ldquo;MUT&rdquo; and &ldquo;WT&rdquo;, respectively.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.broadinstitute.org/gsea
</p>


<h3>References</h3>

<p>Subramanian, A., Tamayo, P., Mootha, V. K., <em>et al</em>. Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, 2005, 102(43): 15545-15550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gsa_label)
</code></pre>

<hr>
<h2 id='gsa_set'>
Gene set list in gene set analysis
</h2><span id='topic+gsa_set'></span>

<h3>Description</h3>

<p>Gene set provided by Subramanian <em>et al</em>., (2005). A list with gene set vector, gene set description vector and a list whose elements are vector of genes in each gene set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gsa_set)</code></pre>


<h3>Format</h3>

<p>A list with three elements: gene set name, gene set description and genes in gene set.
</p>

<dl>
<dt><code>set_name</code></dt><dd><p>a character vector of gene set name.</p>
</dd>
<dt><code>set_description</code></dt><dd><p>a character vector of gene set description.</p>
</dd>
<dt><code>set_description</code></dt><dd><p>a list whose elements are vector. Each of them contains genes in each gene set.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.broadinstitute.org/gsea
</p>


<h3>References</h3>

<p>Subramanian, A., Tamayo, P., Mootha, V. K., <em>et al</em>. Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles. <em>Proceedings of the National Academy of Sciences of the United States of America</em>, 2005, 102(43): 15545-15550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gsa_set)
</code></pre>

<hr>
<h2 id='load_cls'>
Load phenotype file
</h2><span id='topic+load_cls'></span>

<h3>Description</h3>

<p>Load phenotype file from .cls file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  load_cls(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_cls_+3A_file">file</code></td>
<td>
<p>Name of .cls file which contains phenotypes of samples, separared by spaces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>pheotype</code></td>
<td>
<p>Pheotype of samples</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>A vector with encoded value of pheotypes. If there is <em>k</em> pheotypes, it takes values <code class="reqn">0, 1, \ldots, k-1</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Pheotype files are available after registration at Broad institute GSEA website
# http://www.broadinstitute.org/gsea

## Not run: 
filename &lt;- "P53.cls"
label &lt;- load_cls(filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_gct'>
Load gene expression file
</h2><span id='topic+load_gct'></span>

<h3>Description</h3>

<p>Load gene expression data from .gct file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  load_gct(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_gct_+3A_file">file</code></td>
<td>
<p>Name of .gct file which contains gene expression data. Should be a tab-separated text file. The first row is version and the second is the dimension of expression matrix. There is an expression matrix from the third row to the end. The third row is column name of expression matrix. The first column is gene symbol and the second is the description of gene. For the remaining rows and columns, each row is a gene and each column is a sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with row names and column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gene expression files are available after registration at Broad institute GSEA website
# http://www.broadinstitute.org/gsea

## Not run: 
filename &lt;- "P53.gct"
expdat &lt;- load_gct(filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='load_gmt'>
Load gene set file
</h2><span id='topic+load_gmt'></span>

<h3>Description</h3>

<p>Load gene set from .gmt file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  load_gmt(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_gmt_+3A_file">file</code></td>
<td>
<p>Name of .gmt file which contains gene sets. Should be a tab-separated text file. Each row is a gene set. The first column is gene set name and the second is its description. Remaining columns are gene symbols of genes in this set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>set_name</code></td>
<td>
<p>Vector of gene set names.</p>
</td></tr>
<tr><td><code>set_description</code></td>
<td>
<p>Vector of gene set descriptions.</p>
</td></tr>
<tr><td><code>gene_symbol</code></td>
<td>
<p>List of gene symbols in each gene set.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Gene set files are available after registration at Broad institute GSEA website
# http://www.broadinstitute.org/gsea

## Not run: 
filename &lt;- "C2.gmt"
geneset &lt;- load_gmt(filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='rank_by_s2n'>
Ranking genes by signal to noise ratio
</h2><span id='topic+rank_by_s2n'></span>

<h3>Description</h3>

<p>Ranking genes by signal to noise ratio according to their expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rank_by_s2n(expmat, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_by_s2n_+3A_expmat">expmat</code></td>
<td>
<p>A matrix of gene expression data. Each row is a gene and each column is a sample.</p>
</td></tr>
<tr><td><code id="rank_by_s2n_+3A_label">label</code></td>
<td>
<p>An integer vector of encoded pheotypes. Its value is 0 and 1. Its length should match the column number of expression matrix.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A vector of rank of each gene according to signal to noise ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expdat &lt;- matrix(rnorm(500), nrow = 25, ncol = 20)
label &lt;- rep(c(0, 1), 10)
ranklist &lt;- rank_by_s2n(expdat, label)
</code></pre>

<hr>
<h2 id='relabel'>
Reassigning values of categorical variable
</h2><span id='topic+relabel'></span>

<h3>Description</h3>

<p>Reassigning values of categorical variable. It is used for generating legal value of categorical variable before applying dynamic slicing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  relabel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relabel_+3A_x">x</code></td>
<td>
<p>A vector of data values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with values range from 0 to k (k &gt; 0).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_test">ds_test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
x &lt;- c(rep("G1", n), rep("G2", n))
x &lt;- relabel(x)

x &lt;- c(rep(4, n), rep(5, n), rep(NA, n))
x &lt;- relabel(x)
</code></pre>

<hr>
<h2 id='slice_show'>
Show the slicing result
</h2><span id='topic+slice_show'></span>

<h3>Description</h3>

<p>Showing slicing result and plotting counts of observations in each slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slice_show(slices_obj, main="Counts in each slice", xlab="Slices", ylab="Percentage")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slice_show_+3A_slices_obj">slices_obj</code></td>
<td>
<p>A matrix stores slicing strategy. It is a component of object returned by function <code>dslice_k</code> or <code>dslice_eqp_k</code>.</p>
</td></tr>
<tr><td><code id="slice_show_+3A_main">main</code></td>
<td>
<p>An overall title for the plo</p>
</td></tr>
<tr><td><code id="slice_show_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis</p>
</td></tr>
<tr><td><code id="slice_show_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &ldquo;ggplot&rdquo; object which illustrates details of slicing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ds_k">ds_k</a></code>, <code><a href="#topic+ds_eqp_k">ds_eqp_k</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
mu &lt;- 0.5
y &lt;- c(rnorm(n, -mu, 1), rnorm(n, mu, 1))
x &lt;- c(rep(0, n), rep(1, n))
x &lt;- x[order(y)]
xdim &lt;- max(x) + 1
lambda &lt;- 1.0
dsres &lt;- ds_k(x, xdim, lambda, slice = TRUE)

ds_show &lt;- slice_show(dsres$slices)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
