<!DOCTYPE html><html lang="en"><head><title>Help for package R6DS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {R6DS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#R6DS'><p>R6DS: provides reference classes implementing some useful data stuctures.</p></a></li>
<li><a href='#RBST'><p>The RBST reference class</p></a></li>
<li><a href='#RDeque'><p>The RDeque reference class</p></a></li>
<li><a href='#RDict'><p>The RDict reference class</p></a></li>
<li><a href='#RDLL'><p>The RDLL reference class</p></a></li>
<li><a href='#RQueue'><p>The RQueue reference class</p></a></li>
<li><a href='#RSet'><p>The RSet reference class</p></a></li>
<li><a href='#RStack'><p>The RStack reference class</p></a></li>
<li><a href='#version'><p>Show the version number of some information.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R6 Reference Class Based Data Structures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides reference classes implementing some useful data structures.
    The package implements these data structures by using the reference class R6.
    Therefore, the classes of the data structures are also reference classes which means that their instances are passed by reference.
    The implemented data structures include stack, queue, double-ended queue, doubly linked list, set, dictionary and binary search tree.
    See for example <a href="https://en.wikipedia.org/wiki/Data_structure">https://en.wikipedia.org/wiki/Data_structure</a> for more information about the data structures.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yukai-yang/R6DS">https://github.com/yukai-yang/R6DS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yukai-yang/R6DS/issues">https://github.com/yukai-yang/R6DS/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-21 10:53:14 UTC; yyang</td>
</tr>
<tr>
<td>Author:</td>
<td>Yukai Yang <a href="https://orcid.org/0000-0002-2623-8549"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yukai Yang &lt;yukai.yang@statistik.uu.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-21 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='R6DS'>R6DS: provides reference classes implementing some useful data stuctures.</h2><span id='topic+R6DS'></span><span id='topic+R6DS-package'></span>

<h3>Description</h3>

<p>R6DS stands for <span class="pkg">R6</span> class based Data Structures.
The package provides reference classes implementing some useful data stuctures.
</p>


<h3>Details</h3>

<p>Some data structures are quite useful in solving some programming problems,
as they offer great convenience and are the keys to implement some algorithms.
</p>
<p>The package implements these data structures by using the reference class <span class="pkg">R6</span>.
Each class defined in the package represents a certain data structure,
and it inherits the R6 reference class which means that it is also a reference class.
</p>
<p>In order to create an instance of the R6 type reference class, you will have to use its <code>new</code> method as follows:
</p>
<p><code>instance &lt;- RStack$new()</code>
</p>
<p>where <code>RStack</code> is an R6 type reference class.
</p>
<p>The reference class has the feature that each time when you pass (or assign) an instance of the reference class to somewhere,
it is not pass-by-value but pass-by-reference. For example, suppose there is an instance of the reference class <code>x</code> who has an attribute <code>x$y</code>.
If you pass it to a function <code>func</code> by using <code>func(x)</code>, the function will not copy x but pass it as a reference.
Inside the function <code>func</code>, if there is a sentence like
</p>
<p><code>x$y &lt;- 0</code>
</p>
<p>then the attribute <code>y</code> of the global <code>x</code> outside the function will be changed to zero.
</p>
<p>Of course you can copy the instance of a reference class, but you have to use its <code>clone</code> method:
</p>
<p><code>new_instance &lt;- instance$clone()</code>
</p>
<p>Notice that all the classes in the package use instances of some other R6 type reference class as their members.
This implies that, according to the rule of the R6 family, you have to add <code>deep = TRUE</code> when you <code>clone</code> their instances:
</p>
<p><code>new_instance &lt;- instance$clone(deep=TRUE)</code>
</p>
<p>and then you can successfully copy them.
</p>
<p>The classes in the package are designed in the way that you cannot get the access to their members directly,
as they are declared to be private.
Instead, you have to use their methods (member functions) to get them.
In the following, a complete list of these classes and their methods in common are presented.
Each class has its own methods, and for details of these class-specific methods please refer to their help documents.
</p>
<p>Some methods are declared to be &quot;active&quot;, or active method, which means that, when you call them, you do not need to use parenthesis.
For example, the <code>size</code> method is a common active method of all classes in the package. When you call it, you do
</p>
<p><code>instance$size</code>
</p>
<p>So it looks pretty like a member attribute, but actually not.
</p>


<h3>How to Use the Package</h3>

<p>All classes in the package are declared to be non-portable and non-class (R6 standards),
which means that the user of the package cannot inherit them.
</p>
<p>The user can create and use instances of these classes,
and the instances can contain any R objects (vector, matrix, factor, data.frame, list and etc.) as their values.
</p>
<p>The author suggest that the user of the package puts the instances of these classes inside other classes
to be their members.
</p>
<p>But it is still possible to inherit the classes in the package.
To this end, the user can copy and paste the source code of the package.
</p>


<h3>Author and Maintainer</h3>

<p>Yukai Yang
</p>
<p>Department of Statistics, Uppsala University
</p>
<p><a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>References</h3>

<p>For the details about the data structures, see <a href="https://en.wikipedia.org/wiki/Data_structure">Data Structure at Wikipedia</a>.
</p>


<h3>Classes Available in the Package</h3>

<p><code><a href="#topic+RStack">RStack</a></code> The RStack reference class implements the data structure stack.
</p>
<p><code><a href="#topic+RQueue">RQueue</a></code> The RQueue reference class implements the data structure queue.
</p>
<p><code><a href="#topic+RDeque">RDeque</a></code> The RDeque reference class implements the data structure double-ended queue.
</p>
<p><code><a href="#topic+RDLL">RDLL</a></code> The RDLL reference class implements the data structure doubly linked list.
</p>
<p><code><a href="#topic+RSet">RSet</a></code> The RSet reference class implements the data structure set.
</p>
<p><code><a href="#topic+RDict">RDict</a></code> The RDict reference class implements the data structure dictionary.
</p>
<p><code><a href="#topic+RBST">RBST</a></code> The RBST reference class implements the data structure binary search tree.
</p>


<h3>Common Methods of the Classes in the Package</h3>


<dl>
<dt><code>new(..., collapse=NULL)</code></dt><dd>
<p>a method belonging to the class which create an instance of the class.
The method creates a new instance of some class in the package
containing the values in <code>...</code> and <code>collapse</code> as its elements.
</p>
</dd>
<dt><code>toList</code></dt><dd>
<p>an active immutable method of an instance which returns a list containing its elements (a copy).
</p>
<p>Note that <code><a href="#topic+RBST">RBST</a></code> has multiple versions of the <code>toList</code> methods.
</p>
</dd>
<dt><code>is_empty()</code></dt><dd>
<p>a method which returns a boolean showing if the instance is empty.
</p>
</dd>
<dt><code>size</code></dt><dd>
<p>an active immutable method of an instance to return its size (like the <code>length</code> of an R vector).
</p>
</dd>
<dt><code>release()</code></dt><dd>
<p>a method of an instance which does the garbage collection and releases the redundant memory occupation.
</p>
<p>Note that <code><a href="#topic+RDict">RDict</a></code> <code><a href="#topic+RBST">RBST</a></code> do not have this methhod.
</p>
</dd>
</dl>


<hr>
<h2 id='RBST'>The RBST reference class</h2><span id='topic+RBST'></span>

<h3>Description</h3>

<p>The RBST reference class implements the data structure binary search tree (BST).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RBST
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A BST is a particular type of container storing elements in nodes by following a binary tree structure.
So the element is the value of the corresponding node in the tree.
</p>
<p>The BST has one root on top, which is the first node of the tree,
and each node in the BST has at most two sub-nodes (left sub-node and right sub-node) which can be the roots of their sub-trees.
</p>
<p>The BST should be equipped with the &quot;&lt;&quot; and &quot;=&quot; operations such that any two nodes in the tree can be compared.
Note that, by the definitions of the &quot;&lt;&quot; and &quot;=&quot; operations, the operation &quot;&gt;&quot; is also defined.
</p>
<p>The BST structure follows strictly the rules that, for a certain node in the tree,
any nodes in its left sub-tree must be strictly smaller (&quot;&lt;&quot;) than it,
any nodes in its right sub-tree must be strictly larger (&quot;&gt;&quot;) than it,
and any two nodes in the tree must not be equal (no &quot;=&quot;).
</p>
<p>Therefore, the BST is a special set or dictionary equipped with &quot;&lt;&quot;, &quot;&gt;&quot; operations.
</p>
<p>When you create a new RBST instance, you have to input two functions which defines
the bodies of the two private methods <code>lessthan</code> and <code>equal</code>.
The RBST instance then will use them to make comparison and decide where to put new nodes (build the BST).
</p>
<p>Each time a new node is inserted, the BST algorithm finds its location on the tree.
Then you can imagine, the BST is efficient in maintaining (inserting and deleting), searching and traversing the tree.
An average O(log n) time complexity can be achieved by applying the BST algorithm.
</p>
<p>A very important fact is that, the RBST only compares the nodes by using
the function <code>equal</code>.
So it will regard any two nodes identical if <code>equal</code> returns <code>TRUE</code>,
even though they are different.
</p>
<p>We see that the BST can also be regarded as a dictionary,
as the key of the dictionary is actually the value input into <code>insert</code>, <code>delete</code> and <code>search_for</code>.
</p>
<p>The traversals of the BST (in-order, pre-order, and post-order) are implemented as well.
A <code>callback</code> function can be input into the <code>traverse</code> function
to specify how to treat the traversed nodes.
By default (if you do not input anything here) the <code>traverse</code> function
prints the traversed nodes.
But of course you can, for example, store them by changing the <code>callback</code> function,
see the examples below.
</p>
<p>The elements in the BST are not necessarily to be of the same type,
and they can even contain functions.
</p>


<h3>References</h3>

<p>For the details about the BST data structure, see <a href="https://en.wikipedia.org/wiki/Binary_search_tree">BST at Wikipedia</a>.
</p>


<h3>Class Method</h3>

<p>The class method belongs to the class.
</p>

<dl>
<dt><code>new(lessthan, equal, ..., collapse=NULL)</code></dt><dd>
<p>The <code>new</code> method creates a new instance of the RBST class
containing the values in <code>...</code> and <code>collapse</code> as its nodes.
</p>
<p>The argument <code>lessthan</code> takes a function defining the &quot;&lt;&quot; operation,
and the argument <code>equal</code> takes a function defining the &quot;=&quot; operation.
Both of the functions takes two values of the nodes in the tree and return
a boolean.
</p>
<p><code>lessthan</code> can take, for example, the form
</p>
<p><code>lessthan &lt;- function(x, y) return(x$num &lt; y$num)</code>
</p>
<p>where <code>x</code> and <code>y</code> are values of two nodes in the tree
with the attribute <code>num</code>.
</p>
<p><code>equal</code> can take, for example, the form
</p>
<p><code>equal &lt;- function(x, y) return(x$num == y$num)</code>
</p>
<p>where <code>x</code> and <code>y</code> are values of two nodes in the tree
with the attribute <code>num</code>.
</p>
</dd>
</dl>



<h3>Immutable Methods</h3>

<p>The immutable methods do not change the nodes of the instance.
</p>

<dl>
<dt><code>toList</code>, <code>toList_pre</code>, and <code>toList_post</code></dt><dd>
<p>The active method <code>toList</code> returns a list containing its elements (a copy).
</p>
<p>The order of the list can be &quot;traverse-in-order&quot; by using <code>toList</code>,
&quot;traverse-pre-order&quot; by using <code>toList_pre</code>,
or &quot;traverse-post-order&quot; by using <code>toList_post</code>
</p>
</dd>
<dt><code>traverse(mode, callback=function(item){print(item)}, ...)</code></dt><dd>
<p>The <code>traverse</code> method takes at least two arguments which are <code>mode</code> and <code>callback</code>.
</p>
<p>The <code>mode</code> takes a value in one of the three strings
<code>"in"</code>, <code>"pre"</code>, and <code>"post"</code> which indicate
<em>traverse-in-order</em>, <em>traverse-pre-order</em>, and <em>traverse-post-order</em>, respectively.
</p>
<p>The <code>callback</code> takes a function
specifying how to handle the value of each node in the tree.
By default, <code>callback</code> prints the nodes by using the <code>print</code> function.
</p>
<p>Note that the first argument of the <code>callback</code> function must be the value of the node
but not the node itself!
</p>
<p><code>callback</code> can have two or more arguments.
The method also takes <code>...</code> as the additional arguments for the <code>callback</code> function if any.
</p>
</dd>
<dt><code>search_for(val)</code></dt><dd>
<p>The method <code>search_for</code> uses the <code>equal</code> function
to compare <code>val</code> with the nodes in BST.
It returns the value of the node if the node is <code>equal</code> to the given value, and <code>NULL</code> otherwise.
</p>
<p>As the tree has been structured strictly by following the rules introduced above,
there is no need to search the whole tree in most cases, and the maintaining and searching are efficient.
</p>
</dd>
<dt><code>min</code></dt><dd>
<p>The active method <code>min</code> returns the smallest node in the tree,
and <code>NULL</code> if the tree is empty.
</p>
</dd>
<dt><code>max</code></dt><dd>
<p>The active method <code>min</code> returns the largest node in the tree,
and <code>NULL</code> if the tree is empty.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods changes the nodes of the instance.
</p>

<dl>
<dt><code>insert(..., collapse=NULL)</code></dt><dd>
<p>The method <code>insert</code> inserts new nodes into the tree.
If some nodes are <code>equal</code> to the nodes in the tree,
they will not be inserted.
</p>
</dd>
<dt><code>delete(val)</code></dt><dd>
<p>The method <code>delete</code> removes the node which is <code>equal</code> to <code>val</code>.
If the node is found, then it will be removed and the function returns a <code>TRUE</code>,
and if the node is not found, then it will do nothing and returns a <code>FALSE</code>,
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# you have to define two functions for "&lt;" and "="
lessthan &lt;- function(x, y) return(x$key &lt; y$key)
equal &lt;- function(x, y) return(x$key == y$key)
# remember that the nodes in the BST have the "key" variable
# and it is numeric

# to create a new instance of the class
bst &lt;- RBST$new(lessthan=lessthan, equal=equal)

# of course you can start to push elements when creating the instance
bst &lt;- RBST$new(lessthan=lessthan, equal=equal,
    list(key=5, val="5"), collapse=list(list(key=3,val="3"), list(key=9,val="9")))
# the following sentence is equivalent to the above
bst &lt;- RBST$new(lessthan=lessthan, equal=equal,
    list(key=5, val="5"), list(key=3,val="3"), list(key=9,val="9"))
# where the three lists are inserted into the BST

### maintaining

bst$insert(list(key=5, val="6"))
bst$insert(list(key=6, val="5"))

bst$delete(list(key=7, val="7"))
# FALSE
bst$delete(list(key=6, val="7"))
# TRUE and delete list(key=6, val="5")
# though val are different

### searching

bst$search_for(list(key=0, val="0"))
# NULL
bst$search_for(list(key=5, val="0"))
# the BST has a node whose key is 5

### min and max

# min and max are two active functions
# so the parenthesis is not needed
bst$min
bst$max

### toList

bst$toList
bst$toList_pre
bst$toList_post

### traversing

# by default, the callback function prints the nodes
# but you can re-define the callback function
queue &lt;- RQueue$new()
callback &lt;- function(item)queue$enqueue(item)
# remember that RQueue is a reference class
# so the new callback will store the traversed nodes

bst$traverse(mode = "in", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}
bst$traverse(mode = "in", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

# pre-order traversing
bst$traverse(mode = "pre", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

# post-order traversing
bst$traverse(mode = "post", callback=callback)
tmp = queue$dequeue(); print(tmp)
while(!is.null(tmp)) {tmp = queue$dequeue(); print(tmp)}

</code></pre>

<hr>
<h2 id='RDeque'>The RDeque reference class</h2><span id='topic+RDeque'></span>

<h3>Description</h3>

<p>The RDeque reference class implements the data structure double-ended queue (deque).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDeque
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A deque is an ordered list of elements generalizing the queue data structure.
One can append and pop (return and remove) elements from both sides
(left and right, front and rear) of the deque.
</p>
<p>The elements in the deque are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the deque data structure, see <a href="https://en.wikipedia.org/wiki/Double-ended_queue">Deque at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable methods do not change the instance.
</p>

<dl>
<dt><code>peekleft()</code></dt><dd>
<p>This method returns the leftmost (front) element of the deque.
It returns <code>NULL</code> if the deque is empty.
</p>
</dd>
<dt><code>peek()</code></dt><dd>
<p>This method returns the rightmost (rear) element of the deque.
It returns <code>NULL</code> if the deque is empty.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>appendleft(..., collapse=NULL)</code></dt><dd>
<p>The <code>appendleft</code> method appends the elements in <code>...</code> and <code>collapse</code>
into the deque to the left (front).
</p>
<p>Note that if you append elements in this order:
</p>
<p><code>instance$appendleft(elem1, elem2, elem3)</code>
</p>
<p>The order of them inside the deque will be
</p>
<p><code>elem3, elem2, elem1, ...</code>
</p>
<p>and <code>elem3</code> will be the new front of the deque.
</p>
</dd>
<dt><code>append(..., collapse=NULL)</code></dt><dd>
<p>The <code>append</code> method appends the elements in <code>...</code> and <code>collapse</code>
into the deque to the right (rear).
</p>
</dd>
<dt><code>popleft()</code></dt><dd>
<p>The <code>popleft</code> method returns and removes the leftmost (front) element in the deque.
It returns <code>NULL</code> if the deque is empty.
</p>
</dd>
<dt><code>pop()</code></dt><dd>
<p>The <code>pop</code> method returns and removes the rightmost (rear) element in the deque.
It returns <code>NULL</code> if the deque is empty.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+RStack">RStack</a>, <a href="#topic+RQueue">RQueue</a>, and <a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# to create a new instance of the class
deque &lt;- RDeque$new()

# the previous RDeque instance will be removed if you run
deque &lt;- RDeque$new(0, 1, 2, collapse=list(3, 4))
# the following sentence is equivalent to the above
deque &lt;- RDeque$new(0, 1, 2, 3, 4)
# where the numbers 0, 1, 2, 3, 4 are enqueued into the deque

### append and appendleft

# it can be one single element
deque$append(5)
# it can be several elements separated by commas
# note the whole list will be one element of the deque
# because it is not passed through the collapse argument
deque$append(list(a=10,b=20), "Hello world!")
# the collapse argument takes a list whose elements will be collapsed
# but the elements' names will not be saved
deque$append(collapse = list(x=100,y=200))
# they can be used together
deque$append("hurrah", collapse = list("RDeque",300))

# this string will be the new head
deque$appendleft("a string")
# we can update the head by
deque$appendleft("string3","string2","string1")
# "string1" will be the leftmost

### peekleft and peek
deque$peekleft()
# "string1"
deque$peek()
# 300

### popleft and pop

val &lt;- deque$popleft()
# "string1"
val &lt;- deque$pop()
# 300

# then we keep dequeuing!
while(!is.null(val)) val &lt;- deque$pop()

</code></pre>

<hr>
<h2 id='RDict'>The RDict reference class</h2><span id='topic+RDict'></span>

<h3>Description</h3>

<p>The RDict reference class implements the data structure dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDict
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A dictionary is a collection of (key, value) pairs as its elements
such that each possible key appears at most once in the collection.
The dictionary data structure does not care the order of the elements.
</p>
<p>The keys of the elements in the dictionary are stored as strings.
The values in the dictionary are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the dictionary data structure, see <a href="https://en.wikipedia.org/wiki/Associative_array">Dictionary at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable methods do not change the instance.
</p>

<dl>
<dt><code>has(key)</code></dt><dd>
<p>The method <code>has</code> returns a boolean indicating
if the dictionary contains the element with the key &quot;<code>key</code>&quot;.
</p>
<p>Both of the following two sentences are equivalent:
</p>
<p><code>instance$has("keyname")</code>
</p>
<p><code>instance$has(keyname)</code>
</p>
</dd>
<dt><code>get(key)</code></dt><dd>
<p>The method <code>get</code> returns the value of the element whose key is <code>"key"</code>.
It returns <code>NULL</code> if no element is found.
</p>
</dd>
<dt><code>keys</code></dt><dd>
<p>The method <code>keys</code> returns a vector of the keys in the dictionary.
</p>
</dd>
<dt><code>values</code></dt><dd>
<p>The method <code>values</code> returns a list of the values in the dictionary (unnamed list).
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>add(key, val)</code></dt><dd>
<p>The method <code>add</code> adds a new element (the pair key and val) into the dictionary.
It will not add element with the key which exists already in the dictionary.
It returns a boolean showing if the adding is successful.
</p>
<p>Note that any element with the key <code>""</code> (empty string) will not be added.
</p>
</dd>
<dt><code>add_multiple(..., collapse=NULL)</code></dt><dd>
<p>The method <code>add_multiple</code> adds new elements into the dictionary.
It will not add element with the key which exists already in the dictionary.
</p>
<p>The argument <code>...</code> stands for any input with the form
</p>
<p><code>keyname1 = value2, keyname2 = value2, ...</code>
</p>
<p>Therefor, the input can take the form
</p>
<p><code>instance$add(key1=1, key2="hello", key3=list(1))</code>
</p>
<p>and the keys of the elements will be strings like <code>"key1"</code>,
<code>"key2"</code>, and <code>"key3"</code>, respectively.
</p>
<p>If the <code>keyname</code> is missing, the <code>value</code> will not be added.
</p>
</dd>
<dt><code>delete(key)</code></dt><dd>
<p>The method <code>delete</code> removes the element with the key <code>key</code> in the dictionary.
</p>
<p>Suppose that the key name of the element that you want to remove is &quot;keyname&quot;.
Both of the following two sentences are valid:
</p>
<p><code>instance$delete("keyname")</code>
</p>
<p><code>instance$delete(keyname)</code>
</p>
<p>It returns a boolean showing if the element is found and deleted.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# to create a new instance of the class
dict &lt;- RDict$new()

# of course you can start to add elements when creating the instance
dict &lt;- RDict$new(id0001=1, id0002=2, collapse=list(id0003=3, id0004=4))
# the following sentence is equivalent to the above
dict &lt;- RDict$new(id0001=1, id0002=2, id0003=3, id0004=4)
# where the three lists are inserted into the dictionary

### immutable methods

dict$keys
dict$values

dict$has(id0001)
dict$has("id0005")
# TRUE as it has the key attribute

dict$get(id0006)
dict$get("id0002")

### mutable methods

dict$add(id0005, 5)

dict$add(key="id0006", val=6)

dict$delete(id0001)

</code></pre>

<hr>
<h2 id='RDLL'>The RDLL reference class</h2><span id='topic+RDLL'></span>

<h3>Description</h3>

<p>The RDLL reference class implements the data structure doubly linked list (DLL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RDLL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A doubly linked list is an ordered list of elements with multiple operations.
The DLL is a powerful sequantial data structure in the sense that
it can be regarded as the generalized version of the data structures stack, queue, deque.
</p>
<p>The class <code>RDLL</code> inherits the <code><a href="#topic+RDeque">RDeque</a></code> class,
and therefor it has all the methods that <code><a href="#topic+RDeque">RDeque</a></code> has.
</p>
<p>The DLL is much more friendly and flexible as it offers more useful methods to help the user get access to its elements
than <code><a href="#topic+RStack">RStack</a></code>, <code><a href="#topic+RQueue">RQueue</a></code> and <code><a href="#topic+RDeque">RDeque</a></code>.
See below its immutable methods and mutable methods.
</p>
<p>It is worth noting that the classes <code><a href="#topic+RSet">RSet</a></code> inherits the RDLL class,
and therefor it has all the methods that the RDLL has.
</p>
<p>The elements in the DLL are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the DLL data structure, see <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">DLL at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable methods do not change the instance.
</p>

<dl>
<dt><code>show(callback=function(val){print(val)}, ...)</code></dt><dd>
<p>The <code>show</code> method takes a funtion input (argument <code>callback</code>)
specifying how to handle the elements in the DLL.
It also takes <code>...</code> as the additional arguments for the <code>callback</code> function if any.
</p>
<p>By default, the <code>show</code> method prints the elements by using the <code>print</code> function.
</p>
<p><code>callback=function(val){print(val)}</code>
</p>
<p>You can see that <code>show</code> is powerful as it makes it possible to freely manipulate the elements in the DLL.
For example, you can define
</p>
<p><code>func &lt;- function(val, arg1, arg2){ do something here on val with arg1 and arg2 }</code>
</p>
<p>and then
</p>
<p><code>instance$show(func, arg1, arg2)</code>
</p>
<p>And you can also store the elements by using instances of reference classes.
For example,
</p>
<p><code>func &lt;- function(val, queue){ queue$enqueue(val) }</code>
</p>
<p>where <code>queue</code> is an instance of <code>RQueue</code>. The code can be
</p>
<p><code>queue &lt;- RQueue$new()</code>
</p>
<p><code>instance$show(func, queue)</code>
</p>
</dd>
<dt><code>elem_at(index)</code></dt><dd>
<p>It returns the element (a copy) at position <code>index</code> (a positive integer).
<code>index</code> must be a scalar, and if it is a vector of more than one element,
only the first element will be considered.
If the value of <code>index</code> is out of the bounds of the instance,
a <code>NULL</code> will be returned.
</p>
</dd>
<dt><code>peekleft()</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
<dt><code>peek()</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>insert_at(index, val)</code></dt><dd>
<p>This function inserts a new element <code>val</code> at position <code>index</code>.
It returns <code>TRUE</code> if the insertion is successful,
and <code>FALSE</code> if the <code>index</code> is out of the bounds.
It will push all the elements at and after <code>index</code> rightward.
</p>
<p>Thus, suppose that <code>instance</code> is an instance of the class.
</p>
<p><code>insert_at(1, val)</code>
</p>
<p>is equivalent to <code>appendleft</code> in <code><a href="#topic+RDeque">RDeque</a></code>, and
</p>
<p><code>insert_at(instance$size+1, val)</code>
</p>
<p>is equivalent to <code>append</code> in <code><a href="#topic+RDeque">RDeque</a></code>,
<code>push</code> in <code>RStack</code>, and <code>enqueue</code> in <code>RQueue</code>.
</p>
</dd>
<dt><code>remove_at(index)</code></dt><dd>
<p>This function returns and removes the element at position <code>index</code>.
It returns <code>NULL</code> if the <code>index</code> is out of the bounds.
</p>
<p>Thus, suppose that <code>instance</code> is an instance of the class.
</p>
<p><code>remove_at(1, val)</code>
is equivalent to <code>popleft</code> in <code><a href="#topic+RDeque">RDeque</a></code>, and
</p>
<p><code>remove_at(instance$size, val)</code>
is equivalent to <code>pop</code> in <code><a href="#topic+RDeque">RDeque</a></code> and <code>RStack</code>,
and <code>dequeue</code> in <code>RQueue</code>.
</p>
</dd>
<dt><code>appendleft(..., collapse=NULL)</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
<dt><code>append(..., collapse=NULL)</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
<dt><code>popleft()</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
<dt><code>pop()</code></dt><dd>
<p>See <code><a href="#topic+RDeque">RDeque</a></code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+RDeque">RDeque</a>, <a href="#topic+RSet">RSet</a>, and <a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# to create a new instance of the class
dll &lt;- RDLL$new()

# the previous RDLL instance will be removed if you run
dll &lt;- RDLL$new(0, 1, 2, collapse=list(3, 4))
# the following sentence is equivalent to the above
dll &lt;- RDLL$new(0, 1, 2, 3, 4)
# where the numbers 0, 1, 2, 3, 4 are appended into the DLL

### immutable methods

# show
dll$show()

# elem_at
dll$elem_at(1)

# toList
tmp &lt;- dll$toList

### mutable methods

# insert_at
dll$insert_at(1, -1)
dll$insert_at(dll$size+1, "end")

# remove_at
for(iter in 1:dll$size) dll$remove_at(1)

</code></pre>

<hr>
<h2 id='RQueue'>The RQueue reference class</h2><span id='topic+RQueue'></span>

<h3>Description</h3>

<p>The RQueue reference class implements the data structure queue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RQueue
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A queue is an ordered list of elements following the First-In-First-Out (FIFO) principle.
The <code>enqueue</code> method takes elements and add them to the rear terminal position (right) of the queue,
while the <code>dequeue</code> method returns and removes the element in the queue from the front terminal position (left).
</p>
<p>The elements in the queue are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the queue data structure, see <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable method does not change the instance.
</p>

<dl>
<dt><code>peekleft()</code></dt><dd>
<p>This method returns the leftmost (front) element in the queue.
It returns <code>NULL</code> if the queue is empty.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>enqueue(..., collapse=NULL)</code></dt><dd>
<p>The <code>enqueue</code> method enqueues the elements in <code>...</code> and <code>collapse</code> into the queue
(to the right or rear).
</p>
<p>Note that you can input multiple elements.
</p>
</dd>
<dt><code>dequeue()</code></dt><dd>
<p>The <code>dequeue</code> method dequeues (returns and removes) one element (the leftmost or front) fron the queue.
It returns <code>NULL</code> if the queue is empty.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# to create a new instance of the class
queue &lt;- RQueue$new()

# the previous RQueue instance will be removed if you run
queue &lt;- RQueue$new(0, 1, 2, collapse=list(3, 4))
# the following sentence is equivalent to the above
queue &lt;- RQueue$new(0, 1, 2, 3, 4)
# where the numbers 0, 1, 2, 3, 4 are enqueued into the queue

### enqueue elements

# it can be one single element
queue$enqueue(5)
# it can be several elements separated by commas
# note the whole list will be one element of the queue
# because it is not passed through the collapse argument
queue$enqueue(list(a=10,b=20), "Hello world!")
# the collapse argument takes a list whose elements will be collapsed
# but the elements' names will not be saved
queue$enqueue(collapse = list(x=100,y=200))
# they can be used together
queue$enqueue("hurrah", collapse = list("RQueue",300))

### dequeue an element

# dequeue only one element at a time
val &lt;- queue$dequeue()
# then we keep dequeuing!
while(!is.null(val)) val &lt;- queue$dequeue()

</code></pre>

<hr>
<h2 id='RSet'>The RSet reference class</h2><span id='topic+RSet'></span>

<h3>Description</h3>

<p>The RSet reference class implements the data structure set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSet
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A set is a collection of items or elements equipped with the &quot;=&quot; operators
such that any two elements in the set cannot be equal.
The set data structure does not care the order of the elements.
</p>
<p>It should be noticed that, in your design, if any two elements in the set can be easily compared,
by simply, for example, keys, numbers, and etc.,
the RSet should not be recommended due to efficiency reason.
The RSet is suitable for the cases when you have a relatively complex &quot;=&quot; operation
between two elements in the set.
</p>
<p>The class <code>RSet</code> inherits the <code><a href="#topic+RDLL">RDLL</a></code> class,
and therefor it has all the methods that <code><a href="#topic+RDLL">RDLL</a></code> has.
</p>
<p>Note that the methods <code>insert_at</code>, <code>appendleft</code>, <code>append</code>
in the super class still works without checking if the new element equals
any other elements in the set.
Normally they should be depreciated in the <code>RSet</code> class,
but this is not done in the current version of the package.
It is strongly recommended that the user should use the <code>add</code> method
to add a new element when using the <code>RSet</code> class.
</p>
<p>The elements in the set are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the set data structure, see <a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set at Wikipedia</a>.
</p>


<h3>Class Method</h3>

<p>The class method belongs to the class.
</p>

<dl>
<dt><code>new(equal, ..., collapse=NULL)</code></dt><dd>
<p>The <code>new</code> method creates a new instance of the RSet class
containing the values in <code>...</code> and <code>collapse</code> as its elements.
</p>
<p>The argument <code>equal</code> takes a function defining the &quot;=&quot; operation,
The function set to <code>equal</code> takes two values of the elements in the set and return
a boolean.
It can be, for example, of the form
</p>
<p><code>equal &lt;- function(x, y) return(x$num == y$num)</code>
</p>
<p>where <code>x</code> and <code>y</code> are values of two elements in the set
with the attribute <code>num</code>.
</p>
</dd>
</dl>



<h3>Immutable Methods</h3>

<p>The immutable methods do not change the elements of the instance.
</p>

<dl>
<dt><code>has(val)</code></dt><dd>
<p>The method <code>has</code> returns a boolean indicating
if the set contains <code>val</code>.
</p>
</dd>
<dt><code>union(rset)</code></dt><dd>
<p>The method <code>union</code> merges the elements in <code>rset</code>, an instance of some class in the package,
with its elements, and returns a new union set of the two.
</p>
</dd>
<dt><code>intersection(rset)</code></dt><dd>
<p>The method <code>intersection</code> returns a new intersection set (RSet) of
the current set and <code>rset</code>, an instance of some class in the package.
</p>
</dd>
<dt><code>difference(rset)</code></dt><dd>
<p>The method <code>difference</code> returns a new difference set (RSet) of
the current set and <code>rset</code>, an instance of some class in the package
(current instance minus <code>rset</code>).
</p>
</dd>
<dt><code>subset(rset)</code></dt><dd>
<p>The method <code>subset</code> returns a boolean indicating
if the current set is a subset of <code>rset</code>,
an instance of some class in the package.
</p>
</dd>
<dt><code>contains(rset)</code></dt><dd>
<p>The method <code>contains</code> returns a boolean indicating
if the current set contains <code>rset</code>,
an instance of some class in the package.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>add(val)</code></dt><dd>
<p>The method <code>add</code> adds a new element into the set and returns a booleank
showing if the insertion is successful.
</p>
</dd>
<dt><code>add_multiple(..., collapse=NULL)</code></dt><dd>
<p>The method <code>add_multiple</code> adds new elements in <code>...</code> and <code>collapse</code> into the set.
</p>
</dd>
<dt><code>delete(val)</code></dt><dd>
<p>The method <code>delete</code> removes the element which is <code>equal</code> to <code>val</code> in the set.
It returns a boolean showing if the deletion is successful (if the element is not found in the set).
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+RDLL">RDLL</a> and <a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# you have to define "="
equal &lt;- function(x, y) return(x$key == y$key)
# remember that the elements in the set must have the "key" attribute

# to create a new instance of the class
set &lt;- RSet$new(equal=equal)

# of course you can start to add elements when creating the instance
set &lt;- RSet$new(equal=equal,
    list(key=5, val="5"), collapse=list(list(key=3,val="3"), list(key=9,val="9")))
# the following sentence is equivalent to the above
set &lt;- RSet$new(equal=equal,
    list(key=5, val="5"), list(key=3,val="3"), list(key=9,val="9"))
# where the three lists are inserted into the set

### immutable methods

set$has(list(key=5, num=10))
# TRUE as it has the key attribute

### mutable methods

set$add(list(key=5, num=10))
# FALSE

set$add(list(key=10, val="10"))
# TRUE

set$delete(list(key=10))
# TRUE and list(key=10, val="10") is removed

# union
another_set &lt;- RSet$new(equal=equal,
    list(key=5, val="5"), list(key=11,val="11"))
set$union(another_set)$show()

# intersection
set$intersection(another_set)$show()

# difference
set$difference(another_set)$show()

# subset
set$subset(another_set)

# contains
set$contains(another_set)

</code></pre>

<hr>
<h2 id='RStack'>The RStack reference class</h2><span id='topic+RStack'></span>

<h3>Description</h3>

<p>The RStack reference class implements the data structure stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RStack
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>


<h3>Details</h3>

<p>A stack is an ordered list of elements following the Last-In-First-Out (LIFO) principle.
The <code>push</code> method takes elements and add them to the top position (right) of the stack,
while the <code>pop</code> method returns and removes the last &quot;pushed&quot; (top or rightmost) element in the stack.
</p>
<p>The elements in the stack are not necessarily to be of the same type,
and they can be any R objects.
</p>


<h3>References</h3>

<p>For the details about the stack data structure, see <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack at Wikipedia</a>.
</p>


<h3>Immutable Methods</h3>

<p>The immutable method does not change the instance.
</p>

<dl>
<dt><code>peek()</code></dt><dd>
<p>This method returns the last pushed (top or rightmost) element in the stack.
It returns <code>NULL</code> if the stack is empty.
</p>
</dd>
</dl>



<h3>Mutable Methods</h3>

<p>The mutable methods change the instance.
</p>

<dl>
<dt><code>push(..., collapse=NULL)</code></dt><dd>
<p>The <code>push</code> method pushes the elements in <code>...</code> and <code>collapse</code> into the stack
(to the top or right).
</p>
<p>Note that you can input multiple elements.
</p>
</dd>
<dt><code>pop()</code></dt><dd>
<p>The <code>pop</code> method pops (returns and removes) the last pushed (rightmost) element in the stack.
It returns <code>NULL</code> if the stack is empty.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+R6DS">R6DS</a> for the introduction of the reference class and some common methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### create a new instance

# to create a new instance of the class
stack &lt;- RStack$new()

# the previous RStack instance will be removed if you run
stack &lt;- RStack$new(0, 1, 2, collapse=list(3, 4))
# the following sentence is equivalent to the above
stack &lt;- RStack$new(0, 1, 2, 3, 4)
# where the numbers 0, 1, 2, 3, 4 are pushed into the stack

### push elements

# it can be one single element
stack$push(5)
# it can be several elements separated by commas
# note the whole list will be one element of the stack
# because it is not passed through the collapse argument
stack$push(list(a=10,b=20), "Hello world!")
# the collapse argument takes a list whose elements will be collapsed
# but the elements' names will not be saved
stack$push(collapse = list(x=100,y=200))
# they can be used together
stack$push("hurrah", collapse = list("RStack",300))

### pop an element

# pop only one element at a time
val &lt;- stack$pop()
# then we keep poping!
while(!is.null(val)) val &lt;- stack$pop()

</code></pre>

<hr>
<h2 id='version'>Show the version number of some information.</h2><span id='topic+version'></span>

<h3>Description</h3>

<p>This function shows the version number and some information of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version()
</code></pre>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
