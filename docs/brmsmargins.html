<!DOCTYPE html><html><head><title>Help for package brmsmargins</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brmsmargins}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.averagePosterior'><p>Average Over Posterior Predictions</p></a></li>
<li><a href='#.checktab'><p>Check Object Class is a Table</p></a></li>
<li><a href='#.extractlink'><p>Extract the Link from a <code>brms</code> Model</p></a></li>
<li><a href='#.links'><p>Convert a Link Function Name to a List</p></a></li>
<li><a href='#.percent'><p>Calculate Percent of Observations Within or Without a Window</p></a></li>
<li><a href='#assertall'><p>Check Assertions about a <code>brmsfit</code> Model Object</p></a></li>
<li><a href='#brmsmargins'><p>Calculate Marginal Effects from 'brms' Models</p></a></li>
<li><a href='#bsummary'><p>Personal Preference Based Bayesian Summary</p></a></li>
<li><a href='#builders'><p>Build the Variable Names or Data Objects for Estimation</p></a></li>
<li><a href='#integratemvn'><p>Integrate over Multivariate Normal Random Effects</p></a></li>
<li><a href='#integratere'><p>Integrate over Random Effects</p></a></li>
<li><a href='#is.random'><p>Check a <code>brmsfit</code> Object has Random Effects</p></a></li>
<li><a href='#lmcpp'><p>Fast Linear Regression</p></a></li>
<li><a href='#marginalcoef'><p>Marginal Coefficients from a 'brms' Model</p></a></li>
<li><a href='#prediction'><p>Marginal Posterior Predictions from a 'brms' Model</p></a></li>
<li><a href='#rowBootMeans'><p>Bootstrap Row Means</p></a></li>
<li><a href='#tab2mat'><p>Convert a Row of a Table to a Square Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Marginal Effects for 'brms' Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://joshuawiley.com/brmsmargins/">https://joshuawiley.com/brmsmargins/</a>,
<a href="https://github.com/JWiley/brmsmargins">https://github.com/JWiley/brmsmargins</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JWiley/brmsmargins/issues">https://github.com/JWiley/brmsmargins/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate Bayesian marginal effects, average marginal effects, and marginal coefficients (also called population averaged coefficients) for models fit using the 'brms' package including fixed effects, mixed effects, and location scale models. These are based on marginal predictions that integrate out random effects if necessary (see for example &lt;<a href="https://doi.org/10.1186%2Fs12874-015-0046-6">doi:10.1186/s12874-015-0046-6</a>&gt; and &lt;<a href="https://doi.org/10.1111%2Fbiom.12707">doi:10.1111/biom.12707</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, data.table (&ge; 1.12.0), extraoperators (&ge;
0.1.1), brms, bayestestR, Rcpp, posterior</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, withr, knitr, rmarkdown, margins,
betareg</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-18 19:46:16 UTC; jwile</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua F. Wiley <a href="https://orcid.org/0000-0002-0271-6702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Donald Hedeker <a href="https://orcid.org/0000-0001-8134-6094"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua F. Wiley &lt;jwiley.psych@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-18 22:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='.averagePosterior'>Average Over Posterior Predictions</h2><span id='topic+.averagePosterior'></span>

<h3>Description</h3>

<p>Internal function that averages over posterior predictions
using either <code><a href="Matrix.html#topic+rowMeans">rowMeans()</a></code> or <code><a href="#topic+rowBootMeans">rowBootMeans()</a></code>, the latter
being useful to incorporate uncertainty from the
inputs being used to generate predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.averagePosterior(posterior, resample = 0L, seed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".averagePosterior_+3A_posterior">posterior</code></td>
<td>
<p>A posterior matrix type object. It is assumed that different
predictions to be averaged over are on different columns. Different posterior
draws are on different rows.</p>
</td></tr>
<tr><td><code id=".averagePosterior_+3A_resample">resample</code></td>
<td>
<p>An integer indicating the number of
bootstrap resamples of the posterior predictions to
use when calculating summaries. Defaults to <code>0L</code>.
See the details section for more informations as its implementation
is experimental and it may not operate as one would expect.</p>
</td></tr>
<tr><td><code id=".averagePosterior_+3A_seed">seed</code></td>
<td>
<p>A seed for random number generation. Defaults to <code>FALSE</code>,
which means no seed is set.
Only used if <code>resample</code> is a positive, non-zero integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the averaged posterior.
</p>

<hr>
<h2 id='.checktab'>Check Object Class is a Table</h2><span id='topic+.checktab'></span>

<h3>Description</h3>

<p>Internal utility function confirm that an object
has the attributes needed to be used as data.
Currently it should be a <code>tbl</code>,
<code>data.frame</code>, or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checktab(x, requireNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".checktab_+3A_x">x</code></td>
<td>
<p>An object to be evaluated.</p>
</td></tr>
<tr><td><code id=".checktab_+3A_requirenames">requireNames</code></td>
<td>
<p>A logical, whether names are
required. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty string if no issues. Otherwise, a non zero
string with warning/error messages.
</p>

<hr>
<h2 id='.extractlink'>Extract the Link from a <code>brms</code> Model</h2><span id='topic+.extractlink'></span>

<h3>Description</h3>

<p>Internal utility function to take a <code>brmsfit</code> object
and extract the link for a specific <code>dpar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extractlink(object, dpar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extractlink_+3A_object">object</code></td>
<td>
<p>A <code>brmsfit</code> class model object.</p>
</td></tr>
<tr><td><code id=".extractlink_+3A_dpar">dpar</code></td>
<td>
<p>The dpar for which the link should be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, the link.
</p>

<hr>
<h2 id='.links'>Convert a Link Function Name to a List</h2><span id='topic+.links'></span>

<h3>Description</h3>

<p>Internal utility function used in <code><a href="#topic+prediction">prediction()</a></code>.
Takes a link function name as a character string,
the type of effect to be used, and the desired back transformation
and returns a list with all the options needed to execute the desired
options in <code><a href="#topic+prediction">prediction()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.links(
  link,
  effects = c("fixedonly", "includeRE", "integrateoutRE"),
  backtrans = c("response", "linear", "identity", "invlogit", "exp", "square",
    "inverse")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".links_+3A_link">link</code></td>
<td>
<p>The link named in a <code>brmsfit</code> object</p>
</td></tr>
<tr><td><code id=".links_+3A_effects">effects</code></td>
<td>
<p>A character string, the type of effect desired</p>
</td></tr>
<tr><td><code id=".links_+3A_backtrans">backtrans</code></td>
<td>
<p>A character string, the type of back transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with eight elements.
</p>

<dl>
<dt>scale</dt><dd><p>A character string giving the argument to be passed to <code><a href="stats.html#topic+fitted">fitted()</a></code>.</p>
</dd>
<dt>ilink</dt><dd><p>A character string giving the name of the inverse link function.</p>
</dd>
<dt>ifun</dt><dd><p>Inverse link function as an <code>R</code> function.</p>
</dd>
<dt>ilinknum</dt><dd><p>An integer giving the inverse link / transformation to be applied in <code><a href="#topic+integratere">integratere()</a></code>, needed as this is a C++ function and cannot use the <code>R</code> based inverse link function.</p>
</dd>
</dl>


<hr>
<h2 id='.percent'>Calculate Percent of Observations Within or Without a Window</h2><span id='topic+.percent'></span>

<h3>Description</h3>

<p>This is an internal helper function to calculate and label
the percentage of a posterior distribution that falls within
the Region of Practical Equivalence (ROPE) or
at or beyond a Minimally Important Difference (MID).
It is designed to fail gracefully if no window given, and to
give some useful labels about the windows / range used.
Intended for use internally as part of <code><a href="#topic+brmsmargins">brmsmargins</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.percent(x, window = NULL, within = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".percent_+3A_x">x</code></td>
<td>
<p>A vector of values to evaluate. Required.</p>
</td></tr>
<tr><td><code id=".percent_+3A_window">window</code></td>
<td>
<p>An optional numeric vector giving a window.</p>
</td></tr>
<tr><td><code id=".percent_+3A_within">within</code></td>
<td>
<p>A logical value indicating whether to calculate the
percentage within the window (if <code>TRUE</code>) or the
percentage at or outside the window (if <code>FALSE</code>).
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the <code>Window</code>, if specified else <code>NULL</code>,
the <code>Percent</code> of observations, and a <code>Label</code> specifying the
exact window used in human readable format.
</p>

<hr>
<h2 id='assertall'>Check Assertions about a <code>brmsfit</code> Model Object</h2><span id='topic+assertall'></span><span id='topic+.assertbrmsfit'></span><span id='topic+.assertgaussian'></span><span id='topic+.assertfamily'></span><span id='topic+.assertdpar'></span><span id='topic+.assertlink'></span>

<h3>Description</h3>

<p>These are a set of internal utility functions.
They are not intended for general use.
Instead, they are intended to be called in circumstances
where the expected result is <code>TRUE</code>.
All of them are designed to try to give informative error
messages if the assertion is not met.
All of them result in a <code>stop()</code> error if the assertion is not met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.assertbrmsfit(object)

.assertgaussian(object)

.assertfamily(object)

.assertdpar(object, dpar)

.assertlink(object, dpar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assertall_+3A_object">object</code></td>
<td>
<p>A <code>brmsfit</code> model object to be evaluated.</p>
</td></tr>
<tr><td><code id="assertall_+3A_dpar">dpar</code></td>
<td>
<p>Required for <code>.assertdpar</code> which checks this is valid.
Optional for <code>.assertlink</code> which will use <code>NULL</code> if not
specified. If specified, this should be <code>NULL</code> or
a character string.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>.assertbrmsfit</code>asserts that the object should be of class <code>brmsfit</code>.
</p>
</li>
<li><p><code>.assertgaussian</code>asserts that all random effects are Gaussian.
</p>
</li>
<li><p><code>.assertfamily</code>asserts that the distribution (family) of the outcome is a currently supported family. Only applies when integrating out random effects.
</p>
</li>
<li><p><code>.assertlink</code>asserts that the link function is a currently supported link function. Only applies when integrating out random effects.
</p>
</li></ul>



<h3>Value</h3>

<p>An invisible, logical <code>TRUE</code> if the assertion is met.
An (informative) error message if the assertion is not met.
</p>

<hr>
<h2 id='brmsmargins'>Calculate Marginal Effects from 'brms' Models</h2><span id='topic+brmsmargins'></span>

<h3>Description</h3>

<p>This function is designed to help calculate marginal effects
including average marginal effects (AMEs) from <code>brms</code> models.
Arguments are labeled as <em>required</em> when it is required that the
user directly specify the argument. Arguments are labeled as
<em>optional</em> when either the argument is optional or there are
sensible default values so that users do not typically need to specify
the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmsmargins(
  object,
  at = NULL,
  wat = NULL,
  add = NULL,
  newdata = model.frame(object),
  CI = 0.99,
  CIType = "HDI",
  contrasts = NULL,
  ROPE = NULL,
  MID = NULL,
  subset = NULL,
  dpar = NULL,
  seed,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmsmargins_+3A_object">object</code></td>
<td>
<p>A <em>required</em> argument specifying a fitted <code>brms</code> model object.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_at">at</code></td>
<td>
<p>An <em>optional</em> argument (but note, either <code>at</code> or <code>add</code> are
<em>required</em>) specifying an object inheriting from data frame indicating
the values to hold specific variables at when calculating average
predictions. This is intended for AMEs from categorical variables.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_wat">wat</code></td>
<td>
<p>An <em>optional</em> list with named elements including one element named,
&ldquo;ID&rdquo; with a single character string, the name of the variable
in the model frame that is the ID variable. Additionally,
there should be one or more named elements, named after variables
in the model (and specified in the <code>at</code> argument), that
contain a <code>data.table</code> or <code>data.frame</code> with three
variables: (1) the ID variable giving IDs, (2) the values
specified for the variable in the <code>at</code> argument, and
(3) the actual values to be substituted for each ID.
<code>wat</code> cannot be non null unless <code>at</code> also is non null.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_add">add</code></td>
<td>
<p>An <em>optional</em> argument (but note, either <code>at</code> or <code>add</code> are
<em>required</em>) specifying an object inheriting from data frame indicating
the values to add to specific variables at when calculating average
predictions. This is intended for AMEs for continuous variables.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_newdata">newdata</code></td>
<td>
<p>An <em>optional</em> argument specifying an object inheriting
from data frame indicating the baseline values to use for predictions and AMEs.
It uses a sensible default: the model frame from the <code>brms</code>
model object passed on the <code>object</code> argument.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_ci">CI</code></td>
<td>
<p>An <em>optional</em> argument with a numeric value specifying the width
of the credible interval. Defaults to <code>0.99</code>. This default is arbitrary,
but is purposefully higher than the common <code>0.95</code> to encourage science
with greater acknowledgment of uncertainty or larger sample sizes (ideally).</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_citype">CIType</code></td>
<td>
<p>An <em>optional</em> argument, a character string specifying the
type of credible interval (e.g., highest density interval). It is passed down to
<code><a href="#topic+bsummary">bsummary</a></code> which in turn passes it to
<code><a href="bayestestR.html#topic+ci">ci</a></code>. Defaults to &ldquo;HDI&rdquo;.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_contrasts">contrasts</code></td>
<td>
<p>An <em>optional</em> argument specifying a contrast matrix.
The posterior predictions matrix
is post multiplied by the contrast matrix, so they must be conformable.
The posterior predictions matrix has a separate column for each row in the
<code>at</code> or <code>add</code> object, so the contrast matrix should have the same
number of rows. It can have multiple columns, if you desire multiple specific
contrasts.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_rope">ROPE</code></td>
<td>
<p>An <em>optional</em> argument, that can either be left as <code>NULL</code>,
the default, or a numeric vector of length 2, specifying the
lower and upper thresholds for the
Region of Practical Equivalence (ROPE).</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_mid">MID</code></td>
<td>
<p>An <em>optional</em> argument, that can either left as <code>NULL</code>,
the default, or a numeric vector of length 2, specifying the
lower and upper thresholds for a
Minimally Important Difference (MID). Unlike the ROPE, percentages for
the MID are calculated as at or exceeding the bounds specified by this
argument, whereas the ROPE is the percentage of the posterior at or inside
the bounds specified.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_subset">subset</code></td>
<td>
<p>An <em>optional</em> argument, a character string that is a
valid <code>R</code> expression used to subset the dataset passed in <code>newdata</code>,
prior to analysis. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_dpar">dpar</code></td>
<td>
<p>An <em>optional</em> argument giving the parameter passed on to the <code>dpar</code>
argument of <code>fitted()</code> in brms. Defaults to <code>NULL</code>,
indicating the mean or location parameter typically.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_seed">seed</code></td>
<td>
<p>An <em>optional</em> argument that controls whether (and if so what) random seed
to use. This does not matter when using fixed effects only. However,
when using Monte Carlo integration to integrate out random effects from
mixed effects models, it is critical if you are looking at a continuous
marginal effect with some small offset value as otherwise the
Monte Carlo error from one set of predictions to another may exceed
the true predicted difference.
If <code>seed</code> is left missing, the default, than a single, random integer
between +\- 1e7 is chosen and used to set the seed before each
prediction. If manually chosen (recommended for reproducibility),
the seed should either be a single value, in which case this single
value is used to set the seed before each prediction.
Alternately, it can be a vector of seeds with either the same length
as the number of rows in <code>at</code> or <code>add</code>, whichever was specified.
This is probably generally not what you want, as it means that even for
the same input data, you would get slightly different predictions
(when integrating out random effects) due to Monte Carlo variation.
Finally, rather than being missing, you can explicitly set
<code>seed = NULL</code>, if you do not want any seed to be set.
This would be fine, for instance, when only using fixed effects,
or if you know what you are doing and intend that behavior when
integrating out random effects.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_verbose">verbose</code></td>
<td>
<p>An <em>optional</em> argument, a logical value whether to print
more verbose messages. Defaults to <code>FALSE</code> which is quieter. Set to
<code>TRUE</code> for more messages to be printed where relevant.</p>
</td></tr>
<tr><td><code id="brmsmargins_+3A_...">...</code></td>
<td>
<p>An <em>optional</em> argument, additional arguments passed on to
<code><a href="#topic+prediction">prediction</a></code>. In particular, the <code>effects</code> argument of <code><a href="#topic+prediction">prediction()</a></code>
is important for mixed effects models to control how random effects
are treated in the predictions, which subsequently changes the
marginal effect estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main parts required for the function are a fitted model object,
(via the <code>object</code> argument) a dataset to be used for prediction,
(via the <code>newdata</code> argument which defaults to the model frame),
and a dataset passed to either <code>at</code> or <code>add</code>.
The steps are as follows:
</p>

<ol>
<li><p> Check that the function inputs (model object, data, etc.) are valid.
</p>
</li>
<li><p> Take the dataset from the <code>newdata</code> argument and either
add the values from the first row of <code>add</code> or replace the values
using the first row of <code>at</code>. Only variables specified in
<code>at</code> or <code>add</code> are modified. Other variables are left as is.
</p>
</li>
<li><p> Use the <code>fitted()</code> function to generate predictions based on
this modified dataset. If <code>effects</code> is set to &ldquo;fixedonly&rdquo;
(meaning only generate predictions using fixed effects)
or to &ldquo;includeRE&rdquo;
(meaning generate predictions using fixed and random effects),
then predictions are generated entirely using the <code>fitted()</code>
function and are, typically back transformed to the response scale.
For mixed effects models with fixed and random effects where
<code>effects</code> is set to &ldquo;integrateoutRE&rdquo;, then <code>fitted()</code>
is only used to generate predictions using the fixed effects on the linear
scale. For each prediction generated, the random effects are integrated out
by drawing <code>k</code> random samples from the model assumed random effect(s)
distribution. These are added to the fixed effects predictions,
back transformed, and then averaged over all <code>k</code> random samples to
perform numerical Monte Carlo integration.
</p>
</li>
<li><p> All the predictions for each posterior draw, after any back transformation
has been applied, are averaged, resulting in one, marginal value for each
posterior draw. These are marginal predictions. They are average marginal
predictions if averaging over the sample dataset, or may be marginal predictions
at the means, if the initial input dataset used mean values, etc.
</p>
</li>
<li><p> Steps two to four are repeated for each row of <code>at</code> or <code>add</code>.
Results are combined into a matrix where the columns are different
rows from <code>at</code> or <code>add</code> and the rows are different posterior
draws.
</p>
</li>
<li><p> If contrasts were specified, using a contrast matrix, the
marginal prediction matrix is post multiplied by the contrast matrix.
Depending on the choice(s) of <code>add</code> or <code>at</code> and the
values in the contrast matrix, these can then be
average marginal effects (AMEs) by using numerical integration
(<code>add</code> with 0 and a very close to 0 value) or
discrete difference (<code>at</code> with say 0 and 1 as values)
for a given predictor(s).
</p>
</li>
<li><p> The marginal predictions and the contrasts, if specified are
summarized.
</p>
</li></ol>

<p>Although <code>brmsmargins()</code> is focused on helping to calculate
marginal effects, it can also be used to generate marginal predictions,
and indeed these marginal predictions are the foundation of any
marginal effect estimates. Through manipulating the input data,
<code>at</code> or <code>add</code> and the contrast matrix, other types of estimates
averaged or weighting results in specific ways are also possible.
</p>


<h3>Value</h3>

<p>A list with four elements.
</p>

<ul>
<li><p><code>Posterior</code>Posterior distribution of all predictions. These predictions default to fixed effects only, but by specifying options to <code><a href="#topic+prediction">prediction()</a></code> they can include random effects or be predictions integrating out random effects.
</p>
</li>
<li><p><code>Summary</code>A summary of the predictions.
</p>
</li>
<li><p><code>Contrasts</code>Posterior distribution of all contrasts, if a contrast matrix was specified.
</p>
</li>
<li><p><code>ContrastSummary</code>A summary of the posterior distribution of all contrasts, if specified
</p>
</li></ul>



<h3>References</h3>

<p>Pavlou, M., Ambler, G., Seaman, S., &amp; Omar, R. Z. (2015)
<a href="https://doi.org/10.1186/s12874-015-0046-6">doi:10.1186/s12874-015-0046-6</a>
&ldquo;A note on obtaining correct marginal predictions from a random intercepts model for binary outcomes&rdquo;
and
Skrondal, A., &amp; Rabe-Hesketh, S. (2009)
<a href="https://doi.org/10.1111/j.1467-985X.2009.00587.x">doi:10.1111/j.1467-985X.2009.00587.x</a>
&ldquo;Prediction in multilevel generalized linear models&rdquo;
and
Norton EC, Dowd BE, Maciejewski ML. (2019)
<a href="https://doi.org/10.1001/jama.2019.1954">doi:10.1001/jama.2019.1954</a>
&ldquo;Marginal Effects—Quantifying the Effect of Changes in Risk Factors in Logistic Regression Models&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### Testing ####
## sample data and logistic model with brms
set.seed(1234)
Tx &lt;- rep(0:1, each = 50)
ybin &lt;- c(rep(0:1, c(40,10)), rep(0:1, c(10,40)))
logitd &lt;- data.frame(Tx = Tx, ybin = ybin)
logitd$x &lt;- rnorm(100, mean = logitd$ybin, sd = 2)

mbin &lt;- brms::brm(ybin ~ Tx + x, data = logitd, family = brms::bernoulli())

summary(mbin)

## now check AME for Tx
tmp &lt;- brmsmargins(
  object = mbin,
  at = data.table::data.table(Tx = 0:1),
  contrasts = matrix(c(-1, 1), nrow = 2),
  ROPE = c(-.05, +.05),
  MID = c(-.10, +.10))

tmp$Summary
tmp$ContrastSummary ## Tx AME


## now check AME for Tx with bootstrapping the AME population
tmpalt &lt;- brmsmargins(
  object = mbin,
  at = data.table::data.table(Tx = 0:1),
  contrasts = matrix(c(-1, 1), nrow = 2),
  ROPE = c(-.05, +.05),
  MID = c(-.10, +.10),
  resample = 100L)

tmpalt$Summary
tmpalt$ContrastSummary ## Tx AME

## now check AME for continuous predictor, x
## use .01 as an approximation for first derivative
## 1 / .01 in the contrast matrix to get back to a one unit change metric
tmp2 &lt;- brmsmargins(
  object = mbin,
  add = data.table::data.table(x = c(0, .01)),
  contrasts = matrix(c(-1/.01, 1/.01), nrow = 2),
  ROPE = c(-.05, +.05),
  MID = c(-.10, +.10))

tmp2$ContrastSummary ## x AME

if (FALSE) {
  library(lme4)
  data(sleepstudy)
  fit &lt;- brms::brm(Reaction ~ 1 + Days + (1 + Days | Subject),
             data = sleepstudy,
             cores = 4)

  summary(fit, prob = 0.99)

  tmp &lt;- brmsmargins(
    object = fit,
    at = data.table::data.table(Days = 0:1),
    contrasts = matrix(c(-1, 1), nrow = 2),
    ROPE = c(-.05, +.05),
    MID = c(-.10, +.10), CIType = "ETI", effects = "integrateoutRE", k = 5L)

  tmp$Summary
  tmp$ContrastSummary
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='bsummary'>Personal Preference Based Bayesian Summary</h2><span id='topic+bsummary'></span>

<h3>Description</h3>

<p>Returns a summary of a posterior distribution for a single
parameter / value. It is based on personal preference. Notably, it does not
only use <code>bayestestR::describe_posterior</code>, an excellent function,
because of the desire to also describe the percentage of the full posterior
distribution that is at or exceeding the value of a
Minimally Important Difference (MID). MIDs are used in clinical studies with outcome
measures where there are pre-defined differences that are considered clinically
important, which is distinct from the ROPE or general credible intervals capturing
uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsummary(x, CI = 0.99, CIType = "HDI", ROPE = NULL, MID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsummary_+3A_x">x</code></td>
<td>
<p>The posterior distribution of a parameter</p>
</td></tr>
<tr><td><code id="bsummary_+3A_ci">CI</code></td>
<td>
<p>A numeric value indicating the desired width of the credible interval.
Defaults to <code>0.99</code> currently, but this is subject to change.
a 99% interval was chosen as the default as there have been recent arguments
made in the realm of meta science that there are, essentially, too many
false positives and that many of the &ldquo;findings&rdquo; in science are not able
to be replicated.
In any case, users should ideally specify a desired CI width, and not rely on
defaults.</p>
</td></tr>
<tr><td><code id="bsummary_+3A_citype">CIType</code></td>
<td>
<p>A character string indicating the type of credible interval, passed on
to the <code><a href="bayestestR.html#topic+ci">ci</a></code> function as the method for CIs.</p>
</td></tr>
<tr><td><code id="bsummary_+3A_rope">ROPE</code></td>
<td>
<p>Either left as <code>NULL</code>, the default, or a numeric vector of
length 2, specifying the lower and upper thresholds for the
Region of Practical Equivalence (ROPE).</p>
</td></tr>
<tr><td><code id="bsummary_+3A_mid">MID</code></td>
<td>
<p>Either left as <code>NULL</code>, the default, or a numeric vector of
length 2, specifying the lower and upper thresholds for a
Minimally Important Difference (MID). Unlike the ROPE, percentages for
the MID are calculated as at or exceeding the bounds specified by this
argument, whereas the ROPE is the percentage of the posterior at or inside
the bounds specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the mean, <code>M</code>
</p>

<dl>
<dt>M</dt><dd><p>the mean of the posterior samples</p>
</dd>
<dt>Mdn</dt><dd><p>the median of the posterior samples</p>
</dd>
<dt>LL</dt><dd><p>the lower limit of the credible interval</p>
</dd>
<dt>UL</dt><dd><p>the upper limit of the credible interval</p>
</dd>
<dt>PercentROPE</dt><dd><p>the percentage of posterior samples falling into the ROPE</p>
</dd>
<dt>PercentMID</dt><dd><p>the percentage of posterior samples falling at or beyond the MID</p>
</dd>
<dt>CI</dt><dd><p>the width of the credible interval used</p>
</dd>
<dt>CIType</dt><dd><p>the type of credible interval used (e.g., highest density interval)</p>
</dd>
<dt>ROPE</dt><dd><p>a label describing the values included in the ROPE</p>
</dd>
<dt>MID</dt><dd><p>a label describing the values included in the MID</p>
</dd>
</dl>



<h3>References</h3>

<p>Kruschke, J. K. (2018).
<a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>
&ldquo;Rejecting or accepting parameter values in Bayesian estimation&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bsummary(rnorm(1000))

bsummary(rnorm(1000), ROPE = c(-.5, .5), MID = c(-1, 1))
</code></pre>

<hr>
<h2 id='builders'>Build the Variable Names or Data Objects for Estimation</h2><span id='topic+builders'></span><span id='topic+.namesL'></span><span id='topic+.buildL'></span><span id='topic+.namesSD'></span><span id='topic+.buildSD'></span><span id='topic+.namesZ'></span><span id='topic+.buildZ'></span>

<h3>Description</h3>

<p>These are a set of internal utility functions.
They are not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.namesL(block, number)

.buildL(data, block, number, dpar)

.namesSD(ranef, block, dpar)

.buildSD(data, ranef, block, dpar)

.namesZ(block, number, dpar)

.buildZ(data, block, number, dpar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="builders_+3A_block">block</code></td>
<td>
<p>Which random effect block to use. An integer.</p>
</td></tr>
<tr><td><code id="builders_+3A_number">number</code></td>
<td>
<p>The number of elements in that random effect block. An integer.</p>
</td></tr>
<tr><td><code id="builders_+3A_data">data</code></td>
<td>
<p>A data object. For example the result of <code><a href="brms.html#topic+make_standata">make_standata()</a></code>
for <code><a href="#topic+.buildZ">.buildZ()</a></code>, which is a list,
or a dataset of the posterior draws such as from <code><a href="brms.html#topic+as_draws_df">as_draws_df()</a></code>
for <code><a href="#topic+.buildL">.buildL()</a></code> and <code><a href="#topic+.buildSD">.buildSD()</a></code>.</p>
</td></tr>
<tr><td><code id="builders_+3A_dpar">dpar</code></td>
<td>
<p>Which dpar to use. Does not apply to the L matrix.</p>
</td></tr>
<tr><td><code id="builders_+3A_ranef">ranef</code></td>
<td>
<p>A data set with information about the model object random effects.
Only used for <code>.namesSD</code> and <code>.buildSD</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>.namesL</code>Generate names of an L matrix from <code>brms</code>. Create the variable names for the Cholesky decomposition of the random effects correlation matrix in <code>brms</code>. Note that <code>brms</code> returns the lower triangular matrix and we want the upper triangular matrix, so the names are transposed. The results can then be passed to the <code>tab2mat</code> function to convert the row vector into a matrix.
</p>
</li>
<li><p><code>.buildL</code>Returns the L matrix object. Rows are posterior draws.
</p>
</li>
<li><p><code>.namesSD</code>Create the names of random effect standard deviation estimates.
</p>
</li>
<li><p><code>.buildSD</code>Return matrix of random effect standard deviation estimates. Rows are posterior draws.
</p>
</li>
<li><p><code>.namesZ</code>Create the names of random effects data for predictions.
</p>
</li>
<li><p><code>.buildZ</code>Return matrix of data for random effect predictions.
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector for all <code>.names</code> functions or a matrix
for all <code>.build</code> functions.
</p>

<hr>
<h2 id='integratemvn'>Integrate over Multivariate Normal Random Effects</h2><span id='topic+integratemvn'></span><span id='topic+integratemvnR'></span>

<h3>Description</h3>

<p>Used in the process of Monte Carlo integration
over multivariate normal random effects. This generates the
random draws from the multivariate normal distribution
and multiplies these by the data.
Not intended to be called directly by most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integratemvn(X, k, sd, chol)

integratemvnR(X, k, sd, chol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integratemvn_+3A_x">X</code></td>
<td>
<p>A numeric matrix of the data to be multiplied by the random effects</p>
</td></tr>
<tr><td><code id="integratemvn_+3A_k">k</code></td>
<td>
<p>An integer, the number of random samples to be used for numerical integration</p>
</td></tr>
<tr><td><code id="integratemvn_+3A_sd">sd</code></td>
<td>
<p>A numeric vector of the standard deviations</p>
</td></tr>
<tr><td><code id="integratemvn_+3A_chol">chol</code></td>
<td>
<p>A numeric matrix, which should be the Cholesky decomposition of the
correlation matrix of the multivariate normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with random values
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>integratemvnR</code>: Pure <code>R</code> implementation of <code>integratemvn</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>integratemvn(
  X = matrix(1, 1, 2),
  k = 100L,
  sd = c(10, 5),
  chol = chol(matrix(c(1, .5, .5, 1), 2)))

integratemvn(matrix(1, 1, 1), 100L, c(5), matrix(1))
</code></pre>

<hr>
<h2 id='integratere'>Integrate over Random Effects</h2><span id='topic+integratere'></span><span id='topic+integratereR'></span>

<h3>Description</h3>

<p>Used to conduct Monte Carlo integration over Gaussian random effects.
Not intended to be called directly by most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integratere(d, sd, L, k, yhat, backtrans)

integratereR(d, sd, L, k, yhat, backtrans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integratere_+3A_d">d</code></td>
<td>
<p>A list with model matrices for each random effect block.</p>
</td></tr>
<tr><td><code id="integratere_+3A_sd">sd</code></td>
<td>
<p>A list with standard deviation matrices for each random effect block
where rows are different posterior draws.</p>
</td></tr>
<tr><td><code id="integratere_+3A_l">L</code></td>
<td>
<p>A list with matrices for each random effect block containing the parts of
the L matrix, the Cholesky decomposition of the random effect correlation matrix.</p>
</td></tr>
<tr><td><code id="integratere_+3A_k">k</code></td>
<td>
<p>An integer, the number of samples for Monte Carlo integration.</p>
</td></tr>
<tr><td><code id="integratere_+3A_yhat">yhat</code></td>
<td>
<p>A matrix of the fixed effects predictions</p>
</td></tr>
<tr><td><code id="integratere_+3A_backtrans">backtrans</code></td>
<td>
<p>An integer, indicating the type of back transformation.
0 indicates inverse logit (e.g., for logistic regression).
1 indicates exponential (e.g., for poisson or negative binomial regression or if outcome was natural log transformed).
2 indicates square (e.g., if outcome was square root transformed).
3 indicates inverse (e.g., if outcome was inverse transformed such as Gamma regression)
Any other integer results in no transformation. -9 is recommended as the option for no
transformation as any future transformations supported will be other, positive integers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the Monte Carlo integral calculated.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>integratereR</code>: Pure <code>R</code> implementation of <code>integratere</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>integratere(
  d = list(matrix(1, 1, 1)),
  sd = list(matrix(1, 2, 1)),
  L = list(matrix(1, 2, 1)),
  k = 10L,
  yhat = matrix(0, 2, 1),
  backtrans = 0L)
</code></pre>

<hr>
<h2 id='is.random'>Check a <code>brmsfit</code> Object has Random Effects</h2><span id='topic+is.random'></span>

<h3>Description</h3>

<p>Internal utility function to check whether a <code>brmsfit</code>
object has any random effects or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.random(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.random_+3A_object">object</code></td>
<td>
<p>An object to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if any random effects present.
<code>FALSE</code> if no random effects present.
</p>

<hr>
<h2 id='lmcpp'>Fast Linear Regression</h2><span id='topic+lmcpp'></span>

<h3>Description</h3>

<p>Used to get marginal coefficients off of a generalized linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmcpp(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmcpp_+3A_x">X</code></td>
<td>
<p>A numeric model matrix. If intercept is desired, it must already have been added as a column.</p>
</td></tr>
<tr><td><code id="lmcpp_+3A_y">y</code></td>
<td>
<p>A numeric matrix. A single column if one response variable or multiple columns
where each column is a different response, such as a for marginal coefficients where
each column is a different MCMC sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lmcpp(cbind(1, mtcars$hp, mtcars$am), as.matrix(mtcars[, c("mpg", "qsec")]))
</code></pre>

<hr>
<h2 id='marginalcoef'>Marginal Coefficients from a 'brms' Model</h2><span id='topic+marginalcoef'></span>

<h3>Description</h3>

<p>Calculate marginal coefficients from a <code>brms</code>
generalized linear mixed model using the method proposed by Hedeker (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalcoef(
  object,
  summarize = TRUE,
  posterior = FALSE,
  index,
  backtrans = c("response", "linear", "identity", "invlogit", "exp", "square",
    "inverse"),
  k = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalcoef_+3A_object">object</code></td>
<td>
<p>A fitted brms model object that includes random effects. Required.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_summarize">summarize</code></td>
<td>
<p>A logical value, whether or not to
calculate summaries of the posterior predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_posterior">posterior</code></td>
<td>
<p>A logical value whether or not to
save and return the posterior samples. Defaults
to <code>FALSE</code> as the assumption is a typical
use case is to return the summaries only.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_index">index</code></td>
<td>
<p>An optional integer vector, giving the posterior draws
to be used in the calculations. If omitted, defaults to all
posterior draws.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_backtrans">backtrans</code></td>
<td>
<p>A character string indicating the type of
back transformation to be applied. Can be one of
&ldquo;response&rdquo; meaning to use the response scale,
&ldquo;linear&rdquo; or &ldquo;identity&rdquo; meaning to use the linear predictor scale,
or a specific back transformation desired, from a possible list of
&ldquo;invlogit&rdquo;, &ldquo;exp&rdquo;, &ldquo;square&rdquo;, or &ldquo;inverse&rdquo;.
Custom back transformations should only be needed if, for example,
the outcome variable was transformed prior to fitting the model.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_k">k</code></td>
<td>
<p>An integer providing the number of random draws to use for
integrating out the random effects. Only relevant when <code>effects</code>
is &ldquo;integrateoutRE&rdquo;.</p>
</td></tr>
<tr><td><code id="marginalcoef_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fitted()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>Summary</code> and <code>Posterior</code>.
Some of these may be <code>NULL</code> depending on the arguments used.
</p>


<h3>References</h3>

<p>Hedeker, D., du Toit, S. H., Demirtas, H. &amp; Gibbons, R. D. (2018)
<a href="https://doi.org/10.1111/biom.12707">doi:10.1111/biom.12707</a>
&ldquo;A note on marginalization of regression parameters from mixed models of binary outcomes&rdquo;
</p>

<hr>
<h2 id='prediction'>Marginal Posterior Predictions from a 'brms' Model</h2><span id='topic+prediction'></span>

<h3>Description</h3>

<p>Calculate marginal predictions from a <code>brms</code> model.
Marginal predictions average over the input data for each posterior draw.
Marginal predictions for models with random effects will integrate
over random effects.
Arguments are labeled as <em>required</em> when it is required that the
user directly specify the argument. Arguments are labeled as
<em>optional</em> when either the argument is optional or there are
sensible default values so that users do not typically need to specify
the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prediction(
  object,
  data,
  summarize = TRUE,
  posterior = FALSE,
  index,
  dpar = NULL,
  resample = 0L,
  resampleseed = FALSE,
  effects = c("fixedonly", "includeRE", "integrateoutRE"),
  backtrans = c("response", "linear", "identity", "invlogit", "exp", "square",
    "inverse"),
  k = 100L,
  raw = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prediction_+3A_object">object</code></td>
<td>
<p>A <em>required</em> argument specifying a fitted
<code>brms</code> model object.</p>
</td></tr>
<tr><td><code id="prediction_+3A_data">data</code></td>
<td>
<p>A <em>required</em> argument specifying a data frame or
data table passed to <code>fitted()</code> as the new data to be used
for predictions.</p>
</td></tr>
<tr><td><code id="prediction_+3A_summarize">summarize</code></td>
<td>
<p>An <em>optional</em> argument, a logical value, whether
or not to calculate summaries of the posterior predictions.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="prediction_+3A_posterior">posterior</code></td>
<td>
<p>An <em>optional</em> argument, a logical value whether
or not to save and return the posterior samples. Defaults
to <code>FALSE</code> as the assumption is a typical
use case is to return the summaries only.</p>
</td></tr>
<tr><td><code id="prediction_+3A_index">index</code></td>
<td>
<p>An <em>optional</em> argument, an integer vector, giving the
posterior draws to be used in the calculations. If omitted,
defaults to all posterior draws.</p>
</td></tr>
<tr><td><code id="prediction_+3A_dpar">dpar</code></td>
<td>
<p>An <em>optional</em> argument, the parameter passed on to the
<code>dpar</code> argument of <code>fitted()</code> in brms. Defaults to <code>NULL</code>
indicating the mean or location parameter typically.</p>
</td></tr>
<tr><td><code id="prediction_+3A_resample">resample</code></td>
<td>
<p>An <em>optional</em> argument, an integer indicating the
number of bootstrap resamples of the posterior predictions to
use when calculating summaries. Defaults to <code>0L</code>.
See documentation from <code><a href="#topic+.averagePosterior">.averagePosterior()</a></code> for more details.
This should be considered experimental.</p>
</td></tr>
<tr><td><code id="prediction_+3A_resampleseed">resampleseed</code></td>
<td>
<p>An <em>optional</em> argument, a seed for random number
generation. Defaults to <code>FALSE</code>, which means no seed is set.
Only used if <code>resample</code> is a positive, non-zero integer.
See documentation from <code><a href="#topic+.averagePosterior">.averagePosterior()</a></code> for more details.
This should be considered experimental.</p>
</td></tr>
<tr><td><code id="prediction_+3A_effects">effects</code></td>
<td>
<p>An <em>optional</em> argument, a character string indicating
the type of prediction to be made. Can be one of
&ldquo;fixedonly&rdquo; meaning only use fixed effects,
&ldquo;includeRE&rdquo; meaning that random effects should be
included in the predictions, or
&ldquo;integrateoutRE&rdquo; meaning that random effects should be
integrated out / over in the predictions.
It defaults to &ldquo;fixedonly&rdquo; so is not typically required for
a user to specify it.</p>
</td></tr>
<tr><td><code id="prediction_+3A_backtrans">backtrans</code></td>
<td>
<p>An <em>optional</em> argument, a character string indicating
the type of back transformation to be applied. Can be one of
&ldquo;response&rdquo; meaning to use the response scale,
&ldquo;linear&rdquo; or &ldquo;identity&rdquo; meaning to use the linear predictor scale,
or a specific back transformation desired, from a possible list of
&ldquo;invlogit&rdquo;, &ldquo;exp&rdquo;, &ldquo;square&rdquo;, or &ldquo;inverse&rdquo;.
Custom back transformations should only be needed if, for example,
the outcome variable was transformed prior to fitting the model.
It defaults to &ldquo;response&rdquo; so is not typically required for
a user to specify it.</p>
</td></tr>
<tr><td><code id="prediction_+3A_k">k</code></td>
<td>
<p>An <em>optional</em> argument, an integer providing the number of
random draws to use for integrating out the random effects.
Only relevant when <code>effects</code> is &ldquo;integrateoutRE&rdquo;.
It defaults to <code>100L</code>, a rather arbitrary number attempting to
balance the increased precision that comes from a larger value,
with the increased computational cost of more Monte Carlo simulations
when integrating out random effects.</p>
</td></tr>
<tr><td><code id="prediction_+3A_raw">raw</code></td>
<td>
<p>An <em>optional</em> argument, a logical value indicating whether to
return the raw output or to average over the Monte Carlo samples.
Defaults to <code>FALSE</code>.
Setting it to <code>TRUE</code> can be useful if you want not only the
full posterior distribution but also the <code>k</code> Monte Carlo samples
used for the numerical integration. This cannot be used with
<code>summarize = TRUE</code>.</p>
</td></tr>
<tr><td><code id="prediction_+3A_...">...</code></td>
<td>
<p>An <em>optional</em> argument, additional arguments passed
to <code>fitted()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>Summary</code> and <code>Posterior</code>.
Some of these may be <code>NULL</code> depending on the arguments used.
</p>


<h3>References</h3>

<p>Pavlou, M., Ambler, G., Seaman, S., &amp; Omar, R. Z. (2015)
<a href="https://doi.org/10.1186/s12874-015-0046-6">doi:10.1186/s12874-015-0046-6</a>
&ldquo;A note on obtaining correct marginal predictions from a random intercepts model for binary outcomes&rdquo;
and
Skrondal, A., &amp; Rabe-Hesketh, S. (2009)
<a href="https://doi.org/10.1111/j.1467-985X.2009.00587.x">doi:10.1111/j.1467-985X.2009.00587.x</a>
&ldquo;Prediction in multilevel generalized linear models&rdquo;
</p>

<hr>
<h2 id='rowBootMeans'>Bootstrap Row Means</h2><span id='topic+rowBootMeans'></span>

<h3>Description</h3>

<p>This takes a numeric matrix, bootstrap resamples each row, and then
calculates the mean. The intended use case is for Bayesian posterior
predictions from sample data. Instead of directly calculating the
average marginal effect (AME) across all observed values, these can be
bootstrapped, so that uncertainty in the target population, and thus
the AME in the target population, can be incorporated.
Model uncertainty is already assumed to be handled by the different posterior
samples, which are assumed to be across rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowBootMeans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowBootMeans_+3A_x">x</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the simple bootstrapped row means of the matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(1:9, byrow = TRUE, 3)
replicate(10, rowBootMeans(x))
</code></pre>

<hr>
<h2 id='tab2mat'>Convert a Row of a Table to a Square Matrix</h2><span id='topic+tab2mat'></span><span id='topic+tab2matR'></span>

<h3>Description</h3>

<p>Utility function to convert a row matrix to a square matrix.
Used as the <code>brms</code> package returns things like the Cholesky
decomposition matrix as separate columns where rows are posterior draws.
Not intended to be called directly by most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2mat(X)

tab2matR(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab2mat_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with one row.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>tab2matR</code>: Pure <code>R</code> implementation of <code>tab2mat</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tab2mat(matrix(1:4, 1))
tab2mat(matrix(1:9, 1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
