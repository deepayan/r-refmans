<!DOCTYPE html><html><head><title>Help for package pbdMPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pbdMPI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pbdMPI-package'><p>R Interface to MPI (Programming with Big Data in R Project)</p></a></li>
<li><a href='#allgather-methods'><p> All Ranks Gather Objects from Every Rank</p></a></li>
<li><a href='#allreduce-method'><p> All Ranks Receive a Reduction of Objects from Every Rank</p></a></li>
<li><a href='#alltoall'><p> All to All</p></a></li>
<li><a href='#apply+20and+20lapply'><p> Parallel Apply and Lapply Functions</p></a></li>
<li><a href='#bcast-method'><p> A Rank Broadcast an Object to Every Rank</p></a></li>
<li><a href='#Comm+20Internal+20Functions'><p> All Comm Internal Functions</p></a></li>
<li><a href='#comm.chunk'><p>comm.chunk</p></a></li>
<li><a href='#communicator'><p> Communicator Functions</p></a></li>
<li><a href='#gather-methods'><p> A Rank Gathers Objects from Every Rank</p></a></li>
<li><a href='#Get+20Configures+20Used+20at+20Compiling+20Time'><p>Functions to Get MPI and/or pbdMPI Configures Used at Compiling Time</p></a></li>
<li><a href='#get+20job+20id'><p> Divide Job ID by Ranks</p></a></li>
<li><a href='#global+20all+20pairs'><p> Global All Pairs</p></a></li>
<li><a href='#global+20any+20and+20all'><p> Global Any and All Functions</p></a></li>
<li><a href='#global+20as.gbd'><p> Global As GBD Function</p></a></li>
<li><a href='#global+20balanc'><p> Global Balance Functions</p></a></li>
<li><a href='#global+20base'><p> Global Base Functions</p></a></li>
<li><a href='#global+20distance+20function'><p> Global Distance for Distributed Matrices</p></a></li>
<li><a href='#global+20match.arg'><p> Global Argument Matching</p></a></li>
<li><a href='#global+20pairwise'><p> Global Pairwise Evaluations</p></a></li>
<li><a href='#global+20print+20and+20cat'><p> Global Print and Cat Functions</p></a></li>
<li><a href='#global+20range+2C+20max+2C+20and+20min'><p> Global Range, Max, and Min Functions</p></a></li>
<li><a href='#global+20reading'><p> Global Reading Functions</p></a></li>
<li><a href='#global+20Rprof'><p> A Rprof Function for SPMD Routines</p></a></li>
<li><a href='#global+20sort'><p> Global Quick Sort for Distributed Vectors or Matrices</p></a></li>
<li><a href='#global+20stop+20and+20warning'><p> Global Stop and Warning Functions</p></a></li>
<li><a href='#global+20timer'><p> A Timing Function for SPMD Routines</p></a></li>
<li><a href='#global+20which+2C+20which.max+2C+20and+20which.min'><p> Global Which Functions</p></a></li>
<li><a href='#global+20writing'><p> Global Writing Functions</p></a></li>
<li><a href='#info'><p> Info Functions</p></a></li>
<li><a href='#irecv-method'><p> A Rank Receives (Nonblocking) an Object from the Other Rank</p></a></li>
<li><a href='#is.comm.null'><p> Check if a MPI_COMM_NULL</p></a></li>
<li><a href='#isend-method'><p> A Rank Send (Nonblocking) an Object to the Other Rank</p></a></li>
<li><a href='#MPI+20array+20pointers'><p> Set or Get MPI Array Pointers in R</p></a></li>
<li><a href='#Package+20Tools'><p>Functions for Get/Print MPI_COMM Pointer (Address)</p></a></li>
<li><a href='#probe'><p> Probe Functions</p></a></li>
<li><a href='#recv-method'><p> A Rank Receives (Blocking) an Object from the Other Rank</p></a></li>
<li><a href='#reduce-method'><p> A Rank Receive a Reduction of Objects from Every Rank</p></a></li>
<li><a href='#scatter-method'><p> A Rank Scatter Objects to Every Rank</p></a></li>
<li><a href='#seed+20for+20RNG'><p>Parallel random number generation with reproducible results</p></a></li>
<li><a href='#send-method'><p> A Rank Send (blocking) an Object to the Other Rank</p></a></li>
<li><a href='#sendrecv-method'><p> Send and Receive an Object to and from Other Ranks</p></a></li>
<li><a href='#sendrecv.replace-method'><p> Send and Receive an Object to and from Other Ranks</p></a></li>
<li><a href='#Set+20global+20pbd+20options'><p> Set Global pbdR Options</p></a></li>
<li><a href='#sourcetag'><p> Functions to Obtain source and tag</p></a></li>
<li><a href='#SPMD+20Control'><p>Default control in pbdMPI.</p></a></li>
<li><a href='#SPMD+20Control+20Functions'><p>Sets of controls in pbdMPI.</p></a></li>
<li><a href='#SPMD+20Internal+20Functions'><p> All SPMD Internal Functions</p></a></li>
<li><a href='#Task+20Pull'><p>Functions for Task Pull Parallelism</p></a></li>
<li><a href='#Utility+20execmpi'><p> Execute MPI code in system</p></a></li>
<li><a href='#wait'><p> Wait Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5-1</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to MPI for HPC Clusters (Programming with Big Data
Project)</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-03</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>float, parallel</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>A simplified, efficient, interface to MPI for HPC clusters. It is
        a derivation and rethinking of the Rmpi package. pbdMPI embraces the
        prevalent parallel programming style on HPC clusters. Beyond the
        interface, a collection of functions for global work with
        distributed data and resource-independent RNG reproducibility is
        included. It is based on S4 classes and methods. </td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>OpenMPI (&gt;= 1.5.4) on Linux, Mac, and FreeBSD.
MS-MPI (Microsoft MPI v7.1 (SDK) and Microsoft HPC Pack 2012 R2
MS-MPI Redistributable Package) on Windows.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pbdr.org/">https://pbdr.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/pbdMPI/issues">https://github.com/snoweye/pbdMPI/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 00:43:04 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  George Ostrouchov [aut],
  Drew Schmidt [aut],
  Pragneshkumar Patel [aut],
  Hao Yu [aut],
  Christian Heckendorf [ctb] (FreeBSD),
  Brian Ripley [ctb] (Windows HPC Pack 2012),
  R Core team [ctb] (some functions are modified from the base packages),
  Sebastien Lamy de la Chapelle [aut] (fix check type for send/recv long
    vectors)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pbdMPI-package'>R Interface to MPI (Programming with Big Data in R Project)</h2><span id='topic+pbdMPI-package'></span><span id='topic+pbdMPI'></span>

<h3>Description</h3>

<p>A simplified, efficient, interface to MPI for HPC clusters. It is
a derivation and rethinking of the Rmpi package that embraces the
prevalent parallel programming style on HPC clusters. Beyond the
interface, a collection of functions for global work with distributed
data is included. It is based on S4 classes and methods.
</p>


<h3>Details</h3>

<p>This package requires an MPI library (OpenMPI, MPICH2, or LAM/MPI). Standard
installation in an R session with
<br />
<code>&gt; install.packages("pbdMPI")</code> <br />
should work in most cases. 
</p>
<p>On HPC clusters, <strong>it is
strongly recommended that you check with your HPC cluster documentation for 
specific requirements, such as 
<a href="https://en.wikipedia.org/wiki/Environment_Modules_(software)">module</a>
software environments.</strong> Some module examples relevant to R and MPI
are <br />
<code>$ module load openmpi</code> <br />
<code>$ module load openblas</code> <br />
<code>$ module load flexiblas</code> <br />
<code>$ module load r</code> <br />
possibly giving specific versions and possibly with some upper case letters.
Although module software environments are widely used, the specific module
names and their dependence structure are not standard across cluster
installations. The command <br />
<code>$ module avail</code> <br />
usually lists the available software modules on your cluster.
</p>
<p>To install on the Unix command line after
downloading the source file, use <code>R CMD INSTALL</code>. <br />
<br />
If the MPI library is not found, after checking that you are loading the 
correct module environments, the following arguments can be used to
specify its non-standard location on your system
</p>

<table>
<tr>
 <td style="text-align: left;">
  Argument </td><td style="text-align: left;"> Default </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>--with-mpi-type</code>    </td><td style="text-align: left;"> <code>OPENMPI</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>--with-mpi-include</code> </td><td style="text-align: left;"> <code>${MPI_ROOT}/include</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>--with-mpi-libpath</code> </td><td style="text-align: left;"> <code>${MPI_ROOT}/lib</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>--with-mpi</code>         </td><td style="text-align: left;"> <code>${MPI_ROOT}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code>${MPI_ROOT}</code> is the path to the MPI root.
See the package source file <code>pbdMPI/configure</code> for details.
</p>
<p>Loading <code>library(pbdMPI)</code> sets a few global variables, including the
environment <code>.pbd_env</code>, where many defaults are set, and initializes MPI.
In most cases, the defaults should not be modified. Rather, the parameters
of the functions that use them should be changed. <strong>All codes must end
with <code><a href="#topic+finalize">finalize</a>()</code> to cleanly exit MPI.</strong>
</p>
<p>Most functions are assumed to run as Single Program, Multiple Data (SPMD),
i.e. in batch mode. SPMD is based on cooperation between parallel copies of a
single program, which is more scalable than a manager-workers approach that is
natural in interactive programming. Interactivity with an HPC cluster is more
efficiently handled by a client-server approach, such as that enabled by the
<a href="https://cran.r-project.org/package=remoter">remoter</a> package.
</p>
<p>On most clusters, codes run with <code>mpirun</code> or 
<code>mpiexec</code> and <code>Rscript</code>, such as <br />
<code>&gt; mpiexec -np 2 Rscript some_code.r</code> <br />
where <code>some_code.r</code> contains the entire SPMD program. The MPI 
Standard 4.0 recommends <code>mpiexec</code> over <code>mpirun</code>. Some
MPI implementations may have minor differences between the two but under
OpenMPI 5.0 they are synonyms that produce the same behavior. 
</p>
<p>The package source files provide several examples based on <span class="pkg">pbdMPI</span>,
such as
</p>

<table>
<tr>
 <td style="text-align: left;">
  Directory </td><td style="text-align: left;"> Examples </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_spmd/</code>        </td><td style="text-align: left;"> main SPMD functions </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_rmpi/</code>        </td><td style="text-align: left;"> analogues to <span class="pkg">Rmpi</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_parallel/</code>    </td><td style="text-align: left;"> analogues to <span class="pkg">parallel</span> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_performance/</code> </td><td style="text-align: left;"> performance tests </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_s4/</code>          </td><td style="text-align: left;"> S4 extension </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_cs/</code>          </td><td style="text-align: left;"> client/server examples </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>pbdMPI/inst/examples/test_long_vector/</code> </td><td style="text-align: left;"> long vector examples </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code>test_long_vector</code> needs a recompile with setting
</p>
<p><code>#define MPI_LONG_DEBUG 1</code>
</p>
<p>in <code>pbdMPI/src/pkg_constant.h</code>.
</p>
<p>The current version is mainly written and tested under OpenMPI
environments on Linux systems (CentOS 7, RHEL 8, Xubuntu). Also, it is tested
on macOS with Homebrew-installed OpenMPI and under MPICH2 environments on 
Windows systems, although the primary target systems are HPC clusters running
Linux OS.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allgather">allgather</a>()</code>,
<code><a href="#topic+allreduce">allreduce</a>()</code>,
<code><a href="#topic+bcast">bcast</a>()</code>,
<code><a href="#topic+gather">gather</a>()</code>,
<code><a href="#topic+reduce">reduce</a>()</code>,
<code><a href="#topic+scatter">scatter</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### On command line, run each demo with 2 processors by
### (Use Rscript.exe on Windows systems)
# mpiexec -np 2 Rscript -e "demo(allgather,'pbdMPI',ask=F,echo=F)"
# mpiexec -np 2 Rscript -e "demo(allreduce,'pbdMPI',ask=F,echo=F)"
# mpiexec -np 2 Rscript -e "demo(bcast,'pbdMPI',ask=F,echo=F)"
# mpiexec -np 2 Rscript -e "demo(gather,'pbdMPI',ask=F,echo=F)"
# mpiexec -np 2 Rscript -e "demo(reduce,'pbdMPI',ask=F,echo=F)"
# mpiexec -np 2 Rscript -e "demo(scatter,'pbdMPI',ask=F,echo=F)"
### Or
# execmpi("demo(allgather,'pbdMPI',ask=F,echo=F)", nranks = 2L)
# execmpi("demo(allreduce,'pbdMPI',ask=F,echo=F)", nranks = 2L)
# execmpi("demo(bcast,'pbdMPI',ask=F,echo=F)", nranks = 2L)
# execmpi("demo(gather,'pbdMPI',ask=F,echo=F)", nranks = 2L)
# execmpi("demo(reduce,'pbdMPI',ask=F,echo=F)", nranks = 2L)
# execmpi("demo(scatter,'pbdMPI',ask=F,echo=F)", nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='allgather-methods'> All Ranks Gather Objects from Every Rank </h2><span id='topic+allgather-methods'></span><span id='topic+allgather+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic+allgather+2Cinteger+2Cinteger+2Cmissing-method'></span><span id='topic+allgather+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+allgather+2Craw+2Craw+2Cmissing-method'></span><span id='topic+allgather+2CANY+2Cmissing+2Cinteger-method'></span><span id='topic+allgather+2CANY+2CANY+2Cinteger-method'></span><span id='topic+allgather+2Cinteger+2Cinteger+2Cinteger-method'></span><span id='topic+allgather+2Cnumeric+2Cnumeric+2Cinteger-method'></span><span id='topic+allgather+2Craw+2Craw+2Cinteger-method'></span><span id='topic+allgather'></span><span id='topic+allgatherv'></span>

<h3>Description</h3>

<p>This method lets all ranks gather objects from every rank in the same
communicator. The default return is a list of length equal to
<code>comm.size(comm)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allgather(x, x.buffer = NULL, x.count = NULL, displs = NULL,
          comm = .pbd_env$SPMD.CT$comm,
          unlist = .pbd_env$SPMD.CT$unlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allgather-methods_+3A_x">x</code></td>
<td>
<p>an object to be gathered from all ranks.</p>
</td></tr>
<tr><td><code id="allgather-methods_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to hold the return object which probably has
'size of <code>x</code>' times '<code>comm.size(comm)</code>'
with the same type as <code>x</code>.</p>
</td></tr>
<tr><td><code id="allgather-methods_+3A_x.count">x.count</code></td>
<td>
<p>a vector of length '<code>comm.size(comm)</code>' containing all object lengths.</p>
</td></tr>
<tr><td><code id="allgather-methods_+3A_displs">displs</code></td>
<td>
<p><code>c(0L, cumsum(x.count))</code> by default.</p>
</td></tr>
<tr><td><code id="allgather-methods_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="allgather-methods_+3A_unlist">unlist</code></td>
<td>
<p>apply <code>unlist</code> function to the gathered list before
return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x.buffer</code>, <code>x.count</code>, and <code>displs</code> can be 
left unspecified or <code>NULL</code> and are computed for you. 
</p>
<p>If <code>x.buffer</code> is specified, its type should be one of integer, double,
or raw according to the type of <code>x</code>. Serialization and unserialization
is avoided for atomic vectors if they are
all the same size and <code>x.buffer</code> is specified, or if different sizes and
both <code>x.buffer</code> and <code>x.count</code> are specified. A single vector 
instead of a list is returned in these cases.
</p>
<p>Class <code>array</code> objects are gathered without serialization.
</p>
<p>Complex objects can be gathered as serialization and unserialization is used
on objects that are not of class &quot;array&quot; or atomic vectors.
</p>
<p>The <code>allgather</code> is efficient due to the underlying MPI parallel
communication and recursive doubling gathering algorithm that results in
a sublinear (<code>log2(comm.size(comm))</code>) number of communication steps.
Also, serialization is applied only locally and in parallel.
</p>
<p>See <code>methods{"allgather"}</code> for S4 dispatch cases and the source code for
further details.
</p>


<h3>Value</h3>

<p>A list of length <code>comm.size(comm)</code>, containing the gathered objects from
each rank, is returned to all ranks by default. An exception is for atomic
vectors, when
<code>x.buffer</code> is specified, where a list is never formed and a single
vector is returned. In other cases, the <code>unlist = TRUE</code> parameter
simply applies the <code>unlist()</code> function to this list before returning.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather">gather</a>()</code>, <code><a href="#topic+allreduce">allreduce</a>()</code>, <code><a href="#topic+reduce">reduce</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
y &lt;- allgather(matrix(x, nrow = 1))
comm.print(y)

y &lt;- allgather(x, double(N * .comm.size))
comm.print(y)

### Finish
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='allreduce-method'> All Ranks Receive a Reduction of Objects from Every Rank </h2><span id='topic+allreduce-method'></span><span id='topic+allreduce+2CANY+2Cmissing-method'></span><span id='topic+allreduce+2Cinteger+2Cinteger-method'></span><span id='topic+allreduce+2Cnumeric+2Cnumeric-method'></span><span id='topic+allreduce+2Clogical+2Clogical-method'></span><span id='topic+allreduce+2Cfloat32+2Cfloat32-method'></span><span id='topic+allreduce'></span>

<h3>Description</h3>

<p>This method lets all ranks receive a reduction of objects from every
rank in the same communicator based on a given operation. The default
return is an object like the input and the default operation is the sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allreduce(x, x.buffer = NULL, op = .pbd_env$SPMD.CT$op,
          comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allreduce-method_+3A_x">x</code></td>
<td>
<p>an object to be reduced from all ranks.</p>
</td></tr>
<tr><td><code id="allreduce-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>for atomic vectors, a buffer to hold the return object which
has the same size and the same type as <code>x</code>.</p>
</td></tr>
<tr><td><code id="allreduce-method_+3A_op">op</code></td>
<td>
<p>the reduction operation to apply to <code>x</code> across all <code>comm</code>
ranks. The default is normally sum.</p>
</td></tr> 
<tr><td><code id="allreduce-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All ranks are presumed to have <code>x</code> of the same size and type.
</p>
<p>Normally, <code>x.buffer</code> is <code>NULL</code> or unspecified, and is computed
for you. If specified for atomic vectors, the type should be one of integer,
double, or raw and be the same type as <code>x</code>. 
</p>
<p>The <code>allgather</code> is efficient due to the underlying MPI parallel
communication and recursive doubling reduction algorithm that results in
a sublinear (<code>log2(comm.size(comm))</code>) number of reduction and 
communication steps.
</p>
<p>See <code>methods{"allreduce"}</code> for S4 dispatch cases and the source code for
further details.
</p>


<h3>Value</h3>

<p>The reduced object of the same type as <code>x</code> is returned to all ranks
by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allgather">allgather</a>()</code>, <code><a href="#topic+gather">gather</a>()</code>, <code><a href="#topic+reduce">reduce</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
y &lt;- allreduce(matrix(x, nrow = 1), op = \"sum\")
comm.print(y)

y &lt;- allreduce(x, double(N), op = \"prod\")
comm.print(y)

comm.set.seed(1234, diff = TRUE)
x &lt;- as.logical(round(runif(N)))
y &lt;- allreduce(x, logical(N), op = \"land\")
comm.print(y)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code = spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='alltoall'> All to All </h2><span id='topic+alltoall'></span><span id='topic+spmd.alltoall.integer'></span><span id='topic+spmd.alltoall.double'></span><span id='topic+spmd.alltoall.raw'></span><span id='topic+spmd.alltoallv.integer'></span><span id='topic+spmd.alltoallv.double'></span><span id='topic+spmd.alltoallv.raw'></span>

<h3>Description</h3>

<p>These functions make calls to <code>MPI_Alltoall()</code> and
<code>MPI_Alltoallv()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spmd.alltoall.integer(x.send, x.recv, send.count, recv.count,
                      comm = .pbd_env$SPMD.CT$comm)
spmd.alltoall.double(x.send, x.recv, send.count, recv.count,
                    comm = .pbd_env$SPMD.CT$comm)
spmd.alltoall.raw(x.send, x.recv, send.count, recv.count,
                  comm = .pbd_env$SPMD.CT$comm)

spmd.alltoallv.integer(x.send, x.recv, send.count, recv.count,
                       sdispls, rdispls, comm = .pbd_env$SPMD.CT$comm)
spmd.alltoallv.double(x.send, x.recv, send.count, recv.count,
                      sdispls, rdispls, comm = .pbd_env$SPMD.CT$comm)
spmd.alltoallv.raw(x.send, x.recv, send.count, recv.count,
                   sdispls, rdispls, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alltoall_+3A_x.send">x.send</code></td>
<td>
<p>an object to send.</p>
</td></tr>
<tr><td><code id="alltoall_+3A_x.recv">x.recv</code></td>
<td>
<p>an object to receive</p>
</td></tr>
<tr><td><code id="alltoall_+3A_send.count">send.count</code></td>
<td>
<p>send counter</p>
</td></tr>
<tr><td><code id="alltoall_+3A_recv.count">recv.count</code></td>
<td>
<p>recv counter</p>
</td></tr>
<tr><td><code id="alltoall_+3A_sdispls">sdispls</code></td>
<td>
<p>send dis pls</p>
</td></tr>
<tr><td><code id="alltoall_+3A_rdispls">rdispls</code></td>
<td>
<p>recv dis pls</p>
</td></tr>
<tr><td><code id="alltoall_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are very low level functions. Use with cautions. Neigher S4 method nor
long vector is supported.
</p>


<h3>Value</h3>

<p>These are very low level functions. Use with cautions. Neigher S4 method nor
long vector is supported.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allgather">allgather</a>()</code>, <code><a href="#topic+allgatherv">allgatherv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript --vanilla [...].r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
n &lt;- as.integer(2)
x &lt;- 1:(.comm.size * n)
comm.cat(\"Original x:\n\", quiet = TRUE)
comm.print(x, all.rank = TRUE)

x &lt;- as.integer(x)
y &lt;- spmd.alltoall.integer(x, integer(length(x)), n, n)
comm.cat(\"\nAlltoall y:\n\", quiet = TRUE)
comm.print(y, all.rank = TRUE)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='apply+20and+20lapply'> Parallel Apply and Lapply Functions </h2><span id='topic+pbdApply'></span><span id='topic+pbdLapply'></span><span id='topic+pbdSapply'></span>

<h3>Description</h3>

<p>The functions are parallel versions of apply and lapply functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbdApply(X, MARGIN, FUN, ..., pbd.mode = c("mw", "spmd", "dist"),
         rank.source = .pbd_env$SPMD.CT$rank.root,
         comm = .pbd_env$SPMD.CT$comm,
         barrier = TRUE)
pbdLapply(X, FUN, ..., pbd.mode = c("mw", "spmd", "dist"),
          rank.source = .pbd_env$SPMD.CT$rank.root,
          comm = .pbd_env$SPMD.CT$comm,
          bcast = FALSE, barrier = TRUE)
pbdSapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE,
          pbd.mode = c("mw", "spmd", "dist"),
          rank.source = .pbd_env$SPMD.CT$rank.root,
          comm = .pbd_env$SPMD.CT$comm,
          bcast = FALSE, barrier = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_x">X</code></td>
<td>
<p>a matrix or array in <code>pbdApply()</code> or a list in
<code>pbdLapply()</code> and <code>pbdSapply()</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_margin">MARGIN</code></td>
<td>
<p><code>MARGIN</code> as in the <code>apply()</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_fun">FUN</code></td>
<td>
<p>as in the <code>apply()</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_simplify">simplify</code></td>
<td>
<p>as in the <code>sapply()</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>as in the <code>sapply()</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_pbd.mode">pbd.mode</code></td>
<td>
<p>mode of distributed data <code>X</code>.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_rank.source">rank.source</code></td>
<td>
<p>a rank of source where <code>X</code> broadcast from.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_bcast">bcast</code></td>
<td>
<p>if bcast to all ranks.</p>
</td></tr>
<tr><td><code id="apply+2B20and+2B20lapply_+3A_barrier">barrier</code></td>
<td>
<p>if barrier for all ranks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions are majorly called in manager/workers mode
(<code>pbd.model = "mw"</code>), and just work the same as their
serial version.
</p>
<p>If <code>pbd.mode = "mw"</code>, the <code>X</code> in <code>rank.source</code> (manager)
will be distributed to the workers, then <code>FUN</code> will be applied to
the new data, and results gathered to <code>rank.source</code>.
&ldquo;In SPMD, the manager is one of workers.&rdquo;
<code>...</code> is also <code>scatter()</code> from <code>rank.source</code>.
</p>
<p>If <code>pbd.mode = "spmd"</code>, the same copy of <code>X</code> is expected
on all ranks, and the original <code>apply()</code>, <code>lapply()</code>,
or <code>sapply()</code> will operate on part of
<code>X</code>. An explicit <code>allgather()</code> or <code>gather()</code> will be needed to
aggregate the results.
</p>
<p>If <code>pbd.mode = "dist"</code>, different <code>X</code> are expected on
all ranks, i.e. &lsquo;distinct or distributed&rsquo; <code>X</code>,
and original <code>apply()</code>, <code>lapply()</code>, or <code>sapply()</code> will operate
on the distinct <code>X</code>. An explicit <code>allgather()</code> or <code>gather()</code> 
will be needed to aggregate the results.
</p>
<p>In SPMD, it is better to split data into pieces, so that <code>X</code> is a local
piece of a global matrix. If the &quot;apply&quot; dimension is local, the base 
<code>apply()</code> function can be used. 
</p>


<h3>Value</h3>

<p>A list or a matrix will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Example for pbdApply.
N &lt;- 100
x &lt;- matrix((1:N) + N * .comm.rank, ncol = 10)
y &lt;- pbdApply(x, 1, sum, pbd.mode = \"mw\")
comm.print(y)

y &lt;- pbdApply(x, 1, sum, pbd.mode = \"spmd\")
comm.print(y)

y &lt;- pbdApply(x, 1, sum, pbd.mode = \"dist\")
comm.print(y)


### Example for pbdApply for 3D array.
N &lt;- 60
x &lt;- array((1:N) + N * .comm.rank, c(3, 4, 5))
dimnames(x) &lt;- list(lat = paste(\"lat\", 1:3, sep = \"\"),
                    lon = paste(\"lon\", 1:4, sep = \"\"),
                    time = paste(\"time\", 1:5, sep = \"\"))
comm.print(x[,, 1:2])

y &lt;- pbdApply(x, c(1, 2), sum, pbd.mode = \"mw\")
comm.print(y)

y &lt;- pbdApply(x, c(1, 2), sum, pbd.mode = \"spmd\")
comm.print(y)

y &lt;- pbdApply(x, c(1, 2), sum, pbd.mode = \"dist\")
comm.print(y)


### Example for pbdLapply.
N &lt;- 100
x &lt;- split((1:N) + N * .comm.rank, rep(1:10, each = 10))
y &lt;- pbdLapply(x, sum, pbd.mode = \"mw\")
comm.print(unlist(y))

y &lt;- pbdLapply(x, sum, pbd.mode = \"spmd\")
comm.print(unlist(y))

y &lt;- pbdLapply(x, sum, pbd.mode = \"dist\")
comm.print(unlist(y))

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='bcast-method'> A Rank Broadcast an Object to Every Rank </h2><span id='topic+bcast-method'></span><span id='topic+bcast+2CANY-method'></span><span id='topic+bcast+2Cinteger-method'></span><span id='topic+bcast+2Cnumeric-method'></span><span id='topic+bcast+2Craw-method'></span><span id='topic+bcast'></span>

<h3>Description</h3>

<p>This method lets a rank broadcast an object to every rank in the same
communicator. The default return is the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcast(x, rank.source = .pbd_env$SPMD.CT$rank.source,
      comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcast-method_+3A_x">x</code></td>
<td>
<p>an object to be broadcast from all ranks.</p>
</td></tr>
<tr><td><code id="bcast-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a rank of source where <code>x</code> broadcast from.</p>
</td></tr>
<tr><td><code id="bcast-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same copy of <code>x</code> is sent to all ranks.
</p>
<p>See <code>methods{"bcast"}</code> for S4 dispatch cases and the source code for
further details.
</p>


<h3>Value</h3>

<p>Every rank has <code>x</code> returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scatter">scatter</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
x &lt;- matrix(1:5, nrow = 1)
y &lt;- bcast(x)
comm.print(y)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='Comm+20Internal+20Functions'> All Comm Internal Functions </h2><span id='topic+comm.set.errhandler'></span><span id='topic+comm.sort.integer'></span><span id='topic+comm.sort.double'></span><span id='topic+comm.sort.default'></span><span id='topic+comm.allcommon.integer'></span><span id='topic+comm.dist.common'></span><span id='topic+comm.dist.gbd'></span><span id='topic+comm.pairwise.common'></span><span id='topic+comm.pairwise.gbd'></span>

<h3>Description</h3>

<p> All comm internal functions </p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='comm.chunk'>comm.chunk</h2><span id='topic+comm.chunk'></span>

<h3>Description</h3>

<p>Given a total number of items, N, comm.chunk splits the number into
chunks. Tailored especially for situations in SPMD style
programming, potentially returning different results to each rank.
Optionally, results for all ranks can be returned to all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.chunk(
  N,
  form = "number",
  type = "balance",
  lo.side = "right",
  rng = FALSE,
  all.rank = FALSE,
  p = NULL,
  rank = NULL,
  comm = .pbd_env$SPMD.CT$comm,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.chunk_+3A_n">N</code></td>
<td>
<p>The number of items to split into chunks.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_form">form</code></td>
<td>
<p>Output a chunk as a single &quot;number&quot;, as a &quot;vector&quot; of items from 1:N,
or as a &quot;seq&quot; three parameters 'c(from, to, by)' of the base 'seq()' function
(replaced deprecated &quot;iopair&quot; for offset and length in a file). Forms &quot;ldim&quot;
and &quot;bldim&quot; are available only with type &quot;equal&quot; and are intended for setting
&quot;ddmatrix&quot; (see package pbdDMAT) slots.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_type">type</code></td>
<td>
<p>Is the primary load and location balance specification. The choices are:
&quot;balance&quot; the chunks so they differ by no more than 1 item (used most
frequently and default); &quot;cycle&quot; is the same as &quot;balance&quot; in terms of
load but differs on location in that chunks are not contiguous, rather are
assigned in a cycled way to ranks (note that &quot;balance&quot; and &quot;cycle&quot; are the
same if 'form' is &quot;number&quot;);  &quot;equal&quot; maximizes the number of same size
chunks resulting in one or more smaller or even zero size chunks carrying
the leftover (required by pbdDMAT block-cyclic layouts).</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_lo.side">lo.side</code></td>
<td>
<p>If exact balance is not possible, put the smaller chunks on the 
&quot;left&quot;  (low ranks) or on the &quot;right&quot; (high ranks).</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_rng">rng</code></td>
<td>
<p>If TRUE, set up different L'Ecuyere random number generator streams. 
Switch to stream <code>i</code> with <code><a href="#topic+comm.set.stream">comm.set.stream</a>(i)</code>, 
where <code>i</code> is a global index. If <code>form = "vector"</code> random streams are 
set up for each index in the vector and only those needed by each rank are
kept.
If <code>form = "number"</code>, each rank will use a different stream, set by
default (so <code><a href="#topic+comm.set.stream">comm.set.stream</a></code> does not need to be used).
Additional ... parameter 
<code>seed</code>, passed to <code><a href="#topic+comm.set.seed">comm.set.seed</a></code>, can be set for
reproducibility.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_all.rank">all.rank</code></td>
<td>
<p>FALSE returns only the chunk for rank r. TRUE returns a vector of
length p (when form=&quot;number&quot;), and a list of length p (when form=&quot;vector&quot;)
each containing the output for the corresponding rank.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_p">p</code></td>
<td>
<p>The number of chunks (processors). Normally, it is NOT specified and defaults
to NULL, which assigns comm.size(comm).</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_rank">rank</code></td>
<td>
<p>The rank of returned chunk. Normally, it is NOT specified and defaults to
NULL, which assigns comm.rank(comm)). Note that ranks are numbered from 0 to
p-1, whereas the list elements for all.rank=TRUE are numbered 1 to p.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_comm">comm</code></td>
<td>
<p>The communicator that determines MPI rank numbers.</p>
</td></tr>
<tr><td><code id="comm.chunk_+3A_...">...</code></td>
<td>
<p>If <code>rng = TRUE</code>, then a <code>seed</code> parameter should be
provided for <a href="#topic+comm.set.seed">comm.set.seed</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various chunking options are possible when the number does not
split evenly into equal chunks. The output form can be a number,
a vector of items, or a few other special forms intended for pbdR components.
</p>


<h3>Value</h3>

<p>A numeric value from 0:N or a vector giving a subset of 1:N (depending on
form) for the rank. If all.rank is TRUE, a vector or a list of
vectors, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Note that the p and rank parameters are provided by comm.size() and
## comm.rank(), respectively, when running SPMD in parallel. Normally, they
## are not specified unless testing in serial mode (as in this example).
library(pbdIO)

comm.chunk(16, all.rank = TRUE, p = 5)
comm.chunk(16, type = "equal", all.rank = TRUE, p = 5)
comm.chunk(16, type = "equal", lo.side = "left", all.rank = TRUE, p = 5)
comm.chunk(16, p = 5, rank = 0)
comm.chunk(16, p = 5, lo.side = "left", rank = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='communicator'> Communicator Functions </h2><span id='topic+barrier'></span><span id='topic+comm.is.null'></span><span id='topic+comm.rank'></span><span id='topic+comm.localrank'></span><span id='topic+comm.size'></span><span id='topic+comm.dup'></span><span id='topic+comm.free'></span><span id='topic+init'></span><span id='topic+finalize'></span><span id='topic+is.finalized'></span><span id='topic+comm.abort'></span><span id='topic+comm.split'></span><span id='topic+comm.disconnect'></span><span id='topic+comm.connect'></span><span id='topic+comm.accept'></span><span id='topic+port.open'></span><span id='topic+port.close'></span><span id='topic+serv.publish'></span><span id='topic+serv.unpublish'></span><span id='topic+serv.lookup'></span><span id='topic+intercomm.merge'></span><span id='topic+intercomm.create'></span><span id='topic+comm.c2f'></span>

<h3>Description</h3>

<p>The functions provide controls to communicators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barrier(comm = .pbd_env$SPMD.CT$comm)
comm.is.null(comm = .pbd_env$SPMD.CT$comm)
comm.rank(comm = .pbd_env$SPMD.CT$comm)
comm.localrank(comm = .pbd_env$SPMD.CT$comm)
comm.size(comm = .pbd_env$SPMD.CT$comm)
comm.dup(comm, newcomm)
comm.free(comm = .pbd_env$SPMD.CT$comm)
init(set.seed = TRUE)
finalize(mpi.finalize = .pbd_env$SPMD.CT$mpi.finalize)
is.finalized()

comm.abort(errorcode = 1, comm = .pbd_env$SPMD.CT$comm)
comm.split(comm = .pbd_env$SPMD.CT$comm, color = 0L, key = 0L,
           newcomm = .pbd_env$SPMD.CT$newcomm)
comm.disconnect(comm = .pbd_env$SPMD.CT$comm)
comm.connect(port.name, info = .pbd_env$SPMD.CT$info,
             rank.root = .pbd_env$SPMD.CT$rank.root,
             comm = .pbd_env$SPMD.CT$comm,
             newcomm = .pbd_env$SPMD.CT$newcomm)
comm.accept(port.name, info = .pbd_env$SPMD.CT$info,
            rank.root = .pbd_env$SPMD.CT$rank.root,
            comm = .pbd_env$SPMD.CT$comm,
            newcomm = .pbd_env$SPMD.CT$newcomm)

port.open(info = .pbd_env$SPMD.CT$info)
port.close(port.name)
serv.publish(port.name, serv.name = .pbd_env$SPMD.CT$serv.name,
             info = .pbd_env$SPMD.CT$info)
serv.unpublish(port.name, serv.name = .pbd_env$SPMD.CT$serv.name,
               info = .pbd_env$SPMD.CT$info)
serv.lookup(serv.name = .pbd_env$SPMD.CT$serv.name,
            info = .pbd_env$SPMD.CT$info)

intercomm.merge(intercomm = .pbd_env$SPMD.CT$intercomm,
                high = 0L, comm = .pbd_env$SPMD.CT$comm)
intercomm.create(local.comm = .pbd_env$SPMD.CT$comm,
                 local.leader = .pbd_env$SPMD.CT$rank.source,
                 peer.comm = .pbd_env$SPMD.CT$intercomm,
                 remote.leader = .pbd_env$SPMD.CT$rank.dest,
                 tag = .pbd_env$SPMD.CT$tag, 
                 newintercomm = .pbd_env$SPMD.CT$newcomm)

comm.c2f(comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communicator_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_mpi.finalize">mpi.finalize</code></td>
<td>
<p>if MPI should be shutdown.</p>
</td></tr>
<tr><td><code id="communicator_+3A_set.seed">set.seed</code></td>
<td>
<p>if a random seed preset.</p>
</td></tr>
<tr><td><code id="communicator_+3A_port.name">port.name</code></td>
<td>
<p>a port name with default maximum length
1024 characters for OpenMPI.</p>
</td></tr>
<tr><td><code id="communicator_+3A_info">info</code></td>
<td>
<p>a info number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_rank.root">rank.root</code></td>
<td>
<p>a root rank.</p>
</td></tr>
<tr><td><code id="communicator_+3A_newcomm">newcomm</code></td>
<td>
<p>a new communicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_color">color</code></td>
<td>
<p>control of subset assignment.</p>
</td></tr>
<tr><td><code id="communicator_+3A_key">key</code></td>
<td>
<p>control of rank assigment.</p>
</td></tr>
<tr><td><code id="communicator_+3A_serv.name">serv.name</code></td>
<td>
<p>a service name.</p>
</td></tr>
<tr><td><code id="communicator_+3A_errorcode">errorcode</code></td>
<td>
<p>an error code to abort MPI.</p>
</td></tr>
<tr><td><code id="communicator_+3A_intercomm">intercomm</code></td>
<td>
<p>a intercommunicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_high">high</code></td>
<td>
<p>used to order the groups within comm.</p>
</td></tr>
<tr><td><code id="communicator_+3A_local.comm">local.comm</code></td>
<td>
<p>a local communicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_local.leader">local.leader</code></td>
<td>
<p>the leader number of local communicator.</p>
</td></tr>
<tr><td><code id="communicator_+3A_peer.comm">peer.comm</code></td>
<td>
<p>a peer communicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_remote.leader">remote.leader</code></td>
<td>
<p>the remote leader number of peer communicator.</p>
</td></tr>
<tr><td><code id="communicator_+3A_newintercomm">newintercomm</code></td>
<td>
<p>a new intercommunicator number.</p>
</td></tr>
<tr><td><code id="communicator_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Another functions are direct calls to MPI library.
</p>
<p><code>barrier()</code> blocks all processors until everyone call this.
</p>
<p><code>comm.is.null()</code> returns <code>-1</code> if the array of communicators is not
allocated, i.e. <code>init()</code> is not called yet. It returns <code>1</code>
if the communicator is not initialized, i.e. <code>NULL</code>. It
returns <code>0</code> if the communicator is initialized.
</p>
<p><code>comm.rank()</code> returns the processor's rank for the given <code>comm</code>.
</p>
<p><code>comm.size()</code> returns the total processes for the given <code>comm</code>.
</p>
<p><code>comm.dup()</code> duplicate a <code>newcomm</code> from <code>comm</code>.
</p>
<p><code>comm.free()</code> free a <code>comm</code>.
</p>
<p><code>init()</code> initializes a MPI world, and set two global variables
<code>.comm.size</code> and <code>.comm.rank</code> in <code>.GlobalEnv</code>. A random seed
will be preset by default (<code>Sys.getpid() + Sys.time()</code>) to the package
<span class="pkg">rlecuyer</span>.
</p>
<p><code>finalize()</code> frees memory and finishes a MPI world if
<code>mpi.finalize = TRUE</code>.
<code>is.finalized()</code> checks if MPI is already finalized.
</p>
<p><code>comm.abort()</code> aborts MPI.
</p>
<p><code>comm.split()</code> create a <code>newcomm</code> by color and key.
</p>
<p><code>comm.disconnect()</code> frees a <code>comm</code>.
</p>
<p><code>comm.connect()</code> connects a <code>newcomm</code>.
</p>
<p><code>comm.accept()</code> accepts a <code>newcomm</code>.
</p>
<p><code>port.open()</code> opens a port and returns the port name.
</p>
<p><code>port.close()</code> closes a port by name.
</p>
<p><code>serv.publish()</code> publishs a service via <code>port.name</code>.
</p>
<p><code>serv.unpublish()</code> unpublishs a service via <code>port.name</code>.
</p>
<p><code>serv.lookup()</code> lookup the <code>serv.name</code> and returns the port name.
</p>
<p><code>intercomm.merge()</code> merges the <code>intercomm</code> to intracommunicator.
</p>
<p><code>intercomm.create()</code> creates a new <code>intercomm</code> from two
peer intracommunicators.
</p>
<p><code>comm.c2f()</code> returns an integer for Fortran MPI support.
</p>


<h3>Value</h3>

<p>Most function return an invisible state of MPI call.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples .
comm.print(.comm.size)
comm.print(.comm.rank, all.rank = TRUE)
comm.print(comm.rank(), rank.print = 1)
comm.print(comm.c2f())

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='gather-methods'> A Rank Gathers Objects from Every Rank </h2><span id='topic+gather-methods'></span><span id='topic+gather+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic+gather+2Cinteger+2Cinteger+2Cmissing-method'></span><span id='topic+gather+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+gather+2Craw+2Craw+2Cmissing-method'></span><span id='topic+gather+2CANY+2Cmissing+2Cinteger-method'></span><span id='topic+gather+2CANY+2CANY+2Cinteger-method'></span><span id='topic+gather+2Cinteger+2Cinteger+2Cinteger-method'></span><span id='topic+gather+2Cnumeric+2Cnumeric+2Cinteger-method'></span><span id='topic+gather+2Craw+2Craw+2Cinteger-method'></span><span id='topic+gather'></span><span id='topic+gatherv'></span>

<h3>Description</h3>

<p>This method lets one rank gather objects from every rank in the same
communicator. The default return is a list of length equal to <code>comm size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather(x, x.buffer = NULL, x.count = NULL, displs = NULL,
       rank.dest = .pbd_env$SPMD.CT$rank.root,
       comm = .pbd_env$SPMD.CT$comm,
       unlist = .pbd_env$SPMD.CT$unlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather-methods_+3A_x">x</code></td>
<td>
<p>an object to be gathered from all ranks.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to hold the return object which probably has
'size of <code>x</code>' times '<code>comm.size(comm)</code>' 
with the same type of <code>x</code>.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_x.count">x.count</code></td>
<td>
<p>a vector of length '<code>comm.size(comm)</code>' containing all
object lengths.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_displs">displs</code></td>
<td>
<p><code>c(0L, cumsum(x.count))</code> by default.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where all <code>x</code> gather to.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="gather-methods_+3A_unlist">unlist</code></td>
<td>
<p>apply <code>unlist</code> function to the gathered list before
return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>x.buffer</code>, <code>x.count</code>, and <code>displs</code> can be 
left unspecified or <code>NULL</code> and are computed for you. 
</p>
<p>If <code>x.buffer</code> is specified, its type should be one of integer, double,
or raw according to the type of <code>x</code>. Serialization and unserialization
is avoided for atomic vectors if they are
all the same size and <code>x.buffer</code> is specified, or if different sizes and
both <code>x.buffer</code> and <code>x.count</code> are specified. A single vector 
instead of a list is returned in these cases.
</p>
<p>Class <code>array</code> objects are gathered without serialization.
</p>
<p>Complex objects can be gathered as serialization and unserialization is used
on objects that are not of class &quot;array&quot; or atomic vectors.
</p>
<p>The <code>gather</code> is efficient due to the underlying MPI parallel
communication and recursive doubling gathering algorithm that results in
a sublinear (<code>log2(comm.size(comm))</code>) number of communication steps.
Also, serialization is applied only locally and in parallel.
</p>
<p>See <code>methods{"gather"}</code> for S4 dispatch cases and the source code for
further details.
</p>


<h3>Value</h3>

<p>Only <code>rank.dest</code> (by default rank 0) receives the gathered object. All
other ranks receive <code>NULL</code>.
See <code><a href="#topic+allgather">allgather</a>()</code> for a description of the gathered object.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allgather">allgather</a>()</code>, <code><a href="#topic+allreduce">allreduce</a>()</code>, <code><a href="#topic+reduce">reduce</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
y &lt;- gather(matrix(x, nrow = 1))
comm.print(y)

y &lt;- gather(x, double(N * .comm.size))
comm.print(y)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='Get+20Configures+20Used+20at+20Compiling+20Time'>Functions to Get MPI and/or pbdMPI Configures Used at Compiling Time</h2><span id='topic+get.conf'></span><span id='topic+get.lib'></span><span id='topic+get.sysenv'></span>

<h3>Description</h3>

<p>These functions are designed to get MPI and/or pbdMPI configures that
were usually needed at the time of pbdMPI installation. In particular,
to configure, link, and compile with 'libmpi*.so' or so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.conf(arg, arch = '', package = "pbdMPI", return = FALSE)
get.lib(arg, arch, package = "pbdPROF")
get.sysenv(flag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get+2B20Configures+2B20Used+2B20at+2B20Compiling+2B20Time_+3A_arg">arg</code></td>
<td>
<p>an argument to be searched in the configuration file</p>
</td></tr>
<tr><td><code id="Get+2B20Configures+2B20Used+2B20at+2B20Compiling+2B20Time_+3A_arch">arch</code></td>
<td>
<p>system architecture</p>
</td></tr>
<tr><td><code id="Get+2B20Configures+2B20Used+2B20at+2B20Compiling+2B20Time_+3A_package">package</code></td>
<td>
<p>pakge name</p>
</td></tr>
<tr><td><code id="Get+2B20Configures+2B20Used+2B20at+2B20Compiling+2B20Time_+3A_return">return</code></td>
<td>
<p>to return (or print if FALSE) the search results or not</p>
</td></tr>
<tr><td><code id="Get+2B20Configures+2B20Used+2B20at+2B20Compiling+2B20Time_+3A_flag">flag</code></td>
<td>
<p>a system flag that is typically used in windows environment
<code>set</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.conf()</code> and <code>get.lib()</code>
are typically used by 'pbd*/configure.ac',
'pbd*/src/Makevars.in', and/or 'pbd*/src/Makevar.win' to find
the default configurations from 'pbd*/etc${R_ARCH}/Makconf'.
</p>
<p><code>get.sysenv()</code>
is only called by 'pbdMPI/src/Makevars.win' to obtain
possible MPI dynamic/static library from the environment variable
'MPI_ROOT' preset by users.
</p>


<h3>Value</h3>

<p>Typically, there are no return values, but the values are <code>cat()</code> to
scrrn or stdin.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdMPI)
if(Sys.info()["sysname"] != "Windows"){
  get.conf("MPI_INCLUDE_PATH"); cat("\n")
  get.conf("MPI_LIBPATH"); cat("\n")
  get.conf("MPI_LIBNAME"); cat("\n")
  get.conf("MPI_LIBS"); cat("\n")
} else{
  get.conf("MPI_INCLUDE", "/i386"); cat("\n")
  get.conf("MPI_LIB", "/i386"); cat("\n")

  get.conf("MPI_INCLUDE", "/x64"); cat("\n")
  get.conf("MPI_LIB", "/x64"); cat("\n")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='get+20job+20id'> Divide Job ID by Ranks </h2><span id='topic+get.jid'></span>

<h3>Description</h3>

<p>This function obtains job id which can be used to divide jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.jid(n, method = .pbd_env$SPMD.CT$divide.method[1], all = FALSE,
        comm = .pbd_env$SPMD.CT$comm, reduced = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get+2B20job+2B20id_+3A_n">n</code></td>
<td>
<p>total number of jobs.</p>
</td></tr>
<tr><td><code id="get+2B20job+2B20id_+3A_method">method</code></td>
<td>
<p>a way to divide jobs.</p>
</td></tr>
<tr><td><code id="get+2B20job+2B20id_+3A_all">all</code></td>
<td>
<p>indicate if return all id for each processor.</p>
</td></tr>
<tr><td><code id="get+2B20job+2B20id_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="get+2B20job+2B20id_+3A_reduced">reduced</code></td>
<td>
<p>indicate if return should be a reduced representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n</code> is total number of jobs needed to be divided into all processors
(<code>comm.size(comm)</code>, i.e. <code>1:n</code> will be split according to
the rank of processor (<code>comm.rank(comm)</code>) and <code>method</code>.
Job id will be returned. Currently, three possible methods are provided.
</p>
<p><code>"block"</code> will use return id's which are nearly equal size blocks.
For example,
7 jobs in 4 processors will have <code>jid=1</code> for rank 0, <code>jid=2,3</code>
for rank 1, <code>jid=4,5</code> for rank 2, and <code>jid=6,7</code> for rank 3.
</p>
<p><code>"block0"</code> will use return id's which are nearly equal size blocks,
in the opposite direction of <code>"block"</code>.
For example,
7 jobs in 4 processors will have <code>jid=1,2</code> for rank 0, <code>jid=3,4</code>
for rank 1, <code>jid=5,6</code> for rank 2, and <code>jid=7</code> for rank 3.
</p>
<p><code>"cycle"</code> will use return id's which are nearly equal size in cycle.
For example, 7 jobs in 4 processors will have <code>jid=1,5</code> for rank 0,
<code>jid=2,6</code> for rank 1, <code>jid=3,7</code> for rank 2, and <code>jid=4</code>
for rank 3.
</p>


<h3>Value</h3>

<p><code>get.jid()</code> returns a vector containing job id for each individual
processor if <code>all = FALSE</code>. While it returns a list containing all
job id for all processor if <code>all = TRUE</code>. The list has length equal
to <code><a href="#topic+comm.size">comm.size</a></code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+task.pull">task.pull</a>() and <a href="#topic+comm.chunk">comm.chunk</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
comm.cat(\"&gt;&gt;&gt; block\n\", quiet = TRUE)
jid &lt;- get.jid(7, method = \"block\")
comm.print(jid, all.rank = TRUE)

comm.cat(\"&gt;&gt;&gt; cycle\n\", quiet = TRUE)
jid &lt;- get.jid(7, method = \"cycle\")
comm.print(jid, all.rank = TRUE)

comm.cat(\"&gt;&gt;&gt; block (all)\n\", quiet = TRUE)
alljid &lt;- get.jid(7, method = \"block\", all = TRUE)
comm.print(alljid)

comm.cat(\"&gt;&gt;&gt; cycle (all)\n\", quiet = TRUE)
alljid &lt;- get.jid(7, method = \"cycle\", all = TRUE)
comm.print(alljid)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='global+20all+20pairs'> Global All Pairs </h2><span id='topic+comm.allpairs'></span>

<h3>Description</h3>

<p>This function provide global all pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.allpairs(N, diag = FALSE, symmetric = TRUE,
              comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20all+2B20pairs_+3A_n">N</code></td>
<td>
<p>number of elements for matching, <code>(i, j)</code> for all
<code>1 &lt;= i,j &lt;= N</code>.</p>
</td></tr>
<tr><td><code id="global+2B20all+2B20pairs_+3A_diag">diag</code></td>
<td>
<p>if matching the same elements, <code>(i, i)</code> for all <code>i</code>.</p>
</td></tr>
<tr><td><code id="global+2B20all+2B20pairs_+3A_symmetric">symmetric</code></td>
<td>
<p>if matching upper triangular elements. TRUE for
<code>i &gt;= j</code> only, otherwise for all <code>(i, j)</code>.</p>
</td></tr>
<tr><td><code id="global+2B20all+2B20pairs_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates all combinations of <code>N</code> elements.
</p>


<h3>Value</h3>

<p>The function returns a gbd matrix in row blocks with 2 columns
named <code>i</code> and <code>j</code>. The number of rows is dependent
on the options <code>diag</code> and <code>symmetric</code>. If <code>diag = TRUE</code> and
<code>symmetric = FALSE</code>, then this case has the maximum number of rows,
<code>N^2</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.dist">comm.dist</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
id.matrix &lt;- comm.allpairs(comm.size() + 1)
comm.print(id.matrix, all.rank = TRUE)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20any+20and+20all'> Global Any and All Functions </h2><span id='topic+comm.any'></span><span id='topic+comm.all'></span><span id='topic+comm.allcommon'></span>

<h3>Description</h3>

<p>These functions are global any and all applying on distributed data
for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.any(x, na.rm = FALSE, comm = .pbd_env$SPMD.CT$comm)
comm.all(x, na.rm = FALSE, comm = .pbd_env$SPMD.CT$comm)

comm.allcommon(x, comm = .pbd_env$SPMD.CT$comm,
               lazy.check = .pbd_env$SPMD.CT$lazy.check)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20any+2B20and+2B20all_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="global+2B20any+2B20and+2B20all_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>NA</code> removed or not.</p>
</td></tr>
<tr><td><code id="global+2B20any+2B20and+2B20all_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="global+2B20any+2B20and+2B20all_+3A_lazy.check">lazy.check</code></td>
<td>
<p>if TRUE, then <code>allreduce</code> is used to check all ranks,
otherwise, <code>allgather</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply <code>any()</code> and <code>all()</code> locally, and
apply <code>allgather()</code> to get all local results from other ranks, then
apply <code>any()</code> and <code>all()</code> on all local results.
</p>
<p><code>comm.allcommon()</code> is to check if <code>x</code> is exactly the same
across all ranks. This is a vectorized operation on <code>x</code> where the
input and output have the same length of vector, while <code>comm.any()</code>
and <code>comm.all()</code> return a scaler.
</p>
<p>Note that <code>lazy.check = TRUE</code> is faster as
number of cores is large, but it may cause some inconsistence in some
cases. <code>lazy.check = FALSE</code> is much slower, but it provides more
accurate checking.
</p>


<h3>Value</h3>

<p>The global check values (TRUE, FALSE, NA) are returned to all ranks.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
if(comm.rank() == 0){
  a &lt;- c(T, F, NA)
} else{
  a &lt;- T
}

comm.any(a)
comm.all(a)
comm.any(a, na.rm = TRUE)
comm.all(a, na.rm = TRUE)

comm.allcommon(1:3)
if(comm.rank() == 0){
  a &lt;- 1:3
} else{
  a &lt;- 3:1
}
comm.allcommon.integer(a)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20as.gbd'> Global As GBD Function </h2><span id='topic+comm.as.gbd'></span>

<h3>Description</h3>

<p>This function redistributes a regular matrix existed in rank.soure
and turns it in a gbd matrix in row blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.as.gbd(X, balance.method = .pbd_env$SPMD.IO$balance.method,
            rank.source = .pbd_env$SPMD.CT$rank.source,
            comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20as.gbd_+3A_x">X</code></td>
<td>
<p>a regular <code>matrix</code> in <code>rank.source</code> and to be
redistributed as a gbd.</p>
</td></tr>
<tr><td><code id="global+2B20as.gbd_+3A_balance.method">balance.method</code></td>
<td>
<p>a balance method.</p>
</td></tr>
<tr><td><code id="global+2B20as.gbd_+3A_rank.source">rank.source</code></td>
<td>
<p>a rank of source where elements of <code>x</code> scatter from.</p>
</td></tr>
<tr><td><code id="global+2B20as.gbd_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> matrix in <code>rank.source</code> will be redistributed as a gbd
matrix in row blocks.
</p>
<p>This function will first set <code>NULL</code> to <code>X</code> if it is not
located in <code>rank.source</code>, then called <code><a href="#topic+comm.load.balance">comm.load.balance</a>()</code>
to redistributed the one located in <code>rank.source</code> to all other ranks.
</p>


<h3>Value</h3>

<p>A <code>X.gbd</code> will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.load.balance">comm.load.balance</a>()</code>,
<code><a href="#topic+comm.read.table">comm.read.table</a>()</code> and
<code><a href="#topic+comm.write.table">comm.write.table</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
X &lt;- matrix(1:15, ncol = 3)
X.gbd &lt;- comm.as.gbd(X)
comm.print(X.gbd, all.rank = TRUE)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='global+20balanc'> Global Balance Functions </h2><span id='topic+comm.balance.info'></span><span id='topic+comm.load.balance'></span><span id='topic+comm.unload.balance'></span>

<h3>Description</h3>

<p>These functions are global balance methods for gbd <code>data.frame</code> (or
<code>matrix</code>) distributed in row blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.balance.info(X.gbd, balance.method = .pbd_env$SPMD.IO$balance.method[1],
                  comm = .pbd_env$SPMD.CT$comm)
comm.load.balance(X.gbd, bal.info = NULL,
                  balance.method = .pbd_env$SPMD.IO$balance.method[1],
                  comm = .pbd_env$SPMD.CT$comm)
comm.unload.balance(new.X.gbd, bal.info, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20balanc_+3A_x.gbd">X.gbd</code></td>
<td>
<p>a gbd <code>data.frame</code> (or <code>matrix</code>).</p>
</td></tr>
<tr><td><code id="global+2B20balanc_+3A_balance.method">balance.method</code></td>
<td>
<p>a balance method.</p>
</td></tr>
<tr><td><code id="global+2B20balanc_+3A_bal.info">bal.info</code></td>
<td>
<p>a balance information returned from
<code>comm.balance.info()</code>. If <code>NULL</code>, then
this will be generated inside <code>comm.load.balance()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20balanc_+3A_new.x.gbd">new.X.gbd</code></td>
<td>
<p>a new gbd of <code>X.gbd</code> (may be generated from
<code>comm.load.balance()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20balanc_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical use is to balance an input dataset <code>X.gbd</code> from
<code><a href="#topic+comm.read.table">comm.read.table</a>()</code>.  Since by default, a two dimension
<code>data.frame</code> is distributed in row blocks, but each processor (rank)
may not (or closely) have the same number of rows.
These functions redistribute the <code>data.frame</code> (and maybe
<code>matrix</code>) according to the specified way in <code>bal.info</code>.
</p>
<p>Currently, there are three balance methods are supported, <code>block</code>
(uniform distributed but favor higher ranks), <code>block0</code>
(as <code>block</code> but favor lower ranks), and <code>block.cyclic</code>
(as block cyclic with one big block in one cycle).
</p>


<h3>Value</h3>

<p><code>comm.balance.info()</code> returns a <code>list</code> containing
balance information based on the input <code>X.gbd</code> and <code>balance.method</code>.
</p>
<p><code>comm.load.balance()</code> returns a new gbd <code>data.frame</code> (or
<code>matrix</code>).
</p>
<p><code>comm.unload.balance()</code> also returns the new gbd <code>data.frame</code> back
to the original <code>X.gbd</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.read.table">comm.read.table</a>()</code>,
<code><a href="#topic+comm.write.table">comm.write.table</a>()</code>, and
<code><a href="#topic+comm.as.gbd">comm.as.gbd</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Get two gbd row-block data.frame.
da.block &lt;- iris[get.jid(nrow(iris), method = \"block\"),]
da.block0 &lt;- iris[get.jid(nrow(iris), method = \"block0\"),]

### Load balance one and unload it.
bal.info &lt;- comm.balance.info(da.block0)
da.new &lt;- comm.load.balance(da.block0)
da.org &lt;- comm.unload.balance(da.new, bal.info)

### Check if all are equal.
comm.print(c(sum(da.new != da.block), sum(da.org != da.block0)),
           all.rank = TRUE)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20base'> Global Base Functions </h2><span id='topic+comm.length'></span><span id='topic+comm.sum'></span><span id='topic+comm.mean'></span><span id='topic+comm.var'></span><span id='topic+comm.sd'></span>

<h3>Description</h3>

<p>These functions are global base functions applying on
distributed data for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.length(x, comm = .pbd_env$SPMD.CT$comm)
comm.sum(..., na.rm = TRUE, comm = .pbd_env$SPMD.CT$comm)
comm.mean(x, na.rm = TRUE, comm = .pbd_env$SPMD.CT$comm)
comm.var(x, na.rm = TRUE, comm = .pbd_env$SPMD.CT$comm)
comm.sd(x, na.rm = TRUE, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20base_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="global+2B20base_+3A_...">...</code></td>
<td>
<p>as in <code>sum()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20base_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, if remove <code>NA</code> and <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="global+2B20base_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply globally <code>length()</code>, <code>sum()</code>,
<code>mean()</code>, <code>var()</code>, and <code>sd()</code>. 
</p>


<h3>Value</h3>

<p>The global values are returned to all ranks.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

if(comm.size() != 2){
  comm.cat(\"2 processors are requried.\n\", quiet = TRUE)
  finalize()
}

### Examples.
a &lt;- 1:(comm.rank() + 1)

b &lt;- comm.length(a)
comm.print(b)
b &lt;- comm.sum(a)
comm.print(b)
b &lt;- comm.mean(a)
comm.print(b)
b &lt;- comm.var(a)
comm.print(b)
b &lt;- comm.sd(a)
comm.print(b)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20distance+20function'> Global Distance for Distributed Matrices </h2><span id='topic+comm.dist'></span>

<h3>Description</h3>

<p>These functions globally compute distance for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.dist(X.gbd, method = "euclidean", diag = FALSE, upper = FALSE,
          p = 2, comm = .pbd_env$SPMD.CT$comm,
          return.type = c("common", "gbd"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20distance+2B20function_+3A_x.gbd">X.gbd</code></td>
<td>
<p>a gbd matrix.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_method">method</code></td>
<td>
<p>as in <code>dist()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_diag">diag</code></td>
<td>
<p>as in <code>dist()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_upper">upper</code></td>
<td>
<p>as in <code>dist()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_p">p</code></td>
<td>
<p>as in <code>dist()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="global+2B20distance+2B20function_+3A_return.type">return.type</code></td>
<td>
<p>returning type for the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance function is implemented for a distributed matrix.
</p>
<p>The return type <code>common</code> is only useful when the number
of rows of the matrix is small since the returning matrix is <code>N * N</code>
for every rank where <code>N</code> is the total number of rows of <code>X.gbd</code>
of all ranks.
</p>
<p>The return type <code>gbd</code> returns a gbd matrix (distributed across
all ranks, and the gbd matrix has 3 columns, named &quot;i&quot;, &quot;j&quot;, and &quot;value&quot;,
where <code>(i, j)</code> is the global indices of the
i-th and j-th rows of <code>X.gbd</code>, and <code>value</code> is the corresponding
distance. The <code>(i, j)</code> is ordered as a distance matrix.
</p>


<h3>Value</h3>

<p>A full distance matrix is returned from the <code>common</code> return type.
Suppose <code>N.gbd</code> is total rows of <code>X.gbd</code>, then
the distance will have <code>N.gbd * (N.gbd - 1) / 2</code> elements
and the distance matrix will have <code>N.gbd^2</code> elements.
</p>
<p>A gbd distance matrix with 3 columns is returned from the
<code>gbd</code> return type.
</p>


<h3>Warning</h3>

<p>The distance or distance matrix could be huge.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.allpairs">comm.allpairs</a>()</code> and
<code><a href="#topic+comm.pairwise">comm.pairwise</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
comm.set.seed(123456, diff = TRUE)

X.gbd &lt;- matrix(runif(6), ncol = 3)
dist.X.common &lt;- comm.dist(X.gbd)
dist.X.gbd &lt;- comm.dist(X.gbd, return.type = \"gbd\")

### Verify.
dist.X &lt;- dist(do.call(\"rbind\", allgather(X.gbd)))
comm.print(all(dist.X == dist.X.common))

### Verify 2.
dist.X.df &lt;- do.call(\"rbind\", allgather(dist.X.gbd))
comm.print(all(dist.X == dist.X.df[, 3]))
comm.print(dist.X)
comm.print(dist.X.df)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20match.arg'> Global Argument Matching </h2><span id='topic+comm.match.arg'></span>

<h3>Description</h3>

<p>A binding for <code>match.arg()</code> that uses <code>comm.stop()</code> rather
so that the error message (if there is one) is managed according
to the rules of <code>.pbd_env$SPMD.CT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.match.arg(arg, choices, several.ok=FALSE, ..., 
               all.rank = .pbd_env$SPMD.CT$print.all.rank,
               rank.print = .pbd_env$SPMD.CT$rank.source,
               comm = .pbd_env$SPMD.CT$comm,
               mpi.finalize = .pbd_env$SPMD.CT$mpi.finalize,
               quit = .pbd_env$SPMD.CT$quit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20match.arg_+3A_arg">arg</code>, <code id="global+2B20match.arg_+3A_choices">choices</code>, <code id="global+2B20match.arg_+3A_several.ok">several.ok</code></td>
<td>
<p>see match.arg()</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_all.rank">all.rank</code></td>
<td>
<p>if all ranks print (default = FALSE).</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_rank.print">rank.print</code></td>
<td>
<p>rank for printing if not all ranks print (default = 0).</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_comm">comm</code></td>
<td>
<p>communicator for printing (default = 1).</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_mpi.finalize">mpi.finalize</code></td>
<td>
<p>if MPI should be shutdown.</p>
</td></tr>
<tr><td><code id="global+2B20match.arg_+3A_quit">quit</code></td>
<td>
<p>if quit R when errors happen.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='global+20pairwise'> Global Pairwise Evaluations </h2><span id='topic+comm.pairwise'></span>

<h3>Description</h3>

<p>This function provides global pairwise evaluations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.pairwise(X, pairid.gbd = NULL,
    FUN = function(x, y, ...){ return(as.vector(dist(rbind(x, y), ...))) },
    ..., diag = FALSE, symmetric = TRUE, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20pairwise_+3A_x">X</code></td>
<td>
<p>a common matrix across ranks, or a gbd matrix. (See details.)</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_pairid.gbd">pairid.gbd</code></td>
<td>
<p>a pair-wise id in a gbd format. (See details.)</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_fun">FUN</code></td>
<td>
<p>a function to be evaluated for given pairs.</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_...">...</code></td>
<td>
<p>extra variables for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_diag">diag</code></td>
<td>
<p>if matching the same elements, <code>(i, i)</code> for all <code>i</code>.</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_symmetric">symmetric</code></td>
<td>
<p>if matching upper triangular elements. TRUE for
<code>i &gt;= j</code> only, otherwise for all <code>(i, j)</code>.</p>
</td></tr>
<tr><td><code id="global+2B20pairwise_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the objective function
<code>FUN(X[i,], X[j, ])</code> (usually distance of two elements)
on any given pair <code>(i, j)</code> of a matrix <code>X</code>.
</p>
<p>The input <code>X</code> should be in common across all ranks if <code>pairid.gbd</code>
is provided, e.g. from <code>comm.pairwise()</code>.
i.e. <code>X</code> is exactly the same in every ranks, but
<code>pairid.gbd</code> is different and in gbd format indicating the row pair
<code>(i, j)</code> should be evaluated. The returning gbd matrix is ordered
and indexed by <code>pairid.gbd</code>.
</p>
<p>Note that checking consistence of <code>X</code> across all ranks is not
implemented within this function since that drops performance and
may be not accurate.
</p>
<p>The input <code>X</code> should be a gbd format in row major blocks
(i.e. <code>X.gbd</code>) if <code>pairid.gbd</code> is <code>NULL</code>. A internal
pair indices will be built implicitly for evaluation. The returning
gbd matrix is ordered and indexed by <code>X.gbd</code>.
</p>


<h3>Value</h3>

<p>This function returns a common matrix with 3 columns
named <code>i</code>, <code>j</code>, and <code>value</code>. Each <code>value</code> is the
returned value and computed by <code>FUN(X[i,], X[j,])</code> where
<code>(i, j)</code> is the global index as ordered in a distance matrix
for i-th row and j-th columns.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.pairwise">comm.pairwise</a>()</code>, and
<code><a href="#topic+comm.dist">comm.dist</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
comm.set.seed(123456, diff = FALSE)
X &lt;- matrix(rnorm(10), ncol = 2)
id.matrix &lt;- comm.allpairs(nrow(X))

### Method original.
dist.org &lt;- dist(X)

### Method 1.
dist.common &lt;- comm.pairwise(X, pairid.gbd = id.matrix)

### Method 2.
# if(comm.rank() != 0){
#   X &lt;- matrix(0, nrow = 0, ncol = 4)
# }
X.gbd &lt;- comm.as.gbd(X)    ### The other way.
dist.gbd &lt;- comm.pairwise(X.gbd)

### Verify.
d.org &lt;- as.vector(dist.org)
d.1 &lt;- do.call(\"c\", allgather(dist.common[, 3]))
d.2 &lt;- do.call(\"c\", allgather(dist.gbd[, 3]))
comm.print(all(d.org == d.1))
comm.print(all(d.org == d.2))

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20print+20and+20cat'> Global Print and Cat Functions </h2><span id='topic+comm.print'></span><span id='topic+comm.cat'></span>

<h3>Description</h3>

<p>The functions globally print or cat a variable from specified processors,
by default messages is shown on screen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.print(x, all.rank = .pbd_env$SPMD.CT$print.all.rank,
           rank.print = .pbd_env$SPMD.CT$rank.source,
           comm = .pbd_env$SPMD.CT$comm,
           quiet = .pbd_env$SPMD.CT$print.quiet,
           flush = .pbd_env$SPMD.CT$msg.flush,
           barrier = .pbd_env$SPMD.CT$msg.barrier,
           con = stdout(), ...)

comm.cat(..., all.rank = .pbd_env$SPMD.CT$print.all.rank,
         rank.print = .pbd_env$SPMD.CT$rank.source,
         comm = .pbd_env$SPMD.CT$comm,
         quiet = .pbd_env$SPMD.CT$print.quiet, sep = " ", fill = FALSE,
         labels = NULL, append = FALSE, flush = .pbd_env$SPMD.CT$msg.flush,
         barrier = .pbd_env$SPMD.CT$msg.barrier, con = stdout())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_x">x</code></td>
<td>
<p>a variable to be printed.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_...">...</code></td>
<td>
<p>variables to be cat.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_all.rank">all.rank</code></td>
<td>
<p>if all ranks print (default = FALSE).</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_rank.print">rank.print</code></td>
<td>
<p>rank for printing if not all ranks print (default = 0).</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_comm">comm</code></td>
<td>
<p>communicator for printing (default = 1).</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_quiet">quiet</code></td>
<td>
<p>FALSE for printing rank number.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_sep">sep</code></td>
<td>
<p>sep argument as in the <code>cat()</code> function.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_fill">fill</code></td>
<td>
<p>fill argument as in the <code>cat()</code> function.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_labels">labels</code></td>
<td>
<p>labels argument as in the <code>cat()</code> function.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_append">append</code></td>
<td>
<p>labels argument as in the <code>cat()</code> function.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_flush">flush</code></td>
<td>
<p>if flush <code>con</code>.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_barrier">barrier</code></td>
<td>
<p>if barrier <code>con</code>.</p>
</td></tr>
<tr><td><code id="global+2B20print+2B20and+2B20cat_+3A_con">con</code></td>
<td>
<p><code>stdout()</code> is the default to print message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Warning:</strong> These two functions use <code>barrier()</code> to make sure
the well printing process on screen, so should be called by all processors
to avoid a deadlock. A typical misuse is called inside a condition check,
such as <code>if(.comm.rank == 0) comm.cat(...)</code>.
</p>
<p><code>rank.print</code> can be a integer vector containing the ranks of
processors which print messages.
</p>


<h3>Value</h3>

<p>A <code>print()</code> or <code>cat()</code> is called for the specified processors
and the messages of the input variables is shown on screen by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Example.
comm.print(comm.rank(), rank.print = 1)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20range+2C+20max+2C+20and+20min'> Global Range, Max, and Min Functions </h2><span id='topic+comm.range'></span><span id='topic+comm.max'></span><span id='topic+comm.min'></span>

<h3>Description</h3>

<p>These functions are global range, max and min applying on distributed data
for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.range(..., na.rm = FALSE, comm = .pbd_env$SPMD.CT$comm)
comm.max(..., na.rm = FALSE, comm = .pbd_env$SPMD.CT$comm)
comm.min(..., na.rm = FALSE, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20range+2B2C+2B20max+2B2C+2B20and+2B20min_+3A_...">...</code></td>
<td>
<p>an 'numeric' objects.</p>
</td></tr>
<tr><td><code id="global+2B20range+2B2C+2B20max+2B2C+2B20and+2B20min_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>NA</code> removed or not.</p>
</td></tr>
<tr><td><code id="global+2B20range+2B2C+2B20max+2B2C+2B20and+2B20min_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply <code>range()</code>, <code>max()</code> and <code>min()</code>
locally, and apply allgather to get all local results from other ranks,
then apply <code>range()</code>, <code>max()</code> and <code>min()</code> on all local
results.
</p>


<h3>Value</h3>

<p>The global values (range, max, or min) are returned to all ranks.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

if(comm.size() != 2){
  comm.cat(\"2 processors are requried.\n\", quiet = TRUE)
  finalize()
}

### Examples.
a &lt;- 1:(comm.rank() + 1)

b &lt;- comm.range(a)
comm.print(b)
b &lt;- comm.max(a)
comm.print(b)
b &lt;- comm.min(a)
comm.print(b)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20reading'> Global Reading Functions </h2><span id='topic+comm.read.table'></span><span id='topic+comm.read.csv'></span><span id='topic+comm.read.csv2'></span>

<h3>Description</h3>

<p>These functions are global reading from specified file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.read.table(file, header = FALSE, sep = "", quote = "\"'",
                dec = ".",
                na.strings = "NA", colClasses = NA, nrows = -1, skip = 0,
                check.names = TRUE, fill = !blank.lines.skip,
                strip.white = FALSE,
                blank.lines.skip = TRUE, comment.char = "#",
                allowEscapes = FALSE,
                flush = FALSE,
                fileEncoding = "", encoding = "unknown",
                read.method = .pbd_env$SPMD.IO$read.method[1],
                balance.method = .pbd_env$SPMD.IO$balance.method[1],
                comm = .pbd_env$SPMD.CT$comm)

comm.read.csv(file, header = TRUE, sep = ",", quote = "\"",
              dec = ".", fill = TRUE, comment.char = "", ...,
              read.method = .pbd_env$SPMD.IO$read.method[1],
              balance.method = .pbd_env$SPMD.IO$balance.method[1],
              comm = .pbd_env$SPMD.CT$comm)
     
comm.read.csv2(file, header = TRUE, sep = ";", quote = "\"",
               dec = ",", fill = TRUE, comment.char = "", ...,
               read.method = .pbd_env$SPMD.IO$read.method[1],
               balance.method = .pbd_env$SPMD.IO$balance.method[1],
               comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20reading_+3A_file">file</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_header">header</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_sep">sep</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_quote">quote</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_dec">dec</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_na.strings">na.strings</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_colclasses">colClasses</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_nrows">nrows</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_skip">skip</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_check.names">check.names</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_fill">fill</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_strip.white">strip.white</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_blank.lines.skip">blank.lines.skip</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_comment.char">comment.char</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_allowescapes">allowEscapes</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_flush">flush</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_encoding">encoding</code></td>
<td>
<p>as in <code>read.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_...">...</code></td>
<td>
<p>as in <code>read.csv*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_read.method">read.method</code></td>
<td>
<p>either &quot;gbd&quot; or &quot;common&quot;.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_balance.method">balance.method</code></td>
<td>
<p>balance method for <code>read.method = "gbd"</code>
as <code>nrows = -1</code> and <code>skip = 0</code> are set.</p>
</td></tr>
<tr><td><code id="global+2B20reading_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply <code>read.table()</code> locally and sequentially
from rank 0, 1, 2, ...
</p>
<p>By default, rank 0 reads the file only, then scatter to other ranks for
small datasets (<code>.pbd_env$SPMD.IO$max.read.size</code>) in
<code>read.method = "gbd"</code>.
(bcast to others in <code>read.method = "common"</code>.)
</p>
<p>As dataset size increases, the reading is performed from each ranks and
read portion of rows in &quot;gbd&quot; format as described in <span class="pkg">pbdDEMO</span>
vignettes and used in <span class="pkg">pmclust</span>.
</p>
<p><code><a href="#topic+comm.load.balance">comm.load.balance</a>()</code> is called for &quot;gbd&quot; method as
as <code>nrows = -1</code> and <code>skip = 0</code> are set. Note that the default
method &quot;block&quot; is the better way for performance in general that distributes
equally and leaves residuals on higher ranks evenly.
&quot;block0&quot; is the other way around. &quot;block.cyclic&quot; is only useful for
converting to <code>ddmatrix</code> as in <span class="pkg">pbdDMAT</span>.
</p>


<h3>Value</h3>

<p>A distributed data.frame is returned.
</p>
<p>All factors are disable and read as characters or as what data should be.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.load.balance">comm.load.balance</a>()</code> and
<code><a href="#topic+comm.write.table">comm.write.table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Check.
if(comm.size() != 2){
  comm.stop(\"2 processors are requried.\")
}

### Manually distributed iris.
da &lt;- iris[get.jid(nrow(iris)),]

### Dump data.
comm.write.table(da, file = \"iris.txt\", quote = FALSE, sep = \"\\t\",
                 row.names = FALSE)

### Read back in.
da.gbd &lt;- comm.read.table(\"iris.txt\", header = TRUE, sep = \"\\t\",
                          quote = \"\")
comm.print(c(nrow(da), nrow(da.gbd)), all.rank = TRUE)

### Read in common.
da.common &lt;- comm.read.table(\"iris.txt\", header = TRUE, sep = \"\\t\",
                             quote = \"\", read.method = \"common\")
comm.print(c(nrow(da.common), sum(da.common != iris)))

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20Rprof'> A Rprof Function for SPMD Routines </h2><span id='topic+comm.Rprof'></span>

<h3>Description</h3>

<p>A Rprof function for use with parallel codes executed in the batch
SPMD style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.Rprof(filename = "Rprof.out", append = FALSE, interval = 0.02,
           memory.profiling = FALSE, gc.profiling = FALSE,
           line.profiling = FALSE, numfiles = 100L, bufsize = 10000L,
           all.rank = .pbd_env$SPMD.CT$Rprof.all.rank,
           rank.Rprof = .pbd_env$SPMD.CT$rank.source,
           comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20Rprof_+3A_filename">filename</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_append">append</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_interval">interval</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_memory.profiling">memory.profiling</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_gc.profiling">gc.profiling</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_line.profiling">line.profiling</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_numfiles">numfiles</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_bufsize">bufsize</code></td>
<td>
<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_all.rank">all.rank</code></td>
<td>
<p>if calling Rprof on all ranks (default = FALSE).</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_rank.rprof">rank.Rprof</code></td>
<td>
<p>rank for calling Rprof if
<code>all.rank = FALSE</code> (default = 0).</p>
</td></tr>
<tr><td><code id="global+2B20Rprof_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>as in <code><a href="utils.html#topic+Rprof">Rprof</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='global+20sort'> Global Quick Sort for Distributed Vectors or Matrices </h2><span id='topic+comm.sort'></span>

<h3>Description</h3>

<p>This function globally sorts distributed data for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.sort(x, decreasing = FALSE, na.last = NA,
          comm = .pbd_env$SPMD.CT$comm,
          status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20sort_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="global+2B20sort_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the sort order be increasing or decreasing?</p>
</td></tr>
<tr><td><code id="global+2B20sort_+3A_na.last">na.last</code></td>
<td>
<p>for controlling the treatment of <code>NA</code>s.
If <code>TRUE</code>, missing values in the data are put last;
if <code>FALSE</code>, they are put first; if <code>NA</code>,
they are removed.</p>
</td></tr>
<tr><td><code id="global+2B20sort_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="global+2B20sort_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distributed quick sort is implemented for this functions.
</p>


<h3>Value</h3>

<p>The returns are the same size of <code>x</code> but in global sorting order.
</p>


<h3>Warning</h3>

<p>All ranks may not have a NULL <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
comm.set.seed(123456, diff = TRUE)
x &lt;- c(rnorm(5 + .comm.rank * 2), NA)
# x &lt;- sample(1:5, 5 + .comm.rank * 2, replace = TRUE)
comm.end.seed()

if(.comm.rank == 1){
  x &lt;- NULL    ### Test for NULL or 0 vector
}

y &lt;- allgather(x)
comm.print(y)

y &lt;- comm.sort(x)
y &lt;- allgather(y)
comm.print(y)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20stop+20and+20warning'> Global Stop and Warning Functions </h2><span id='topic+comm.stop'></span><span id='topic+comm.warning'></span><span id='topic+comm.warnings'></span><span id='topic+comm.stopifnot'></span>

<h3>Description</h3>

<p>These functions are global stop and warning applying on distributed data
for all ranks, and are called by experts only. These functions may
lead to potential performance degradation and system termination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.stop(..., call. = TRUE, domain = NULL,
          all.rank = .pbd_env$SPMD.CT$print.all.rank,
          rank.print = .pbd_env$SPMD.CT$rank.source,
          comm = .pbd_env$SPMD.CT$comm,
          mpi.finalize = .pbd_env$SPMD.CT$mpi.finalize,
          quit = .pbd_env$SPMD.CT$quit)

comm.warning(..., call. = TRUE, immediate. = FALSE, domain = NULL,
             all.rank = .pbd_env$SPMD.CT$print.all.rank,
             rank.print = .pbd_env$SPMD.CT$rank.source,
             comm = .pbd_env$SPMD.CT$comm)

comm.warnings(...,
              all.rank = .pbd_env$SPMD.CT$print.all.rank,
              rank.print = .pbd_env$SPMD.CT$rank.source,
              comm = .pbd_env$SPMD.CT$comm)

comm.stopifnot(..., call. = TRUE, domain = NULL,
               all.rank = .pbd_env$SPMD.CT$print.all.rank,
               rank.print = .pbd_env$SPMD.CT$rank.source,
               comm = .pbd_env$SPMD.CT$comm,
               mpi.finalize = .pbd_env$SPMD.CT$mpi.finalize,
               quit = .pbd_env$SPMD.CT$quit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_...">...</code></td>
<td>
<p>variables to be cat.</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_call.">call.</code></td>
<td>
<p>see stop() and warnings().</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_immediate.">immediate.</code></td>
<td>
<p>see stop() and warnings().</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_domain">domain</code></td>
<td>
<p>see stop() and warnings().</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_all.rank">all.rank</code></td>
<td>
<p>if all ranks print (default = FALSE).</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_rank.print">rank.print</code></td>
<td>
<p>rank for printing if not all ranks print (default = 0).</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_comm">comm</code></td>
<td>
<p>communicator for printing (default = 1).</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_mpi.finalize">mpi.finalize</code></td>
<td>
<p>if MPI should be shutdown.</p>
</td></tr>
<tr><td><code id="global+2B20stop+2B20and+2B20warning_+3A_quit">quit</code></td>
<td>
<p>if quit R when errors happen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will respectively apply <code>stop()</code>, <code>warning()</code>,
<code>warnings()</code>, and <code>stopifnot()</code> locally.
</p>


<h3>Value</h3>

<p><code>comm.stop()</code> and <code>comm.stopifnot()</code> terminate all ranks, 
<code>comm.warning()</code> returns messages, and <code>comm.warnings()</code>
print the message.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

if(comm.size() != 2){
  comm.cat(\"2 processors are requried.\n\", quiet = TRUE)
  finalize()
}

### Examples.
comm.warning(\"test warning.\n\")
comm.warnings()
comm.stop(\"test stop.\n\")
comm.stopifnot(1 == 2)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20timer'> A Timing Function for SPMD Routines </h2><span id='topic+comm.timer'></span>

<h3>Description</h3>

<p>A timing function for use with parallel codes executed in the batch
SPMD style.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.timer(timed, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20timer_+3A_timed">timed</code></td>
<td>
<p>expression to be timed.</p>
</td></tr>
<tr><td><code id="global+2B20timer_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the min, mean, and max execution time across all independent 
processes executing the operation <code>timed</code>.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='global+20which+2C+20which.max+2C+20and+20which.min'> Global Which Functions </h2><span id='topic+comm.which'></span><span id='topic+comm.which.max'></span><span id='topic+comm.which.min'></span>

<h3>Description</h3>

<p>These functions are global which, which.max and which.min applying on
distributed data for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.which(x, arr.ind = FALSE, useNames = TRUE,
           comm = .pbd_env$SPMD.CT$comm)
comm.which.max(x, comm = .pbd_env$SPMD.CT$comm)
comm.which.min(x, comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20which+2B2C+2B20which.max+2B2C+2B20and+2B20which.min_+3A_x">x</code></td>
<td>
<p>a 'logical' vector or array as in <code>which()</code>,
or an 'numeric' objects in <code>which.max()</code> and
<code>which.min()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20which+2B2C+2B20which.max+2B2C+2B20and+2B20which.min_+3A_arr.ind">arr.ind</code></td>
<td>
<p>logical, as in <code>which()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20which+2B2C+2B20which.max+2B2C+2B20and+2B20which.min_+3A_usenames">useNames</code></td>
<td>
<p>logical, as in <code>which()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20which+2B2C+2B20which.max+2B2C+2B20and+2B20which.min_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply <code>which()</code>, <code>which.max()</code> and
<code>which.min()</code> locally, and apply <code>allgather()</code> to get all local
results from other ranks.
</p>


<h3>Value</h3>

<p>The global values (<code>which()</code>, <code>which.max()</code>, or <code>which.min()</code>)
are returned to all ranks.
</p>
<p><code>comm.which()</code> returns with two columns, 'rank id' and 'index of
<code>TRUE</code>'.
</p>
<p><code>comm.which.max()</code> and <code>comm.which.min()</code> return with three
values, 'the _smallest_ rank id', 'index of the _first_ maximum or minimum',
and 'max/min value of <code>x</code>'.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.read.table">comm.read.table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

if(comm.size() != 2){
  comm.cat(\"2 processors are requried.\n\", quiet = TRUE)
  finalize()
}

### Examples.
a &lt;- 1:(comm.rank() + 1)

b &lt;- comm.which(a == 2)
comm.print(b)
b &lt;- comm.which.max(a)
comm.print(b)
b &lt;- comm.which.min(a)
comm.print(b)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='global+20writing'> Global Writing Functions </h2><span id='topic+comm.write'></span><span id='topic+comm.write.table'></span><span id='topic+comm.write.csv'></span><span id='topic+comm.write.csv2'></span>

<h3>Description</h3>

<p>These functions are global writing applying on distributed data
for all ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.write(x, file = "data", ncolumns = if(is.character(x)) 1 else 5,
           append = FALSE, sep = " ", comm = .pbd_env$SPMD.CT$comm)
comm.write.table(x, file = "", append = FALSE, quote = TRUE, sep = " ",
                 eol = "\n", na = "NA", dec = ".", row.names = TRUE,
                 col.names = TRUE, qmethod = c("escape", "double"),
                 fileEncoding = "", comm = .pbd_env$SPMD.CT$comm)

comm.write.csv(..., comm = .pbd_env$SPMD.CT$comm)
comm.write.csv2(..., comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global+2B20writing_+3A_x">x</code></td>
<td>
<p>as in <code>write()</code> or <code>write.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_file">file</code></td>
<td>
<p>as in <code>write()</code> or <code>write.table()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_ncolumns">ncolumns</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_append">append</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_sep">sep</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_quote">quote</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_eol">eol</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_na">na</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_dec">dec</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_row.names">row.names</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_col.names">col.names</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_qmethod">qmethod</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_...">...</code></td>
<td>
<p>as in <code>write*()</code>.</p>
</td></tr>
<tr><td><code id="global+2B20writing_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions will apply <code>write*()</code> locally and sequentially
from rank 0, 1, 2, ...
</p>
<p>By default, rank 0 makes the file, and rest of ranks append the data.
</p>


<h3>Value</h3>

<p>A file will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.load.balance">comm.load.balance</a>()</code> and
<code><a href="#topic+comm.read.table">comm.read.table</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
if(comm.size() != 2){
  comm.cat(\"2 processors are requried.\n\", quiet = TRUE)
  finalize()
}

### Examples.
comm.write((1:5) + comm.rank(), file = \"test.txt\")

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='info'> Info Functions </h2><span id='topic+info.create'></span><span id='topic+info.set'></span><span id='topic+info.free'></span><span id='topic+info.c2f'></span>

<h3>Description</h3>

<p>The functions call MPI info functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info.create(info = .pbd_env$SPMD.CT$info)
info.set(info = .pbd_env$SPMD.CT$info, key, value)
info.free(info = .pbd_env$SPMD.CT$info)
info.c2f(info = .pbd_env$SPMD.CT$info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_+3A_info">info</code></td>
<td>
<p>a info number.</p>
</td></tr>
<tr><td><code id="info_+3A_key">key</code></td>
<td>
<p>a character string to be set.</p>
</td></tr>
<tr><td><code id="info_+3A_value">value</code></td>
<td>
<p>a character string to be set associate with <code>key</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal functions. Potentially, they set
information for initialization of manager and workers.
</p>


<h3>Value</h3>

<p>An invisible state of MPI call is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
info.create(0L)
info.set(0L, \"file\", \"appschema\")
info.free(0L)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='irecv-method'> A Rank Receives (Nonblocking) an Object from the Other Rank </h2><span id='topic+irecv-method'></span><span id='topic+irecv+2CANY-method'></span><span id='topic+irecv+2Cinteger-method'></span><span id='topic+irecv+2Cnumeric-method'></span><span id='topic+irecv+2Craw-method'></span><span id='topic+irecv'></span>

<h3>Description</h3>

<p>This method lets a rank receive (nonblocking) an object from the
other rank in the same communicator. The default return is the object
sent from the other rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irecv(x.buffer = NULL, rank.source = .pbd_env$SPMD.CT$rank.source,
      tag = .pbd_env$SPMD.CT$tag, comm = .pbd_env$SPMD.CT$comm,
      request = .pbd_env$SPMD.CT$request,
      status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irecv-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to store <code>x</code> sent from the other rank.</p>
</td></tr>
<tr><td><code id="irecv-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a source rank where <code>x</code> sent from</p>
</td></tr>
<tr><td><code id="irecv-method_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
<tr><td><code id="irecv-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="irecv-method_+3A_request">request</code></td>
<td>
<p>a request number.</p>
</td></tr>
<tr><td><code id="irecv-method_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>send()</code>/<code>isend()</code> should be evoked at the
corresponding rank <code>rank.source</code>.
</p>
<p><strong>Warning:</strong> <code>irecv()</code> is not safe for <span class="rlang"><b>R</b></span> since <span class="rlang"><b>R</b></span> is not a thread
safe package that a dynamic returning object requires certain blocking or
barrier at some where. Current, the default method is equivalent to the
default method of <code>recv()</code>.
</p>


<h3>Value</h3>

<p>An object is returned by default.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.irecv.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recv">recv</a>()</code>, <code><a href="#topic+send">send</a>()</code>, <code><a href="#topic+isend">isend</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
if(.comm.rank == 0){
  y &lt;- send(matrix(x, nrow = 1))
} else if(.comm.rank == 1){
  y &lt;- irecv()
}
comm.print(y, rank.print = 1)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.comm.null'> Check if a MPI_COMM_NULL </h2><span id='topic+is.comm.null'></span>

<h3>Description</h3>

<p>The functions check MPI_COMM_NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.comm.null(comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.comm.null_+3A_comm">comm</code></td>
<td>
<p>a comm number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal uses.
</p>


<h3>Value</h3>

<p>TRUE if input comm is MPI_COMM_NULL, otherwise FALSE.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
is.comm.null(0L)
is.comm.null(1L)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='isend-method'> A Rank Send (Nonblocking) an Object to the Other Rank </h2><span id='topic+isend-method'></span><span id='topic+isend+2CANY-method'></span><span id='topic+isend+2Cinteger-method'></span><span id='topic+isend+2Cnumeric-method'></span><span id='topic+isend+2Craw-method'></span><span id='topic+isend'></span>

<h3>Description</h3>

<p>This method lets a rank send (nonblocking) a object to the other
rank in the same communicator. The default return is <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isend(x, rank.dest = .pbd_env$SPMD.CT$rank.dest,
      tag = .pbd_env$SPMD.CT$tag,
      comm = .pbd_env$SPMD.CT$comm,
      request = .pbd_env$SPMD.CT$request,
      check.type = .pbd_env$SPMD.CT$check.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isend-method_+3A_x">x</code></td>
<td>
<p>an object to be sent from a rank.</p>
</td></tr>
<tr><td><code id="isend-method_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where <code>x</code> send to.</p>
</td></tr>
<tr><td><code id="isend-method_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
<tr><td><code id="isend-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="isend-method_+3A_request">request</code></td>
<td>
<p>a request number.</p>
</td></tr>
<tr><td><code id="isend-method_+3A_check.type">check.type</code></td>
<td>
<p>if checking data type first for handshaking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>recv()</code> or <code>irecv()</code> should be evoked at the
corresponding rank <code>rank.dest</code>.
</p>
<p>See details of <code>send()</code> for the arugments <code>check.type</code>.
</p>


<h3>Value</h3>

<p>A <code>NULL</code> is returned by default.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.isend.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+send">send</a>()</code>, <code><a href="#topic+recv">recv</a>()</code>, <code><a href="#topic+irecv">irecv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
if(.comm.rank == 0){
  y &lt;- isend(matrix(x, nrow = 1))
} else if(.comm.rank == 1){
  y &lt;- recv()
}
comm.print(y, rank.print = 1)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='MPI+20array+20pointers'> Set or Get MPI Array Pointers in R </h2><span id='topic+arrange.mpi.apts'></span>

<h3>Description</h3>

<p>The function set/get a point address in R where the point point to
a structure containing MPI arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.mpi.apts()
</code></pre>


<h3>Details</h3>

<p>Since Rmpi/pbdMPI pre-allocate memory to store comm, status,
datatype, info, request, this function provides a variable in <span class="rlang"><b>R</b></span>
to let different APIs share the same memory address.
</p>
<p>If the package loads first, then this sets '<code>.__MPI_APTS__</code>'
in the <code>.GlobalEnv</code> of <span class="rlang"><b>R</b></span>. If the package does not load before other
MPI APIs, then this gives a structure pointer to external memory
according to '<code>.__MPI_APTS__</code>', i.e. allocated by other MPI APIs.
</p>
<p><code>pbdMPI/R/arrange.mpi.apts</code> provides the <span class="rlang"><b>R</b></span> code, and
<code>pbdMPI/src/pkg_*.*</code> provides the details of this call.
</p>


<h3>Value</h3>

<p>'<code>.__MPI_APTS__</code>' is set in <code>.GlobalEnv</code> of <span class="rlang"><b>R</b></span>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### See source code for the details.

## End(Not run)
</code></pre>

<hr>
<h2 id='Package+20Tools'>Functions for Get/Print MPI_COMM Pointer (Address)</h2><span id='topic+get.mpi.comm.ptr'></span><span id='topic+addr.mpi.comm.ptr'></span>

<h3>Description</h3>

<p>These functions are designed to get or print MPI_COMM pointer and
its address when the SPMD code in R be a foreign application of
other applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mpi.comm.ptr(comm = .pbd_env$SPMD.CT$comm, show.msg = FALSE)
addr.mpi.comm.ptr(comm.ptr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Package+2B20Tools_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="Package+2B20Tools_+3A_comm.ptr">comm.ptr</code></td>
<td>
<p>a communicator pointer.</p>
</td></tr>
<tr><td><code id="Package+2B20Tools_+3A_show.msg">show.msg</code></td>
<td>
<p>if showing message for debug only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.mpi.comm.ptr()</code> returns an R external pointer that points
to the address of the comm.
</p>
<p><code>addr.mpi.comm.ptr()</code> takes the R external points, and
prints the address of the comm. This function is mainly for debugging.
</p>


<h3>Value</h3>

<p><code>get.mpi.comm.ptr()</code> returns an R external pointer.
</p>
<p><code>addr.mpi.comm.ptr()</code> prints the comm pointer address and the
address of MPI_COMM_WORLD.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 22processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

ptr1 &lt;- get.mpi.comm.ptr(1, show.msg = TRUE)
addr.mpi.comm.ptr(ptr1)

comm.split(color = as.integer(comm.rank()/2), key = comm.rank())

ptr1.new &lt;- get.mpi.comm.ptr(1, show.msg = TRUE)
addr.mpi.comm.ptr(ptr1.new)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code = spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='probe'> Probe Functions </h2><span id='topic+probe'></span><span id='topic+iprobe'></span>

<h3>Description</h3>

<p>The functions call MPI probe functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probe(rank.source = .pbd_env$SPMD.CT$rank.source,
      tag = .pbd_env$SPMD.CT$tag, comm = .pbd_env$SPMD.CT$comm,
      status = .pbd_env$SPMD.CT$status)
iprobe(rank.source = .pbd_env$SPMD.CT$rank.source,
       tag = .pbd_env$SPMD.CT$tag, comm = .pbd_env$SPMD.CT$comm,
       status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probe_+3A_rank.source">rank.source</code></td>
<td>
<p>a source rank where an object sent from.</p>
</td></tr>
<tr><td><code id="probe_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
<tr><td><code id="probe_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="probe_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal functions. Potentially, they set/get
probe for receiving data.
</p>


<h3>Value</h3>

<p>An invisible state of MPI call is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### See source code of spmd.recv.default() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='recv-method'> A Rank Receives (Blocking) an Object from the Other Rank </h2><span id='topic+recv-method'></span><span id='topic+recv+2CANY-method'></span><span id='topic+recv+2Cinteger-method'></span><span id='topic+recv+2Cnumeric-method'></span><span id='topic+recv+2Craw-method'></span><span id='topic+recv'></span>

<h3>Description</h3>

<p>This method lets a rank receive (blocking) an object from the other
rank in the same communicator. The default return is the object sent from
the other rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recv(x.buffer = NULL, rank.source = .pbd_env$SPMD.CT$rank.source,
     tag = .pbd_env$SPMD.CT$tag, comm = .pbd_env$SPMD.CT$comm,
     status = .pbd_env$SPMD.CT$status,
     check.type = .pbd_env$SPMD.CT$check.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recv-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to store <code>x</code> sent from the other rank.</p>
</td></tr>
<tr><td><code id="recv-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a source rank where <code>x</code> sent from</p>
</td></tr>
<tr><td><code id="recv-method_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
<tr><td><code id="recv-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="recv-method_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
<tr><td><code id="recv-method_+3A_check.type">check.type</code></td>
<td>
<p>if checking data type first for handshaking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>send()</code> should be evoked at the corresponding rank
<code>rank.source</code>.
</p>
<p>These are high level S4 methods. By default, <code>check.type</code> is <code>TRUE</code>
and an additional <code>send()/recv()</code> will make a handshaking call first,
then deliver the data next.
i.e. an integer vector of length two (type and length)
will be deliver first between <code>send()</code> and <code>recv()</code> to ensure
a buffer (of right type and right size/length) is properly allocated at
the <code>rank.dest</code> side.
</p>
<p>Currently, four data types are considered: <code>integer</code>, <code>double</code>,
<code>raw/byte</code>, and <code>default/raw.object</code>. The default method will
make a <code>serialize()</code> call first to convert the general R object into
a <code>raw</code> vector before sending it away. After the <code>raw</code> vector
is received at the <code>rank.dest</code> side, the vector will be
<code>unserialize()</code> back to the R object format.
</p>
<p><code>check.type</code> set as <code>FALSE</code> will stop the additional
handhsaking call, but the buffer should be prepared carefully
by the user self. This is typically for the advanced users and
more specifically calls are needed. i.e. calling those
<code>spmd.send.integer</code> with <code>spmd.recv.integer</code> correspondingly.
</p>
<p><code>check.type</code> also needs to be set as <code>FALSE</code> for more efficient
calls such as <code>isend()/recv()</code> or <code>send()/irecv()</code>. Currently,
no check types are implemented in those mixed calls.
</p>


<h3>Value</h3>

<p>An object is returned by default and the buffer will be overwritten
implicitely.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.recv.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irecv">irecv</a>()</code>, <code><a href="#topic+send">send</a>()</code>, <code><a href="#topic+isend">isend</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
if(.comm.rank == 0){
  y &lt;- send(matrix(x, nrow = 1))
} else if(.comm.rank == 1){
  y &lt;- recv()
}
comm.print(y, rank.print = 1)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='reduce-method'> A Rank Receive a Reduction of Objects from Every Rank </h2><span id='topic+reduce-method'></span><span id='topic+reduce+2CANY+2Cmissing-method'></span><span id='topic+reduce+2Cinteger+2Cinteger-method'></span><span id='topic+reduce+2Cnumeric+2Cnumeric-method'></span><span id='topic+reduce+2Clogical+2Clogical-method'></span><span id='topic+reduce+2Cfloat32+2Cfloat32-method'></span><span id='topic+reduce'></span>

<h3>Description</h3>

<p>This method lets a rank receive a reduction of objects from every rank
in the same communicator based on a given operation. The default return
is an object as the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce(x, x.buffer = NULL, op = .pbd_env$SPMD.CT$op,
       rank.dest = .pbd_env$SPMD.CT$rank.source,
       comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce-method_+3A_x">x</code></td>
<td>
<p>an object to be gathered from all ranks.</p>
</td></tr>
<tr><td><code id="reduce-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to hold the return object which probably has
<code>x</code> with the same type of <code>x</code>.</p>
</td></tr>
<tr><td><code id="reduce-method_+3A_op">op</code></td>
<td>
<p>a reduction operation applied on combine all <code>x</code>.</p>
</td></tr>
<tr><td><code id="reduce-method_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where all <code>x</code> reduce to.</p>
</td></tr>
<tr><td><code id="reduce-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the object is reduced to <code>.pbd_env$SPMD.CT$rank.source</code>,
i.e. <em>rank 0L</em>.
</p>
<p>All <code>x</code> on all ranks are likely presumed to have the same size and type.
</p>
<p><code>x.buffer</code> can be <code>NULL</code> or unspecified. If specified, the type
should be either integer or double specified correctly according to the
type of <code>x</code>.
</p>
<p>See <code>methods{"reduce"}</code> for S4 dispatch cases and the source code for
further details.
</p>


<h3>Value</h3>

<p>The reduced object of the same type as <code>x</code> is returned by default.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allgather">allgather</a>()</code>, <code><a href="#topic+gather">gather</a>()</code>, <code><a href="#topic+reduce">reduce</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initial.
suppressMessages(library(pbdMPI, quietly = TRUE))
init()
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
y &lt;- reduce(matrix(x, nrow = 1), op = \"sum\")
comm.print(y)

y &lt;- reduce(x, double(N), op = \"prod\")
comm.print(y)

x &lt;- as.logical(round(runif(N)))
y &lt;- reduce(x, logical(N), op = \"land\")
comm.print(y)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code = spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='scatter-method'> A Rank Scatter Objects to Every Rank </h2><span id='topic+scatter-method'></span><span id='topic+scatter+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic+scatter+2Cinteger+2Cinteger+2Cmissing-method'></span><span id='topic+scatter+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic+scatter+2Craw+2Craw+2Cmissing-method'></span><span id='topic+scatter+2CANY+2Cmissing+2Cinteger-method'></span><span id='topic+scatter+2CANY+2CANY+2Cinteger-method'></span><span id='topic+scatter+2Cinteger+2Cinteger+2Cinteger-method'></span><span id='topic+scatter+2Cnumeric+2Cnumeric+2Cinteger-method'></span><span id='topic+scatter+2Craw+2Craw+2Cinteger-method'></span><span id='topic+scatter'></span>

<h3>Description</h3>

<p>This method lets a rank scatter objects to every rank in the same
communicator. The default input is a list of length equal to &lsquo;comm size&rsquo;
and the default return is an element of the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter(x, x.buffer = NULL, x.count = NULL, displs = NULL,
        rank.source = .pbd_env$SPMD.CT$rank.source,
        comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter-method_+3A_x">x</code></td>
<td>
<p>an object of length &lsquo;comm size&rsquo; to be scattered to all ranks.</p>
</td></tr>
<tr><td><code id="scatter-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to hold the return object which probably has
'size of element of <code>x</code>' with the same type
of the element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="scatter-method_+3A_x.count">x.count</code></td>
<td>
<p>a vector of length &lsquo;comm size&rsquo; containing all object lengths.</p>
</td></tr>
<tr><td><code id="scatter-method_+3A_displs">displs</code></td>
<td>
<p><code>c(0L, cumsum(x.count))</code> by default.</p>
</td></tr>
<tr><td><code id="scatter-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a rank of source where elements of <code>x</code> scatter from.</p>
</td></tr>
<tr><td><code id="scatter-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All elements of <code>x</code> are likely presumed to have the same size and type.
</p>
<p><code>x.buffer</code>, <code>x.count</code>, and <code>displs</code> can be <code>NULL</code> or
unspecified. If specified, the type should be one of integer, double, or
raw specified correctly according to the type of <code>x</code>.
</p>
<p>If <code>x.count</code> is specified, then the <code>spmd.scatterv.*()</code> is 
called.
</p>


<h3>Value</h3>

<p>An element of <code>x</code> is returned according to the rank id.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.scatter.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY", x.buffer = "missing", x.count = "missing")</code></dt><dd></dd>
<dt><code>signature(x = "integer", x.buffer = "integer", x.count = "missing")</code></dt><dd></dd>
<dt><code>signature(x = "numeric", x.buffer = "numeric", x.count = "missing")</code></dt><dd></dd>
<dt><code>signature(x = "raw", x.buffer = "raw", x.count = "missing")</code></dt><dd></dd>
</dl>

<p>For calling <code>spmd.scatterv.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY", x.buffer = "missing", x.count = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "ANY", x.buffer = "ANY", x.count = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "integer", x.buffer = "integer", x.count = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric", x.buffer = "numeric", x.count = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "raw", x.buffer = "raw", x.count = "integer")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bcast">bcast</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- split(1:(N * .comm.size), rep(1:.comm.size, N))
y &lt;- scatter(lapply(x, matrix, nrow = 1))
comm.print(y)
y &lt;- scatter(x, double(N))
comm.print(y)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='seed+20for+20RNG'>Parallel random number generation with reproducible results</h2><span id='topic+comm.set.seed'></span><span id='topic+comm.set.stream'></span><span id='topic+comm.get.streams'></span><span id='topic+comm.seed.state'></span><span id='topic+comm.end.seed'></span><span id='topic+comm.reset.seed'></span>

<h3>Description</h3>

<p>These functions control the parallel-capable L'Ecuyer-CMRG pseudo-random 
number generator (RNG) on clusters and in multicore parallel applications for 
reproducible results. Reproducibility is possible across different node and
core configurations by associating the RNG streams with an application 
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.set.seed(
  seed = NULL,
  diff = TRUE,
  state = NULL,
  streams = NULL,
  comm = .pbd_env$SPMD.CT$comm
)
comm.set.stream(
  name = NULL,
  reset = FALSE,
  state = NULL,
  comm = .pbd_env$SPMD.CT$comm
)
comm.get.streams(
  comm = .pbd_env$SPMD.CT$comm, 
  seed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_seed">seed</code></td>
<td>
<p>In <code>comm.set.seed</code>, a single value interpreted as an 
integer. In <code>comm.get.streams</code>, a logical if TRUE, return includes the
current local <code>.Random.seed</code>.
</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_diff">diff</code></td>
<td>
<p>Logical indicating if the parallel instances should have different
random streams.</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_state">state</code></td>
<td>
<p>In function <code>comm.set.seed</code>: This parameter is deprecated. 
In function <code>comm.set.stream</code>: If non-NULLit restarts a stream from a
previously saved <code>state &lt;- comm.set.stream()</code>. A stream state is a list 
with one named element, which is the 6-element L'Ecuyer-CMRG 
<code>.Random.seed</code>, probably captured earlier with 
<code>state &lt;- comm.set.stream()</code>). The stream name, if 
different from a provided parameter <code>name</code>, has precedence, but a 
warning is produced. Further, the requesting rank must own the stream.</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_streams">streams</code></td>
<td>
<p>An vector of sequential integers specifying the streams to be
prepared on the current rank. Typically, this is used by 'comm.chunk()' to 
prepare correct streams for each rank, which are aligned with the vector 
being chunk-ed.</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_name">name</code></td>
<td>
<p>Stream number that is coercible to character, indicating to 
start or continue generating from that stream.</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_reset">reset</code></td>
<td>
<p>If true, reset the requested stream back to its beginning.</p>
</td></tr>
<tr><td><code id="seed+2B20for+2B20RNG_+3A_comm">comm</code></td>
<td>
<p>The communicator that determines MPI rank numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation uses the function <code><a href="parallel.html#topic+nextRNGStream">nextRNGStream</a></code>
in package <code>parallel</code> to set up streams appropriate for working on a
cluster system with MPI. The main difference from <code>parallel</code> is
that it adds a reproducibility capability with vector-based
streams that works across different numbers of nodes or cores by associating
streams with an application vector.
</p>
<p>Vector-based streams are best set up with the higher level function 
<code><a href="#topic+comm.chunk">comm.chunk</a></code> instead of using <code>comm.set.stream</code> directly.
<code><a href="#topic+comm.chunk">comm.chunk</a></code> will set up only the streams that each rank needs 
and provides the stream numbers necessary to switch between them with 
<code>comm.set.stream</code>.
</p>
<p>The function uses <code>parallel</code>'s
<code>nextRNGStream()</code> and sets up the parallel stream seeds in the
<code>.pbd_env$RNG</code> environment, which are then managed with
<code><a href="#topic+comm.set.stream">comm.set.stream</a></code>. There is only one communication broadcast in
this implementation that ensures all ranks have the same seed as rank 0. 
Subsequently, each rank maintains only its own streams.
</p>
<p>When rank-based streams are set up, <code><a href="#topic+comm.chunk">comm.chunk</a></code> with 
<code>form = "number"</code> and <code>rng = TRUE</code> parameters, streams are 
different for each rank and switching is not needed. Vector-based streams
are obtained with <code>form = "vector"</code> and <code>rng = TRUE</code> parameters.
In this latter case, the vector returned to each
rank contains the stream numbers (and vector components) that the rank owns.
Switch with <code>comm.set.stream(v)</code>, where v is one of the stream numbers.
Switching back and forth is allowed, with each stream continuing where it
left off.
</p>
<p>## RNG Notes
R sessions connected by MPI begin like other R sessions as discussed in
<code><a href="base.html#topic+Random">Random</a></code>. On first use of random number generation, 
each rank computes its own seed from a combination of clock time and process
id (unless it reads a previously saved workspace, which is not recommended). 
Because of asynchronous execution, imperfectly synchronized node clocks,
and likely different process ids, this
almost guarantees unique seeds and most likely results in independent 
streams. However, this is not reproducible and not guaranteed. Both 
reproducibility and guarantee are brought by the use of the L'Ecuyer-CMRG 
generator implementation in <code><a href="parallel.html#topic+nextRNGStream">nextRNGStream</a></code> and the
use of <code>comm.set.seed</code> and <code><a href="#topic+comm.set.stream">comm.set.stream</a></code> adaptation for
parallel computing on cluster systems.
</p>
<p>At a high level, the L'Ecuyer-CMRG pseudo-random number generator can 
take jumps (advance the seed) in its 
stream (about 2^191 long) so that distant substreams can be assigned. The 
<code><a href="parallel.html#topic+nextRNGStream">nextRNGStream</a></code> implementation takes jumps of 2^127 
(about 1.7e38) to provide up to 2^64 (about 1.8e19) independent streams. See
<a href="https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf">https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf</a>
for more details.
</p>
<p>In situations that require the same stream on all ranks, a simple 
<code><a href="base.html#topic+set.seed">set.seed</a></code> from base R and the default RNG will suffice. 
<code>comm.set.seed</code> will also accomplish this with the <code>diff = FALSE</code>
parameter if switching between same and different streams is needed.
</p>


<h3>Value</h3>

<p><code>comm.set.seed</code> engages the L'Ecuyer-CMRG RNG and invisibly returns
the previous RNG in use (Output of RNGkind()[1]). Capturing it, enables 
the restoration of the previous RNG with <code><a href="base.html#topic+RNGkind">RNGkind</a></code>. See examples
of use in <code>demo/seed_rank.r</code> and <code>demo/seed_vec.r</code>.
</p>
<p><code>comm.set.stream</code> invisibly returns the current stream number as character.
</p>
<p><code>comm.get.streams</code> returns the current stream name and other stream names available to the rank as a character string. Optionally, the local 
<code>.Random.seed</code> is included. This function is a debugging aid for 
distributed random streams.
</p>
<p>All three functions manage and use the environment <code>.pbd_env$RNG</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Pierre L'Ecuyer, Simard, R., Chen, E.J., and Kelton, W.D. (2002)
An Object-Oriented Random-Number Package with Many Long Streams and
Substreams. Operations Research, 50(6), 1073-1075.
</p>
<p><a href="https://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf">https://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf</a>
</p>
<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code>comm.chunk()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
suppressMessages(library(pbdMPI, quietly = TRUE))     

comm.print(RNGkind())
comm.print(runif(5), all.rank = TRUE)

set.seed(1357)
comm.print(runif(5), all.rank = TRUE)

old.kind = comm.set.seed(1357)
comm.print(RNGkind())
comm.print(runif(5), all.rank = TRUE)

comm.set.stream(reset = TRUE)
comm.print(runif(5), all.rank = TRUE)

comm.set.seed(1357, diff = TRUE)
comm.print(runif(5), all.rank = TRUE)

state &lt;- comm.set.stream()   ### save each rank's stream state
comm.print(runif(5), all.rank = TRUE)

comm.set.stream(state = state) ### set current RNG to state
comm.print(runif(5), all.rank = TRUE)

RNGkind(old.kind)
set.seed(1357)
comm.print(RNGkind())
comm.print(runif(5), all.rank = TRUE)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='send-method'> A Rank Send (blocking) an Object to the Other Rank </h2><span id='topic+send-method'></span><span id='topic+send+2CANY-method'></span><span id='topic+send+2Cinteger-method'></span><span id='topic+send+2Cnumeric-method'></span><span id='topic+send+2Craw-method'></span><span id='topic+send'></span>

<h3>Description</h3>

<p>This method lets a rank send (blocking) an object to the other rank
in the same communicator. The default return is <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send(x, rank.dest = .pbd_env$SPMD.CT$rank.dest,
     tag = .pbd_env$SPMD.CT$tag,
     comm = .pbd_env$SPMD.CT$comm,
     check.type = .pbd_env$SPMD.CT$check.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send-method_+3A_x">x</code></td>
<td>
<p>an object to be sent from a rank.</p>
</td></tr>
<tr><td><code id="send-method_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where <code>x</code> send to.</p>
</td></tr>
<tr><td><code id="send-method_+3A_tag">tag</code></td>
<td>
<p>a tag number.</p>
</td></tr>
<tr><td><code id="send-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="send-method_+3A_check.type">check.type</code></td>
<td>
<p>if checking data type first for handshaking.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>recv()</code> should be evoked at the corresponding rank
<code>rank.dest</code>.
</p>
<p>These are high level S4 methods. By default, <code>check.type</code> is <code>TRUE</code>
and an additional <code>send()/recv()</code> will make a handshaking call first,
then deliver the data next.
i.e. an integer vector of length two (type and length)
will be deliver first between <code>send()</code> and <code>recv()</code> to ensure
a buffer (of right type and right size/length) is properly allocated at
the <code>rank.dest</code> side.
</p>
<p>Currently, four data types are considered: <code>integer</code>, <code>double</code>,
<code>raw/byte</code>, and <code>default/raw.object</code>. The default method will
make a <code>serialize()</code> call first to convert the general R object into
a <code>raw</code> vector before sending it away. After the <code>raw</code> vector
is received at the <code>rank.dest</code> side, the vector will be
<code>unserialize()</code> back to the R object format.
</p>
<p><code>check.type</code> set as <code>FALSE</code> will stop the additional
handhsaking call, but the buffer should be prepared carefully
by the user self. This is typically for the advanced users and
more specifically calls are needed. i.e. calling those
<code>spmd.send.integer</code> with <code>spmd.recv.integer</code> correspondingly.
</p>
<p><code>check.type</code> also needs to be set as <code>FALSE</code> for more efficient
calls such as <code>isend()/recv()</code> or <code>send()/irecv()</code>. Currently,
no check types are implemented in those mixed calls.
</p>


<h3>Value</h3>

<p>A <code>NULL</code> is returned by default.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.send.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isend">isend</a>()</code>, <code><a href="#topic+recv">recv</a>()</code>, <code><a href="#topic+irecv">irecv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
if(.comm.rank == 0){
  y &lt;- send(matrix(x, nrow = 1))
} else if(.comm.rank == 1){
  y &lt;- recv()
}
comm.print(y, rank.print = 1)

### Finish.
finalize()
"
pbdMPI::execmpi(spmd.code, nranks = 2L)
</code></pre>

<hr>
<h2 id='sendrecv-method'> Send and Receive an Object to and from Other Ranks </h2><span id='topic+sendrecv-method'></span><span id='topic+sendrecv+2CANY+2CANY-method'></span><span id='topic+sendrecv+2Cinteger+2Cinteger-method'></span><span id='topic+sendrecv+2Cnumeric+2Cnumeric-method'></span><span id='topic+sendrecv+2Craw+2Craw-method'></span><span id='topic+sendrecv'></span>

<h3>Description</h3>

<p>This method lets a rank send an object to the other rank and
receive an object from another rank in the same communicator.
The default return is <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendrecv(x, x.buffer = NULL,
  rank.dest = (comm.rank(.pbd_env$SPMD.CT$comm) + 1) %%
              comm.size(.pbd_env$SPMD.CT$comm),
  send.tag = .pbd_env$SPMD.CT$tag,
  rank.source = (comm.rank(.pbd_env$SPMD.CT$comm) - 1) %%
                comm.size(.pbd_env$SPMD.CT$comm),
  recv.tag = .pbd_env$SPMD.CT$tag,
  comm = .pbd_env$SPMD.CT$comm, status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sendrecv-method_+3A_x">x</code></td>
<td>
<p>an object to be sent from a rank.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_x.buffer">x.buffer</code></td>
<td>
<p>a buffer to store <code>x</code> sent from the other rank.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where <code>x</code> send to.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_send.tag">send.tag</code></td>
<td>
<p>a send tag number.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a source rank where <code>x</code> sent from.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_recv.tag">recv.tag</code></td>
<td>
<p>a receive tag number.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="sendrecv-method_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>sendrecv()</code> should be evoked at the corresponding ranks
<code>rank.dest</code> and <code>rank.source</code>.
</p>
<p><code>rank.dest</code> and <code>rank.source</code> can be <code>as.integer(NULL)</code> to
create a silent sendrecv operation which is more efficient than setting
<code>rank.dest</code> and <code>rank.source</code> to be equal.
</p>


<h3>Value</h3>

<p>A <code>x</code> is returned by default.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.sendrecv.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY", x.buffer = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer", x.buffer = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric", x.buffer = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw", x.buffer = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sendrecv.replace">sendrecv.replace</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.size
y &lt;- sendrecv(matrix(x, nrow = 1))
comm.print(y, rank.print = 1)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendrecv.replace-method'> Send and Receive an Object to and from Other Ranks </h2><span id='topic+sendrecv.replace-method'></span><span id='topic+sendrecv.replace+2CANY-method'></span><span id='topic+sendrecv.replace+2Cinteger-method'></span><span id='topic+sendrecv.replace+2Cnumeric-method'></span><span id='topic+sendrecv.replace+2Craw-method'></span><span id='topic+sendrecv.replace'></span>

<h3>Description</h3>

<p>This method lets a rank send an object to the other rank and
receive an object from another rank in the same communicator.
The default return is <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendrecv.replace(x,
  rank.dest = (comm.rank(.pbd_env$SPMD.CT$comm) + 1) %%
              comm.size(.pbd_env$SPMD.CT$comm),
  send.tag = .pbd_env$SPMD.CT$tag,
  rank.source = (comm.rank(.pbd_env$SPMD.CT$comm) - 1) %%
                comm.size(.pbd_env$SPMD.CT$comm),
  recv.tag = .pbd_env$SPMD.CT$tag,
  comm = .pbd_env$SPMD.CT$comm, status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sendrecv.replace-method_+3A_x">x</code></td>
<td>
<p>an object to be sent from a rank.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_rank.dest">rank.dest</code></td>
<td>
<p>a rank of destination where <code>x</code> send to.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_send.tag">send.tag</code></td>
<td>
<p>a send tag number.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_rank.source">rank.source</code></td>
<td>
<p>a source rank where <code>x</code> sent from.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_recv.tag">recv.tag</code></td>
<td>
<p>a receive tag number.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="sendrecv.replace-method_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A corresponding <code>sendrecv.replace()</code> should be evoked at the
corresponding ranks <code>rank.dest</code> and <code>rank.source</code>.
</p>
<p><code>rank.dest</code> and <code>rank.source</code> can be <code>as.integer(NULL)</code> to
create a silent sendrecv operation which is more efficient than setting
<code>rank.dest</code> and <code>rank.source</code> to be equal.
</p>
<p><strong>Warning:</strong> <code>sendrecv.replace()</code> is not safe for <span class="rlang"><b>R</b></span> since <span class="rlang"><b>R</b></span> is
not a thread safe package that a dynamic returning object requires certain
blocking or barrier at some where. The replaced object or memory address
&lsquo;MUST&rsquo; return correctly. This is almost equivalent to <code>sendrecv()</code>.
</p>


<h3>Value</h3>

<p>A <code>x</code> is returned by default.
</p>


<h3>Methods</h3>

<p>For calling <code>spmd.sendrecv.replace.*()</code>:
</p>

<dl>
<dt><code>signature(x = "ANY")</code></dt><dd></dd>
<dt><code>signature(x = "integer")</code></dt><dd></dd>
<dt><code>signature(x = "numeric")</code></dt><dd></dd>
<dt><code>signature(x = "raw")</code></dt><dd></dd>
</dl>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sendrecv">sendrecv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.size
x &lt;- sendrecv.replace(matrix(x, nrow = 1))
comm.print(x, rank.print = 1)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='Set+20global+20pbd+20options'> Set Global pbdR Options </h2><span id='topic+pbd_opt'></span>

<h3>Description</h3>

<p>This is an advanced function to set pbdR options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbd_opt(..., bytext = "", envir = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Set+2B20global+2B20pbd+2B20options_+3A_...">...</code></td>
<td>
<p>in argument format <code>option = value</code> to set
<code>.pbd_env$option &lt;- value</code> inside the <code>envir</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20global+2B20pbd+2B20options_+3A_bytext">bytext</code></td>
<td>
<p>in text format <code>"option = value"</code> to set
<code>.pbd_env$option &lt;- value</code> inside the <code>envir</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20global+2B20pbd+2B20options_+3A_envir">envir</code></td>
<td>
<p>by default the global environment is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>...</code> allows multiple options in
<code>envir$.pbd_env</code>, but only in a simple way.
</p>
<p><code>bytext</code> allows to assign options by text in
<code>envir$.pbd_env</code>, but can assign advanced objects. For example,
<code>"option$suboption &lt;- value"</code> will set
<code>envir$.pbd_env$option$suboption &lt;- value</code>.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and Drew Schmidt.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.pbd_env">.pbd_env</a></code>,
<code><a href="#topic+SPMD.CT">SPMD.CT</a>()</code>,
<code><a href="#topic+SPMD.OP">SPMD.OP</a>()</code>,
<code><a href="#topic+SPMD.IO">SPMD.IO</a>()</code>,
<code><a href="#topic+SPMD.TP">SPMD.TP</a>()</code>, and
<code><a href="#topic+.mpiopt_init">.mpiopt_init</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 4 processors by
### SHELL&gt; mpiexec -np 4 Rscript demo.r

### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))

### Examples.
ls(.pbd_env)
pbd_opt(ICTXT = c(2, 2))
pbd_opt(bytext = "grid.new &lt;- list(); grid.new$ICTXT &lt;- c(4, 4)")
pbd_opt(BLDIM = c(16, 16), bytext = "grid.new$BLDIM = c(8, 8)")
ls(.pbd_env)
.pbd_env$ICTXT
.pbd_env$BLDIM
.pbd_env$grid.new

### Finish.
finalize()

## End(Not run)
</code></pre>

<hr>
<h2 id='sourcetag'> Functions to Obtain source and tag </h2><span id='topic+anysource'></span><span id='topic+anytag'></span><span id='topic+get.sourcetag'></span>

<h3>Description</h3>

<p>The functions extract MPI_ANY_SOURCE, MPI_ANY_TAG,
MPI_status.source and MPI_status.tag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anysource()
anytag()
get.sourcetag(status = .pbd_env$SPMD.CT$status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourcetag_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal uses.
</p>


<h3>Value</h3>

<p>Corresponding status will be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()
if(.comm.size &lt; 2)
  comm.stop(\"At least two processors are requried.\")

### Examples.
if(.comm.rank != 0){
  send(as.integer(.comm.rank * 10), rank.dest = 0L,
       tag = as.integer(.comm.rank + 10))
}
if(.comm.rank == 0){
  for(i in 1:(.comm.size - 1)){
    ret &lt;- recv(x.buffer = integer(1),
                rank.source = anysource(), tag = anytag())
    sourcetag &lt;- get.sourcetag()
    print(c(sourcetag, ret))
  }
}

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='SPMD+20Control'>Default control in pbdMPI.</h2><span id='topic+.pbd_env'></span>

<h3>Description</h3>

<p>These variables provide default values for most functions in the package.
</p>


<h3>Format</h3>

<p>The environment <code>.pbd_env</code> contains several objects with parameters for
communicators and methods.
</p>


<h3>Details</h3>

<p>The elements of <code>.pbd_env$SPMD.CT</code> are default values for various 
controls
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements              </td><td style="text-align: center;"> Default    </td><td style="text-align: left;"> Meaning </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>comm</code>           </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> communicator index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>intercomm</code>      </td><td style="text-align: center;"> 2L         </td><td style="text-align: left;"> inter communicator index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>info</code>           </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> info index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>newcomm</code>        </td><td style="text-align: center;"> 1L         </td><td style="text-align: left;"> new communicator index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>op</code>             </td><td style="text-align: center;"> "sum"      </td><td style="text-align: left;"> the operation </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>port.name</code>      </td><td style="text-align: center;"> "spmdport" </td><td style="text-align: left;"> the operation </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>print.all.rank</code> </td><td style="text-align: center;"> FALSE      </td><td style="text-align: left;"> whether all ranks print message </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>print.quiet</code>    </td><td style="text-align: center;"> FALSE      </td><td style="text-align: left;"> whether rank is added to print/cat </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rank.root</code>      </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> the rank of root </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rank.source</code>    </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> the rank of source </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rank.dest</code>      </td><td style="text-align: center;"> 1L         </td><td style="text-align: left;"> the rank of destination </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>request</code>        </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> the request index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>serv.name</code>      </td><td style="text-align: center;"> "spmdserv" </td><td style="text-align: left;"> the service name </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>status</code>         </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> the status index </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>tag</code>            </td><td style="text-align: center;"> 0L         </td><td style="text-align: left;"> the tag number </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>unlist</code>         </td><td style="text-align: center;"> FALSE      </td><td style="text-align: left;"> whether to unlist a return </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>divide.method</code>  </td><td style="text-align: center;"> "block"    </td><td style="text-align: left;"> default method for jid </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>mpi.finalize</code>   </td><td style="text-align: center;"> TRUE       </td><td style="text-align: left;"> shutdown MPI on <code>finalize()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quit</code>           </td><td style="text-align: center;"> TRUE       </td><td style="text-align: left;"> quit when errors occur </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>msg.flush</code>      </td><td style="text-align: center;"> TRUE       </td><td style="text-align: left;"> flush each comm.cat/comm.print</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>msg.barrier</code>    </td><td style="text-align: center;"> TRUE       </td><td style="text-align: left;"> include barrier in comm.cat/comm.print </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>Rprof.all.rank</code> </td><td style="text-align: center;"> FALSE      </td><td style="text-align: left;"> call Rprof on all ranks </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>lazy.check</code>     </td><td style="text-align: center;"> TRUE      </td><td style="text-align: left;"> use lazy check on all ranks </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of <code>.pbd_env$SPMD.OP</code> list the implemented operations for
<code>reduce()</code> and <code>allreduce()</code>. Currently, implemented operations are
&quot;sum&quot;, &quot;prod&quot;, &quot;max&quot;, &quot;min&quot;, &quot;land&quot;, &quot;band&quot;, &quot;lor&quot;, &quot;bor&quot;, &quot;lxor&quot;, &quot;bxor&quot;.
</p>
<p>The elements of <code>.SPMD.IO</code> are default values for functions in
<code>comm_read.r</code> and <code>comm_balance.r</code>.
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements              </td><td style="text-align: center;"> Default    </td><td style="text-align: left;"> Meaning </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>max.read.size</code>  </td><td style="text-align: center;"> 5.2e6      </td><td style="text-align: left;"> max of reading size (5 MB) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>max.test.lines</code> </td><td style="text-align: center;"> 500        </td><td style="text-align: left;"> max of testing lines </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>read.method</code>    </td><td style="text-align: center;"> "gbd"      </td><td style="text-align: left;"> default reading method </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>balance.method</code> </td><td style="text-align: center;"> "block"    </td><td style="text-align: left;"> default load balance method </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>where <code>balance.method</code> is only used for &quot;gbd&quot; reading method when
<code>nrows = -1</code> and <code>skip = 0</code> are set.
</p>
<p>The elements of <code>.pbd_env$SPMD.TP</code> are default values for
task pull settings
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements          </td><td style="text-align: center;"> Default </td><td style="text-align: left;"> Meaning </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>bcast</code>      </td><td style="text-align: center;"> FALSE   </td><td style="text-align: left;"> whether to <code>bcast()</code> objects to all ranks </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>barrier</code>    </td><td style="text-align: center;"> TRUE    </td><td style="text-align: left;"> if call <code>barrier()</code> for all ranks </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>try</code>        </td><td style="text-align: center;"> TRUE    </td><td style="text-align: left;"> if use <code>try()</code> in works </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>try.silent</code> </td><td style="text-align: center;"> FALSE   </td><td style="text-align: left;"> if silent the <code>try()</code> message </td>
</tr>
<tr>
 <td style="text-align: left;">
  See <code><a href="#topic+task.pull">task.pull</a>()</code> for details.
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='SPMD+20Control+20Functions'>Sets of controls in pbdMPI.</h2><span id='topic+SPMD.CT'></span><span id='topic+SPMD.OP'></span><span id='topic+SPMD.IO'></span><span id='topic+SPMD.TP'></span><span id='topic+SPMD.DT'></span><span id='topic+.mpiopt_init'></span>

<h3>Description</h3>

<p>These sets of controls are used to provide default values in this package.
The values are not supposed to be changed in general.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.pbd_env">.pbd_env</a></code>.
</p>

<hr>
<h2 id='SPMD+20Internal+20Functions'> All SPMD Internal Functions </h2><span id='topic+spmd.allcheck.type'></span><span id='topic+spmd.allgather.object'></span><span id='topic+spmd.allgather.array'></span><span id='topic+spmd.allgather.default'></span><span id='topic+spmd.allgatherv.default'></span><span id='topic+spmd.allgather.integer'></span><span id='topic+spmd.allgather.double'></span><span id='topic+spmd.allgather.raw'></span><span id='topic+spmd.allgatherv.integer'></span><span id='topic+spmd.allgatherv.double'></span><span id='topic+spmd.allgatherv.raw'></span><span id='topic+spmd.allreduce.object'></span><span id='topic+spmd.allreduce.array'></span><span id='topic+spmd.allreduce.default'></span><span id='topic+spmd.allreduce.integer'></span><span id='topic+spmd.allreduce.double'></span><span id='topic+spmd.allreduce.logical'></span><span id='topic+spmd.allreduce.float'></span><span id='topic+spmd.allreduce.float32'></span><span id='topic+spmd.bcast.object'></span><span id='topic+spmd.bcast.array'></span><span id='topic+spmd.bcast.default'></span><span id='topic+spmd.bcast.integer'></span><span id='topic+spmd.bcast.double'></span><span id='topic+spmd.bcast.raw'></span><span id='topic+spmd.bcast.string'></span><span id='topic+spmd.bcast.message'></span><span id='topic+spmd.barrier'></span><span id='topic+spmd.check.type.send'></span><span id='topic+spmd.check.type.recv'></span><span id='topic+spmd.comm.set.errhandler'></span><span id='topic+spmd.comm.is.null'></span><span id='topic+spmd.comm.rank'></span><span id='topic+spmd.comm.localrank'></span><span id='topic+spmd.comm.size'></span><span id='topic+spmd.comm.dup'></span><span id='topic+spmd.comm.free'></span><span id='topic+spmd.init'></span><span id='topic+spmd.finalize'></span><span id='topic+spmd.is.finalized'></span><span id='topic+spmd.is.manager'></span><span id='topic+spmd.get.processor.name'></span><span id='topic+spmd.comm.abort'></span><span id='topic+spmd.comm.split'></span><span id='topic+spmd.comm.disconnect'></span><span id='topic+spmd.comm.connect'></span><span id='topic+spmd.comm.accept'></span><span id='topic+spmd.port.open'></span><span id='topic+spmd.port.close'></span><span id='topic+spmd.serv.publish'></span><span id='topic+spmd.serv.unpublish'></span><span id='topic+spmd.serv.lookup'></span><span id='topic+spmd.comm.spawn'></span><span id='topic+spmd.comm.get.parent'></span><span id='topic+spmd.intercomm.merge'></span><span id='topic+spmd.intercomm.create'></span><span id='topic+spmd.comm.c2f'></span><span id='topic+spmd.gather.object'></span><span id='topic+spmd.gather.array'></span><span id='topic+spmd.gather.default'></span><span id='topic+spmd.gatherv.default'></span><span id='topic+spmd.gather.integer'></span><span id='topic+spmd.gather.double'></span><span id='topic+spmd.gather.raw'></span><span id='topic+spmd.gatherv.integer'></span><span id='topic+spmd.gatherv.double'></span><span id='topic+spmd.gatherv.raw'></span><span id='topic+spmd.info.create'></span><span id='topic+spmd.info.set'></span><span id='topic+spmd.info.free'></span><span id='topic+spmd.info.c2f'></span><span id='topic+spmd.irecv.default'></span><span id='topic+spmd.irecv.integer'></span><span id='topic+spmd.irecv.double'></span><span id='topic+spmd.irecv.raw'></span><span id='topic+spmd.isend.default'></span><span id='topic+spmd.isend.integer'></span><span id='topic+spmd.isend.double'></span><span id='topic+spmd.isend.raw'></span><span id='topic+spmd.recv.default'></span><span id='topic+spmd.recv.integer'></span><span id='topic+spmd.recv.double'></span><span id='topic+spmd.recv.raw'></span><span id='topic+spmd.reduce.object'></span><span id='topic+spmd.reduce.array'></span><span id='topic+spmd.reduce.default'></span><span id='topic+spmd.reduce.integer'></span><span id='topic+spmd.reduce.double'></span><span id='topic+spmd.scatter.object'></span><span id='topic+spmd.reduce.logical'></span><span id='topic+spmd.reduce.float'></span><span id='topic+spmd.reduce.float32'></span><span id='topic+spmd.scatter.array'></span><span id='topic+spmd.scatter.default'></span><span id='topic+spmd.scatterv.default'></span><span id='topic+spmd.scatter.integer'></span><span id='topic+spmd.scatter.double'></span><span id='topic+spmd.scatter.raw'></span><span id='topic+spmd.scatterv.integer'></span><span id='topic+spmd.scatterv.double'></span><span id='topic+spmd.scatterv.raw'></span><span id='topic+spmd.send.default'></span><span id='topic+spmd.send.integer'></span><span id='topic+spmd.send.double'></span><span id='topic+spmd.send.raw'></span><span id='topic+spmd.sendrecv.default'></span><span id='topic+spmd.sendrecv.integer'></span><span id='topic+spmd.sendrecv.double'></span><span id='topic+spmd.sendrecv.raw'></span><span id='topic+spmd.sendrecv.replace.default'></span><span id='topic+spmd.sendrecv.replace.integer'></span><span id='topic+spmd.sendrecv.replace.double'></span><span id='topic+spmd.sendrecv.replace.raw'></span><span id='topic+spmd.hostinfo'></span><span id='topic+spmd.comm.print'></span><span id='topic+spmd.comm.cat'></span><span id='topic+spmd.probe'></span><span id='topic+spmd.iprobe'></span><span id='topic+spmd.anysource'></span><span id='topic+spmd.anytag'></span><span id='topic+spmd.get.sourcetag'></span><span id='topic+spmd.get.count'></span><span id='topic+spmd.is.comm.null'></span><span id='topic+spmd.wait'></span><span id='topic+spmd.waitany'></span><span id='topic+spmd.waitsome'></span><span id='topic+spmd.waitall'></span>

<h3>Description</h3>

<p> All SPMD internal functions </p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat("

==========================================================================
All examples are run.
==========================================================================

")

### Force "R CMD check" to free memory.
finalize(mpi.finalize = TRUE)
</code></pre>

<hr>
<h2 id='Task+20Pull'>Functions for Task Pull Parallelism</h2><span id='topic+task.pull'></span><span id='topic+task.pull.workers'></span><span id='topic+task.pull.manager'></span>

<h3>Description</h3>

<p>These functions are designed for SPMD but assume that rank 0 is a manager and
the rest are workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>task.pull(jids, FUN, ..., rank.manager = .pbd_env$SPMD.CT$rank.root,
          comm = .pbd_env$SPMD.CT$comm, bcast = .pbd_env$SPMD.TP$bcast,
          barrier = .pbd_env$SPMD.TP$barrier,
          try = .pbd_env$SPMD.TP$try,
          try.silent = .pbd_env$SPMD.TP$try.silent)

task.pull.workers(FUN = function(jid, ...){ return(jid) }, ...,
                  rank.manager = .pbd_env$SPMD.CT$rank.root,
                  comm = .pbd_env$SPMD.CT$comm,
                  try = .pbd_env$SPMD.TP$try,
                  try.silent = .pbd_env$SPMD.TP$try.silent)
task.pull.manager(jids, rank.manager = .pbd_env$SPMD.CT$rank.root,
                 comm = .pbd_env$SPMD.CT$comm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Task+2B20Pull_+3A_jids">jids</code></td>
<td>
<p>all job ids (a vector of positive integers).</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_fun">FUN</code></td>
<td>
<p>a function to be evaluated by workers.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_...">...</code></td>
<td>
<p>extra parameters for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_rank.manager">rank.manager</code></td>
<td>
<p>rank of the manager from where <code>jid</code> is sent.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_comm">comm</code></td>
<td>
<p>a communicator number.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_bcast">bcast</code></td>
<td>
<p>if bcast to all ranks.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_barrier">barrier</code></td>
<td>
<p>if barrier for all ranks.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_try">try</code></td>
<td>
<p>wheter to use <code>try()</code> to avoid crashes. CAUTION: 
<code>try = FALSE</code> is not safe and can crash all MPI/R jobs.</p>
</td></tr>
<tr><td><code id="Task+2B20Pull_+3A_try.silent">try.silent</code></td>
<td>
<p>turn off error messages from <code>try()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All of these functions are designed to emulate a manager/workers paradigm in 
an SPMD environment. If your chunk workloads are known and similar, consider
a direct SPMD solution.
</p>
<p><code>FUN</code> is a user defined function which has <code>jid</code> as
its first argument and other variables are given in <code>...</code>.
</p>
<p>The manager will be queried by workers whenever a worker finishes a job to
see if more jobs are available.
</p>


<h3>Value</h3>

<p>A list with length <code>comm.size() - 1</code>
will be returned to the manager and <code>NULL</code> to the workers.
Each element of the list contains the returns <code>ret</code> of their <code>FUN</code>
results.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.jid">get.jid</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Under command mode, run the demo with 2 processors by
### (Use Rscript.exe for windows system)
# mpiexec -np 2 Rscript -e "demo(task_pull,'pbdMPI',ask=F,echo=F)"
### Or
# execmpi("demo(task_pull,'pbdMPI',ask=F,echo=F)", nranks = 2L)

## End(Not run)
</code></pre>

<hr>
<h2 id='Utility+20execmpi'> Execute MPI code in system </h2><span id='topic+execmpi'></span><span id='topic+runmpi'></span>

<h3>Description</h3>

<p>This function basically saves code in a spmd.file and executes
MPI via R's system call e.g.
<code>system("mpiexec -np 1 Rscript spmd.file")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execmpi(spmd.code = NULL, spmd.file = NULL,
    mpicmd = NULL, nranks = 1L, rscmd = NULL, verbose = TRUE,
    disable.current.mpi = TRUE, mpiopt = NULL, rsopt = NULL)
runmpi(spmd.code = NULL, spmd.file = NULL,
    mpicmd = NULL, nranks = 1L, rscmd = NULL, verbose = TRUE,
    disable.current.mpi = TRUE, mpiopt = NULL, rsopt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Utility+2B20execmpi_+3A_spmd.code">spmd.code</code></td>
<td>
<p>SPMD code to be run via mpicmd and <code>Rscript</code>.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_spmd.file">spmd.file</code></td>
<td>
<p>a file contains SPMD code to be run via mpicmd and <code>Rscript</code>.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_mpicmd">mpicmd</code></td>
<td>
<p>MPI executable command. If <code>NULL</code>, system default will be searched.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_nranks">nranks</code></td>
<td>
<p>number of processes to run the SPMD code envoked by mpicmd.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_rscmd">rscmd</code></td>
<td>
<p><code>Rscript</code> executable command. If <code>NULL</code>, system default will be searched.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_verbose">verbose</code></td>
<td>
<p>print SPMD code outputs and MPI messages.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_disable.current.mpi">disable.current.mpi</code></td>
<td>
<p>force to finalize the current MPI comm if any, for unix-alike system only.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_mpiopt">mpiopt</code></td>
<td>
<p>MPI options appended after <code>-np nranks --oversubscribe </code>.</p>
</td></tr>
<tr><td><code id="Utility+2B20execmpi_+3A_rsopt">rsopt</code></td>
<td>
<p><code>Rscript</code> options appended after <code>Rscript </code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>spmd.code</code> is <code>NULL</code>: The code should be already
saved in the file named <code>spmd.file</code> for using.
</p>
<p>When the <code>spmd.code</code> is not <code>NULL</code>:
The <code>spmd.code</code> will be dumped to a temp file (<code>spmd.file</code>) via the
call <code>writeLines(spmd.code, conn)</code> where
<code>conn &lt;- file(spmd.file, open = "wt")</code>. The file will be closed after
the dumping.
</p>
<p>When <code>spmd.file</code> is ready (either dumped from <code>spmd.code</code> or
provided by the user), the steps below will be followed:
If <code>spmd.file = NULL</code>, then a temporary file will be generated and
used to dump <code>spmd.code</code>.
</p>
<p>For Unix-alike systems, the command
<code>cmd &lt;- paste(mpicmd, "-np", nranks, mpiopt, rscmd, rscmd spmd.file, "&gt;", log.file, " 2&gt;&amp;1 &amp; echo \"PID=$!\" &amp;")</code>
is executed via <code>system(cmd, intern = TRUE, wait = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)</code>. The <code>log.file</code> is a temporary file to
save the outputs from the <code>spmd.code</code>. The results saved to the
<code>log.file</code> will be read back in and <code>cat</code> and <code>return</code>
to R.
</p>
<p>For OPENMPI, the &quot;&ndash;oversubscribe &quot; is added before <code>mpiopt</code> as
<code>mpiopt &lt;- paste("--oversubscribe ", mpiopt, sep = "")</code>
and is passed to <code>cmd</code> thereon.
</p>
<p>For Windows, the <code>cmd</code> will be
<code>paste(mpicmd, "-np", nranks, mpiopt, rscmd, rsopt spmd.file)</code>
and is executed via
<code>system(cmd, intern = TRUE, wait = FALSE, ignore.stdout = TRUE, ignore.stderr = TRUE)</code>.
</p>


<h3>Value</h3>

<p>Basically, only the PID of the MPI job (in background) will be returned
in Linux-alike systems. For Windows, the MPI job is always wait until
it is complete.
</p>


<h3>Note</h3>

<p>For Unix-alike systems,
in new R and MPI, the <code>pbdMPI::execmpi(...)</code> may
carry the current MPI <code>comm</code> into <code>system(cmd, ...)</code> calls.
Because the <code>comm</code> has been established/loaded by the
<code>init()</code> call because of <code>::</code>,
the <code>mpiexec</code> inside the <code>system(cmd, ...)</code> calls
will be confused with the exist <code>comm</code>.
</p>
<p>Consider that <code>pbdMPI::execmpi(...)</code> is typically called in
interactive mode (or actually only done for CRAN check in most case),
an argument <code>disable.current.mpi = TRUE</code> is added/needed to finalize
the existing <code>comm</code> first before <code>system(cmd, ...)</code> be executed.
</p>
<p>This function is NOT recommended for running SPMD programs.
The recommended way is to run under shell command.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and Drew Schmidt.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code>pbdCS::pbdRscript()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.file &lt;- tempfile()
cat("
suppressMessages(library(pbdMPI, quietly = TRUE))
allreduce(2)
finalize()
", file = spmd.file)
pbdMPI::execmpi(spmd.file = spmd.file, nranks = 2L)
</code></pre>

<hr>
<h2 id='wait'> Wait Functions </h2><span id='topic+wait'></span><span id='topic+waitany'></span><span id='topic+waitsome'></span><span id='topic+waitall'></span>

<h3>Description</h3>

<p>The functions call MPI wait functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait(request = .pbd_env$SPMD.CT$request,
     status = .pbd_env$SPMD.CT$status)
waitany(count, status = .pbd_env$SPMD.CT$status)
waitsome(count)
waitall(count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wait_+3A_request">request</code></td>
<td>
<p>a request number.</p>
</td></tr>
<tr><td><code id="wait_+3A_status">status</code></td>
<td>
<p>a status number.</p>
</td></tr>
<tr><td><code id="wait_+3A_count">count</code></td>
<td>
<p>a count number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for internal uses. Potentially, they wait after some
nonblocking MPI calls.
</p>


<h3>Value</h3>

<p>An invisible state of MPI call is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>, George Ostrouchov,
Drew Schmidt, Pragneshkumar Patel, and Hao Yu.
</p>


<h3>References</h3>

<p>Programming with Big Data in R Website:
<a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Save code in a file "demo.r" and run with 2 processors by
### SHELL&gt; mpiexec -np 2 Rscript demo.r

spmd.code &lt;- "
### Initialize
suppressMessages(library(pbdMPI, quietly = TRUE))
.comm.size &lt;- comm.size()
.comm.rank &lt;- comm.rank()

### Examples.
N &lt;- 5
x &lt;- (1:N) + N * .comm.rank
if(.comm.rank == 0){
  isend(list(x))
}
if(.comm.rank == 1){
  y &lt;- irecv(list(x))
}
wait()
comm.print(y, rank.print = 1L)

### Finish.
finalize()
"
# execmpi(spmd.code, nranks = 2L)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
