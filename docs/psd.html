<!DOCTYPE html><html><head><title>Help for package psd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psd-package'><p>Adaptive power spectral density estimation using optimal sine multitapers</p></a></li>
<li><a href='#as.tapers'><p>Coerce an object into a <code>'tapers'</code> object.</p></a></li>
<li><a href='#coherence'><p>coherence</p></a></li>
<li><a href='#ctap_loess'><p>Taper constraints using loess smoothing</p></a></li>
<li><a href='#det_vector'><p>det_vector</p></a></li>
<li><a href='#hfsnm'><p>Noise levels found in PBO strainmeter data at seismic frequencies.</p></a></li>
<li><a href='#magnet'><p>A single line of Project MAGNET horizontal field intensity</p></a></li>
<li><a href='#modulo_floor'><p>Nearest value below</p></a></li>
<li><a href='#parabolic_weights_rcpp'><p>parabolic_weights_field</p></a></li>
<li><a href='#pgram_compare'><p>Compare multitaper spectrum with cosine-tapered periodogram</p></a></li>
<li><a href='#phase'><p>phase</p></a></li>
<li><a href='#pilot_spec'><p>Calculate initial power spectral density estimates</p></a></li>
<li><a href='#prewhiten'><p>Prepare a series for spectral estimation</p></a></li>
<li><a href='#psd-environment'><p>Various environment manipulation functions.</p></a></li>
<li><a href='#psd-normalization'><p>Normalization of power spectral density estimates.</p></a></li>
<li><a href='#psd-utilities'><p>Various utility functions.</p></a></li>
<li><a href='#psdcore'><p>Multitaper power spectral density estimates of a series</p></a></li>
<li><a href='#pspectrum'><p>Adaptive sine multitaper power spectral density estimation</p></a></li>
<li><a href='#rcpp_ctap_simple'><p>c++ implementation of the RLP constraint filter</p></a></li>
<li><a href='#resample_fft_rcpp'><p>Resample an fft using varying numbers of sine tapers</p></a></li>
<li><a href='#resample_mvfft'><p>Resample an fft using varying numbers of sine tapers</p></a></li>
<li><a href='#riedsid'><p>Constrained, optimal tapers using the Riedel &amp; Sidorenko&ndash;Parker method</p></a></li>
<li><a href='#riedsid_rcpp'><p>replaces time consuming portion of riedsid2</p></a></li>
<li><a href='#spec_confint'><p>Confidence intervals for multitaper power spectral density estimates</p></a></li>
<li><a href='#spec-methods'><p>Generic methods for objects with class <code>'spec'</code></p></a></li>
<li><a href='#spectral_properties'><p>Calculate properties of multitaper power spectral density estimates</p></a></li>
<li><a href='#splineGrad'><p>Numerical derivatives of a series based on its smooth-spline representation</p></a></li>
<li><a href='#tapers-constraints'><p>Taper constraint methods</p></a></li>
<li><a href='#tapers-methods'><p>Generic methods for objects with class <code>'tapers'</code></p></a></li>
<li><a href='#tapers-refinement'><p>Taper constraints using simple derivatives</p></a></li>
<li><a href='#Tohoku'><p>Observations of teleseismic strains from the 2011 Tohoku earthquake.</p></a></li>
<li><a href='#wipp30'><p>Water levels from borehole WIPP30</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive, Sine-Multitaper Power Spectral Density and Cross
Spectrum Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Produces power spectral density estimates through iterative
    refinement of the optimal number of sine-tapers at each frequency. This
    optimization procedure is based on the method of Riedel and Sidorenko
    (1995), which minimizes the Mean Square Error (sum of variance and bias)
    at each frequency, but modified for computational stability. The same
    procedure can now be used to calculate the cross spectrum (multivariate
    analyses).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/abarbour/psd">https://github.com/abarbour/psd</a>, Barbour and Parker (2014):
<a href="https://doi.org/10.1016/j.cageo.2013.09.015">https://doi.org/10.1016/j.cageo.2013.09.015</a>, Riedel and
Sidorenko (1995): <a href="https://doi.org/10.1109/78.365298">https://doi.org/10.1109/78.365298</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/abarbour/psd/issues">https://github.com/abarbour/psd/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.5), RColorBrewer</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bspec, fftw (&ge; 1.0.3), ggplot2 (&ge; 0.9), multitaper, plyr,
RSEIS, rbenchmark, reshape2, knitr, rmarkdown, signal, formatR,
testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-31 21:00:07 UTC; abarbour</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew J. Barbour <a href="https://orcid.org/0000-0002-6890-2452"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonathan Kennel <a href="https://orcid.org/0000-0003-4474-6886"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Robert L. Parker [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew J. Barbour &lt;andy.barbour@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-31 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='psd-package'>Adaptive power spectral density estimation using optimal sine multitapers</h2><span id='topic+psd-package'></span><span id='topic+psd'></span><span id='topic+spec.psd'></span>

<h3>Description</h3>

<p>Estimate the power spectral density (PSD) 
of a timeseries using the sine multitapers, adaptively; the number of tapers 
(and hence the resolution and uncertainty) vary according to 
spectral shape. The main function to be used is <code><a href="#topic+pspectrum">pspectrum</a></code>.
</p>


<h3>Details</h3>

<p>In frequency ranges where the spectrum  (<code class="reqn">S</code>)
is relatively flat, more tapers are taken and so a higher accuracy is 
attained at the expense of lower frequency resolution. 
The program makes a pilot estimate of the spectrum, then uses
Riedel and Sidorenko's (1995) estimate of the MSE (minimum square error), 
which is based on an estimate of the second derivative of the PSD (<code class="reqn">S''</code>). 
The process is repeated <code>niter</code> times; further iteration may be necessary 
to reach convergence, or an acceptably low spectral variance. 
In this context the term &quot;acceptable&quot; is rather subjective: one can 
usually detect an unconverged state by a rather jagged appearance of the spectrum,
but this is uncommon in our experience.
</p>


<h4>Adaptive estimation</h4>

<p>The adaptive process used is as follows. A quadratic fit to the logarithm of the
PSD within an adaptively determined frequency band is used to find an estimate of the local second 
derivative of the spectrum. This is used in an equation like R-S equation (13) for 
the MSE taper number, with the difference that a parabolic weighting is applied with 
increasing taper order. Because the FFTs of the tapered series can be found by 
resampling the FFT of the original time series (doubled in length and padded with zeros) 
only one FFT is required per series, no matter how many tapers are used. 
The spectra associated with the sine tapers are weighted before averaging with a 
parabolically varying weight. The expression for the optimal number of tapers 
given by R-S must be modified since it gives an unbounded result near points 
where <code class="reqn">S''</code> vanishes, which happens at many points in most spectra. 
This program restricts the rate of growth of the number of tapers so that a 
neighboring covering interval estimate is never completely contained in the next 
such interval.
</p>



<h4>Resolution and uncertainty</h4>

<p>The sine multitaper adaptive process 
introduces a variable resolution and error in the frequency domain. 
See documentation for <code><a href="#topic+spectral_properties">spectral_properties</a></code> details on
how these are computed.
</p>



<h3>Author(s)</h3>

<p>Andrew J. Barbour &lt;andy.barbour@gmail.com&gt;, Jonathan Kennel, and Robert L. Parker
</p>


<h3>References</h3>

<p>Barbour, A. J. and R. L. Parker, (2014), 
psd: Adaptive, sine multitaper power spectral density estimation for R,
<em>Computers and Geosciences</em>, <strong>63</strong>, 1&ndash;8,
doi: 10.1016/j.cageo.2013.09.015
</p>
<p>Percival, D. B., and A.T. Walden (1993),
Spectral analysis for physical applications,
<em>Cambridge University Press</em>
</p>
<p>Prieto, G. A., R. L. Parker, D. J. Thomson, F. L. Vernon, and R. L. Graham  (2007), 
Reducing the bias of multitaper spectrum estimates,
<em>Geophysical Journal International</em>, <strong>171</strong>, 1269&ndash;1281,
doi: 10.1111/j.1365-246X.2007.03592.x
</p>
<p>Riedel, K. S., &amp; Sidorenko, A. (1995), 
Minimum bias multiple taper spectral estimation,
<em>Signal Processing, IEEE Transactions on</em>, <strong>43</strong>(1), 188&ndash;195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code> (main function); <code><a href="#topic+psdcore">psdcore</a></code> and <code><a href="#topic+riedsid">riedsid</a></code>
</p>

<hr>
<h2 id='as.tapers'>Coerce an object into a <code>'tapers'</code> object.</h2><span id='topic+as.tapers'></span><span id='topic+tapers'></span>

<h3>Description</h3>

<p>In a tapered spectrum estimation algorithm, it is
necessary to enforce rules on the number of tapers
that may be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.tapers(
  x,
  min_taper = 1,
  max_taper = NULL,
  setspan = FALSE,
  record.last = FALSE
)

tapers(
  x,
  min_taper = 1,
  max_taper = NULL,
  setspan = FALSE,
  record.last = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.tapers_+3A_x">x</code></td>
<td>
<p>An object to set</p>
</td></tr>
<tr><td><code id="as.tapers_+3A_min_taper">min_taper</code></td>
<td>
<p>Set all values less than this to this.</p>
</td></tr>
<tr><td><code id="as.tapers_+3A_max_taper">max_taper</code></td>
<td>
<p>Set all values greater than this to this.</p>
</td></tr>
<tr><td><code id="as.tapers_+3A_setspan">setspan</code></td>
<td>
<p>logical; should the tapers object be passed through <code><a href="#topic+minspan">minspan</a></code> before being returned?</p>
</td></tr>
<tr><td><code id="as.tapers_+3A_record.last">record.last</code></td>
<td>
<p>logical; should the <code>x</code> be saved to the <code><a href="#topic+psd-environment">psd-environment</a></code> before coercion?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Formal requirements enforced by this function are:
</p>

<ul>
<li><p> Non-zero.
</p>
</li>
<li><p> Integer values.
</p>
</li>
<li><p> Fewer than the half-length of the spectrum.
</p>
</li></ul>

<p>For example, we cannot apply
zero tapers (the result would be a raw periodogram)
or one million tapers (that would be absurd, and
violate orthogonality
conditions for any series less than two million terms long!).
</p>
<p>An object with S3 class <code>'tapers'</code> is created;
this will have
a minimum number of tapers in each position
set by <code>min_taper</code>, and
a maximum number of tapers in each position
set by <code>max_taper</code>.
If <code>minspan=TRUE</code>, the bounded taper is fed through <code><a href="#topic+minspan">minspan</a></code>
which will restrict the maximum tapers to less than or equal to
the half-length of the spectrum.
</p>
<p>Various classes can be coerced into a <code>'tapers'</code> object; those
tested sofar include: scalar, vector, matrix, data.frame, 
and list.  
</p>
<p>Multiple objects are concatenated into a single
vector dimension.  
</p>
<p>Enabling <code>setspan</code> will only override
<code>max_taper</code> should it be larger than the half-width of the series.
</p>


<h3>Value</h3>

<p>An object with class <code>'taper'</code>
</p>


<h3>Note</h3>

<p>No support (yet) for use of <code>min_taper,max_taper</code> as vectors, although
this could be quite desirable.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.tapers">is.tapers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Objects with class 'tapers'
##
is.tapers(as.tapers(1))
is.tapers(as.tapers(1:10))

# note dimensions
as.tapers(matrix(1:10,ncol=1))
as.tapers(list(x=1:10,y=1:30))
as.tapers( x &lt;- data.frame(x=1:10,y=10:19) )

# change constraints
as.tapers(x, min_taper=3, max_taper=10)

# class 'character' is in-coercible; raise error
try(as.tapers(c("a","b")), silent=TRUE)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='coherence'>coherence</h2><span id='topic+coherence'></span>

<h3>Description</h3>

<p>Calculate coherence from the spectra and cross-spectra. This method is the same as
used in <code>spec.pgram</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coherence(pgram)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coherence_+3A_pgram">pgram</code></td>
<td>
<p><code>numeric array</code> must be multivariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of coherence. For multivariate time series, a 
matrix containing the squared coherency between different series. 
Column i + (j - 1) * (j - 2)/2 contains the squared coherency 
between columns i and j of x, where i &lt; j.
</p>

<hr>
<h2 id='ctap_loess'>Taper constraints using loess smoothing</h2><span id='topic+ctap_loess'></span><span id='topic+ctap_loess.tapers'></span><span id='topic+ctap_loess.default'></span>

<h3>Description</h3>

<p>Taper constraints using loess smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctap_loess(tapvec, ...)

## S3 method for class 'tapers'
ctap_loess(tapvec, ...)

## Default S3 method:
ctap_loess(
  tapvec,
  tapseq = NULL,
  loess.span = 0.3,
  loess.degree = 1,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctap_loess_+3A_tapvec">tapvec</code></td>
<td>
<p>integer or <code>'tapers'</code> object; the number of tapers at each frequency</p>
</td></tr>
<tr><td><code id="ctap_loess_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="ctap_loess_+3A_tapseq">tapseq</code></td>
<td>
<p>numeric; positions or frequencies &ndash; necessary for smoother methods</p>
</td></tr>
<tr><td><code id="ctap_loess_+3A_loess.span">loess.span</code></td>
<td>
<p>scalar; the span used in <code>loess</code></p>
</td></tr>
<tr><td><code id="ctap_loess_+3A_loess.degree">loess.degree</code></td>
<td>
<p>scalar; the polynomial degree</p>
</td></tr>
<tr><td><code id="ctap_loess_+3A_verbose">verbose</code></td>
<td>
<p>logical; should warnings and messages be given?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+constrain_tapers">constrain_tapers</a></code>, <code><a href="#topic+ctap_simple">ctap_simple</a></code>
</p>

<hr>
<h2 id='det_vector'>det_vector</h2><span id='topic+det_vector'></span>

<h3>Description</h3>

<p>Determinant for an array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det_vector(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_vector_+3A_x">x</code></td>
<td>
<p><code>numeric array</code> values to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of determinants
</p>

<hr>
<h2 id='hfsnm'>Noise levels found in PBO strainmeter data at seismic frequencies.</h2><span id='topic+hfsnm'></span>

<h3>Description</h3>

<p>These values represent noise levels in high frequency data (<code class="reqn">10^{-3} - 10</code> Hz) from 2009, averaged over all
stations in the Anza cluster of the Plate Boundary Observatory (PBO) borehole
strainmeter network, and the UCSD-style longbase laser strainmeters.
</p>


<h3>Format</h3>

<p>A dataframe with 141 observations on the following 4 variables:
</p>

<dl>
<dt><code>freq</code></dt><dd><p>Frequencies, in Hertz.</p>
</dd>
<dt><code>P50</code></dt><dd><p>The 50th percentile (median) noise levels in decibels relative to <code class="reqn">1 \epsilon^2 / </code> Hz.</p>
</dd>
<dt><code>P10</code></dt><dd><p>The 10th percentile noise levels also in decibels.</p>
</dd>
<dt><code>meter.type</code></dt><dd><p>The strainmeter design type.</p>
</dd>
</dl>

<p>and 2 attributes:
</p>

<dl>
<dt><code>source.doi</code></dt><dd><p>The DOI number of the source publication.</p>
</dd>
<dt><code>generator</code></dt><dd><p>The structure of a function which will refresh the values from the supplemental files of the original publication.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>NA</code> values in the series highlight frequency bands where the noise
levels are unreliable, due to a instrumental artifact.
</p>


<h3>Source</h3>

<p>Barbour, A. J., and Agnew, D. C. (2011), Noise Levels on Plate Boundary Observatory Borehole Strainmeters in Southern California,
<em>Bulletin of the Seismological Society of America</em>,
<strong>101</strong>(5), 2453-2466, doi:10.1785/0120110062
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code>, <code><a href="#topic+Tohoku">Tohoku</a></code>, <code><a href="#topic+magnet">magnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hfsnm)
str(hfsnm)
FUN &lt;- attr(hfsnm, "generator")
try(dat &lt;- FUN(molten=FALSE)) # may fail without library-access to BSSA
try(all.equal(dat[,1:4], hfsnm[,1:4]))
</code></pre>

<hr>
<h2 id='magnet'>A single line of Project MAGNET horizontal field intensity</h2><span id='topic+magnet'></span>

<h3>Description</h3>

<p>The Project MAGNET mission 
provided a wealth of airborne-magnetometer data
spanning the globe (Coleman, 1992).  
This dataset represents a single track of horizontal field
intensities (a very small subset of the full collection!).
</p>


<h3>Format</h3>

<p>A dataframe with 2048 observations on the following 4 variables.
</p>

<dl>
<dt><code>km</code></dt><dd><p>Relative along-track distance, in kilometers. The first observation is at zero kilometers.</p>
</dd>
<dt><code>raw</code></dt><dd><p>Raw intensities, in nanotesla.</p>
</dd>
<dt><code>clean</code></dt><dd><p>Edited raw intensities, in nanotesla</p>
</dd>
<dt><code>mdiff</code></dt><dd><p>The difference between <code>clean</code> and <code>raw</code> intensities, in nanotesla.</p>
</dd>
</dl>



<h3>Details</h3>



<h4>Raw and Clean Sets</h4>

<p>There are non-real data points in raw MAGNET series; these are 
instrumental artefacts, and can severely affect
power spectral density (PSD) estimates.  
A clean series has been included
so that a comparison of PSDs may be made.
</p>
<p>Some command like <code>subset(magnet, abs(mdiff) &gt; 0)</code>
can be used to identify the rows where edits have been made.
</p>



<h3>Source</h3>

<p>Project MAGNET page: <a href="https://www.ngdc.noaa.gov/geomag/proj_mag.shtml">https://www.ngdc.noaa.gov/geomag/proj_mag.shtml</a>
</p>


<h3>References</h3>

<p>Coleman, R. J. (1992),
Project Magnet high-level vector survey data reduction. 
In <em>Types and Characteristics of Data for Geomagnetic Field Modeling</em>,
<strong>3153</strong>, pp. 215-248.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code>, <code><a href="#topic+Tohoku">Tohoku</a></code>, <code><a href="#topic+hfsnm">hfsnm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(magnet)
summary(magnet)
</code></pre>

<hr>
<h2 id='modulo_floor'>Nearest value below</h2><span id='topic+modulo_floor'></span>

<h3>Description</h3>

<p>Returns the nearest <code>m</code>-length value (downwards from <code>n</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modulo_floor(n, m = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modulo_floor_+3A_n">n</code></td>
<td>
<p>integer; the number of terms (can be a vector)</p>
</td></tr>
<tr><td><code id="modulo_floor_+3A_m">m</code></td>
<td>
<p>integer; the modulo term (cannot be zero)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is different from <code><a href="stats.html#topic+nextn">nextn</a></code> in that the value is floored.
For example:
<code>10</code> is the result for <code>n=11,m=2</code> whereas <code><a href="stats.html#topic+nextn">nextn</a></code> would give <code>12</code>.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psd-utilities">psd-utilities</a></code>; <code><a href="#topic+psdcore">psdcore</a></code> uses this to 
truncate series to their nearest even length (i.e., <code>m=2</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 11
nextn(n) # 12
modulo_floor(n) # 10

# works on vectors too:
# defaults to m=2
modulo_floor(seq_len(n))
#[1]  0  2  2  4  4  6  6  8  8 10 10

# change the floor factor
modulo_floor(seq_len(n), 3)
#[1] 0 0 3 3 3 6 6 6 9 9 9

# zeros are not allowed for m
try(modulo_floor(n, 0))

</code></pre>

<hr>
<h2 id='parabolic_weights_rcpp'>parabolic_weights_field</h2><span id='topic+parabolic_weights_rcpp'></span><span id='topic+parabolic_weights_field'></span><span id='topic+parabolic_weights'></span><span id='topic+parabolic_weights.tapers'></span><span id='topic+parabolic_weights.default'></span>

<h3>Description</h3>

<p>The resampled spectrum involves summing weighted tapers; this produces
the weighting factors. 
<code><a href="#topic+parabolic_weights_rcpp">parabolic_weights_rcpp</a></code> is the fastest implementation, used by
<code><a href="#topic+resample_fft_rcpp">resample_fft_rcpp</a></code>, but it takes only a single value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parabolic_weights_rcpp(ntap = 1L)

parabolic_weights_field(ntap)

parabolic_weights(ntap, ...)

## S3 method for class 'tapers'
parabolic_weights(ntap, tap.index = 1L, ...)

## Default S3 method:
parabolic_weights(ntap = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parabolic_weights_rcpp_+3A_ntap">ntap</code></td>
<td>
<p>integer (or <code>tapers</code> object); the number of tapers to provide weightings for.</p>
</td></tr>
<tr><td><code id="parabolic_weights_rcpp_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="parabolic_weights_rcpp_+3A_tap.index">tap.index</code></td>
<td>
<p>integer; if <code>ntap</code> is a <code>tapers</code> object, the index from which to produce a sequence of weights for</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If one has a <code>tapers</code> object, specify the <code>taper.index</code> to
produce a sequence of weights up to the value at that index; the user
is likely to never need to use this function though.
</p>
<p>Weighting factors, <code class="reqn">W</code>, are calculated as follows:
</p>
<p style="text-align: center;"><code class="reqn">
 W \equiv \frac{6 (n^2 - K^2)}{n (4 * n - 1) (n + 1)}
</code>
</p>

<p>where <code class="reqn">n</code> is the total number of tapers, and 
<code class="reqn">K</code> is the integer sequence <code class="reqn">[0,n-1]</code>.
</p>
<p>The sum of tapers should equal 1, within machine precision, when <code class="reqn">n&gt;0</code>.
</p>


<h3>Value</h3>

<p>A list with the number of tapers, indices of the taper sequence, and the weights <code class="reqn">W_N</code>.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour adapted the original algorithm (R.L. Parker), and authored the optimized versions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample_fft_rcpp">resample_fft_rcpp</a></code>, <code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+riedsid2">riedsid2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)
library(grDevices)
library(RColorBrewer)

##
## Show parabolic weighting factors as a function of maximum tapers
##

# maximum number of tapers
maxx &lt;- 1e3
# sequence in logspace
xseq &lt;- seq(from=1,to=2.8,by=0.2)

# plot palette
pal &lt;- "Spectral"
npal &lt;- switch(pal, RdYlBu=11, Spectral=11, Blues=9)
pal.col &lt;- RColorBrewer::brewer.pal(npal, pal)
cols &lt;- rev(grDevices::colorRampPalette(pal.col)(maxx))

to_df &lt;- function(W){
  # convert parabolic results to data.frame
  with(W, data.frame(taper_seq=as.vector(taper_seq), taper_weights=as.vector(taper_weights)))
}

## a roundabout way of bootstrapping y-axis limits:
#  upper
WgtsU &lt;- parabolic_weights(5)
DfU &lt;- to_df(WgtsU)
#  lower
WgtsL &lt;- parabolic_weights(maxx)
DfL &lt;- to_df(WgtsL)

ylims &lt;- range(pretty(dB(c(DfL$taper_weights, DfU$taper_weights)))) + c(-2,5)

# function for plotting text
TFUN &lt;- function(Df.){
  tx &lt;- max(Df.$taper_seq)
  ty &lt;- mean(Df.$taper_weights)
  text(log10(tx)+0.1, dB(ty), sprintf("%i", tx), col=cols[tx])
}

# function for weighting factors and plotting
WFUN &lt;- function(x){
  message(x)
  Wgts &lt;- parabolic_weights(x)
  Df &lt;- to_df(Wgts)
  lcol &lt;- cols[x]
  lines(dB(taper_weights) ~ log10(taper_seq), Df, type="s", lwd=2, col=lcol)
  TFUN(Df)
}

## Plot parabolic weighting, in dB, colored by maximum num tapers
plot(dB(taper_weights) ~ log10(taper_seq), DfU, type="s", 
     xlim=c(0, log10(maxx)+0.2), 
     ylim=ylims, yaxs="i",
     col=cols[5], lwd=2,  
     main="Multitaper weighting factors by maximum tapers applied",
     xlab="log10 taper sequence", 
     ylab="dB")
TFUN(DfU)
invisible(lapply(round(10**xseq), FUN=WFUN))
WFUN(maxx)

##

## End(Not run)#REX
</code></pre>

<hr>
<h2 id='pgram_compare'>Compare multitaper spectrum with cosine-tapered periodogram</h2><span id='topic+pgram_compare'></span><span id='topic+pgram_compare.amt'></span>

<h3>Description</h3>

<p>Plot the results of <code><a href="#topic+psdcore">psdcore</a></code> against the results of 
<code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgram_compare(x, ...)

## S3 method for class 'amt'
pgram_compare(
  x,
  f = NULL,
  X = NULL,
  log.freq = TRUE,
  db.spec = TRUE,
  taper = 0.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgram_compare_+3A_x">x</code></td>
<td>
<p>a single <code><a href="#topic+psdcore">psdcore</a></code> object</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_...">...</code></td>
<td>
<p>additional parameters (currently unused)</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_f">f</code></td>
<td>
<p>numeric; the frequency range to plot; optional: if not given the program will show the entire band.</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_x">X</code></td>
<td>
<p>object used to create <code>x</code>; optional: if not given the program will
try and access the last copy in the environment. An attempt is made to coerce to an object of class <code>'ts'</code>.</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_log.freq">log.freq</code></td>
<td>
<p>logical; should frequencies be transformed with <code><a href="base.html#topic+log10">log10</a></code>?
Note that if <code>f</code> is given, the values should not already be transformed.</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_db.spec">db.spec</code></td>
<td>
<p>logical; should the spectrum estimates be converted to decibels with <code><a href="#topic+dB">dB</a></code>?</p>
</td></tr>
<tr><td><code id="pgram_compare_+3A_taper">taper</code></td>
<td>
<p>numeric; specifies the proportion of data to taper for the cosine periodogram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the cosine-tapered estimates and the adaptive estimates, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
X &lt;- rnorm(1e3)

# multitaper spectrum
p &lt;- psdcore(X, ntaper=10)

# how does it compare to a single-cosine tapered spectrum?
pgram_compare(p)

# or in a certain band
pgram_compare(p, c(0.1,0.4))

# linear frequencies
pgram_compare(p, c(0.1,0.4), log.freq = FALSE)
</code></pre>

<hr>
<h2 id='phase'>phase</h2><span id='topic+phase'></span>

<h3>Description</h3>

<p>Calculate phase from the spectra and cross spectrum. This method is the same as
used in <code>spec.pgram</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase(pgram)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase_+3A_pgram">pgram</code></td>
<td>
<p><code>numeric array</code> must be multivariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of phase. For multivariate time series a matrix containing the cross 
spectrum phase between different series. The format is the same as <code><a href="#topic+coherence">coherence</a></code>.
</p>

<hr>
<h2 id='pilot_spec'>Calculate initial power spectral density estimates</h2><span id='topic+pilot_spec'></span><span id='topic+pilot_spectrum'></span><span id='topic+spec.pilot'></span><span id='topic+pilot_spec.ts'></span><span id='topic+pilot_spec.matrix'></span><span id='topic+pilot_spec.default'></span>

<h3>Description</h3>

<p>This PSD is used as the starting point &ndash; the pilot spectrum &ndash; for
the adaptive estimation routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pilot_spec(x, ...)

## S3 method for class 'ts'
pilot_spec(x, ...)

## S3 method for class 'matrix'
pilot_spec(x, x.frequency, ...)

## Default S3 method:
pilot_spec(
  x,
  x.frequency = NULL,
  ntap = NULL,
  remove.AR = NULL,
  plot = FALSE,
  verbose = FALSE,
  fast = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pilot_spec_+3A_x">x</code></td>
<td>
<p>vector; the data series to find a pilot spectrum for</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+psdcore">psdcore</a></code></p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_x.frequency">x.frequency</code></td>
<td>
<p>scalar; the sampling frequency (e.g. Hz) of the series</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_ntap">ntap</code></td>
<td>
<p>scalar; the number of tapers to apply during spectrum estimation</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_remove.ar">remove.AR</code></td>
<td>
<p>scalar; the max AR model to be removed from the data.</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_plot">plot</code></td>
<td>
<p>logical; should a plot be created?</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be given?</p>
</td></tr>
<tr><td><code id="pilot_spec_+3A_fast">fast</code></td>
<td>
<p>logical; use fast method in <code><a href="#topic+psdcore">psdcore</a></code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fixed number
of tapers is applied across all frequencies using <code><a href="#topic+psdcore">psdcore</a></code>, and
subsequent taper-refinements are based on the spectral derivatives
of this spectrum; hence, changes in the number of tapers can affect
how many adaptive stages may be needed (though there are no formal convergence
criteria to speak of).
</p>
<p>The taper series of the returned spectrum is constrained using
<code>as.tapers(..., minspan=TRUE)</code>.
</p>
<p>The default behavior (<code>remove.AR &lt;= 0</code>) is to remove the standard linear 
model <code class="reqn">[f(x) = \alpha x + \beta]</code> from the data; however,
the user can model the effect of an autoregressive process by specifying
<code>remove.AR</code>.
</p>


<h3>Value</h3>

<p>Invisibly, an object with class <code>'spec'</code>, and 
<code>"pilot_psd"</code> in the working environment.
</p>


<h3>Removing an AR effect from the spectrum</h3>

<p>If <code>remove.AR &gt; 0</code> the argument is used as <code>AR.max</code> in 
<code><a href="#topic+prewhiten">prewhiten</a></code>, from which an AR-response spectrum is calculated using
the best fitting model.
</p>
<p>If the value of <code>remove.AR</code> is too low the spectrum 
could become distorted,
so use with care.
<em>Note, however, that the 
value of <code>remove.AR</code> will be restricted to within the 
range <code class="reqn">[1,100]</code>.</em>
If the AR order is much larger than this, it's unclear how <code><a href="#topic+prewhiten">prewhiten</a></code>
will perform and whether the AR model is appropriate.
</p>
<p><em>Note that this function does not produce a parametric spectrum estimation; rather,
it will return the amplitude response of the best-fitting AR model as <code><a href="stats.html#topic+spec.ar">spec.ar</a></code>
would. <strong>Interpret these results with caution, as an AR response spectrum
can be misleading.</strong></em>
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+prewhiten">prewhiten</a></code>, <code><a href="stats.html#topic+spec.ar">spec.ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Pilot spectrum
##

data(magnet)

## simply calculate the pilot spectrum with a few tapers
plot(pilot_spec(xc &lt;- magnet$clean), log="dB", 
     main="Pilot PSDs for MAGNET and its AR-innovations (red)")

## remove the effect of an AR model
# note: remove.AR -- the max AR model to be removed from the data
plot(pilot_spec(xc, remove.AR=10), log="dB", add=TRUE, col="red")


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='prewhiten'>Prepare a series for spectral estimation</h2><span id='topic+prewhiten'></span><span id='topic+prewhiten.default'></span><span id='topic+prewhiten.ts'></span>

<h3>Description</h3>

<p>Remove (optionally) mean, trend, and Auto Regressive (AR) model
from the original series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prewhiten(tser, ...)

## Default S3 method:
prewhiten(tser, x.fsamp = 1, x.start = c(1, 1), ...)

## S3 method for class 'ts'
prewhiten(
  tser,
  AR.max = 0L,
  detrend = TRUE,
  demean = TRUE,
  impute = TRUE,
  plot = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prewhiten_+3A_tser">tser</code></td>
<td>
<p>vector; An object to prewhiten.</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_...">...</code></td>
<td>
<p>variables passed to <code>prewhiten.ts</code> (for non <code>ts</code> objects)</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_x.fsamp">x.fsamp</code></td>
<td>
<p>sampling frequency (for non <code>ts</code> objects)</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_x.start">x.start</code></td>
<td>
<p>start time of observations (for non <code>ts</code> objects)</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_ar.max">AR.max</code></td>
<td>
<p>numeric; the maximum AR order to fit.</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_detrend">detrend</code></td>
<td>
<p>logical; Should a trend (and mean) be removed?</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_demean">demean</code></td>
<td>
<p>logical; Should a mean value be removed?</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_impute">impute</code></td>
<td>
<p>logical; Should NA values be imputed?</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_plot">plot</code></td>
<td>
<p>logical; Should the results be plotted?</p>
</td></tr>
<tr><td><code id="prewhiten_+3A_verbose">verbose</code></td>
<td>
<p>logical; Should messages be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The R-S multitapers do not exhibit the remarkable spectral-leakage 
suppression properties of the Thomson prolate tapers, 
so that in spectra with large dynamic range, 
power bleeds from the strong peaks into neighboring frequency bands of 
low amplitude &ndash; spectral leakage. 
Prewhitening can ameliorate the problem, at least for red spectra 
[see Chapter 9, Percival and Walden (1993)]. 
</p>
<p>The value of the <code>AR.max</code> argument is made absolute, after which
this function has essentially two modes of operation (detailed below):
</p>

<dl>
<dt><code>AR.max</code> == 0</dt><dd><p>Remove (optionally) a mean and/or linear trend.</p>
</dd>
<dt><code>AR.max</code> &gt; 0</dt><dd><p>Remove an autoregressive model</p>
</dd>
</dl>

<p>In the second case,
the time series is 
filtered in the time domain with a finite-impulse-response 
filter of <code>AR.max</code> terms. The filter is found by solving the Yule-Walker 
equations for 
which it is assumed the series was generated by an autoregressive process, up to
order <code>AR.max</code>.
</p>


<h4>Mean and trend (<code>AR.max == 0</code>)</h4>

<p>Power spectral density estimates can become badly biased
(especially at lower frequencies) if a signal of the form
<code class="reqn">f(x) = A x + B</code> is not removed from the series.  
If <code>detrend=TRUE</code> a model of this form is removed over the entire series using a
linear least-squares estimator; in this case a mean value is removed
regardless of the logical state of <code>demean</code>.
To remove <em>only</em> a mean value, set <code>detrend=FALSE</code> and (obviously) <code>demean=TRUE</code>.
</p>



<h4>Auto Regressive (AR) innovations (<code>AR.max &gt; 0</code>)</h4>

<p>When an autoregressive model is removed from a non-stationary series, the residuals
are known as 'innovations', and may be stationary (or very-nearly stationary).  
This function fits an AR model [order at least 1, but up to and including AR(<code>AR.max</code>)] to the series 
by solving the Yule-Walker equations; however, AIC is used to estimate the highest significant
order, which means that higher-order components may not necessarily be fit.
The resulting innovations can be used to better estimate the stationary component
of the original signal, and possibly in an interactive editing method.
</p>
<p>Note that the method used here&ndash;solving the Yule-Walker equations&ndash;is 
not a true maximum likelihood estimator; hence the AIC is calculated
based on the variance estimate (no determinant). From <code>?ar</code>:
<em>In <code>ar.yw</code> the variance matrix of the innovations is 
computed from the fitted coefficients and the autocovariance of <code>x</code>.</em>
</p>
<p>A quick way to determine whether this may be needed for the series is to run
<code>acf</code> on the series, and see if significant non-zero lag correlations
are found.  A warning is produced if the fit returns an AR(0) fit, indicating
that AR prewhitening most likely inappropriate for the series, which
is apparently stationary (or very nearly so).  (The innovations could end up
having <em>higher</em> variance than the input series in such a case.)
</p>
<p><em>Note that <code>AR.max</code> is restricted to the range <code class="reqn">[1,N-1]</code> where
<code class="reqn">N</code> is the series length.</em>
</p>



<h3>Value</h3>

<p>A list with the model fits (<code>lm</code> and <code>ar</code> objects),
the linear and AR prewhitened series (<code>ts</code> objects), and a logical
flag indicating whether the I/O has been imputed. This list includes:
<code>"lmdfit"</code>, <code>"ardfit"</code>, <code>"prew_lm"</code>, <code>"prew_ar"</code>, and <code>"imputed"</code>
</p>
<p><em>Note that if <code>AR.max=0</code> the AR information will exist as <code>NULL</code>.</em>
</p>


<h3>NA values</h3>

<p><code>NA</code> values are allowed.  If present, and <code>impute=TRUE</code>, 
the <code>na.locf</code> function in the package
<code>zoo</code> is used twice (with and without <code>fromLast</code> so that lead and
trailing <code>NA</code> values are also imputed).  The function name is an
acronym for &quot;Last Observation Carried Forward&quot;, a very crude method
of imputation.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour and Robert L. Parker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+pspectrum">pspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Using prewhiten to improve spectral estimates
##

data(magnet)
mts &lt;- ts(magnet$clean)
# add a slope
mts.slope &lt;- mts + seq_along(mts)

# Prewhiten by removing mean+trend, and
# AR model; fit truncates the series by 
# a few terms, so zero pad
mts &lt;- prewhiten(mts.slope,  AR.max=10, zero.pad="rear")
mts.p &lt;- mts[['prew_lm']]
mts.par &lt;- mts[['prew_ar']]

# uniformly-tapered spectral estimates
PSD &lt;- psdcore(mts.p, ntaper=20)
PSD.ar &lt;- psdcore(mts.par, ntaper=20)

# remove the effect of AR model
PSD.ar[['spec']] &lt;- PSD.ar[['spec']] / mean(PSD.ar[['spec']])
PSD[['spec']] &lt;- PSD[['spec']] / PSD.ar[['spec']]

plot(PSD, log='dB', lwd=2, ylim=c(-5,35))
plot(PSD, log='dB', add=TRUE, lwd=2, col="red")
plot(PSD.ar, log='dB', add=TRUE, col="blue", lwd=2)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='psd-environment'>Various environment manipulation functions.</h2><span id='topic+psd-environment'></span><span id='topic+get_psd_env_pointer'></span><span id='topic+get_psd_env_name'></span><span id='topic+psd_envRefresh'></span><span id='topic+psd_envClear'></span><span id='topic+psd_envStatus'></span><span id='topic+psd_envList'></span><span id='topic+psd_envGet'></span><span id='topic+psd_envAssign'></span><span id='topic+psd_envAssignGet'></span><span id='topic+get_adapt_history'></span><span id='topic+last_psd'></span><span id='topic+update_adapt_history'></span><span id='topic+update_adapt_history.spec'></span><span id='topic+update_adapt_history.default'></span><span id='topic+new_adapt_history'></span>

<h3>Description</h3>

<p>The computation of <em>adaptive</em> power spectral density estimates 
requires bookkeeping and non-destructive manipulation of variables.  
The functions here are mainly convenience wrappers
designed to maintain variable separation from the 
<code>.GlobalEnv</code> environment so that no innocent variable is destroyed in
the process of iteratively computing spectra.
<strong>The user should generally not be using the <em>setters</em> even though
all functions exist in the namespace.</strong>
</p>
<p><code>get_psd_env_pointer</code> is a convenience wrapper to get the environment pointer.
</p>
<p><code>get_psd_env_name</code> is a convenience wrapper to get the environment name.
</p>
<p><code>psd_envRefresh</code> will clear any variables in the environment and reset the initialization stamp.
</p>
<p><code>psd_envClear</code> clears the contents of the environment.
</p>
<p><code>psd_envStatus</code> returns a list of some information regarding
the status of the environment.
</p>
<p><code>psd_envList</code> returns a listing of any assignments.
</p>
<p><code>psd_envGet</code> returns the value of <code>variable</code>.
</p>
<p><code>psd_envAssign</code> assigns <code>value</code> to <code>variable</code>, but does not return it.
</p>
<p><code>psd_envAssignGet</code> both assigns and returns a value.
</p>
<p><code>update_adapt_history</code> updates the adaptive estimation history list.
</p>
<p><code>new_adapt_history</code> initializes a nested-list object to store the 
data from each iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_psd_env_pointer()

get_psd_env_name()

psd_envRefresh(verbose = TRUE)

psd_envClear()

psd_envStatus()

psd_envList()

psd_envGet(variable)

psd_envAssign(variable, value)

psd_envAssignGet(variable, value)

get_adapt_history()

last_psd()

update_adapt_history(PSD, stage, ...)

## S3 method for class 'spec'
update_adapt_history(PSD, stage, ...)

## Default S3 method:
update_adapt_history(PSD, stage, ntap = NA, freq = NULL, ...)

new_adapt_history(adapt_stages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psd-environment_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be given?</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_variable">variable</code></td>
<td>
<p>character; the name of the variable to get or assign</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_value">value</code></td>
<td>
<p>character; the name of the variable to assign</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_psd">PSD</code></td>
<td>
<p>vector or object with class <code>'spec'</code>; the power spectral density estimates</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_stage">stage</code></td>
<td>
<p>scalar; the current stage of the adaptive estimation procedure</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_ntap">ntap</code></td>
<td>
<p>vector; the tapers</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_freq">freq</code></td>
<td>
<p>vector; the frequencies</p>
</td></tr>
<tr><td><code id="psd-environment_+3A_adapt_stages">adapt_stages</code></td>
<td>
<p>scalar; The number of adaptive iterations to save (excluding pilot spectrum).</p>
</td></tr>
</table>


<h3>Defaults and Initialization</h3>

<p>One can use <code>get_psd_env_pointer()</code> and <code>get_psd_env_name()</code> to access the 
pointer and name of the environment, if
needed.
</p>
<p><code>psd_envRefresh</code> should be used when
a fresh environment is desired: typically only if, for example, <code><a href="#topic+psdcore">psdcore</a></code> is 
used rather than <code><a href="#topic+pspectrum">pspectrum</a></code>.
</p>


<h3>Assigning and Retrieving</h3>

<p><code>psd_envAssign</code> and <code>psd_envGet</code> perform the assignments and retrieval
of objects in the environment.  A convenience function, <code>psd_envAssignGet</code>,
is included so that both assignment and retrieval may be performed at the same
time.  This ensures the assignment has succeeded, and the returned value is
not from some other frame.
</p>


<h3>Getters and Setters</h3>

<p>The functions here can be classified whether the get, or set variables in the
environment; some do both.  
Others make no modifications to the environment.
</p>


<h4>Getter</h4>


<ul>
<li><p><code>get_adapt_history</code>
</p>
</li>
<li><p><code>get_psd_env_name</code>
</p>
</li>
<li><p><code>get_psd_env_pointer</code>
</p>
</li>
<li><p><code>psd_envGet</code>
</p>
</li>
<li><p><code>psd_envList</code>
</p>
</li>
<li><p><code>psd_envStatus</code>
</p>
</li></ul>




<h4>Setter</h4>


<ul>
<li><p><code>new_adapt_history</code>
</p>
</li>
<li><p><code>psd_envAssign</code>
</p>
</li></ul>




<h4>Getter and Setter</h4>


<ul>
<li><p><code>psd_envAssignGet</code>
</p>
</li>
<li><p><code>psd_envClear</code>
</p>
</li>
<li><p><code>psd_envRefresh</code>
</p>
</li>
<li><p><code>update_adapt_history</code>
</p>
</li></ul>




<h3>Adaptive History</h3>

<p>The list object for historical adapt-data may be accessed with <code><a href="#topic+get_adapt_history">get_adapt_history</a></code>.
The top names of the returned list are
</p>

<dl>
<dt><code>stg_kopt</code></dt><dd><p>Sequential taper vectors.</p>
</dd>
<dt><code>stg_psd</code></dt><dd><p>Sequential power spectral density vectors.</p>
</dd>
<dt><code>freq</code></dt><dd><p>The frequencies for each set of <code>stg_kopt</code> and <code>stg_psd</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p><code>psd_envClear</code> does <em>not</em> remove the environment&ndash;simply the assignments within it.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psd-utilities">psd-utilities</a></code>, <code><a href="#topic+pspectrum">pspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## psd working environment
##

# Get some status information about the psd working environment
psd_envStatus()

# Get a list of all variables
psd_envList()

# Pull the variable "init" into .GlobalEnv
print(x &lt;- psd_envGet("init"))

# Pull the adaptive history into .GlobalEnv
set.seed(1234)
X &lt;- rnorm(1e3)
pspectrum(X)
get_adapt_history()


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='psd-normalization'>Normalization of power spectral density estimates.</h2><span id='topic+psd-normalization'></span><span id='topic+normalization'></span><span id='topic+normalize'></span><span id='topic+normalize.list'></span><span id='topic+normalize.spec'></span><span id='topic+normalize.amt'></span>

<h3>Description</h3>

<p>Normalize power spectral densities from
various estimators into single-sided spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(Spec, ...)

## S3 method for class 'list'
normalize(Spec, ...)

## S3 method for class 'spec'
normalize(
  Spec,
  Fsamp = 1,
  src = c("spectrum", "double.sided", "psd", "single.sided"),
  verbose = TRUE,
  ...
)

## S3 method for class 'amt'
normalize(Spec, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psd-normalization_+3A_spec">Spec</code></td>
<td>
<p>spectrum to normalize</p>
</td></tr>
<tr><td><code id="psd-normalization_+3A_...">...</code></td>
<td>
<p>(unused) additional parameters</p>
</td></tr>
<tr><td><code id="psd-normalization_+3A_fsamp">Fsamp</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="psd-normalization_+3A_src">src</code></td>
<td>
<p>character string; the source of the spectrum estimator</p>
</td></tr>
<tr><td><code id="psd-normalization_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be given?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalizations commonly encountered for power spectra 
depend on it's assumed sidedness: whether the
spectrum is either single- or double-sided.
The normalizations performed here enforce single-sidedness, and correct
as necessary.
</p>
<p>Frequencies are assumed to be based on the Nyquist frequency (half the 
sampling rate).  For example: If a series <code class="reqn">X</code> has sampling frequency <code class="reqn">F_S</code>,
then the PSD frequencies will span <code class="reqn">[0,F_S/2]</code>.
</p>
<p>For amplitudes, improper normalization can can introduce errant factors
of either 1/2 or <code class="reqn">F_S</code> into the estimates, depending on the assumed sidedness.  
These factors can be accounted for with the <code>src</code>
argument, which defaults to normalizing a double-sided spectrum.
</p>


<h3>Value</h3>

<p>An object with its spectral values normalized accordingly.
</p>


<h3>Spectrum sidedness and the <code>src</code> argument</h3>



<h4><code>"double.sided"</code> or <code>"spectrum"</code></h4>

<p>These spectra assume frequency range of <code class="reqn">[-F_S/2,F_S/2]</code>, and so are normalized
by scaling by a factor of two upwards.
Some estimators producing double-sided spectra: 
</p>

<ul>
<li><p><code>stats::spectrum</code>
</p>
</li>
<li><p><code>RSEIS::mtapspec</code>
</p>
</li></ul>




<h4><code>"single.sided"</code> or <code>"psd"</code></h4>

<p>As mentioned before, 
these spectra assume frequency range of <code class="reqn">[0,F_S/2]</code> and
are scaled only by the inverse of the sampling rate.
Some estimators producing single-sided spectra: 
</p>

<ul>
<li><p><code><a href="#topic+psdcore">psdcore</a></code>
</p>
</li></ul>




<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+spectral_properties">spectral_properties</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Normalization
##

# timeseries with sampling frequency **not** equal to 1:
set.seed(1234)
X &lt;- ts(rnorm(1e3), frequency=20)

# spec.pgram: double sided
pgram &lt;- spectrum(X)

# psdcore: single sided
PSD &lt;- psdcore(X)

# note the normalization differences:
plot(pgram, log="dB", ylim=c(-40,10))
plot(PSD, add=TRUE, col="red", log="dB")

# A crude representation of integrated spectrum: 
#   should equal variance of white noise series (~= 1)
mean(pgram[['spec']]) * max(pgram[['freq']])
mean(PSD[['spec']]) * max(PSD[['freq']])

# normalize 
pgram &lt;- normalize(pgram, src="spectrum")
PSD &lt;- normalize(pgram, src="psd")
# replot them
plot(pgram, log="dB", ylim=c(-40,10))
plot(PSD, add=TRUE, col="red", log="dB")

# Again, integrated spectrum should be ~= 1:
mean(pgram[['spec']]) * max(pgram[['freq']])
mean(PSD[['spec']]) * max(PSD[['freq']])



## End(Not run)#REX
</code></pre>

<hr>
<h2 id='psd-utilities'>Various utility functions.</h2><span id='topic+psd-utilities'></span><span id='topic+na_locf'></span><span id='topic+na_locf.matrix'></span><span id='topic+na_locf.default'></span><span id='topic+vardiff'></span><span id='topic+varddiff'></span><span id='topic+varddiff.spec'></span><span id='topic+varddiff.default'></span><span id='topic+create_poly'></span><span id='topic+dB'></span><span id='topic+decibels'></span><span id='topic+db'></span><span id='topic+vector_reshape'></span><span id='topic+colvec'></span><span id='topic+rowvec'></span><span id='topic+is.spec'></span><span id='topic+is.amt'></span><span id='topic+is.tapers'></span><span id='topic+na_mat'></span><span id='topic+zeros'></span><span id='topic+ones'></span><span id='topic+mod'></span>

<h3>Description</h3>

<p><em>The various utility functions are:</em>
</p>
<p><code><a href="#topic+na_locf">na_locf</a></code> is meant as a simple replacement for zoo::na.locf
which carries the last observation forward; here we force both directions, meaning
the first observation is carried backwards as well.
</p>
<p><code><a href="#topic+vardiff">vardiff</a></code> returns the variance of the first (or second) 
difference of the series. <code><a href="#topic+varddiff">varddiff</a></code> is a convenience wrapper
to return variance for the second difference.
</p>
<p><code><a href="#topic+create_poly">create_poly</a></code> generates an x-y sequence compatible for use with <code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>
<p><code><a href="#topic+dB">dB</a></code> returns an object converted to decibels.
</p>
<p><code><a href="#topic+vector_reshape">vector_reshape</a></code> reshapes a vector into another vector.
</p>
<p><code><a href="#topic+colvec">colvec</a></code> returns the object as a vertically long vector; whereas
<code><a href="#topic+rowvec">rowvec</a></code> returns the object as a horizontally long vector.
</p>
<p><code><a href="#topic+is.spec">is.spec</a></code> and <code><a href="#topic+is.amt">is.amt</a></code> report whether an object has class <code>'spec'</code> or <code>'amt'</code>, as
would one returned by, for example, <code><a href="stats.html#topic+spectrum">spectrum</a></code> or <code><a href="#topic+psdcore">psdcore</a></code>.
</p>
<p><code><a href="#topic+is.tapers">is.tapers</a></code> reports whether an object has class <code>'tapers'</code>, as
would one returned by, for example, <code><a href="#topic+as.tapers">as.tapers</a></code>.
</p>
<p><code><a href="#topic+na_mat">na_mat</a></code> populates a matrix of specified dimensions 
with <code>NA</code> values.
</p>
<p><code><a href="#topic+zeros">zeros</a></code> populate a column-wise matrix with zeros; whereas,
<code><a href="#topic+ones">ones</a></code> populates a column-wise matrix with ones.  <em>Note that 
<code>n</code> is enforced to be at least 1 for both functions.</em>
</p>
<p><code><a href="#topic+mod">mod</a></code> finds the modulo division of two values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_locf(x)

## S3 method for class 'matrix'
na_locf(x)

## Default S3 method:
na_locf(x)

vardiff(x, double.diff = FALSE)

varddiff(x)

## S3 method for class 'spec'
varddiff(x)

## Default S3 method:
varddiff(x)

create_poly(x, y, dy, from.lower = FALSE)

dB(Rat, invert = FALSE, pos.only = TRUE, is.power = FALSE)

vector_reshape(x, vec.shape = c("horizontal", "vertical"))

colvec(x)

rowvec(x)

is.spec(Obj)

is.amt(Obj)

is.tapers(Obj)

na_mat(nrow, ncol = 1)

zeros(nrow)

ones(nrow)

mod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psd-utilities_+3A_x">x</code>, <code id="psd-utilities_+3A_y">y</code></td>
<td>
<p>objects; in <code><a href="#topic+create_poly">create_poly</a></code> these are the vectors used to
create a <code><a href="graphics.html#topic+polygon">polygon</a></code>-compatible sequence (<code>x</code> is sorted by default);
in <code><a href="#topic+mod">mod</a></code> these are the &quot;numerator&quot; and &quot;denominator&quot;, respectively.</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_double.diff">double.diff</code></td>
<td>
<p>logical; should the double difference be used instead?</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_dy">dy</code></td>
<td>
<p>numeric; the distance from <code>y</code> to the top and bottom of
the polygonal surfaces; see <code>from.lower</code></p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_from.lower">from.lower</code></td>
<td>
<p>logical; should the bottom be <code>y</code> instead of <code>y+dy</code>, so that
<code>dy</code> represents the distance from the lower surface?</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_rat">Rat</code></td>
<td>
<p>numeric; the values &ndash; ratios &ndash; to convert to decibels (<code>dB</code>).</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_invert">invert</code></td>
<td>
<p>logical; assumes <code>Rat</code> is already in decibels, so return ratio</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_pos.only">pos.only</code></td>
<td>
<p>logical; if <code>invert=FALSE</code>, sets negative or zero values to NA</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_is.power">is.power</code></td>
<td>
<p>logical; should the factor of 2 be included in the decibel calculation?</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_vec.shape">vec.shape</code></td>
<td>
<p>choice between horizontally-long or vertically-long vector.</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_obj">Obj</code></td>
<td>
<p>An object to test for class inheritance.</p>
</td></tr>
<tr><td><code id="psd-utilities_+3A_nrow">nrow</code>, <code id="psd-utilities_+3A_ncol">ncol</code></td>
<td>
<p>integer; the number of rows and/or columns to create</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decibels are defined as <code class="reqn">10 \log{}_{10} \frac{X_1}{X_2}</code>, 
unless <code>is.power=TRUE</code> in which <code class="reqn">\mathrm{db} X^2 \equiv 20 \log{}_{10} X^2</code>
</p>
<p><code>colvec, rowvec</code> are simple wrapper functions to <code>vector_reshape</code>.
</p>
<p>Modulo division has higher order-of-operations ranking than other
arithmetic operations; hence, <code>x + 1 %% y</code> is equivalent to
<code>x + (1 %% y)</code> which can produce confusing results. <code>mod</code>
is simply a series of <code>trunc</code> commands which
reduces the chance for unintentionally erroneous results.
</p>


<h3>Value</h3>

<p><code>vector_reshape</code> returns a &quot;reshaped&quot; vector, meaning it has
had it's dimensions changes so that it has either one row 
(if <code>vec.shape=="horizontal"</code>), or one column (<code>"vertical"</code>).
</p>
<p><code>is.spec</code>, <code>is.amt</code>, and <code>is.tapers</code> return the output of <code><a href="base.html#topic+inherits">inherits</a></code>.
</p>
<p><code>na_mat</code> returns a matrix of dimensions <code>(nrow,ncol)</code> with
<code>NA</code> values, the representation of which is set by <code>NA_real_</code>
</p>
<p><code>mod</code> returns the result of a modulo division, which is 
equivalent to <code>(x) %% (y)</code>.
</p>


<h3>Note</h3>

<p>The performance of <code><a href="#topic+mod">mod</a></code> has not been tested against the 
<code>%%</code> arithmetic method &ndash; it may or may not be slower for large
numeric vectors.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>References</h3>

<p>For <code><a href="#topic+mod">mod</a></code>: see Peter Dalgaard's explanation of 
the non-bug (#14771) I raised (instead I should've asked it on R-help): 
<a href="https://bugs.r-project.org/show_bug.cgi?id=14771">https://bugs.r-project.org/show_bug.cgi?id=14771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psd-package">psd-package</a></code>, <code><a href="#topic+as.tapers">as.tapers</a></code>, <code><a href="#topic+modulo_floor">modulo_floor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Various utilities
##

set.seed(1234)
X &lt;- rnorm(1e2)

#
# Matrix and vector creation:
#
# NA matrix
nd &lt;- 5
na_mat(nd)
na_mat(nd,nd-1)

# zeros
zeros(nd)

# and ones
ones(nd)

#
# Check for tapers object:
#
is.tapers(X)
is.tapers(as.tapers(X))

#
# Check for spec object:
#
PSD &lt;- spectrum(X, plot=FALSE)
plot(PSD)
# return is class 'spec'
is.spec(PSD) # TRUE
# but the underlying structure is just a list
PSD &lt;- unclass(PSD)
is.spec(PSD) # FALSE

#
# decibels
#
dB(1) # signal is equal &lt;--&gt; zero dB
sig &lt;- 1e-10
all.equal(sig, dB(dB(sig), invert=TRUE))
pow &lt;- sig**2
all.equal(pow, dB(dB(sig, is.power=TRUE), invert=TRUE, is.power=TRUE))

# 
# Variance of difference series
#
vardiff(X) # first difference
varddiff(X) # second difference
all.equal(vardiff(X, TRUE), varddiff(X))

#
# modulo division
#
x &lt;- 1:10
mc1a &lt;- mod(1,2)
mc2a &lt;- mod(1+x,2)
mc1b &lt;- 1 %% 2
mc2b &lt;- 1 + x %% 2
mc2c &lt;- (1 + x) %% 2
all.equal(mc1a, mc1b) # TRUE
all.equal(mc2a, mc2b) # "Mean absolute difference: 2"
all.equal(mc2a, mc2c) # TRUE
# on a series
modulo_floor(1:10) # defaults to 2
modulo_floor(1:10, 3)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='psdcore'>Multitaper power spectral density estimates of a series</h2><span id='topic+psdcore'></span><span id='topic+psdcore.ts'></span><span id='topic+psdcore.matrix'></span><span id='topic+psdcore.default'></span>

<h3>Description</h3>

<p>Compute power spectral density (PSD) estimates
for the input series using sine multitapers.
This is used by <code><a href="#topic+pspectrum">pspectrum</a></code> for the adaptive
estimation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdcore(X.d, ...)

## S3 method for class 'ts'
psdcore(X.d, ...)

## S3 method for class 'matrix'
psdcore(X.d, X.frq, ...)

## Default S3 method:
psdcore(
  X.d,
  X.frq = NULL,
  ntaper = as.tapers(5),
  preproc = TRUE,
  na.action = stats::na.fail,
  plot = FALSE,
  refresh = FALSE,
  verbose = FALSE,
  fast = FALSE,
  ndecimate,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdcore_+3A_x.d">X.d</code></td>
<td>
<p>the series to estimate a spectrum for</p>
</td></tr>
<tr><td><code id="psdcore_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="psdcore_+3A_x.frq">X.frq</code></td>
<td>
<p>scalar; the sampling information (see section Sampling)</p>
</td></tr>
<tr><td><code id="psdcore_+3A_ntaper">ntaper</code></td>
<td>
<p>scalar, vector, or <code><a href="#topic+tapers">tapers</a></code>; the number of sine tapers to apply at each frequency</p>
</td></tr>
<tr><td><code id="psdcore_+3A_preproc">preproc</code></td>
<td>
<p>logical; should <code>X.d</code> have a linear trend removed?</p>
</td></tr>
<tr><td><code id="psdcore_+3A_na.action">na.action</code></td>
<td>
<p>function to deal with <code>NA</code> values</p>
</td></tr>
<tr><td><code id="psdcore_+3A_plot">plot</code></td>
<td>
<p>logical; should the estimates be shown compared to the <code><a href="stats.html#topic+spectrum">spectrum</a></code>-based estimates?
Note that this will add some computation time, since the cosine-tapered periodogram is calculated inside
<code><a href="#topic+pgram_compare">pgram_compare</a></code>.</p>
</td></tr>
<tr><td><code id="psdcore_+3A_refresh">refresh</code></td>
<td>
<p>logical; ensure a free environment prior to execution</p>
</td></tr>
<tr><td><code id="psdcore_+3A_verbose">verbose</code></td>
<td>
<p>logical; should warnings and messages be given?</p>
</td></tr>
<tr><td><code id="psdcore_+3A_fast">fast</code></td>
<td>
<p>logical; use the faster method?</p>
</td></tr>
<tr><td><code id="psdcore_+3A_ndecimate">ndecimate</code></td>
<td>
<p>now ignored</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Tapering</h4>

<p>The parameter <code>ntaper</code> specifies the number of sine tapers to be used 
at each frequency: equal tapers at each frequency for a scalar; 
otherwise, use <code>ntaper[j]</code> sine tapers at <code>frequency[j]</code>.
</p>



<h4>Truncation</h4>

<p>The series, with length <code class="reqn">N</code>, is necessarily truncated so that <code class="reqn">1+N/2</code> evenly 
spaced frequencies are returned. This truncation makes the series length &ldquo;highly composite&quot;,
which the discrete Fourier transform (DFT) is most efficient.
The &quot;fftw&quot; vignette (accessed with <code>vignette("fftw",package="psd")</code>) shows
how the performance of a DFT can be affected by series length.
</p>



<h4>Decimation</h4>

<p>No longer supported. Setting <code>ndecimate</code> will not affect the results
</p>



<h4>Sampling</h4>

<p>If <code>X.frq</code> is NULL, the value is assumed to be 1, unless <code>X.d</code> is a  <code>'ts'</code> object.
If <code>X.frq &gt; 0</code> it's assumed the value represents <em>frequency</em> (e.g. Hz).
If <code>X.frq &lt; 0</code> it's assumed the value represents <em>interval</em> (e.g. seconds).
</p>



<h3>Value</h3>

<p>An on object of class <code>'amt','spec'</code>, which has a structure similar to a regular <code>'spec'</code> object, 
but with a few additional fields, invisibly.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour; original algorithm by R.L. Parker.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code>, <code><a href="#topic+riedsid">riedsid</a></code>, <code><a href="#topic+parabolic_weights">parabolic_weights</a></code>, <code><a href="#topic+pgram_compare">pgram_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Multitaper PSD estimation
##

set.seed(1234)
X &lt;- rnorm(1e3)

# use the defaults, and appeal to plot.spec
# sampling assumed to be 1
plot(psdcore(X))

# use more tapers, compare to stats::spectrum, and clear 
# env data from the previous calculation
psdcore(X, ntaper=10, plot=TRUE, refresh=TRUE)

# change the sampling frequency to 20
psdcore(X, X.frq=20, ntaper=10, plot=TRUE, refresh=TRUE)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='pspectrum'>Adaptive sine multitaper power spectral density estimation</h2><span id='topic+pspectrum'></span><span id='topic+pspectrum.ts'></span><span id='topic+pspectrum.matrix'></span><span id='topic+pspectrum.spec'></span><span id='topic+pspectrum.default'></span><span id='topic+pspectrum_basic'></span><span id='topic+adapt_message'></span>

<h3>Description</h3>

<p>This is the primary function to be used in this package: it returns
power spectral density estimates of a timeseries, with
an optimal number of tapers at each frequency based on iterative
reweighted spectral derivatives. If the object given is a multicolumn
object, the cross spectrum (multivariate PSD) will be calculated using the same
iterative procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspectrum(x, ...)

## S3 method for class 'ts'
pspectrum(x, output_column = NULL, ...)

## S3 method for class 'matrix'
pspectrum(x, x.frqsamp, ...)

## S3 method for class 'spec'
pspectrum(x, ...)

## Default S3 method:
pspectrum(
  x,
  x.frqsamp = 1,
  ntap.init = NULL,
  niter = 3,
  output_column = NULL,
  AR = FALSE,
  Nyquist.normalize = TRUE,
  verbose = TRUE,
  no.history = FALSE,
  plot = FALSE,
  ...
)

pspectrum_basic(x, ntap.init = 7, niter = 5, verbose = TRUE, ...)

adapt_message(stage, dvar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pspectrum_+3A_x">x</code></td>
<td>
<p>vector; series to find PSD estimates for; if this is a multicolumn object, a cross spectrum will
be calculated.</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="#topic+riedsid2">riedsid2</a></code></p>
</td></tr>
<tr><td><code id="pspectrum_+3A_output_column">output_column</code></td>
<td>
<p>scalar integer; If the series contains multiple columns,  specify
which column contains the output.  
The default assumes the last column is the output and the others are all inputs.</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_x.frqsamp">x.frqsamp</code></td>
<td>
<p>scalar; the sampling rate (e.g. Hz) of the series <code>x</code>; equivalent to <code><a href="stats.html#topic+frequency">frequency</a></code>.</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_ntap.init">ntap.init</code></td>
<td>
<p>scalar; the number of sine tapers to use in the pilot spectrum estimation; if <code>NULL</code> then the
default in <code><a href="#topic+pilot_spec">pilot_spec</a></code> is used.</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_niter">niter</code></td>
<td>
<p>scalar; the number of adaptive iterations to execute after the pilot spectrum is estimated.</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_ar">AR</code></td>
<td>
<p>logical; should the effects of an AR model be removed from the pilot spectrum?</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_nyquist.normalize">Nyquist.normalize</code></td>
<td>
<p>logical; should the units be returned on Hz, rather than Nyquist?</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_verbose">verbose</code></td>
<td>
<p>logical; Should messages be given?</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_no.history">no.history</code></td>
<td>
<p>logical; Should the adaptive history <em>not</em> be saved?</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_plot">plot</code></td>
<td>
<p>logical; Should the results be plotted?</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_stage">stage</code></td>
<td>
<p>integer; the current adaptive stage (0 is pilot)</p>
</td></tr>
<tr><td><code id="pspectrum_+3A_dvar">dvar</code></td>
<td>
<p>numeric; the spectral variance; see also <code><a href="#topic+vardiff">vardiff</a></code> etc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <strong>Adaptive estimation</strong> section in the description of
the <code><a href="#topic+psd-package">psd-package</a></code> for details regarding adaptive estimation.
</p>
<p>NEW as of version 2.0: use <code><a href="#topic+pspectrum">pspectrum</a></code> to calculate the
cross spectrum if <code>x</code> is a multi-column array.
</p>
<p><code><a href="#topic+pspectrum_basic">pspectrum_basic</a></code> is a simplified implementation used mainly for
testing.
</p>


<h3>Value</h3>

<p>Object with class 'spec', invisibly. It also assigns the object to
<code>"final_psd"</code> in the working environment.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour adapted original by R.L. Parker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+pilot_spec">pilot_spec</a></code>, <code><a href="#topic+riedsid2">riedsid2</a></code>, <code><a href="#topic+prewhiten">prewhiten</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)
library(RColorBrewer)

##
## Adaptive multitaper PSD estimation
## (see also the  "psd_overview"  vignette)
##

data(magnet)
Xr &lt;- magnet$raw
Xc &lt;- magnet$clean

# adaptive psd estimation (turn off diagnostic plot)
PSDr &lt;- pspectrum(Xr, plot=FALSE)
PSDc &lt;- pspectrum(Xc, plot=FALSE)

# plot them on the same scale
plot(PSDc, log="dB",
     main="Raw and cleaned Project MAGNET power spectral density estimates",
     lwd=3, ci.col=NA, ylim=c(0,32), yaxs="i")
plot(PSDr, log="dB", add=TRUE, lwd=3, lty=5)
text(c(0.25,0.34), c(11,24), c("Clean","Raw"), cex=1)

## Change sampling, and inspect the diagnostic plot
plot(pspectrum(Xc, niter=1, x.frqsamp=10, plot=TRUE))

## Say we forgot to assign the results: we can recover from the environment with:
PSDc_recovered &lt;- psd_envGet("final_psd")
plot(PSDc_recovered)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='rcpp_ctap_simple'>c++ implementation of the RLP constraint filter</h2><span id='topic+rcpp_ctap_simple'></span>

<h3>Description</h3>

<p>c++ implementation of the RLP constraint filter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_ctap_simple(tapvec, maxslope = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_ctap_simple_+3A_tapvec">tapvec</code></td>
<td>
<p>integer or <code>'tapers'</code> object; the number of tapers at each frequency</p>
</td></tr>
<tr><td><code id="rcpp_ctap_simple_+3A_maxslope">maxslope</code></td>
<td>
<p>integer; constrain based on this maximum first difference</p>
</td></tr>
</table>

<hr>
<h2 id='resample_fft_rcpp'>Resample an fft using varying numbers of sine tapers</h2><span id='topic+resample_fft_rcpp'></span>

<h3>Description</h3>

<p>Produce an un-normalized psd based on an fft and a vector of optimal sine tapers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_fft_rcpp(fftz, tapers, verbose = TRUE, dbl = TRUE, tapcap = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_fft_rcpp_+3A_fftz">fftz</code></td>
<td>
<p>complex; a vector representing the dual-length <code><a href="stats.html#topic+fft">fft</a></code>; see also the <code>dbl</code> argument</p>
</td></tr>
<tr><td><code id="resample_fft_rcpp_+3A_tapers">tapers</code></td>
<td>
<p>integer; a vector of tapers</p>
</td></tr>
<tr><td><code id="resample_fft_rcpp_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be given?</p>
</td></tr>
<tr><td><code id="resample_fft_rcpp_+3A_dbl">dbl</code></td>
<td>
<p>logical; should the code assume <code>fftz</code> is dual-length or single-length?</p>
</td></tr>
<tr><td><code id="resample_fft_rcpp_+3A_tapcap">tapcap</code></td>
<td>
<p>integer; the maximum number of tapers which can be applied; note that the length is
automatically limited by the length of the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To produce a psd estimate with our adaptive spectrum estimation method, we need only make one 
fft calculation initially and then
apply the weighting factors given by <code><a href="#topic+parabolic_weights_rcpp">parabolic_weights_rcpp</a></code>, which this
function does.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riedsid">riedsid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fftz &lt;- complex(real=1:8, imaginary = 1:8)
taps &lt;- 1:4
try(resample_fft_rcpp(fftz, taps))

</code></pre>

<hr>
<h2 id='resample_mvfft'>Resample an fft using varying numbers of sine tapers</h2><span id='topic+resample_mvfft'></span>

<h3>Description</h3>

<p>Produce an un-normalized psd based on an fft and a vector of optimal sine 
tapers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_mvfft(fftz, tapers, verbose = TRUE, dbl = TRUE, tapcap = 10000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_mvfft_+3A_fftz">fftz</code></td>
<td>
<p>complex; a matrix representing the dual-length <code><a href="stats.html#topic+fft">fft</a></code>; see also the <code>dbl</code> argument</p>
</td></tr>
<tr><td><code id="resample_mvfft_+3A_tapers">tapers</code></td>
<td>
<p>integer; a vector of tapers</p>
</td></tr>
<tr><td><code id="resample_mvfft_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be given?</p>
</td></tr>
<tr><td><code id="resample_mvfft_+3A_dbl">dbl</code></td>
<td>
<p>logical; should the code assume <code>fftz</code> is dual-length or single-length?</p>
</td></tr>
<tr><td><code id="resample_mvfft_+3A_tapcap">tapcap</code></td>
<td>
<p>integer; the maximum number of tapers which can be applied; note that the length is
automatically limited by the length of the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To produce a psd estimate with our adaptive spectrum estimation method,
we need only make one fft calculation initially and then apply the weighting
factors given by <code><a href="#topic+parabolic_weights">parabolic_weights</a></code>, which this function 
does.
</p>


<h3>Value</h3>

<p>list that includes the auto and cross-spectral density, and the
number of tapers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riedsid">riedsid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fftz &lt;- complex(real=1:8, imaginary = 1:8)
taps &lt;- 1:4
try(resample_mvfft(fftz, taps))

</code></pre>

<hr>
<h2 id='riedsid'>Constrained, optimal tapers using the Riedel &amp; Sidorenko&ndash;Parker method</h2><span id='topic+riedsid'></span><span id='topic+riedsid.spec'></span><span id='topic+riedsid.default'></span><span id='topic+riedsid2'></span><span id='topic+riedsid2.spec'></span><span id='topic+riedsid2.default'></span>

<h3>Description</h3>

<p>Estimates the optimal number of tapers at each frequency of
given PSD, using a modified Riedel-Sidorenko MSE recipe (RS-RLP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riedsid(PSD, ...)

## S3 method for class 'spec'
riedsid(PSD, ...)

## Default S3 method:
riedsid(
  PSD,
  ntaper = 1L,
  tapseq = NULL,
  Deriv.method = c("local_qls", "spg"),
  constrained = TRUE,
  c.method = NULL,
  verbose = TRUE,
  ...
)

riedsid2(PSD, ...)

## S3 method for class 'spec'
riedsid2(PSD, ...)

## Default S3 method:
riedsid2(
  PSD,
  ntaper = 1L,
  constrained = TRUE,
  verbose = TRUE,
  fast = FALSE,
  riedsid_column = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riedsid_+3A_psd">PSD</code></td>
<td>
<p>vector or class <code>'amt'</code> or <code>'spec'</code>; the spectral values used to optimize taper numbers</p>
</td></tr>
<tr><td><code id="riedsid_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="#topic+constrain_tapers">constrain_tapers</a></code></p>
</td></tr>
<tr><td><code id="riedsid_+3A_ntaper">ntaper</code></td>
<td>
<p>scalar or vector; number of tapers to apply optimization</p>
</td></tr>
<tr><td><code id="riedsid_+3A_tapseq">tapseq</code></td>
<td>
<p>vector; representing positions or frequencies (same length as <code>PSD</code>)</p>
</td></tr>
<tr><td><code id="riedsid_+3A_deriv.method">Deriv.method</code></td>
<td>
<p>character; choice of gradient estimation method</p>
</td></tr>
<tr><td><code id="riedsid_+3A_constrained">constrained</code></td>
<td>
<p>logical; apply constraints with <code><a href="#topic+constrain_tapers">constrain_tapers</a></code>; <code>FALSE</code> turns off constraints</p>
</td></tr>
<tr><td><code id="riedsid_+3A_c.method">c.method</code></td>
<td>
<p>string; constraint method to use with <code><a href="#topic+constrain_tapers">constrain_tapers</a></code>, only if <code>constrained=TRUE</code></p>
</td></tr>
<tr><td><code id="riedsid_+3A_verbose">verbose</code></td>
<td>
<p>logical; should messages be printed?</p>
</td></tr>
<tr><td><code id="riedsid_+3A_fast">fast</code></td>
<td>
<p>logical; use faster method?</p>
</td></tr>
<tr><td><code id="riedsid_+3A_riedsid_column">riedsid_column</code></td>
<td>
<p>scalar integer; which column to use in multivariate optimization. If the value is 0 the maximum number of tapers for all columns is chosen. If the value is &lt; 0 the minimum number of tapers for all columns is chosen. If the value is 1, 2, 3, etc. the number of tapers is based on the column selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimization is as follows. First, weighted derivatives of the 
input PSD are computed.
Using those derivatives the optimal number of tapers is found through the 
RS-RLP formulation.
Constraints are then placed on the practicable number of tapers.
</p>
<p><code><a href="#topic+riedsid2">riedsid2</a></code> is a new (faster) implementation which does not allow 
for multiple constraint methods; this is the preferred function to use.
</p>


<h4>Taper constraints</h4>

<p>The parameter <code>c.method</code> provides an option to change the method
of taper constraints.  A description of each may be found in 
the documentation for <code><a href="#topic+constrain_tapers">constrain_tapers</a></code>.
</p>
<p>Once can use <code>constrained=FALSE</code> to turn off all taper constraints; this
could lead to strange behavior though.
</p>



<h4>Spectral derivatives</h4>

<p>The parameter <code>Deriv.method</code> determines which method is used
to estimate derivatives.
</p>

<ul>
<li><p><code>"local_qls"</code> (<strong>default</strong>) uses quadratic weighting and
local least-squares estimation; this can be slower than <code>"spg"</code>.
</p>
</li>
<li><p><code>"spg"</code> uses <code><a href="#topic+splineGrad">splineGrad</a></code>; then, additional arguments
may be passed to control the smoothness of the derivatives
(e.g <code>spar</code> in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>).
</p>
</li></ul>




<h3>Value</h3>

<p>Object with class <code>'tapers'</code>
</p>


<h3>Warning</h3>

<p>The <code>"spg"</code> can become numerically unstable, and it's not clear when it will
be the preferred over the <code>"local_qls"</code> method, other than for efficiency's sake.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour adapted original by R.L. Parker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain_tapers">constrain_tapers</a></code>, <code><a href="#topic+resample_fft_rcpp">resample_fft_rcpp</a></code>, <code><a href="#topic+psdcore">psdcore</a></code>, <code><a href="#topic+pspectrum">pspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Riedel-Sidorenko-Parker taper optimization
##

set.seed(1234)
# some params
nd &lt;- 512 # num data
ntap &lt;- 10 # num tapers
nrm &lt;- 40 # sharpness of the peaks rel 2*variance
#
# create a pseudo spectrum
# with broad peaks
x &lt;- 0:(nd-1)
riex &lt;- rnorm(nd) + nrm*abs(cos(pi*x/180) + 1.2)
riex &lt;- riex + 8*nrm*dcauchy(x, nd/3)
riex &lt;- riex + 5*nrm*dnorm(x, nd/2)
# some flat regions
riex[riex&lt;25] &lt;- 25
ried &lt;- dB(riex, invert=TRUE)

# optimize tapers
rtap &lt;- riedsid(riex, ntaper=ntap) # deprecation warning
rtap2 &lt;- riedsid2(riex, ntaper=ntap)
rtap3 &lt;- riedsid2(riex, ntaper=ntap, fast=TRUE)

# plot
op &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1), mar=rep(1.3,4), mai=rep(0.6,4))
# ... the mock spectrum
plot(riex, type="h", xaxs="i", ylim=c(0,200), 
     main='Pseudo-spectrum') 

# ... tapers
plot(rtap2, col=NA, xaxs="i",
     main='Original and Optimized tapers', 
     ylim=c(0,max(c(ntap, rtap,rtap2,rtap3)))) 
# original tapers:
abline(h=ntap, lty=2)
# optimized tapers
lines(rtap, col="red")
# 2 and 2-fast
lines(rtap2, lwd=3, col="blue")
lines(rtap3, col="cyan")
par(op)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='riedsid_rcpp'>replaces time consuming portion of riedsid2</h2><span id='topic+riedsid_rcpp'></span>

<h3>Description</h3>

<p>replaces time consuming portion of riedsid2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riedsid_rcpp(PSD, ntaper, riedsid_column = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riedsid_rcpp_+3A_psd">PSD</code></td>
<td>
<p>vector or class <code>'amt'</code> or <code>'spec'</code>; the spectral values used to optimize taper numbers</p>
</td></tr>
<tr><td><code id="riedsid_rcpp_+3A_ntaper">ntaper</code></td>
<td>
<p>scalar or vector; number of tapers to apply optimization</p>
</td></tr>
<tr><td><code id="riedsid_rcpp_+3A_riedsid_column">riedsid_column</code></td>
<td>
<p>scalar integer; which column to use in multivariate optimization. If the value is 0 the maximum number of tapers for all columns is chosen. If the value is &lt; 0 the minimum number of tapers for all columns is chosen. If the value is 1, 2, 3, etc. the number of tapers is based on the column selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kopt vector
</p>

<hr>
<h2 id='spec_confint'>Confidence intervals for multitaper power spectral density estimates</h2><span id='topic+spec_confint'></span><span id='topic+spec_confint.spec'></span><span id='topic+spec_confint.tapers'></span><span id='topic+spec_confint.default'></span><span id='topic+.spec_confint'></span>

<h3>Description</h3>

<p>Confidence intervals for multitaper power spectral density estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_confint(x, ...)

## S3 method for class 'spec'
spec_confint(x, ...)

## S3 method for class 'tapers'
spec_confint(x, ...)

## Default S3 method:
spec_confint(x, ...)

.spec_confint(dof, p = 0.95, as.db = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_confint_+3A_x">x</code></td>
<td>
<p>object to calculate spectral properties</p>
</td></tr>
<tr><td><code id="spec_confint_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="spec_confint_+3A_dof">dof</code></td>
<td>
<p>numeric; the degrees of freedom <code class="reqn">\nu</code></p>
</td></tr>
<tr><td><code id="spec_confint_+3A_p">p</code></td>
<td>
<p>numeric; the coverage probability <code class="reqn">p</code>, bound within <code class="reqn">[0,1)</code></p>
</td></tr>
<tr><td><code id="spec_confint_+3A_as.db">as.db</code></td>
<td>
<p>logical; should the values be returned as decibels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The errors are estimated 
from the number of degrees of freedom <code class="reqn">\nu</code> by evaluating
the <code class="reqn">\chi_{p,\nu}^{2}(\nu,\nu)</code> distribution for an optional 
coverage probability <code class="reqn">p</code> (defaulting to <code class="reqn">p=0.95</code>).  
Additionally, the
<code class="reqn">p=0.5</code> values and an approximation from <code class="reqn">1/\sqrt{\nu - 1}</code>
are returned.
</p>
<p>A more 
sophisticated (and complicated) approach would be to
estimate via jack-knifing (Prieto et al 2007), but this is not yet
made available.
</p>
<p>Additive uncertainties <code class="reqn">\delta S</code> are returned, such that 
the spectrum with confidence interval is <code class="reqn">S \pm \delta S</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following properties (and names):
</p>

<ul>
<li><p><code>lower</code>: Based on upper tail probabilities (<code class="reqn">p</code>)
</p>
</li>
<li><p><code>upper</code>: Based on lower tail probabilities (<code class="reqn">1-p</code>)
</p>
</li>
<li><p><code>median</code>: Based on lower tail probabilities (<code class="reqn">p=0.5</code>)
</p>
</li>
<li><p><code>approx</code>: Approximation based on <code class="reqn">1/\sqrt(\nu - 1)</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>A.J. Barbour; some code modified from the <code>spec.ci</code> function inside <code>stats::plot.spec</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spectral_properties">spectral_properties</a></code>, <code><a href="#topic+psd-package">psd-package</a></code>, <code>stats::plot.spec</code>, <code><a href="#topic+dB">dB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Confidence intervals from taper numbers
##

sp &lt;- spectral_properties(as.tapers(1:50), p=0.95, db.ci=TRUE)

# standard errors as a function of tapers
par(las=1)
plot(stderr.chi.upper ~ taper, sp, type="s",
       ylim=c(-10,20), yaxs="i", xaxs="i",
       xlab=expression("number of tapers ("* nu/2 *")"), ylab="dB",
       main="Spectral uncertainties")
mtext("(additive factor)", line=.3)
lines(stderr.chi.lower ~ taper, sp, type="s")
lines(stderr.chi.median ~ taper, sp, type="s", lwd=2)
lines(stderr.chi.approx ~ taper, sp, type="s", col="red",lwd=2)
# indicate K needed to reach 3 dB wide confidence interval (p=.95)
abline(v=33, lty=3)
legend("topright",
        c(expression("Based on "* chi^2 *"(p,"*nu*") and (1-p,"*nu*")"),
          expression(""* chi^2 *"(p=0.5,"*nu*")"),
          "approximation"),
       lwd=c(1,3,3),
       col=c("black","black","red"),
       bg="grey98")


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='spec-methods'>Generic methods for objects with class <code>'spec'</code></h2><span id='topic+spec-methods'></span><span id='topic+lines.spec'></span><span id='topic+spec_details'></span><span id='topic+as.data.frame.spec'></span><span id='topic+as.matrix.spec'></span><span id='topic+as.list.spec'></span>

<h3>Description</h3>

<p>Generic methods for objects with class <code>'spec'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spec'
lines(x, y = NULL, type = "l", ...)

spec_details(x, ...)

## S3 method for class 'spec'
as.data.frame(x, ...)

## S3 method for class 'spec'
as.matrix(x, ...)

## S3 method for class 'spec'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec-methods_+3A_x">x</code></td>
<td>
<p>a <code>'spec'</code> object</p>
</td></tr>
<tr><td><code id="spec-methods_+3A_y">y</code></td>
<td>
<p>optional coordinate vector for the y-axis</p>
</td></tr>
<tr><td><code id="spec-methods_+3A_type">type</code></td>
<td>
<p>character; the type of plot</p>
</td></tr>
<tr><td><code id="spec-methods_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects with class <code>'spec'</code> are simply lists with spectral estimates and parameters 
<code>as.data.frame</code> converts the list into a <code>'data.frame'</code> with individual
columns for the frequency, PSD, and taper vectors; 
all other information will be retained as a list in the attributes.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Objects with class 'spec'
##

set.seed(1234)
xn &lt;- rnorm(10)
x &lt;- spectrum(xn, plot=FALSE)
xc &lt;- psdcore(xn)

xdf &lt;- as.data.frame(x)
str(xdf)
is.tapers(xdf$taper)

xdfc &lt;- as.data.frame(xc)
str(xdfc)
is.tapers(xdfc$taper)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='spectral_properties'>Calculate properties of multitaper power spectral density estimates</h2><span id='topic+spectral_properties'></span><span id='topic+spectral_properties.spec'></span><span id='topic+spectral_properties.tapers'></span><span id='topic+spectral_properties.default'></span>

<h3>Description</h3>

<p>Various spectral properties may be computed from the vector of tapers, and
if necessary the sampling frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_properties(x, ...)

## S3 method for class 'spec'
spectral_properties(x, ...)

## S3 method for class 'tapers'
spectral_properties(x, ...)

## Default S3 method:
spectral_properties(x, f.samp = 1, n.freq = NULL, p = 0.95, db.ci = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_properties_+3A_x">x</code></td>
<td>
<p>object to calculate spectral properties for; or a vector of number of tapers</p>
</td></tr>
<tr><td><code id="spectral_properties_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="spectral_properties_+3A_f.samp">f.samp</code></td>
<td>
<p>numeric; the sampling frequency (e.g. Hz) of the series the tapers are for</p>
</td></tr>
<tr><td><code id="spectral_properties_+3A_n.freq">n.freq</code></td>
<td>
<p>integer; the number of frequencies of the original spectrum 
(if <code>NULL</code> the length of the tapers object is assumed to be the number)</p>
</td></tr>
<tr><td><code id="spectral_properties_+3A_p">p</code></td>
<td>
<p>numeric; the coverage probability, bound within <code class="reqn">[0,1)</code></p>
</td></tr>
<tr><td><code id="spectral_properties_+3A_db.ci">db.ci</code></td>
<td>
<p>logical; should the uncertainty confidence intervals be returned as decibels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter Details:
</p>


<h4>Uncertainty</h4>

<p>See <code><a href="#topic+spec_confint">spec_confint</a></code> for details.
</p>



<h4>Resolution</h4>

<p>The frequency resolution depends on the number of tapers (<code class="reqn">K</code>), and
is found from 
</p>
<p style="text-align: center;"><code class="reqn">\frac{K \cdot f_N}{N_f}</code>
</p>
 
<p>where <code class="reqn">f_N</code> is the Nyquist
frequency and <code class="reqn">N_f</code> is the 
number of frequencies estimated.
</p>



<h4>Degrees of Freedom</h4>

<p>There are two degrees of freedom for each taper <code class="reqn">K</code>:
</p>
<p style="text-align: center;"><code class="reqn">\nu = 2 K</code>
</p>




<h4>Bandwidth</h4>

<p>The bandwidth of a multitaper estimate depends on the number of
tapers.
Following Walden et al (1995) the effective bandwidth is <code class="reqn">\approx 2W</code>
where
</p>
<p style="text-align: center;"><code class="reqn">W = \frac{K + 1}{2 N}</code>
</p>
 
<p>and <code class="reqn">N</code> is the number of terms in the series, which makes <code class="reqn">N \cdot W</code> the
approximate time-bandwidth product.
</p>



<h3>Value</h3>

<p>A list with the following properties (and names):
</p>

<ul>
<li><p><code>taper</code>: the number of tapers
</p>
</li>
<li><p><code>stderr.chi .upper, .lower, .median</code>: results returned from <code><a href="#topic+spec_confint">spec_confint</a></code>
</p>
</li>
<li><p><code>resolution</code>: effective spectral resolution
</p>
</li>
<li><p><code>dof</code>: degrees of freedom; will be slightly inaccurate for single-taper periodograms
</p>
</li>
<li><p><code>bw</code>: effective bandwidth of the spectrum
</p>
</li></ul>



<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spec_confint">spec_confint</a></code>, <code><a href="#topic+psd-package">psd-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Spectral properties from the number of tapers used
## (portions extracted from overview vignette)
##

#
# Theoretical uncertainties from Chi^2 distribution
#
sp &lt;- spectral_properties(as.tapers(1:50), p=0.95, db.ci=TRUE)
par(las=1)
plot(stderr.chi.upper ~ taper, sp, type="s",
       ylim=c(-10,20), yaxs="i", xaxs="i",
       xlab=expression("number of tapers ("* nu/2 *")"), ylab="dB",
       main="Spectral uncertainties")
lines(stderr.chi.lower ~ taper, sp, type="s")
lines(stderr.chi.median ~ taper, sp, type="s", lwd=2)
lines(stderr.chi.approx ~ taper, sp, type="s", col="red",lwd=2)

#
# An example using the Project MAGNET dataset
#
data(magnet)
tapinit &lt;- 15 # tapers
dt &lt;- 1 # 1/km

# remove mean/trend (not really necessary but good practice; also, done internally)
ats &lt;- prewhiten(ts(magnet$clean, deltat=dt), plot=FALSE)$prew_lm

# normal and adaptive multitaper spectra
Pspec &lt;- psdcore(ats, dt, tapinit)
Aspec &lt;- pspectrum(ats, dt, tapinit, niter=3, plot=FALSE)

# calculate spectral properties
spp &lt;- spectral_properties(Pspec$taper, db.ci=TRUE)
spa &lt;- spectral_properties(Aspec$taper, db.ci=TRUE)

# function to create polygon data, and create them
pspp &lt;- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.approx)
psppu &lt;- create_poly(Pspec$freq, dB(Pspec$spec), spp$stderr.chi.upper)
pspa &lt;- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.approx)
pspau &lt;- create_poly(Aspec$freq, dB(Aspec$spec), spa$stderr.chi.upper)

##
## Project MAGNET uncertainties
##
plot(c(0,0.5),c(-8,35),col="white",
       main="Project MAGNET Spectral Uncertainty (p &gt; 0.95)",
       ylab="", xlab="spatial frequency, 1/km", yaxt="n", frame.plot=FALSE)
lines(c(2,1,1,2)*0.01,c(5,5,8.01,8.01)-8)
text(.05, -1.4, "3.01 dB")
polygon(psppu$xx, (psppu$yy), col="light grey", border="black", lwd=0.5)
polygon(pspp$xx, (pspp$yy), col="dark grey", border=NA)
text(0.15, 6, "With adaptive\ntaper refinement", cex=1.2)
polygon(pspau$xx, (pspau$yy)-10, col="light grey", border="black", lwd=0.5)
polygon(pspa$xx, (pspa$yy)-10, col="dark grey", border=NA)
text(0.35, 22, "Uniform tapering", cex=1.2)

##
## Project MAGNET resolution
##
frq &lt;- Aspec$freq
relp &lt;- dB(1/spa$resolution)
par(las=1)
plot(frq, relp,
     col="light grey",
     ylim=dB(c(1,5)),
     type="h", xaxs="i", yaxs="i",
     ylab="dB", xlab="frequency, 1/km",
     main="Project MAGNET Spectral Resolution and Uncertainty")
lines(frq, relp)
lines(frq, spp$stderr.chi.upper+relp, lwd=1.5, lty=3)
lines(frq, spa$stderr.chi.upper+relp, lwd=3, lty=2)
abline(h=dB(sqrt(vardiff(Aspec$spec))), lwd=1.5, lty=2, col="red")

##

## End(Not run)#REX
</code></pre>

<hr>
<h2 id='splineGrad'>Numerical derivatives of a series based on its smooth-spline representation</h2><span id='topic+splineGrad'></span><span id='topic+splineGrad.default'></span>

<h3>Description</h3>

<p>This computes the numerical derivatives of a spline 
representation of the input series; differentiation of spline curves is 
numerically efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineGrad(dseq, dsig, ...)

## Default S3 method:
splineGrad(dseq, dsig, plot.derivs = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineGrad_+3A_dseq">dseq</code></td>
<td>
<p>numeric; a vector of positions for <code>dsig</code>.</p>
</td></tr>
<tr><td><code id="splineGrad_+3A_dsig">dsig</code></td>
<td>
<p>numeric; a vector of values (which will have a spline fit to them).</p>
</td></tr>
<tr><td><code id="splineGrad_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code></p>
</td></tr>
<tr><td><code id="splineGrad_+3A_plot.derivs">plot.derivs</code></td>
<td>
<p>logical; should the derivatives be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With smoothing, the numerical instability for &quot;noisy&quot; data can be drastically
reduced, since spline curves are inherently (at least) twice differentiable.
</p>


<h3>Value</h3>

<p>A matrix with columns representing <code class="reqn">x, f(x), f'(x), f''(x)</code>
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, <code><a href="#topic+constrain_tapers">constrain_tapers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Spline gradient
##

set.seed(1234)
x &lt;- seq(0,5*pi,by=pi/64)
y &lt;- cos(x) #**2

splineGrad(x, y, TRUE)

# unfortunately, the presence of
# noise will affect numerical derivatives
y &lt;- y + rnorm(length(y), sd=.1)
splineGrad(x, y, TRUE)

# so change the smoothing used in smooth.spline
splineGrad(x, y, TRUE, spar=0.2)
splineGrad(x, y, TRUE, spar=0.6)
splineGrad(x, y, TRUE, spar=1.0)


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='tapers-constraints'>Taper constraint methods</h2><span id='topic+tapers-constraints'></span><span id='topic+constrain_tapers'></span><span id='topic+constrain_tapers.tapers'></span><span id='topic+constrain_tapers.default'></span><span id='topic+minspan'></span><span id='topic+minspan.tapers'></span><span id='topic+minspan.default'></span>

<h3>Description</h3>

<p>In the Riedel-Sidorenko recipe, the number of optimal tapers
at each frequency is strongly dependent on the first and
second derivatives of the spectrum. It is crucial to enforce
constraints on the number of actual tapers applied; this is
because the derivatives of &quot;noisy&quot; series can be bogus.
</p>
<p><code><a href="#topic+constrain_tapers">constrain_tapers</a></code> refines the number of tapers at each frequency.
</p>
<p><code><a href="#topic+minspan">minspan</a></code> sets bounds on the number of tapers at each frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constrain_tapers(tapvec, ...)

## S3 method for class 'tapers'
constrain_tapers(tapvec, ...)

## Default S3 method:
constrain_tapers(
  tapvec,
  tapseq = NULL,
  constraint.method = c("simple.slope", "loess.smooth", "none"),
  verbose = TRUE,
  ...
)

minspan(tapvec, ...)

## S3 method for class 'tapers'
minspan(tapvec, ...)

## Default S3 method:
minspan(tapvec, Kmin = NULL, Kmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapers-constraints_+3A_tapvec">tapvec</code></td>
<td>
<p>integer or <code>'tapers'</code> object; the number of tapers at each frequency</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_tapseq">tapseq</code></td>
<td>
<p>numeric; positions or frequencies &ndash; necessary for smoother methods</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_constraint.method">constraint.method</code></td>
<td>
<p>character; method to use for constraints on tapers numbers</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_verbose">verbose</code></td>
<td>
<p>logical; should warnings and messages be given?</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_kmin">Kmin</code></td>
<td>
<p>numeric; the minimum to set; default is 1</p>
</td></tr>
<tr><td><code id="tapers-constraints_+3A_kmax">Kmax</code></td>
<td>
<p>numeric; the maximum to set; default is the minimum of either (7/5 max value), or (1/2 series length)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method by which <code><a href="#topic+constrain_tapers">constrain_tapers</a></code> refines tapers is 
set with the <code>constraint.method</code> argument:
</p>

<ul>
<li> <p><code>'simple.slope'</code> use <code><a href="#topic+ctap_simple">ctap_simple</a></code>
</p>
</li>
<li> <p><code>'loess.smooth'</code> uses <code><a href="#topic+ctap_loess">ctap_loess</a></code>
</p>
</li>
<li> <p><code>'none'</code> returns unbounded tapers.
</p>
</li></ul>

<p><code><a href="#topic+minspan">minspan</a></code> bounds the number of tapers to within
the minimum of either the maximum number of tapers found in the object, 
or the half-length of the series, which is necessary because 
it would be nonsense to have more tapers than the length of the series. 
</p>
<p>Details of the constraint methods:
</p>


<h4>via first differencing (the default)</h4>

<p><code><a href="#topic+ctap_simple">ctap_simple</a></code> is the preferred constraint method.
The algorithm uses first-differencing to modify the number
of tapers in the previous position.  Effectively, the constraint
is based on a causal, 1st-order Finite Impulse-response Filter (FIR) 
which makes the method sensitive to rapid changes in the number of tapers; 
naturally, smoother spectra tend to produce less fluctuation in taper numbers, 
which makes this well suited for adaptive processing. 
</p>
<p>This produces, generally, the most
stable results, meaning repeatedly running the constraint will not change values
other than on the first execution; the same cannot be said for the other
methods, which are also considerably more expensive to use.
</p>



<h4>via LOESS smoothing</h4>

<p><code><a href="#topic+ctap_loess">ctap_loess</a></code> uses <code><a href="stats.html#topic+loess">loess</a></code> to smooth the taper vector; is
can be very slow thanks to quadratic scaling.
</p>



<h3>Value</h3>

<p><code><a href="#topic+constrain_tapers">constrain_tapers</a></code>: an object with class <code>'tapers'</code>; <code><a href="#topic+minspan">minspan</a></code>: a vector
</p>


<h3>Warning</h3>

<p><code><a href="#topic+ctap_loess">ctap_loess</a></code> results tend to be strongly dependent on
the tuning parameters given to <code>loess</code> (for obvious reasons); hence, 
some effort should be given to understand their effect, and/or re-tuning them if needed.
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour and R.L. Parker
</p>


<h3>See Also</h3>

<p><code><a href="#topic+riedsid">riedsid</a></code>, <code><a href="#topic+ctap_simple">ctap_simple</a></code>, <code><a href="#topic+ctap_loess">ctap_loess</a></code>, <code><a href="#topic+tapers">tapers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: #REX
library(psd)

##
## Taper constraint procedures
##

data(magnet)
X &lt;- magnet$clean

##
## spectrum
PSD &lt;- psdcore(X, ntaper=10, refresh=TRUE)
## optimize tapers
kopt &lt;- riedsid(PSD)
kopt.loess  &lt;- riedsid(PSD, c.method="loess.smooth")
# the preferred function:
kopt2 &lt;- riedsid2(PSD)
#
plot(as.tapers(kopt2), ylim =c(0, 60))
lines(as.tapers(kopt.loess), col='black')
lines(as.tapers(kopt), col='black', lwd=2)

##
## To compare all the methods at once:
demo("ctap")


## End(Not run)#REX
</code></pre>

<hr>
<h2 id='tapers-methods'>Generic methods for objects with class <code>'tapers'</code></h2><span id='topic+tapers-methods'></span><span id='topic+as.data.frame.tapers'></span><span id='topic+data.frame.tapers'></span><span id='topic+print.tapers'></span><span id='topic+summary.tapers'></span><span id='topic+print.summary.tapers'></span><span id='topic+lines.tapers'></span><span id='topic+points.tapers'></span><span id='topic+plot.tapers'></span>

<h3>Description</h3>

<p>Generic methods for objects with class <code>'tapers'</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tapers'
as.data.frame(x, ...)

data.frame.tapers(x, ...)

## S3 method for class 'tapers'
print(x, ...)

## S3 method for class 'tapers'
summary(object, ...)

## S3 method for class 'summary.tapers'
print(x, ...)

## S3 method for class 'tapers'
lines(x, lwd = 1.8, col = "red", ...)

## S3 method for class 'tapers'
points(x, pch = "_", cex = 1, ...)

## S3 method for class 'tapers'
plot(
  x,
  xi = NULL,
  color.pal = c("Blues", "Spectral"),
  ylim = NULL,
  hv.lines = FALSE,
  log.y = FALSE,
  xlab = "taper index",
  ylab = "number of tapers",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapers-methods_+3A_x">x</code></td>
<td>
<p>tapers object</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_object">object</code></td>
<td>
<p>tapers object</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_lwd">lwd</code></td>
<td>
<p>line width (default is 1.8)</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_col">col</code></td>
<td>
<p>color of line (default is &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_pch">pch</code></td>
<td>
<p>point character (default is &quot;_&quot;)</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_cex">cex</code></td>
<td>
<p>point size (default is 1)</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_xi">xi</code></td>
<td>
<p>optional vector for indices of <code>x</code></p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_color.pal">color.pal</code></td>
<td>
<p>color palette to use (choices are: &quot;Blues&quot;,&quot;Spectral&quot;)</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_ylim">ylim</code></td>
<td>
<p>optional limits for y-axis</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_hv.lines">hv.lines</code></td>
<td>
<p>logical; should horizontal (log2) and vertical reference lines be plotted?</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_log.y">log.y</code></td>
<td>
<p>logical; should the vertical scale be logarithmic?</p>
</td></tr>
<tr><td><code id="tapers-methods_+3A_xlab">xlab</code>, <code id="tapers-methods_+3A_ylab">ylab</code></td>
<td>
<p>character; labels for plot axes</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot</code> returns a list with names: <code>line.colors</code> (hex values)
</p>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.tapers">as.tapers</a></code>, <code><a href="#topic+constrain_tapers">constrain_tapers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
tap &lt;- as.tapers(c(1:49,50:0)+rnorm(1e2))
print(tap)
print(summary(tap))
plot(tap)
# no arithmetic methods
tap &lt;- as.tapers(tap/2)
lines(tap)
</code></pre>

<hr>
<h2 id='tapers-refinement'>Taper constraints using simple derivatives</h2><span id='topic+tapers-refinement'></span><span id='topic+ctap_simple'></span><span id='topic+ctap_simple.tapers'></span><span id='topic+ctap_simple.default'></span>

<h3>Description</h3>

<p>Taper constraints using simple derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctap_simple(tapvec, ...)

## S3 method for class 'tapers'
ctap_simple(tapvec, ...)

## Default S3 method:
ctap_simple(tapvec, maxslope = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapers-refinement_+3A_tapvec">tapvec</code></td>
<td>
<p>integer or <code>'tapers'</code> object; the number of tapers at each frequency</p>
</td></tr>
<tr><td><code id="tapers-refinement_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
<tr><td><code id="tapers-refinement_+3A_maxslope">maxslope</code></td>
<td>
<p>integer; constrain based on this maximum first difference</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>A.J. Barbour
</p>


<h3>See Also</h3>

<p><code><a href="#topic+constrain_tapers">constrain_tapers</a></code>, <code><a href="#topic+ctap_loess">ctap_loess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate some random taper series and constrain them based on slopes
set.seed(1237)
n &lt;- 11
x &lt;- seq_len(n)
xn &lt;- round(runif(n,1,n))

xnf &lt;- ctap_simple(xn, 0) # flattens out
xnc &lt;- ctap_simple(xn, 1) # no change, already only slopes = 1
try(all.equal(xnc, xn))
xnc2 &lt;- ctap_simple(xn, 2) # slopes = 2 only

plot(xn, type='b', pch=16, ylim=c(0,12))
grid()
abline(a=0,b=1, col='red', lty=3); abline(a=0,b=2, col='blue', lty=3)
lines(xnf, type='b', col='green')
lines(xnc, type='b', col='red')
lines(xnc2, type='b', col='blue')
lines(0.2+as.vector(psd::ctap_simple(psd::as.tapers(xn))), type='b', pch=".", col='salmon')

# more examples:
</code></pre>

<hr>
<h2 id='Tohoku'>Observations of teleseismic strains from the 2011 Tohoku earthquake.</h2><span id='topic+Tohoku'></span>

<h3>Description</h3>

<p>The <code class="reqn">M_w 9</code> Tohoku earthquake happened on March 11, 2011.  The seismic
waves were recorded at stations across the globe, including by borehole strainmeters
in the Network of the Americas (NOTA), which was previously
known as the Plate Boundary Observatory (PBO) network.
</p>


<h3>Format</h3>

<p>A dataframe with 16000 observations on the following 15 variables.
</p>

<dl>
<dt><code>Dts</code></dt><dd><p>The original datetime string, in UTC.</p>
</dd>
<dt><code>areal</code></dt><dd><p>Areal strains</p>
</dd>
<dt><code>areal.tide</code></dt><dd><p>Tidal correction to the areal strains.</p>
</dd>
<dt><code>areal.baro</code></dt><dd><p>Barometric correction to the areal strains.</p>
</dd>
<dt><code>gamma1</code></dt><dd><p>Engineering differential extensional strain: <code class="reqn">\gamma_1</code></p>
</dd>
<dt><code>gamma1.tide</code></dt><dd><p>Tidal correction for the <code class="reqn">\gamma_1</code> strains.</p>
</dd>
<dt><code>gamma1.baro</code></dt><dd><p>Barometric pressure correction to the <code class="reqn">\gamma_1</code> strains.</p>
</dd>
<dt><code>gamma2</code></dt><dd><p>Engineering shear strain: <code class="reqn">\gamma_2</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code>gamma2.tide</code></dt><dd><p>Tidal correction for the <code class="reqn">\gamma_2</code> strains.</p>
</dd>
<dt><code>gamma2.baro</code></dt><dd><p>Barometric pressure correction to the <code class="reqn">\gamma_2</code> strains.</p>
</dd>
<dt><code>pressure.atm</code></dt><dd><p>Atmospheric pressure.</p>
</dd>
<dt><code>pressure.pore</code></dt><dd><p>Pore-fluid pressure.</p>
</dd>
<dt><code>Dt</code></dt><dd><p>The <code>Dts</code> information converted to POSIX datetime.</p>
</dd>
<dt><code>Origin.secs</code></dt><dd><p>The number of seconds relative to the earthquake-origin time.</p>
</dd>
<dt><code>epoch</code></dt><dd><p>Classification based on predicted P-wave arrival: preseismic or seismic.</p>
</dd>
</dl>

<p>and 2 attributes:
</p>

<dl>
<dt><code>units</code></dt><dd><p>A list of strings regarding the units of various physical quantities given here.</p>
</dd>
<dt><code>iasp</code></dt><dd><p>A list of source and station characteristics, including the
the origin time, predicted
traveltimes for P and S waves, and the geodetic information used in the traveltime
calculation.</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are for station B084, which is located approximately 8500 km away from
the epicenter. Because this distance is large, the seismic waves didn't arrive
at this station for more than 700 seconds after the origin time.  So there
is a record of pre-seismic noise included, the timeseries extends 6784 seconds
prior to the origin time, and 9215 seconds after.  
</p>
<p>The data are classified with the <code>"epoch"</code> variable, which separates
the series into pre-seismic and seismic data; this is defined relative
to the predicted P-wave arrival time from a traveltime model.
</p>
<p>The original dataset contained <code>NA</code> values, which were imputed
using <code>zoo::na.locf</code>, which fills <code>NA</code> with the last previous observation.
</p>


<h3>Source</h3>

<p>High frequency strain data archive:
</p>
<p><a href="http://borehole.unavco.org/bsm/earthquakes/NeartheEastCoastofHonshuJapan_20110311/">http://borehole.unavco.org/bsm/earthquakes/NeartheEastCoastofHonshuJapan_20110311/</a>
</p>


<h3>References</h3>

<p>USGS summary page:
</p>
<p><a href="https://earthquake.usgs.gov/earthquakes/eventpage/official20110311054624120_30/executive">https://earthquake.usgs.gov/earthquakes/eventpage/official20110311054624120_30/executive</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code>, <code><a href="#topic+hfsnm">hfsnm</a></code>, <code><a href="#topic+magnet">magnet</a></code>
</p>
<p><code>TauP.R</code> for an R-implementation of the traveltime calculations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Tohoku)
str(Tohoku)
</code></pre>

<hr>
<h2 id='wipp30'>Water levels from borehole WIPP30</h2><span id='topic+wipp30'></span>

<h3>Description</h3>

<p>Observed water levels and barometric pressure from
well WIPP30 (WIPP: Waste Isolation Pilot Plant)
</p>


<h3>Format</h3>

<p>A matrix with 13413 rows following 4 variables.
</p>

<dl>
<dt><code>time</code></dt><dd><p>Time (hours)</p>
</dd>
<dt><code>wl</code></dt><dd><p>Water levels (psi)</p>
</dd>
<dt><code>baro</code></dt><dd><p>Barometric pressure (psi)</p>
</dd>
<dt><code>et</code></dt><dd><p>Earth tide gravity potential (nanometers/second^2)</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is the dataset used in the multivariate PSD vignette
</p>


<h3>Source</h3>

<p>BETCO page: <a href="http://www.hydrology.uga.edu/rasmussen/betco/">http://www.hydrology.uga.edu/rasmussen/betco/</a>
</p>


<h3>References</h3>

<p>Toll, N.J., Rasmussen, T.C., (2007),
Removal of Barometric Pressure Effects and Earth Tides from Observed Water Levels.
<em>Ground Water</em>, <strong>45</strong>, 101105,
doi: 10.1111/j.1745-6584.2006.00254.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pspectrum">pspectrum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wipp30)
summary(wipp30)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
