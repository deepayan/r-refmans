<!DOCTYPE html><html lang="en"><head><title>Help for package predictmeans</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {predictmeans}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#predictmeans-package'>
<p>Predicted Means for Linear and Semiparametric Models</p></a></li>
<li><a href='#ATP'><p><code>ATP</code> containing data</p></a></li>
<li><a href='#ci_mcp'>
<p>Multiple Comparisons Based on the Confidence Intervals</p></a></li>
<li><a href='#Clinical'><p><code>Clinical</code> data</p></a></li>
<li><a href='#contrastmeans'><p>Linear Contrast Tests for a Linear Model</p></a></li>
<li><a href='#CookD'>
<p>Calculates and plots Cook's distances for a Linear (Mixed) Model</p></a></li>
<li><a href='#covariatemeans'>
<p>Predicted Means of a Linear Model with Covariate Variable(s)</p></a></li>
<li><a href='#df_term'><p>Calculate degree of freedom of a modelterm (contrast) for a lmer model</p></a></li>
<li><a href='#Drug'><p><code>Drug</code> data</p></a></li>
<li><a href='#Kmatrix'>
<p>Matrix of Coefficients in a Linear Model</p></a></li>
<li><a href='#permanova.lmer'>
<p>Permutation ANOVA for <code>lmer</code> Model</p></a></li>
<li><a href='#permindex'>
<p>Permutation Index</p></a></li>
<li><a href='#permlmer'>
<p>Permutation Test of random or fixed effects for <code>lmer</code> model.</p></a></li>
<li><a href='#permmodels'>
<p>Permutation Test of Linear Model</p></a></li>
<li><a href='#PMplot'>
<p>Level Plot of a Matrix of p-values.</p></a></li>
<li><a href='#predictmeans'>
<p>Predicted Means of a Linear Model</p></a></li>
<li><a href='#R2_glmm'>
<p>An adjusted coefficient of determination (R2) for generalized linear mixed models</p></a></li>
<li><a href='#residplot'>
<p>Diagnostic Plots for a Linear (Mixed) Model</p></a></li>
<li><a href='#se_ranef'><p>Extract Standard Errors of Model Random Effects</p></a></li>
<li><a href='#semipred'>
<p>Predicted Means of a Semi Paramatric Model with Covariate Variable(s)</p></a></li>
<li><a href='#semireg'>
<p>Fitting Semi Parametric Models Using lme4 Ecosystem</p></a></li>
<li><a href='#semireg_tmb'>
<p>Fitting Semi Parametric Models Using glmmTMB</p></a></li>
<li><a href='#smZ'>
<p>Generate Sparse Matrix Z for penalized spline smoothing</p></a></li>
<li><a href='#varcomp'>
<p>Calculate SE and CI of variance components for <code>lmer</code>, <code>glmer</code>, <code>lme</code> model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dongwen Luo [aut, cre],
  Siva Ganesh [ctb],
  John Koolaard [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dongwen Luo &lt;dongwen.luo@agresearch.co.nz&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Predicted Means for Linear and Semiparametric Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Providing functions to diagnose and make inferences from various linear models, 
    such as those obtained from 'aov', 'lm', 'glm', 'gls', 'lme', 'lmer', 'glmmTMB' and 'semireg'. 
	Inferences include predicted means and standard errors, contrasts, multiple comparisons, 
	permutation tests, adjusted R-square and graphs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), glmmTMB, lme4, nlme, lmerTest</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, ggplot2, graphics, grDevices, HRW, lmeInfo, lmeSplines,
Matrix, MASS, methods, numDeriv, parallel, pbkrtest, plotly,
plyr, reformulas, splines2, stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-29 03:55:36 UTC; luod</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=predictmeans">https://CRAN.R-project.org/package=predictmeans</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-29 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='predictmeans-package'>
Predicted Means for Linear and Semiparametric Models
</h2><span id='topic+predictmeans-package'></span>

<h3>Description</h3>

<p>This package provides functions to diagnose and make inferences from various linear models, such as those obtained from 'aov', 'lm', 'glm', 'gls', 'lme', 'lmer', 'glmmTMB' and 'semireg'. Inferences include predicted means and standard errors, contrasts, multiple comparisons, permutation tests, adjusted R-square and graphs.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> predictmeans</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-11-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>
<p>Maintainer: Dongwen Luo &lt;dongwen.luo@agresearch.co.nz&gt;
</p>


<h3>References</h3>

<p>Welham, S., Cullis, B., Gogel, B., Gilmour, A., &amp; Thompson, R. (2004),
<em>Prediction in linear mixed models</em>, Australian and New Zealand Journal of Statistics, 46(3), 325-347. 
</p>

<hr>
<h2 id='ATP'><code>ATP</code> containing data</h2><span id='topic+ATP'></span>

<h3>Description</h3>

<p><code>ATP</code> containing data from an experiment to study the effects 
of preserving liquids on the enzyme content of dog hearts. There were 23 hearts 
and two treatment factors, A and B, each at two levels. Measurements were made 
of ATP as a percentage of total enzyme in the heart, at one and two hourly
intervals during a twelve hour period following initial preservation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ATP)
</code></pre>


<h3>Format</h3>

<p><code>ATP</code> is a 230 row data frame with the following columns 
</p>

<dl>
<dt>heart</dt><dd><p>dog heart id.</p>
</dd>
<dt>time</dt><dd><p>time in hour for <code>ATP</code> measurement.</p>
</dd>
<dt>A</dt><dd><p>treatment with two levels.</p>
</dd>
<dt>B</dt><dd><p>treatment with two levels.</p>
</dd>
<dt>ATP</dt><dd><p>percentage of total enzyme in the heart.</p>
</dd>
</dl>


<hr>
<h2 id='ci_mcp'>
Multiple Comparisons Based on the Confidence Intervals
</h2><span id='topic+ci_mcp'></span>

<h3>Description</h3>

<p>This function produces letter representations for a multiple comparison test by analyzing the confidence intervals associated with the mean values of different treatments. In particular, if the confidence intervals of two treatments overlap, it indicates that there is no significant difference between them. Conversely, if the confidence intervals do not overlap, it indicates that the treatments are significantly different from each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_mcp(LL, UL, trt_n=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_mcp_+3A_ll">LL</code></td>
<td>

<p>Lower limits of treatments' confidence interval.
</p>
</td></tr>
<tr><td><code id="ci_mcp_+3A_ul">UL</code></td>
<td>

<p>Upper limits of treatments' confidence interval. 
</p>
</td></tr>
<tr><td><code id="ci_mcp_+3A_trt_n">trt_n</code></td>
<td>

<p>Treatments' names. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Vanessa, C. (05 October 2022),
<em>Confidence tricks: the 83.4% confidence interval for comparing means</em>, https://vsni.co.uk/blogs/confidence_trick. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  ci_mcp(LL=c(68.2566,  87.7566, 103.0899, 112.2566), UL=c(90.5212, 110.0212, 125.3545, 134.5212))
  
  data("Oats", package="nlme")
  Oats$nitro &lt;- factor(Oats$nitro)
  fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
  predictmeans(fm, "nitro", adj="BH", plot=FALSE)$mean_table
  predictmeans(fm, "nitro", pair=TRUE, level=0.166, letterCI = TRUE, plot=FALSE)$mean_table
</code></pre>

<hr>
<h2 id='Clinical'><code>Clinical</code> data</h2><span id='topic+Clinical'></span>

<h3>Description</h3>

<p><code>Clinical</code> data is from a multicentre randomized clinical trial (Beitler
&amp; Landis 1985, Biometrics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Clinical)
</code></pre>


<h3>Format</h3>

<p><code>Clinical</code> is a 16 row data frame with the following columns 
</p>

<dl>
<dt>Clinic</dt><dd><p>8 centres id.</p>
</dd>
<dt>Treatment</dt><dd><p>2 skin treatments (control or active drug).</p>
</dd>
<dt>Favorable</dt><dd><p>number that produced a favourable response.</p>
</dd>
<dt>Total</dt><dd><p>number of patients in each treatment group.</p>
</dd>
</dl>


<hr>
<h2 id='contrastmeans'>Linear Contrast Tests for a Linear Model</h2><span id='topic+contrastmeans'></span>

<h3>Description</h3>

<p>Performs t-tests (or permuted t-tests) of specified contrasts for linear models 
obtained from functions <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, 
or <code>lmer</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  contrastmeans(model, modelterm, ctrmatrix, ctrnames=NULL, adj="none", Df, permlist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contrastmeans_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="contrastmeans_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which factor term's contrast to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in the printed model, e.g. &quot;A&quot; or &quot;A:B&quot;. 
</p>
</td></tr>
<tr><td><code id="contrastmeans_+3A_ctrmatrix">ctrmatrix</code></td>
<td>

<p>A specified contrast matrix. If <code>ctrmatrix</code> is missing, the programe will ask user to enter it. 
</p>
</td></tr>
<tr><td><code id="contrastmeans_+3A_ctrnames">ctrnames</code></td>
<td>
<p> Names of the specified contrasts, e.g. c(&quot;A vs D&quot;, &quot;C vs B&quot;, ...) 
</p>
</td></tr>
<tr><td><code id="contrastmeans_+3A_adj">adj</code></td>
<td>
<p>   Name (in &quot;quote&quot;) for indicating a method for adjusting p-values of pairwise comparisons. 
The choices are &quot;none&quot;, &quot;tukey&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot; and &quot;fdr&quot;. 
The default method is &quot;none&quot;.
</p>
</td></tr>  
<tr><td><code id="contrastmeans_+3A_df">Df</code></td>
<td>
<p> A denominator degree of freedom for <code>modelterm</code>. (For <code>glmer</code> models 
the <code>Df</code> needs to be specified, while for the other models, <code>Df</code> is obtained from the fitted model automatically). 
</p>
</td></tr>
<tr><td><code id="contrastmeans_+3A_permlist">permlist</code></td>
<td>
<p> A model parameter list containing <code>nsim</code> parameters produced by the function <code>permmodels</code>. When <code>permlist != NULL</code>, the option <code>Df</code> will be non-functional. This is a key 
option for the permutation test. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There are two components in the output which are
</p>
<table role = "presentation">
<tr><td><code>Table</code></td>
<td>
<p>A table showing t-test results for the specified linear contrasts.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>A contrast matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Torsten Hothorn, Frank Bretz and Peter Westfall (2008),
<em>Simultaneous Inference in General Parametric Models. Biometrical</em>, Journal 50(3), 346&ndash;363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(predictmeans)
# ftable(xtabs(yield ~ Block+Variety+nitro, data=Oats))
Oats$nitro &lt;- factor(Oats$nitro)
fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# library(lme4)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)

## Not run: 
## The contrast has a contrast matrix as follows:
#     0:Golden Rain 0:Marvellous 0:Victory 
#[1,]            -1            0         1 
#[2,]             0            0         1 
#     0.2:Golden Rain 0.2:Marvellous 0.2:Victory 
#[1,]               0              0           0 
#[2,]               0              0           0 
#     0.4:Golden Rain  0.4:Marvellous 0.4:Victory
#[1,]               0               0           0
#[2,]               0              -1           0
#      0.6:Golden Rain 0.6:Marvellous 0.6:Victory
#[1,]                0              0           0
#[2,]                0              0           0

# 1. Enter above contrast matrix into a pop up window, then close the window
# contrastmeans(fm, "nitro:Variety")
 
# 2. Construct the contrast matrix directly
cm &lt;- rbind(c(-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
            c(0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0))
contrastmeans(fm, "nitro:Variety", ctrmatrix=cm)
</code></pre>

<hr>
<h2 id='CookD'>
Calculates and plots Cook's distances for a Linear (Mixed) Model
</h2><span id='topic+CookD'></span>

<h3>Description</h3>

<p>This function produces Cook's distance plots for a linear model obtained from functions <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, 
or <code>lmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CookD(model, group=NULL, plot=TRUE, idn=3, newwd=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CookD_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="CookD_+3A_group">group</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating how observations are deleted for Cook's distance calculation. If <code>group!=NULL</code> then deletions will be along levels of <code>group</code> variable, otherwise, will be along individual observations.
</p>
</td></tr>
<tr><td><code id="CookD_+3A_plot">plot</code></td>
<td>

<p>A logical variable; if it is true, a plot of Cook's distance will be presented. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="CookD_+3A_idn">idn</code></td>
<td>

<p>An integer indicating the number of top Cook's distances to be labelled in the plot. The default value is 3.
</p>
</td></tr>
<tr><td><code id="CookD_+3A_newwd">newwd</code></td>
<td>

<p>A logical variable to indicate whether to print graph in a new window. The default value is FALSE.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(predictmeans)
Oats$nitro &lt;- factor(Oats$nitro)
fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# library(lme4)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
CookD(fm)
</code></pre>

<hr>
<h2 id='covariatemeans'>
Predicted Means of a Linear Model with Covariate Variable(s)
</h2><span id='topic+covariatemeans'></span>

<h3>Description</h3>

<p>This function obtains predicted means with graph for a new set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  covariatemeans(model, modelterm=NULL, covariate, as.is=FALSE, covariateV=NULL, 
  data=NULL, level=0.05, Df=NULL, trans=NULL, transOff=0, responsen=NULL, trellis=TRUE, 
  plotord=NULL, mtitle=NULL, ci=TRUE, point=TRUE, jitterv=0, newwd=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covariatemeans_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which factor term's predicted mean to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in the printed model, e.g. &quot;A&quot; or &quot;A:B&quot;. 
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_covariate">covariate</code></td>
<td>

<p>Name (in &quot;quotes&quot;) of one the covariate variables in the <code>model</code>.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_as.is">as.is</code></td>
<td>

<p>A logic value to specify wheather or not using original covariate values' rage for graph, the default is FALSE.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_covariatev">covariateV</code></td>
<td>

<p>A numeric vector when as.is is FALSE, then covariatemeans will produce the result for <code>covariate</code> at value of <code>covariateV</code>.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_data">data</code></td>
<td>

<p>In some cases, you need to provide the data set used in model fitting, especially when you have applied some variable trnasformation in the model.</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_level">level</code></td>
<td>

<p>A significant level for calculating confident interval. The default value is 0.05.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_df">Df</code></td>
<td>

<p>A degree of freedom for calculating CI of predicted means (you can manually specified ddf here). For the above models, ddf is obtained from the function automatically.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_trans">trans</code></td>
<td>

<p>A function object for calculating the back transformed means, e.g. <code>trans=exp</code>.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_transoff">transOff</code></td>
<td>

<p>When you use <code>trans=exp(x+1)</code>, then <code>transOff=1</code>, the default is 0.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_responsen">responsen</code></td>
<td>

<p>Name (in &quot;quotes&quot;) of the back transformed response variable in the <code>model</code>.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_trellis">trellis</code></td>
<td>

<p>A logical variable. If set to TRUE (default), a trellis plots of predicted means with CI will be drawn.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_plotord">plotord</code></td>
<td>

<p>A numeric (or character) vector specifying the order of plotting for two or three way interaction (e.g. 
<code>plotord = c(2, 1, 3)</code> or <code>plotord = c("B", "A", "C")</code> will put the second variable 'B' in 
<code>modelterm</code> on the <code>X</code> axis, the first variable 'A' as the grouping variable, and the third one 
'C' as the panel variable). The defaults are <code>c(1, 2)</code> and <code>c(1, 2, 3)</code> for two and three way 
interactions. 
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_mtitle">mtitle</code></td>
<td>

<p>The main title in the graph.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_ci">ci</code></td>
<td>

<p>A logical variable to indicate whether to print confidence interval. The default value is TRUE.
</p>
</td></tr> 
<tr><td><code id="covariatemeans_+3A_point">point</code></td>
<td>

<p>A logical variable to indicate whether to print raw data points. The default value is TRUE.
</p>
</td></tr> 
<tr><td><code id="covariatemeans_+3A_jitterv">jitterv</code></td>
<td>

<p>A degree of jitter in x and y direction in the graph. The default is zero.
</p>
</td></tr>
<tr><td><code id="covariatemeans_+3A_newwd">newwd</code></td>
<td>

<p>A logical variable to indicate whether to print graph in a new window. The default value is FALSE.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Predicted Means</code></td>
<td>
<p>A table of predicted means.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  data(Oats, package="nlme")
  fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# library(lme4)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
  covariatemeans(fm, "Variety", covariate="nitro")
  covariatemeans(fm, "Variety", covariate="nitro", covariateV=seq(0, 0.6, 0.1))$pltdf
</code></pre>

<hr>
<h2 id='df_term'>Calculate degree of freedom of a modelterm (contrast) for a lmer model</h2><span id='topic+df_term'></span>

<h3>Description</h3>

<p>Calculate the degree of freedom of a modelterm (contrast) for a <code>lmer</code> model 
using &quot;Kenward-Roger&quot; or &quot;Satterthwaite&quot; method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  df_term(model, modelterm, covariate=NULL, ctrmatrix=NULL, ctrnames=NULL, 
          type=c("Kenward-Roger", "Satterthwaite"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_term_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="df_term_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which factor term's degree of freedom to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in the model formlar, e.g. &quot;A&quot; or &quot;A:B&quot;. 
</p>
</td></tr>
<tr><td><code id="df_term_+3A_covariate">covariate</code></td>
<td>

<p>Name (in &quot;quotes&quot;) of one the covariate variables in the <code>model</code>.
</p>
</td></tr>
<tr><td><code id="df_term_+3A_ctrmatrix">ctrmatrix</code></td>
<td>

<p>A specified contrast matrix. If <code>ctrmatrix</code> isn't NULL, the programe will ignore modelterm 
and calculate degree of freedom for the <code>ctrmatrix</code>. 
</p>
</td></tr>
<tr><td><code id="df_term_+3A_ctrnames">ctrnames</code></td>
<td>
<p> Names of the specified contrasts, e.g. c(&quot;A vs D&quot;, &quot;C vs B&quot;, ...) 
</p>
</td></tr>
<tr><td><code id="df_term_+3A_type">type</code></td>
<td>
<p>   Name (in &quot;quote&quot;) for indicating a method for claculating degree of freedom. 
The choices are &quot;Kenward-Roger&quot; and &quot;Satterthwaite&quot;. The default method is &quot;Kenward-Roger&quot;.
</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(predictmeans)
# ftable(xtabs(yield ~ Block+Variety+nitro, data=Oats))
Oats$nitro &lt;- factor(Oats$nitro)
fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
df_term(fm, "nitro:Variety")
## Not run: 
## The contrast has a contrast matrix as follows:
#     0:Golden Rain 0:Marvellous 0:Victory 
#[1,]            -1            0         1 
#[2,]             0            0         1 
#     0.2:Golden Rain 0.2:Marvellous 0.2:Victory 
#[1,]               0              0           0 
#[2,]               0              0           0 
#     0.4:Golden Rain  0.4:Marvellous 0.4:Victory
#[1,]               0               0           0
#[2,]               0              -1           0
#      0.6:Golden Rain 0.6:Marvellous 0.6:Victory
#[1,]                0              0           0
#[2,]                0              0           0

# 1. Enter above contrast matrix into a pop up window, then close the window
# df_term(fm, "nitro:Variety")
 
# 2. Construct the contrast matrix directly
cm &lt;- rbind(c(-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
            c(0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0))
df_term(fm, ctrmatrix=cm, type="Satterthwaite")
</code></pre>

<hr>
<h2 id='Drug'><code>Drug</code> data</h2><span id='topic+Drug'></span>

<h3>Description</h3>

<p>The data is for the comparison of the effectiveness of three analgesic drugs 
to a standard drug, morphine (Finney, Probit analysis, 3rd Edition 1971, p.103). 14 groups 
of mice were tested for response to the drugs at a range of doses. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Drug)
</code></pre>


<h3>Format</h3>

<p><code>Drug</code> is a 14 row data frame with the following columns 
</p>

<dl>
<dt>Drug</dt><dd><p>type of drug.</p>
</dd>
<dt>Dose</dt><dd><p>dose volumn.</p>
</dd>
<dt>N</dt><dd><p>total number of mice in each group.</p>
</dd>
<dt>R</dt><dd><p>number responding mice in each group.</p>
</dd>
<dt>log10Dose</dt><dd><p>log10 transformed dose volumn.</p>
</dd>
</dl>


<hr>
<h2 id='Kmatrix'>
Matrix of Coefficients in a Linear Model
</h2><span id='topic+Kmatrix'></span>

<h3>Description</h3>

<p>This function obtains a matrix of coefficients for parametric models such as <code>aov</code>, <code>lm</code>, 
<code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kmatrix(model, modelterm, covariate=NULL, covariateV=NULL, data=NULL, prtnum=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kmatrix_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>.
</p>
</td></tr>
<tr><td><code id="Kmatrix_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which model term's predicted mean to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in the printed model, e.g. &quot;A&quot; or &quot;A:B&quot;. 
</p>
</td></tr>
<tr><td><code id="Kmatrix_+3A_covariate">covariate</code></td>
<td>

<p>A numerical vector to specify values of covariates for calculating predicted means, 
default values are the means of the associated covariates. It also can be the name of one covariate in the model.
</p>
</td></tr>
<tr><td><code id="Kmatrix_+3A_covariatev">covariateV</code></td>
<td>

<p>A numeric vector or list of numeric vector, then covariatemeans will produce the result for <code>covariate</code> at value of <code>covariateV</code>.
</p>
</td></tr>
<tr><td><code id="Kmatrix_+3A_data">data</code></td>
<td>

<p>In some cases, you need to provide the data set used in model fitting, especially when you have applied some variable trnasformation in the model.</p>
</td></tr>
<tr><td><code id="Kmatrix_+3A_prtnum">prtnum</code></td>
<td>

<p>An option for printing covariate info on the screen or not. The default is FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>K</code></td>
<td>
<p>Coefficients matrix</p>
</td></tr>
<tr><td><code>fctnames</code></td>
<td>
<p>A model frame contains factor(s) info in the model.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>The name of response variable in the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>This function heavily depends on the codes from package &quot;lsmeans&quot;.
</p>


<h3>References</h3>

<p>Welham, S., Cullis, B., Gogel, B., Gilmour, A., &amp; Thompson, R. (2004),
<em>Prediction in linear mixed models</em>, Australian and New Zealand Journal of Statistics, 46(3), 325-347. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  data(Oats, package="nlme")
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
  fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
  Kmatrix(fm, "Variety", prtnum=TRUE)$K
  Kmatrix(fm, "Variety", 0.5, prtnum=TRUE)$K
 # Kmatrix(fm, "Variety", "nitro")$K
  Kmatrix(fm, "Variety", "nitro", covariateV=seq(0, 0.6, 0.1))$K
</code></pre>

<hr>
<h2 id='permanova.lmer'>
Permutation ANOVA for <code>lmer</code> Model
</h2><span id='topic+permanova.lmer'></span>

<h3>Description</h3>

<p>This function provides permutation ANOVA for <code>lmer</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permanova.lmer(model, nperm = 999, ncore=3L, type = c("I", "II", "III",  "1", "2", "3"),
 ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permanova.lmer_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="permanova.lmer_+3A_nperm">nperm</code></td>
<td>

<p>Number of permutation, the default value is 999.
</p>
</td></tr>
<tr><td><code id="permanova.lmer_+3A_ncore">ncore</code></td>
<td>

<p>Number of core for parallel computing, the default value is 3.
</p>
</td></tr>
<tr><td><code id="permanova.lmer_+3A_type">type</code></td>
<td>

<p>The type of ANOVA table requested (using SAS terminology) with Type I being the familiar 
sequential ANOVA table.
</p>
</td></tr>
<tr><td><code id="permanova.lmer_+3A_...">...</code></td>
<td>

<p>Use to setup option: seed &ndash; Specify a random number generator seed, for reproducible 
results.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Permutation ANOVA table. 
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT RUN
# library(predictmeans)
# Oats$nitro &lt;- factor(Oats$nitro) 
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
# 
# # Permutation Test for model terms
# permanova.lmer(fm)
# permanova.lmer(fm, type=2)
# 
# # Compare to F test
# fm0 &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# anova(fm0)
</code></pre>

<hr>
<h2 id='permindex'>
Permutation Index
</h2><span id='topic+permindex'></span>

<h3>Description</h3>

<p>This function obtains permutation index for a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permindex(data, block=NULL, group=NULL, nsim=4999, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permindex_+3A_data">data</code></td>
<td>

<p>Data object used in the <code>model</code> fitting.
</p>
</td></tr>
<tr><td><code id="permindex_+3A_block">block</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for the blocking factor in the <code>data</code>.
</p>
</td></tr>
<tr><td><code id="permindex_+3A_group">group</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for the group factor in the <code>data</code>.
</p>
</td></tr>
<tr><td><code id="permindex_+3A_nsim">nsim</code></td>
<td>

<p>The number of permutations. The default is 4999.  
</p>
</td></tr>
<tr><td><code id="permindex_+3A_seed">seed</code></td>
<td>

<p>Specify a random number generator seed, for reproducible results.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix has 'nsim' columns of permuted index.
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  block &lt;- rep(1:3, each=12)
  group &lt;- rep(rep(1:3, each=4), 3)
  data &lt;- data.frame(block, group)
  cbind(data, permindex(data, block="block", group="group", nsim=5))  
                        # Permute group as a whole within each block first, 
                        # then permute obs within each group.
  cbind(data, permindex(data, block="block",  nsim=5)) 
                        # Permute obs within each block only.
  cbind(data, permindex(data, group="group", nsim=5)) 
                        # Permute groups as a whole block first, 
                        # then permute obs within each group.
  cbind(data, permindex(data, nsim=5))  # Free permutation.
</code></pre>

<hr>
<h2 id='permlmer'>
Permutation Test of random or fixed effects for <code>lmer</code> model.  
</h2><span id='topic+permlmer'></span>

<h3>Description</h3>

<p>This function provides permutation tests for the terms in a linear mixed model of <code>lmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permlmer(lmer0, lmer1, nperm = 999, ncore=3, plot=FALSE, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permlmer_+3A_lmer0">lmer0</code></td>
<td>

<p><code>lmer</code> model under H0, note that <code>lmer0</code> model must nest within <code>lmer1</code> model. 
</p>
</td></tr>
<tr><td><code id="permlmer_+3A_lmer1">lmer1</code></td>
<td>

<p><code>lmer</code> model under H1, note that <code>lmer0</code> model must nest within <code>lmer1</code> model. 
</p>
</td></tr>
<tr><td><code id="permlmer_+3A_nperm">nperm</code></td>
<td>

<p>Number of permutation, the default value is 999.
</p>
</td></tr>
<tr><td><code id="permlmer_+3A_ncore">ncore</code></td>
<td>

<p>Number of core for parallel computing, the default value is 3.
</p>
</td></tr>
<tr><td><code id="permlmer_+3A_plot">plot</code></td>
<td>

<p>Plot permutation distribution or not, the default value is FALSE.
</p>
</td></tr>
<tr><td><code id="permlmer_+3A_seed">seed</code></td>
<td>

<p>Specify a random number generator seed, for reproducible results.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Permutation p-value. 
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Oliver E. Lee and Thomas M. Braun (2012),
<em>Permutation Tests for Random Effects in Linear Mixed Models. Biometrics</em>, Journal 68(2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># library(predictmeans)
## Test random effects
# fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
# fm2 &lt;- lmer(Reaction ~ Days + (Days || Subject), sleepstudy)
# fm3 &lt;- update(fm1, . ~ . - (Days | Subject) + (1 | Subject))
# anova(fm1, fm2, fm3)
# permlmer(fm3, fm2)
# permlmer(fm2, fm1)

## Test fixed effects
# Oats$nitro &lt;- factor(Oats$nitro)
# fm0 &lt;- lmer(yield ~ nitro+Variety+(1|Block/Variety), data=Oats)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
# permlmer(fm0, fm)
</code></pre>

<hr>
<h2 id='permmodels'>
Permutation Test of Linear Model 
</h2><span id='topic+permmodels'></span>

<h3>Description</h3>

<p>This function provides permutation t-tests for coefficients of (fixed) effects and permutation F-tests 
for the terms in a linear model such as <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permmodels(model, nperm=4999, type=c("I", "II", "III", 1, 2, 3), 
  test.statistic=c("Chisq", "F", "LR", "Wald"), exact=FALSE, data=NULL, 
  fo=NULL, prt=TRUE, ncore=3L, seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permmodels_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_nperm">nperm</code></td>
<td>

<p>The number of permutations. The default is 4999.  
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_type">type</code></td>
<td>

<p>type of ANOVA test, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, 1, 2, or 3. Roman numerals are equivalent to the corresponding Arabic numerals.
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_test.statistic">test.statistic</code></td>
<td>

<p>For type I ANOVA, F test is applied to all models, while for type II and III ANOVA, F test is performed for <code>lm</code>, 
Chisq test for <code>lme</code> and <code>gls</code> model, Chisq or F tests for <code>lmer</code> model and Likelihood ratio, Wald or F tests for <code>glm</code> model.
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_exact">exact</code></td>
<td>

<p>A logical variable to indicate whether or not exact no. of permutations will be used (applicable only to free the permutation case). The default is FALSE.
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_data">data</code></td>
<td>

<p>In some cases, you need to provide the data set used in model fitting, especially when you have applied some variable trnasformation in the model.</p>
</td></tr>
<tr><td><code id="permmodels_+3A_fo">fo</code></td>
<td>

<p>A model formula used in the <code>model</code>; <code>fo!=NULL</code> when the formula is specified by function <code>formula</code>.</p>
</td></tr>
<tr><td><code id="permmodels_+3A_prt">prt</code></td>
<td>

<p>A logical variable to indicate whether or not to print output on the screen. The default is TRUE.</p>
</td></tr>
<tr><td><code id="permmodels_+3A_ncore">ncore</code></td>
<td>

<p>Number of core for parallel computing, the default value is 3.
</p>
</td></tr>
<tr><td><code id="permmodels_+3A_seed">seed</code></td>
<td>

<p>Specify a random number generator seed, for reproducible results.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function produces permutation t-test table for coefficients of (fixed) effects, permutation ANOVA table for model terms and a model parameter list <code>permlist</code>, a list containing <code>nsim=4999</code> times permutation refitted <code>model</code> parameters which are used in functions <code>predictmeans</code> and <code>contrastmeans</code>. 
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'># # Not run for simplifying process of submiting pkg to CRAN
# library(predictmeans)
# Oats$nitro &lt;- factor(Oats$nitro) 
# fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# # library(lme4)
# # fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
# 
# # Permutation Test for model terms
# system.time(
#   permlme &lt;- permmodels(model=fm, nperm=999)
# )  
# 
# # Permutation Test for multiple comparisons
# predictmeans(model=fm, modelterm="nitro:Variety", atvar="Variety", adj="BH", 
#              permlist=permlme, plot=FALSE)
# 
# # Permutation Test for specified contrasts
# cm &lt;- rbind(c(-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0), 
#             c(0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0))
# contrastmeans(model=fm, modelterm="nitro:Variety", ctrmatrix=cm, permlist=permlme)
</code></pre>

<hr>
<h2 id='PMplot'>
Level Plot of a Matrix of p-values.
</h2><span id='topic+PMplot'></span>

<h3>Description</h3>

<p>Creates a plot of p-values of pairwise comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PMplot(pmatrix, level=0.05, mtitle=NULL, xylabel=NULL, margin=5, legendx=0.73, 
  newwd=FALSE)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PMplot_+3A_pmatrix">pmatrix</code></td>
<td>

<p>A matrix with p-values from pairwise comparisons. (This is a lower triangle matrix.)
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_level">level</code></td>
<td>

<p>The level of p-value to be highlighted. Default is 0.05.
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_mtitle">mtitle</code></td>
<td>

<p>The main title in the graph.
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_xylabel">xylabel</code></td>
<td>

<p>The x and y labels in the graph. 
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_margin">margin</code></td>
<td>

<p>A value for specifying x and y margins in the graph. The default value is 5.
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_legendx">legendx</code></td>
<td>

<p>A value for specifying x coordinate of legend. The default value is 0.73.
</p>
</td></tr>
<tr><td><code id="PMplot_+3A_newwd">newwd</code></td>
<td>

<p>A logical variable to indicate whether to print graph in a new window. The default is FALSE.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  set.seed(2013)
  pvalues &lt;- runif(28)
  pmatrix &lt;- matrix(0,8,8)
  pmatrix[lower.tri(pmatrix)] &lt;- pvalues
  round(pmatrix, 4)
  PMplot(pmatrix)

  Oats$nitro &lt;- factor(Oats$nitro)
  fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
  predictout &lt;- predictmeans(fm, "nitro:Variety", atvar="Variety", adj="BH", barplot=TRUE)
  PMplot(predictout$p_valueMatrix)  
</code></pre>

<hr>
<h2 id='predictmeans'>
Predicted Means of a Linear Model
</h2><span id='topic+predictmeans'></span>

<h3>Description</h3>

<p>This function obtains predicted means, SE of means, SED of means, LSDs and plots of means
with SE bar or LSD bar for parametric models such as <code>aov</code>, <code>lm</code>, 
<code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. The function also perfomrs pairwise comparisons
and permutation tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictmeans(model, modelterm, data=NULL, pairwise=FALSE, atvar=NULL, adj="none", Df=NULL,
  lsd_bar=TRUE, level=0.05, covariate=NULL, meandecr=NULL, letterCI=FALSE, trans = I,
  transOff = 0, responsen=NULL, count=FALSE, plotord=NULL, lineplot=TRUE, plottitle=NULL, 
  plotxlab=NULL, plotylab=NULL, mplot=TRUE, barplot=FALSE, pplot=TRUE, bkplot=TRUE, 
  plot=TRUE, jitterv=0.2, basesz=12L, prtnum=TRUE, prtplt=TRUE, newwd=FALSE, 
  permlist=NULL, ncore=3L, ndecimal=4L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictmeans_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which factor term's predicted mean to be calculated. 
The <code>modelterm</code> must be factors and given exactly as it appears in the printed model, e.g. &quot;A&quot; or &quot;A:B&quot;. 
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_data">data</code></td>
<td>

<p>In some cases, you need to provide the data set used in model fitting, especially when you have applied some 
variable trnasformation in the model.</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_pairwise">pairwise</code></td>
<td>

<p>An option for showing pair-wise LSDs and p-values, or not. The default is FALSE. 
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_atvar">atvar</code></td>
<td>

<p>When <code>pairwise = TRUE</code>, a quoted name indicating within levels of which variable in 
<code>modelterm</code> the multiple comparison will be performed.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_adj">adj</code></td>
<td>

<p>Name (in &quot;quote&quot;) for indicating a method for adjusting p-values of pairwise comparisons. 
The choices are &quot;none&quot;, &quot;tukey&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot; and &quot;fdr&quot;. 
The default method is &quot;none&quot;. Note that LSD can't be adjusted except for &quot;bonferroni&quot; method.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_df">Df</code></td>
<td>

<p>A degree of freedom for calculating LSD. For the above models, Df is obtained from the function automatically.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_lsd_bar">lsd_bar</code></td>
<td>

<p>A logical variable to indicate to print an average LSD or SED bar on the means plot. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_level">level</code></td>
<td>

<p>A significant level for calculating LSD, CI etc. The default value is 0.05.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_covariate">covariate</code></td>
<td>

<p>A numerical vector to specify values of covariates for calculating predicted means. The default 
values are the means of the associated covariates.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_meandecr">meandecr</code></td>
<td>

<p>A logical variable to indicate whether to print letters for multiple comparisons by decreasing order of means in the mean_table. 
The default is NULL which indicates the mean order follows the associated factor levels.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_letterci">letterCI</code></td>
<td>

<p>A logical variable to indicate printed letters for multiple comparisons by whether or not CI overlap in the mean_table. 
The default is FALSE. Note that the method of examining overlap is more conservative (i.e., rejects the null hypothesis less often) than the standard method when the null hypothesis is true.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_trans">trans</code></td>
<td>

<p>A function object for calculating the back transformed means, e.g. <code>trans=exp</code>.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_transoff">transOff</code></td>
<td>

<p>When you use <code>trans=exp(x+1)</code>, then <code>transOff=1</code>, the default is 0.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_responsen">responsen</code></td>
<td>

<p>Name (in &quot;quotes&quot;) of the back transformed response variable in the <code>model</code>.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_count">count</code></td>
<td>

<p>An option for indicating the back transformed mean values are counts or not. The default is FALSE.
</p>
</td></tr> 
<tr><td><code id="predictmeans_+3A_plotord">plotord</code></td>
<td>

<p>A numeric (or character) vector specifying the order of plotting for two or three way interaction (e.g. 
<code>plotord = c(2, 1, 3)</code> or <code>plotord = c("B", "A", "C")</code> will put the second variable 'B' in 
<code>modelterm</code> on the <code>X</code> axis, the first variable 'A' as the grouping variable, and the third one 
'C' as the panel variable). The defaults are <code>c(1, 2)</code> and <code>c(1, 2, 3)</code> for two and three way 
interactions. 
</p>
</td></tr> 
<tr><td><code id="predictmeans_+3A_lineplot">lineplot</code></td>
<td>

<p>An option for drawing a line chart, or dot chart. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_plottitle">plottitle</code></td>
<td>

<p>A character vector specifying the main title for plot(s). The default is NULL. 
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_plotxlab">plotxlab</code></td>
<td>

<p>A character vector specifying the x label for plot(s). The default is NULL. 
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_plotylab">plotylab</code></td>
<td>

<p>A character vector specifying the y label for plot(s). The default is NULL. 
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_mplot">mplot</code></td>
<td>

<p>An option for drawing a means plot, or not. The default is TRUE.
</p>
</td></tr> 
<tr><td><code id="predictmeans_+3A_barplot">barplot</code></td>
<td>

<p>An option for drawing a bar chart, or not. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_pplot">pplot</code></td>
<td>

<p>An option for drawing a p-values plot, or not when there are more than six p-values. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_bkplot">bkplot</code></td>
<td>

<p>An option for drawing back transformed plot, or not. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_plot">plot</code></td>
<td>

<p>An option for drawing plots, or not. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_jitterv">jitterv</code></td>
<td>

<p>A degree of jitter in x and y direction in the back transformed means graph. The default is zero.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_basesz">basesz</code></td>
<td>

<p>The base font size. The default is 12.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_prtnum">prtnum</code></td>
<td>

<p>An option for printing covariate information on the screen, or not. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_prtplt">prtplt</code></td>
<td>

<p>An option for printing plots on the screen, or not. The default is TRUE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_newwd">newwd</code></td>
<td>

<p>A logical variable to indicate whether to print graph in a new window. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="predictmeans_+3A_permlist">permlist</code></td>
<td>

<p>A model parameter list produced by the function <code>permmodels</code>. When <code>permlist != NULL</code>, 
the option <code>Df</code> will be non-functional. This is a key option for pairwise comparisons via 
permutation tests.
</p>
</td></tr> 
<tr><td><code id="predictmeans_+3A_ncore">ncore</code></td>
<td>

<p>Number of core for parallel computing when <code>permlist != NULL</code>, the default value is 3.
</p>
</td></tr> 
<tr><td><code id="predictmeans_+3A_ndecimal">ndecimal</code></td>
<td>

<p>An option for specifying number of decimal point to be print at predicted means table. The default is 4.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Predicted Means</code></td>
<td>
<p>A table of predicted means.</p>
</td></tr>
<tr><td><code>Standard Error of Means</code></td>
<td>
<p>A table of standard errors of predicted means.</p>
</td></tr>
<tr><td><code>Standard Error of Differences</code></td>
<td>
<p>Standard errors of differences between predicted means.</p>
</td></tr>
<tr><td><code>LSD</code></td>
<td>
<p>Least significant differences between predicted means.</p>
</td></tr>
<tr><td><code>Pairwise p-value</code></td>
<td>
<p>A matrix with t-values above the diagonal and p-values below the diagonal, or 
matrix of pairwise comparison p-values for each level of <code>atvar</code>.</p>
</td></tr>
<tr><td><code>mean_table</code></td>
<td>
<p>A summary of predicted means result including 'Predicted means', 'Standard error', 'Df' 
and 'CIs'. When <code>trans!=NULL</code> or <code>trans!=I</code>, a table of back transformed means with CIs are also shown.</p>
</td></tr>
<tr><td><code>predictmeansPlot</code></td>
<td>
<p>ggplot of predicted means.</p>
</td></tr>
<tr><td><code>predictmeansBKPlot</code></td>
<td>
<p>ggplot of back transformed means.</p>
</td></tr>
<tr><td><code>predictmeansBarPlot</code></td>
<td>
<p>gg bar plot of predicted means.</p>
</td></tr>
<tr><td><code>p_valueMatrix</code></td>
<td>
<p>p_value matrix for pairwise comparison.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>predictmeans</code> function becomes confused if a factor or covariate is changed to the other
in a model formula. Consequently, formulae that include calls <code>as.factor</code>, <code>factor</code>, or <code>numeric</code>
(e.g. <code>as.factor(income)</code>) will cause errors. Instead, create the modified variables outside of the model
formula (e.g., <code>fincome &lt;- as.factor(income)</code>) and then use them in the model formula.
</p>
<p>Factors cannot have colons in level names (e.g., <code>"level:A"</code>); the <code>predictmeans</code> function will confuse the
colons with interactions; rename levels to avoid colons.
</p>
<p>For <code>predictmeans</code> function, it is assumed that methods <code>coef</code>, <code>vcov</code>, <code>model.matrix</code>, <code>model.frame</code> and <code>terms</code> are available for <code>model</code>. 
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Maghsoodloo Saeed, Ching-Ying Huang (2010),
<em>Comparing the overlapping of two independent confidence intervals with a single confidence interval for two normal population parameters</em>, Journal of Statistical Planning and Inference, 140(11), 3295-3305. https://www.sciencedirect.com/science/article/pii/S0378375810002405. 
</p>
<p>Torsten Hothorn, Frank Bretz and Peter Westfall (2008),
<em>Simultaneous Inference in General Parametric Models. Biometrical</em>, Journal 50(3), 346-363.
</p>
<p>Welham S., Cullis B., Gogel B., Gilmour A., &amp; Thompson R. (2004),
<em>Prediction in linear mixed models</em>, Australian and New Zealand Journal of Statistics, 46(3), 325-347.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  ftable(xtabs(yield ~ Block+Variety+nitro, data=Oats))
  Oats$nitro &lt;- factor(Oats$nitro)
  fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
# fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
  predictmeans(fm, "nitro", adj="BH")
  predictmeans(fm, "nitro:Variety", atvar="Variety", adj="BH", line=FALSE)
  predictout &lt;- predictmeans(fm, "nitro:Variety", atvar="Variety", adj="BH", 
    barplot=TRUE, line=FALSE)
  names(predictout)
  print(predictout$predictmeansPlot)
  print(predictout$predictmeansBarPlot)
</code></pre>

<hr>
<h2 id='R2_glmm'>
An adjusted coefficient of determination (R2) for generalized linear mixed models
</h2><span id='topic+R2_glmm'></span>

<h3>Description</h3>

<p>This function produces adjusted R2 for generalized linear mixed models which was crafted following the guidance provided by Professor Hans-Peter Piepho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  R2_glmm(model, over_disp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_glmm_+3A_model">model</code></td>
<td>

<p>An object returned by <code>lmer</code>, <code>glmer</code> or <code>glmmTMB</code>. 
</p>
</td></tr>
<tr><td><code id="R2_glmm_+3A_over_disp">over_disp</code></td>
<td>

<p>A logical scalar to indicate whether <code>model</code> with over-dispersion or not. The default value is FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjusted R2 in percentage for Total (fixed + random), Fiexd, Random and individual random term.
</p>


<h3>References</h3>

<p>Piepho HP. An adjusted coefficient of determination (R2 ) for generalized linear mixed models in one go. Biom J. 2023 Oct;65(7):e2200290. doi: 10.1002/bimj.202200290. Epub 2023 May 1. PMID: 37127864.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(predictmeans)
  Oats$nitro &lt;- factor(Oats$nitro)
  (fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats))
  R2_glmm(fm)
  (gm &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial))
  R2_glmm(gm)		  
</code></pre>

<hr>
<h2 id='residplot'>
Diagnostic Plots for a Linear (Mixed) Model
</h2><span id='topic+residplot'></span>

<h3>Description</h3>

<p>This function produces diagnostic plots for linear models including 'aov', 'lm', 'glm', 'gls', 'lme' and 'lmer'. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  residplot(model, group = "none", level = 1, slope = FALSE, id = FALSE, newwd=FALSE,
    ask=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residplot_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>aov</code>, <code>lm</code>, <code>glm</code>, <code>gls</code>, <code>lme</code>, and <code>lmer</code>. 
</p>
</td></tr>
<tr><td><code id="residplot_+3A_group">group</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating the variable used to show grouping in the residual vs predicted plot. If variable is a term in the model, then group will be a name of the variable such as <code>group="A"</code>, otherwise group will be the actual variable such as <code>group=data$A</code>.
</p>
</td></tr>
<tr><td><code id="residplot_+3A_level">level</code></td>
<td>

<p>An integer 1, 2, etc. used to specify a level of the random effect for plotting. The default value is 1.
</p>
</td></tr>
<tr><td><code id="residplot_+3A_slope">slope</code></td>
<td>

<p>A logical variable. If set to TRUE, a Q-Q plot of random slope will be drawn.
</p>
</td></tr>
<tr><td><code id="residplot_+3A_id">id</code></td>
<td>

<p>A logical variable. If set to TRUE, outliers in the residual vs fitted plot can be identified interactively.
</p>
</td></tr>
<tr><td><code id="residplot_+3A_newwd">newwd</code></td>
<td>

<p>A logical variable to indicate whether to print graph in a new window. The default is FALSE.
</p>
</td></tr>
<tr><td><code id="residplot_+3A_ask">ask</code></td>
<td>

<p>logical. If TRUE (and the R session is interactive) the user is asked for input, before a new figure is drawn.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that the order of levels of nested random effects is oposite 
## between lme and lmer objects.

library(predictmeans)
Oats$nitro &lt;- factor(Oats$nitro)
fm &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
residplot(fm, level=2)    #lme: level=2 for random effect "Block:Variety"

#  Not Run
#  library(lme4)
#  fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
#  residplot(fm) # lmer: By default level=1 for random effect "Block:Variety"
</code></pre>

<hr>
<h2 id='se_ranef'>Extract Standard Errors of Model Random Effects</h2><span id='topic+se_ranef'></span>

<h3>Description</h3>

<p>These functions extract standard errors of model random effects
from objects returned by modeling functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  se_ranef(object, rand_term=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se_ranef_+3A_object">object</code></td>
<td>
<p>object of <code>merMod</code> and <code>glmmTMB</code> fit</p>
</td></tr>
<tr><td><code id="se_ranef_+3A_rand_term">rand_term</code></td>
<td>
<p>a name of random term in the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>se_ranef</code> extracts standard errors of the random effects
from objects returned by lmer, glmer and glmmTMB functions.
</p>


<h3>Value</h3>

<p><code>se_ranef</code> gives a list of standard errors for <code>ranef</code>.
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>This function is modified from function 'se.ranef' at package 'arm'.</p>

<hr>
<h2 id='semipred'>
Predicted Means of a Semi Paramatric Model with Covariate Variable(s)
</h2><span id='topic+semipred'></span>

<h3>Description</h3>

<p>This function produces predicted means with graph for a semi paramatric model with new set of covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  semipred(semireg, modelterm=NULL, covariate, sm_term=NULL, contr=NULL,
           covariateV=NULL, boundary=NULL, level=0.05, trans=NULL, trellis=TRUE, 
		   scales=c("fixed", "free", "free_x", "free_y"),
		   plotord=NULL, ci=TRUE, point=TRUE, jitterv=0, threeD=FALSE, prt=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="semipred_+3A_semireg">semireg</code></td>
<td>

<p>A list object returned by <code>semireg</code>. 
</p>
</td></tr>
<tr><td><code id="semipred_+3A_modelterm">modelterm</code></td>
<td>

<p>Name (in &quot;quotes&quot;) for indicating which factor term's predicted mean to be calculated. 
The <code>modelterm</code> must be given exactly as it appears in <code>semireg</code> model, e.g. &quot;A&quot; or &quot;A:B&quot;. In case <code>modelterm</code> is the same as <code>covariate</code> or <code>NULL</code>, them <code>semipred</code> will product predictmeans with CI based on <code>covariate</code> only with out any grouping.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_covariate">covariate</code></td>
<td>

<p>Name (in &quot;quotes&quot;) of one or two (for <code>Ztps</code> smooth) the covariate variables in the <code>semireg</code> shuch as &quot;x1&quot; or c(&quot;x1&quot;, &quot;x2&quot;).
</p>
</td></tr>
<tr><td><code id="semipred_+3A_sm_term">sm_term</code></td>
<td>

<p>Names (in &quot;quotes&quot;) of smooth terms (from <code>smoothZ</code> list in <code>semireg</code> model) used in the prediction such as &quot;sm1_grp&quot; or c(&quot;sm1_grp&quot;, &quot;sm2_grp&quot;). The default is using all smooth terms which is <code>sm_term=NULL</code>. 
</p>
</td></tr> 
<tr><td><code id="semipred_+3A_contr">contr</code></td>
<td>

<p>A numeric (or character) vector with length of two (e.g. c(4, 1) or c(&quot;d&quot;, &quot;a&quot;)) which indicates to produce predicted mean with CI for difference between <code>modelterm</code> level 4 (&quot;d&quot;) vs level 1 (&quot;a&quot;) along <code>covariate</code>.
</p>
</td></tr> 
<tr><td><code id="semipred_+3A_covariatev">covariateV</code></td>
<td>

<p>A numeric vector or matrix, then semipred will produce the result for <code>covariate</code> at value of <code>covariateV</code>.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_boundary">boundary</code></td>
<td>

<p>A matrix or data frame of two columns, used to specify boundary of longitude and latitude, it is functional when the length of covariate is two.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_level">level</code></td>
<td>

<p>A significant level for calculating confident interval. The default value is 0.05.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_trans">trans</code></td>
<td>

<p>A function object for calculating the back transformed means, e.g. <code>trans=exp</code>.
</p>
</td></tr>  
<tr><td><code id="semipred_+3A_trellis">trellis</code></td>
<td>

<p>A logical scalar. If set to TRUE (default), a trellis plots of predicted means with CI will be drawn.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_scales">scales</code></td>
<td>

<p>Should scales be fixed (&quot;fixed&quot;, the default), free (&quot;free&quot;), or free in one dimension (&quot;free_x&quot;, &quot;free_y&quot;) in a trellis graph?
</p>
</td></tr>
<tr><td><code id="semipred_+3A_plotord">plotord</code></td>
<td>

<p>A numeric vector specifying the order of plotting for two way interaction (e.g. 
<code>plotord = c(2, 1)</code> will put the second variable in <code>modelterm</code> on the <code>X</code> 
axis, the first variable as the grouping variable, and the third one as the panel variable). 
The defaults are <code>c(1, 2)</code> for two way interactions. 
</p>
</td></tr>
<tr><td><code id="semipred_+3A_ci">ci</code></td>
<td>

<p>A logical scalar to indicate whether to print confidence interval. The default value is TRUE.
</p>
</td></tr> 
<tr><td><code id="semipred_+3A_point">point</code></td>
<td>

<p>A logical scalar to indicate whether to print raw data points. The default value is TRUE.
</p>
</td></tr> 
<tr><td><code id="semipred_+3A_jitterv">jitterv</code></td>
<td>

<p>A degree of jitter in x and y direction in the graph. The default is zero.
</p>
</td></tr>
<tr><td><code id="semipred_+3A_threed">threeD</code></td>
<td>

<p>A logical scalar to indicate whether to produce a 3-D plot or not. The default value is FALSE.
</p>
</td></tr> 
<tr><td><code id="semipred_+3A_prt">prt</code></td>
<td>

<p>A logical scalar to indicate whether to produce plots on the screen or not. The default value is TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>plt</code></td>
<td>
<p>A ggplot object.</p>
</td></tr>
<tr><td><code>pred_df</code></td>
<td>
<p>A data.frame with predcted data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT RUN 
# library(predictmeans)
# data(Dialyzer, package="nlme")
# help(Dialyzer)
# str(Dialyzer)
# 
# library(ggplot2)
# ggplot(Dialyzer, aes(x=pressure, y=rate, col=QB)) +
#   geom_line() +
#   facet_wrap(vars(Subject))
# 
# fm &lt;- semireg(rate ~ pressure*QB+(pressure|Subject),
#               smoothZ=list(
#                 qb_grp=smZ(pressure, k=4, by=QB, group=TRUE)
#               ),
#               data=Dialyzer)
# str(fm$data)
# summary(fm$semer)
# residplot(fm$semer, group="QB")
# anova(fm$semer)
# ranova(fm$semer)
# R2_glmm(fm$semer)
# ap_out1 &lt;- semipred(fm, "QB", "pressure")
# str(ap_out1$pred_df)
# ap_out2 &lt;- semipred(fm, "QB", "pressure", contr=c(1,2))
# str(ap_out2$pred_df)
# 
# data(sleepstudy, package="lme4")
# help(sleepstudy)
# str(sleepstudy)
# library(latticeExtra)
# xyplot(Reaction ~ Days | Subject, sleepstudy, aspect = "xy",
#        layout = c(9, 2), type = c("g", "p", "r"),
#        index.cond = function(x, y) coef(lm(y ~ x))[2],
#        xlab = "Days of sleep deprivation",
#        ylab = "Average reaction time (ms)",
#        as.table = TRUE)
# 
# sleep.semi &lt;- semireg(Reaction ~ Days*Subject,
#                       smoothZ=list(
#                         sub_grp=smZ(Days, by=Subject, group=TRUE)
#                       ),
#                       data=sleepstudy)
# residplot(sleep.semi$semer)
# summary(sleep.semi$semer)
# anova(sleep.semi$semer)
# ranova(sleep.semi$semer)
# R2_glmm(sleep.semi$semer)
# 
# predout1 &lt;- semipred(sleep.semi, "Subject", "Days")
# str(predout1$pred_df)
# predout2 &lt;- semipred(sleep.semi, "Subject", "Days", contr = c(6,1))
# str(predout2$pred_df)
</code></pre>

<hr>
<h2 id='semireg'>
Fitting Semi Parametric Models Using lme4 Ecosystem
</h2><span id='topic+semireg'></span>

<h3>Description</h3>

<p>Fit a semi parametric model based on lme4 ecosystem including <code>lmer</code>, <code>glmer</code> and <code>glmer.nb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semireg(formula, data, family = NULL, ngbinomial=FALSE, REML = TRUE, 
        smoothZ = list(), ncenter=TRUE, nscale=FALSE, resp_scale=FALSE, 
        control = lmerControl(optimizer="bobyqa"), start = NULL, 
        verbose = FALSE, drop.unused.levels=TRUE, subset, weights, 
        offset, contrasts = NULL,  prt=TRUE, predict_info=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="semireg_+3A_formula">formula</code></td>
<td>

<p>A two-sided linear formula object describing both the fixed-effects and random-effects part of the model, with the response on the left of a ~ operator and the terms, separated by + operators, on the right. Random-effects terms are distinguished by vertical bars (&quot;|&quot;) separating expressions for design matrices from grouping factors.
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_data">data</code></td>
<td>

<p>A data frame or list containing the model response variable and covariates required by the formula. By default the variables are taken from environment(formula and smoothZ), typically the environment from which semireg is called.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_family">family</code></td>
<td>

<p>A GLM family, see glm and family.
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_ngbinomial">ngbinomial</code></td>
<td>

<p>Logical scalar - Should a negative binomial GLMMs be used?                  .
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_reml">REML</code></td>
<td>

<p>Logical scalar - Should the estimates be chosen to optimize the REML criterion (as opposed to the log-likelihood)?
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_smoothz">smoothZ</code></td>
<td>

<p>A list includes a set of smooth Z matrixs (called 'smooth term') used in the mixed effects model, the name of 'smooth term' should be different any variables in the model, each 'smooth term' is the result of function <code>smZ</code>. e.g.
smoothZ=list(sm1=smZ(x1), sm2=smZ(x2, by=f1), sm3=smZ(x3, by=f2, group=TRUE), ...) where 'sm1' to 'sm3' should be new variable names in the <code>data</code>, and x1 to x3 are covariates, and f1, f2 are factors.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_ncenter">ncenter</code></td>
<td>

<p>Logical scalar - Should the numeric predictors to be centered or not?
</p>
</td></tr>
<tr><td><code id="semireg_+3A_nscale">nscale</code></td>
<td>

<p>Logical scalar - Should the numeric predictors to be scaled or not?
</p>
</td></tr>
<tr><td><code id="semireg_+3A_resp_scale">resp_scale</code></td>
<td>

<p>Logical scalar - Should the response be involved in the scaling action or not?
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_control">control</code></td>
<td>

<p>A list (of correct class, resulting from lmerControl() or glmerControl() respectively) containing control parameters, including the nonlinear optimizer to be used and parameters to be passed through to the nonlinear optimizer, see the *lmerControl documentation for details.
</p>
</td></tr>	
<tr><td><code id="semireg_+3A_start">start</code></td>
<td>

<p>Starting value list as used by lmer or glmer.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_verbose">verbose</code></td>
<td>
	
<p>Passed on to fitting lme4 fitting routines.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
	
<p>By default unused levels are dropped from factors before fitting. For some smooths involving factor variables you might want to turn this off. Only do so if you know what you are doing.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_subset">subset</code></td>
<td>
	
<p>An optional expression indicating the subset of the rows of data that should be used in the fit. This can be a logical vector, or a numeric vector indicating which observation numbers are to be included, or a character vector of the row names to be included. All observations are included by default.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_weights">weights</code></td>
<td>

<p>An optional vector of ‘prior weights’ to be used in the fitting process. Should be NULL or a numeric vector.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_offset">offset</code></td>
<td>

<p>This can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See model.offset.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_contrasts">contrasts</code></td>
<td>
	
<p>An optional list. See the contrasts.arg of model.matrix.default.
</p>
</td></tr>
<tr><td><code id="semireg_+3A_prt">prt</code></td>
<td>

<p>Logical scalar - Should the info to be print on screen in the middle of the process or not?
</p>
</td></tr>
<tr><td><code id="semireg_+3A_predict_info">predict_info</code></td>
<td>

<p>Logical scalar - Should provide the info for function semipred or not?
</p>
</td></tr>
<tr><td><code id="semireg_+3A_...">...</code></td>
<td>
	
<p>Further arguments for passing on to model setup routines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A semi parametric model can be parameterized as a linear (or generalized linear) mixed model in which its random effects are smooth functions of some covariates (named ‘smooth term’). <code>semireg</code> follows the approach suggested by Wand and Ormerod (2008) and represents the 'smooth term' using O'Sullivan-type of Z. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>semer</code></td>
<td>
<p>A mer model used in the fitting.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data.frame with generated variables in the fitting.</p>
</td></tr>
<tr><td><code>fomul_vars</code></td>
<td>
<p>Name of variables in the formula of semireg model.</p>
</td></tr>
<tr><td><code>sm_vars</code></td>
<td>
<p>Name of variables in the smoothZ list.</p>
</td></tr>
<tr><td><code>smoothZ_call</code></td>
<td>
<p>A call used to produce smooth terms in the fitting.</p>
</td></tr>
<tr><td><code>knots_lst</code></td>
<td>
<p>Knots used in each smooth term in the fitting.</p>
</td></tr>
<tr><td><code>range_lst</code></td>
<td>
<p>Range of covariate used in each smooth term in the fitting.</p>
</td></tr>
<tr><td><code>cov_lst</code></td>
<td>
<p>Covariance matrix list for each smooth term.</p>
</td></tr>
<tr><td><code>u_lst</code></td>
<td>
<p>Random effects list for each smooth term.</p>
</td></tr> 
<tr><td><code>type_lst</code></td>
<td>
<p>Smooth type list of smooth terms.</p>
</td></tr> 
<tr><td><code>CovMat</code></td>
<td>
<p>Covariance matrix for all smooth terms.</p>
</td></tr>
<tr><td><code>Cov_ind</code></td>
<td>
<p>Covariance matrix index for each smooth term.</p>
</td></tr>
<tr><td><code>Cov_indN</code></td>
<td>
<p>Covariance matrix index for each smooth term when <code>group=TRUE</code> in <code>smoothZ</code> argument.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degree of freedom of all random terms.</p>
</td></tr>
<tr><td><code>lmerc</code></td>
<td>
<p>Call used in the mer model in the fitting.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Wand, M.P. and Ormerod, J.T. (2008). On semiparametric regression with O'Sullivan penalized splines. <em>Australian and New Zealand Journal of Statistics.</em> <b>50</b>, 179-198. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT RUN
# library(predictmeans)
# library(HRW) 
# data(WarsawApts)
# help(WarsawApts)
# str(WarsawApts)
# fit1 &lt;- semireg(areaPerMzloty ~ construction.date,
#                 smoothZ=list(
#                   grp=smZ(construction.date, k=25)
#                 ),
#                 data = WarsawApts)
# sp_out1 &lt;- semipred(fit1, "construction.date", "construction.date")
# 
# WarsawApts$district &lt;- factor(WarsawApts$district)
# fit2 &lt;- semireg(areaPerMzloty ~ construction.date*district, resp_scale = TRUE,
#                 smoothZ=list(group=smZ(construction.date, k=15,
#                                        by = district, group=TRUE)), 
#                 data=WarsawApts)
# sp_out2_1 &lt;- semipred(fit2, "district", "construction.date")
# sp_out2_2 &lt;- semipred(fit2, "district", "construction.date", contr=c(2,1))
# 
# data(indonRespir)
# help(indonRespir)
# str(indonRespir)
# fit3 &lt;- semireg(respirInfec ~ age+vitAdefic + female + height
#                 + stunted + visit2 + visit3 + visit4  + visit5 + visit6+(1|idnum),
#                 smoothZ=list(
#                   grp=smZ(age)
#                 ),
#                 family = binomial,
#                 data = indonRespir)
# sp_out3 &lt;- semipred(fit3, "age", "age")
# library(ggplot2)
# sp_out3$plt+
#   geom_rug(data = subset(indonRespir, respirInfec==0), sides = "b", col="deeppink") +
#   geom_rug(data = subset(indonRespir, respirInfec==1), sides = "t", col="deeppink")+
#   ylim(0, 0.2)                  
</code></pre>

<hr>
<h2 id='semireg_tmb'>
Fitting Semi Parametric Models Using glmmTMB
</h2><span id='topic+semireg_tmb'></span>

<h3>Description</h3>

<p>Fit a semi parametric model based on glmmTMB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semireg_tmb(formula, data, family = gaussian(), smoothZ = list(), ziformula = ~0, 
        dispformula = ~1, weights = NULL, offset = NULL, contrasts = NULL, na.action, 
		se = TRUE, verbose = FALSE, doFit = TRUE, control = glmmTMBControl(), 
		REML = TRUE, start = NULL, map = NULL, sparseX = NULL, prt=TRUE, 
		predict_info=TRUE)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="semireg_tmb_+3A_formula">formula</code></td>
<td>

<p>A two-sided linear formula object describing both the fixed-effects and random-effects part of the model, with the response on the left of a ~ operator and the terms, separated by + operators, on the right. Random-effects terms are distinguished by vertical bars (&quot;|&quot;) separating expressions for design matrices from grouping factors.
</p>
</td></tr>	
<tr><td><code id="semireg_tmb_+3A_data">data</code></td>
<td>
<p>data frame (tibbles are OK) containing model variables. Not required, but strongly recommended; if <code>data</code> is not specified, downstream methods such as prediction with new data (<code>predict(fitted_model, newdata = ...)</code>) will fail. If it is necessary to call <code>glmmTMB</code> with model variables taken from the environment rather than from a data frame, specifying <code>data=NULL</code> will suppress the warning message.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_family">family</code></td>
<td>
<p>a family function, a character string naming a family function, or the result of a call to a family function (variance/link function) information. See <code>family</code> for a generic discussion of families or <code>family_glmmTMB</code> for details of <code>glmmTMB</code>-specific families.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_smoothz">smoothZ</code></td>
<td>

<p>A list includes a set of smooth Z matrixs (called 'smooth term') used in the mixed effects model, the name of 'smooth term' should be different any variables in the model, each 'smooth term' is the result of function <code>smZ</code>. e.g.
smoothZ=list(sm1=smZ(x1), sm2=smZ(x2, by=f1), sm3=smZ(x3, by=f2, group=TRUE), ...) where 'sm1' to 'sm3' should be new variable names in the <code>data</code>, and x1 to x3 are covariates, and f1, f2 are factors.
</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_ziformula">ziformula</code></td>
<td>
<p>a <em>one-sided</em> (i.e., no response variable) formula for zero-inflation combining fixed and random effects: the default <code>~0</code> specifies no zero-inflation. Specifying <code>~.</code> sets the zero-inflation formula identical to the right-hand side of <code>formula</code> (i.e., the conditional effects formula); terms can also be added or subtracted. <strong>When using <code>~.</code> as the zero-inflation formula in models where the conditional effects formula contains an offset term, the offset term will automatically be dropped</strong>. The zero-inflation model uses a logit link.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_dispformula">dispformula</code></td>
<td>
<p>a <em>one-sided</em> formula for dispersion containing only fixed effects: the default <code>~1</code> specifies the standard dispersion given any family. The argument is ignored for families that do not have a dispersion parameter. For an explanation of the dispersion parameter for each family, see <code>sigma</code>. The dispersion model uses a log link. In Gaussian mixed models, <code>dispformula=~0</code> fixes the residual variance to be 0 (actually a small non-zero value), forcing variance into the random effects. The precise value can be controlled via <code>control=glmmTMBControl(zero_dispval=...)</code>; the default value is <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_weights">weights</code></td>
<td>
<p>weights, as in <code>glm</code>. Not automatically scaled to have sum 1.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_offset">offset</code></td>
<td>
<p>offset for conditional model (only).</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list, e.g., <code>list(fac1="contr.sum")</code>. See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_na.action">na.action</code></td>
<td>
<p>a function that specifies how to handle observations
containing <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables. Using <code>na.action = na.exclude</code>
will similarly drop observations with missing values while fitting the model,
but will fill in <code>NA</code> values for the predicted and residual
values for cases that were excluded during the fitting process
because of missingness.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_se">se</code></td>
<td>
<p>whether to return standard errors.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_verbose">verbose</code></td>
<td>
<p>whether progress indication should be printed to the console.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_dofit">doFit</code></td>
<td>
<p>whether to fit the full model, or (if FALSE) return the preprocessed data and parameter objects, without fitting the model.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_control">control</code></td>
<td>
<p>control parameters, see <code>glmmTMBControl</code>.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_reml">REML</code></td>
<td>
<p>whether to use REML estimation rather than maximum likelihood.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_start">start</code></td>
<td>
<p>starting values, expressed as a list with possible components <code>beta</code>, <code>betazi</code>, <code>betad</code> (fixed-effect parameters for conditional, zero-inflation, dispersion models); <code>b</code>, <code>bzi</code> (conditional modes for conditional and zero-inflation models); <code>theta</code>, <code>thetazi</code> (random-effect parameters, on the standard deviation/Cholesky scale, for conditional and z-i models); <code>psi</code> (extra family parameters, e.g., shape for Tweedie models).</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_map">map</code></td>
<td>
<p>a list specifying which parameter values should be fixed to a constant value rather than estimated. <code>map</code> should be a named list containing factors corresponding to a subset of the internal parameter names (see <code>start</code> parameter). Distinct factor values are fitted as separate parameter values, <code>NA</code> values are held fixed: e.g., <code>map=list(beta=factor(c(1,2,3,NA)))</code> would fit the first three fixed-effect parameters of the conditional model and fix the fourth parameter to its starting value. In general, users will probably want to use <code>start</code> to specify non-default starting values for fixed parameters. See <code>MakeADFun</code> for more details.</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_sparsex">sparseX</code></td>
<td>
<p>a named logical vector containing (possibly) elements named &quot;cond&quot;, &quot;zi&quot;, &quot;disp&quot; to indicate whether fixed-effect model matrices for particular model components should be generated as sparse matrices, e.g. <code>c(cond=TRUE)</code>. Default is all <code>FALSE</code></p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_prt">prt</code></td>
<td>

<p>Logical scalar - Should the info to be print on screen in the middle of the process or not?
</p>
</td></tr>
<tr><td><code id="semireg_tmb_+3A_predict_info">predict_info</code></td>
<td>

<p>Logical scalar - Should provide the info for function semipred or not? In case of there is a correlation theta parameter appearing, you may set predict=FALSE.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A semi parametric model can be parameterized as a linear (or generalized linear) mixed model in which its random effects are smooth functions of some covariates (named ‘smooth term’). <code>semireg_tmb</code> follows the approach suggested by Wand and Ormerod (2008) and represents the 'smooth term' using O'Sullivan-type of Z. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>semer</code></td>
<td>
<p>A glmmTMB model used in the fitting.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>A data.frame with generated variables in the fitting.</p>
</td></tr>
<tr><td><code>fomul_vars</code></td>
<td>
<p>Name of variables in the formula of semireg_tmb model.</p>
</td></tr>
<tr><td><code>sm_vars</code></td>
<td>
<p>Name of variables in the smoothZ list.</p>
</td></tr>
<tr><td><code>smoothZ_call</code></td>
<td>
<p>A call used to produce smooth terms in the fitting.</p>
</td></tr>
<tr><td><code>knots_lst</code></td>
<td>
<p>Knots used in each smooth term in the fitting.</p>
</td></tr>
<tr><td><code>range_lst</code></td>
<td>
<p>Range of covariate used in each smooth term in the fitting.</p>
</td></tr>
<tr><td><code>cov_lst</code></td>
<td>
<p>Covariance matrix list for each smooth term.</p>
</td></tr>
<tr><td><code>u_lst</code></td>
<td>
<p>Random effects list for each smooth term.</p>
</td></tr> 
<tr><td><code>type_lst</code></td>
<td>
<p>Smooth type list of smooth terms.</p>
</td></tr> 
<tr><td><code>CovMat</code></td>
<td>
<p>Covariance matrix for all smooth terms.</p>
</td></tr>
<tr><td><code>Cov_ind</code></td>
<td>
<p>Covariance matrix index for each smooth term.</p>
</td></tr>
<tr><td><code>Cov_indN</code></td>
<td>
<p>Covariance matrix index for each smooth term when <code>group=TRUE</code> in <code>smoothZ</code> argument.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degree of freedom of all random terms.</p>
</td></tr>
<tr><td><code>tmbf</code></td>
<td>
<p>The glmmTMB model result using doFit=FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>Wand, M.P. and Ormerod, J.T. (2008). On semiparametric regression with O'Sullivan penalized splines. <em>Australian and New Zealand Journal of Statistics.</em> <b>50</b>, 179-198. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT RUN
# library(predictmeans)
# library(HRW) 
# data(WarsawApts)
# help(WarsawApts)
# str(WarsawApts)
# fit1 &lt;- semireg_tmb(areaPerMzloty ~ construction.date,
#                     smoothZ=list(
#                       grp=smZ(construction.date, k=25)
#                     ),
#                     data = WarsawApts)
# sp_out1 &lt;- semipred(fit1, "construction.date", "construction.date")
# 
# WarsawApts$district &lt;- factor(WarsawApts$district)
# fit2 &lt;- semireg_tmb(areaPerMzloty ~ construction.date*district, resp_scale = TRUE,
#                     smoothZ=list(group=smZ(construction.date, k=15,
#                                            by = district, group=TRUE)), 
#                     data=WarsawApts)
# sp_out2_1 &lt;- semipred(fit2, "district", "construction.date")
# sp_out2_2 &lt;- semipred(fit2, "district", "construction.date", contr=c(2,1))
# 
# data(indonRespir)
# help(indonRespir)
# str(indonRespir)
# fit3 &lt;- semireg_tmb(respirInfec ~ age+vitAdefic + female + height
#                     + stunted + visit2 + visit3 + visit4  + visit5 + visit6+(1|idnum),
#                     smoothZ=list(
#                       grp=smZ(age)
#                     ),
#                     family = binomial,
#                     data = indonRespir)
# sp_out3 &lt;- semipred(fit3, "age", "age")
# library(ggplot2)
# sp_out3$plt+
#   geom_rug(data = subset(indonRespir, respirInfec==0), sides = "b", col="deeppink") +
#   geom_rug(data = subset(indonRespir, respirInfec==1), sides = "t", col="deeppink")+
#   ylim(0, 0.2)  
</code></pre>

<hr>
<h2 id='smZ'>
Generate Sparse Matrix Z for penalized spline smoothing
</h2><span id='topic+smZ'></span>

<h3>Description</h3>

<p>Constructs a sparse matrix (Z) of a spline function with for a covariate with(out) group. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smZ(x, k=6, intKnots=NULL, range.x=NULL, degree=3, 
    type=c("ZOSull", "Ztps", "ns", "bs", "bernstein", "bSpline",
         "nSpline", "cSpline", "iSpline", "mSpline", "smspline"), 
    by=NULL, group=FALSE, intercept=FALSE, pred=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

	
<table role = "presentation">
<tr><td><code id="smZ_+3A_x">x</code></td>
<td>
<p>x covariate for the smooth function. Missing values are allowed and will be returned as they are.</p>
</td></tr>
<tr><td><code id="smZ_+3A_k">k</code></td>
<td>
<p>Degree of freedom that equals to the column number of the returned matrix. One can specify df rather than knots, then the function chooses df - degree - as.integer(intercept) internal knots at suitable quantiles of x ignoring missing values and those x outside of the boundary. If internal knots are specified via knots, the specified df will be ignored.</p>
</td></tr>
<tr><td><code id="smZ_+3A_intknots">intKnots</code></td>
<td>
<p>Ordered array of length smaller than that of x and consisting of unique numbers between min(x) and max(x) that specifies the positions of internal knots, that define the spline basis (see the Wand and Ormerod (2008) reference below for full mathematical details).</p>
</td></tr>
<tr><td><code id="smZ_+3A_range.x">range.x</code></td>
<td>
<p>Array of length 2 such that range.x[1] &gt;= min(x) and range.x[2] &lt;= max(x).</p>
</td></tr>
<tr><td><code id="smZ_+3A_degree">degree</code></td>
<td>
<p>Integer: degree of (truncated) polynomial.</p>
</td></tr>
<tr><td><code id="smZ_+3A_type">type</code></td>
<td>
<p>Type of splines including &quot;ZOSull&quot;, &quot;Ztps&quot;, &quot;ns&quot;, &quot;bs&quot;, &quot;bernstein&quot;, &quot;bSpline&quot;, &quot;nSpline&quot;, &quot;cSpline&quot;, &quot;iSpline&quot;, &quot;mSpline&quot; and &quot;smspline&quot;, the default is &quot;ZOSull&quot;.</p>
</td></tr>
<tr><td><code id="smZ_+3A_by">by</code></td>
<td>
<p>Factor for group wise splines.</p>
</td></tr>
<tr><td><code id="smZ_+3A_group">group</code></td>
<td>
<p>When <code>by != NULL</code>, producing group wise splines with radom effects separately.</p>
</td></tr>
<tr><td><code id="smZ_+3A_intercept">intercept</code></td>
<td>
<p>If TRUE, all of the spline basis functions are returned. Notice that when using I-Spline for monotonic regression, intercept = TRUE should be set even when an intercept term is considered additional to the spline basis functions.</p>
</td></tr>
<tr><td><code id="smZ_+3A_pred">pred</code></td>
<td>
<p>If TRUE, the function <code>smZ</code> will be applied for prediction purpose, this option mainly used by function <code>semipred</code> internally.</p>
</td></tr>
<tr><td><code id="smZ_+3A_...">...</code></td>
<td>
<p>Further arguments for passing on to model setup routines, such as
drv: either 0,1 or 2 with a default value of 0. If drv = 1 then the first derivatives of the O'Sullivan spline basis functions are computed instead. Similarly, if drv = 2 then the second derivatives are computed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Z</code></td>
<td>
<p>A (or a list of) spline design matrix used in the list <code>smoothZ</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>References</h3>

<p>O'Sullivan, F. (1986). A statistical perspective on ill-posed inverse problems (with discussion). <em>Statistical Science</em>, <b>1</b>, 505-527.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq.int(0, 1, by = 0.01)
knots &lt;- c(0.3, 0.5, 0.6)

zosuMat &lt;- smZ(x, intKnots = knots)
bsMat &lt;- smZ(x, intKnots = knots, degree = 2, type="bs")
isMat &lt;- smZ(x, intKnots = knots, degree = 2, type="iSpline")

splst &lt;- list(zosuMat, bsMat, isMat)
for (i in splst) {
op &lt;- par(mar = c(2.5, 2.5, 0.2, 0.1), mgp = c(1.5, 0.5, 0))
matplot(x, i, type = "l", ylab = "I-spline basis")
abline(v = knots, lty = 2, col = "gray")
## reset to previous plotting settings
par(op)
}

f &lt;- gl(4, 25, length=length(x))
zosuMat_by &lt;- smZ(x, intKnots = knots, by=f) # one sparse matrix
str(zosuMat_by)

zosuMat_by &lt;- smZ(x, intKnots = knots, by=f, group=TRUE) # a list of sparse matrix
str(zosuMat_by)
</code></pre>

<hr>
<h2 id='varcomp'>
Calculate SE and CI of variance components for <code>lmer</code>, <code>glmer</code>, <code>lme</code> model
</h2><span id='topic+varcomp'></span>

<h3>Description</h3>

<p>This function calculates SE and CI of variance components for <code>lmer</code>, <code>glmer</code>, <code>lme</code>, <code>glmmTMB</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcomp(model, ci=TRUE, level=0.95) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varcomp_+3A_model">model</code></td>
<td>

<p>Model object returned by <code>lmer</code>, <code>glmer</code>, <code>lme</code>, <code>glmmTMB</code>. 
</p>
</td></tr>
<tr><td><code id="varcomp_+3A_ci">ci</code></td>
<td>

<p>a logical value to indicates wheather or not to simulate a confidence interval for <code>lmer</code> model, the default value is TRUE.
</p>
</td></tr>
<tr><td><code id="varcomp_+3A_level">level</code></td>
<td>

<p>level of confidence of CI, the default value is 0.95.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance components table. 
</p>


<h3>Author(s)</h3>

<p>Dongwen Luo, Siva Ganesh and John Koolaard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(predictmeans)
Oats$nitro &lt;- factor(Oats$nitro) 
fm &lt;- lmer(yield ~ nitro*Variety+(1|Block/Variety), data=Oats)
## Not run: varcomp(fm)
fm1 &lt;- lme(yield ~ nitro*Variety, random=~1|Block/Variety, data=Oats)
varcomp(fm1)

data(Orthodont, package="nlme")
mod &lt;- lmer(distance ~ age + (age|Subject), data=Orthodont)
## Not run: varcomp(mod)
mod1 &lt;- lme(distance ~ age, random=~age|Subject, data=Orthodont)
varcomp(mod1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
