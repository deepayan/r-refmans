<!DOCTYPE html><html><head><title>Help for package mlpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlpack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlpack'><p>mlpack</p></a></li>
<li><a href='#adaboost'><p>AdaBoost</p></a></li>
<li><a href='#approx_kfn'><p>Approximate furthest neighbor search</p></a></li>
<li><a href='#bayesian_linear_regression'><p>BayesianLinearRegression</p></a></li>
<li><a href='#cf'><p>Collaborative Filtering</p></a></li>
<li><a href='#dbscan'><p>DBSCAN clustering</p></a></li>
<li><a href='#decision_tree'><p>Decision tree</p></a></li>
<li><a href='#det'><p>Density Estimation With Density Estimation Trees</p></a></li>
<li><a href='#emst'><p>Fast Euclidean Minimum Spanning Tree</p></a></li>
<li><a href='#fastmks'><p>FastMKS (Fast Max-Kernel Search)</p></a></li>
<li><a href='#gmm_generate'><p>GMM Sample Generator</p></a></li>
<li><a href='#gmm_probability'><p>GMM Probability Calculator</p></a></li>
<li><a href='#gmm_train'><p>Gaussian Mixture Model (GMM) Training</p></a></li>
<li><a href='#hmm_generate'><p>Hidden Markov Model (HMM) Sequence Generator</p></a></li>
<li><a href='#hmm_loglik'><p>Hidden Markov Model (HMM) Sequence Log-Likelihood</p></a></li>
<li><a href='#hmm_train'><p>Hidden Markov Model (HMM) Training</p></a></li>
<li><a href='#hmm_viterbi'><p>Hidden Markov Model (HMM) Viterbi State Prediction</p></a></li>
<li><a href='#hoeffding_tree'><p>Hoeffding trees</p></a></li>
<li><a href='#image_converter'><p>Image Converter</p></a></li>
<li><a href='#kde'><p>Kernel Density Estimation</p></a></li>
<li><a href='#kernel_pca'><p>Kernel Principal Components Analysis</p></a></li>
<li><a href='#kfn'><p>k-Furthest-Neighbors Search</p></a></li>
<li><a href='#kmeans'><p>K-Means Clustering</p></a></li>
<li><a href='#knn'><p>k-Nearest-Neighbors Search</p></a></li>
<li><a href='#krann'><p>K-Rank-Approximate-Nearest-Neighbors (kRANN)</p></a></li>
<li><a href='#lars'><p>LARS</p></a></li>
<li><a href='#linear_regression'><p>Simple Linear Regression and Prediction</p></a></li>
<li><a href='#linear_svm'><p>Linear SVM is an L2-regularized support vector machine.</p></a></li>
<li><a href='#lmnn'><p>Large Margin Nearest Neighbors (LMNN)</p></a></li>
<li><a href='#local_coordinate_coding'><p>Local Coordinate Coding</p></a></li>
<li><a href='#logistic_regression'><p>L2-regularized Logistic Regression and Prediction</p></a></li>
<li><a href='#lsh'><p>K-Approximate-Nearest-Neighbor Search with LSH</p></a></li>
<li><a href='#mean_shift'><p>Mean Shift Clustering</p></a></li>
<li><a href='#nbc'><p>Parametric Naive Bayes Classifier</p></a></li>
<li><a href='#nca'><p>Neighborhood Components Analysis (NCA)</p></a></li>
<li><a href='#nmf'><p>Non-negative Matrix Factorization</p></a></li>
<li><a href='#pca'><p>Principal Components Analysis</p></a></li>
<li><a href='#perceptron'><p>Perceptron</p></a></li>
<li><a href='#preprocess_binarize'><p>Binarize Data</p></a></li>
<li><a href='#preprocess_describe'><p>Descriptive Statistics</p></a></li>
<li><a href='#preprocess_one_hot_encoding'><p>One Hot Encoding</p></a></li>
<li><a href='#preprocess_scale'><p>Scale Data</p></a></li>
<li><a href='#preprocess_split'><p>Split Data</p></a></li>
<li><a href='#radical'><p>RADICAL</p></a></li>
<li><a href='#random_forest'><p>Random forests</p></a></li>
<li><a href='#Serialize'><p>Serialize/Unserialize an mlpack model.</p></a></li>
<li><a href='#softmax_regression'><p>Softmax Regression</p></a></li>
<li><a href='#sparse_coding'><p>Sparse Coding</p></a></li>
<li><a href='#test_r_binding'><p>R binding test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>'Rcpp' Integration for the 'mlpack' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>4.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast, flexible machine learning library, written in C++, that
             aims to provide fast, extensible implementations of cutting-edge
             machine learning algorithms.  See also Curtin et al. (2023)
             &lt;<a href="https://doi.org/10.21105%2Fjoss.05026">doi:10.21105/joss.05026</a>&gt;.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>A C++17 compiler. Version 8 or later of GCC will be
fine.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.800), RcppEnsmallen (&ge;
0.2.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.mlpack.org/doc/mlpack-git/r_documentation.html">https://www.mlpack.org/doc/mlpack-git/r_documentation.html</a>,
<a href="https://github.com/mlpack/mlpack">https://github.com/mlpack/mlpack</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlpack/mlpack/issues">https://github.com/mlpack/mlpack/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-28 21:46:11 UTC; runner</td>
</tr>
<tr>
<td>Author:</td>
<td>Yashwant Singh Parihar [aut, ctb, cph],
  Ryan Curtin [aut, ctb, cph, cre],
  Dirk Eddelbuettel [aut, ctb, cph],
  James Balamuta [aut, ctb, cph],
  Bill March [ctb, cph],
  Dongryeol Lee [ctb, cph],
  Nishant Mehta [ctb, cph],
  Parikshit Ram [ctb, cph],
  James Cline [ctb, cph],
  Sterling Peet [ctb, cph],
  Matthew Amidon [ctb, cph],
  Neil Slagle [ctb, cph],
  Ajinkya Kale [ctb, cph],
  Vlad Grantcharov [ctb, cph],
  Noah Kauffman [ctb, cph],
  Rajendran Mohan [ctb, cph],
  Trironk Kiatkungwanglai [ctb, cph],
  Patrick Mason [ctb, cph],
  Marcus Edel [ctb, cph],
  Mudit Raj Gupta [ctb, cph],
  Sumedh Ghaisas [ctb, cph],
  Michael Fox [ctb, cph],
  Siddharth Agrawal [ctb, cph],
  Saheb Motiani [ctb, cph],
  Yash Vadalia [ctb, cph],
  Abhishek Laddha [ctb, cph],
  Vahab Akbarzadeh [ctb, cph],
  Andrew Wells [ctb, cph],
  Zhihao Lou [ctb, cph],
  Udit Saxena [ctb, cph],
  Stephen Tu [ctb, cph],
  Jaskaran Singh [ctb, cph],
  Hritik Jain [ctb, cph],
  Vladimir Glazachev [ctb, cph],
  QiaoAn Chen [ctb, cph],
  Janzen Brewer [ctb, cph],
  Trung Dinh [ctb, cph],
  Tham Ngap Wei [ctb, cph],
  Grzegorz Krajewski [ctb, cph],
  Joseph Mariadassou [ctb, cph],
  Pavel Zhigulin [ctb, cph],
  Andy Fang [ctb, cph],
  Barak Pearlmutter [ctb, cph],
  Ivari Horm [ctb, cph],
  Dhawal Arora [ctb, cph],
  Alexander Leinoff [ctb, cph],
  Palash Ahuja [ctb, cph],
  Yannis Mentekidis [ctb, cph],
  Ranjan Mondal [ctb, cph],
  Mikhail Lozhnikov [ctb, cph],
  Marcos Pividori [ctb, cph],
  Keon Kim [ctb, cph],
  Nilay Jain [ctb, cph],
  Peter Lehner [ctb, cph],
  Anuraj Kanodia [ctb, cph],
  Ivan Georgiev [ctb, cph],
  Shikhar Bhardwaj [ctb, cph],
  Yashu Seth [ctb, cph],
  Mike Izbicki [ctb, cph],
  Sudhanshu Ranjan [ctb, cph],
  Piyush Jaiswal [ctb, cph],
  Dinesh Raj [ctb, cph],
  Vivek Pal [ctb, cph],
  Prasanna Patil [ctb, cph],
  Lakshya Agrawal [ctb, cph],
  Praveen Ch [ctb, cph],
  Kirill Mishchenko [ctb, cph],
  Abhinav Moudgil [ctb, cph],
  Thyrix Yang [ctb, cph],
  Sagar B Hathwar [ctb, cph],
  Nishanth Hegde [ctb, cph],
  Parminder Singh [ctb, cph],
  CodeAi [ctb, cph],
  Franciszek Stokowacki [ctb, cph],
  Samikshya Chand [ctb, cph],
  N Rajiv Vaidyanathan [ctb, cph],
  Kartik Nighania [ctb, cph],
  Eugene Freyman [ctb, cph],
  Manish Kumar [ctb, cph],
  Haritha Sreedharan Nair [ctb, cph],
  Sourabh Varshney [ctb, cph],
  Projyal Dev [ctb, cph],
  Nikhil Goel [ctb, cph],
  Shikhar Jaiswal [ctb, cph],
  B Kartheek Reddy [ctb, cph],
  Atharva Khandait [ctb, cph],
  Wenhao Huang [ctb, cph],
  Roberto Hueso [ctb, cph],
  Prabhat Sharma [ctb, cph],
  Tan Jun An [ctb, cph],
  Moksh Jain [ctb, cph],
  Manthan-R-Sheth [ctb, cph],
  Namrata Mukhija [ctb, cph],
  Conrad Sanderson [ctb, cph],
  Thanasis Mattas [ctb, cph],
  Shashank Shekhar [ctb, cph],
  Yasmine Dumouchel [ctb, cph],
  German Lancioni [ctb, cph],
  Arash Abghari [ctb, cph],
  Ayush Chamoli [ctb, cph],
  Tommi Laivamaa [ctb, cph],
  Kim SangYeon [ctb, cph],
  Niteya Shah [ctb, cph],
  Toshal Agrawal [ctb, cph],
  Dan Timson [ctb, cph],
  Miguel Canteras [ctb, cph],
  Bishwa Karki [ctb, cph],
  Mehul Kumar Nirala [ctb, cph],
  Heet Sankesara [ctb, cph],
  Jeffin Sam [ctb, cph],
  Vikas S Shetty [ctb, cph],
  Khizir Siddiqui [ctb, cph],
  Tejasvi Tomar [ctb, cph],
  Jai Agarwal [ctb, cph],
  Ziyang Jiang [ctb, cph],
  Rohit Kartik [ctb, cph],
  Aditya Viki [ctb, cph],
  Kartik Dutt [ctb, cph],
  Suryoday Basak [ctb, cph],
  Sriram S K [ctb, cph],
  Manoranjan Kumar Bharti ( Nakul Bharti ) [ctb, cph],
  Saraansh Tandon [ctb, cph],
  Gaurav Singh [ctb, cph],
  Lakshya Ojha [ctb, cph],
  Bisakh Mondal [ctb, cph],
  Benson Muite [ctb, cph],
  Sarthak Bhardwaj [ctb, cph],
  Aakash Kaushik [ctb, cph],
  Anush Kini [ctb, cph],
  Nippun Sharma [ctb, cph],
  Rishabh Garg [ctb, cph],
  Sudhakar Brar [ctb, cph],
  Alex Nguyen [ctb, cph],
  Gaurav Ghati [ctb, cph],
  Anmolpreet Singh [ctb, cph],
  Anjishnu Mukherjee [ctb, cph],
  Omar Shrit [ctb, cph],
  Tru Hoang [ctb, cph],
  Mark Fischinger [ctb, cph],
  Muhammad Fawwaz Mayda [ctb, cph],
  Roshan Nrusing Swain [ctb, cph],
  Suvarsha Chennareddy [ctb, cph],
  Shubham Agrawal [ctb, cph],
  James Joseph Balamuta [ctb, cph],
  Sri Madhan M [ctb, cph],
  Zhuojin Liu [ctb, cph],
  Richèl Bilderbeek [ctb, cph],
  Chetan Pandey [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Curtin &lt;ryan@ratml.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 22:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlpack'>mlpack</h2><span id='topic+mlpack'></span><span id='topic+mlpack-package'></span>

<h3>Description</h3>

<p>mlpack is a fast, flexible machine learning library, written in C++, that
aims to provide fast, extensible implementations of cutting-edge machine
learning algorithms. mlpack provides these algorithms as simple command-line
programs, C++ classes and bindings for : Python, Julia, Go and R which can
then be integrated into larger-scale machine learning solutions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ryan Curtin <a href="mailto:ryan@ratml.org">ryan@ratml.org</a> [contributor, copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Yashwant Singh Parihar <a href="mailto:yashwantsingh.sngh@gmail.com">yashwantsingh.sngh@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Dirk Eddelbuettel <a href="mailto:edd@debian.org">edd@debian.org</a> [contributor, copyright holder]
</p>
</li>
<li><p> James Balamuta <a href="mailto:james.balamuta@gmail.com">james.balamuta@gmail.com</a> [contributor, copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Bill March <a href="mailto:march@gatech.edu">march@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Dongryeol Lee <a href="mailto:dongryel@cc.gatech.edu">dongryel@cc.gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Nishant Mehta <a href="mailto:niche@cc.gatech.edu">niche@cc.gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Parikshit Ram <a href="mailto:p.ram@gatech.edu">p.ram@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> James Cline <a href="mailto:james.cline@gatech.edu">james.cline@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sterling Peet <a href="mailto:sterling.peet@gatech.edu">sterling.peet@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Matthew Amidon <a href="mailto:mamidon@gatech.edu">mamidon@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Neil Slagle <a href="mailto:npslagle@gmail.com">npslagle@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ajinkya Kale <a href="mailto:kaleajinkya@gmail.com">kaleajinkya@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Vlad Grantcharov <a href="mailto:vlad321@gatech.edu">vlad321@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Noah Kauffman <a href="mailto:notoriousnoah@gmail.com">notoriousnoah@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Rajendran Mohan <a href="mailto:rmohan88@gatech.edu">rmohan88@gatech.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Trironk Kiatkungwanglai <a href="mailto:trironk@gmail.com">trironk@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Patrick Mason <a href="mailto:patrick.s.mason@gmail.com">patrick.s.mason@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Marcus Edel <a href="mailto:marcus.edel@fu-berlin.de">marcus.edel@fu-berlin.de</a> [contributor, copyright holder]
</p>
</li>
<li><p> Mudit Raj Gupta <a href="mailto:mudit.raaj.gupta@gmail.com">mudit.raaj.gupta@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sumedh Ghaisas <a href="mailto:sumedhghaisas@gmail.com">sumedhghaisas@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Michael Fox <a href="mailto:michaelfox99@gmail.com">michaelfox99@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Siddharth Agrawal <a href="mailto:siddharth.950@gmail.com">siddharth.950@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Saheb Motiani <a href="mailto:saheb210692@gmail.com">saheb210692@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Yash Vadalia <a href="mailto:yashdv@gmail.com">yashdv@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Abhishek Laddha <a href="mailto:laddhaabhishek11@gmail.com">laddhaabhishek11@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Vahab Akbarzadeh <a href="mailto:v.akbarzadeh@gmail.com">v.akbarzadeh@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Andrew Wells <a href="mailto:andrewmw94@gmail.com">andrewmw94@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Zhihao Lou <a href="mailto:lzh1984@gmail.com">lzh1984@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Udit Saxena <a href="mailto:saxenda.udit@gmail.com">saxenda.udit@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Stephen Tu <a href="mailto:tu.stephenl@gmail.com">tu.stephenl@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Jaskaran Singh <a href="mailto:jaskaranvirdi@ymail.com">jaskaranvirdi@ymail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Hritik Jain <a href="mailto:hritik.jain.cse13@itbhu.ac.in">hritik.jain.cse13@itbhu.ac.in</a> [contributor, copyright holder]
</p>
</li>
<li><p> Vladimir Glazachev <a href="mailto:glazachev.vladimir@gmail.com">glazachev.vladimir@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> QiaoAn Chen <a href="mailto:kazenoyumechen@gmail.com">kazenoyumechen@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Janzen Brewer <a href="mailto:jahabrewer@gmail.com">jahabrewer@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Trung Dinh <a href="mailto:dinhanhtrung@gmail.com">dinhanhtrung@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Tham Ngap Wei <a href="mailto:thamngapwei@gmail.com">thamngapwei@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Grzegorz Krajewski <a href="mailto:krajekg@gmail.com">krajekg@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Joseph Mariadassou <a href="mailto:joe.mariadassou@gmail.com">joe.mariadassou@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Pavel Zhigulin <a href="mailto:pashaworking@gmail.com">pashaworking@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Andy Fang <a href="mailto:AndyFang.DZ@gmail.com">AndyFang.DZ@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Barak Pearlmutter <a href="mailto:barak+git@pearlmutter.net">barak+git@pearlmutter.net</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ivari Horm <a href="mailto:ivari@risk.ee">ivari@risk.ee</a> [contributor, copyright holder]
</p>
</li>
<li><p> Dhawal Arora <a href="mailto:d.p.arora1@gmail.com">d.p.arora1@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Alexander Leinoff <a href="mailto:alexander-leinoff@uiowa.edu">alexander-leinoff@uiowa.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Palash Ahuja <a href="mailto:abhor902@gmail.com">abhor902@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Yannis Mentekidis <a href="mailto:mentekid@gmail.com">mentekid@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ranjan Mondal <a href="mailto:ranjan.rev@gmail.com">ranjan.rev@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Mikhail Lozhnikov <a href="mailto:lozhnikovma@gmail.com">lozhnikovma@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Marcos Pividori <a href="mailto:marcos.pividori@gmail.com">marcos.pividori@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Keon Kim <a href="mailto:kwk236@gmail.com">kwk236@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Nilay Jain <a href="mailto:nilayjain13@gmail.com">nilayjain13@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Peter Lehner <a href="mailto:peter.lehner@dlr.de">peter.lehner@dlr.de</a> [contributor, copyright holder]
</p>
</li>
<li><p> Anuraj Kanodia <a href="mailto:akanuraj200@gmail.com">akanuraj200@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ivan Georgiev <a href="mailto:ivan@jonan.info">ivan@jonan.info</a> [contributor, copyright holder]
</p>
</li>
<li><p> Shikhar Bhardwaj <a href="mailto:shikharbhardwaj68@gmail.com">shikharbhardwaj68@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Yashu Seth <a href="mailto:yashuseth2503@gmail.com">yashuseth2503@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Mike Izbicki <a href="mailto:mike@izbicki.me">mike@izbicki.me</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sudhanshu Ranjan <a href="mailto:sranjan.sud@gmail.com">sranjan.sud@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Piyush Jaiswal <a href="mailto:piyush.jaiswal@st.niituniversity.in">piyush.jaiswal@st.niituniversity.in</a> [contributor, copyright holder]
</p>
</li>
<li><p> Dinesh Raj <a href="mailto:dinu.iota@gmail.com">dinu.iota@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Vivek Pal <a href="mailto:vivekpal.dtu@gmail.com">vivekpal.dtu@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Prasanna Patil <a href="mailto:prasannapatil08@gmail.com">prasannapatil08@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Lakshya Agrawal <a href="mailto:zeeshan.lakshya@gmail.com">zeeshan.lakshya@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Praveen Ch <a href="mailto:chvsp972911@gmail.com">chvsp972911@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Kirill Mishchenko <a href="mailto:ki.mishchenko@gmail.com">ki.mishchenko@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Abhinav Moudgil <a href="mailto:abhinavmoudgil95@gmail.com">abhinavmoudgil95@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Thyrix Yang <a href="mailto:thyrixyang@gmail.com">thyrixyang@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sagar B Hathwar <a href="mailto:sagarbhathwar@gmail.com">sagarbhathwar@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Nishanth Hegde <a href="mailto:hegde.nishanth@gmail.com">hegde.nishanth@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Parminder Singh <a href="mailto:parmsingh101@gmail.com">parmsingh101@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> CodeAi <a href="mailto:benjamin.bales@assrc.us">benjamin.bales@assrc.us</a> [contributor, copyright holder]
</p>
</li>
<li><p> Franciszek Stokowacki <a href="mailto:franek.stokowacki@gmail.com">franek.stokowacki@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Samikshya Chand <a href="mailto:samikshya289@gmail.com">samikshya289@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> N Rajiv Vaidyanathan <a href="mailto:rajivvaidyanathan4@gmail.com">rajivvaidyanathan4@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Kartik Nighania <a href="mailto:kartiknighania@gmail.com">kartiknighania@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Eugene Freyman <a href="mailto:evg.freyman@gmail.com">evg.freyman@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Manish Kumar <a href="mailto:manish887kr@gmail.com">manish887kr@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Haritha Sreedharan Nair <a href="mailto:haritha1313@gmail.com">haritha1313@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sourabh Varshney <a href="mailto:sourabhvarshney111@gmail.com">sourabhvarshney111@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Projyal Dev <a href="mailto:projyal@gmail.com">projyal@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Nikhil Goel <a href="mailto:nikhilgoel199797@gmail.com">nikhilgoel199797@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Shikhar Jaiswal <a href="mailto:jaiswalshikhar87@gmail.com">jaiswalshikhar87@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> B Kartheek Reddy <a href="mailto:bkartheekreddy@gmail.com">bkartheekreddy@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Atharva Khandait <a href="mailto:akhandait45@gmail.com">akhandait45@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Wenhao Huang <a href="mailto:wenhao.huang.work@gmail.com">wenhao.huang.work@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Roberto Hueso <a href="mailto:robertohueso96@gmail.com">robertohueso96@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Prabhat Sharma <a href="mailto:prabhatsharma7298@gmail.com">prabhatsharma7298@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Tan Jun An <a href="mailto:yamidarkxxx@gmail.com">yamidarkxxx@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Moksh Jain <a href="mailto:mokshjn00@gmail.com">mokshjn00@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Manthan-R-Sheth <a href="mailto:manthanrsheth96@gmail.com">manthanrsheth96@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Namrata Mukhija <a href="mailto:namratamukhija@gmail.com">namratamukhija@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Conrad Sanderson [contributor, copyright holder]
</p>
</li>
<li><p> Thanasis Mattas <a href="mailto:mattasa@auth.gr">mattasa@auth.gr</a> [contributor, copyright holder]
</p>
</li>
<li><p> Shashank Shekhar <a href="mailto:contactshashankshekhar@gmail.com">contactshashankshekhar@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Yasmine Dumouchel <a href="mailto:yasmine.dumouchel@gmail.com">yasmine.dumouchel@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> German Lancioni [contributor, copyright holder]
</p>
</li>
<li><p> Arash Abghari <a href="mailto:arash.abghari@gmail.com">arash.abghari@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ayush Chamoli [contributor, copyright holder]
</p>
</li>
<li><p> Tommi Laivamaa <a href="mailto:tommi.laivamaa@protonmail.com">tommi.laivamaa@protonmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Kim SangYeon <a href="mailto:sy0814k@gmail.com">sy0814k@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Niteya Shah <a href="mailto:niteya.56@gmail.com">niteya.56@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Toshal Agrawal <a href="mailto:tagrawal1339@gmail.com">tagrawal1339@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Dan Timson [contributor, copyright holder]
</p>
</li>
<li><p> Miguel Canteras <a href="mailto:mcanteras@gmail.com">mcanteras@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Bishwa Karki <a href="mailto:karkeebishwa1@gmail.com">karkeebishwa1@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Mehul Kumar Nirala <a href="mailto:mehulkumarnirala@gmail.com">mehulkumarnirala@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Heet Sankesara <a href="mailto:heetsankesara3@gmail.com">heetsankesara3@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Jeffin Sam <a href="mailto:sam.jeffin@gmail.com">sam.jeffin@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Vikas S Shetty <a href="mailto:shettyvikas209@gmail.com">shettyvikas209@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Khizir Siddiqui <a href="mailto:khizirsiddiqui@gmail.com">khizirsiddiqui@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Tejasvi Tomar <a href="mailto:tstomar@outlook.com">tstomar@outlook.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Jai Agarwal <a href="mailto:jai.bhageria@gmail.com">jai.bhageria@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Ziyang Jiang <a href="mailto:zij004@alumni.stanford.edu">zij004@alumni.stanford.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Rohit Kartik <a href="mailto:rohit.audrey@gmail.com">rohit.audrey@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Aditya Viki <a href="mailto:adityaviki01@gmail.com">adityaviki01@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Kartik Dutt <a href="mailto:kartikdutt@live.in">kartikdutt@live.in</a> [contributor, copyright holder]
</p>
</li>
<li><p> Suryoday Basak <a href="mailto:suryodaybasak@gmail.com">suryodaybasak@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sriram S K <a href="mailto:sriramsk1999@gmail.com">sriramsk1999@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Manoranjan Kumar Bharti ( Nakul Bharti ) <a href="mailto:knakul853@gmail.com">knakul853@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Saraansh Tandon <a href="mailto:saraanshtandon1999@gmail.com">saraanshtandon1999@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Gaurav Singh <a href="mailto:gs8763076@gmail.com">gs8763076@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Lakshya Ojha <a href="mailto:ojhalakshya@gmail.com">ojhalakshya@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Bisakh Mondal <a href="mailto:bisakhmondal00@gmail.com">bisakhmondal00@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Benson Muite <a href="mailto:benson_muite@emailplus.org">benson_muite@emailplus.org</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sarthak Bhardwaj <a href="mailto:7sarthakbhardwaj@gmail.com">7sarthakbhardwaj@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Aakash Kaushik <a href="mailto:kaushikaakash7539@gmail.com">kaushikaakash7539@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Anush Kini <a href="mailto:anushkini@gmail.com">anushkini@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Nippun Sharma <a href="mailto:inbox.nippun@gmail.com">inbox.nippun@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Rishabh Garg <a href="mailto:rishabhgarg108@gmail.com">rishabhgarg108@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sudhakar Brar <a href="mailto:dxhrmhall1449@tutanota.com">dxhrmhall1449@tutanota.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Alex Nguyen <a href="mailto:alexvn.edu@gmail.com">alexvn.edu@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Gaurav Ghati <a href="mailto:gauravghatii@gmail.com">gauravghatii@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Anmolpreet Singh <a href="mailto:anmol323c@gmail.com">anmol323c@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Anjishnu Mukherjee <a href="mailto:amukher6@gmu.edu">amukher6@gmu.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Omar Shrit <a href="mailto:omar@shrit.me">omar@shrit.me</a> [contributor, copyright holder]
</p>
</li>
<li><p> Tru Hoang <a href="mailto:trugiahoang@gmail.com">trugiahoang@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Mark Fischinger <a href="mailto:markfischinger@gmail.com">markfischinger@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Muhammad Fawwaz Mayda <a href="mailto:maydafawwaz@gmail.com">maydafawwaz@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Roshan Nrusing Swain <a href="mailto:swainroshan001@gmail.com">swainroshan001@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Suvarsha Chennareddy <a href="mailto:suvarshachennareddy@gmail.com">suvarshachennareddy@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Shubham Agrawal <a href="mailto:shubham.agra1206@gmail.com">shubham.agra1206@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> James Joseph Balamuta <a href="mailto:balamut2@illinois.edu">balamut2@illinois.edu</a> [contributor, copyright holder]
</p>
</li>
<li><p> Sri Madhan M <a href="mailto:srimadhan11@gmail.com">srimadhan11@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Zhuojin Liu <a href="mailto:zhuojinliu.cs@gmail.com">zhuojinliu.cs@gmail.com</a> [contributor, copyright holder]
</p>
</li>
<li><p> Richèl Bilderbeek <a href="mailto:richel@richelbilderbeek.nl">richel@richelbilderbeek.nl</a> [contributor, copyright holder]
</p>
</li>
<li><p> Chetan Pandey <a href="mailto:chetanpandey1266@gmail.com">chetanpandey1266@gmail.com</a> [contributor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.mlpack.org/doc/mlpack-git/r_documentation.html">https://www.mlpack.org/doc/mlpack-git/r_documentation.html</a>
</p>
</li>
<li> <p><a href="https://github.com/mlpack/mlpack">https://github.com/mlpack/mlpack</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlpack/mlpack/issues">https://github.com/mlpack/mlpack/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adaboost'>AdaBoost</h2><span id='topic+adaboost'></span>

<h3>Description</h3>

<p>An implementation of the AdaBoost.MH (Adaptive Boosting) algorithm for
classification.  This can be used to train an AdaBoost model on labeled data
or use an existing AdaBoost model to predict the classes of new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaboost(
  input_model = NA,
  iterations = NA,
  labels = NA,
  test = NA,
  tolerance = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE),
  weak_learner = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaboost_+3A_input_model">input_model</code></td>
<td>
<p>Input AdaBoost model (AdaBoostModel).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_iterations">iterations</code></td>
<td>
<p>The maximum number of boosting iterations to be run (0
will run until convergence..  Default value &quot;1000&quot; (integer).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_labels">labels</code></td>
<td>
<p>Labels for the training set (integer row).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_test">test</code></td>
<td>
<p>Test dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for change in values of the weighted
error during training.  Default value &quot;1e-10&quot; (numeric).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_training">training</code></td>
<td>
<p>Dataset for training AdaBoost (numeric matrix).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="adaboost_+3A_weak_learner">weak_learner</code></td>
<td>
<p>The type of weak learner to use: 'decision_stump',
or 'perceptron'.  Default value &quot;decision_stump&quot; (character).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements the AdaBoost (or Adaptive Boosting) algorithm. The
variant of AdaBoost implemented here is AdaBoost.MH. It uses a weak learner,
either decision stumps or perceptrons, and over many iterations, creates a
strong learner that is a weighted ensemble of weak learners. It runs these
iterations until a tolerance value is crossed for change in the value of the
weighted training error.
</p>
<p>For more information about the algorithm, see the paper &quot;Improved Boosting
Algorithms Using Confidence-Rated Predictions&quot;, by R.E. Schapire and Y.
Singer.
</p>
<p>This program allows training of an AdaBoost model, and then application of
that model to a test dataset.  To train a model, a dataset must be passed
with the &quot;training&quot; option.  Labels can be given with the &quot;labels&quot; option; if
no labels are specified, the labels will be assumed to be the last column of
the input dataset.  Alternately, an AdaBoost model may be loaded with the
&quot;input_model&quot; option.
</p>
<p>Once a model is trained or loaded, it may be used to provide class
predictions for a given test dataset.  A test dataset may be specified with
the &quot;test&quot; parameter.  The predicted classes for each point in the test
dataset are output to the &quot;predictions&quot; output parameter.  The AdaBoost model
itself is output to the &quot;output_model&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output trained AdaBoost model (AdaBoostModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Predicted labels for the test set (integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Predicted class probabilities for each point in the
test set (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to run AdaBoost on an input dataset "data" with labels
# "labels"and perceptrons as the weak learner type, storing the trained model
# in "model", one could use the following command: 

## Not run: 
output &lt;- adaboost(training=data, labels=labels, weak_learner="perceptron")
model &lt;- output$output_model

## End(Not run)

# Similarly, an already-trained model in "model" can be used to provide class
# predictions from test data "test_data" and store the output in
# "predictions" with the following command: 

## Not run: 
output &lt;- adaboost(input_model=model, test=test_data)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='approx_kfn'>Approximate furthest neighbor search</h2><span id='topic+approx_kfn'></span>

<h3>Description</h3>

<p>An implementation of two strategies for furthest neighbor search.  This can
be used to compute the furthest neighbor of query point(s) from a set of
points; furthest neighbor models can be saved and reused with future query
point(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_kfn(
  algorithm = NA,
  calculate_error = FALSE,
  exact_distances = NA,
  input_model = NA,
  k = NA,
  num_projections = NA,
  num_tables = NA,
  query = NA,
  reference = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx_kfn_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to use: 'ds' or 'qdafn'.  Default value &quot;ds&quot;
(character).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_calculate_error">calculate_error</code></td>
<td>
<p>If set, calculate the average distance error for
the first furthest neighbor only.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_exact_distances">exact_distances</code></td>
<td>
<p>Matrix containing exact distances to furthest
neighbors; this can be used to avoid explicit calculation when
&ndash;calculate_error is set (numeric matrix).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_input_model">input_model</code></td>
<td>
<p>File containing input model (ApproxKFNModel).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_k">k</code></td>
<td>
<p>Number of furthest neighbors to search for.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_num_projections">num_projections</code></td>
<td>
<p>Number of projections to use in each hash table. 
Default value &quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_num_tables">num_tables</code></td>
<td>
<p>Number of hash tables to use.  Default value &quot;5&quot;
(integer).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_query">query</code></td>
<td>
<p>Matrix containing query points (numeric matrix).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_reference">reference</code></td>
<td>
<p>Matrix containing the reference dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code id="approx_kfn_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements two strategies for furthest neighbor search. These
strategies are:
</p>
<p>- The 'qdafn' algorithm from &quot;Approximate Furthest Neighbor in High
Dimensions&quot; by R. Pagh, F. Silvestri, J. Sivertsen, and M. Skala, in
Similarity Search and Applications 2015 (SISAP).
- The 'DrusillaSelect' algorithm from &quot;Fast approximate furthest neighbors
with data-dependent candidate selection&quot;, by R.R. Curtin and A.B. Gardner, in
Similarity Search and Applications 2016 (SISAP).
</p>
<p>These two strategies give approximate results for the furthest neighbor
search problem and can be used as fast replacements for other furthest
neighbor techniques such as those found in the mlpack_kfn program.  Note that
typically, the 'ds' algorithm requires far fewer tables and projections than
the 'qdafn' algorithm.
</p>
<p>Specify a reference set (set to search in) with &quot;reference&quot;, specify a query
set with &quot;query&quot;, and specify algorithm parameters with &quot;num_tables&quot; and
&quot;num_projections&quot; (or don't and defaults will be used).  The algorithm to be
used (either 'ds'&mdash;the default&mdash;or 'qdafn')  may be specified with
&quot;algorithm&quot;.  Also specify the number of neighbors to search for with &quot;k&quot;.
</p>
<p>Note that for 'qdafn' in lower dimensions, &quot;num_projections&quot; may need to be
set to a high value in order to return results for each query point.
</p>
<p>If no query set is specified, the reference set will be used as the query
set.  The &quot;output_model&quot; output parameter may be used to store the built
model, and an input model may be loaded instead of specifying a reference set
with the &quot;input_model&quot; option.
</p>
<p>Results for each query point can be stored with the &quot;neighbors&quot; and
&quot;distances&quot; output parameters.  Each row of these output matrices holds the k
distances or neighbor indices for each query point.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Matrix to save furthest neighbor distances to (numeric
matrix).</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>Matrix to save neighbor indices to (integer matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>File to save output model to (ApproxKFNModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to find the 5 approximate furthest neighbors with
# "reference_set" as the reference set and "query_set" as the query set using
# DrusillaSelect, storing the furthest neighbor indices to "neighbors" and
# the furthest neighbor distances to "distances", one could call

## Not run: 
output &lt;- approx_kfn(query=query_set, reference=reference_set, k=5,
  algorithm="ds")
neighbors &lt;- output$neighbors
distances &lt;- output$distances

## End(Not run)

# and to perform approximate all-furthest-neighbors search with k=1 on the
# set "data" storing only the furthest neighbor distances to "distances", one
# could call

## Not run: 
output &lt;- approx_kfn(reference=reference_set, k=1)
distances &lt;- output$distances

## End(Not run)

# A trained model can be re-used.  If a model has been previously saved to
# "model", then we may find 3 approximate furthest neighbors on a query set
# "new_query_set" using that model and store the furthest neighbor indices
# into "neighbors" by calling

## Not run: 
output &lt;- approx_kfn(input_model=model, query=new_query_set, k=3)
neighbors &lt;- output$neighbors

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesian_linear_regression'>BayesianLinearRegression</h2><span id='topic+bayesian_linear_regression'></span>

<h3>Description</h3>

<p>An implementation of the bayesian linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesian_linear_regression(
  center = FALSE,
  input = NA,
  input_model = NA,
  responses = NA,
  scale = FALSE,
  test = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesian_linear_regression_+3A_center">center</code></td>
<td>
<p>Center the data and fit the intercept if enabled.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_input">input</code></td>
<td>
<p>Matrix of covariates (X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_input_model">input_model</code></td>
<td>
<p>Trained BayesianLinearRegression model to use
(BayesianLinearRegression).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_responses">responses</code></td>
<td>
<p>Matrix of responses/observations (y) (numeric row).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_scale">scale</code></td>
<td>
<p>Scale each feature by their standard deviations if enabled.
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_test">test</code></td>
<td>
<p>Matrix containing points to regress on (test points)
(numeric matrix).</p>
</td></tr>
<tr><td><code id="bayesian_linear_regression_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of the bayesian linear regression.
This model is a probabilistic view and implementation of the linear
regression. The final solution is obtained by computing a posterior
distribution from gaussian likelihood and a zero mean gaussian isotropic 
prior distribution on the solution. 
Optimization is AUTOMATIC and does not require cross validation. The
optimization is performed by maximization of the evidence function.
Parameters are tuned during the maximization of the marginal likelihood. This
procedure includes the Ockham's razor that penalizes over complex solutions. 
</p>
<p>This program is able to train a Bayesian linear regression model or load a
model from file, output regression predictions for a test set, and save the
trained model to a file.
</p>
<p>To train a BayesianLinearRegression model, the &quot;input&quot; and
&quot;responses&quot;parameters must be given. The &quot;center&quot;and &quot;scale&quot; parameters
control the centering and the normalizing options. A trained model can be
saved with the &quot;output_model&quot;. If no training is desired at all, a model can
be passed via the &quot;input_model&quot; parameter.
</p>
<p>The program can also provide predictions for test data using either the
trained model or the given input model.  Test points can be specified with
the &quot;test&quot; parameter.  Predicted responses to the test points can be saved
with the &quot;predictions&quot; output parameter. The corresponding standard deviation
can be save by precising the &quot;stds&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output BayesianLinearRegression model
(BayesianLinearRegression).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>If &ndash;test_file is specified, this file is where the
predicted responses will be saved (numeric matrix).</p>
</td></tr>
<tr><td><code>stds</code></td>
<td>
<p>If specified, this is where the standard deviations of the
predictive distribution will be saved (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following command trains a model on the data "data" and
# responses "responses"with center set to true and scale set to false (so,
# Bayesian linear regression is being solved, and then the model is saved to
# "blr_model":

## Not run: 
output &lt;- bayesian_linear_regression(input=data, responses=responses,
  center=1, scale=0)
blr_model &lt;- output$output_model

## End(Not run)

# The following command uses the "blr_model" to provide predicted  responses
# for the data "test" and save those  responses to "test_predictions": 

## Not run: 
output &lt;- bayesian_linear_regression(input_model=blr_model, test=test)
test_predictions &lt;- output$predictions

## End(Not run)

# Because the estimator computes a predictive distribution instead of a
# simple point estimate, the "stds" parameter allows one to save the
# prediction uncertainties: 

## Not run: 
output &lt;- bayesian_linear_regression(input_model=blr_model, test=test)
test_predictions &lt;- output$predictions
stds &lt;- output$stds

## End(Not run)
</code></pre>

<hr>
<h2 id='cf'>Collaborative Filtering</h2><span id='topic+cf'></span>

<h3>Description</h3>

<p>An implementation of several collaborative filtering (CF) techniques for
recommender systems.  This can be used to train a new CF model, or use an
existing CF model to compute recommendations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf(
  algorithm = NA,
  all_user_recommendations = FALSE,
  input_model = NA,
  interpolation = NA,
  iteration_only_termination = FALSE,
  max_iterations = NA,
  min_residue = NA,
  neighbor_search = NA,
  neighborhood = NA,
  normalization = NA,
  query = NA,
  rank = NA,
  recommendations = NA,
  seed = NA,
  test = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm used for matrix factorization.  Default value
&quot;NMF&quot; (character).</p>
</td></tr>
<tr><td><code id="cf_+3A_all_user_recommendations">all_user_recommendations</code></td>
<td>
<p>Generate recommendations for all users. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="cf_+3A_input_model">input_model</code></td>
<td>
<p>Trained CF model to load (CFModel).</p>
</td></tr>
<tr><td><code id="cf_+3A_interpolation">interpolation</code></td>
<td>
<p>Algorithm used for weight interpolation.  Default
value &quot;average&quot; (character).</p>
</td></tr>
<tr><td><code id="cf_+3A_iteration_only_termination">iteration_only_termination</code></td>
<td>
<p>Terminate only when the maximum number
of iterations is reached.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="cf_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations. If set to zero,
there is no limit on the number of iterations.  Default value &quot;1000&quot;
(integer).</p>
</td></tr>
<tr><td><code id="cf_+3A_min_residue">min_residue</code></td>
<td>
<p>Residue required to terminate the factorization
(lower values generally mean better fits).  Default value &quot;1e-05&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="cf_+3A_neighbor_search">neighbor_search</code></td>
<td>
<p>Algorithm used for neighbor search.  Default
value &quot;euclidean&quot; (character).</p>
</td></tr>
<tr><td><code id="cf_+3A_neighborhood">neighborhood</code></td>
<td>
<p>Size of the neighborhood of similar users to
consider for each query user.  Default value &quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="cf_+3A_normalization">normalization</code></td>
<td>
<p>Normalization performed on the ratings.  Default
value &quot;none&quot; (character).</p>
</td></tr>
<tr><td><code id="cf_+3A_query">query</code></td>
<td>
<p>List of query users for which recommendations should be
generated (integer matrix).</p>
</td></tr>
<tr><td><code id="cf_+3A_rank">rank</code></td>
<td>
<p>Rank of decomposed matrices (if 0, a heuristic is used to
estimate the rank).  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="cf_+3A_recommendations">recommendations</code></td>
<td>
<p>Number of recommendations to generate for each
query user.  Default value &quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="cf_+3A_seed">seed</code></td>
<td>
<p>Set the random seed (0 uses std::time(NULL)).  Default value
&quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="cf_+3A_test">test</code></td>
<td>
<p>Test set to calculate RMSE on (numeric matrix).</p>
</td></tr>
<tr><td><code id="cf_+3A_training">training</code></td>
<td>
<p>Input dataset to perform CF on (numeric matrix).</p>
</td></tr>
<tr><td><code id="cf_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs collaborative filtering (CF) on the given dataset.
Given a list of user, item and preferences (the &quot;training&quot; parameter), the
program will perform a matrix decomposition and then can perform a series of
actions related to collaborative filtering.  Alternately, the program can
load an existing saved CF model with the &quot;input_model&quot; parameter and then use
that model to provide recommendations or predict values.
</p>
<p>The input matrix should be a 3-dimensional matrix of ratings, where the first
dimension is the user, the second dimension is the item, and the third
dimension is that user's rating of that item.  Both the users and items
should be numeric indices, not names. The indices are assumed to start from
0.
</p>
<p>A set of query users for which recommendations can be generated may be
specified with the &quot;query&quot; parameter; alternately, recommendations may be
generated for every user in the dataset by specifying the
&quot;all_user_recommendations&quot; parameter.  In addition, the number of
recommendations per user to generate can be specified with the
&quot;recommendations&quot; parameter, and the number of similar users (the size of the
neighborhood) to be considered when generating recommendations can be
specified with the &quot;neighborhood&quot; parameter.
</p>
<p>For performing the matrix decomposition, the following optimization
algorithms can be specified via the &quot;algorithm&quot; parameter:
</p>
<p>- 'RegSVD' &ndash; Regularized SVD using a SGD optimizer
- 'NMF' &ndash; Non-negative matrix factorization with alternating least squares
update rules
- 'BatchSVD' &ndash; SVD batch learning
- 'SVDIncompleteIncremental' &ndash; SVD incomplete incremental learning
- 'SVDCompleteIncremental' &ndash; SVD complete incremental learning
- 'BiasSVD' &ndash; Bias SVD using a SGD optimizer
- 'SVDPP' &ndash; SVD++ using a SGD optimizer
- 'RandSVD' &ndash; RandomizedSVD learning
- 'QSVD' &ndash; QuicSVD learning
- 'BKSVD' &ndash; Block Krylov SVD learning
</p>
<p>The following neighbor search algorithms can be specified via the
&quot;neighbor_search&quot; parameter:
</p>
<p>- 'cosine'  &ndash; Cosine Search Algorithm
- 'euclidean'  &ndash; Euclidean Search Algorithm
- 'pearson'  &ndash; Pearson Search Algorithm
</p>
<p>The following weight interpolation algorithms can be specified via the
&quot;interpolation&quot; parameter:
</p>
<p>- 'average'  &ndash; Average Interpolation Algorithm
- 'regression'  &ndash; Regression Interpolation Algorithm
- 'similarity'  &ndash; Similarity Interpolation Algorithm
</p>
<p>The following ranking normalization algorithms can be specified via the
&quot;normalization&quot; parameter:
</p>
<p>- 'none'  &ndash; No Normalization
- 'item_mean'  &ndash; Item Mean Normalization
- 'overall_mean'  &ndash; Overall Mean Normalization
- 'user_mean'  &ndash; User Mean Normalization
- 'z_score'  &ndash; Z-Score Normalization
</p>
<p>A trained model may be saved to with the &quot;output_model&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix that will store output recommendations (integer
matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained CF model (CFModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To train a CF model on a dataset "training_set" using NMF for decomposition
# and saving the trained model to "model", one could call: 

## Not run: 
output &lt;- cf(training=training_set, algorithm="NMF")
model &lt;- output$output_model

## End(Not run)

# Then, to use this model to generate recommendations for the list of users
# in the query set "users", storing 5 recommendations in "recommendations",
# one could call 

## Not run: 
output &lt;- cf(input_model=model, query=users, recommendations=5)
recommendations &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='dbscan'>DBSCAN clustering</h2><span id='topic+dbscan'></span>

<h3>Description</h3>

<p>An implementation of DBSCAN clustering.  Given a dataset, this can compute
and return a clustering of that dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbscan(
  input,
  epsilon = NA,
  min_size = NA,
  naive = FALSE,
  selection_type = NA,
  single_mode = FALSE,
  tree_type = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbscan_+3A_input">input</code></td>
<td>
<p>Input dataset to cluster (numeric matrix).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_epsilon">epsilon</code></td>
<td>
<p>Radius of each range search.  Default value &quot;1&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_min_size">min_size</code></td>
<td>
<p>Minimum number of points for a cluster.  Default value
&quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_naive">naive</code></td>
<td>
<p>If set, brute-force range search (not tree-based) will be
used.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_selection_type">selection_type</code></td>
<td>
<p>If using point selection policy, the type of
selection to use ('ordered', 'random').  Default value &quot;ordered&quot;
(character).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_single_mode">single_mode</code></td>
<td>
<p>If set, single-tree range search (not dual-tree) will
be used.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_tree_type">tree_type</code></td>
<td>
<p>If using single-tree or dual-tree search, the type of
tree to use ('kd', 'r', 'r-star', 'x', 'hilbert-r', 'r-plus',
'r-plus-plus', 'cover', 'ball').  Default value &quot;kd&quot; (character).</p>
</td></tr>
<tr><td><code id="dbscan_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements the DBSCAN algorithm for clustering using accelerated
tree-based range search.  The type of tree that is used may be parameterized,
or brute-force range search may also be used.
</p>
<p>The input dataset to be clustered may be specified with the &quot;input&quot;
parameter; the radius of each range search may be specified with the
&quot;epsilon&quot; parameters, and the minimum number of points in a cluster may be
specified with the &quot;min_size&quot; parameter.
</p>
<p>The &quot;assignments&quot; and &quot;centroids&quot; output parameters may be used to save the
output of the clustering. &quot;assignments&quot; contains the cluster assignments of
each point, and &quot;centroids&quot; contains the centroids of each cluster.
</p>
<p>The range search may be controlled with the &quot;tree_type&quot;, &quot;single_mode&quot;, and
&quot;naive&quot; parameters.  &quot;tree_type&quot; can control the type of tree used for range
search; this can take a variety of values: 'kd', 'r', 'r-star', 'x',
'hilbert-r', 'r-plus', 'r-plus-plus', 'cover', 'ball'. The &quot;single_mode&quot;
parameter will force single-tree search (as opposed to the default dual-tree
search), and '&quot;naive&quot; will force brute-force range search.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>assignments</code></td>
<td>
<p>Output matrix for assignments of each point (integer
row).</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>Matrix to save output centroids to (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An example usage to run DBSCAN on the dataset in "input" with a radius of
# 0.5 and a minimum cluster size of 5 is given below:

## Not run: 
dbscan(input=input, epsilon=0.5, min_size=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='decision_tree'>Decision tree</h2><span id='topic+decision_tree'></span>

<h3>Description</h3>

<p>An implementation of an ID3-style decision tree for classification, which
supports categorical data.  Given labeled data with numeric or categorical
features, a decision tree can be trained and saved; or, an existing decision
tree can be used for classification on new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decision_tree(
  input_model = NA,
  labels = NA,
  maximum_depth = NA,
  minimum_gain_split = NA,
  minimum_leaf_size = NA,
  print_training_accuracy = FALSE,
  test = NA,
  test_labels = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE),
  weights = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decision_tree_+3A_input_model">input_model</code></td>
<td>
<p>Pre-trained decision tree, to be used with test
points (DecisionTreeModel).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_labels">labels</code></td>
<td>
<p>Training labels (integer row).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_maximum_depth">maximum_depth</code></td>
<td>
<p>Maximum depth of the tree (0 means no limit). 
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_minimum_gain_split">minimum_gain_split</code></td>
<td>
<p>Minimum gain for node splitting.  Default
value &quot;1e-07&quot; (numeric).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_minimum_leaf_size">minimum_leaf_size</code></td>
<td>
<p>Minimum number of points in a leaf.  Default
value &quot;20&quot; (integer).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_print_training_accuracy">print_training_accuracy</code></td>
<td>
<p>Print the training accuracy.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_test">test</code></td>
<td>
<p>Testing dataset (may be categorical) (numeric
matrix/data.frame with info).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_test_labels">test_labels</code></td>
<td>
<p>Test point labels, if accuracy calculation is desired
(integer row).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_training">training</code></td>
<td>
<p>Training dataset (may be categorical) (numeric
matrix/data.frame with info).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="decision_tree_+3A_weights">weights</code></td>
<td>
<p>The weight of label (numeric matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Train and evaluate using a decision tree.  Given a dataset containing numeric
or categorical features, and associated labels for each point in the dataset,
this program can train a decision tree on that data.
</p>
<p>The training set and associated labels are specified with the &quot;training&quot; and
&quot;labels&quot; parameters, respectively.  The labels should be in the range '[0,
num_classes - 1]'. Optionally, if &quot;labels&quot; is not specified, the labels are
assumed to be the last dimension of the training dataset.
</p>
<p>When a model is trained, the &quot;output_model&quot; output parameter may be used to
save the trained model.  A model may be loaded for predictions with the
&quot;input_model&quot; parameter.  The &quot;input_model&quot; parameter may not be specified
when the &quot;training&quot; parameter is specified.  The &quot;minimum_leaf_size&quot;
parameter specifies the minimum number of training points that must fall into
each leaf for it to be split.  The &quot;minimum_gain_split&quot; parameter specifies
the minimum gain that is needed for the node to split.  The &quot;maximum_depth&quot;
parameter specifies the maximum depth of the tree.  If
&quot;print_training_accuracy&quot; is specified, the training accuracy will be
printed.
</p>
<p>Test data may be specified with the &quot;test&quot; parameter, and if performance
numbers are desired for that test set, labels may be specified with the
&quot;test_labels&quot; parameter.  Predictions for each test point may be saved via
the &quot;predictions&quot; output parameter.  Class probabilities for each prediction
may be saved with the &quot;probabilities&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained decision tree
(DecisionTreeModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Class predictions for each test point (integer
row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Class probabilities for each test point (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to train a decision tree with a minimum leaf size of 20 on the
# dataset contained in "data" with labels "labels", saving the output model
# to "tree" and printing the training error, one could call

## Not run: 
output &lt;- decision_tree(training=data, labels=labels, minimum_leaf_size=20,
  minimum_gain_split=0.001, print_training_accuracy=TRUE)
tree &lt;- output$output_model

## End(Not run)

# Then, to use that model to classify points in "test_set" and print the test
# error given the labels "test_labels" using that model, while saving the
# predictions for each point to "predictions", one could call 

## Not run: 
output &lt;- decision_tree(input_model=tree, test=test_set,
  test_labels=test_labels)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='det'>Density Estimation With Density Estimation Trees</h2><span id='topic+det'></span>

<h3>Description</h3>

<p>An implementation of density estimation trees for the density estimation
task.  Density estimation trees can be trained or used to predict the density
at locations given by query points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>det(
  folds = NA,
  input_model = NA,
  max_leaf_size = NA,
  min_leaf_size = NA,
  path_format = NA,
  skip_pruning = FALSE,
  test = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="det_+3A_folds">folds</code></td>
<td>
<p>The number of folds of cross-validation to perform for the
estimation (0 is LOOCV.  Default value &quot;10&quot; (integer).</p>
</td></tr>
<tr><td><code id="det_+3A_input_model">input_model</code></td>
<td>
<p>Trained density estimation tree to load (DTree).</p>
</td></tr>
<tr><td><code id="det_+3A_max_leaf_size">max_leaf_size</code></td>
<td>
<p>The maximum size of a leaf in the unpruned, fully
grown DET.  Default value &quot;10&quot; (integer).</p>
</td></tr>
<tr><td><code id="det_+3A_min_leaf_size">min_leaf_size</code></td>
<td>
<p>The minimum size of a leaf in the unpruned, fully
grown DET.  Default value &quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="det_+3A_path_format">path_format</code></td>
<td>
<p>The format of path printing: 'lr', 'id-lr', or
'lr-id'.  Default value &quot;lr&quot; (character).</p>
</td></tr>
<tr><td><code id="det_+3A_skip_pruning">skip_pruning</code></td>
<td>
<p>Whether to bypass the pruning process and output the
unpruned tree only.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="det_+3A_test">test</code></td>
<td>
<p>A set of test points to estimate the density of (numeric
matrix).</p>
</td></tr>
<tr><td><code id="det_+3A_training">training</code></td>
<td>
<p>The data set on which to build a density estimation tree
(numeric matrix).</p>
</td></tr>
<tr><td><code id="det_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs a number of functions related to Density Estimation
Trees.  The optimal Density Estimation Tree (DET) can be trained on a set of
data (specified by &quot;training&quot;) using cross-validation (with number of folds
specified with the &quot;folds&quot; parameter).  This trained density estimation tree
may then be saved with the &quot;output_model&quot; output parameter.
</p>
<p>The variable importances (that is, the feature importance values for each
dimension) may be saved with the &quot;vi&quot; output parameter, and the density
estimates for each training point may be saved with the
&quot;training_set_estimates&quot; output parameter.
</p>
<p>Enabling path printing for each node outputs the path from the root node to a
leaf for each entry in the test set, or training set (if a test set is not
provided).  Strings like 'LRLRLR' (indicating that traversal went to the left
child, then the right child, then the left child, and so forth) will be
output. If 'lr-id' or 'id-lr' are given as the &quot;path_format&quot; parameter, then
the ID (tag) of every node along the path will be printed after or before the
L or R character indicating the direction of traversal, respectively.
</p>
<p>This program also can provide density estimates for a set of test points,
specified in the &quot;test&quot; parameter.  The density estimation tree used for this
task will be the tree that was trained on the given training points, or a
tree given as the parameter &quot;input_model&quot;.  The density estimates for the
test points may be saved using the &quot;test_set_estimates&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output to save trained density estimation tree to
(DTree).</p>
</td></tr>
<tr><td><code>tag_counters_file</code></td>
<td>
<p>The file to output the number of points that
went to each leaf.  Default value &quot;&quot; (character).</p>
</td></tr>
<tr><td><code>tag_file</code></td>
<td>
<p>The file to output the tags (and possibly paths) for
each sample in the test set.  Default value &quot;&quot; (character).</p>
</td></tr>
<tr><td><code>test_set_estimates</code></td>
<td>
<p>The output estimates on the test set from the
final optimally pruned tree (numeric matrix).</p>
</td></tr>
<tr><td><code>training_set_estimates</code></td>
<td>
<p>The output density estimates on the
training set from the final optimally pruned tree (numeric matrix).</p>
</td></tr>
<tr><td><code>vi</code></td>
<td>
<p>The output variable importance values for each feature
(numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>

<hr>
<h2 id='emst'>Fast Euclidean Minimum Spanning Tree</h2><span id='topic+emst'></span>

<h3>Description</h3>

<p>An implementation of the Dual-Tree Boruvka algorithm for computing the
Euclidean minimum spanning tree of a set of input points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emst(
  input,
  leaf_size = NA,
  naive = FALSE,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emst_+3A_input">input</code></td>
<td>
<p>Input data matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="emst_+3A_leaf_size">leaf_size</code></td>
<td>
<p>Leaf size in the kd-tree.  One-element leaves give the
empirically best performance, but at the cost of greater memory
requirements.  Default value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="emst_+3A_naive">naive</code></td>
<td>
<p>Compute the MST using O(n^2) naive algorithm.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="emst_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program can compute the Euclidean minimum spanning tree of a set of
input points using the dual-tree Boruvka algorithm.
</p>
<p>The set to calculate the minimum spanning tree of is specified with the
&quot;input&quot; parameter, and the output may be saved with the &quot;output&quot; output
parameter.
</p>
<p>The &quot;leaf_size&quot; parameter controls the leaf size of the kd-tree that is used
to calculate the minimum spanning tree, and if the &quot;naive&quot; option is given,
then brute-force search is used (this is typically much slower in low
dimensions).  The leaf size does not affect the results, but it may have some
effect on the runtime of the algorithm.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Output data.  Stored as an edge list (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the minimum spanning tree of the input dataset "data" can be
# calculated with a leaf size of 20 and stored as "spanning_tree" using the
# following command:

## Not run: 
output &lt;- emst(input=data, leaf_size=20)
spanning_tree &lt;- output$output

## End(Not run)

# The output matrix is a three-dimensional matrix, where each row indicates
# an edge.  The first dimension corresponds to the lesser index of the edge;
# the second dimension corresponds to the greater index of the edge; and the
# third column corresponds to the distance between the two points.
</code></pre>

<hr>
<h2 id='fastmks'>FastMKS (Fast Max-Kernel Search)</h2><span id='topic+fastmks'></span>

<h3>Description</h3>

<p>An implementation of the single-tree and dual-tree fast max-kernel search
(FastMKS) algorithm.  Given a set of reference points and a set of query
points, this can find the reference point with maximum kernel value for each
query point; trained models can be reused for future queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastmks(
  bandwidth = NA,
  base = NA,
  degree = NA,
  input_model = NA,
  k = NA,
  kernel = NA,
  naive = FALSE,
  offset = NA,
  query = NA,
  reference = NA,
  scale = NA,
  single = FALSE,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastmks_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth (for Gaussian, Epanechnikov, and triangular
kernels).  Default value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_base">base</code></td>
<td>
<p>Base to use during cover tree construction.  Default value
&quot;2&quot; (numeric).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_degree">degree</code></td>
<td>
<p>Degree of polynomial kernel.  Default value &quot;2&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_input_model">input_model</code></td>
<td>
<p>Input FastMKS model to use (FastMKSModel).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_k">k</code></td>
<td>
<p>Number of maximum kernels to find.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_kernel">kernel</code></td>
<td>
<p>Kernel type to use: 'linear', 'polynomial', 'cosine',
'gaussian', 'epanechnikov', 'triangular', 'hyptan'.  Default value &quot;linear&quot;
(character).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_naive">naive</code></td>
<td>
<p>If true, O(n^2) naive mode is used for computation. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_offset">offset</code></td>
<td>
<p>Offset of kernel (for polynomial and hyptan kernels). 
Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_query">query</code></td>
<td>
<p>The query dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_reference">reference</code></td>
<td>
<p>The reference dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_scale">scale</code></td>
<td>
<p>Scale of kernel (for hyptan kernel).  Default value &quot;1&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_single">single</code></td>
<td>
<p>If true, single-tree search is used (as opposed to
dual-tree search.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="fastmks_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program will find the k maximum kernels of a set of points, using a
query set and a reference set (which can optionally be the same set). More
specifically, for each point in the query set, the k points in the reference
set with maximum kernel evaluations are found.  The kernel function used is
specified with the &quot;kernel&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>indices</code></td>
<td>
<p>Output matrix of indices (integer matrix).</p>
</td></tr>
<tr><td><code>kernels</code></td>
<td>
<p>Output matrix of kernels (numeric matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>Output for FastMKS model (FastMKSModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following command will calculate, for each point in the
# query set "query", the five points in the reference set "reference" with
# maximum kernel evaluation using the linear kernel.  The kernel evaluations
# may be saved with the  "kernels" output parameter and the indices may be
# saved with the "indices" output parameter.

## Not run: 
output &lt;- fastmks(k=5, reference=reference, query=query, kernel="linear")
indices &lt;- output$indices
kernels &lt;- output$kernels

## End(Not run)

# The output matrices are organized such that row i and column j in the
# indices matrix corresponds to the index of the point in the reference set
# that has j'th largest kernel evaluation with the point in the query set
# with index i.  Row i and column j in the kernels matrix corresponds to the
# kernel evaluation between those two points.
# 
# This program performs FastMKS using a cover tree.  The base used to build
# the cover tree can be specified with the "base" parameter.
</code></pre>

<hr>
<h2 id='gmm_generate'>GMM Sample Generator</h2><span id='topic+gmm_generate'></span>

<h3>Description</h3>

<p>A sample generator for pre-trained GMMs.  Given a pre-trained GMM, this can
sample new points randomly from that distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm_generate(
  input_model,
  samples,
  seed = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm_generate_+3A_input_model">input_model</code></td>
<td>
<p>Input GMM model to generate samples from (GMM).</p>
</td></tr>
<tr><td><code id="gmm_generate_+3A_samples">samples</code></td>
<td>
<p>Number of samples to generate (integer).</p>
</td></tr>
<tr><td><code id="gmm_generate_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="gmm_generate_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program is able to generate samples from a pre-trained GMM (use
gmm_train to train a GMM).  The pre-trained GMM must be specified with the
&quot;input_model&quot; parameter.  The number of samples to generate is specified by
the &quot;samples&quot; parameter.  Output samples may be saved with the &quot;output&quot;
output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save output samples in (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following command can be used to generate 100 samples from the
# pre-trained GMM "gmm" and store those generated samples in "samples":

## Not run: 
output &lt;- gmm_generate(input_model=gmm, samples=100)
samples &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='gmm_probability'>GMM Probability Calculator</h2><span id='topic+gmm_probability'></span>

<h3>Description</h3>

<p>A probability calculator for GMMs.  Given a pre-trained GMM and a set of
points, this can compute the probability that each point is from the given
GMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm_probability(
  input,
  input_model,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm_probability_+3A_input">input</code></td>
<td>
<p>Input matrix to calculate probabilities of (numeric
matrix).</p>
</td></tr>
<tr><td><code id="gmm_probability_+3A_input_model">input_model</code></td>
<td>
<p>Input GMM to use as model (GMM).</p>
</td></tr>
<tr><td><code id="gmm_probability_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program calculates the probability that given points came from a given
GMM (that is, P(X | gmm)).  The GMM is specified with the &quot;input_model&quot;
parameter, and the points are specified with the &quot;input&quot; parameter.  The
output probabilities may be saved via the &quot;output&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to store calculated probabilities in (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># So, for example, to calculate the probabilities of each point in "points"
# coming from the pre-trained GMM "gmm", while storing those probabilities in
# "probs", the following command could be used:

## Not run: 
output &lt;- gmm_probability(input_model=gmm, input=points)
probs &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='gmm_train'>Gaussian Mixture Model (GMM) Training</h2><span id='topic+gmm_train'></span>

<h3>Description</h3>

<p>An implementation of the EM algorithm for training Gaussian mixture models
(GMMs).  Given a dataset, this can train a GMM for future use with other
tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm_train(
  gaussians,
  input,
  diagonal_covariance = FALSE,
  input_model = NA,
  kmeans_max_iterations = NA,
  max_iterations = NA,
  no_force_positive = FALSE,
  noise = NA,
  percentage = NA,
  refined_start = FALSE,
  samplings = NA,
  seed = NA,
  tolerance = NA,
  trials = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm_train_+3A_gaussians">gaussians</code></td>
<td>
<p>Number of Gaussians in the GMM (integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_input">input</code></td>
<td>
<p>The training data on which the model will be fit (numeric
matrix).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_diagonal_covariance">diagonal_covariance</code></td>
<td>
<p>Force the covariance of the Gaussians to be
diagonal.  This can accelerate training time significantly.  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_input_model">input_model</code></td>
<td>
<p>Initial input GMM model to start training with
(GMM).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_kmeans_max_iterations">kmeans_max_iterations</code></td>
<td>
<p>Maximum number of iterations for the
k-means algorithm (used to initialize EM).  Default value &quot;1000&quot;
(integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations of EM algorithm
(passing 0 will run until convergence).  Default value &quot;250&quot; (integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_no_force_positive">no_force_positive</code></td>
<td>
<p>Do not force the covariance matrices to be
positive definite.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_noise">noise</code></td>
<td>
<p>Variance of zero-mean Gaussian noise to add to data. 
Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_percentage">percentage</code></td>
<td>
<p>If using &ndash;refined_start, specify the percentage of
the dataset used for each sampling (should be between 0.0 and 1.0). 
Default value &quot;0.02&quot; (numeric).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_refined_start">refined_start</code></td>
<td>
<p>During the initialization, use refined initial
positions for k-means clustering (Bradley and Fayyad, 1998).  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_samplings">samplings</code></td>
<td>
<p>If using &ndash;refined_start, specify the number of
samplings used for initial points.  Default value &quot;100&quot; (integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for convergence of EM.  Default value &quot;1e-10&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_trials">trials</code></td>
<td>
<p>Number of trials to perform in training GMM.  Default
value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="gmm_train_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program takes a parametric estimate of a Gaussian mixture model (GMM)
using the EM algorithm to find the maximum likelihood estimate.  The model
may be saved and reused by other mlpack GMM tools.
</p>
<p>The input data to train on must be specified with the &quot;input&quot; parameter, and
the number of Gaussians in the model must be specified with the &quot;gaussians&quot;
parameter.  Optionally, many trials with different random initializations may
be run, and the result with highest log-likelihood on the training data will
be taken.  The number of trials to run is specified with the &quot;trials&quot;
parameter.  By default, only one trial is run.
</p>
<p>The tolerance for convergence and maximum number of iterations of the EM
algorithm are specified with the &quot;tolerance&quot; and &quot;max_iterations&quot; parameters,
respectively.  The GMM may be initialized for training with another model,
specified with the &quot;input_model&quot; parameter. Otherwise, the model is
initialized by running k-means on the data.  The k-means clustering
initialization can be controlled with the &quot;kmeans_max_iterations&quot;,
&quot;refined_start&quot;, &quot;samplings&quot;, and &quot;percentage&quot; parameters.  If
&quot;refined_start&quot; is specified, then the Bradley-Fayyad refined start
initialization will be used.  This can often lead to better clustering
results.
</p>
<p>The 'diagonal_covariance' flag will cause the learned covariances to be
diagonal matrices.  This significantly simplifies the model itself and causes
training to be faster, but restricts the ability to fit more complex GMMs.
</p>
<p>If GMM training fails with an error indicating that a covariance matrix could
not be inverted, make sure that the &quot;no_force_positive&quot; parameter is not
specified.  Alternately, adding a small amount of Gaussian noise (using the
&quot;noise&quot; parameter) to the entire dataset may help prevent Gaussians with zero
variance in a particular dimension, which is usually the cause of
non-invertible covariance matrices.
</p>
<p>The &quot;no_force_positive&quot; parameter, if set, will avoid the checks after each
iteration of the EM algorithm which ensure that the covariance matrices are
positive definite.  Specifying the flag can cause faster runtime, but may
also cause non-positive definite covariance matrices, which will cause the
program to crash.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained GMM model (GMM).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, to train a 6-Gaussian GMM on the data in "data" with a
# maximum of 100 iterations of EM and 3 trials, saving the trained GMM to
# "gmm", the following command can be used:

## Not run: 
output &lt;- gmm_train(input=data, gaussians=6, trials=3)
gmm &lt;- output$output_model

## End(Not run)

# To re-train that GMM on another set of data "data2", the following command
# may be used: 

## Not run: 
output &lt;- gmm_train(input_model=gmm, input=data2, gaussians=6)
new_gmm &lt;- output$output_model

## End(Not run)
</code></pre>

<hr>
<h2 id='hmm_generate'>Hidden Markov Model (HMM) Sequence Generator</h2><span id='topic+hmm_generate'></span>

<h3>Description</h3>

<p>A utility to generate random sequences from a pre-trained Hidden Markov Model
(HMM).  The length of the desired sequence can be specified, and a random
sequence of observations is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_generate(
  length,
  model,
  seed = NA,
  start_state = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_generate_+3A_length">length</code></td>
<td>
<p>Length of sequence to generate (integer).</p>
</td></tr>
<tr><td><code id="hmm_generate_+3A_model">model</code></td>
<td>
<p>Trained HMM to generate sequences with (HMMModel).</p>
</td></tr>
<tr><td><code id="hmm_generate_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="hmm_generate_+3A_start_state">start_state</code></td>
<td>
<p>Starting state of sequence.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="hmm_generate_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes an already-trained HMM, specified as the &quot;model&quot;
parameter, and generates a random observation sequence and hidden state
sequence based on its parameters. The observation sequence may be saved with
the &quot;output&quot; output parameter, and the internal state  sequence may be saved
with the &quot;state&quot; output parameter.
</p>
<p>The state to start the sequence in may be specified with the &quot;start_state&quot;
parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save observation sequence to (numeric matrix).</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>Matrix to save hidden state sequence to (integer matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to generate a sequence of length 150 from the HMM "hmm" and
# save the observation sequence to "observations" and the hidden state
# sequence to "states", the following command may be used: 

## Not run: 
output &lt;- hmm_generate(model=hmm, length=150)
observations &lt;- output$output
states &lt;- output$state

## End(Not run)
</code></pre>

<hr>
<h2 id='hmm_loglik'>Hidden Markov Model (HMM) Sequence Log-Likelihood</h2><span id='topic+hmm_loglik'></span>

<h3>Description</h3>

<p>A utility for computing the log-likelihood of a sequence for Hidden Markov
Models (HMMs).  Given a pre-trained HMM and an observation sequence, this
computes and returns the log-likelihood of that sequence being observed from
that HMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_loglik(input, input_model, verbose = getOption("mlpack.verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_loglik_+3A_input">input</code></td>
<td>
<p>File containing observations (numeric matrix).</p>
</td></tr>
<tr><td><code id="hmm_loglik_+3A_input_model">input_model</code></td>
<td>
<p>File containing HMM (HMMModel).</p>
</td></tr>
<tr><td><code id="hmm_loglik_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes an already-trained HMM, specified with the &quot;input_model&quot;
parameter, and evaluates the log-likelihood of a sequence of observations,
given with the &quot;input&quot; parameter.  The computed log-likelihood is given as
output.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>log_likelihood</code></td>
<td>
<p>Log-likelihood of the sequence.  Default value &quot;0&quot;
(numeric).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to compute the log-likelihood of the sequence "seq" with the
# pre-trained HMM "hmm", the following command may be used: 

## Not run: 
hmm_loglik(input=seq, input_model=hmm)

## End(Not run)
</code></pre>

<hr>
<h2 id='hmm_train'>Hidden Markov Model (HMM) Training</h2><span id='topic+hmm_train'></span>

<h3>Description</h3>

<p>An implementation of training algorithms for Hidden Markov Models (HMMs).
Given labeled or unlabeled data, an HMM can be trained for further use with
other mlpack HMM tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_train(
  input_file,
  batch = FALSE,
  gaussians = NA,
  input_model = NA,
  labels_file = NA,
  seed = NA,
  states = NA,
  tolerance = NA,
  type = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_train_+3A_input_file">input_file</code></td>
<td>
<p>File containing input observations (character).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_batch">batch</code></td>
<td>
<p>If true, input_file (and if passed, labels_file) are
expected to contain a list of files to use as input observation sequences
(and label sequences).  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_gaussians">gaussians</code></td>
<td>
<p>Number of gaussians in each GMM (necessary when type is
'gmm').  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_input_model">input_model</code></td>
<td>
<p>Pre-existing HMM model to initialize training with
(HMMModel).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_labels_file">labels_file</code></td>
<td>
<p>Optional file of hidden states, used for labeled
training.  Default value &quot;&quot; (character).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_states">states</code></td>
<td>
<p>Number of hidden states in HMM (necessary, unless
model_file is specified).  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance of the Baum-Welch algorithm.  Default value
&quot;1e-05&quot; (numeric).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_type">type</code></td>
<td>
<p>Type of HMM: discrete | gaussian | diag_gmm | gmm.  Default
value &quot;gaussian&quot; (character).</p>
</td></tr>
<tr><td><code id="hmm_train_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program allows a Hidden Markov Model to be trained on labeled or
unlabeled data.  It supports four types of HMMs: Discrete HMMs, Gaussian
HMMs, GMM HMMs, or Diagonal GMM HMMs
</p>
<p>Either one input sequence can be specified (with &quot;input_file&quot;), or, a file
containing files in which input sequences can be found (when
&quot;input_file&quot;and&quot;batch&quot; are used together).  In addition, labels can be
provided in the file specified by &quot;labels_file&quot;, and if &quot;batch&quot; is used, the
file given to &quot;labels_file&quot; should contain a list of files of labels
corresponding to the sequences in the file given to &quot;input_file&quot;.
</p>
<p>The HMM is trained with the Baum-Welch algorithm if no labels are provided. 
The tolerance of the Baum-Welch algorithm can be set with the
&quot;tolerance&quot;option.  By default, the transition matrix is randomly initialized
and the emission distributions are initialized to fit the extent of the data.
</p>
<p>Optionally, a pre-created HMM model can be used as a guess for the transition
matrix and emission probabilities; this is specifiable with &quot;output_model&quot;.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained HMM (HMMModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>

<hr>
<h2 id='hmm_viterbi'>Hidden Markov Model (HMM) Viterbi State Prediction</h2><span id='topic+hmm_viterbi'></span>

<h3>Description</h3>

<p>A utility for computing the most probable hidden state sequence for Hidden
Markov Models (HMMs).  Given a pre-trained HMM and an observed sequence, this
uses the Viterbi algorithm to compute and return the most probable hidden
state sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm_viterbi(input, input_model, verbose = getOption("mlpack.verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_viterbi_+3A_input">input</code></td>
<td>
<p>Matrix containing observations (numeric matrix).</p>
</td></tr>
<tr><td><code id="hmm_viterbi_+3A_input_model">input_model</code></td>
<td>
<p>Trained HMM to use (HMMModel).</p>
</td></tr>
<tr><td><code id="hmm_viterbi_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes an already-trained HMM, specified as &quot;input_model&quot;, and
evaluates the most probable hidden state sequence of a given sequence of
observations (specified as '&quot;input&quot;, using the Viterbi algorithm.  The
computed state sequence may be saved using the &quot;output&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>File to save predicted state sequence to (integer
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to predict the state sequence of the observations "obs" using
# the HMM "hmm", storing the predicted state sequence to "states", the
# following command could be used:

## Not run: 
output &lt;- hmm_viterbi(input=obs, input_model=hmm)
states &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='hoeffding_tree'>Hoeffding trees</h2><span id='topic+hoeffding_tree'></span>

<h3>Description</h3>

<p>An implementation of Hoeffding trees, a form of streaming decision tree for
classification.  Given labeled data, a Hoeffding tree can be trained and
saved for later use, or a pre-trained Hoeffding tree can be used for
predicting the classifications of new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoeffding_tree(
  batch_mode = FALSE,
  bins = NA,
  confidence = NA,
  info_gain = FALSE,
  input_model = NA,
  labels = NA,
  max_samples = NA,
  min_samples = NA,
  numeric_split_strategy = NA,
  observations_before_binning = NA,
  passes = NA,
  test = NA,
  test_labels = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoeffding_tree_+3A_batch_mode">batch_mode</code></td>
<td>
<p>If true, samples will be considered in batch instead
of as a stream.  This generally results in better trees but at the cost of
memory usage and runtime.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_bins">bins</code></td>
<td>
<p>If the 'domingos' split strategy is used, this specifies the
number of bins for each numeric split.  Default value &quot;10&quot; (integer).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_confidence">confidence</code></td>
<td>
<p>Confidence before splitting (between 0 and 1). 
Default value &quot;0.95&quot; (numeric).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_info_gain">info_gain</code></td>
<td>
<p>If set, information gain is used instead of Gini
impurity for calculating Hoeffding bounds.  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_input_model">input_model</code></td>
<td>
<p>Input trained Hoeffding tree model
(HoeffdingTreeModel).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_labels">labels</code></td>
<td>
<p>Labels for training dataset (integer row).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_max_samples">max_samples</code></td>
<td>
<p>Maximum number of samples before splitting.  Default
value &quot;5000&quot; (integer).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_min_samples">min_samples</code></td>
<td>
<p>Minimum number of samples before splitting.  Default
value &quot;100&quot; (integer).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_numeric_split_strategy">numeric_split_strategy</code></td>
<td>
<p>The splitting strategy to use for numeric
features: 'domingos' or 'binary'.  Default value &quot;binary&quot; (character).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_observations_before_binning">observations_before_binning</code></td>
<td>
<p>If the 'domingos' split strategy is
used, this specifies the number of samples observed before binning is
performed.  Default value &quot;100&quot; (integer).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_passes">passes</code></td>
<td>
<p>Number of passes to take over the dataset.  Default value
&quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_test">test</code></td>
<td>
<p>Testing dataset (may be categorical) (numeric
matrix/data.frame with info).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_test_labels">test_labels</code></td>
<td>
<p>Labels of test data (integer row).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_training">training</code></td>
<td>
<p>Training dataset (may be categorical) (numeric
matrix/data.frame with info).</p>
</td></tr>
<tr><td><code id="hoeffding_tree_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements Hoeffding trees, a form of streaming decision tree
suited best for large (or streaming) datasets.  This program supports both
categorical and numeric data.  Given an input dataset, this program is able
to train the tree with numerous training options, and save the model to a
file.  The program is also able to use a trained model or a model from file
in order to predict classes for a given test set.
</p>
<p>The training file and associated labels are specified with the &quot;training&quot; and
&quot;labels&quot; parameters, respectively. Optionally, if &quot;labels&quot; is not specified,
the labels are assumed to be the last dimension of the training dataset.
</p>
<p>The training may be performed in batch mode (like a typical decision tree
algorithm) by specifying the &quot;batch_mode&quot; option, but this may not be the
best option for large datasets.
</p>
<p>When a model is trained, it may be saved via the &quot;output_model&quot; output
parameter.  A model may be loaded from file for further training or testing
with the &quot;input_model&quot; parameter.
</p>
<p>Test data may be specified with the &quot;test&quot; parameter, and if performance
statistics are desired for that test set, labels may be specified with the
&quot;test_labels&quot; parameter.  Predictions for each test point may be saved with
the &quot;predictions&quot; output parameter, and class probabilities for each
prediction may be saved with the &quot;probabilities&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained Hoeffding tree model
(HoeffdingTreeModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Matrix to output label predictions for test data into
(integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>In addition to predicting labels, provide rediction
probabilities in this matrix (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to train a Hoeffding tree with confidence 0.99 with data
# "dataset", saving the trained tree to "tree", the following command may be
# used:

## Not run: 
output &lt;- hoeffding_tree(training=dataset, confidence=0.99)
tree &lt;- output$output_model

## End(Not run)

# Then, this tree may be used to make predictions on the test set "test_set",
# saving the predictions into "predictions" and the class probabilities into
# "class_probs" with the following command: 

## Not run: 
output &lt;- hoeffding_tree(input_model=tree, test=test_set)
predictions &lt;- output$predictions
class_probs &lt;- output$probabilities

## End(Not run)
</code></pre>

<hr>
<h2 id='image_converter'>Image Converter</h2><span id='topic+image_converter'></span>

<h3>Description</h3>

<p>A utility to load an image or set of images into a single dataset that can
then be used by other mlpack methods and utilities. This can also unpack an
image dataset into individual files, for instance after mlpack methods have
been used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_converter(
  input,
  channels = NA,
  dataset = NA,
  height = NA,
  quality = NA,
  save = FALSE,
  verbose = getOption("mlpack.verbose", FALSE),
  width = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_converter_+3A_input">input</code></td>
<td>
<p>Image filenames which have to be loaded/saved (character
vector).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_channels">channels</code></td>
<td>
<p>Number of channels in the image.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_dataset">dataset</code></td>
<td>
<p>Input matrix to save as images (numeric matrix).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_height">height</code></td>
<td>
<p>Height of the images.  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_quality">quality</code></td>
<td>
<p>Compression of the image if saved as jpg (0-100). 
Default value &quot;90&quot; (integer).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_save">save</code></td>
<td>
<p>Save a dataset as images.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="image_converter_+3A_width">width</code></td>
<td>
<p>Width of the image.  Default value &quot;0&quot; (integer).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes an image or an array of images and loads them to a matrix.
You can optionally specify the height &quot;height&quot; width &quot;width&quot; and channel
&quot;channels&quot; of the images that needs to be loaded; otherwise, these parameters
will be automatically detected from the image.
There are other options too, that can be specified such as &quot;quality&quot;.
</p>
<p>You can also provide a dataset and save them as images using &quot;dataset&quot; and
&quot;save&quot; as an parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save images data to, Onlyneeded if you are
specifying 'save' option (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  An example to load an image : 

## Not run: 
output &lt;- image_converter(input=X, height=256, width=256, channels=3)
Y &lt;- output$output

## End(Not run)

#  An example to save an image is :

## Not run: 
image_converter(input=X, height=256, width=256, channels=3, dataset=Y,
  save=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='kde'>Kernel Density Estimation</h2><span id='topic+kde'></span>

<h3>Description</h3>

<p>An implementation of kernel density estimation with dual-tree algorithms.
Given a set of reference points and query points and a kernel function, this
can estimate the density function at the location of each query point using
trees; trees that are built can be saved for later use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde(
  abs_error = NA,
  algorithm = NA,
  bandwidth = NA,
  initial_sample_size = NA,
  input_model = NA,
  kernel = NA,
  mc_break_coef = NA,
  mc_entry_coef = NA,
  mc_probability = NA,
  monte_carlo = FALSE,
  query = NA,
  reference = NA,
  rel_error = NA,
  tree = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde_+3A_abs_error">abs_error</code></td>
<td>
<p>Relative error tolerance for the prediction.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to use for the prediction.('dual-tree',
'single-tree').  Default value &quot;dual-tree&quot; (character).</p>
</td></tr>
<tr><td><code id="kde_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth of the kernel.  Default value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_initial_sample_size">initial_sample_size</code></td>
<td>
<p>Initial sample size for Monte Carlo
estimations.  Default value &quot;100&quot; (integer).</p>
</td></tr>
<tr><td><code id="kde_+3A_input_model">input_model</code></td>
<td>
<p>Contains pre-trained KDE model (KDEModel).</p>
</td></tr>
<tr><td><code id="kde_+3A_kernel">kernel</code></td>
<td>
<p>Kernel to use for the prediction.('gaussian',
'epanechnikov', 'laplacian', 'spherical', 'triangular').  Default value
&quot;gaussian&quot; (character).</p>
</td></tr>
<tr><td><code id="kde_+3A_mc_break_coef">mc_break_coef</code></td>
<td>
<p>Controls what fraction of the amount of node's
descendants is the limit for the sample size before it recurses.  Default
value &quot;0.4&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_mc_entry_coef">mc_entry_coef</code></td>
<td>
<p>Controls how much larger does the amount of node
descendants has to be compared to the initial sample size in order to be a
candidate for Monte Carlo estimations.  Default value &quot;3&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_mc_probability">mc_probability</code></td>
<td>
<p>Probability of the estimation being bounded by
relative error when using Monte Carlo estimations.  Default value &quot;0.95&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_monte_carlo">monte_carlo</code></td>
<td>
<p>Whether to use Monte Carlo estimations when possible.
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kde_+3A_query">query</code></td>
<td>
<p>Query dataset to KDE on (numeric matrix).</p>
</td></tr>
<tr><td><code id="kde_+3A_reference">reference</code></td>
<td>
<p>Input reference dataset use for KDE (numeric matrix).</p>
</td></tr>
<tr><td><code id="kde_+3A_rel_error">rel_error</code></td>
<td>
<p>Relative error tolerance for the prediction.  Default
value &quot;0.05&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kde_+3A_tree">tree</code></td>
<td>
<p>Tree to use for the prediction.('kd-tree', 'ball-tree',
'cover-tree', 'octree', 'r-tree').  Default value &quot;kd-tree&quot; (character).</p>
</td></tr>
<tr><td><code id="kde_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs a Kernel Density Estimation. KDE is a non-parametric
way of estimating probability density function. For each query point the
program will estimate its probability density by applying a kernel function
to each reference point. The computational complexity of this is O(N^2) where
there are N query points and N reference points, but this implementation will
typically see better performance as it uses an approximate dual or single
tree algorithm for acceleration.
</p>
<p>Dual or single tree optimization avoids many barely relevant calculations (as
kernel function values decrease with distance), so it is an approximate
computation. You can specify the maximum relative error tolerance for each
query value with &quot;rel_error&quot; as well as the maximum absolute error tolerance
with the parameter &quot;abs_error&quot;. This program runs using an Euclidean metric.
Kernel function can be selected using the &quot;kernel&quot; option. You can also
choose what which type of tree to use for the dual-tree algorithm with
&quot;tree&quot;. It is also possible to select whether to use dual-tree algorithm or
single-tree algorithm using the &quot;algorithm&quot; option.
</p>
<p>Monte Carlo estimations can be used to accelerate the KDE estimate when the
Gaussian Kernel is used. This provides a probabilistic guarantee on the the
error of the resulting KDE instead of an absolute guarantee.To enable Monte
Carlo estimations, the &quot;monte_carlo&quot; flag can be used, and success
probability can be set with the &quot;mc_probability&quot; option. It is possible to
set the initial sample size for the Monte Carlo estimation using
&quot;initial_sample_size&quot;. This implementation will only consider a node, as a
candidate for the Monte Carlo estimation, if its number of descendant nodes
is bigger than the initial sample size. This can be controlled using a
coefficient that will multiply the initial sample size and can be set using
&quot;mc_entry_coef&quot;. To avoid using the same amount of computations an exact
approach would take, this program recurses the tree whenever a fraction of
the amount of the node's descendant points have already been computed. This
fraction is set using &quot;mc_break_coef&quot;.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>If specified, the KDE model will be saved here
(KDEModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Vector to store density predictions (numeric
column).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following will run KDE using the data in "ref_data" for
# training and the data in "qu_data" as query data. It will apply an
# Epanechnikov kernel with a 0.2 bandwidth to each reference point and use a
# KD-Tree for the dual-tree optimization. The returned predictions will be
# within 5% of the real KDE value for each query point.

## Not run: 
output &lt;- kde(reference=ref_data, query=qu_data, bandwidth=0.2,
  kernel="epanechnikov", tree="kd-tree", rel_error=0.05)
out_data &lt;- output$predictions

## End(Not run)

# the predicted density estimations will be stored in "out_data".
# If no "query" is provided, then KDE will be computed on the "reference"
# dataset.
# It is possible to select either a reference dataset or an input model but
# not both at the same time. If an input model is selected and parameter
# values are not set (e.g. "bandwidth") then default parameter values will be
# used.
# 
# In addition to the last program call, it is also possible to activate Monte
# Carlo estimations if a Gaussian kernel is used. This can provide faster
# results, but the KDE will only have a probabilistic guarantee of meeting
# the desired error bound (instead of an absolute guarantee). The following
# example will run KDE using a Monte Carlo estimation when possible. The
# results will be within a 5% of the real KDE value with a 95% probability.
# Initial sample size for the Monte Carlo estimation will be 200 points and a
# node will be a candidate for the estimation only when it contains 700 (i.e.
# 3.5*200) points. If a node contains 700 points and 420 (i.e. 0.6*700) have
# already been sampled, then the algorithm will recurse instead of keep
# sampling.

## Not run: 
output &lt;- kde(reference=ref_data, query=qu_data, bandwidth=0.2,
  kernel="gaussian", tree="kd-tree", rel_error=0.05, monte_carlo=,
  mc_probability=0.95, initial_sample_size=200, mc_entry_coef=3.5,
  mc_break_coef=0.6)
out_data &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel_pca'>Kernel Principal Components Analysis</h2><span id='topic+kernel_pca'></span>

<h3>Description</h3>

<p>An implementation of Kernel Principal Components Analysis (KPCA).  This can
be used to perform nonlinear dimensionality reduction or preprocessing on a
given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_pca(
  input,
  kernel,
  bandwidth = NA,
  center = FALSE,
  degree = NA,
  kernel_scale = NA,
  new_dimensionality = NA,
  nystroem_method = FALSE,
  offset = NA,
  sampling = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_pca_+3A_input">input</code></td>
<td>
<p>Input dataset to perform KPCA on (numeric matrix).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_kernel">kernel</code></td>
<td>
<p>The kernel to use; see the above documentation for the
list of usable kernels (character).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth, for 'gaussian' and 'laplacian' kernels. 
Default value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_center">center</code></td>
<td>
<p>If set, the transformed data will be centered about the
origin.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_degree">degree</code></td>
<td>
<p>Degree of polynomial, for 'polynomial' kernel.  Default
value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_kernel_scale">kernel_scale</code></td>
<td>
<p>Scale, for 'hyptan' kernel.  Default value &quot;1&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_new_dimensionality">new_dimensionality</code></td>
<td>
<p>If not 0, reduce the dimensionality of the
output dataset by ignoring the dimensions with the smallest eigenvalues. 
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_nystroem_method">nystroem_method</code></td>
<td>
<p>If set, the Nystroem method will be used. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_offset">offset</code></td>
<td>
<p>Offset, for 'hyptan' and 'polynomial' kernels.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_sampling">sampling</code></td>
<td>
<p>Sampling scheme to use for the Nystroem method:
'kmeans', 'random', 'ordered.  Default value &quot;kmeans&quot; (character).</p>
</td></tr>
<tr><td><code id="kernel_pca_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs Kernel Principal Components Analysis (KPCA) on the
specified dataset with the specified kernel.  This will transform the data
onto the kernel principal components, and optionally reduce the
dimensionality by ignoring the kernel principal components with the smallest
eigenvalues.
</p>
<p>For the case where a linear kernel is used, this reduces to regular PCA.
</p>
<p>The kernels that are supported are listed below:
</p>
<p>* 'linear': the standard linear dot product (same as normal PCA):
'K(x, y) = x^T y'
</p>
<p>* 'gaussian': a Gaussian kernel; requires bandwidth:
'K(x, y) = exp(-(|| x - y || ^ 2) / (2 * (bandwidth ^ 2)))'
</p>
<p>* 'polynomial': polynomial kernel; requires offset and degree:
'K(x, y) = (x^T y + offset) ^ degree'
</p>
<p>* 'hyptan': hyperbolic tangent kernel; requires scale and offset:
'K(x, y) = tanh(scale * (x^T y) + offset)'
</p>
<p>* 'laplacian': Laplacian kernel; requires bandwidth:
'K(x, y) = exp(-(|| x - y ||) / bandwidth)'
</p>
<p>* 'epanechnikov': Epanechnikov kernel; requires bandwidth:
'K(x, y) = max(0, 1 - || x - y ||^2 / bandwidth^2)'
</p>
<p>* 'cosine': cosine distance:
'K(x, y) = 1 - (x^T y) / (|| x || * || y ||)'
</p>
<p>The parameters for each of the kernels should be specified with the options
&quot;bandwidth&quot;, &quot;kernel_scale&quot;, &quot;offset&quot;, or &quot;degree&quot; (or a combination of those
parameters).
</p>
<p>Optionally, the Nystroem method (&quot;Using the Nystroem method to speed up
kernel machines&quot;, 2001) can be used to calculate the kernel matrix by
specifying the &quot;nystroem_method&quot; parameter. This approach works by using a
subset of the data as basis to reconstruct the kernel matrix; to specify the
sampling scheme, the &quot;sampling&quot; parameter is used.  The sampling scheme for
the Nystroem method can be chosen from the following list: 'kmeans',
'random', 'ordered'.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save modified dataset to (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following command will perform KPCA on the dataset "input"
# using the Gaussian kernel, and saving the transformed data to
# "transformed": 

## Not run: 
output &lt;- kernel_pca(input=input, kernel="gaussian")
transformed &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='kfn'>k-Furthest-Neighbors Search</h2><span id='topic+kfn'></span>

<h3>Description</h3>

<p>An implementation of k-furthest-neighbor search using single-tree and
dual-tree algorithms.  Given a set of reference points and query points, this
can find the k furthest neighbors in the reference set of each query point
using trees; trees that are built can be saved for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfn(
  algorithm = NA,
  epsilon = NA,
  input_model = NA,
  k = NA,
  leaf_size = NA,
  percentage = NA,
  query = NA,
  random_basis = FALSE,
  reference = NA,
  seed = NA,
  tree_type = NA,
  true_distances = NA,
  true_neighbors = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfn_+3A_algorithm">algorithm</code></td>
<td>
<p>Type of neighbor search: 'naive', 'single_tree',
'dual_tree', 'greedy'.  Default value &quot;dual_tree&quot; (character).</p>
</td></tr>
<tr><td><code id="kfn_+3A_epsilon">epsilon</code></td>
<td>
<p>If specified, will do approximate furthest neighbor
search with given relative error. Must be in the range [0,1).  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kfn_+3A_input_model">input_model</code></td>
<td>
<p>Pre-trained kFN model (KFNModel).</p>
</td></tr>
<tr><td><code id="kfn_+3A_k">k</code></td>
<td>
<p>Number of furthest neighbors to find.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="kfn_+3A_leaf_size">leaf_size</code></td>
<td>
<p>Leaf size for tree building (used for kd-trees, vp
trees, random projection trees, UB trees, R trees, R* trees, X trees,
Hilbert R trees, R+ trees, R++ trees, and octrees).  Default value &quot;20&quot;
(integer).</p>
</td></tr>
<tr><td><code id="kfn_+3A_percentage">percentage</code></td>
<td>
<p>If specified, will do approximate furthest neighbor
search. Must be in the range (0,1] (decimal form). Resultant neighbors will
be at least (p*100) 
Default value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="kfn_+3A_query">query</code></td>
<td>
<p>Matrix containing query points (optional) (numeric
matrix).</p>
</td></tr>
<tr><td><code id="kfn_+3A_random_basis">random_basis</code></td>
<td>
<p>Before tree-building, project the data onto a random
orthogonal basis.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kfn_+3A_reference">reference</code></td>
<td>
<p>Matrix containing the reference dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code id="kfn_+3A_seed">seed</code></td>
<td>
<p>Random seed (if 0, std::time(NULL) is used).  Default value
&quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="kfn_+3A_tree_type">tree_type</code></td>
<td>
<p>Type of tree to use: 'kd', 'vp', 'rp', 'max-rp', 'ub',
'cover', 'r', 'r-star', 'x', 'ball', 'hilbert-r', 'r-plus', 'r-plus-plus',
'oct'.  Default value &quot;kd&quot; (character).</p>
</td></tr>
<tr><td><code id="kfn_+3A_true_distances">true_distances</code></td>
<td>
<p>Matrix of true distances to compute the effective
error (average relative error) (it is printed when -v is specified)
(numeric matrix).</p>
</td></tr>
<tr><td><code id="kfn_+3A_true_neighbors">true_neighbors</code></td>
<td>
<p>Matrix of true neighbors to compute the recall (it
is printed when -v is specified) (integer matrix).</p>
</td></tr>
<tr><td><code id="kfn_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program will calculate the k-furthest-neighbors of a set of points. You
may specify a separate set of reference points and query points, or just a
reference set which will be used as both the reference and query set.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Matrix to output distances into (numeric matrix).</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>Matrix to output neighbors into (integer matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>If specified, the kFN model will be output here
(KFNModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following will calculate the 5 furthest neighbors of
# eachpoint in "input" and store the distances in "distances" and the
# neighbors in "neighbors": 

## Not run: 
output &lt;- kfn(k=5, reference=input)
distances &lt;- output$distances
neighbors &lt;- output$neighbors

## End(Not run)

# The output files are organized such that row i and column j in the
# neighbors output matrix corresponds to the index of the point in the
# reference set which is the j'th furthest neighbor from the point in the
# query set with index i.  Row i and column j in the distances output file
# corresponds to the distance between those two points.
</code></pre>

<hr>
<h2 id='kmeans'>K-Means Clustering</h2><span id='topic+kmeans'></span>

<h3>Description</h3>

<p>An implementation of several strategies for efficient k-means clustering.
Given a dataset and a value of k, this computes and returns a k-means
clustering on that data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans(
  clusters,
  input,
  algorithm = NA,
  allow_empty_clusters = FALSE,
  in_place = FALSE,
  initial_centroids = NA,
  kill_empty_clusters = FALSE,
  kmeans_plus_plus = FALSE,
  labels_only = FALSE,
  max_iterations = NA,
  percentage = NA,
  refined_start = FALSE,
  samplings = NA,
  seed = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans_+3A_clusters">clusters</code></td>
<td>
<p>Number of clusters to find (0 autodetects from initial
centroids) (integer).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_input">input</code></td>
<td>
<p>Input dataset to perform clustering on (numeric matrix).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm to use for the Lloyd iteration ('naive',
'pelleg-moore', 'elkan', 'hamerly', 'dualtree', or 'dualtree-covertree'). 
Default value &quot;naive&quot; (character).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_allow_empty_clusters">allow_empty_clusters</code></td>
<td>
<p>Allow empty clusters to be persist.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_in_place">in_place</code></td>
<td>
<p>If specified, a column containing the learned cluster
assignments will be added to the input dataset file.  In this case,
&ndash;output_file is overridden. (Do not use in Python..  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_initial_centroids">initial_centroids</code></td>
<td>
<p>Start with the specified initial centroids
(numeric matrix).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_kill_empty_clusters">kill_empty_clusters</code></td>
<td>
<p>Remove empty clusters when they occur. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_kmeans_plus_plus">kmeans_plus_plus</code></td>
<td>
<p>Use the k-means++ initialization strategy to
choose initial points.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_labels_only">labels_only</code></td>
<td>
<p>Only output labels into output file.  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations before k-means
terminates.  Default value &quot;1000&quot; (integer).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_percentage">percentage</code></td>
<td>
<p>Percentage of dataset to use for each refined start
sampling (use when &ndash;refined_start is specified).  Default value &quot;0.02&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_refined_start">refined_start</code></td>
<td>
<p>Use the refined initial point strategy by Bradley
and Fayyad to choose initial points.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_samplings">samplings</code></td>
<td>
<p>Number of samplings to perform for refined start (use
when &ndash;refined_start is specified).  Default value &quot;100&quot; (integer).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="kmeans_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs K-Means clustering on the given dataset.  It can return
the learned cluster assignments, and the centroids of the clusters.  Empty
clusters are not allowed by default; when a cluster becomes empty, the point
furthest from the centroid of the cluster with maximum variance is taken to
fill that cluster.
</p>
<p>Optionally, the strategy to choose initial centroids can be specified.  The
k-means++ algorithm can be used to choose initial centroids with the
&quot;kmeans_plus_plus&quot; parameter.  The Bradley and Fayyad approach (&quot;Refining
initial points for k-means clustering&quot;, 1998) can be used to select initial
points by specifying the &quot;refined_start&quot; parameter.  This approach works by
taking random samplings of the dataset; to specify the number of samplings,
the &quot;samplings&quot; parameter is used, and to specify the percentage of the
dataset to be used in each sample, the &quot;percentage&quot; parameter is used (it
should be a value between 0.0 and 1.0).
</p>
<p>There are several options available for the algorithm used for each Lloyd
iteration, specified with the &quot;algorithm&quot;  option.  The standard O(kN)
approach can be used ('naive').  Other options include the Pelleg-Moore
tree-based algorithm ('pelleg-moore'), Elkan's triangle-inequality based
algorithm ('elkan'), Hamerly's modification to Elkan's algorithm ('hamerly'),
the dual-tree k-means algorithm ('dualtree'), and the dual-tree k-means
algorithm using the cover tree ('dualtree-covertree').
</p>
<p>The behavior for when an empty cluster is encountered can be modified with
the &quot;allow_empty_clusters&quot; option.  When this option is specified and there
is a cluster owning no points at the end of an iteration, that cluster's
centroid will simply remain in its position from the previous iteration. If
the &quot;kill_empty_clusters&quot; option is specified, then when a cluster owns no
points at the end of an iteration, the cluster centroid is simply filled with
DBL_MAX, killing it and effectively reducing k for the rest of the
computation.  Note that the default option when neither empty cluster option
is specified can be time-consuming to calculate; therefore, specifying either
of these parameters will often accelerate runtime.
</p>
<p>Initial clustering assignments may be specified using the &quot;initial_centroids&quot;
parameter, and the maximum number of iterations may be specified with the
&quot;max_iterations&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>centroid</code></td>
<td>
<p>If specified, the centroids of each cluster will  be
written to the given file (numeric matrix).</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>Matrix to store output labels or labeled data to (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, to use Hamerly's algorithm to perform k-means clustering
# with k=10 on the dataset "data", saving the centroids to "centroids" and
# the assignments for each point to "assignments", the following command
# could be used:

## Not run: 
output &lt;- kmeans(input=data, clusters=10)
assignments &lt;- output$output
centroids &lt;- output$centroid

## End(Not run)

# To run k-means on that same dataset with initial centroids specified in
# "initial" with a maximum of 500 iterations, storing the output centroids in
# "final" the following command may be used:

## Not run: 
output &lt;- kmeans(input=data, initial_centroids=initial, clusters=10,
  max_iterations=500)
final &lt;- output$centroid

## End(Not run)
</code></pre>

<hr>
<h2 id='knn'>k-Nearest-Neighbors Search</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p>An implementation of k-nearest-neighbor search using single-tree and
dual-tree algorithms.  Given a set of reference points and query points, this
can find the k nearest neighbors in the reference set of each query point
using trees; trees that are built can be saved for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(
  algorithm = NA,
  epsilon = NA,
  input_model = NA,
  k = NA,
  leaf_size = NA,
  query = NA,
  random_basis = FALSE,
  reference = NA,
  rho = NA,
  seed = NA,
  tau = NA,
  tree_type = NA,
  true_distances = NA,
  true_neighbors = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_algorithm">algorithm</code></td>
<td>
<p>Type of neighbor search: 'naive', 'single_tree',
'dual_tree', 'greedy'.  Default value &quot;dual_tree&quot; (character).</p>
</td></tr>
<tr><td><code id="knn_+3A_epsilon">epsilon</code></td>
<td>
<p>If specified, will do approximate nearest neighbor search
with given relative error.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="knn_+3A_input_model">input_model</code></td>
<td>
<p>Pre-trained kNN model (KNNModel).</p>
</td></tr>
<tr><td><code id="knn_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbors to find.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="knn_+3A_leaf_size">leaf_size</code></td>
<td>
<p>Leaf size for tree building (used for kd-trees, vp
trees, random projection trees, UB trees, R trees, R* trees, X trees,
Hilbert R trees, R+ trees, R++ trees, spill trees, and octrees).  Default
value &quot;20&quot; (integer).</p>
</td></tr>
<tr><td><code id="knn_+3A_query">query</code></td>
<td>
<p>Matrix containing query points (optional) (numeric
matrix).</p>
</td></tr>
<tr><td><code id="knn_+3A_random_basis">random_basis</code></td>
<td>
<p>Before tree-building, project the data onto a random
orthogonal basis.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="knn_+3A_reference">reference</code></td>
<td>
<p>Matrix containing the reference dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code id="knn_+3A_rho">rho</code></td>
<td>
<p>Balance threshold (only valid for spill trees).  Default
value &quot;0.7&quot; (numeric).</p>
</td></tr>
<tr><td><code id="knn_+3A_seed">seed</code></td>
<td>
<p>Random seed (if 0, std::time(NULL) is used).  Default value
&quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="knn_+3A_tau">tau</code></td>
<td>
<p>Overlapping size (only valid for spill trees).  Default value
&quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="knn_+3A_tree_type">tree_type</code></td>
<td>
<p>Type of tree to use: 'kd', 'vp', 'rp', 'max-rp', 'ub',
'cover', 'r', 'r-star', 'x', 'ball', 'hilbert-r', 'r-plus', 'r-plus-plus',
'spill', 'oct'.  Default value &quot;kd&quot; (character).</p>
</td></tr>
<tr><td><code id="knn_+3A_true_distances">true_distances</code></td>
<td>
<p>Matrix of true distances to compute the effective
error (average relative error) (it is printed when -v is specified)
(numeric matrix).</p>
</td></tr>
<tr><td><code id="knn_+3A_true_neighbors">true_neighbors</code></td>
<td>
<p>Matrix of true neighbors to compute the recall (it
is printed when -v is specified) (integer matrix).</p>
</td></tr>
<tr><td><code id="knn_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program will calculate the k-nearest-neighbors of a set of points using
kd-trees or cover trees (cover tree support is experimental and may be slow).
You may specify a separate set of reference points and query points, or just
a reference set which will be used as both the reference and query set.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Matrix to output distances into (numeric matrix).</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>Matrix to output neighbors into (integer matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>If specified, the kNN model will be output here
(KNNModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following command will calculate the 5 nearest neighbors
# of each point in "input" and store the distances in "distances" and the
# neighbors in "neighbors": 

## Not run: 
output &lt;- knn(k=5, reference=input)
neighbors &lt;- output$neighbors
distances &lt;- output$distances

## End(Not run)

# The output is organized such that row i and column j in the neighbors
# output matrix corresponds to the index of the point in the reference set
# which is the j'th nearest neighbor from the point in the query set with
# index i.  Row j and column i in the distances output matrix corresponds to
# the distance between those two points.
</code></pre>

<hr>
<h2 id='krann'>K-Rank-Approximate-Nearest-Neighbors (kRANN)</h2><span id='topic+krann'></span>

<h3>Description</h3>

<p>An implementation of rank-approximate k-nearest-neighbor search (kRANN) 
using single-tree and dual-tree algorithms.  Given a set of reference points
and query points, this can find the k nearest neighbors in the reference set
of each query point using trees; trees that are built can be saved for future
use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krann(
  alpha = NA,
  first_leaf_exact = FALSE,
  input_model = NA,
  k = NA,
  leaf_size = NA,
  naive = FALSE,
  query = NA,
  random_basis = FALSE,
  reference = NA,
  sample_at_leaves = FALSE,
  seed = NA,
  single_mode = FALSE,
  single_sample_limit = NA,
  tau = NA,
  tree_type = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krann_+3A_alpha">alpha</code></td>
<td>
<p>The desired success probability.  Default value &quot;0.95&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="krann_+3A_first_leaf_exact">first_leaf_exact</code></td>
<td>
<p>The flag to trigger sampling only after exactly
exploring the first leaf.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="krann_+3A_input_model">input_model</code></td>
<td>
<p>Pre-trained kNN model (RAModel).</p>
</td></tr>
<tr><td><code id="krann_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbors to find.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="krann_+3A_leaf_size">leaf_size</code></td>
<td>
<p>Leaf size for tree building (used for kd-trees, UB
trees, R trees, R* trees, X trees, Hilbert R trees, R+ trees, R++ trees,
and octrees).  Default value &quot;20&quot; (integer).</p>
</td></tr>
<tr><td><code id="krann_+3A_naive">naive</code></td>
<td>
<p>If true, sampling will be done without using a tree. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="krann_+3A_query">query</code></td>
<td>
<p>Matrix containing query points (optional) (numeric
matrix).</p>
</td></tr>
<tr><td><code id="krann_+3A_random_basis">random_basis</code></td>
<td>
<p>Before tree-building, project the data onto a random
orthogonal basis.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="krann_+3A_reference">reference</code></td>
<td>
<p>Matrix containing the reference dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code id="krann_+3A_sample_at_leaves">sample_at_leaves</code></td>
<td>
<p>The flag to trigger sampling at leaves.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="krann_+3A_seed">seed</code></td>
<td>
<p>Random seed (if 0, std::time(NULL) is used).  Default value
&quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="krann_+3A_single_mode">single_mode</code></td>
<td>
<p>If true, single-tree search is used (as opposed to
dual-tree search.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="krann_+3A_single_sample_limit">single_sample_limit</code></td>
<td>
<p>The limit on the maximum number of samples
(and hence the largest node you can approximate).  Default value &quot;20&quot;
(integer).</p>
</td></tr>
<tr><td><code id="krann_+3A_tau">tau</code></td>
<td>
<p>The allowed rank-error in terms of the percentile of the
data.  Default value &quot;5&quot; (numeric).</p>
</td></tr>
<tr><td><code id="krann_+3A_tree_type">tree_type</code></td>
<td>
<p>Type of tree to use: 'kd', 'ub', 'cover', 'r', 'x',
'r-star', 'hilbert-r', 'r-plus', 'r-plus-plus', 'oct'.  Default value &quot;kd&quot;
(character).</p>
</td></tr>
<tr><td><code id="krann_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program will calculate the k rank-approximate-nearest-neighbors of a set
of points. You may specify a separate set of reference points and query
points, or just a reference set which will be used as both the reference and
query set. You must specify the rank approximation (in 
success probability).
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Matrix to output distances into (numeric matrix).</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>Matrix to output neighbors into (integer matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>If specified, the kNN model will be output here
(RAModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following will return 5 neighbors from the top 0.1% of the
# data (with probability 0.95) for each point in "input" and store the
# distances in "distances" and the neighbors in "neighbors.csv":

## Not run: 
output &lt;- krann(reference=input, k=5, tau=0.1)
distances &lt;- output$distances
neighbors &lt;- output$neighbors

## End(Not run)

# Note that tau must be set such that the number of points in the
# corresponding percentile of the data is greater than k.  Thus, if we choose
# tau = 0.1 with a dataset of 1000 points and k = 5, then we are attempting
# to choose 5 nearest neighbors out of the closest 1 point -- this is invalid
# and the program will terminate with an error message.
# 
# The output matrices are organized such that row i and column j in the
# neighbors output file corresponds to the index of the point in the
# reference set which is the i'th nearest neighbor from the point in the
# query set with index j.  Row i and column j in the distances output file
# corresponds to the distance between those two points.
</code></pre>

<hr>
<h2 id='lars'>LARS</h2><span id='topic+lars'></span>

<h3>Description</h3>

<p>An implementation of Least Angle Regression (Stagewise/laSso), also known as
LARS.  This can train a LARS/LASSO/Elastic Net model and use that model or a
pre-trained model to output regression predictions for a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lars(
  input = NA,
  input_model = NA,
  lambda1 = NA,
  lambda2 = NA,
  no_intercept = FALSE,
  no_normalize = FALSE,
  responses = NA,
  test = NA,
  use_cholesky = FALSE,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lars_+3A_input">input</code></td>
<td>
<p>Matrix of covariates (X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="lars_+3A_input_model">input_model</code></td>
<td>
<p>Trained LARS model to use (LARS).</p>
</td></tr>
<tr><td><code id="lars_+3A_lambda1">lambda1</code></td>
<td>
<p>Regularization parameter for l1-norm penalty.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lars_+3A_lambda2">lambda2</code></td>
<td>
<p>Regularization parameter for l2-norm penalty.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lars_+3A_no_intercept">no_intercept</code></td>
<td>
<p>Do not fit an intercept in the model.  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="lars_+3A_no_normalize">no_normalize</code></td>
<td>
<p>Do not normalize data to unit variance before
modeling.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="lars_+3A_responses">responses</code></td>
<td>
<p>Matrix of responses/observations (y) (numeric matrix).</p>
</td></tr>
<tr><td><code id="lars_+3A_test">test</code></td>
<td>
<p>Matrix containing points to regress on (test points)
(numeric matrix).</p>
</td></tr>
<tr><td><code id="lars_+3A_use_cholesky">use_cholesky</code></td>
<td>
<p>Use Cholesky decomposition during computation rather
than explicitly computing the full Gram matrix.  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="lars_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of LARS: Least Angle Regression (Stagewise/laSso).  This is
a stage-wise homotopy-based algorithm for L1-regularized linear regression
(LASSO) and L1+L2-regularized linear regression (Elastic Net).
</p>
<p>This program is able to train a LARS/LASSO/Elastic Net model or load a model
from file, output regression predictions for a test set, and save the trained
model to a file.  The LARS algorithm is described in more detail below:
</p>
<p>Let X be a matrix where each row is a point and each column is a dimension,
and let y be a vector of targets.
</p>
<p>The Elastic Net problem is to solve
</p>
<p>min_beta 0.5 || X * beta - y ||_2^2 + lambda_1 ||beta||_1 +
0.5 lambda_2 ||beta||_2^2
</p>
<p>If lambda1 &gt; 0 and lambda2 = 0, the problem is the LASSO.
If lambda1 &gt; 0 and lambda2 &gt; 0, the problem is the Elastic Net.
If lambda1 = 0 and lambda2 &gt; 0, the problem is ridge regression.
If lambda1 = 0 and lambda2 = 0, the problem is unregularized linear
regression.
</p>
<p>For efficiency reasons, it is not recommended to use this algorithm with
&quot;lambda1&quot; = 0.  In that case, use the 'linear_regression' program, which
implements both unregularized linear regression and ridge regression.
</p>
<p>To train a LARS/LASSO/Elastic Net model, the &quot;input&quot; and &quot;responses&quot;
parameters must be given.  The &quot;lambda1&quot;, &quot;lambda2&quot;, and &quot;use_cholesky&quot;
parameters control the training options.  A trained model can be saved with
the &quot;output_model&quot;.  If no training is desired at all, a model can be passed
via the &quot;input_model&quot; parameter.
</p>
<p>The program can also provide predictions for test data using either the
trained model or the given input model.  Test points can be specified with
the &quot;test&quot; parameter.  Predicted responses to the test points can be saved
with the &quot;output_predictions&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output LARS model (LARS).</p>
</td></tr>
<tr><td><code>output_predictions</code></td>
<td>
<p>If &ndash;test_file is specified, this file is
where the predicted responses will be saved (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following command trains a model on the data "data" and
# responses "responses" with lambda1 set to 0.4 and lambda2 set to 0 (so,
# LASSO is being solved), and then the model is saved to "lasso_model":

## Not run: 
output &lt;- lars(input=data, responses=responses, lambda1=0.4, lambda2=0)
lasso_model &lt;- output$output_model

## End(Not run)

# The following command uses the "lasso_model" to provide predicted responses
# for the data "test" and save those responses to "test_predictions": 

## Not run: 
output &lt;- lars(input_model=lasso_model, test=test)
test_predictions &lt;- output$output_predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='linear_regression'>Simple Linear Regression and Prediction</h2><span id='topic+linear_regression'></span>

<h3>Description</h3>

<p>An implementation of simple linear regression and ridge regression using
ordinary least squares.  Given a dataset and responses, a model can be
trained and saved for later use, or a pre-trained model can be used to output
regression predictions for a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_regression(
  input_model = NA,
  lambda = NA,
  test = NA,
  training = NA,
  training_responses = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_regression_+3A_input_model">input_model</code></td>
<td>
<p>Existing LinearRegression model to use
(LinearRegression).</p>
</td></tr>
<tr><td><code id="linear_regression_+3A_lambda">lambda</code></td>
<td>
<p>Tikhonov regularization for ridge regression.  If 0, the
method reduces to linear regression.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="linear_regression_+3A_test">test</code></td>
<td>
<p>Matrix containing X' (test regressors) (numeric matrix).</p>
</td></tr>
<tr><td><code id="linear_regression_+3A_training">training</code></td>
<td>
<p>Matrix containing training set X (regressors) (numeric
matrix).</p>
</td></tr>
<tr><td><code id="linear_regression_+3A_training_responses">training_responses</code></td>
<td>
<p>Optional vector containing y (responses). If
not given, the responses are assumed to be the last row of the input file
(numeric row).</p>
</td></tr>
<tr><td><code id="linear_regression_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of simple linear regression and simple ridge regression
using ordinary least squares. This solves the problem
</p>
<p>y = X * b + e
</p>
<p>where X (specified by &quot;training&quot;) and y (specified either as the last column
of the input matrix &quot;training&quot; or via the &quot;training_responses&quot; parameter) are
known and b is the desired variable.  If the covariance matrix (X'X) is not
invertible, or if the solution is overdetermined, then specify a Tikhonov
regularization constant (with &quot;lambda&quot;) greater than 0, which will regularize
the covariance matrix to make it invertible.  The calculated b may be saved
with the &quot;output_predictions&quot; output parameter.
</p>
<p>Optionally, the calculated value of b is used to predict the responses for
another matrix X' (specified by the &quot;test&quot; parameter):
</p>
<p>y' = X' * b
</p>
<p>and the predicted responses y' may be saved with the &quot;output_predictions&quot;
output parameter.  This type of regression is related to least-angle
regression, which mlpack implements as the 'lars' program.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output LinearRegression model (LinearRegression).</p>
</td></tr>
<tr><td><code>output_predictions</code></td>
<td>
<p>If &ndash;test_file is specified, this matrix is
where the predicted responses will be saved (numeric row).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to run a linear regression on the dataset "X" with responses
# "y", saving the trained model to "lr_model", the following command could be
# used:

## Not run: 
output &lt;- linear_regression(training=X, training_responses=y)
lr_model &lt;- output$output_model

## End(Not run)

# Then, to use "lr_model" to predict responses for a test set "X_test",
# saving the predictions to "X_test_responses", the following command could
# be used:

## Not run: 
output &lt;- linear_regression(input_model=lr_model, test=X_test)
X_test_responses &lt;- output$output_predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='linear_svm'>Linear SVM is an L2-regularized support vector machine.</h2><span id='topic+linear_svm'></span>

<h3>Description</h3>

<p>An implementation of linear SVM for multiclass classification. Given labeled
data, a model can be trained and saved for future use; or, a pre-trained
model can be used to classify new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_svm(
  delta = NA,
  epochs = NA,
  input_model = NA,
  labels = NA,
  lambda = NA,
  max_iterations = NA,
  no_intercept = FALSE,
  num_classes = NA,
  optimizer = NA,
  seed = NA,
  shuffle = FALSE,
  step_size = NA,
  test = NA,
  test_labels = NA,
  tolerance = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_svm_+3A_delta">delta</code></td>
<td>
<p>Margin of difference between correct class and other
classes.  Default value &quot;1&quot; (numeric).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_epochs">epochs</code></td>
<td>
<p>Maximum number of full epochs over dataset for psg. 
Default value &quot;50&quot; (integer).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_input_model">input_model</code></td>
<td>
<p>Existing model (parameters) (LinearSVMModel).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_labels">labels</code></td>
<td>
<p>A matrix containing labels (0 or 1) for the points in the
training set (y) (integer row).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_lambda">lambda</code></td>
<td>
<p>L2-regularization parameter for training.  Default value
&quot;0.0001&quot; (numeric).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum iterations for optimizer (0 indicates no
limit).  Default value &quot;10000&quot; (integer).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_no_intercept">no_intercept</code></td>
<td>
<p>Do not add the intercept term to the model.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_num_classes">num_classes</code></td>
<td>
<p>Number of classes for classification; if unspecified
(or 0), the number of classes found in the labels will be used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_optimizer">optimizer</code></td>
<td>
<p>Optimizer to use for training ('lbfgs' or 'psgd'). 
Default value &quot;lbfgs&quot; (character).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_shuffle">shuffle</code></td>
<td>
<p>Don't shuffle the order in which data points are visited
for parallel SGD.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_step_size">step_size</code></td>
<td>
<p>Step size for parallel SGD optimizer.  Default value
&quot;0.01&quot; (numeric).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_test">test</code></td>
<td>
<p>Matrix containing test dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_test_labels">test_labels</code></td>
<td>
<p>Matrix containing test labels (integer row).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_tolerance">tolerance</code></td>
<td>
<p>Convergence tolerance for optimizer.  Default value
&quot;1e-10&quot; (numeric).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_training">training</code></td>
<td>
<p>A matrix containing the training set (the matrix of
predictors, X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="linear_svm_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of linear SVMs that uses either L-BFGS or parallel SGD
(stochastic gradient descent) to train the model.
</p>
<p>This program allows loading a linear SVM model (via the &quot;input_model&quot;
parameter) or training a linear SVM model given training data (specified with
the &quot;training&quot; parameter), or both those things at once.  In addition, this
program allows classification on a test dataset (specified with the &quot;test&quot;
parameter) and the classification results may be saved with the &quot;predictions&quot;
output parameter. The trained linear SVM model may be saved using the
&quot;output_model&quot; output parameter.
</p>
<p>The training data, if specified, may have class labels as its last dimension.
Alternately, the &quot;labels&quot; parameter may be used to specify a separate vector
of labels.
</p>
<p>When a model is being trained, there are many options.  L2 regularization (to
prevent overfitting) can be specified with the &quot;lambda&quot; option, and the
number of classes can be manually specified with the &quot;num_classes&quot;and if an
intercept term is not desired in the model, the &quot;no_intercept&quot; parameter can
be specified.Margin of difference between correct class and other classes can
be specified with the &quot;delta&quot; option.The optimizer used to train the model
can be specified with the &quot;optimizer&quot; parameter.  Available options are
'psgd' (parallel stochastic gradient descent) and 'lbfgs' (the L-BFGS
optimizer).  There are also various parameters for the optimizer; the
&quot;max_iterations&quot; parameter specifies the maximum number of allowed
iterations, and the &quot;tolerance&quot; parameter specifies the tolerance for
convergence.  For the parallel SGD optimizer, the &quot;step_size&quot; parameter
controls the step size taken at each iteration by the optimizer and the
maximum number of epochs (specified with &quot;epochs&quot;). If the objective function
for your data is oscillating between Inf and 0, the step size is probably too
large.  There are more parameters for the optimizers, but the C++ interface
must be used to access these.
</p>
<p>Optionally, the model can be used to predict the labels for another matrix of
data points, if &quot;test&quot; is specified.  The &quot;test&quot; parameter can be specified
without the &quot;training&quot; parameter, so long as an existing linear SVM model is
given with the &quot;input_model&quot; parameter.  The output predictions from the
linear SVM model may be saved with the &quot;predictions&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained linear svm model
(LinearSVMModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>If test data is specified, this matrix is where the
predictions for the test set will be saved (integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>If test data is specified, this matrix is where the
class probabilities for the test set will be saved (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, to train a LinaerSVM on the data '"data"' with labels
# '"labels"' with L2 regularization of 0.1, saving the model to
# '"lsvm_model"', the following command may be used:

## Not run: 
output &lt;- linear_svm(training=data, labels=labels, lambda=0.1, delta=1,
  num_classes=0)
lsvm_model &lt;- output$output_model

## End(Not run)

# Then, to use that model to predict classes for the dataset '"test"',
# storing the output predictions in '"predictions"', the following command
# may be used: 

## Not run: 
output &lt;- linear_svm(input_model=lsvm_model, test=test)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='lmnn'>Large Margin Nearest Neighbors (LMNN)</h2><span id='topic+lmnn'></span>

<h3>Description</h3>

<p>An implementation of Large Margin Nearest Neighbors (LMNN), a distance
learning technique.  Given a labeled dataset, this learns a transformation of
the data that improves k-nearest-neighbor performance; this can be useful as
a preprocessing step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmnn(
  input,
  batch_size = NA,
  center = FALSE,
  distance = NA,
  k = NA,
  labels = NA,
  linear_scan = FALSE,
  max_iterations = NA,
  normalize = FALSE,
  optimizer = NA,
  passes = NA,
  print_accuracy = FALSE,
  range = NA,
  rank = NA,
  regularization = NA,
  seed = NA,
  step_size = NA,
  tolerance = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmnn_+3A_input">input</code></td>
<td>
<p>Input dataset to run LMNN on (numeric matrix).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_batch_size">batch_size</code></td>
<td>
<p>Batch size for mini-batch SGD.  Default value &quot;50&quot;
(integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_center">center</code></td>
<td>
<p>Perform mean-centering on the dataset. It is useful when
the centroid of the data is far from the origin.  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_distance">distance</code></td>
<td>
<p>Initial distance matrix to be used as starting poin
(numeric matrix).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_k">k</code></td>
<td>
<p>Number of target neighbors to use for each datapoint.  Default
value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_labels">labels</code></td>
<td>
<p>Labels for input dataset (integer row).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_linear_scan">linear_scan</code></td>
<td>
<p>Don't shuffle the order in which data points are
visited for SGD or mini-batch SGD.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for L-BFGS (0
indicates no limit).  Default value &quot;100000&quot; (integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_normalize">normalize</code></td>
<td>
<p>Use a normalized starting point for optimization. Itis
useful for when points are far apart, or when SGD is returning NaN. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_optimizer">optimizer</code></td>
<td>
<p>Optimizer to use; 'amsgrad', 'bbsgd', 'sgd', or
'lbfgs'.  Default value &quot;amsgrad&quot; (character).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_passes">passes</code></td>
<td>
<p>Maximum number of full passes over dataset for AMSGrad,
BB_SGD and SGD.  Default value &quot;50&quot; (integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_print_accuracy">print_accuracy</code></td>
<td>
<p>Print accuracies on initial and transformed
datase.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_range">range</code></td>
<td>
<p>Number of iterations after which impostors needs to be
recalculate.  Default value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_rank">rank</code></td>
<td>
<p>Rank of distance matrix to be optimized..  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_regularization">regularization</code></td>
<td>
<p>Regularization for LMNN objective function. 
Default value &quot;0.5&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_step_size">step_size</code></td>
<td>
<p>Step size for AMSGrad, BB_SGD and SGD (alpha).  Default
value &quot;0.01&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_tolerance">tolerance</code></td>
<td>
<p>Maximum tolerance for termination of AMSGrad, BB_SGD,
SGD or L-BFGS.  Default value &quot;1e-07&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lmnn_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements Large Margin Nearest Neighbors, a distance learning
technique.  The method seeks to improve k-nearest-neighbor classification on
a dataset.  The method employes the strategy of reducing distance between
similar labeled data points (a.k.a target neighbors) and increasing distance
between differently labeled points (a.k.a impostors) using standard
optimization techniques over the gradient of the distance between data
points.
</p>
<p>To work, this algorithm needs labeled data.  It can be given as the last row
of the input dataset (specified with &quot;input&quot;), or alternatively as a separate
matrix (specified with &quot;labels&quot;).  Additionally, a starting point for
optimization (specified with &quot;distance&quot;can be given, having (r x d)
dimensionality.  Here r should satisfy 1 &lt;= r &lt;= d, Consequently a Low-Rank
matrix will be optimized. Alternatively, Low-Rank distance can be learned by
specifying the &quot;rank&quot;parameter (A Low-Rank matrix with uniformly distributed
values will be used as initial learning point). 
</p>
<p>The program also requires number of targets neighbors to work with (
specified with &quot;k&quot;), A regularization parameter can also be passed, It acts
as a trade of between the pulling and pushing terms (specified with
&quot;regularization&quot;), In addition, this implementation of LMNN includes a
parameter to decide the interval after which impostors must be re-calculated
(specified with &quot;range&quot;).
</p>
<p>Output can either be the learned distance matrix (specified with &quot;output&quot;),
or the transformed dataset  (specified with &quot;transformed_data&quot;), or both.
Additionally mean-centered dataset (specified with &quot;centered_data&quot;) can be
accessed given mean-centering (specified with &quot;center&quot;) is performed on the
dataset. Accuracy on initial dataset and final transformed dataset can be
printed by specifying the &quot;print_accuracy&quot;parameter. 
</p>
<p>This implementation of LMNN uses AdaGrad, BigBatch_SGD, stochastic gradient
descent, mini-batch stochastic gradient descent, or the L_BFGS optimizer. 
</p>
<p>AdaGrad, specified by the value 'adagrad' for the parameter &quot;optimizer&quot;, uses
maximum of past squared gradients. It primarily on six parameters: the step
size (specified with &quot;step_size&quot;), the batch size (specified with
&quot;batch_size&quot;), the maximum number of passes (specified with &quot;passes&quot;).
Inaddition, a normalized starting point can be used by specifying the
&quot;normalize&quot; parameter. 
</p>
<p>BigBatch_SGD, specified by the value 'bbsgd' for the parameter &quot;optimizer&quot;,
depends primarily on four parameters: the step size (specified with
&quot;step_size&quot;), the batch size (specified with &quot;batch_size&quot;), the maximum
number of passes (specified with &quot;passes&quot;).  In addition, a normalized
starting point can be used by specifying the &quot;normalize&quot; parameter. 
</p>
<p>Stochastic gradient descent, specified by the value 'sgd' for the parameter
&quot;optimizer&quot;, depends primarily on three parameters: the step size (specified
with &quot;step_size&quot;), the batch size (specified with &quot;batch_size&quot;), and the
maximum number of passes (specified with &quot;passes&quot;).  In addition, a
normalized starting point can be used by specifying the &quot;normalize&quot;
parameter. Furthermore, mean-centering can be performed on the dataset by
specifying the &quot;center&quot;parameter. 
</p>
<p>The L-BFGS optimizer, specified by the value 'lbfgs' for the parameter
&quot;optimizer&quot;, uses a back-tracking line search algorithm to minimize a
function.  The following parameters are used by L-BFGS: &quot;max_iterations&quot;,
&quot;tolerance&quot;(the optimization is terminated when the gradient norm is below
this value).  For more details on the L-BFGS optimizer, consult either the
mlpack L-BFGS documentation (in lbfgs.hpp) or the vast set of published
literature on L-BFGS.  In addition, a normalized starting point can be used
by specifying the &quot;normalize&quot; parameter.
</p>
<p>By default, the AMSGrad optimizer is used.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>centered_data</code></td>
<td>
<p>Output matrix for mean-centered dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>Output matrix for learned distance matrix (numeric
matrix).</p>
</td></tr>
<tr><td><code>transformed_data</code></td>
<td>
<p>Output matrix for transformed dataset (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example - Let's say we want to learn distance on iris dataset with number
# of targets as 3 using BigBatch_SGD optimizer. A simple call for the same
# will look like: 

## Not run: 
output &lt;- lmnn(input=iris, labels=iris_labels, k=3, optimizer="bbsgd")
output &lt;- output$output

## End(Not run)

# An another program call making use of range &amp; regularization parameter with
# dataset having labels as last column can be made as: 

## Not run: 
output &lt;- lmnn(input=letter_recognition, k=5, range=10, regularization=0.4)
output &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='local_coordinate_coding'>Local Coordinate Coding</h2><span id='topic+local_coordinate_coding'></span>

<h3>Description</h3>

<p>An implementation of Local Coordinate Coding (LCC), a data transformation
technique.  Given input data, this transforms each point to be expressed as a
linear combination of a few points in the dataset; once an LCC model is
trained, it can be used to transform points later also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_coordinate_coding(
  atoms = NA,
  initial_dictionary = NA,
  input_model = NA,
  lambda = NA,
  max_iterations = NA,
  normalize = FALSE,
  seed = NA,
  test = NA,
  tolerance = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_coordinate_coding_+3A_atoms">atoms</code></td>
<td>
<p>Number of atoms in the dictionary.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_initial_dictionary">initial_dictionary</code></td>
<td>
<p>Optional initial dictionary (numeric matrix).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_input_model">input_model</code></td>
<td>
<p>Input LCC model (LocalCoordinateCoding).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_lambda">lambda</code></td>
<td>
<p>Weighted l1-norm regularization parameter.  Default value
&quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for LCC (0 indicates
no limit).  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_normalize">normalize</code></td>
<td>
<p>If set, the input data matrix will be normalized before
coding.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_test">test</code></td>
<td>
<p>Test points to encode (numeric matrix).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance for objective function.  Default value &quot;0.01&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_training">training</code></td>
<td>
<p>Matrix of training data (X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="local_coordinate_coding_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of Local Coordinate Coding (LCC), which codes data that
approximately lives on a manifold using a variation of l1-norm regularized
sparse coding.  Given a dense data matrix X with n points and d dimensions,
LCC seeks to find a dense dictionary matrix D with k atoms in d dimensions,
and a coding matrix Z with n points in k dimensions.  Because of the
regularization method used, the atoms in D should lie close to the manifold
on which the data points lie.
</p>
<p>The original data matrix X can then be reconstructed as D * Z.  Therefore,
this program finds a representation of each point in X as a sparse linear
combination of atoms in the dictionary D.
</p>
<p>The coding is found with an algorithm which alternates between a dictionary
step, which updates the dictionary D, and a coding step, which updates the
coding matrix Z.
</p>
<p>To run this program, the input matrix X must be specified (with -i), along
with the number of atoms in the dictionary (-k).  An initial dictionary may
also be specified with the &quot;initial_dictionary&quot; parameter.  The l1-norm
regularization parameter is specified with the &quot;lambda&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>codes</code></td>
<td>
<p>Output codes matrix (numeric matrix).</p>
</td></tr>
<tr><td><code>dictionary</code></td>
<td>
<p>Output dictionary matrix (numeric matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained LCC model
(LocalCoordinateCoding).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to run LCC on the dataset "data" using 200 atoms and an
# l1-regularization parameter of 0.1, saving the dictionary "dictionary" and
# the codes into "codes", use

## Not run: 
output &lt;- local_coordinate_coding(training=data, atoms=200, lambda=0.1)
dict &lt;- output$dictionary
codes &lt;- output$codes

## End(Not run)

# The maximum number of iterations may be specified with the "max_iterations"
# parameter. Optionally, the input data matrix X can be normalized before
# coding with the "normalize" parameter.
# 
# An LCC model may be saved using the "output_model" output parameter.  Then,
# to encode new points from the dataset "points" with the previously saved
# model "lcc_model", saving the new codes to "new_codes", the following
# command can be used:

## Not run: 
output &lt;- local_coordinate_coding(input_model=lcc_model, test=points)
new_codes &lt;- output$codes

## End(Not run)
</code></pre>

<hr>
<h2 id='logistic_regression'>L2-regularized Logistic Regression and Prediction</h2><span id='topic+logistic_regression'></span>

<h3>Description</h3>

<p>An implementation of L2-regularized logistic regression for two-class
classification.  Given labeled data, a model can be trained and saved for
future use; or, a pre-trained model can be used to classify new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_regression(
  batch_size = NA,
  decision_boundary = NA,
  input_model = NA,
  labels = NA,
  lambda = NA,
  max_iterations = NA,
  optimizer = NA,
  print_training_accuracy = FALSE,
  step_size = NA,
  test = NA,
  tolerance = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_regression_+3A_batch_size">batch_size</code></td>
<td>
<p>Batch size for SGD.  Default value &quot;64&quot; (integer).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_decision_boundary">decision_boundary</code></td>
<td>
<p>Decision boundary for prediction; if the
logistic function for a point is less than the boundary, the class is taken
to be 0; otherwise, the class is 1.  Default value &quot;0.5&quot; (numeric).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_input_model">input_model</code></td>
<td>
<p>Existing model (parameters) (LogisticRegression).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_labels">labels</code></td>
<td>
<p>A matrix containing labels (0 or 1) for the points in the
training set (y) (integer row).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_lambda">lambda</code></td>
<td>
<p>L2-regularization parameter for training.  Default value
&quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum iterations for optimizer (0 indicates no
limit).  Default value &quot;10000&quot; (integer).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_optimizer">optimizer</code></td>
<td>
<p>Optimizer to use for training ('lbfgs' or 'sgd'). 
Default value &quot;lbfgs&quot; (character).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_print_training_accuracy">print_training_accuracy</code></td>
<td>
<p>If set, then the accuracy of the model on
the training set will be printed (verbose must also be specified).  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_step_size">step_size</code></td>
<td>
<p>Step size for SGD optimizer.  Default value &quot;0.01&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_test">test</code></td>
<td>
<p>Matrix containing test dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_tolerance">tolerance</code></td>
<td>
<p>Convergence tolerance for optimizer.  Default value
&quot;1e-10&quot; (numeric).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_training">training</code></td>
<td>
<p>A matrix containing the training set (the matrix of
predictors, X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="logistic_regression_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of L2-regularized logistic regression using either the
L-BFGS optimizer or SGD (stochastic gradient descent).  This solves the
regression problem
</p>
<p>y = (1 / 1 + e^-(X * b)).
</p>
<p>In this setting, y corresponds to class labels and X corresponds to data.
</p>
<p>This program allows loading a logistic regression model (via the
&quot;input_model&quot; parameter) or training a logistic regression model given
training data (specified with the &quot;training&quot; parameter), or both those things
at once.  In addition, this program allows classification on a test dataset
(specified with the &quot;test&quot; parameter) and the classification results may be
saved with the &quot;predictions&quot; output parameter. The trained logistic
regression model may be saved using the &quot;output_model&quot; output parameter.
</p>
<p>The training data, if specified, may have class labels as its last dimension.
Alternately, the &quot;labels&quot; parameter may be used to specify a separate matrix
of labels.
</p>
<p>When a model is being trained, there are many options.  L2 regularization (to
prevent overfitting) can be specified with the &quot;lambda&quot; option, and the
optimizer used to train the model can be specified with the &quot;optimizer&quot;
parameter.  Available options are 'sgd' (stochastic gradient descent) and
'lbfgs' (the L-BFGS optimizer).  There are also various parameters for the
optimizer; the &quot;max_iterations&quot; parameter specifies the maximum number of
allowed iterations, and the &quot;tolerance&quot; parameter specifies the tolerance for
convergence.  For the SGD optimizer, the &quot;step_size&quot; parameter controls the
step size taken at each iteration by the optimizer.  The batch size for SGD
is controlled with the &quot;batch_size&quot; parameter. If the objective function for
your data is oscillating between Inf and 0, the step size is probably too
large.  There are more parameters for the optimizers, but the C++ interface
must be used to access these.
</p>
<p>For SGD, an iteration refers to a single point. So to take a single pass over
the dataset with SGD, &quot;max_iterations&quot; should be set to the number of points
in the dataset.
</p>
<p>Optionally, the model can be used to predict the responses for another matrix
of data points, if &quot;test&quot; is specified.  The &quot;test&quot; parameter can be
specified without the &quot;training&quot; parameter, so long as an existing logistic
regression model is given with the &quot;input_model&quot; parameter.  The output
predictions from the logistic regression model may be saved with the
&quot;predictions&quot; parameter.
</p>
<p>This implementation of logistic regression does not support the general
multi-class case but instead only the two-class case.  Any labels must be
either 0 or 1.  For more classes, see the softmax regression implementation.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained logistic regression model
(LogisticRegression).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>If test data is specified, this matrix is where the
predictions for the test set will be saved (integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>If test data is specified, this matrix is where the
class probabilities for the test set will be saved (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, to train a logistic regression model on the data '"data"'
# with labels '"labels"' with L2 regularization of 0.1, saving the model to
# '"lr_model"', the following command may be used:

## Not run: 
output &lt;- logistic_regression(training=data, labels=labels, lambda=0.1,
  print_training_accuracy=TRUE)
lr_model &lt;- output$output_model

## End(Not run)

# Then, to use that model to predict classes for the dataset '"test"',
# storing the output predictions in '"predictions"', the following command
# may be used: 

## Not run: 
output &lt;- logistic_regression(input_model=lr_model, test=test)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='lsh'>K-Approximate-Nearest-Neighbor Search with LSH</h2><span id='topic+lsh'></span>

<h3>Description</h3>

<p>An implementation of approximate k-nearest-neighbor search with
locality-sensitive hashing (LSH).  Given a set of reference points and a set
of query points, this will compute the k approximate nearest neighbors of
each query point in the reference set; models can be saved for future use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsh(
  bucket_size = NA,
  hash_width = NA,
  input_model = NA,
  k = NA,
  num_probes = NA,
  projections = NA,
  query = NA,
  reference = NA,
  second_hash_size = NA,
  seed = NA,
  tables = NA,
  true_neighbors = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsh_+3A_bucket_size">bucket_size</code></td>
<td>
<p>The size of a bucket in the second level hash. 
Default value &quot;500&quot; (integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_hash_width">hash_width</code></td>
<td>
<p>The hash width for the first-level hashing in the LSH
preprocessing. By default, the LSH class automatically estimates a hash
width for its use.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="lsh_+3A_input_model">input_model</code></td>
<td>
<p>Input LSH model (LSHSearch).</p>
</td></tr>
<tr><td><code id="lsh_+3A_k">k</code></td>
<td>
<p>Number of nearest neighbors to find.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_num_probes">num_probes</code></td>
<td>
<p>Number of additional probes for multiprobe LSH; if 0,
traditional LSH is used.  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_projections">projections</code></td>
<td>
<p>The number of hash functions for each tabl.  Default
value &quot;10&quot; (integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_query">query</code></td>
<td>
<p>Matrix containing query points (optional) (numeric
matrix).</p>
</td></tr>
<tr><td><code id="lsh_+3A_reference">reference</code></td>
<td>
<p>Matrix containing the reference dataset (numeric
matrix).</p>
</td></tr>
<tr><td><code id="lsh_+3A_second_hash_size">second_hash_size</code></td>
<td>
<p>The size of the second level hash table. 
Default value &quot;99901&quot; (integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_tables">tables</code></td>
<td>
<p>The number of hash tables to be used.  Default value &quot;30&quot;
(integer).</p>
</td></tr>
<tr><td><code id="lsh_+3A_true_neighbors">true_neighbors</code></td>
<td>
<p>Matrix of true neighbors to compute recall with
(the recall is printed when -v is specified) (integer matrix).</p>
</td></tr>
<tr><td><code id="lsh_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program will calculate the k approximate-nearest-neighbors of a set of
points using locality-sensitive hashing. You may specify a separate set of
reference points and query points, or just a reference set which will be used
as both the reference and query set.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>distances</code></td>
<td>
<p>Matrix to output distances into (numeric matrix).</p>
</td></tr>
<tr><td><code>neighbors</code></td>
<td>
<p>Matrix to output neighbors into (integer matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained LSH model (LSHSearch).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, the following will return 5 neighbors from the data for each
# point in "input" and store the distances in "distances" and the neighbors
# in "neighbors":

## Not run: 
output &lt;- lsh(k=5, reference=input)
distances &lt;- output$distances
neighbors &lt;- output$neighbors

## End(Not run)

# The output is organized such that row i and column j in the neighbors
# output corresponds to the index of the point in the reference set which is
# the j'th nearest neighbor from the point in the query set with index i. 
# Row j and column i in the distances output file corresponds to the distance
# between those two points.
# 
# Because this is approximate-nearest-neighbors search, results may be
# different from run to run.  Thus, the "seed" parameter can be specified to
# set the random seed.
# 
# This program also has many other parameters to control its functionality;
# see the parameter-specific documentation for more information.
</code></pre>

<hr>
<h2 id='mean_shift'>Mean Shift Clustering</h2><span id='topic+mean_shift'></span>

<h3>Description</h3>

<p>A fast implementation of mean-shift clustering using dual-tree range search. 
Given a dataset, this uses the mean shift algorithm to produce and return a
clustering of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_shift(
  input,
  force_convergence = FALSE,
  in_place = FALSE,
  labels_only = FALSE,
  max_iterations = NA,
  radius = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_shift_+3A_input">input</code></td>
<td>
<p>Input dataset to perform clustering on (numeric matrix).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_force_convergence">force_convergence</code></td>
<td>
<p>If specified, the mean shift algorithm will
continue running regardless of max_iterations until the clusters converge. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_in_place">in_place</code></td>
<td>
<p>If specified, a column containing the learned cluster
assignments will be added to the input dataset file.  In this case,
&ndash;output_file is overridden.  (Do not use with Python..  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_labels_only">labels_only</code></td>
<td>
<p>If specified, only the output labels will be written
to the file specified by &ndash;output_file.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations before mean shift
terminates.  Default value &quot;1000&quot; (integer).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_radius">radius</code></td>
<td>
<p>If the distance between two centroids is less than the
given radius, one will be removed.  A radius of 0 or less means an estimate
will be calculated and used for the radius.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="mean_shift_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs mean shift clustering on the given dataset, storing the
learned cluster assignments either as a column of labels in the input dataset
or separately.
</p>
<p>The input dataset should be specified with the &quot;input&quot; parameter, and the
radius used for search can be specified with the &quot;radius&quot; parameter.  The
maximum number of iterations before algorithm termination is controlled with
the &quot;max_iterations&quot; parameter.
</p>
<p>The output labels may be saved with the &quot;output&quot; output parameter and the
centroids of each cluster may be saved with the &quot;centroid&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>centroid</code></td>
<td>
<p>If specified, the centroids of each cluster will be
written to the given matrix (numeric matrix).</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>Matrix to write output labels or labeled data to (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to run mean shift clustering on the dataset "data" and store
# the centroids to "centroids", the following command may be used: 

## Not run: 
output &lt;- mean_shift(input=data)
centroids &lt;- output$centroid

## End(Not run)
</code></pre>

<hr>
<h2 id='nbc'>Parametric Naive Bayes Classifier</h2><span id='topic+nbc'></span>

<h3>Description</h3>

<p>An implementation of the Naive Bayes Classifier, used for classification.
Given labeled data, an NBC model can be trained and saved, or, a pre-trained
model can be used for classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbc(
  incremental_variance = FALSE,
  input_model = NA,
  labels = NA,
  test = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbc_+3A_incremental_variance">incremental_variance</code></td>
<td>
<p>The variance of each class will be
calculated incrementally.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="nbc_+3A_input_model">input_model</code></td>
<td>
<p>Input Naive Bayes model (NBCModel).</p>
</td></tr>
<tr><td><code id="nbc_+3A_labels">labels</code></td>
<td>
<p>A file containing labels for the training set (integer
row).</p>
</td></tr>
<tr><td><code id="nbc_+3A_test">test</code></td>
<td>
<p>A matrix containing the test set (numeric matrix).</p>
</td></tr>
<tr><td><code id="nbc_+3A_training">training</code></td>
<td>
<p>A matrix containing the training set (numeric matrix).</p>
</td></tr>
<tr><td><code id="nbc_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program trains the Naive Bayes classifier on the given labeled training
set, or loads a model from the given model file, and then may use that
trained model to classify the points in a given test set.
</p>
<p>The training set is specified with the &quot;training&quot; parameter.  Labels may be
either the last row of the training set, or alternately the &quot;labels&quot;
parameter may be specified to pass a separate matrix of labels.
</p>
<p>If training is not desired, a pre-existing model may be loaded with the
&quot;input_model&quot; parameter.
</p>
<p>The &quot;incremental_variance&quot; parameter can be used to force the training to use
an incremental algorithm for calculating variance.  This is slower, but can
help avoid loss of precision in some cases.
</p>
<p>If classifying a test set is desired, the test set may be specified with the
&quot;test&quot; parameter, and the classifications may be saved with the
&quot;predictions&quot;predictions  parameter.  If saving the trained model is desired,
this may be done with the &quot;output_model&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>File to save trained Naive Bayes model to
(NBCModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>The matrix in which the predicted labels for the test
set will be written (integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>The matrix in which the predicted probability of
labels for the test set will be written (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to train a Naive Bayes classifier on the dataset "data" with
# labels "labels" and save the model to "nbc_model", the following command
# may be used:

## Not run: 
output &lt;- nbc(training=data, labels=labels)
nbc_model &lt;- output$output_model

## End(Not run)

# Then, to use "nbc_model" to predict the classes of the dataset "test_set"
# and save the predicted classes to "predictions", the following command may
# be used:

## Not run: 
output &lt;- nbc(input_model=nbc_model, test=test_set)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='nca'>Neighborhood Components Analysis (NCA)</h2><span id='topic+nca'></span>

<h3>Description</h3>

<p>An implementation of neighborhood components analysis, a distance learning
technique that can be used for preprocessing.  Given a labeled dataset, this
uses NCA, which seeks to improve the k-nearest-neighbor classification, and
returns the learned distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nca(
  input,
  armijo_constant = NA,
  batch_size = NA,
  labels = NA,
  linear_scan = FALSE,
  max_iterations = NA,
  max_line_search_trials = NA,
  max_step = NA,
  min_step = NA,
  normalize = FALSE,
  num_basis = NA,
  optimizer = NA,
  seed = NA,
  step_size = NA,
  tolerance = NA,
  verbose = getOption("mlpack.verbose", FALSE),
  wolfe = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nca_+3A_input">input</code></td>
<td>
<p>Input dataset to run NCA on (numeric matrix).</p>
</td></tr>
<tr><td><code id="nca_+3A_armijo_constant">armijo_constant</code></td>
<td>
<p>Armijo constant for L-BFGS.  Default value
&quot;0.0001&quot; (numeric).</p>
</td></tr>
<tr><td><code id="nca_+3A_batch_size">batch_size</code></td>
<td>
<p>Batch size for mini-batch SGD.  Default value &quot;50&quot;
(integer).</p>
</td></tr>
<tr><td><code id="nca_+3A_labels">labels</code></td>
<td>
<p>Labels for input dataset (integer row).</p>
</td></tr>
<tr><td><code id="nca_+3A_linear_scan">linear_scan</code></td>
<td>
<p>Don't shuffle the order in which data points are
visited for SGD or mini-batch SGD.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="nca_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for SGD or L-BFGS (0
indicates no limit).  Default value &quot;500000&quot; (integer).</p>
</td></tr>
<tr><td><code id="nca_+3A_max_line_search_trials">max_line_search_trials</code></td>
<td>
<p>Maximum number of line search trials for
L-BFGS.  Default value &quot;50&quot; (integer).</p>
</td></tr>
<tr><td><code id="nca_+3A_max_step">max_step</code></td>
<td>
<p>Maximum step of line search for L-BFGS.  Default value
&quot;1e+20&quot; (numeric).</p>
</td></tr>
<tr><td><code id="nca_+3A_min_step">min_step</code></td>
<td>
<p>Minimum step of line search for L-BFGS.  Default value
&quot;1e-20&quot; (numeric).</p>
</td></tr>
<tr><td><code id="nca_+3A_normalize">normalize</code></td>
<td>
<p>Use a normalized starting point for optimization. This
is useful for when points are far apart, or when SGD is returning NaN. 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="nca_+3A_num_basis">num_basis</code></td>
<td>
<p>Number of memory points to be stored for L-BFGS. 
Default value &quot;5&quot; (integer).</p>
</td></tr>
<tr><td><code id="nca_+3A_optimizer">optimizer</code></td>
<td>
<p>Optimizer to use; 'sgd' or 'lbfgs'.  Default value
&quot;sgd&quot; (character).</p>
</td></tr>
<tr><td><code id="nca_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="nca_+3A_step_size">step_size</code></td>
<td>
<p>Step size for stochastic gradient descent (alpha). 
Default value &quot;0.01&quot; (numeric).</p>
</td></tr>
<tr><td><code id="nca_+3A_tolerance">tolerance</code></td>
<td>
<p>Maximum tolerance for termination of SGD or L-BFGS. 
Default value &quot;1e-07&quot; (numeric).</p>
</td></tr>
<tr><td><code id="nca_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="nca_+3A_wolfe">wolfe</code></td>
<td>
<p>Wolfe condition parameter for L-BFGS.  Default value &quot;0.9&quot;
(numeric).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements Neighborhood Components Analysis, both a linear
dimensionality reduction technique and a distance learning technique.  The
method seeks to improve k-nearest-neighbor classification on a dataset by
scaling the dimensions.  The method is nonparametric, and does not require a
value of k.  It works by using stochastic (&quot;soft&quot;) neighbor assignments and
using optimization techniques over the gradient of the accuracy of the
neighbor assignments.
</p>
<p>To work, this algorithm needs labeled data.  It can be given as the last row
of the input dataset (specified with &quot;input&quot;), or alternatively as a separate
matrix (specified with &quot;labels&quot;).
</p>
<p>This implementation of NCA uses stochastic gradient descent, mini-batch
stochastic gradient descent, or the L_BFGS optimizer.  These optimizers do
not guarantee global convergence for a nonconvex objective function (NCA's
objective function is nonconvex), so the final results could depend on the
random seed or other optimizer parameters.
</p>
<p>Stochastic gradient descent, specified by the value 'sgd' for the parameter
&quot;optimizer&quot;, depends primarily on three parameters: the step size (specified
with &quot;step_size&quot;), the batch size (specified with &quot;batch_size&quot;), and the
maximum number of iterations (specified with &quot;max_iterations&quot;).  In addition,
a normalized starting point can be used by specifying the &quot;normalize&quot;
parameter, which is necessary if many warnings of the form 'Denominator of
p_i is 0!' are given.  Tuning the step size can be a tedious affair.  In
general, the step size is too large if the objective is not mostly uniformly
decreasing, or if zero-valued denominator warnings are being issued.  The
step size is too small if the objective is changing very slowly.  Setting the
termination condition can be done easily once a good step size parameter is
found; either increase the maximum iterations to a large number and allow SGD
to find a minimum, or set the maximum iterations to 0 (allowing infinite
iterations) and set the tolerance (specified by &quot;tolerance&quot;) to define the
maximum allowed difference between objectives for SGD to terminate.  Be
careful&mdash;setting the tolerance instead of the maximum iterations can take a
very long time and may actually never converge due to the properties of the
SGD optimizer. Note that a single iteration of SGD refers to a single point,
so to take a single pass over the dataset, set the value of the
&quot;max_iterations&quot; parameter equal to the number of points in the dataset.
</p>
<p>The L-BFGS optimizer, specified by the value 'lbfgs' for the parameter
&quot;optimizer&quot;, uses a back-tracking line search algorithm to minimize a
function.  The following parameters are used by L-BFGS: &quot;num_basis&quot;
(specifies the number of memory points used by L-BFGS), &quot;max_iterations&quot;,
&quot;armijo_constant&quot;, &quot;wolfe&quot;, &quot;tolerance&quot; (the optimization is terminated when
the gradient norm is below this value), &quot;max_line_search_trials&quot;, &quot;min_step&quot;,
and &quot;max_step&quot; (which both refer to the line search routine).  For more
details on the L-BFGS optimizer, consult either the mlpack L-BFGS
documentation (in lbfgs.hpp) or the vast set of published literature on
L-BFGS.
</p>
<p>By default, the SGD optimizer is used.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Output matrix for learned distance matrix (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>

<hr>
<h2 id='nmf'>Non-negative Matrix Factorization</h2><span id='topic+nmf'></span>

<h3>Description</h3>

<p>An implementation of non-negative matrix factorization.  This can be used to
decompose an input dataset into two low-rank non-negative components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nmf(
  input,
  rank,
  initial_h = NA,
  initial_w = NA,
  max_iterations = NA,
  min_residue = NA,
  seed = NA,
  update_rules = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nmf_+3A_input">input</code></td>
<td>
<p>Input dataset to perform NMF on (numeric matrix).</p>
</td></tr>
<tr><td><code id="nmf_+3A_rank">rank</code></td>
<td>
<p>Rank of the factorization (integer).</p>
</td></tr>
<tr><td><code id="nmf_+3A_initial_h">initial_h</code></td>
<td>
<p>Initial H matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="nmf_+3A_initial_w">initial_w</code></td>
<td>
<p>Initial W matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="nmf_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Number of iterations before NMF terminates (0 runs
until convergence.  Default value &quot;10000&quot; (integer).</p>
</td></tr>
<tr><td><code id="nmf_+3A_min_residue">min_residue</code></td>
<td>
<p>The minimum root mean square residue allowed for each
iteration, below which the program terminates.  Default value &quot;1e-05&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="nmf_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="nmf_+3A_update_rules">update_rules</code></td>
<td>
<p>Update rules for each iteration; ( multdist |
multdiv | als ).  Default value &quot;multdist&quot; (character).</p>
</td></tr>
<tr><td><code id="nmf_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs non-negative matrix factorization on the given dataset,
storing the resulting decomposed matrices in the specified files.  For an
input dataset V, NMF decomposes V into two matrices W and H such that 
</p>
<p>V = W * H
</p>
<p>where all elements in W and H are non-negative.  If V is of size (n x m),
then W will be of size (n x r) and H will be of size (r x m), where r is the
rank of the factorization (specified by the &quot;rank&quot; parameter).
</p>
<p>Optionally, the desired update rules for each NMF iteration can be chosen
from the following list:
</p>
<p>- multdist: multiplicative distance-based update rules (Lee and Seung 1999)
- multdiv: multiplicative divergence-based update rules (Lee and Seung 1999)
- als: alternating least squares update rules (Paatero and Tapper 1994)
</p>
<p>The maximum number of iterations is specified with &quot;max_iterations&quot;, and the
minimum residue required for algorithm termination is specified with the
&quot;min_residue&quot; parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>h</code></td>
<td>
<p>Matrix to save the calculated H to (numeric matrix).</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Matrix to save the calculated W to (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to run NMF on the input matrix "V" using the 'multdist' update
# rules with a rank-10 decomposition and storing the decomposed matrices into
# "W" and "H", the following command could be used: 

## Not run: 
output &lt;- nmf(input=V, rank=10, update_rules="multdist")
W &lt;- output$w
H &lt;- output$h

## End(Not run)
</code></pre>

<hr>
<h2 id='pca'>Principal Components Analysis</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>An implementation of several strategies for principal components analysis
(PCA), a common preprocessing step.  Given a dataset and a desired new
dimensionality, this can reduce the dimensionality of the data using the
linear transformation determined by PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(
  input,
  decomposition_method = NA,
  new_dimensionality = NA,
  scale = FALSE,
  var_to_retain = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_input">input</code></td>
<td>
<p>Input dataset to perform PCA on (numeric matrix).</p>
</td></tr>
<tr><td><code id="pca_+3A_decomposition_method">decomposition_method</code></td>
<td>
<p>Method used for the principal components
analysis: 'exact', 'randomized', 'randomized-block-krylov', 'quic'. 
Default value &quot;exact&quot; (character).</p>
</td></tr>
<tr><td><code id="pca_+3A_new_dimensionality">new_dimensionality</code></td>
<td>
<p>Desired dimensionality of output dataset. If
0, no dimensionality reduction is performed.  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="pca_+3A_scale">scale</code></td>
<td>
<p>If set, the data will be scaled before running PCA, such
that the variance of each feature is 1.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="pca_+3A_var_to_retain">var_to_retain</code></td>
<td>
<p>Amount of variance to retain; should be between 0
and 1.  If 1, all variance is retained.  Overrides -d.  Default value &quot;0&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="pca_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs principal components analysis on the given dataset
using the exact, randomized, randomized block Krylov, or QUIC SVD method. It
will transform the data onto its principal components, optionally performing
dimensionality reduction by ignoring the principal components with the
smallest eigenvalues.
</p>
<p>Use the &quot;input&quot; parameter to specify the dataset to perform PCA on.  A
desired new dimensionality can be specified with the &quot;new_dimensionality&quot;
parameter, or the desired variance to retain can be specified with the
&quot;var_to_retain&quot; parameter.  If desired, the dataset can be scaled before
running PCA with the &quot;scale&quot; parameter.
</p>
<p>Multiple different decomposition techniques can be used.  The method to use
can be specified with the &quot;decomposition_method&quot; parameter, and it may take
the values 'exact', 'randomized', or 'quic'.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save modified dataset to (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to reduce the dimensionality of the matrix "data" to 5
# dimensions using randomized SVD for the decomposition, storing the output
# matrix to "data_mod", the following command can be used:

## Not run: 
output &lt;- pca(input=data, new_dimensionality=5,
  decomposition_method="randomized")
data_mod &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='perceptron'>Perceptron</h2><span id='topic+perceptron'></span>

<h3>Description</h3>

<p>An implementation of a perceptron&mdash;a single level neural network&ndash;=for
classification.  Given labeled data, a perceptron can be trained and saved
for future use; or, a pre-trained perceptron can be used for classification
on new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perceptron(
  input_model = NA,
  labels = NA,
  max_iterations = NA,
  test = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perceptron_+3A_input_model">input_model</code></td>
<td>
<p>Input perceptron model (PerceptronModel).</p>
</td></tr>
<tr><td><code id="perceptron_+3A_labels">labels</code></td>
<td>
<p>A matrix containing labels for the training set (integer
row).</p>
</td></tr>
<tr><td><code id="perceptron_+3A_max_iterations">max_iterations</code></td>
<td>
<p>The maximum number of iterations the perceptron is
to be ru.  Default value &quot;1000&quot; (integer).</p>
</td></tr>
<tr><td><code id="perceptron_+3A_test">test</code></td>
<td>
<p>A matrix containing the test set (numeric matrix).</p>
</td></tr>
<tr><td><code id="perceptron_+3A_training">training</code></td>
<td>
<p>A matrix containing the training set (numeric matrix).</p>
</td></tr>
<tr><td><code id="perceptron_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program implements a perceptron, which is a single level neural network.
The perceptron makes its predictions based on a linear predictor function
combining a set of weights with the feature vector.  The perceptron learning
rule is able to converge, given enough iterations (specified using the
&quot;max_iterations&quot; parameter), if the data supplied is linearly separable.  The
perceptron is parameterized by a matrix of weight vectors that denote the
numerical weights of the neural network.
</p>
<p>This program allows loading a perceptron from a model (via the &quot;input_model&quot;
parameter) or training a perceptron given training data (via the &quot;training&quot;
parameter), or both those things at once.  In addition, this program allows
classification on a test dataset (via the &quot;test&quot; parameter) and the
classification results on the test set may be saved with the &quot;predictions&quot;
output parameter.  The perceptron model may be saved with the &quot;output_model&quot;
output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Output for trained perceptron model
(PerceptronModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>The matrix in which the predicted labels for the test
set will be written (integer row).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The training data given with the "training" option may have class labels as
# its last dimension (so, if the training data is in CSV format, labels
# should be the last column).  Alternately, the "labels" parameter may be
# used to specify a separate matrix of labels.
# 
# All these options make it easy to train a perceptron, and then re-use that
# perceptron for later classification.  The invocation below trains a
# perceptron on "training_data" with labels "training_labels", and saves the
# model to "perceptron_model".

## Not run: 
output &lt;- perceptron(training=training_data, labels=training_labels)
perceptron_model &lt;- output$output_model

## End(Not run)

# Then, this model can be re-used for classification on the test data
# "test_data".  The example below does precisely that, saving the predicted
# classes to "predictions".

## Not run: 
output &lt;- perceptron(input_model=perceptron_model, test=test_data)
predictions &lt;- output$predictions

## End(Not run)

# Note that all of the options may be specified at once: predictions may be
# calculated right after training a model, and model training can occur even
# if an existing perceptron model is passed with the "input_model" parameter.
#  However, note that the number of classes and the dimensionality of all
# data must match.  So you cannot pass a perceptron model trained on 2
# classes and then re-train with a 4-class dataset.  Similarly, attempting
# classification on a 3-dimensional dataset with a perceptron that has been
# trained on 8 dimensions will cause an error.
</code></pre>

<hr>
<h2 id='preprocess_binarize'>Binarize Data</h2><span id='topic+preprocess_binarize'></span>

<h3>Description</h3>

<p>A utility to binarize a dataset.  Given a dataset, this utility converts each
value in the desired dimension(s) to 0 or 1; this can be a useful
preprocessing step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_binarize(
  input,
  dimension = NA,
  threshold = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_binarize_+3A_input">input</code></td>
<td>
<p>Input data matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="preprocess_binarize_+3A_dimension">dimension</code></td>
<td>
<p>Dimension to apply the binarization. If not set, the
program will binarize every dimension by default.  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="preprocess_binarize_+3A_threshold">threshold</code></td>
<td>
<p>Threshold to be applied for binarization. If not set,
the threshold defaults to 0.0.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="preprocess_binarize_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes a dataset and binarizes the variables into either 0 or 1
given threshold. User can apply binarization on a dimension or the whole
dataset.  The dimension to apply binarization to can be specified using the
&quot;dimension&quot; parameter; if left unspecified, every dimension will be
binarized.  The threshold for binarization can also be specified with the
&quot;threshold&quot; parameter; the default threshold is 0.0.
</p>
<p>The binarized matrix may be saved with the &quot;output&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix in which to save the output (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, if we want to set all variables greater than 5 in the dataset
# "X" to 1 and variables less than or equal to 5.0 to 0, and save the result
# to "Y", we could run

## Not run: 
output &lt;- preprocess_binarize(input=X, threshold=5)
Y &lt;- output$output

## End(Not run)

# But if we want to apply this to only the first (0th) dimension of "X",  we
# could instead run

## Not run: 
output &lt;- preprocess_binarize(input=X, threshold=5, dimension=0)
Y &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='preprocess_describe'>Descriptive Statistics</h2><span id='topic+preprocess_describe'></span>

<h3>Description</h3>

<p>A utility for printing descriptive statistics about a dataset.  This prints a
number of details about a dataset in a tabular format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_describe(
  input,
  dimension = NA,
  population = FALSE,
  precision = NA,
  row_major = FALSE,
  verbose = getOption("mlpack.verbose", FALSE),
  width = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_describe_+3A_input">input</code></td>
<td>
<p>Matrix containing data (numeric matrix).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_dimension">dimension</code></td>
<td>
<p>Dimension of the data. Use this to specify a dimensio. 
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_population">population</code></td>
<td>
<p>If specified, the program will calculate statistics
assuming the dataset is the population. By default, the program will assume
the dataset as a sample.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_precision">precision</code></td>
<td>
<p>Precision of the output statistics.  Default value &quot;4&quot;
(integer).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_row_major">row_major</code></td>
<td>
<p>If specified, the program will calculate statistics
across rows, not across columns.  (Remember that in mlpack, a column
represents a point, so this option is generally not necessary..  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_describe_+3A_width">width</code></td>
<td>
<p>Width of the output table.  Default value &quot;8&quot; (integer).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes a dataset and prints out the descriptive statistics of the
data. Descriptive statistics is the discipline of quantitatively describing
the main features of a collection of information, or the quantitative
description itself. The program does not modify the original file, but
instead prints out the statistics to the console. The printed result will
look like a table.
</p>
<p>Optionally, width and precision of the output can be adjusted by a user using
the &quot;width&quot; and &quot;precision&quot; parameters. A user can also select a specific
dimension to analyze if there are too many dimensions. The &quot;population&quot;
parameter can be specified when the dataset should be considered as a
population.  Otherwise, the dataset will be considered as a sample.
</p>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># So, a simple example where we want to print out statistical facts about the
# dataset "X" using the default settings, we could run 

## Not run: 
preprocess_describe(input=X, verbose=TRUE)

## End(Not run)

# If we want to customize the width to 10 and precision to 5 and consider the
# dataset as a population, we could run

## Not run: 
preprocess_describe(input=X, width=10, precision=5, verbose=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='preprocess_one_hot_encoding'>One Hot Encoding</h2><span id='topic+preprocess_one_hot_encoding'></span>

<h3>Description</h3>

<p>A utility to do one-hot encoding on features of dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_one_hot_encoding(
  input,
  dimensions = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_one_hot_encoding_+3A_input">input</code></td>
<td>
<p>Matrix containing data (numeric matrix/data.frame with
info).</p>
</td></tr>
<tr><td><code id="preprocess_one_hot_encoding_+3A_dimensions">dimensions</code></td>
<td>
<p>Index of dimensions that need to be one-hot encoded
(if unspecified, all categorical dimensions are one-hot encoded) (integer
vector).</p>
</td></tr>
<tr><td><code id="preprocess_one_hot_encoding_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes a dataset and a vector of indices and does one-hot
encoding of the respective features at those indices. Indices represent the
IDs of the dimensions to be one-hot encoded.
</p>
<p>If no dimensions are specified with &quot;dimensions&quot;, then all categorical-type
dimensions will be one-hot encoded. Otherwise, only the dimensions given in
&quot;dimensions&quot; will be one-hot encoded.
</p>
<p>The output matrix with encoded features may be saved with the &quot;output&quot;
parameters.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save one-hot encoded features data to (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># So, a simple example where we want to encode 1st and 3rd feature from
# dataset "X" into "X_output" would be

## Not run: 
output &lt;- preprocess_one_hot_encoding(input=X, dimensions=1, dimensions=3)
X_ouput &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='preprocess_scale'>Scale Data</h2><span id='topic+preprocess_scale'></span>

<h3>Description</h3>

<p>A utility to perform feature scaling on datasets using one of sixtechniques. 
Both scaling and inverse scaling are supported, andscalers can be saved and
then applied to other datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_scale(
  input,
  epsilon = NA,
  input_model = NA,
  inverse_scaling = FALSE,
  max_value = NA,
  min_value = NA,
  scaler_method = NA,
  seed = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_scale_+3A_input">input</code></td>
<td>
<p>Matrix containing data (numeric matrix).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_epsilon">epsilon</code></td>
<td>
<p>regularization Parameter for pcawhitening, or
zcawhitening, should be between -1 to 1.  Default value &quot;1e-06&quot; (numeric).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_input_model">input_model</code></td>
<td>
<p>Input Scaling model (ScalingModel).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_inverse_scaling">inverse_scaling</code></td>
<td>
<p>Inverse Scaling to get original datase.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_max_value">max_value</code></td>
<td>
<p>Ending value of range for min_max_scaler.  Default
value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_min_value">min_value</code></td>
<td>
<p>Starting value of range for min_max_scaler.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_scaler_method">scaler_method</code></td>
<td>
<p>method to use for scaling, the default is
standard_scaler.  Default value &quot;standard_scaler&quot; (character).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_seed">seed</code></td>
<td>
<p>Random seed (0 for std::time(NULL)).  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="preprocess_scale_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes a dataset and performs feature scaling using one of the
six scaler methods namely: 'max_abs_scaler', 'mean_normalization',
'min_max_scaler' ,'standard_scaler', 'pca_whitening' and 'zca_whitening'. The
function takes a matrix as &quot;input&quot; and a scaling method type which you can
specify using &quot;scaler_method&quot; parameter; the default is standard scaler, and
outputs a matrix with scaled feature.
</p>
<p>The output scaled feature matrix may be saved with the &quot;output&quot; output
parameters.
</p>
<p>The model to scale features can be saved using &quot;output_model&quot; and later can
be loaded back using&quot;input_model&quot;.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output</code></td>
<td>
<p>Matrix to save scaled data to (numeric matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>Output scaling model (ScalingModel).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># So, a simple example where we want to scale the dataset "X" into "X_scaled"
# with  standard_scaler as scaler_method, we could run 

## Not run: 
output &lt;- preprocess_scale(input=X, scaler_method="standard_scaler")
X_scaled &lt;- output$output

## End(Not run)

# A simple example where we want to whiten the dataset "X" into "X_whitened"
# with  PCA as whitening_method and use 0.01 as regularization parameter, we
# could run 

## Not run: 
output &lt;- preprocess_scale(input=X, scaler_method="pca_whitening",
  epsilon=0.01)
X_scaled &lt;- output$output

## End(Not run)

# You can also retransform the scaled dataset back using"inverse_scaling". An
# example to rescale : "X_scaled" into "X"using the saved model "input_model"
# is:

## Not run: 
output &lt;- preprocess_scale(input=X_scaled, inverse_scaling=TRUE,
  input_model=saved)
X &lt;- output$output

## End(Not run)

# Another simple example where we want to scale the dataset "X" into
# "X_scaled" with  min_max_scaler as scaler method, where scaling range is 1
# to 3 instead of default 0 to 1. We could run 

## Not run: 
output &lt;- preprocess_scale(input=X, scaler_method="min_max_scaler",
  min_value=1, max_value=3)
X_scaled &lt;- output$output

## End(Not run)
</code></pre>

<hr>
<h2 id='preprocess_split'>Split Data</h2><span id='topic+preprocess_split'></span>

<h3>Description</h3>

<p>A utility to split data into a training and testing dataset.  This can also
split labels according to the same split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_split(
  input,
  input_labels = NA,
  no_shuffle = FALSE,
  seed = NA,
  stratify_data = FALSE,
  test_ratio = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_split_+3A_input">input</code></td>
<td>
<p>Matrix containing data (numeric matrix).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_input_labels">input_labels</code></td>
<td>
<p>Matrix containing labels (integer matrix).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_no_shuffle">no_shuffle</code></td>
<td>
<p>Avoid shuffling the data before splitting.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_seed">seed</code></td>
<td>
<p>Random seed (0 for std::time(NULL)).  Default value &quot;0&quot;
(integer).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_stratify_data">stratify_data</code></td>
<td>
<p>Stratify the data according to label.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_test_ratio">test_ratio</code></td>
<td>
<p>Ratio of test set; if not set,the ratio defaults to
0..  Default value &quot;0.2&quot; (numeric).</p>
</td></tr>
<tr><td><code id="preprocess_split_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility takes a dataset and optionally labels and splits them into a
training set and a test set. Before the split, the points in the dataset are
randomly reordered. The percentage of the dataset to be used as the test set
can be specified with the &quot;test_ratio&quot; parameter; the default is 0.2 (20
</p>
<p>The output training and test matrices may be saved with the &quot;training&quot; and
&quot;test&quot; output parameters.
</p>
<p>Optionally, labels can also be split along with the data by specifying the
&quot;input_labels&quot; parameter.  Splitting labels works the same way as splitting
the data. The output training and test labels may be saved with the
&quot;training_labels&quot; and &quot;test_labels&quot; output parameters, respectively.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p>Matrix to save test data to (numeric matrix).</p>
</td></tr>
<tr><td><code>test_labels</code></td>
<td>
<p>Matrix to save test labels to (integer matrix).</p>
</td></tr>
<tr><td><code>training</code></td>
<td>
<p>Matrix to save training data to (numeric matrix).</p>
</td></tr>
<tr><td><code>training_labels</code></td>
<td>
<p>Matrix to save train labels to (integer
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># So, a simple example where we want to split the dataset "X" into "X_train"
# and "X_test" with 60% of the data in the training set and 40% of the
# dataset in the test set, we could run 

## Not run: 
output &lt;- preprocess_split(input=X, test_ratio=0.4)
X_train &lt;- output$training
X_test &lt;- output$test

## End(Not run)

# Also by default the dataset is shuffled and split; you can provide the
# "no_shuffle" option to avoid shuffling the data; an example to avoid
# shuffling of data is:

## Not run: 
output &lt;- preprocess_split(input=X, test_ratio=0.4, no_shuffle=TRUE)
X_train &lt;- output$training
X_test &lt;- output$test

## End(Not run)

# If we had a dataset "X" and associated labels "y", and we wanted to split
# these into "X_train", "y_train", "X_test", and "y_test", with 30% of the
# data in the test set, we could run

## Not run: 
output &lt;- preprocess_split(input=X, input_labels=y, test_ratio=0.3)
X_train &lt;- output$training
y_train &lt;- output$training_labels
X_test &lt;- output$test
y_test &lt;- output$test_labels

## End(Not run)
# To maintain the ratio of each class in the train and test sets,
# the"stratify_data" option can be used.

## Not run: 
output &lt;- preprocess_split(input=X, test_ratio=0.4, stratify_data=TRUE)
X_train &lt;- output$training
X_test &lt;- output$test

## End(Not run)
</code></pre>

<hr>
<h2 id='radical'>RADICAL</h2><span id='topic+radical'></span>

<h3>Description</h3>

<p>An implementation of RADICAL, a method for independent component analysis
(ICA).  Given a dataset, this can decompose the dataset into an unmixing
matrix and an independent component matrix; this can be useful for
preprocessing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radical(
  input,
  angles = NA,
  noise_std_dev = NA,
  objective = FALSE,
  replicates = NA,
  seed = NA,
  sweeps = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radical_+3A_input">input</code></td>
<td>
<p>Input dataset for ICA (numeric matrix).</p>
</td></tr>
<tr><td><code id="radical_+3A_angles">angles</code></td>
<td>
<p>Number of angles to consider in brute-force search during
Radical2D.  Default value &quot;150&quot; (integer).</p>
</td></tr>
<tr><td><code id="radical_+3A_noise_std_dev">noise_std_dev</code></td>
<td>
<p>Standard deviation of Gaussian noise.  Default
value &quot;0.175&quot; (numeric).</p>
</td></tr>
<tr><td><code id="radical_+3A_objective">objective</code></td>
<td>
<p>If set, an estimate of the final objective function is
printed.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="radical_+3A_replicates">replicates</code></td>
<td>
<p>Number of Gaussian-perturbed replicates to use (per
point) in Radical2D.  Default value &quot;30&quot; (integer).</p>
</td></tr>
<tr><td><code id="radical_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="radical_+3A_sweeps">sweeps</code></td>
<td>
<p>Number of sweeps; each sweep calls Radical2D once for each
pair of dimensions.  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="radical_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of RADICAL, a method for independent component analysis
(ICA).  Assuming that we have an input matrix X, the goal is to find a square
unmixing matrix W such that Y = W * X and the dimensions of Y are independent
components.  If the algorithm is running particularly slowly, try reducing
the number of replicates.
</p>
<p>The input matrix to perform ICA on should be specified with the &quot;input&quot;
parameter.  The output matrix Y may be saved with the &quot;output_ic&quot; output
parameter, and the output unmixing matrix W may be saved with the
&quot;output_unmixing&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_ic</code></td>
<td>
<p>Matrix to save independent components to (numeric
matrix).</p>
</td></tr>
<tr><td><code>output_unmixing</code></td>
<td>
<p>Matrix to save unmixing matrix to (numeric
matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to perform ICA on the matrix "X" with 40 replicates, saving
# the independent components to "ic", the following command may be used: 

## Not run: 
output &lt;- radical(input=X, replicates=40)
ic &lt;- output$output_ic

## End(Not run)
</code></pre>

<hr>
<h2 id='random_forest'>Random forests</h2><span id='topic+random_forest'></span>

<h3>Description</h3>

<p>An implementation of the standard random forest algorithm by Leo Breiman for
classification.  Given labeled data, a random forest can be trained and saved
for future use; or, a pre-trained random forest can be used for
classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_forest(
  input_model = NA,
  labels = NA,
  maximum_depth = NA,
  minimum_gain_split = NA,
  minimum_leaf_size = NA,
  num_trees = NA,
  print_training_accuracy = FALSE,
  seed = NA,
  subspace_dim = NA,
  test = NA,
  test_labels = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE),
  warm_start = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_forest_+3A_input_model">input_model</code></td>
<td>
<p>Pre-trained random forest to use for classification
(RandomForestModel).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_labels">labels</code></td>
<td>
<p>Labels for training dataset (integer row).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_maximum_depth">maximum_depth</code></td>
<td>
<p>Maximum depth of the tree (0 means no limit). 
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_minimum_gain_split">minimum_gain_split</code></td>
<td>
<p>Minimum gain needed to make a split when
building a tree.  Default value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_minimum_leaf_size">minimum_leaf_size</code></td>
<td>
<p>Minimum number of points in each leaf node. 
Default value &quot;1&quot; (integer).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_num_trees">num_trees</code></td>
<td>
<p>Number of trees in the random forest.  Default value
&quot;10&quot; (integer).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_print_training_accuracy">print_training_accuracy</code></td>
<td>
<p>If set, then the accuracy of the model on
the training set will be predicted (verbose must also be specified). 
Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_subspace_dim">subspace_dim</code></td>
<td>
<p>Dimensionality of random subspace to use for each
split.  '0' will autoselect the square root of data dimensionality. 
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_test">test</code></td>
<td>
<p>Test dataset to produce predictions for (numeric matrix).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_test_labels">test_labels</code></td>
<td>
<p>Test dataset labels, if accuracy calculation is
desired (integer row).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_training">training</code></td>
<td>
<p>Training dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
<tr><td><code id="random_forest_+3A_warm_start">warm_start</code></td>
<td>
<p>If true and passed along with 'training' and
'input_model' then trains more trees on top of existing model.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program is an implementation of the standard random forest
classification algorithm by Leo Breiman.  A random forest can be trained and
saved for later use, or a random forest may be loaded and predictions or
class probabilities for points may be generated.
</p>
<p>The training set and associated labels are specified with the &quot;training&quot; and
&quot;labels&quot; parameters, respectively.  The labels should be in the range '[0,
num_classes - 1]'. Optionally, if &quot;labels&quot; is not specified, the labels are
assumed to be the last dimension of the training dataset.
</p>
<p>When a model is trained, the &quot;output_model&quot; output parameter may be used to
save the trained model.  A model may be loaded for predictions with the
&quot;input_model&quot;parameter. The &quot;input_model&quot; parameter may not be specified when
the &quot;training&quot; parameter is specified.  The &quot;minimum_leaf_size&quot; parameter
specifies the minimum number of training points that must fall into each leaf
for it to be split.  The &quot;num_trees&quot; controls the number of trees in the
random forest.  The &quot;minimum_gain_split&quot; parameter controls the minimum
required gain for a decision tree node to split.  Larger values will force
higher-confidence splits.  The &quot;maximum_depth&quot; parameter specifies the
maximum depth of the tree.  The &quot;subspace_dim&quot; parameter is used to control
the number of random dimensions chosen for an individual node's split.  If
&quot;print_training_accuracy&quot; is specified, the calculated accuracy on the
training set will be printed.
</p>
<p>Test data may be specified with the &quot;test&quot; parameter, and if performance
measures are desired for that test set, labels for the test points may be
specified with the &quot;test_labels&quot; parameter.  Predictions for each test point
may be saved via the &quot;predictions&quot;output parameter.  Class probabilities for
each prediction may be saved with the &quot;probabilities&quot; output parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>Model to save trained random forest to
(RandomForestModel).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Predicted classes for each point in the test set
(integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Predicted class probabilities for each point in the
test set (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to train a random forest with a minimum leaf size of 20 using
# 10 trees on the dataset contained in "data"with labels "labels", saving the
# output random forest to "rf_model" and printing the training error, one
# could call

## Not run: 
output &lt;- random_forest(training=data, labels=labels, minimum_leaf_size=20,
  num_trees=10, print_training_accuracy=TRUE)
rf_model &lt;- output$output_model

## End(Not run)

# Then, to use that model to classify points in "test_set" and print the test
# error given the labels "test_labels" using that model, while saving the
# predictions for each point to "predictions", one could call 

## Not run: 
output &lt;- random_forest(input_model=rf_model, test=test_set,
  test_labels=test_labels)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='Serialize'>Serialize/Unserialize an mlpack model.</h2><span id='topic+Serialize'></span><span id='topic+Unserialize'></span>

<h3>Description</h3>

<p>Serialize/Unserialize an mlpack model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Serialize(model, filename)

Unserialize(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Serialize_+3A_model">model</code></td>
<td>
<p>Input model pointer.</p>
</td></tr>
<tr><td><code id="Serialize_+3A_filename">filename</code></td>
<td>
<p>Input filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For Unserialize, Output model_ptr.
</p>

<hr>
<h2 id='softmax_regression'>Softmax Regression</h2><span id='topic+softmax_regression'></span>

<h3>Description</h3>

<p>An implementation of softmax regression for classification, which is a
multiclass generalization of logistic regression.  Given labeled data, a
softmax regression model can be trained and saved for future use, or, a
pre-trained softmax regression model can be used for classification of new
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softmax_regression(
  input_model = NA,
  labels = NA,
  lambda = NA,
  max_iterations = NA,
  no_intercept = FALSE,
  number_of_classes = NA,
  test = NA,
  test_labels = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="softmax_regression_+3A_input_model">input_model</code></td>
<td>
<p>File containing existing model (parameters)
(SoftmaxRegression).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_labels">labels</code></td>
<td>
<p>A matrix containing labels (0 or 1) for the points in the
training set (y). The labels must order as a row (integer row).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_lambda">lambda</code></td>
<td>
<p>L2-regularization constan.  Default value &quot;0.0001&quot;
(numeric).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations before termination. 
Default value &quot;400&quot; (integer).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_no_intercept">no_intercept</code></td>
<td>
<p>Do not add the intercept term to the model.  Default
value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_number_of_classes">number_of_classes</code></td>
<td>
<p>Number of classes for classification; if
unspecified (or 0), the number of classes found in the labels will be used.
Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_test">test</code></td>
<td>
<p>Matrix containing test dataset (numeric matrix).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_test_labels">test_labels</code></td>
<td>
<p>Matrix containing test labels (integer row).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_training">training</code></td>
<td>
<p>A matrix containing the training set (the matrix of
predictors, X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="softmax_regression_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This program performs softmax regression, a generalization of logistic
regression to the multiclass case, and has support for L2 regularization. 
The program is able to train a model, load  an existing model, and give
predictions (and optionally their accuracy) for test data.
</p>
<p>Training a softmax regression model is done by giving a file of training
points with the &quot;training&quot; parameter and their corresponding labels with the
&quot;labels&quot; parameter. The number of classes can be manually specified with the
&quot;number_of_classes&quot; parameter, and the maximum number of iterations of the
L-BFGS optimizer can be specified with the &quot;max_iterations&quot; parameter.  The
L2 regularization constant can be specified with the &quot;lambda&quot; parameter and
if an intercept term is not desired in the model, the &quot;no_intercept&quot;
parameter can be specified.
</p>
<p>The trained model can be saved with the &quot;output_model&quot; output parameter. If
training is not desired, but only testing is, a model can be loaded with the
&quot;input_model&quot; parameter.  At the current time, a loaded model cannot be
trained further, so specifying both &quot;input_model&quot; and &quot;training&quot; is not
allowed.
</p>
<p>The program is also able to evaluate a model on test data.  A test dataset
can be specified with the &quot;test&quot; parameter. Class predictions can be saved
with the &quot;predictions&quot; output parameter.  If labels are specified for the
test data with the &quot;test_labels&quot; parameter, then the program will print the
accuracy of the predictions on the given test set and its corresponding
labels.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>output_model</code></td>
<td>
<p>File to save trained softmax regression model to
(SoftmaxRegression).</p>
</td></tr>
<tr><td><code>predictions</code></td>
<td>
<p>Matrix to save predictions for test dataset into
(integer row).</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>
<p>Matrix to save class probabilities for test dataset
into (numeric matrix).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For example, to train a softmax regression model on the data "dataset" with
# labels "labels" with a maximum of 1000 iterations for training, saving the
# trained model to "sr_model", the following command can be used: 

## Not run: 
output &lt;- softmax_regression(training=dataset, labels=labels)
sr_model &lt;- output$output_model

## End(Not run)

# Then, to use "sr_model" to classify the test points in "test_points",
# saving the output predictions to "predictions", the following command can
# be used:

## Not run: 
output &lt;- softmax_regression(input_model=sr_model, test=test_points)
predictions &lt;- output$predictions

## End(Not run)
</code></pre>

<hr>
<h2 id='sparse_coding'>Sparse Coding</h2><span id='topic+sparse_coding'></span>

<h3>Description</h3>

<p>An implementation of Sparse Coding with Dictionary Learning.  Given a
dataset, this will decompose the dataset into a sparse combination of a few
dictionary elements, where the dictionary is learned during computation; a
dictionary can be reused for future sparse coding of new points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_coding(
  atoms = NA,
  initial_dictionary = NA,
  input_model = NA,
  lambda1 = NA,
  lambda2 = NA,
  max_iterations = NA,
  newton_tolerance = NA,
  normalize = FALSE,
  objective_tolerance = NA,
  seed = NA,
  test = NA,
  training = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_coding_+3A_atoms">atoms</code></td>
<td>
<p>Number of atoms in the dictionary.  Default value &quot;15&quot;
(integer).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_initial_dictionary">initial_dictionary</code></td>
<td>
<p>Optional initial dictionary matrix (numeric
matrix).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_input_model">input_model</code></td>
<td>
<p>File containing input sparse coding model
(SparseCoding).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_lambda1">lambda1</code></td>
<td>
<p>Sparse coding l1-norm regularization parameter.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_lambda2">lambda2</code></td>
<td>
<p>Sparse coding l2-norm regularization parameter.  Default
value &quot;0&quot; (numeric).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for sparse coding (0
indicates no limit).  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_newton_tolerance">newton_tolerance</code></td>
<td>
<p>Tolerance for convergence of Newton method. 
Default value &quot;1e-06&quot; (numeric).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_normalize">normalize</code></td>
<td>
<p>If set, the input data matrix will be normalized before
coding.  Default value &quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_objective_tolerance">objective_tolerance</code></td>
<td>
<p>Tolerance for convergence of the objective
function.  Default value &quot;0.01&quot; (numeric).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_seed">seed</code></td>
<td>
<p>Random seed.  If 0, 'std::time(NULL)' is used.  Default
value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_test">test</code></td>
<td>
<p>Optional matrix to be encoded by trained model (numeric
matrix).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_training">training</code></td>
<td>
<p>Matrix of training data (X) (numeric matrix).</p>
</td></tr>
<tr><td><code id="sparse_coding_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An implementation of Sparse Coding with Dictionary Learning, which achieves
sparsity via an l1-norm regularizer on the codes (LASSO) or an (l1+l2)-norm
regularizer on the codes (the Elastic Net).  Given a dense data matrix X with
d dimensions and n points, sparse coding seeks to find a dense dictionary
matrix D with k atoms in d dimensions, and a sparse coding matrix Z with n
points in k dimensions.
</p>
<p>The original data matrix X can then be reconstructed as Z * D.  Therefore,
this program finds a representation of each point in X as a sparse linear
combination of atoms in the dictionary D.
</p>
<p>The sparse coding is found with an algorithm which alternates between a
dictionary step, which updates the dictionary D, and a sparse coding step,
which updates the sparse coding matrix.
</p>
<p>Once a dictionary D is found, the sparse coding model may be used to encode
other matrices, and saved for future usage.
</p>
<p>To run this program, either an input matrix or an already-saved sparse coding
model must be specified.  An input matrix may be specified with the
&quot;training&quot; option, along with the number of atoms in the dictionary
(specified with the &quot;atoms&quot; parameter).  It is also possible to specify an
initial dictionary for the optimization, with the &quot;initial_dictionary&quot;
parameter.  An input model may be specified with the &quot;input_model&quot;
parameter.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>codes</code></td>
<td>
<p>Matrix to save the output sparse codes of the test matrix
(&ndash;test_file) to (numeric matrix).</p>
</td></tr>
<tr><td><code>dictionary</code></td>
<td>
<p>Matrix to save the output dictionary to (numeric
matrix).</p>
</td></tr>
<tr><td><code>output_model</code></td>
<td>
<p>File to save trained sparse coding model to
(SparseCoding).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, to build a sparse coding model on the dataset "data" using
# 200 atoms and an l1-regularization parameter of 0.1, saving the model into
# "model", use 

## Not run: 
output &lt;- sparse_coding(training=data, atoms=200, lambda1=0.1)
model &lt;- output$output_model

## End(Not run)

# Then, this model could be used to encode a new matrix, "otherdata", and
# save the output codes to "codes": 

## Not run: 
output &lt;- sparse_coding(input_model=model, test=otherdata)
codes &lt;- output$codes

## End(Not run)
</code></pre>

<hr>
<h2 id='test_r_binding'>R binding test</h2><span id='topic+test_r_binding'></span>

<h3>Description</h3>

<p>A simple program to test R binding functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_r_binding(
  double_in,
  int_in,
  string_in,
  build_model = FALSE,
  col_in = NA,
  flag1 = FALSE,
  flag2 = FALSE,
  matrix_and_info_in = NA,
  matrix_in = NA,
  model_in = NA,
  row_in = NA,
  str_vector_in = NA,
  tmatrix_in = NA,
  ucol_in = NA,
  umatrix_in = NA,
  urow_in = NA,
  vector_in = NA,
  verbose = getOption("mlpack.verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_r_binding_+3A_double_in">double_in</code></td>
<td>
<p>Input double, must be 4.0 (numeric).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_int_in">int_in</code></td>
<td>
<p>Input int, must be 12 (integer).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_string_in">string_in</code></td>
<td>
<p>Input string, must be 'hello' (character).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_build_model">build_model</code></td>
<td>
<p>If true, a model will be returned.  Default value
&quot;FALSE&quot; (logical).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_col_in">col_in</code></td>
<td>
<p>Input column (numeric column).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_flag1">flag1</code></td>
<td>
<p>Input flag, must be specified.  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_flag2">flag2</code></td>
<td>
<p>Input flag, must not be specified.  Default value &quot;FALSE&quot;
(logical).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_matrix_and_info_in">matrix_and_info_in</code></td>
<td>
<p>Input matrix and info (numeric
matrix/data.frame with info).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_matrix_in">matrix_in</code></td>
<td>
<p>Input matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_model_in">model_in</code></td>
<td>
<p>Input model (GaussianKernel).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_row_in">row_in</code></td>
<td>
<p>Input row (numeric row).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_str_vector_in">str_vector_in</code></td>
<td>
<p>Input vector of strings (character vector).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_tmatrix_in">tmatrix_in</code></td>
<td>
<p>Input (transposed) matrix (numeric matrix).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_ucol_in">ucol_in</code></td>
<td>
<p>Input unsigned column (integer column).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_umatrix_in">umatrix_in</code></td>
<td>
<p>Input unsigned matrix (integer matrix).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_urow_in">urow_in</code></td>
<td>
<p>Input unsigned row (integer row).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_vector_in">vector_in</code></td>
<td>
<p>Input vector of numbers (integer vector).</p>
</td></tr>
<tr><td><code id="test_r_binding_+3A_verbose">verbose</code></td>
<td>
<p>Display informational messages and the full list of
parameters and timers at the end of execution.  Default value
&quot;getOption(&quot;mlpack.verbose&quot;, FALSE)&quot; (logical).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple program to test R binding functionality.  You can build mlpack with
the BUILD_TESTS option set to off, and this binding will no longer be built.
</p>


<h3>Value</h3>

<p>A list with several components:
</p>
<table>
<tr><td><code>col_out</code></td>
<td>
<p>Output column. 2x input colum (numeric column).</p>
</td></tr>
<tr><td><code>double_out</code></td>
<td>
<p>Output double, will be 5.0.  Default value &quot;0&quot;
(numeric).</p>
</td></tr>
<tr><td><code>int_out</code></td>
<td>
<p>Output int, will be 13.  Default value &quot;0&quot; (integer).</p>
</td></tr>
<tr><td><code>matrix_and_info_out</code></td>
<td>
<p>Output matrix and info; all numeric elements
multiplied by 3 (numeric matrix).</p>
</td></tr>
<tr><td><code>matrix_out</code></td>
<td>
<p>Output matrix (numeric matrix).</p>
</td></tr>
<tr><td><code>model_bw_out</code></td>
<td>
<p>The bandwidth of the model.  Default value &quot;0&quot;
(numeric).</p>
</td></tr>
<tr><td><code>model_out</code></td>
<td>
<p>Output model, with twice the bandwidth
(GaussianKernel).</p>
</td></tr>
<tr><td><code>row_out</code></td>
<td>
<p>Output row.  2x input row (numeric row).</p>
</td></tr>
<tr><td><code>str_vector_out</code></td>
<td>
<p>Output string vector (character vector).</p>
</td></tr>
<tr><td><code>string_out</code></td>
<td>
<p>Output string, will be 'hello2'.  Default value &quot;&quot;
(character).</p>
</td></tr>
<tr><td><code>ucol_out</code></td>
<td>
<p>Output unsigned column. 2x input column (integer
column).</p>
</td></tr>
<tr><td><code>umatrix_out</code></td>
<td>
<p>Output unsigned matrix (integer matrix).</p>
</td></tr>
<tr><td><code>urow_out</code></td>
<td>
<p>Output unsigned row.  2x input row (integer row).</p>
</td></tr>
<tr><td><code>vector_out</code></td>
<td>
<p>Output vector (integer vector).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>mlpack developers
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
