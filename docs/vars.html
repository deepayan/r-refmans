<!DOCTYPE html><html><head><title>Help for package vars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Acoef'><p>Coefficient matrices of the lagged endogenous variables</p></a></li>
<li><a href='#arch.test'><p>ARCH-LM test</p></a></li>
<li><a href='#Bcoef'><p>Coefficient matrix of an estimated VAR(p)</p></a></li>
<li><a href='#BQ'><p>Estimates a Blanchard-Quah type SVAR</p></a></li>
<li><a href='#Canada'><p>Canada: Macroeconomic time series</p></a></li>
<li><a href='#causality'><p>Causality Analysis</p></a></li>
<li><a href='#coef'><p>Coefficient method for objects of class varest</p></a></li>
<li><a href='#fanchart'><p>Fanchart plot for objects of class varprd</p></a></li>
<li><a href='#fevd'><p>Forecast Error Variance Decomposition</p></a></li>
<li><a href='#fitted'><p>Fit method for objects of class varest or vec2var</p></a></li>
<li><a href='#irf'><p>Impulse response function</p></a></li>
<li><a href='#logLik'><p>Log-Likelihood method</p></a></li>
<li><a href='#normality.test'><p>Normality, multivariate skewness and kurtosis test</p></a></li>
<li><a href='#Phi'><p>Coefficient matrices of the MA represention</p></a></li>
<li><a href='#plot'><p>Plot methods for objects in vars</p></a></li>
<li><a href='#predict'><p>Predict method for objects of class varest and vec2var</p></a></li>
<li><a href='#Psi'><p>Coefficient matrices of the orthogonalised MA represention</p></a></li>
<li><a href='#residuals'><p>Residuals method for objects of class varest and vec2var</p></a></li>
<li><a href='#restrict'><p>Restricted VAR</p></a></li>
<li><a href='#roots'><p>Eigenvalues of the companion coefficient matrix of a VAR(p)-process</p></a></li>
<li><a href='#serial.test'><p>Test for serially correlated errors</p></a></li>
<li><a href='#stability'><p>Structural stability of a VAR(p)</p></a></li>
<li><a href='#summary'><p>Summary method for objects of class varest, svarest and svecest</p></a></li>
<li><a href='#SVAR'><p>Estimation of a SVAR</p></a></li>
<li><a href='#SVEC'><p>Estimation of a SVEC</p></a></li>
<li><a href='#VAR'><p>Estimation of a VAR(p)</p></a></li>
<li><a href='#vars-deprecated'><p>Deprecated Functions in package vars</p></a></li>
<li><a href='#VARselect'><p>Information criteria and FPE for different VAR(p)</p></a></li>
<li><a href='#vec2var'><p>Transform a VECM to VAR in levels</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>VAR Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.0.0), MASS, strucchange, urca (&ge; 1.1-6), lmtest (&ge;
0.9-26), sandwich (&ge; 2.2-4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation, lag selection, diagnostic testing, forecasting, causality analysis, forecast error variance decomposition and impulse response functions of VAR models and estimation of SVAR and SVEC models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.pfaffikus.de">https://www.pfaffikus.de</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Bernhard Pfaff [aut, cre],
  Matthieu Stigler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bernhard Pfaff &lt;bernhard@pfaffikus.de&gt;</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>vars</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>99</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2013-07-21 14:35:42</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 12:20:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 21:22:36 UTC; bp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='Acoef'>Coefficient matrices of the lagged endogenous variables</h2><span id='topic+Acoef'></span><span id='topic+A-deprecated'></span>

<h3>Description</h3>

<p>Returns the estimated coefficient matrices of the lagged endogenous
variables as a list of matrices each with dimension <code class="reqn">(K \times K)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Acoef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Acoef_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by <code>VAR()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an estimated VAR(p) of the form:
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\bold{y}}_t = \hat{A}_1 \bold{y}_{t-1} + \ldots +
    \hat{A}_p \bold{y}_{t-p} + \hat{C}D_t
  </code>
</p>

<p>the function returns the matrices <code class="reqn">(\hat{A}_1,  \ldots, \hat{A}_p)</code>
each with dimension <code class="reqn">(K \times K)</code> as a list object. 
</p>


<h3>Value</h3>

<p>A list object with coefficient matrices for the lagged endogenous variables.
</p>


<h3>Note</h3>

<p>This function was named <code>A</code> in earlier versions of package
<span class="pkg">vars</span>; it is now deprecated. See <code><a href="#topic+vars-deprecated">vars-deprecated</a></code> too.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bcoef">Bcoef</a></code>, <code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
Acoef(var.2c)
</code></pre>

<hr>
<h2 id='arch.test'>ARCH-LM test</h2><span id='topic+arch.test'></span><span id='topic+arch-deprecated'></span><span id='topic+print.varcheck'></span>

<h3>Description</h3>

<p>This function computes univariate and multivariate ARCH-LM tests for a
VAR(p).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arch.test(x, lags.single = 16, lags.multi = 5, multivariate.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arch.test_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;; generated by
<code>vec2var()</code>.</p>
</td></tr>
<tr><td><code id="arch.test_+3A_lags.single">lags.single</code></td>
<td>
<p>An integer specifying the lags to be used for the
univariate ARCH statistics.</p>
</td></tr>
<tr><td><code id="arch.test_+3A_lags.multi">lags.multi</code></td>
<td>
<p>An integer specifying the lags to be used for the
multivariate ARCH statistic.</p>
</td></tr>
<tr><td><code id="arch.test_+3A_multivariate.only">multivariate.only</code></td>
<td>
<p>If <code>TRUE</code> (the default), only
the multivariate test statistic is computed.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The multivariate ARCH-LM test is based on the following regression
(the univariate test can be considered as special case of the
exhibtion below and is skipped):
</p>
<p style="text-align: center;"><code class="reqn">
    vech(\bold{\hat{u}}_t \bold{\hat{u}}_t') = \bold{\beta}_0 + B_1
    vech(\bold{\hat{u}}_{t-1} \bold{\hat{u}}_{t-1}') + \ldots + B_q
    vech(\bold{\hat{u}}_{t-q} \bold{\hat{u}}_{t-q}' + \bold{v}_t)
  </code>
</p>

<p>whereby <code class="reqn">\bold{v}_t</code> assigns a spherical error process and
<code class="reqn">vech</code> is the column-stacking operator for symmetric matrices
that stacks the columns from the main diagonal on downwards. The
dimension of <code class="reqn">\bold{\beta}_0</code> is <code class="reqn">\frac{1}{2}K(K +1)</code> and for
the coefficient matrices <code class="reqn">B_i</code> with <code class="reqn">i=1, \ldots, q</code>,
<code class="reqn">\frac{1}{2}K(K +1) \times \frac{1}{2}K(K +1)</code>. The null
hypothesis is: <code class="reqn">H_0 := B_1 = B_2 = \ldots = B_q = 0</code> and the
alternative is: <code class="reqn">H_1: B_1 \neq 0 or B_2 \neq 0 or \ldots B_q  \neq
    0</code>.
The test statistic is:
</p>
<p style="text-align: center;"><code class="reqn">
    VARCH_{LM}(q) = \frac{1}{2}T K (K + 1)R_m^2 \quad ,
  </code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">
    R_m^2 = 1 - \frac{2}{K(K+1)}tr(\hat{\Omega} \hat{\Omega}_0^{-1})
    \quad ,
  </code>
</p>

<p>and <code class="reqn">\hat{\Omega}</code> assigns the covariance matrix of the above
defined regression model. This test statistic is distributed as
<code class="reqn">\chi^2(qK^2(K+1)^2/4)</code>.      
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varcheck</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>resid</code></td>
<td>
<p>A matrix with the residuals of the VAR.</p>
</td></tr>
<tr><td><code>arch.uni</code></td>
<td>
<p>A list with objects of class &lsquo;<code>htest</code>&rsquo;
containing the univariate ARCH-LM tests per equation. This element
is only returned if <code>multivariate.only = FALSE</code> is set.</p>
</td></tr>
<tr><td><code>arch.mul</code></td>
<td>
<p>An object with class attribute &lsquo;<code>htest</code>&rsquo;
containing the multivariate ARCH-LM statistic.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was named <code>arch</code> in earlier versions of package
<span class="pkg">vars</span>; it is now deprecated. See <code><a href="#topic+vars-deprecated">vars-deprecated</a></code> too.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Doornik, J. A. and D. F. Hendry (1997), <em>Modelling Dynamic
Systems Using PcFiml 9.0 for Windows</em>, International Thomson
Business Press, London.
</p>
<p>Engle, R. F. (1982), Autoregressive conditional heteroscedasticity
with estimates of the variance of United Kingdom inflation,
<em>Econometrica</em>, <b>50</b>: 987-1007.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="#topic+resid">resid</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
arch.test(var.2c)
</code></pre>

<hr>
<h2 id='Bcoef'>Coefficient matrix of an estimated VAR(p)</h2><span id='topic+Bcoef'></span><span id='topic+B-deprecated'></span>

<h3>Description</h3>

<p>Returns the estimated coefficients of a VAR(p) as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bcoef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bcoef_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by <code>VAR()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an estimated VAR of the form:
</p>
<p style="text-align: center;"><code class="reqn">
    \hat{\bold{y}}_t = \hat{A}_1 \bold{y}_{t-1} + \ldots +
    \hat{A}_p \bold{y}_{t-p} + \hat{C}D_t
  </code>
</p>

<p>the function returns the matrices <code class="reqn">(\hat{A}_1 | \ldots |
    \hat{A}_p | \hat{C})</code> as a matrix object.
</p>


<h3>Value</h3>

<p>A matrix holding the estimated coefficients of a VAR.
</p>


<h3>Note</h3>

<p>This function was named <code>B</code> in earlier versions of package
<span class="pkg">vars</span>; it is now deprecated. See <code><a href="#topic+vars-deprecated">vars-deprecated</a></code> too.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>See Also</h3>

<p><code><a href="#topic+Acoef">Acoef</a></code>, <code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
Bcoef(var.2c)
</code></pre>

<hr>
<h2 id='BQ'>Estimates a Blanchard-Quah type SVAR</h2><span id='topic+BQ'></span>

<h3>Description</h3>

<p>This function estimates a SVAR of type Blanchard and Quah. It returns
a list object with class attribute &lsquo;<code>svarest</code>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BQ(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BQ_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a Blanchard-Quah model the matrix <code class="reqn">A</code> is set to be an identity
matrix with dimension <code class="reqn">K</code>. The matrix of the long-run effects is
assumed to be lower-triangular and is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    (I_K - A_1 - \cdots - A_p)^{-1}B
  </code>
</p>

<p>Hence, the residual of the second equation cannot exert a long-run
influence on the first variable and likewise the third residual cannot
impact the first and second variable. The estimation of the
Blanchard-Quah model is achieved by a Choleski decomposition of:
</p>
<p style="text-align: center;"><code class="reqn">
    (I_K - \hat{A}_1 - \cdots - \hat{A}_p)^{-1}\hat{\Sigma}_u (I_K -
    \hat{A}_1' - \cdots - \hat{A}_p')^{-1}
  </code>
</p>

<p>The matrices <code class="reqn">\hat{A}_i</code> for <code class="reqn">i = 1, \ldots, p</code> assign the
reduced form estimates. The long-run impact matrix is the
lower-triangular Choleski decomposition of the above matrix and the
contemporaneous impact matrix is equal to:
</p>
<p style="text-align: center;"><code class="reqn">
    (I_K - A_1 - \cdots - A_p)Q
  </code>
</p>

<p>where <code class="reqn">Q</code> assigns the lower-trinagular Choleski decomposition.
</p>


<h3>Value</h3>

<p>A list of class &lsquo;<code>svarest</code>&rsquo; with the following elements is
returned:<br />
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>An identity matrix.</p>
</td></tr>
<tr><td><code>Ase</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The estimated contemporaneous impact matrix.</p>
</td></tr>
<tr><td><code>Bse</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>LRIM</code></td>
<td>
<p>The estimated long-run impact matrix.</p>
</td></tr>  
<tr><td><code>Sigma.U</code></td>
<td>
<p>The variance-covariance matrix of the reduced form
residuals times 100.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character: &ldquo;Blanchard-Quah&rdquo;.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The &lsquo;<code>varest</code>&rsquo; object &lsquo;<code>x</code>&rsquo;.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>BQ()</code>.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Blanchard, O. and D. Quah (1989), The Dynamic Effects of Aggregate
Demand and Supply Disturbances, <em>The American Economic Review</em>,
<b>79</b>(4), 655-673.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
BQ(var.2c)
</code></pre>

<hr>
<h2 id='Canada'>Canada: Macroeconomic time series</h2><span id='topic+Canada'></span>

<h3>Description</h3>

<p>The original time series are published by the <abbr><span class="acronym">OECD</span></abbr>. The
sample range is from the 1stQ 1980 until 4thQ 2000. The following
series have been utilised in the construction of the series provided
in <code>Canada</code>:<br />
<br />
<em>Main Economic Indicators:</em><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    Canadian unemployment rate in % </td><td style="text-align: left;"> 444113DSA </td>
</tr>
<tr>
 <td style="text-align: left;">
    Canadian manufacturing real wage </td><td style="text-align: left;"> 444321KSA </td>
</tr>
<tr>
 <td style="text-align: left;">
    Canadian consumer price index </td><td style="text-align: left;"> 445241K </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><em>Quarterly National Accounts:</em><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    Canadian nominal GDP </td><td style="text-align: left;"> CAN1008S1</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><em>Labour Force Statistics:</em><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    Canadian civil employment in 1000 persons </td><td style="text-align: left;"> 445005DSA</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The series in <code>Canada</code> are constructed as:<br />
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>prod</code> := </td><td style="text-align: left;"> 100*(ln(CAN1008S1/445241K)-ln(445005DSA))</td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>e</code> := </td><td style="text-align: left;"> 100*ln(445005DSA)</td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>U</code> := </td><td style="text-align: left;"> 444113DSA</td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>rw</code> := </td><td style="text-align: left;"> 100*ln(100*444321KSA)</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>Hence, <code>prod</code> is used as a measure of labour productivity;
<code>e</code> is used for employment; <code>U</code> is the unemployment rate and
<code>rw</code> assigns the real wage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Canada</code></pre>


<h3>Format</h3>

<p>An object with class attributes <code>mts</code> and <code>ts</code> containing four variables with 84 observations.</p>


<h3>Source</h3>

<p><abbr><span class="acronym">OECD</span></abbr>: <a href="https://www.oecd.org">https://www.oecd.org</a>; data set is available
for download at <a href="http://www.jmulti.org/data_atse.html">http://www.jmulti.org/data_atse.html</a>, the
official homepage of <abbr><span class="acronym">JMULTI</span></abbr> is
<a href="http://www.jmulti.com">http://www.jmulti.com</a>. The book resource for JMULTI is:
Luetkepohl, H. and Kraetzig, M., <em>Applied Time Series
Econometrics</em>, Cambridge University Press, Cambridge, 2004.</p>

<hr>
<h2 id='causality'>Causality Analysis</h2><span id='topic+causality'></span>

<h3>Description</h3>

<p>Computes the test statistics for Granger- and Instantaneous causality
for a VAR(p). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>causality(x, cause = NULL, vcov.=NULL, boot=FALSE, boot.runs=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="causality_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>.</p>
</td></tr> 
<tr><td><code id="causality_+3A_cause">cause</code></td>
<td>
<p>A character vector of the cause variable(s). If not set,
then the variable in the first column of <code>x$y</code> is used as cause
variable and a warning is printed.</p>
</td></tr>   
<tr><td><code id="causality_+3A_vcov.">vcov.</code></td>
<td>
<p>a specification of the covariance matrix of the estimated coefficients. This can be
specified as a matrix or as a function yielding a matrix when applied to <code>x</code>.</p>
</td></tr>
<tr><td><code id="causality_+3A_boot">boot</code></td>
<td>
<p>Logical. Whether a wild bootstrap procedure should be used to compute the critical values. Default is no</p>
</td></tr>
<tr><td><code id="causality_+3A_boot.runs">boot.runs</code></td>
<td>
<p>Number of bootstrap replications if boot=TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two causality tests are implemented. The first is a F-type
Granger-causality test and the second is a Wald-type test that is
characterized by testing for nonzero correlation between the error
processes of the cause and effect variables. For both tests the vector
of endogenous variables <code class="reqn">\bold{y}_t</code> is split into two subvectors
<code class="reqn">\bold{y}_{1t}</code> and <code class="reqn">\bold{y}_{2t}</code> with dimensions <code class="reqn">(K_1
    \times 1)</code> and <code class="reqn">(K_2 \times 1)</code> with <code class="reqn">K = K_1 + K_2</code>.<br />
For the rewritten VAR(p):
</p>
<p style="text-align: center;"><code class="reqn">
    [\bold{y}_{1t} , \bold{y}_{2t}] = \sum_{i=1}^p [\bold{\alpha}_{11, i}' ,
    \bold{\alpha}_{12, i}' | \bold{\alpha}_{21, i}' , \bold{\alpha}_{22,
      i}'][\bold{y}_{1,t-i}, \bold{y}_{2, t-i}] + CD_t + [\bold{u}_{1t},
    \bold{u}_{2t}]  \quad ,
  </code>
</p>

<p>the null hypothesis that the subvector <code class="reqn">\bold{y}_{1t}</code> does not
Granger-cause <code class="reqn">\bold{y}_{2t}</code>, is defined as
<code class="reqn">\bold{\alpha}_{21, i} = 0</code> for <code class="reqn">i = 1, 2, \ldots, p</code>. The
alternative is: <code class="reqn">\exists \; \bold{\alpha}_{21,i} \ne 0</code> for <code class="reqn">i =
    1, 2, \ldots, p</code>. The test statistic is distributed as <code class="reqn">F(p K_1
    K_2, KT - n^*)</code>, with <code class="reqn">n^*</code> equal to the total number of
parameters in the above VAR(p) (including deterministic
regressors).<br />
The null hypothesis for instantaneous causality is defined as:
<code class="reqn">H_0: C \bold{\sigma} = 0</code>, where <code class="reqn">C</code> is a <code class="reqn">(N \times K(K
    + 1)/2)</code> matrix of rank <code class="reqn">N</code> selecting the relevant co-variances of
<code class="reqn">\bold{u}_{1t}</code> and <code class="reqn">\bold{u}_{2t}</code>; <code class="reqn">\bold{\sigma} =
    vech(\Sigma_u)</code>. The Wald statistic is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda_W = T \tilde{\bold{\sigma}}'C'[2 C D_{K}^{+}(\tilde{\Sigma}_u
    \otimes \tilde{\Sigma}_u) D_{K}^{+'} C']^{-1} C
    \tilde{\bold{\sigma}}  \quad , 
  </code>
</p>

<p>hereby assigning the Moore-Penrose inverse of the duplication matrix
<code class="reqn">D_K</code> with <code class="reqn">D_{K}^{+}</code> and <code class="reqn">\tilde{\Sigma}_u =
    \frac{1}{T}\sum_{t=1}^T \hat{\bold{u}}_t \hat{\bold{u}}_t'</code>. The
duplication matrix <code class="reqn">D_K</code> has dimension <code class="reqn">(K^2 \times
    \frac{1}{2}K(K + 1))</code> and is defined such that for any symmetric
<code class="reqn">(K \times K)</code> matrix A, <code class="reqn">vec(A) = D_K vech(A)</code> holds. The
test statistic <code class="reqn">\lambda_W</code> is asymptotically distributed as
<code class="reqn">\chi^2(N)</code>.
</p>
<p>Fot the Granger causality test, a robust covariance-matrix estimator can be 
used in case of heteroskedasticity through argument <code>vcov.</code> It can be either a pre-computed matrix or
a function for extracting the covariance matrix. See <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code>
from package <span class="pkg">sandwich</span> for further details. 
</p>
<p>A wild bootstrap computation (imposing the restricted model as null)
of the p values is available through argument <code>boot</code> and <code>boot.runs</code> following Hafner and Herwartz (2009). 
</p>


<h3>Value</h3>

<p>A list with elements of class &lsquo;<code>htest</code>&rsquo;:<br />
</p>
<table>
<tr><td><code>Granger</code></td>
<td>
<p>The result of the Granger-causality test.</p>
</td></tr>
<tr><td><code>Instant</code></td>
<td>
<p>The result of the instantaneous causality test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Moore-Penrose inverse matrix is computed with the function
<code><a href="MASS.html#topic+ginv">ginv</a></code> contained in the package &lsquo;<code>MASS</code>&rsquo;.<br />
The Granger-causality test is problematic if some of the
variables are nonstationary. In that case the usual asymptotic
distribution of the test statistic may not be valid under the null
hypothesis.  
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Granger, C. W. J. (1969), Investigating causal relations by
econometric models and cross-spectral methods, <em>Econometrica</em>,
<b>37</b>: 424-438. 
</p>
<p>Hafner, C. M. and Herwartz, H. (2009) Testing for linear vector autoregressive 
dynamics under multivariate generalized autoregressive heteroskedasticity, 
<em>Statistica Neerlandica</em>, <b>63</b>: 294-323
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>
<p>Venables, W. N. and B. D. Ripley (2002), <em>Modern Applied
Statistics with S</em>, 4th edition, Springer, New York.
</p>
<p>Zeileis, A. (2006) Object-Oriented Computation of Sandwich Estimators
<em>Journal of Statistical Software</em>, <b>16</b>, 1-16
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
causality(var.2c, cause = "e")

#use a robust HC variance-covariance matrix for the Granger test:
causality(var.2c, cause = "e", vcov.=vcovHC(var.2c))

#use a wild-bootstrap procedure to for the Granger test
## Not run: causality(var.2c, cause = "e", boot=TRUE, boot.runs=1000)
</code></pre>

<hr>
<h2 id='coef'>Coefficient method for objects of class varest</h2><span id='topic+coef'></span><span id='topic+coefficients'></span><span id='topic+coef.varest'></span>

<h3>Description</h3>

<p>Returns the coefficients of a VAR(p)-model for objects generated by
<code>VAR()</code>. Thereby the coef-method is applied to the summary of
the list element <code>varresult</code>, which is itself a list of
<code>summary.lm</code>-objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code></p>
</td></tr> 
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
coef(var.2c)
</code></pre>

<hr>
<h2 id='fanchart'>Fanchart plot for objects of class varprd</h2><span id='topic+fanchart'></span>

<h3>Description</h3>

<p>Time Series plots of VAR forecasts with differently shaded confidence
regions (fanchart) for each endogenous variable. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fanchart(x, colors = NULL, cis = NULL, names = NULL, main = NULL, ylab =
NULL, xlab = NULL, col.y = NULL, nc, plot.type = c("multiple",
"single"), mar = par("mar"), oma = par("oma"), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fanchart_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varprd</code>&rsquo;; generated by
<code>predict()</code>.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_colors">colors</code></td>
<td>
<p>Character vector of colors to be used for shading. If
unset, a gray color scheme is used.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_cis">cis</code></td>
<td>
<p>A numeric vector of confidence intervals. If unset the
sequence from 0.1 to 0.9 is used (step size 0.1).</p>
</td></tr>
<tr><td><code id="fanchart_+3A_names">names</code></td>
<td>
<p>Character vector, names of variables for fancharts. If
unset, all variables are plotted.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_main">main</code></td>
<td>
<p>Character vector, title for fanchart plots.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_ylab">ylab</code></td>
<td>
<p>Character, ylab for fanchart.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_xlab">xlab</code></td>
<td>
<p>Character, xlab for fanchart.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_col.y">col.y</code></td>
<td>
<p>Character, color for plotted time series.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_plot.type">plot.type</code></td>
<td>
<p>Character, if multiple all fancharts appear in one
device.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_nc">nc</code></td>
<td>
<p>Integer, number of columns if plot.type is multiple.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_mar">mar</code></td>
<td>
<p>Vector, setting of margins.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_oma">oma</code></td>
<td>
<p>Vector, setting of outer margins.</p>
</td></tr>
<tr><td><code id="fanchart_+3A_...">...</code></td>
<td>
<p>Dot argument, passed to plot.ts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Britton, E., P.G. Fisher and J.D. Whitley (1998), Inflation Report
projections: understanding the fan chart, <em>Bank of England
Quarterly Bulletin</em>, February, Bank of England, pages 30-37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+predict">predict</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
var.2c.prd &lt;- predict(var.2c, n.ahead = 8, ci = 0.95)
fanchart(var.2c.prd)

## End(Not run)
</code></pre>

<hr>
<h2 id='fevd'>Forecast Error Variance Decomposition</h2><span id='topic+fevd'></span><span id='topic+fevd.varest'></span><span id='topic+fevd.svarest'></span><span id='topic+fevd.svecest'></span><span id='topic+fevd.vec2var'></span><span id='topic+print.varfevd'></span>

<h3>Description</h3>

<p>Computes the forecast error variance decomposition of a VAR(p) for
<code>n.ahead</code> steps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
fevd(x, n.ahead=10, ...)
## S3 method for class 'svarest'
fevd(x, n.ahead=10, ...)
## S3 method for class 'svecest'
fevd(x, n.ahead=10, ...)
## S3 method for class 'vec2var'
fevd(x, n.ahead=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fevd_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>svarest</code>&rsquo;;
generated by <code>SVAR()</code>, or an object of class
&lsquo;<code>vec2var</code>&rsquo;; generated by <code>vec2var()</code>, or an
object of class &lsquo;<code>svecest</code>&rsquo;; generated by <code>SVEC()</code>.</p>
</td></tr>  
<tr><td><code id="fevd_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="fevd_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecast error variance decomposition is based upon the
orthogonalised impulse response coefficient matrices <code class="reqn">\Psi_h</code> and
allow the user to analyse the contribution of variable <code class="reqn">j</code> to the
h-step forecast error variance of variable <code class="reqn">k</code>. If the
orthogonalised impulse reponses are divided by the variance of the
forecast error <code class="reqn">\sigma_k^2(h)</code>, the resultant is a percentage
figure. Formally:
</p>
<p style="text-align: center;"><code class="reqn">
    \sigma_k^2(h) = \sum_{n=0}^{h-1}(\psi_{k1, n}^2 + \ldots + \psi_{kK, n}^2)
  </code>
</p>

<p>which can be written as:
</p>
<p style="text-align: center;"><code class="reqn">
    \sigma_k^2(h) = \sum_{j=1}^K(\psi_{kj, 0}^2 + \ldots + \psi_{kj,
      h-1}^2) \quad.
  </code>
</p>

<p>Dividing the term <code class="reqn">(\psi_{kj, 0}^2 + \ldots + \psi_{kj, h-1}^2)</code>
by <code class="reqn">\sigma_k^2(h)</code> yields the forecast error variance
decompositions in percentage terms.
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varfevd</code>&rsquo; of length <code>K</code>
holding the forecast error variances as matrices.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>,
<code><a href="#topic+SVEC">SVEC</a></code>, <code><a href="#topic+Phi">Phi</a></code>, <code><a href="#topic+Psi">Psi</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
fevd(var.2c, n.ahead = 5)
</code></pre>

<hr>
<h2 id='fitted'>Fit method for objects of class varest or vec2var</h2><span id='topic+fitted'></span><span id='topic+fitted.values'></span><span id='topic+fitted.varest'></span><span id='topic+fitted.vec2var'></span>

<h3>Description</h3>

<p>Returns the fitted values of a VAR(p)-model for objects generated by
<code>VAR()</code> or <code>vec2var()</code>. For objects of class varest
the fitted.values-method is applied to the list element
<code>varresult</code>, which is itself a list of <code>lm</code>-objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
fitted(object, ...)
## S3 method for class 'vec2var'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;;
generated by <code>vec2var()</code>.</p>
</td></tr> 
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
fitted(var.2c)
</code></pre>

<hr>
<h2 id='irf'>Impulse response function</h2><span id='topic+irf'></span><span id='topic+print.varirf'></span><span id='topic+irf.varest'></span><span id='topic+irf.svarest'></span><span id='topic+irf.svecest'></span><span id='topic+irf.vec2var'></span>

<h3>Description</h3>

<p>Computes the impulse response coefficients of a VAR(p) (or transformed
VECM to VAR(p)) or a SVAR for <code>n.ahead</code> steps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
irf(x, impulse = NULL, response = NULL, n.ahead = 10,
ortho = TRUE, cumulative = FALSE, boot = TRUE, ci = 0.95,
runs = 100, seed = NULL, ...)
## S3 method for class 'svarest'
irf(x, impulse = NULL, response = NULL, n.ahead = 10,
ortho = TRUE, cumulative = FALSE, boot = TRUE, ci = 0.95,
runs = 100, seed = NULL, ...)
## S3 method for class 'vec2var'
irf(x, impulse = NULL, response = NULL, n.ahead = 10,
ortho = TRUE, cumulative = FALSE, boot = TRUE, ci = 0.95,
runs = 100, seed = NULL, ...)
## S3 method for class 'svecest'
irf(x, impulse = NULL, response = NULL, n.ahead = 10,
ortho = TRUE, cumulative = FALSE, boot = TRUE, ci = 0.95,
runs = 100, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or object of class &lsquo;<code>svarest</code>&rsquo;; generated by
<code>SVAR()</code>, or object of class &lsquo;<code>vec2var</code>&rsquo;; generated by
<code>vec2var()</code>, or object of class &lsquo;<code>svecest</code>&rsquo;;
generated by <code>SVEC()</code>.</p>
</td></tr>  
<tr><td><code id="irf_+3A_impulse">impulse</code></td>
<td>
<p>A character vector of the impulses, default is all
variables.</p>
</td></tr>  
<tr><td><code id="irf_+3A_response">response</code></td>
<td>
<p>A character vector of the responses, default is all
variables.</p>
</td></tr>  
<tr><td><code id="irf_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Integer specifying the steps.</p>
</td></tr>
<tr><td><code id="irf_+3A_ortho">ortho</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) the orthogonalised impulse
response coefficients are computed (only for objects of class
&lsquo;<code>varest</code>&rsquo;).</p>
</td></tr>    
<tr><td><code id="irf_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if <code>TRUE</code> the cumulated
impulse response coefficients are computed. The default value is false.</p>
</td></tr>  
<tr><td><code id="irf_+3A_boot">boot</code></td>
<td>
<p>Logical, if <code>TRUE</code> (the default) bootstrapped error
bands for the imuplse response coefficients are computed.</p>
</td></tr>  
<tr><td><code id="irf_+3A_ci">ci</code></td>
<td>
<p>Numeric, the confidence interval for the bootstrapped errors
bands.</p>
</td></tr>
<tr><td><code id="irf_+3A_runs">runs</code></td>
<td>
<p>An integer, specifying the runs for the bootstrap.</p>
</td></tr>
<tr><td><code id="irf_+3A_seed">seed</code></td>
<td>
<p>An integer, specifying the seed for the <code>rng</code> of the
bootstrap.</p>
</td></tr>
<tr><td><code id="irf_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The impulse response coefficients of a VAR(p) for <code>n.ahead</code> steps
are computed by utilising either the function <code>Phi()</code> or
<code>Psi()</code>. If <code>boot = TRUE</code> (the default), confidence
bands for a given width specified by <code>ci</code> are derived from
<code>runs</code> bootstrap. Hereby, it is at the users leisure to set a
<code>seed</code> for the random number generator.<br />
The standard percentile interval is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    CI_s = [s_{\alpha/2}^*, s_{1 - \alpha/2}^*] \quad ,
  </code>
</p>

<p>with <code class="reqn">s_{\alpha/2}^*</code> and <code class="reqn">s_{1 - \alpha/2}^*</code> are the
<code class="reqn">\alpha/2</code> and <code class="reqn">1 - \alpha/2</code> quantiles of the bootstrap
distribution of <code class="reqn">\Psi^*</code> or <code class="reqn">\Phi^*</code> depending whether
<code>ortho = TRUE</code>. In case <code>cumulative = TRUE</code>, the confidence
bands are calculated from the cumulated impulse response
coefficients. 
</p>


<h3>Value</h3>

<p>A list of class &lsquo;<code>varirf</code>&rsquo; with the following elements is
returned:<br />
</p>
<table>
<tr><td><code>irf</code></td>
<td>
<p>A list with matrices for each of the impulse variables
containing the impulse response coefficients.</p>
</td></tr>
<tr><td><code>Lower</code></td>
<td>
<p>If <code>boot = TRUE</code>, a list with matrices for each of
the impulse variables containing the lower bands.</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>If <code>boot = TRUE</code>, a list with matrices for each of
the impulse variables containing the upper bands.</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>Character vector holding the names of the response
variables.</p>
</td></tr>  
<tr><td><code>impulse</code></td>
<td>
<p>Character vector holding the names of the impulse  variables.</p>
</td></tr>
<tr><td><code>ortho</code></td>
<td>
<p>Logical, if <code>TRUE</code>, orthogonalised impulse reponses
have been computed.</p>
</td></tr>
<tr><td><code>cumulative</code></td>
<td>
<p>Logical, if <code>TRUE</code>, cumulated impulse reponses
have been computed.</p>
</td></tr>
<tr><td><code>runs</code></td>
<td>
<p>An integer, specifying the number of bootstrap runs.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Numeric, defining the confidence level.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>Logical, if <code>TRUE</code> bootstrapped error bands have been
computed.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Character, containing &lsquo;<code>class(x)</code>&rsquo;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Efron, B. and R. J. Tibshirani (1993), <em>An Introduction to the
Bootstrap</em>, Chapman and Hall, New York. 
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>,
<code><a href="#topic+SVEC">SVEC</a></code>, <code><a href="#topic+Phi">Phi</a></code>, <code><a href="#topic+Psi">Psi</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
## For VAR
var.2c &lt;- VAR(Canada, p = 2, type = "const")
irf(var.2c, impulse = "e", response = c("prod", "rw", "U"), boot =
FALSE)
## For SVAR
amat &lt;- diag(4)
diag(amat) &lt;- NA
svar.a &lt;- SVAR(var.2c, estmethod = "direct", Amat = amat)
irf(svar.a, impulse = "e", response = c("prod", "rw", "U"), boot =
FALSE)
</code></pre>

<hr>
<h2 id='logLik'>Log-Likelihood method</h2><span id='topic+logLik'></span><span id='topic+logLik.varest'></span><span id='topic+logLik.vec2var'></span><span id='topic+logLik.svarest'></span><span id='topic+logLik.svecest'></span>

<h3>Description</h3>

<p>Returns the log-Likelihood of a VAR, level-VECM,  SVAR or SVEC object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
logLik(object, ...)
## S3 method for class 'vec2var'
logLik(object, ...)
## S3 method for class 'svarest'
logLik(object, ...)
## S3 method for class 'svecest'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by
<code>VAR()</code>; or an object of class &lsquo;<code>vec2var</code>&rsquo;,
generated by <code>vec2var()</code>; or an object of class
&lsquo;<code>svarest</code>&rsquo;, generated by either <code>SVAR()</code> or
an object of class &lsquo;<code>svecest</code>&rsquo;, generated by <code>SVEC()</code>.</p>
</td></tr>  
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood of a VAR or level-VECM model is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    \log l = - \frac{K T}{2} \log 2 \pi - \frac{T}{2} \log |\Sigma_u| -
    \frac{1}{2} tr (U \Sigma^{-1}_u U')
  </code>
</p>

<p>and for a SVAR / SVEC model the log-likelihood takes the form of:
</p>
<p style="text-align: center;"><code class="reqn">
    \log l = - \frac{K T}{2} \log 2 \pi + \frac{T}{2} \log |A|^2 -
    \frac{T}{2} \log |B|^2 - \frac{T}{2} tr (A'B'^{-1}B^{-1}A\Sigma_u)
    </code>
</p>



<h3>Value</h3>

<p>An object with class attribute <code>logLik</code>.  
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+SVEC">SVEC</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
logLik(var.2c) 
</code></pre>

<hr>
<h2 id='normality.test'>Normality, multivariate skewness and kurtosis test</h2><span id='topic+normality.test'></span><span id='topic+normality-deprecated'></span>

<h3>Description</h3>

<p>This function computes univariate and multivariate Jarque-Bera tests
and multivariate skewness and kurtosis tests for the residuals of a
VAR(p) or of a VECM in levels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normality.test(x, multivariate.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normality.test_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;;
generated by <code>vec2var()</code>.</p>
</td></tr>
<tr><td><code id="normality.test_+3A_multivariate.only">multivariate.only</code></td>
<td>
<p>If <code>TRUE</code> (the default), only
multivariate test statistics are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate and univariate versions of the Jarque-Bera test are
applied to the residuals of a VAR. The multivariate version of this
test is computed by using the residuals that are standardized by a
Choleski decomposition of the variance-covariance matrix for the centered
residuals. Please note, that in this case the test result is dependant
upon the ordering of the variables.
</p>


<h3>Value</h3>

<p>A list of class &lsquo;<code>varcheck</code>&rsquo; with the following elements is
returned:<br />
</p>
<table>
<tr><td><code>resid</code></td>
<td>
<p>A matrix of the residuals.</p>
</td></tr>
<tr><td><code>jb.uni</code></td>
<td>
<p>A list of elements with class attribute
&lsquo;<code>htest</code>&rsquo; containing the univariate Jarque-Bera
tests. This element is only returned if <code>multivariate.only =
      FALSE</code> is set.</p>
</td></tr>
<tr><td><code>jb.mul</code></td>
<td>
<p>A list of elements with class attribute
&lsquo;<code>htest</code>&rsquo;.</p>
</td></tr></table>
<p> containing the mutlivariate Jarque-Bera
test, the multivariate Skewness and Kurtosis tests.    
</p>


<h3>Note</h3>

<p>This function was named <code>normality</code> in earlier versions of package
<span class="pkg">vars</span>; it is now deprecated. See <code><a href="#topic+vars-deprecated">vars-deprecated</a></code> too.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Jarque, C. M. and A. K. Bera (1987), A test for normality of
observations and regression residuals, <em>International Statistical
Review</em>, <b>55</b>: 163-172.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
normality.test(var.2c)
</code></pre>

<hr>
<h2 id='Phi'>Coefficient matrices of the MA represention</h2><span id='topic+Phi'></span><span id='topic+Phi.varest'></span><span id='topic+Phi.svarest'></span><span id='topic+Phi.svecest'></span><span id='topic+Phi.vec2var'></span>

<h3>Description</h3>

<p>Returns the estimated coefficient matrices of the moving average
representation of a stable VAR(p), of an SVAR as an array or a
converted VECM to VAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
Phi(x, nstep=10, ...)
## S3 method for class 'svarest'
Phi(x, nstep=10, ...)
## S3 method for class 'svecest'
Phi(x, nstep=10, ...)
## S3 method for class 'vec2var'
Phi(x, nstep=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Phi_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by
<code>VAR()</code>, or an object of class &lsquo;<code>svarest</code>&rsquo;,
generated by <code>SVAR()</code>, or an object of class
&lsquo;<code>svecest</code>&rsquo;, generated by <code>SVEC()</code>, or an object
of class &lsquo;<code>vec2var</code>&rsquo;, generated by <code>vec2var()</code>.</p>
</td></tr>  
<tr><td><code id="Phi_+3A_nstep">nstep</code></td>
<td>
<p>An integer specifying the number of moving error
coefficient matrices to be calculated.</p>
</td></tr>
<tr><td><code id="Phi_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the process <code class="reqn">\bold{y}_t</code> is stationary (<em>i.e.</em> <code class="reqn">I(0)</code>,
it has a Wold moving average representation in the form of:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_t = \Phi_0 \bold{u}_t + \Phi_1 \bold{u}_{t-1} + \Phi
    \bold{u}_{t-2} + \ldots ,
  </code>
</p>

<p>whith <code class="reqn">\Phi_0 = I_k</code> and the matrices <code class="reqn">\Phi_s</code> can be computed
recursively according to:
</p>
<p style="text-align: center;"><code class="reqn">
    \Phi_s = \sum_{j=1}^s \Phi_{s-j} A_j \quad s = 1, 2, \ldots ,
  </code>
</p>

<p>whereby <code class="reqn">A_j</code> are set to zero for <code class="reqn">j &gt; p</code>. The matrix elements
represent the impulse responses of the components of <code class="reqn">\bold{y}_t</code>
with respect to the shocks <code class="reqn">\bold{u}_t</code>. More precisely, the
<code class="reqn">(i, j)</code>th element of the matrix <code class="reqn">\Phi_s</code> mirrors the expected
response of <code class="reqn">y_{i, t+s}</code> to a unit change of the variable
<code class="reqn">y_{jt}</code>.
<br />
In case of a SVAR, the impulse response matrices are given by:
</p>
<p style="text-align: center;"><code class="reqn">
    \Theta_i = \Phi_i A^{-1} B \quad .
  </code>
</p>

<p>Albeit the fact, that the Wold decomposition does not exist for
nonstationary processes, it is however still possible to compute the
<code class="reqn">\Phi_i</code> matrices likewise with integrated variables or for the
level version of a VECM. However, a convergence to zero of
<code class="reqn">\Phi_i</code> as i tends to infinity is not ensured; hence some shocks
may have a permanent effect.  
</p>


<h3>Value</h3>

<p>An array with dimension <code class="reqn">(K \times K \times nstep + 1)</code> holding the
estimated coefficients of the moving average representation.
</p>


<h3>Note</h3>

<p>The first returned array element is the starting value, <em>i.e.</em>,
<code class="reqn">\Phi_0</code>. 
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Psi">Psi</a></code>, <code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>,
<code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="#topic+SVEC">SVEC</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
Phi(var.2c, nstep=4)
</code></pre>

<hr>
<h2 id='plot'>Plot methods for objects in vars</h2><span id='topic+plot.varcheck'></span><span id='topic+plot.varest'></span><span id='topic+plot.varfevd'></span><span id='topic+plot.varirf'></span><span id='topic+plot.varprd'></span><span id='topic+plot.varstabil'></span><span id='topic+plot.vec2var'></span>

<h3>Description</h3>

<p>Plot method for objects with class attribute <code>varest</code>,
<code>vec2var</code>, <code>varcheck</code>, <code>varfevd</code>, <code>varirf</code>,
<code>varprd</code>, <code>varstabil</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varcheck'
plot(x, names = NULL, main.resid = NULL, main.hist =
NULL, main.acf = NULL, main.pacf = NULL, main.acf2 = NULL, main.pacf2 =
NULL, ylim.resid = NULL, ylim.hist = NULL, ylab.resid = NULL, xlab.resid
= NULL, xlab.acf = NULL, lty.resid = NULL, lwd.resid = NULL, col.resid =
NULL, col.edf = NULL, lag.acf = NULL, lag.pacf = NULL, lag.acf2 = NULL,
lag.pacf2 = NULL, mar = par("mar"), oma = par("oma"), ...)
## S3 method for class 'varest'
plot(x, names = NULL, main.fit = NULL, main.acf = NULL,
main.pacf = NULL, ylim.fit = NULL, ylim.resid = NULL, lty.fit = NULL,
lty.resid = NULL, lwd.fit = NULL, lwd.resid = NULL, lag.acf = NULL,
lag.pacf = NULL, col.fit = NULL, col.resid = NULL, ylab.fit = NULL,
ylab.resid = NULL, ylab.acf = NULL, ylab.pacf = NULL, xlab.fit = NULL,
xlab.resid = NULL, nc, mar = par("mar"), oma = par("oma"), adj.mtext =
NA, padj.mtext = NA, col.mtext = NA, ...)
## S3 method for class 'vec2var'
plot(x, ...)
## S3 method for class 'varfevd'
plot(x, plot.type = c("multiple", "single"),
names = NULL, main = NULL, col = NULL, ylim = NULL, ylab = NULL,
xlab = NULL, legend = NULL, names.arg = NULL, nc,
mar = par("mar"), oma = par("oma"), addbars = 1, ...)
## S3 method for class 'varirf'
plot(x, plot.type = c("multiple", "single"), names =
NULL, main = NULL, sub = NULL, lty = NULL, lwd = NULL, col = NULL, ylim
= NULL, ylab = NULL, xlab = NULL, nc, mar.multi = c(0, 4, 0, 4),
oma.multi = c(6, 4, 6, 4), adj.mtext = NA, padj.mtext = NA, col.mtext =
NA, ...)  
## S3 method for class 'varprd'
plot(x, plot.type = c("multiple", "single"),
names = NULL, main = NULL, col = NULL, lty = NULL, lwd = NULL,
ylim = NULL, ylab = NULL, xlab = NULL, nc, mar = par("mar"),
oma = par("oma"), ...)
## S3 method for class 'varstabil'
plot(x, plot.type = c("multiple", "single"), names =
NULL, main = NULL, nc, mar = par("mar"), oma = par("oma"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_addbars">addbars</code></td>
<td>
<p>Integer, number of empty bars in barplot to reserve
space for legend. If set to zero, no legend will be returned.</p>
</td></tr>
<tr><td><code id="plot_+3A_adj.mtext">adj.mtext</code></td>
<td>
<p>Adjustment for <code>mtext()</code>, only applicable if <code>plot.type = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>Character vector, colors to use in plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_col.edf">col.edf</code></td>
<td>
<p>Character, color of residuals' EDF.</p>
</td></tr>
<tr><td><code id="plot_+3A_col.fit">col.fit</code></td>
<td>
<p>Character vector, colors for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_col.mtext">col.mtext</code></td>
<td>
<p>Character, color for <code>mtext()</code>, only applicable
if <code>plot.type = "multiple"</code>.</p>
</td></tr> 
<tr><td><code id="plot_+3A_col.resid">col.resid</code></td>
<td>
<p>Character vector, colors for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_lag.acf">lag.acf</code></td>
<td>
<p>Integer, lag.max for ACF of residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_lag.acf2">lag.acf2</code></td>
<td>
<p>Integer, lag.max for ACF of squared residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_lag.pacf">lag.pacf</code></td>
<td>
<p>Integer, lag.max for PACF of residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_lag.pacf2">lag.pacf2</code></td>
<td>
<p>Integer, lag.max for PACF of squared residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>Character vector of names in legend.</p>
</td></tr>
<tr><td><code id="plot_+3A_lty">lty</code></td>
<td>
<p>Integer/Character, the line types.</p>
</td></tr>
<tr><td><code id="plot_+3A_lty.fit">lty.fit</code></td>
<td>
<p>Vector, lty for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_lty.resid">lty.resid</code></td>
<td>
<p>Vector, lty for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd">lwd</code></td>
<td>
<p>The width of the lines.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd.fit">lwd.fit</code></td>
<td>
<p>Vector, lwd for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_lwd.resid">lwd.resid</code></td>
<td>
<p>Vector, lwd for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>Character vector, the titles of the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.acf">main.acf</code></td>
<td>
<p>Character vector, main for residuals' ACF.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.acf2">main.acf2</code></td>
<td>
<p>Character vector, main for squared residuals' ACF.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.fit">main.fit</code></td>
<td>
<p>Character vector, main for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.hist">main.hist</code></td>
<td>
<p>Character vector, main for histogram of residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.pacf">main.pacf</code></td>
<td>
<p>Character vector, main for residuals' PACF.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.pacf2">main.pacf2</code></td>
<td>
<p>Character vector, main for squared residuals' PACF.</p>
</td></tr>
<tr><td><code id="plot_+3A_main.resid">main.resid</code></td>
<td>
<p>Character vector, main for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_mar">mar</code></td>
<td>
<p>Setting of margins.</p>
</td></tr>
<tr><td><code id="plot_+3A_mar.multi">mar.multi</code></td>
<td>
<p>Setting of margins, if <code>plot.type = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_names">names</code></td>
<td>
<p>Character vector, the variables names to be plotted. If
left <code>NULL</code>, all variables are plotted.</p>
</td></tr> 
<tr><td><code id="plot_+3A_names.arg">names.arg</code></td>
<td>
<p>Character vector, names for x-axis of barplot.</p>
</td></tr>
<tr><td><code id="plot_+3A_nc">nc</code></td>
<td>
<p>Integer, number of columns for multiple plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_oma">oma</code></td>
<td>
<p>Setting of outer margins.</p>
</td></tr>
<tr><td><code id="plot_+3A_oma.multi">oma.multi</code></td>
<td>
<p>Setting of margins, if <code>plot.type = "multiple"</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_padj.mtext">padj.mtext</code></td>
<td>
<p>Adjustment for <code>mtext()</code>, only applicable if
<code>plot.type = "multiple"</code>.</p>
</td></tr> 
<tr><td><code id="plot_+3A_plot.type">plot.type</code></td>
<td>
<p>Character, if <code>multiple</code> all plots are drawn in
a single device, otherwise the plots are shown consecutively.</p>
</td></tr>
<tr><td><code id="plot_+3A_sub">sub</code></td>
<td>
<p>Character, sub title in plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>An object of one of the above classes.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>Character vector signifying the labels for the x-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab.acf">xlab.acf</code></td>
<td>
<p>Character, xlab for ACF and PACF of residuals and
their squares in plot.varcheck.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab.fit">xlab.fit</code></td>
<td>
<p>Character vector, xlab for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab.resid">xlab.resid</code></td>
<td>
<p>Character vector, xlab for residual plot.</p>
</td></tr>  
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>Character vector signifying the labels for the y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab.acf">ylab.acf</code></td>
<td>
<p>Character, ylab for ACF.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab.fit">ylab.fit</code></td>
<td>
<p>Character vector, ylab for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab.pacf">ylab.pacf</code></td>
<td>
<p>Character, ylab for PACF</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab.resid">ylab.resid</code></td>
<td>
<p>Character vector, ylab for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>Vector, the limits of the y-axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim.fit">ylim.fit</code></td>
<td>
<p>Vector, ylim for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim.hist">ylim.hist</code></td>
<td>
<p>Vector, ylim for histogram of residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim.resid">ylim.resid</code></td>
<td>
<p>Vector, ylim for residual plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Passed to internal plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot-method for objects with class attribute <code>vec2var</code> is the
same as for objects with class attribute <code>varest</code>. Hence, the
same arguments can be utilised.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>
<p>Zeileis, A., F. Leisch, K. Hornik and C. Kleiber (2002), strucchange:
An R Package for Testing for Structural Change in Linear Regression
Models, <em>Journal of Statistical Software</em>, <b>7(2)</b>: 1-38,
<a href="https://www.jstatsoft.org/v07/i02/">https://www.jstatsoft.org/v07/i02/</a>  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="#topic+fevd">fevd</a></code>,
<code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+predict">predict</a></code>, <code><a href="#topic+fanchart">fanchart</a></code>,
<code><a href="#topic+stability">stability</a></code>, <code><a href="#topic+arch.test">arch.test</a></code>, <code><a href="#topic+normality.test">normality.test</a></code>,
<code><a href="#topic+serial.test">serial.test</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
plot(var.2c)
## Diagnostic Testing
## ARCH test
archtest &lt;- arch.test(var.2c)
plot(archtest)
## Normality test
normalitytest &lt;- normality.test(var.2c)
plot(normalitytest)
## serial correlation test
serialtest &lt;- serial.test(var.2c)
plot(serialtest)
## FEVD
var.2c.fevd &lt;- fevd(var.2c, n.ahead = 5)
plot(var.2c.fevd)
## IRF
var.2c.irf &lt;- irf(var.2c, impulse = "e",
response = c("prod", "rw", "U"), boot = FALSE)
plot(var.2c.irf)
## Prediction
var.2c.prd &lt;- predict(var.2c, n.ahead = 8, ci = 0.95)
plot(var.2c.prd)
## Stability
var.2c.stabil &lt;- stability(var.2c, type = "Rec-CUSUM")
plot(var.2c.stabil)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict'>Predict method for objects of class varest and vec2var</h2><span id='topic+predict'></span><span id='topic+predict.varest'></span><span id='topic+predict.vec2var'></span><span id='topic+print.varprd'></span>

<h3>Description</h3>

<p>Forecating a VAR object of class &lsquo;<code>varest</code>&rsquo; or of class
&lsquo;<code>vec2var</code>&rsquo; with confidence bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
predict(object, ..., n.ahead = 10, ci = 0.95, dumvar = NULL)
## S3 method for class 'vec2var'
predict(object, ..., n.ahead = 10, ci = 0.95, dumvar = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;;
generated by <code>vec2var()</code>.</p>
</td></tr> 
<tr><td><code id="predict_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of forecast steps.</p>
</td></tr>
<tr><td><code id="predict_+3A_ci">ci</code></td>
<td>
<p>The forecast confidence interval</p>
</td></tr>
<tr><td><code id="predict_+3A_dumvar">dumvar</code></td>
<td>
<p>Matrix for objects of class &lsquo;<code>vec2var</code>&rsquo; or
&lsquo;<code>varest</code>&rsquo;, if the <code>dumvar</code> argument in
<code>ca.jo()</code> has been used or if the <code>exogen</code> argument in
<code>VAR()</code> has been used, respectively. The matrix should have
the same column dimension as in the call to <code>ca.jo()</code> or to
<code>VAR()</code> and row dimension equal to <code>n.ahead</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>n.ahead</code> forecasts are computed recursively for the
estimated VAR, beginning with <code class="reqn">h = 1, 2, \ldots, n.ahead</code>:  
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_{T+1 | T} = A_1 \bold{y}_T  + \ldots + A_p \bold{y}_{T+1-p} +
    C D_{T+1}
  </code>
</p>

<p>The variance-covariance matrix of the forecast errors is a function of
<code class="reqn">\Sigma_u</code> and <code class="reqn">\Phi_s</code>. 
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varprd</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>fcst</code></td>
<td>
<p>A list of matrices per endogenous variable containing the
forecasted values with lower and upper bounds as well as the
confidence interval.</p>
</td></tr> 
<tr><td><code>endog</code></td>
<td>
<p>Matrix of the in-sample endogenous variables.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The estimated VAR <code>object</code>.</p>
</td></tr>
<tr><td><code>exo.fcst</code></td>
<td>
<p>If applicable provided values of exogenous variables,
otherwise <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="#topic+fanchart">fanchart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
predict(var.2c, n.ahead = 8, ci = 0.95) 
</code></pre>

<hr>
<h2 id='Psi'>Coefficient matrices of the orthogonalised MA represention</h2><span id='topic+Psi'></span><span id='topic+Psi.varest'></span><span id='topic+Psi.vec2var'></span>

<h3>Description</h3>

<p>Returns the estimated orthogonalised coefficient matrices of the
moving average representation of a stable VAR(p) as an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
Psi(x, nstep=10, ...)
## S3 method for class 'vec2var'
Psi(x, nstep=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psi_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;,
generated by <code>vec2var()</code>.</p>
</td></tr>  
<tr><td><code id="Psi_+3A_nstep">nstep</code></td>
<td>
<p>An integer specifying the number of othogonalised moving error
coefficient matrices to be calculated.</p>
</td></tr>
<tr><td><code id="Psi_+3A_...">...</code></td>
<td>
<p>Dots currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case that the components of the error process are instantaneously
correlated with each other, that is: the off-diagonal elements of the
variance-covariance matrix <code class="reqn">\Sigma_u</code> are not null, the impulses
measured by the <code class="reqn">\Phi_s</code> matrices, would also reflect disturbances
from the other variables. Therefore, in practice a Choleski
decomposition has been propagated by considering <code class="reqn">\Sigma_u = PP'</code> and the
orthogonalised shocks <code class="reqn">\bold{\epsilon}_t = P^{-1}\bold{u}_t</code>. The
moving average representation is then in the form of:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_t = \Psi_0 \bold{\epsilon}_t + \Psi_1
    \bold{\epsilon}_{t-1} + \Psi \bold{\epsilon}_{t-2} + \ldots ,
  </code>
</p>

<p>whith <code class="reqn">\Psi_0 = P</code> and the matrices <code class="reqn">\Psi_s</code> are computed
as <code class="reqn">\Psi_s = \Phi_s P</code> for <code class="reqn">s = 1, 2, 3, \ldots</code>.
</p>


<h3>Value</h3>

<p>An array with dimension <code class="reqn">(K \times K \times nstep + 1)</code> holding the
estimated orthogonalised coefficients of the moving average representation.
</p>


<h3>Note</h3>

<p>The first returned array element is the starting value, <em>i.e.</em>,
<code class="reqn">\Psi_0</code>. Due to the utilisation of the Choleski decomposition,
the impulse are now dependent on the ordering of the vector elements
in <code class="reqn">\bold{y}_t</code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Phi">Phi</a></code>, <code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>,
<code><a href="#topic+vec2var">vec2var</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
Psi(var.2c, nstep=4)
</code></pre>

<hr>
<h2 id='residuals'>Residuals method for objects of class varest and vec2var</h2><span id='topic+residuals'></span><span id='topic+resid'></span><span id='topic+residuals.varest'></span><span id='topic+residuals.vec2var'></span>

<h3>Description</h3>

<p>Returns the residuals of a VAR(p)-model or for a VECM in levels. For
the former class the residuals-method is applied to the list
element <code>varresult</code>, which is itself a list of <code>lm</code>-objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
residuals(object, ...)
## S3 method for class 'vec2var'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;;
generated by <code>vec2var()</code></p>
</td></tr> 
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
resid(var.2c)

## End(Not run)
</code></pre>

<hr>
<h2 id='restrict'>Restricted VAR</h2><span id='topic+restrict'></span>

<h3>Description</h3>

<p>Estimation of a VAR, by imposing zero restrictions manually or by
significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict(x, method = c("ser", "manual"), thresh = 2.0, resmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo; generated by
<code>VAR()</code>.</p>
</td></tr>  
<tr><td><code id="restrict_+3A_method">method</code></td>
<td>
<p>A character, choosing the method</p>
</td></tr>
<tr><td><code id="restrict_+3A_thresh">thresh</code></td>
<td>
<p>If method <code>ser</code>: the threshhold value for the
t-statistics.</p>
</td></tr>
<tr><td><code id="restrict_+3A_resmat">resmat</code></td>
<td>
<p>If method <code>manual</code>: The restriction matrix.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Given an estimated VAR object of class &lsquo;<code>varest</code>&rsquo;, a restricted VAR
can be obtained by either choosing method <code>ser</code> or
<code>manual</code>. In the former case, each equation is re-estimated
separately as long as there are t-values that are in absolut value below the
threshhold value set by the function's argument <code>thresh</code>. In the
latter case, a restriction matrix has to be provided that consists of
0/1 values, thereby selecting the coefficients to be retained in the
model.</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varest</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>varresult</code></td>
<td>
<p>list of &lsquo;<code>lm</code>&rsquo; objects.</p>
</td></tr>
<tr><td><code>datamat</code></td>
<td>
<p>The data matrix of the endogenous and explanatory variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The data matrix of the endogenous variables</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character, specifying the deterministic regressors.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>An integer specifying the lag order.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>An integer specifying the dimension of the VAR.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>An integer specifying the number of used observations.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>An integer specifying the total number of observations.</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>The matrix object containing the zero restrictions
provided as argument <code>resmat</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>VAR()</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently, the restricted VAR is estimated by OLS and not by an
efficient EGLS-method.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
## Restrictions determined by thresh
restrict(var.2c, method = "ser")
## Restrictions set manually
restrict &lt;- matrix(c(1, 1, 1, 1, 1, 1, 0, 0, 0, 
                     1, 0, 1, 0, 0, 1, 0, 1, 1,
                     0, 0, 1, 1, 0, 1, 0, 0, 1,
                     1, 1, 1, 0, 1, 1, 0, 1, 0),
                   nrow=4, ncol=9, byrow=TRUE)
restrict(var.2c, method = "man", resmat = restrict)
</code></pre>

<hr>
<h2 id='roots'>Eigenvalues of the companion coefficient matrix of a VAR(p)-process</h2><span id='topic+roots'></span>

<h3>Description</h3>

<p>Returns a vector of the eigenvalues of the companion coefficient matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots(x, modulus = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roots_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>varest</code>&rsquo;, generated by
<code>VAR()</code>.</p>
</td></tr>
<tr><td><code id="roots_+3A_modulus">modulus</code></td>
<td>
<p>Logical, set to <code>TRUE</code> for returning the modulus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any VAR(p)-process can be written in a first-order vector
autoregressive form: the companion form. A VAR(p)-process is stable,
if its reverse characteristic polynomial:
</p>
<p style="text-align: center;"><code class="reqn">
    \det(I_K - A_1 z - \cdots - A_p z^p) \neq 0 \; \hbox{for} \; |z| \le 1
    \; ,
    </code>
</p>

<p>has no roots in or on the complex circle. This is equivalent to the
condition that all eigenvalues of the companion matrix <code class="reqn">A</code> have
modulus less than 1. The function <code>roots()</code>, does compute the
eigen values of the companion matrix <code class="reqn">A</code> and returns by default
their moduli. 
</p>


<h3>Value</h3>

<p>A vector object with the eigen values of the companion matrix, or
their moduli (default).
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
roots(var.2c)
</code></pre>

<hr>
<h2 id='serial.test'>Test for serially correlated errors</h2><span id='topic+serial.test'></span><span id='topic+serial-deprecated'></span>

<h3>Description</h3>

<p>This function computes the multivariate Portmanteau- and Breusch-Godfrey
test for serially correlated errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial.test(x, lags.pt = 16, lags.bg = 5, type = c("PT.asymptotic",
"PT.adjusted", "BG", "ES") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serial.test_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>, or an object of class &lsquo;<code>vec2var</code>&rsquo;;
generated by <code>vec2var()</code>.</p>
</td></tr>  
<tr><td><code id="serial.test_+3A_lags.pt">lags.pt</code></td>
<td>
<p>An integer specifying the lags to be used for the
Portmanteau statistic.</p>
</td></tr>
<tr><td><code id="serial.test_+3A_lags.bg">lags.bg</code></td>
<td>
<p>An integer specifying the lags to be used for the
Breusch-Godfrey statistic.</p>
</td></tr>
<tr><td><code id="serial.test_+3A_type">type</code></td>
<td>
<p>Character, the type of test. The default is an asymptotic
Portmanteau test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Portmanteau statistic for testing the absence of up to the order <code class="reqn">h</code>
serially correlated disturbances in a stable VAR(p) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    Q_h = T \sum_{j = 1}^h
    tr(\hat{C}_j'\hat{C}_0^{-1}\hat{C}_j\hat{C}_0^{-1}) \quad ,
  </code>
</p>

<p>where <code class="reqn">\hat{C}_i = \frac{1}{T}\sum_{t = i + 1}^T \bold{\hat{u}}_t
    \bold{\hat{u}}_{t - i}'</code>. The test statistic is approximately
distributed as <code class="reqn">\chi^2(K^2(h - p))</code>. This test statistic is
choosen by setting <code>type = "PT.asymptotic"</code>. For smaller sample sizes
and/or values of <code class="reqn">h</code> that are not sufficiently large, a corrected
test statistic is computed as:
</p>
<p style="text-align: center;"><code class="reqn">
    Q_h^* = T^2 \sum_{j = 1}^h
    \frac{1}{T - j}tr(\hat{C}_j'\hat{C}_0^{-1}\hat{C}_j\hat{C}_0^{-1}) \quad ,
  </code>
</p>

<p>This test statistic can be accessed, if <code>type = "PT.adjusted"</code> is
set.<br />  
</p>
<p>The Breusch-Godfrey LM-statistic is based upon the following auxiliary
regressions:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{\hat{u}}_t = A_1 \bold{y}_{t-1} + \ldots + A_p\bold{y}_{t-p} +
    CD_t + B_1\bold{\hat{u}}_{t-1} + \ldots + B_h\bold{\hat{u}}_{t-h} +
    \bold{\varepsilon}_t   
  </code>
</p>

<p>The null hypothesis is: <code class="reqn">H_0: B_1 = \ldots = B_h = 0</code> and
correspondingly the alternative hypothesis is of the form <code class="reqn">H_1:
    \exists \; B_i \ne 0</code> for <code class="reqn">i = 1, 2, \ldots, h</code>. The test statistic
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    LM_h = T(K - tr(\tilde{\Sigma}_R^{-1}\tilde{\Sigma}_e))  \quad ,
  </code>
</p>

<p>where <code class="reqn">\tilde{\Sigma}_R</code> and <code class="reqn">\tilde{\Sigma}_e</code> assign the
residual covariance matrix of the restricted and unrestricted
model, respectively. The test statistic <code class="reqn">LM_h</code> is distributed as
<code class="reqn">\chi^2(hK^2)</code>. This test statistic is calculated if <code>type =
    "BG"</code> is used.<br />
</p>
<p>Edgerton and Shukur (1999) proposed a small sample correction, which
is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    LMF_h = \frac{1 - (1 - R_r^2)^{1/r}}{(1 - R_r^2)^{1/r}} \frac{Nr -
      q}{K m} \quad ,
  </code>
</p>

<p>with <code class="reqn">R_r^2 = 1 - |\tilde{\Sigma}_e | / |\tilde{\Sigma}_R|</code>,
<code class="reqn">r = ((K^2m^2 - 4)/(K^2 + m^2 - 5))^{1/2}</code>, <code class="reqn">q = 1/2 K m - 1</code>
and <code class="reqn">N = T - K - m - 1/2(K - m + 1)</code>, whereby <code class="reqn">n</code> is the
number of regressors in the original system and <code class="reqn">m = Kh</code>. The
modified test statistic is distributed as <code class="reqn">F(hK^2, int(Nr -
    q))</code>. This modified statistic will be returned, if <code>type =
    "ES"</code> is provided in the call to <code>serial()</code>.    
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varcheck</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>resid</code></td>
<td>
<p>A matrix with the residuals of the VAR.</p>
</td></tr>
<tr><td><code>pt.mul</code></td>
<td>
<p>A list with objects of class attribute &lsquo;<code>htest</code>&rsquo;
containing the multivariate Portmanteau-statistic (asymptotic and
adjusted.</p>
</td></tr>
<tr><td><code>LMh</code></td>
<td>
<p>An object with class attribute &lsquo;<code>htest</code>&rsquo;
containing the Breusch-Godfrey LM-statistic.</p>
</td></tr>
<tr><td><code>LMFh</code></td>
<td>
<p>An object with class attribute &lsquo;<code>htest</code>&rsquo;
containing the Edgerton-Shukur F-statistic.</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>This function was named <code>serial</code> in earlier versions of package
<span class="pkg">vars</span>; it is now deprecated. See <code><a href="#topic+vars-deprecated">vars-deprecated</a></code> too.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Breusch, T . S. (1978), Testing for autocorrelation in dynamic linear
models, <em>Australian Economic Papers</em>, <b>17</b>: 334-355.
</p>
<p>Edgerton, D. and Shukur, G. (1999), Testing autocorrelation in a
system perspective, <em>Econometric Reviews</em>, <b>18</b>: 43-386.
</p>
<p>Godfrey, L. G. (1978), Testing for higher order serial correlation in
regression equations when the regressors include lagged dependent
variables, <em>Econometrica</em>, <b>46</b>: 1303-1313.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+vec2var">vec2var</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
serial.test(var.2c, lags.pt = 16, type = "PT.adjusted")
</code></pre>

<hr>
<h2 id='stability'>Structural stability of a VAR(p)</h2><span id='topic+stability'></span><span id='topic+stability.default'></span><span id='topic+stability.varest'></span><span id='topic+print.varstabil'></span>

<h3>Description</h3>

<p>Computes an empirical fluctuation process according to a specified
method from the generalised fluctuation test framework. The test
utilises the function <code>efp()</code> and its methods from
package &lsquo;<code>strucchange</code>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
stability(x, type = c("OLS-CUSUM", "Rec-CUSUM",
"Rec-MOSUM", "OLS-MOSUM", "RE", "ME", "Score-CUSUM", "Score-MOSUM",
"fluctuation"), h = 0.15, dynamic = FALSE, rescale = TRUE, ...)
## S3 method for class 'varest'
stability(x, type = c("OLS-CUSUM", "Rec-CUSUM",
"Rec-MOSUM", "OLS-MOSUM", "RE", "ME", "Score-CUSUM", "Score-MOSUM",
"fluctuation"), h = 0.15, dynamic = FALSE, rescale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stability_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>.</p>
</td></tr> 
<tr><td><code id="stability_+3A_type">type</code></td>
<td>
<p>Specifies which type of fluctuation process will be
computed, the default is &lsquo;<code>OLS-CUSUM</code>&rsquo;. For details see:
<code><a href="strucchange.html#topic+efp">efp</a></code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_h">h</code></td>
<td>
<p>A numeric from interval (0,1) sepcifying the
bandwidth. Determins the size of the data window relative to sample
size (for &lsquo;<code>MOSUM</code>&rsquo; and &lsquo;<code>ME</code>&rsquo; processes only).</p>
</td></tr>
<tr><td><code id="stability_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical. If &lsquo;<code>TRUE</code>&rsquo; the lagged
observations are included as a regressor.</p>
</td></tr>  
<tr><td><code id="stability_+3A_rescale">rescale</code></td>
<td>
<p>Logical. If &lsquo;<code>TRUE</code>&rsquo; the estimates will be
standardized by the regressor matrix of the corresponding subsample;
if &lsquo;<code>FALSE</code>&rsquo; the whole regressor matrix will be
used. (only if &lsquo;<code>type</code>&rsquo; is either &lsquo;<code>RE</code>&rsquo; or
&lsquo;<code>E</code>&rsquo;).</p>
</td></tr>
<tr><td><code id="stability_+3A_...">...</code></td>
<td>
<p>Ellipsis, is passed to <code>strucchange::sctest()</code>, as default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details, please refer to documentation <code><a href="strucchange.html#topic+efp">efp</a></code>.
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varstabil</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>stability</code></td>
<td>
<p>A list with objects of class &lsquo;<code>efp</code>&rsquo;;
length is equal to the dimension of the VAR.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Character vector containing the names of the endogenous
variables.</p>
</td></tr> 
<tr><td><code>K</code></td>
<td>
<p>An integer of the VAR dimension.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Zeileis, A., F. Leisch, K. Hornik and C. Kleiber (2002), strucchange:
An R Package for Testing for Structural Change in Linear Regression
Models, <em>Journal of Statistical Software</em>, <b>7(2)</b>: 1-38,
<a href="https://www.jstatsoft.org/v07/i02/">https://www.jstatsoft.org/v07/i02/</a>
</p>
<p>and see the references provided in the reference section of
<code><a href="strucchange.html#topic+efp">efp</a></code>, too.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="strucchange.html#topic+efp">efp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
var.2c.stabil &lt;- stability(var.2c, type = "OLS-CUSUM")
var.2c.stabil
## Not run: 
plot(var.2c.stabil)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary'>Summary method for objects of class varest, svarest and svecest</h2><span id='topic+summary'></span><span id='topic+summary.varest'></span><span id='topic+summary.svarest'></span><span id='topic+summary.svecest'></span><span id='topic+print.varsum'></span><span id='topic+print.svarsum'></span><span id='topic+print.svecsum'></span>

<h3>Description</h3>

<p>'summary' methods for class '&quot;varest&quot;', '&quot;svarest&quot;' and '&quot;svecest&quot;'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
summary(object, equations = NULL, ...)
## S3 method for class 'varsum'
print(x, digits = max(3, getOption("digits") - 3),
signif.stars = getOption("show.signif.stars"), ...)
## S3 method for class 'svarest'
summary(object,  ...)
## S3 method for class 'svarsum'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'svecest'
summary(object,  ...)
## S3 method for class 'svecsum'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;, usually, a
result of a call to <code>VAR</code>, or object of class &lsquo;<code>svarest</code>&rsquo;, usually, a
result of a call to <code>SVAR</code>, or object of class &lsquo;<code>svecest</code>&rsquo;, usually, a
result of a call to <code>SVEC</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_equations">equations</code></td>
<td>
<p>Character vector of endogenous variable names for
which summary results should be returned. The default is <code>NULL</code>
and results are returned for all equations in the VAR.</p>
</td></tr>
<tr><td><code id="summary_+3A_x">x</code></td>
<td>
<p>Object with class attribute &lsquo;varsum&rsquo;, &lsquo;svarsum&rsquo;.</p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If 'TRUE', &lsquo;significance stars&rsquo;
are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a list with class attribute <code>varsum</code> which contains the
following elements:
</p>
<table>
<tr><td><code>names</code></td>
<td>
<p>Character vector with the names of the endogenous
correlation matrix of VAR residuals.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Numeric, value of log Likelihood.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Integer, sample size.</p>
</td></tr>
<tr><td><code>roots</code></td>
<td>
<p>Vector, roots of the characteristic polynomial.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character vector, deterministic regressors included in VAR:</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call, the initial call to <code>VAR</code>.</p>
</td></tr>
</table>
<p>Or a list with class attribute <code>svarsum</code> which contains the
following elements:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Character, the type of SVAR-model.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Matrix, estimated coefficients for A matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Matrix, estimated coefficients for B matrix.</p>
</td></tr>
<tr><td><code>Ase</code></td>
<td>
<p>Matrix, standard errors for A matrix.</p>
</td></tr>
<tr><td><code>Bse</code></td>
<td>
<p>Matrix, standard errors for B matrix.</p>
</td></tr>
<tr><td><code>LRIM</code></td>
<td>
<p>Matrix, long-run impact coefficients for <code>BQ</code>.</p>
</td></tr>
<tr><td><code>Sigma.U</code></td>
<td>
<p>Matrix, variance/covariance of reduced form residuals.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Numeric, value of log-Likelihood.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>htest, LR result of over-identification test.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Integer, number of observations used.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>List, result of <code>optim()</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Integer, the count of iterations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call, the call to <code>SVAR()</code>.</p>
</td></tr>
</table>
<p>Or a list with class attribute <code>svecsum</code> which contains the
following elements:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Character, the type of SVEC-model.</p>
</td></tr>
<tr><td><code>SR</code></td>
<td>
<p>Matrix, contemporaneous impact matrix.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>Matrix, long-run impact matrix.</p>
</td></tr>
<tr><td><code>SRse</code></td>
<td>
<p>Matrix, standard errors for SR matrix.</p>
</td></tr>
<tr><td><code>LRse</code></td>
<td>
<p>Matrix, standard errors for LR matrix.</p>
</td></tr>
<tr><td><code>Sigma.U</code></td>
<td>
<p>Matrix, variance/covariance of reduced form residuals.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>Numeric, value of log-Likelihood.</p>
</td></tr>
<tr><td><code>LRover</code></td>
<td>
<p>htest, LR result of over-identification test.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>Integer, number of observations used.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Integer, co-integration rank of VECM.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Integer, the count of iterations.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call, the call to <code>SVEC()</code>.</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+SVEC">SVEC</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
## summary-method for varest
var.2c &lt;- VAR(Canada, p = 2 , type = "const")
summary(var.2c)
## summary-method for svarest
amat &lt;- diag(4)
diag(amat) &lt;- NA
amat[2, 1] &lt;- NA
amat[4, 1] &lt;- NA
## Estimation method scoring
svar.a &lt;- SVAR(x = var.2c, estmethod = "scoring", Amat = amat, Bmat = NULL,
max.iter = 100, maxls = 1000, conv.crit = 1.0e-8)
summary(svar.a)
## summary-method for svecest
vecm &lt;- ca.jo(Canada[, c("prod", "e", "U", "rw")], type = "trace",
              ecdet = "trend", K = 3, spec = "transitory")
SR &lt;- matrix(NA, nrow = 4, ncol = 4)
SR[4, 2] &lt;- 0
LR &lt;- matrix(NA, nrow = 4, ncol = 4)
LR[1, 2:4] &lt;- 0
LR[2:4, 4] &lt;- 0
svec.b &lt;- SVEC(vecm, LR = LR, SR = SR, r = 1, lrtest = FALSE, boot =
FALSE)
summary(svec.b) 
</code></pre>

<hr>
<h2 id='SVAR'>Estimation of a SVAR</h2><span id='topic+SVAR'></span><span id='topic+print.svarest'></span>

<h3>Description</h3>

<p>Estimates an SVAR (either &lsquo;A-model&rsquo;, &lsquo;B-model&rsquo; or
&lsquo;AB-model&rsquo;) by using a scoring algorithm or by directly
minimising the negative log-likelihood with <code>optim()</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVAR(x, estmethod = c("scoring", "direct"), Amat = NULL, Bmat = NULL,
start = NULL, max.iter = 100, conv.crit = 0.1e-6, maxls = 1.0,
lrtest = TRUE, ...)
## S3 method for class 'svarest'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVAR_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>varest</code>&rsquo;; generated by
<code>VAR()</code>.</p>
</td></tr>
<tr><td><code id="SVAR_+3A_estmethod">estmethod</code></td>
<td>
<p>Character, either scoring for estimating the
SVAR-model with the scoring algorithm (default), or directly
minimizing the negative log-likelihood.</p>
</td></tr> 
<tr><td><code id="SVAR_+3A_start">start</code></td>
<td>
<p>Vector with starting values for the parameters to be
optimised.</p>
</td></tr>  
<tr><td><code id="SVAR_+3A_lrtest">lrtest</code></td>
<td>
<p>Logical, over-identification LR test, the result is set
to <code>NULL</code> for just-identified system.</p>
</td></tr>
<tr><td><code id="SVAR_+3A_max.iter">max.iter</code></td>
<td>
<p>Integer, maximum number of iteration (used if
<code>estmethod = "scoring"</code>).</p>
</td></tr>
<tr><td><code id="SVAR_+3A_conv.crit">conv.crit</code></td>
<td>
<p>Real, convergence value of algorithm (used if
<code>estmethod = "scoring"</code>).</p>
</td></tr>
<tr><td><code id="SVAR_+3A_maxls">maxls</code></td>
<td>
<p>Real, maximum movement of the parameters between two
iterations of the scoring algorithm (used if
<code>estmethod = "scoring"</code>).</p>
</td></tr>
<tr><td><code id="SVAR_+3A_amat">Amat</code></td>
<td>
<p>Matrix with dimension <code class="reqn">(K \times K)</code> for A- or
AB-model.</p>
</td></tr>
<tr><td><code id="SVAR_+3A_bmat">Bmat</code></td>
<td>
<p>Matrix with dimension <code class="reqn">(K \times K)</code> for B- or
AB-model.</p>
</td></tr>
<tr><td><code id="SVAR_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="SVAR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Consider the following structural form of a k-dimensional vector
autoregressive model: 
</p>
<p style="text-align: center;"><code class="reqn">
    A \bold{y}_t = A_1^*\bold{y}_{t-1} + \ldots + A_p^*\bold{y}_{t-p} +
    C^*D_t + B\bold{\varepsilon}_t
  </code>
</p>

<p>The coefficient matrices <code class="reqn">(A_1^* | \ldots | A_p^* | C^*)</code> might
now differ from the ones of a VAR (see <code>?VAR</code>). One can now
impose restrictions on &lsquo;<code>A</code>&rsquo; and/or &lsquo;<code>B</code>&rsquo;,
resulting in an &lsquo;A-model&rsquo; or &lsquo;B-model&rsquo; or if the
restrictions are placed on both matrices, an &lsquo;AB-model&rsquo;. In case
of a SVAR &lsquo;A-model&rsquo;, <code class="reqn">B = I_K</code> and conversely for a
SVAR &lsquo;B-model&rsquo;. Please note that for either an &lsquo;A-model&rsquo; or
&lsquo;B-model&rsquo;, <code class="reqn">K(K-1)/2</code> restrictions have to be imposed, such
that the models' coefficients are identified. For an &lsquo;AB-model&rsquo;
the number of restrictions amounts to: <code class="reqn">K^2 + K(K-1)/2</code>.<br />
For an &lsquo;A-model&rsquo; a <code class="reqn">(K \times K)</code> matrix has to be provided for
the functional argument &lsquo;<code>Amat</code>&rsquo; and the functional
argument &lsquo;<code>Bmat</code>&rsquo; must be set to &lsquo;<code>NULL</code>&rsquo; (the
default). Hereby, the to be estimated elements of &lsquo;<code>Amat</code>&rsquo;
have to be set as &lsquo;<code>NA</code>&rsquo;. Conversely, for a
&lsquo;B-model&rsquo; a matrix object with dimension <code class="reqn">(K \times K)</code>
with elements set to &lsquo;<code>NA</code>&rsquo; at the positions of the to be
estimated parameters has to be provided and the functional argument
&lsquo;<code>Amat</code>&rsquo; is &lsquo;<code>NULL</code>&rsquo; (the default). Finally,
for an &lsquo;AB-model&rsquo; both arguments, &lsquo;<code>Amat</code>&rsquo; and
&lsquo;<code>Bmat</code>&rsquo;, have to be set as matrix objects containing
desired restrictions and &lsquo;<code>NA</code>&rsquo; values. The parameters are
estimated by minimising the negative of the concentrated
log-likelihood function:  
</p>
<p style="text-align: center;"><code class="reqn">
    \ln L_c(A, B) = - \frac{KT}{2}\ln(2\pi) + \frac{T}{2}\ln|A|^2 -
    \frac{T}{2}\ln|B|^2 - \frac{T}{2}tr(A'B'^{-1}B^{-1}A\tilde{\Sigma}_u) 
  </code>
</p>

<p>Two alternatives are implemented for this: a scoring algorithm or
direct minimization with <code>optim()</code>. If the latter is chosen, the
standard errors are returned if <code>SVAR()</code> is called with
&lsquo;<code>hessian = TRUE</code>&rsquo;.<br /> 
</p>
<p>If &lsquo;<code>start</code>&rsquo; is not set, then <code>0.1</code> is used as
starting values for the unknown coefficients.<br />
</p>
<p>The reduced form residuals can be obtained from the above equation
<em>via</em> the relation: <code class="reqn">\bold{u}_t =
  A^{-1}B\bold{\varepsilon}_t</code>, with variance-covariance matrix
<code class="reqn">\Sigma_U = A^{-1}BB'A^{-1'}</code>.<br /> 
</p>
<p>Finally, in case of an overidentified SVAR, a likelihood ratio
statistic is computed according to: 
</p>
<p style="text-align: center;"><code class="reqn">
    LR = T(\ln\det(\tilde{\Sigma}_u^r) - \ln\det(\tilde{\Sigma}_u))
    \quad , 
  </code>
</p>

<p>with <code class="reqn">\tilde{\Sigma}_u^r</code> being the restricted variance-covariance
matrix and <code class="reqn">\tilde{\Sigma}_u</code> being the variance covariance matrix
of the reduced form residuals. The test statistic is distributed as
<code class="reqn">\chi^2(nr - 2K^2 - \frac{1}{2}K(K + 1))</code>, where <code class="reqn">nr</code> is equal
to the number of restrictions.  
</p>


<h3>Value</h3>

<p>A list of class &lsquo;<code>svarest</code>&rsquo; with the following elements is
returned:<br />
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>If A- or AB-model, the matrix of estimated coefficients.</p>
</td></tr>
<tr><td><code>Ase</code></td>
<td>
<p>The standard errors of &lsquo;<code>A</code>&rsquo;.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>If A- or AB-model, the matrix of estimated coefficients.</p>
</td></tr>
<tr><td><code>Bse</code></td>
<td>
<p>The standard errors of &lsquo;<code>B</code>&rsquo;.</p>
</td></tr>
<tr><td><code>LRIM</code></td>
<td>
<p>For Blanchard-Quah estimation <code>LRIM</code> is the estimated
long-run impact matrix; for all other SVAR models <code>LRIM</code> is
<code>NULL</code>.</p>
</td></tr>  
<tr><td><code>Sigma.U</code></td>
<td>
<p>The variance-covariance matrix of the reduced form
residuals times 100, <em>i.e.</em>, <code class="reqn">\Sigma_U = A^{-1}BB'A^{-1'}
      \times 100</code>.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>Object of class &lsquo;<code>htest</code>&rsquo;, holding the Likelihood
ratio overidentification test.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>List object returned by <code>optim()</code>.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>Vector of starting values.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>SVAR-type, character, either &lsquo;A-model&rsquo;,
&lsquo;B-model&rsquo; or &lsquo;AB-model&rsquo;.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The &lsquo;<code>varest</code>&rsquo; object &lsquo;<code>x</code>&rsquo;.</p>
</td></tr> 
<tr><td><code>iter</code></td>
<td>
<p>Integer, the count of iterations.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>SVAR()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Amisano, G. and C. Giannini (1997), <em>Topics in Structural VAR
Econometrics</em>, 2nd edition, Springer, Berlin.
</p>
<p>Breitung, J., R. Brüggemann and H. Lütkepohl (2004), Structural vector
autoregressive modeling and impulse responses, in H. Lütkepohl and
M. Krätzig (editors), <em>Applied Time Series Econometrics</em>,
Cambridge University Press, Cambridge.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+SVEC">SVEC</a></code>, <code><a href="#topic+logLik">logLik</a></code>,
<code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+fevd">fevd</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
var.2c &lt;- VAR(Canada, p = 2, type = "const")
amat &lt;- diag(4)
diag(amat) &lt;- NA
amat[2, 1] &lt;- NA
amat[4, 1] &lt;- NA
## Estimation method scoring
SVAR(x = var.2c, estmethod = "scoring", Amat = amat, Bmat = NULL,
max.iter = 100, maxls = 1000, conv.crit = 1.0e-8) 
## Estimation method direct
SVAR(x = var.2c, estmethod = "direct", Amat = amat, Bmat = NULL,
hessian = TRUE, method="BFGS") 
</code></pre>

<hr>
<h2 id='SVEC'>Estimation of a SVEC</h2><span id='topic+SVEC'></span><span id='topic+print.svecest'></span>

<h3>Description</h3>

<p>Estimates an SVEC by utilising a scoring algorithm.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVEC(x, LR = NULL, SR = NULL, r = 1, start = NULL, max.iter = 100,
conv.crit = 1e-07, maxls = 1.0, lrtest = TRUE, boot = FALSE, runs = 100)
## S3 method for class 'svecest'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVEC_+3A_x">x</code></td>
<td>
<p>Object of class &lsquo;<code>ca.jo</code>&rsquo;; generated by
<code>ca.jo()</code> contained in <code>urca</code>.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_lr">LR</code></td>
<td>
<p>Matrix of the restricted long run impact matrix.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_sr">SR</code></td>
<td>
<p>Matrix of the restricted contemporaneous impact matrix.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_r">r</code></td>
<td>
<p>Integer, the cointegration rank of x.</p>
</td></tr>  
<tr><td><code id="SVEC_+3A_start">start</code></td>
<td>
<p>Vector of starting values for <code class="reqn">\gamma</code>.</p>
</td></tr>  
<tr><td><code id="SVEC_+3A_max.iter">max.iter</code></td>
<td>
<p>Integer, maximum number of iteration.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_conv.crit">conv.crit</code></td>
<td>
<p>Real, convergence value of algorithm..</p>
</td></tr>
<tr><td><code id="SVEC_+3A_maxls">maxls</code></td>
<td>
<p>Real, maximum movement of the parameters between two
iterations of the scoring algorithm.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_lrtest">lrtest</code></td>
<td>
<p>Logical, over-identification LR test, the result is set
to <code>NULL</code> for just-identified system.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_boot">boot</code></td>
<td>
<p>Logical, if <code>TRUE</code>, standard errors of the parameters
are computed by bootstrapping. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_runs">runs</code></td>
<td>
<p>Integer, number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="SVEC_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>Consider the following reduced form of a k-dimensional vector
error correction model: 
</p>
<p style="text-align: center;"><code class="reqn">
    A \Delta \bold{y}_t = \Pi \bold{y}_{t-1} + \Gamma_1 \Delta
    \bold{y}_{t-1} + \ldots + \Gamma_p \Delta \bold{y}_{t-p + 1} +
    \bold{u}_t \quad .</code>
</p>

<p>This VECM has the following MA representation:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_t = \Xi \sum_{i=1}^t \bold{u}_i + \Xi^*(L)\bold{u}_t +
    \bold{y}_0^* \quad ,</code>
</p>

<p>with <code class="reqn">\Xi = \beta_{\perp} (\alpha_{\perp}'(I_K -
    \sum_{i=1}^{p-1}\Gamma_i)\beta_{\perp} )^{-1}\alpha_{\perp}'</code> and
<code class="reqn">\Xi^*(L)</code> signifies an infinite-order polynomial in the lag
operator with coefficient matrices <code class="reqn">\Xi^*_j</code> that tends to zero
with increasing size of <code class="reqn">j</code>.<br /> 
</p>
<p>Contemporaneous restrictions on the impact matrix <code class="reqn">B</code> must be
supplied as zero entries in <code>SR</code> and free parameters as <code>NA</code>
entries. Restrictions on the long run impact matrix <code class="reqn">\Xi B</code> have
to be supplied likewise. The unknown parameters are estimated by
maximising the concentrated log-likelihood subject to the imposed
restrictions by utilising a scoring algorithm on:
</p>
<p style="text-align: center;"><code class="reqn">
    \ln L_c(A, B) = - \frac{KT}{2}\ln(2\pi) + \frac{T}{2}\ln|A|^2 -
    \frac{T}{2}\ln|B|^2 - \frac{T}{2}tr(A'B'^{-1}B^{-1}A\tilde{\Sigma}_u) 
  </code>
</p>

<p>with <code class="reqn">\tilde{\Sigma}_u</code> signifies the reduced form
variance-covariance matrix and <code class="reqn">A</code> is set equal to the identity
matrix <code class="reqn">I_K</code>.
</p>
<p>If &lsquo;<code>start</code>&rsquo; is not set, then normal random numbers are used as
starting values for the unknown coefficients. In case of an
overidentified SVEC, a likelihood ratio statistic is computed according to:
</p>
<p style="text-align: center;"><code class="reqn">
    LR = T(\ln\det(\tilde{\Sigma}_u^r) - \ln\det(\tilde{\Sigma}_u))
    \quad , </code>
</p>

<p>with <code class="reqn">\tilde{\Sigma}_u^r</code> being the restricted variance-covariance
matrix and <code class="reqn">\tilde{\Sigma}_u</code> being the variance covariance matrix
of the reduced form residuals. The test statistic is distributed as
<code class="reqn">\chi^2(K*(K+1)/2 - nr)</code>, where <code class="reqn">nr</code> is equal to the number of
restrictions.   
</p>


<h3>Value</h3>

<p>A list of class &lsquo;<code>svecest</code>&rsquo; with the following elements is
returned:<br />
</p>
<table>
<tr><td><code>SR</code></td>
<td>
<p>The estimated contemporaneous impact matrix.</p>
</td></tr>
<tr><td><code>SRse</code></td>
<td>
<p>The standard errors of the contemporaneous impact matrix,
if <code>boot = TRUE</code>.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>The estimated long run impact matrix.</p>
</td></tr>
<tr><td><code>LRse</code></td>
<td>
<p>The standard errors of the long run impact matrix,
if <code>boot = TRUE</code>.</p>
</td></tr>  
<tr><td><code>Sigma.U</code></td>
<td>
<p>The variance-covariance matrix of the reduced form
residuals times 100, <em>i.e.</em>, <code class="reqn">\Sigma_U = A^{-1}BB'A^{-1'}
      \times 100</code>.</p>
</td></tr>
<tr><td><code>Restrictions</code></td>
<td>
<p>Vector, containing the ranks of the restricted
long run and contemporaneous impact matrices.</p>
</td></tr>
<tr><td><code>LRover</code></td>
<td>
<p>Object of class &lsquo;<code>htest</code>&rsquo;, holding the Likelihood
ratio overidentification test.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>Vector of used starting values.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Character, type of the SVEC-model.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The &lsquo;<code>ca.jo</code>&rsquo; object &lsquo;<code>x</code>&rsquo;.</p>
</td></tr> 
<tr><td><code>LRorig</code></td>
<td>
<p>The supplied long run impact matrix.</p>
</td></tr>
<tr><td><code>SRorig</code></td>
<td>
<p>The supplied contemporaneous impact matrix.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Integer, the supplied cointegration rank.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Integer, the count of iterations.</p>
</td></tr>   
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>SVEC()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Amisano, G. and C. Giannini (1997), <em>Topics in Structural VAR
Econometrics</em>, 2nd edition, Springer, Berlin.
</p>
<p>Breitung, J., R. Brüggemann and H. Lütkepohl (2004), Structural vector
autoregressive modeling and impulse responses, in H. Lütkepohl and
M. Krätzig (editors), <em>Applied Time Series Econometrics</em>,
Cambridge University Press, Cambridge.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SVAR">SVAR</a></code>, <code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+fevd">fevd</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
vecm &lt;- ca.jo(Canada[, c("prod", "e", "U", "rw")], type = "trace",
              ecdet = "trend", K = 3, spec = "transitory")
SR &lt;- matrix(NA, nrow = 4, ncol = 4)
SR[4, 2] &lt;- 0
SR
LR &lt;- matrix(NA, nrow = 4, ncol = 4)
LR[1, 2:4] &lt;- 0
LR[2:4, 4] &lt;- 0
LR
SVEC(vecm, LR = LR, SR = SR, r = 1, lrtest = FALSE, boot = FALSE)
</code></pre>

<hr>
<h2 id='VAR'>Estimation of a VAR(p)</h2><span id='topic+VAR'></span><span id='topic+print.varest'></span>

<h3>Description</h3>

<p>Estimation of a VAR by utilising OLS per equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR(y, p = 1, type = c("const", "trend", "both", "none"),
season = NULL, exogen = NULL, lag.max = NULL,
ic = c("AIC", "HQ", "SC", "FPE"))
## S3 method for class 'varest'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAR_+3A_y">y</code></td>
<td>
<p>Data item containing the endogenous variables</p>
</td></tr>
<tr><td><code id="VAR_+3A_p">p</code></td>
<td>
<p>Integer for the lag order (default is p=1).</p>
</td></tr>
<tr><td><code id="VAR_+3A_type">type</code></td>
<td>
<p>Type of deterministic regressors to include.</p>
</td></tr>
<tr><td><code id="VAR_+3A_season">season</code></td>
<td>
<p>Inlusion of centered seasonal dummy variables (integer
value of frequency).</p>
</td></tr>
<tr><td><code id="VAR_+3A_exogen">exogen</code></td>
<td>
<p>Inlusion of exogenous variables.</p>
</td></tr>
<tr><td><code id="VAR_+3A_lag.max">lag.max</code></td>
<td>
<p>Integer, determines the highest lag order for lag
length selection according to the choosen <code>ic</code>.</p>
</td></tr>
<tr><td><code id="VAR_+3A_ic">ic</code></td>
<td>
<p>Character, selects the information criteria, if
<code>lag.max</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="VAR_+3A_x">x</code></td>
<td>
<p>Object with class attribute &lsquo;varest&rsquo;.</p>
</td></tr>
<tr><td><code id="VAR_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="VAR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a VAR by OLS per equation. The model is of the following
form:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_t = A_1 \bold{y}_{t-1} + \ldots + A_p \bold{y}_{t-p} +
    CD_t + \bold{u}_t
  </code>
</p>

<p>where <code class="reqn">\bold{y}_t</code> is a <code class="reqn">K \times 1</code> vector of endogenous
variables and <code class="reqn">u_t</code> assigns a spherical disturbance term of the
same dimension. The coefficient matrices <code class="reqn">A_1, \ldots, A_p</code> are of
dimension <code class="reqn">K \times K</code>. In addition, either a constant and/or a
trend can be included as deterministic regressors as well as centered
seasonal dummy variables and/or exogenous variables (term <code class="reqn">CD_T</code>, by
setting the <code>type</code> argument to the corresponding value and/or
setting <code>season</code> to the desired frequency (integer) and/or providing a
matrix object for <code>exogen</code>, respectively. The default for <code>type</code> is
<code>const</code> and for <code>season</code> and <code>exogen</code> the default is
set to <code>NULL</code>.<br />
If for <code>lag.max</code> an integer value is provided instead of
<code>NULL</code> (the default), the lag length is determined by the
selected information criteria in <code>ic</code>, the default is Akaike.
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>varest</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>varresult</code></td>
<td>
<p>list of &lsquo;<code>lm</code>&rsquo; objects.</p>
</td></tr>
<tr><td><code>datamat</code></td>
<td>
<p>The data matrix of the endogenous and explanatory variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The data matrix of the endogenous variables</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character, specifying the deterministic regressors.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>An integer specifying the lag order.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>An integer specifying the dimension of the VAR.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>An integer specifying the number of used observations.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>An integer specifying the total number of observations.</p>
</td></tr>
<tr><td><code>restrictions</code></td>
<td>
<p>Either <code>NULL</code> or a matrix object containing
the zero restrictions of the VAR(p).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>VAR()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary">summary</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="#topic+coef">coef</a></code>, <code><a href="#topic+residuals">residuals</a></code>,
<code><a href="#topic+fitted">fitted</a></code>, <code><a href="#topic+predict">predict</a></code>, <code><a href="#topic+irf">irf</a></code>,
<code><a href="#topic+fevd">fevd</a></code>, <code><a href="#topic+Phi">Phi</a></code>, <code><a href="#topic+Psi">Psi</a></code>,
<code><a href="#topic+normality.test">normality.test</a></code>, <code><a href="#topic+arch.test">arch.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>,
<code><a href="#topic+VARselect">VARselect</a></code>, <code><a href="#topic+logLik">logLik</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
VAR(Canada, p = 2, type = "none")
VAR(Canada, p = 2, type = "const")
VAR(Canada, p = 2, type = "trend")
VAR(Canada, p = 2, type = "both")
</code></pre>

<hr>
<h2 id='vars-deprecated'>Deprecated Functions in package vars</h2><span id='topic+vars-deprecated'></span><span id='topic+A'></span><span id='topic+B'></span><span id='topic+arch'></span><span id='topic+normality'></span><span id='topic+serial'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of package vars only, and may be defunct as soon as the next release.
</p>


<h3>Details</h3>

<p>'A' is a deprecated synonym for 'Acoef'.<br />
'arch' is a deprecated synonym for 'arch.test'.<br />
'B' is a deprecated synonym for 'Bcoef'.<br />
'normality' is a deprecated synonym for 'normality.test'.<br />
'serial' is a deprecated synonym for 'serial.test'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Acoef">Acoef</a></code>, <code><a href="#topic+arch.test">arch.test</a></code>, <code><a href="#topic+Bcoef">Bcoef</a></code>,
<code><a href="#topic+normality.test">normality.test</a></code>, <code><a href="#topic+serial.test">serial.test</a></code>  
</p>

<hr>
<h2 id='VARselect'>Information criteria and FPE for different VAR(p)</h2><span id='topic+VARselect'></span>

<h3>Description</h3>

<p>The function returns infomation criteria and final prediction error
for sequential increasing the lag order up to a VAR(p)-proccess.
which are based on the same sample size. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VARselect(y, lag.max = 10, type = c("const", "trend", "both", "none"),
season = NULL, exogen = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VARselect_+3A_y">y</code></td>
<td>
<p>Data item containing the endogenous variables</p>
</td></tr>
<tr><td><code id="VARselect_+3A_lag.max">lag.max</code></td>
<td>
<p>Integer for the highest lag order (default is
<code>lag.max = 10</code>).</p>
</td></tr>
<tr><td><code id="VARselect_+3A_type">type</code></td>
<td>
<p>Type of deterministic regressors to include.</p>
</td></tr>
<tr><td><code id="VARselect_+3A_season">season</code></td>
<td>
<p>Inlusion of centered seasonal dummy variables (integer
value of frequency).</p>
</td></tr>
<tr><td><code id="VARselect_+3A_exogen">exogen</code></td>
<td>
<p>Inlusion of exogenous variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates a VAR by OLS per equation. The model is of the following
form:
</p>
<p style="text-align: center;"><code class="reqn">
    \bold{y}_t = A_1 \bold{y}_{t-1} + \ldots + A_p \bold{y}_{t-p} + CD_t
    + \bold{u}_t
  </code>
</p>

<p>where <code class="reqn">\bold{y}_t</code> is a <code class="reqn">K \times 1</code> vector of endogenous
variables and <code class="reqn">u_t</code> assigns a spherical disturbance term of the
same dimension. The coefficient matrices <code class="reqn">A_1, \ldots, A_p</code> are of
dimension <code class="reqn">K \times K</code>. In addition, either a constant and/or a
trend can be included as deterministic regressors as well as centered
seasonal dummy variables and/or exogenous variables (term <code class="reqn">CD_T</code>, by
setting the <code>type</code> argument to the corresponding value and/or
setting <code>season</code> to the desired frequency (integer) and/or providing a
matrix object for <code>exogen</code>, respectively. The default for <code>type</code> is
<code>const</code> and for <code>season</code> and <code>exogen</code> the default is
set to <code>NULL</code>.<br />
Based on the same sample size the following information criteria and
the final prediction error are computed:
</p>
<p style="text-align: center;"><code class="reqn">
    AIC(n) = \ln \det(\tilde{\Sigma}_u(n)) + \frac{2}{T}n K^2 \quad, 
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    HQ(n) = \ln \det(\tilde{\Sigma}_u(n)) + \frac{2 \ln(\ln(T))}{T}n K^2 \quad,
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    SC(n) = \ln \det(\tilde{\Sigma}_u(n)) + \frac{\ln(T)}{T}n K^2 \quad,
  </code>
</p>

<p style="text-align: center;"><code class="reqn">
    FPE(n) = \left ( \frac{T + n^*}{T - n^*} \right )^K
    \det(\tilde{\Sigma}_u(n)) \quad ,
  </code>
</p>

<p>with <code class="reqn">\tilde{\Sigma}_u (n) = T^{-1} \sum_{t=1}^T \bold{\hat{u}}_t
    \bold{\hat{u}}_t'</code> and <code class="reqn">n^*</code> is the total number of the
parameters in each equation and <code class="reqn">n</code> assigns the lag order.  
</p>


<h3>Value</h3>

<p>A list with the following elements:<br />
</p>
<table>
<tr><td><code>selection</code></td>
<td>
<p>Vector with the optimal lag number according to each
criterium.</p>
</td></tr>  
<tr><td><code>criteria</code></td>
<td>
<p>A matrix containing the values of the criteria up to
<code>lag.max</code>.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Akaike, H. (1969), Fitting autoregressive models for prediction,
<em>Annals of the Institute of Statistical Mathematics</em>,
<b>21</b>: 243-247.
</p>
<p>Akaike, H. (1971), Autoregressive model fitting for control,
<em>Annals of the Institute of Statistical Mathematics</em>,
<b>23</b>: 163-180.
</p>
<p>Akaike, H. (1973), Information theory and an extension of the maximum
likelihood principle, in B. N. Petrov and F. Csáki (eds.), <em>2nd
International Symposium on Information Theory</em>, Académia Kiadó,
Budapest, pp. 267-281.
</p>
<p>Akaike, H. (1974), A new look at the statistical model identification,
<abbr><span class="acronym">IEEE</span></abbr> <em>Transactions on Automatic Control</em>, <b>AC-19</b>:
716-723.
</p>
<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Hannan, E. J. and B. G. Quinn (1979), The determination of the order
of an autoregression, <em>Journal of the Royal Statistical Society</em>,
<b>B41</b>: 190-195.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>
<p>Quinn, B. (1980), Order determination for a multivariate
autoregression, <em>Journal of the Royal Statistical Society</em>,
<b>B42</b>: 182-185.
</p>
<p>Schwarz, G. (1978), Estimating the dimension of a model, <em>Annals
of Statistics</em>, <b>6</b>: 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Canada)
VARselect(Canada, lag.max = 5, type="const")
</code></pre>

<hr>
<h2 id='vec2var'>Transform a VECM to VAR in levels</h2><span id='topic+vec2var'></span><span id='topic+print.vec2var'></span>

<h3>Description</h3>

<p>An object of formal class 'ca.jo' is transformed to a VAR in level
presentation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2var(z, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2var_+3A_z">z</code></td>
<td>
<p>An object of class 'ca.jo' generated by function
<code>ca.jo()</code> in package 'urca'.</p>
</td></tr>
<tr><td><code id="vec2var_+3A_r">r</code></td>
<td>
<p>The cointegration rank (default is <code>r=1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables the user to transform a vector-error-correction
model (VECM) into a level-VAR form. The rank of the matrix
<code class="reqn">\bold{\Pi}</code> has to be submitted, <em>i.e.</em> how many
cointegration relationships have been determined according to the
outcome of <code>ca.jo()</code>.
</p>


<h3>Value</h3>

<p>A list with class attribute &lsquo;<code>vec2var</code>&rsquo; holding the
following elements:<br />
</p>
<table>
<tr><td><code>deterministic</code></td>
<td>
<p>The matrix of deterministic coefficients.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>A list with matrix object(s) containing the coefficients for
the lagged endogenous variables.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The lag-order of the estimated VAR-process.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>The count of endogenous variables.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A dataframe with the endogenous variables in levels.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>An integer signifying the count of used observations.</p>
</td></tr>
<tr><td><code>totobs</code></td>
<td>
<p>An integer signifying the total number of observations,
<em>i.e</em> including observations taken as starting values..</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The <code>call</code> to <code>vec2var</code>.</p>
</td></tr>
<tr><td><code>vecm</code></td>
<td>
<p>The supplied object <code>z</code> of formal class <code>ca.jo</code>.</p>
</td></tr>
<tr><td><code>datamat</code></td>
<td>
<p>A dataframe with the used dataset.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>A matrix with the residuals from the empirical VAR(p).</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>Intefer, the assigned co-integration rank from the call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bernhard Pfaff</p>


<h3>References</h3>

<p>Hamilton, J. (1994), <em>Time Series Analysis</em>, Princeton
University Press, Princeton.
</p>
<p>Lütkepohl, H. (2006), <em>New Introduction to Multiple Time Series
Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="urca.html#topic+ca.jo">ca.jo</a></code>, <code><a href="#topic+predict">predict</a></code>, <code><a href="#topic+irf">irf</a></code>,
<code><a href="#topic+fevd">fevd</a></code>, <code><a href="#topic+Phi">Phi</a></code>, <code><a href="#topic+Psi">Psi</a></code>,
<code><a href="#topic+normality.test">normality.test</a></code>, <code><a href="#topic+arch.test">arch.test</a></code>,
<code><a href="#topic+serial.test">serial.test</a></code>, <code><a href="#topic+logLik">logLik</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(urca)
data(finland)
sjf &lt;- finland
sjf.vecm &lt;- ca.jo(sjf, ecdet = "none", type = "eigen", K = 2,
spec = "longrun", season = 4)
vec2var(sjf.vecm, r = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
