<!DOCTYPE html><html><head><title>Help for package jordan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jordan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jordan-package'>
<p>A Suite of Routines for Working with Jordan Algebras</p></a></li>
<li><a href='#Arith'><p>Methods for Function Arith in package Jordan</p></a></li>
<li><a href='#c'><p>Concatenation</p></a></li>
<li><a href='#coerce'><p>Coercion</p></a></li>
<li><a href='#Compare-methods'><p>Methods for compare S4 group</p></a></li>
<li><a href='#extract'><p>Extract and replace methods for jordan objects</p></a></li>
<li><a href='#id'><p>Multiplicative identities</p></a></li>
<li><a href='#jordan'><p>Create jordan objects</p></a></li>
<li><a href='#jordan-class'><p>Classes in the  <code>"jordan"</code> package</p></a></li>
<li><a href='#misc'><p>Miscellaneous Jordan functionality</p></a></li>
<li><a href='#r_to_n'><p>Sizes of Matrix-based Jordan algebras</p></a></li>
<li><a href='#random'><p>Random Jordan objects</p></a></li>
<li><a href='#show'><p>Print methods</p></a></li>
<li><a href='#valid'><p>Validity methods</p></a></li>
<li><a href='#zero'><p>The zero Jordan object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Suite of Routines for Working with Jordan Algebras</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A Jordan algebra is an algebraic object originally
   designed to study observables in quantum mechanics.  Jordan
   algebras are commutative but non-associative; they satisfy the
   Jordan identity.  The package follows the ideas and notation of
   K. McCrimmon (2004, ISBN:0-387-95447-3) "A Taste of Jordan
   Algebras".  To cite the package in publications, please use
   Hankin (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2303.06062">doi:10.48550/arXiv.2303.06062</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>onion (&ge; 1.4-0), Matrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadform,methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/jordan">https://github.com/RobinHankin/jordan</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/jordan/issues">https://github.com/RobinHankin/jordan/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-04 09:10:14 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jordan-package'>
A Suite of Routines for Working with Jordan Algebras
</h2><span id='topic+jordan-package'></span>

<h3>Description</h3>

<p>A Jordan algebra is an algebraic object originally
   designed to study observables in quantum mechanics.  Jordan
   algebras are commutative but non-associative; they satisfy the
   Jordan identity.  The package follows the ideas and notation of
   K. McCrimmon (2004, ISBN:0-387-95447-3) &quot;A Taste of Jordan
   Algebras&quot;.  To cite the package in publications, please use
   Hankin (2023) &lt;doi:10.48550/arXiv.2303.06062&gt;.
</p>


<h3>Details</h3>

<p>A <dfn>Jordan algebra</dfn> is a non-associative algebra over the reals
with a multiplication that satisfies the following identities:
</p>
<p style="text-align: center;"><code class="reqn">xy=yx</code>
</p>

<p style="text-align: center;"><code class="reqn">(xy)(xx) = x(y(xx))</code>
</p>

<p>(the second identity is known as the Jordan identity).  In literature
one usually indicates multiplication by juxtaposition but one
sometimes sees <code class="reqn">x\circ y</code>.  Package idiom is to use an
asterisk, as in <code>x*y</code>.  There are five types of Jordan algebras:
</p>

<ol>
<li><p> Real symmetric matrices, class <code>real_symmetric_matrix</code>,
abbreviated in the package to <code>rsm</code>
</p>
</li>
<li><p> Complex Hermitian matrices, class <code>complex_herm_matrix</code>,
abbreviated to <code>chm</code>
</p>
</li>
<li><p> Quaternionic Hermitian matrices, class
<code>quaternion_herm_matrix</code>, abbreviated to <code>qhm</code>
</p>
</li>
<li><p> Albert algebras, the space of <code class="reqn">3\times 3</code>
octonionic matrices, class <code>albert</code>
</p>
</li>
<li><p> Spin factors, class <code>spin</code>
</p>
</li></ol>

<p>(of course, the first two are special cases of the next).  The
<code>jordan</code> package provides functionality to manipulate jordan
objects using natural <span class="rlang"><b>R</b></span> idiom.
</p>
<p>Objects of all these classes are stored in dataframe (technically, a
matrix) form with columns being elements of the jordan algebra.
</p>
<p>The first four classes are matrix-based in the sense that the
algebraic objects are symmetric or Hermitian matrices (the <code>S4</code>
class is &ldquo;<code>jordan_matrix</code>&rdquo;).  The fifth class, spin
factors, is not matrix based.
</p>
<p>One can extract the symmetric or Hermitian matrix from objects of
class <code>jordan_matrix</code> using <code>as.list()</code>, which will return a
list of symmetric or Hermitian matrices.  A function name preceded by
a &ldquo;1&rdquo; (for example <code>as.1matrix()</code> or <code>vec_to_qhm1()</code>)
means that it deals with a single (symmetric or Hermitian) matrix.
</p>
<p>Algebraically, the matrix form of <code>jordan_matrix</code> objects is
redundant (for example, a <code>real_symmetric_matrix</code> of size
<code class="reqn">n\times n</code> has only <code class="reqn">n(n+1)/2</code> independent entries,
corresponding to the upper triangular elements).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>K. McCrimmon 1978. &ldquo;Jordan algebras and their applications&rdquo;.
<em>Bulletin of the American Mathematical Society</em>, Volume 84, Number 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rrsm()     # Random Real Symmetric matrices
rchm()     # Random Complex Hermitian matrices
rqhm()     # Random Quaternionic Hermitian matrices
ralbert()  # Random Albert algebra
rspin()    # Random spin factor

x &lt;- rqhm(n=1)  
y &lt;- rqhm(n=1)  
z &lt;- rqhm(n=1)  

x/1.2 + 0.3*x*y     # Arithmetic works as expected ...
x*(y*z) -(x*y)*z    # ... but '*' is not associative


## Verify the Jordan identity for  type 3 algebras:

LHS &lt;- (x*y)*(x*x)
RHS &lt;- x*(y*(x*x))

diff &lt;- LHS-RHS  # zero to numerical precision

diff[1,drop=TRUE]  # result in matrix form

</code></pre>

<hr>
<h2 id='Arith'>Methods for Function Arith in package Jordan</h2><span id='topic+Arith'></span><span id='topic+Arith-methods'></span><span id='topic+Arith+2Cjordan+2Cmissing-method'></span><span id='topic+Arith+2Cjordan+2CANY-method'></span><span id='topic+Arith+2CANY+2Cjordan-method'></span><span id='topic+Arith+2Cjordan+2Cjordan-method'></span><span id='topic+Arith+2Cjordan+2Cnumeric-method'></span><span id='topic+jordan_negative'></span><span id='topic+jordan_inverse'></span><span id='topic+jordan_arith_jordan'></span><span id='topic+jordan_arith_numeric'></span><span id='topic+numeric_arith_jordan'></span><span id='topic+harmonize_oo'></span><span id='topic+harmonize_on'></span><span id='topic+jordan_plus_jordan'></span><span id='topic+jordan_plus_numeric'></span><span id='topic+jordan_prod_jordan'></span><span id='topic+octjordan_prod_octjordan'></span><span id='topic+quaternion_prod_quaternion'></span><span id='topic+jordan_prod_numeric'></span><span id='topic+jordan_prod_jordan'></span><span id='topic+jordan_power_jordan'></span><span id='topic+jordan_power_singleinteger'></span><span id='topic+jordan_power_numeric'></span><span id='topic+albert_arith_albert'></span><span id='topic+albert_arith_numeric'></span><span id='topic+albert_inverse'></span><span id='topic+albert_power_albert'></span><span id='topic+albert_power_numeric'></span><span id='topic+albert_power_single_n'></span><span id='topic+albert_prod_albert'></span><span id='topic+chm_arith_chm'></span><span id='topic+chm_arith_numeric'></span><span id='topic+chm_inverse'></span><span id='topic+chm_power_numeric'></span><span id='topic+chm_prod_chm'></span><span id='topic+numeric_arith_albert'></span><span id='topic+numeric_arith_chm'></span><span id='topic+numeric_arith_qhm'></span><span id='topic+numeric_arith_rsm'></span><span id='topic+qhm_arith_numeric'></span><span id='topic+qhm_arith_qhm'></span><span id='topic+qhm_inverse'></span><span id='topic+qhm_power_numeric'></span><span id='topic+qhm_prod_qhm'></span><span id='topic+rsm_arith_numeric'></span><span id='topic+rsm_arith_rsm'></span><span id='topic+rsm_inverse'></span><span id='topic+rsm_power_numeric'></span><span id='topic+rsm_prod_rsm'></span><span id='topic+spin_plus_numeric'></span><span id='topic+spin_plus_spin'></span><span id='topic+spin_power_numeric'></span><span id='topic+spin_power_single_n'></span><span id='topic+spin_power_spin'></span><span id='topic+spin_prod_numeric'></span><span id='topic+spin_prod_spin'></span><span id='topic+spin_inverse'></span><span id='topic+spin_negative'></span><span id='topic+vec_albertprod_vec'></span><span id='topic+vec_chmprod_vec'></span><span id='topic+vec_qhmprod_vec'></span><span id='topic+vec_rsmprod_vec'></span>

<h3>Description</h3>

<p>Methods for Arithmetic functions for jordans: <code>+</code>,
<code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jordan_negative(z)
jordan_plus_jordan(e1,e2)
jordan_plus_numeric(e1,e2)
jordan_prod_numeric(e1,e2)
jordan_power_jordan(e1,e2)
albert_arith_albert(e1,e2)
albert_arith_numeric(e1,e2)
albert_inverse(e1)
albert_power_albert(...)
albert_power_numeric(e1,e2)
albert_power_single_n(e1,n)
albert_prod_albert(e1,e2)
chm_arith_chm(e1,e2)
chm_arith_numeric(e1,e2)
chm_inverse(e1)
chm_power_numeric(e1,e2)
chm_prod_chm(e1,e2)
numeric_arith_albert(e1,e2)
numeric_arith_chm(e1,e2)
numeric_arith_qhm(e1,e2)
numeric_arith_rsm(e1,e2)
qhm_arith_numeric(e1,e2)
qhm_arith_qhm(e1,e2)
qhm_inverse(x)
qhm_power_numeric(e1,e2)
qhm_prod_qhm(e1,e2)
rsm_arith_numeric(e1,e2)
rsm_arith_rsm(e1,e2)
rsm_inverse(e1)
rsm_power_numeric(e1,e2)
rsm_prod_rsm(e1,e2)
spin_plus_numeric(e1,e2)
spin_plus_spin(e1,e2)
spin_power_numeric(e1,e2)
spin_power_single_n(e1,n)
spin_power_spin(...)
spin_prod_numeric(e1,e2)
spin_prod_spin(e1,e2)
spin_inverse(...)
spin_negative(e1)
vec_albertprod_vec(x,y)
vec_chmprod_vec(x,y)
vec_qhmprod_vec(x,y)
vec_rsmprod_vec(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arith_+3A_z">z</code>, <code id="Arith_+3A_e1">e1</code>, <code id="Arith_+3A_e2">e2</code></td>
<td>
<p>Jordan objects or numeric vectors</p>
</td></tr>
<tr><td><code id="Arith_+3A_n">n</code></td>
<td>
<p>Integer for powers</p>
</td></tr>
<tr><td><code id="Arith_+3A_...">...</code></td>
<td>
<p>Further arguments (ignored)</p>
</td></tr>
<tr><td><code id="Arith_+3A_x">x</code>, <code id="Arith_+3A_y">y</code></td>
<td>
<p>Numeric vectors, Jordan objects in independent form</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package implements the <code>Arith</code> group of <code>S4</code> generics so
that idiom like <code>A + B*C</code> works as expected with jordans.
</p>
<p>Functions like <code>jordan_inverse()</code> and <code>jordan_plus_jordan()</code>
are low-level helper functions.  The only really interesting operation
is multiplication; functions like <code>jordan_prod_jordan()</code>.
</p>
<p>Names are implemented and the rules are inherited (via
<code>onion::harmonize_oo()</code> and <code>onion::harmonize_on()</code>) from
<code>rbind()</code>.
</p>


<h3>Value</h3>

<p>generally return jordans</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rspin()
y &lt;- rspin()
z &lt;- rspin()

x*(y*(x*x)) - (x*y)*(x*x) # should be zero

x + y*z



</code></pre>

<hr>
<h2 id='c'>Concatenation</h2><span id='topic+c'></span><span id='topic+c.jordan'></span><span id='topic+concatenate'></span><span id='topic+conc'></span><span id='topic+conc_pair'></span><span id='topic+c+2Cjordan-method'></span>

<h3>Description</h3>

<p>Combines its arguments to form a single jordan object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'jordan'
c(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code>, <code id="c_+3A_...">...</code></td>
<td>
<p>Jordan objects</p>
</td></tr></table>


<h3>Details</h3>

<p>Returns a concatenated jordan of the same type as its arguments.
Argument checking is not performed.
</p>


<h3>Value</h3>

<p>Returns a Jordan object of the appropriate type (coercion is not performed)</p>


<h3>Note</h3>

<p>Names are inherited from the behaviour of <code>cbind()</code>, not
<code>c()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(rqhm(),rqhm()*10)
</code></pre>

<hr>
<h2 id='coerce'>Coercion</h2><span id='topic+coerce'></span><span id='topic+coercion'></span><span id='topic+as.1matrix'></span><span id='topic+as.jordan'></span><span id='topic+as.1matrix+2Creal_symmetric_matrix-method'></span><span id='topic+as.1matrix+2Ccomplex_herm_matrix-method'></span><span id='topic+as.1matrix+2Cquaternion_herm_matrix-method'></span><span id='topic+as.1matrix+2Calbert-method'></span><span id='topic+as.1matrix+2Cspin-method'></span><span id='topic+vec_to_rsm1'></span><span id='topic+vec_to_chm1'></span><span id='topic+vec_to_qhm1'></span><span id='topic+vec_to_albert1'></span><span id='topic+rsm1_to_vec'></span><span id='topic+chm1_to_vec'></span><span id='topic+qhm1_to_vec'></span><span id='topic+albert1_to_vec'></span><span id='topic+as.real_symmetric_matrix'></span><span id='topic+as.complex_herm_matrix'></span><span id='topic+as.quaternion_herm_matrix'></span><span id='topic+as.albert'></span><span id='topic+numeric_to_real_symmetric_matrix'></span><span id='topic+numeric_to_complex_herm_matrix'></span><span id='topic+numeric_to_quaternion_herm_matrix'></span><span id='topic+numeric_to_albert'></span><span id='topic+as.list'></span><span id='topic+as.list+2Calbert-method'></span><span id='topic+as.matrix+2Cjordan-method'></span><span id='topic+matrix1_to_jordan'></span>

<h3>Description</h3>

<p>Various coercions needed in the package</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.jordan(x,class)
vec_to_rsm1(x)
vec_to_chm1(x)
vec_to_qhm1(x)
vec_to_albert1(x)
rsm1_to_vec(M)
chm1_to_vec(M)
qhm1_to_vec(M)
albert1_to_vec(H)
as.real_symmetric_matrix(x,d,single=FALSE)
as.complex_herm_matrix(x,d,single=FALSE)
as.quaternion_herm_matrix(x,d,single=FALSE)
as.albert(x,single=FALSE)
numeric_to_real_symmetric_matrix(x,d)
numeric_to_complex_herm_matrix(x,d)
numeric_to_quaternion_herm_matrix(x,d)
numeric_to_albert(e1)
as.list(x,...)
matrix1_to_jordan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_+3A_x">x</code>, <code id="coerce_+3A_e1">e1</code></td>
<td>
<p>Numeric vector of independent entries</p>
</td></tr>
<tr><td><code id="coerce_+3A_m">M</code>, <code id="coerce_+3A_h">H</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="coerce_+3A_d">d</code></td>
<td>
<p>Dimensionality of algebra</p>
</td></tr>
<tr><td><code id="coerce_+3A_single">single</code></td>
<td>
<p>Boolean, indicating whether a single value is to be
returned</p>
</td></tr>
<tr><td><code id="coerce_+3A_class">class</code></td>
<td>
<p>Class of object</p>
</td></tr>
<tr><td><code id="coerce_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numeral &ldquo;1&rdquo; in a function name means that it operates on,
or returns, a single element, usually a matrix.  Thus function
<code>as.1matrix()</code> is used to convert a jordan object to a list of
matrices.  Length one jordan objects are converted to a matrix.
</p>
<p>Functions <code>vec_to_rsm1()</code> et seq convert a numeric vector to a
(symmetric, complex, quaternion, octonion) matrix, that is, elements
of a matrix-based Jordan algebra.
</p>
<p>Functions <code>rsm1_to_vec()</code> convert a (symmetric, complex,
quaternion, octonion) matrix to a numeric vector of independent
components.  The upper triangular components are used; no checking for
symmetry is performed (the lower triangular components, and non-real
components of the diagonal, are discarded).
</p>
<p>Functions <code>as.real_symmetric_matrix()</code>,
<code>as.complex_herm_matrix()</code>, <code>as.quaternion_herm_matrix()</code>
and <code>as.albert()</code> take a numeric matrix and return a
(matrix-based) Jordan object.
</p>
<p>Functions <code>numeric_to_real_symmetric_matrix()</code> have not been
coded up yet.
</p>
<p>Function <code>matrix1_to_jordan()</code> takes a matrix and returns a
length-1 (matrix based) Jordan vector.  It uses the class of the
entries (real, complex, quaternion, octonion) to decide which type of
Jordan to return.
</p>


<h3>Value</h3>

<p>Return a coerced value.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

vec_to_chm1(1:16)  # Hermitian matrix

as.1matrix(rchm())

as.complex_herm_matrix(matrix(runif(75),ncol=3))

matrix1_to_jordan(cprod(matrix(rnorm(35),7,5)))
matrix1_to_jordan(matrix(c(1,1+1i,1-1i,3),2,2))
matrix1_to_jordan(Oil + matrix(1,3,3))


</code></pre>

<hr>
<h2 id='Compare-methods'>Methods for compare S4 group</h2><span id='topic+Compare-methods'></span><span id='topic+Compare+2Cjordan+2Cjordan-method'></span><span id='topic+Compare+2Cjordan+2Cnumeric-method'></span><span id='topic+Compare+2Cnumeric+2Cjordan-method'></span><span id='topic+Compare+2Cjordan+2Cjordan-method'></span><span id='topic+Compare+2Cjordan+2CANY-method'></span><span id='topic+Compare+2CANY+2Cjordan-method'></span><span id='topic+jordan_compare'></span><span id='topic+jordan_equal_jordan'></span><span id='topic+jordan_equal_single'></span><span id='topic+jordan_compare_jordan'></span><span id='topic+jordan_compare_single'></span><span id='topic+spin_equal_spin'></span>

<h3>Description</h3>

<p>Methods for comparison (equal to, greater than, etc) of
jordans.  Only equality makes sense.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jordan_compare_jordan(e1,e2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Compare-methods_+3A_e1">e1</code>, <code id="Compare-methods_+3A_e2">e2</code></td>
<td>
<p>Jordan objects</p>
</td></tr></table>


<h3>Value</h3>

<p>Return a boolean</p>


<h3>Examples</h3>

<pre><code class='language-R'># rspin() &gt; 0 # meaningless and returns an error
</code></pre>

<hr>
<h2 id='extract'>Extract and replace methods for jordan objects</h2><span id='topic+extract'></span><span id='topic+index-class'></span><span id='topic++5B+2Calbert+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Ccomplex_herm_matrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Cjordan+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+2Cjordan+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cquaternion_herm_matrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Creal_symmetric_matrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Cspin+2Cindex+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cspin+2Cmissing+2Cindex+2CANY-method'></span><span id='topic++5B+3C-+2Calbert+2Cindex+2Cmissing+2Calbert-method'></span><span id='topic++5B+3C-+2Ccomplex_herm_matrix+2Cindex+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Ccomplex_herm_matrix+2Cindex+2Cmissing+2Ccomplex_herm_matrix-method'></span><span id='topic++5B+3C-+2Cjordan_matrix+2Cindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cquaternion_herm_matrix+2Cindex+2Cmissing+2Cquaternion_herm_matrix-method'></span><span id='topic++5B+3C-+2Creal_symmetric_matrix+2Cindex+2Cmissing+2Creal_symmetric_matrix-method'></span><span id='topic++5B+3C-+2Cspin+2Cindex+2Cindex+2CANY-method'></span><span id='topic++5B+3C-+2Cspin+2Cindex+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspin+2Cindex+2Cmissing+2Cspin-method'></span><span id='topic++5B+2Cspin+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspin+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cspin+2Cmissing+2CANY+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspin+2Cmissing+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+3C-+2Cspin+2Cmissing+2Cmissing+2Cspin-method'></span>

<h3>Description</h3>

<p>Extraction and replace methods for jordan objects should
work as expected.
</p>
<p>Replace methods can take a jordan or a numeric, but  the numeric must
be zero.
</p>


<h3>Value</h3>

<p>Generally return a jordan object of the same class as the first argument</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "albert", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "complex_herm_matrix", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "jordan", i = "index", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "jordan", i = "index", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "quaternion_herm_matrix", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "real_symmetric_matrix", i = "index", j = "missing", drop = "logical")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "spin", i = "index", j = "missing", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "spin", i = "missing", j = "index", drop = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "albert", i = "index", j = "missing", value = "albert")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "complex_herm_matrix", i = "index", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "complex_herm_matrix", i = "index", j = "missing", value = "complex_herm_matrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "jordan_matrix", i = "index", j = "missing", value = "numeric")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "quaternion_herm_matrix", i = "index", j = "missing", value = "quaternion_herm_matrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "real_symmetric_matrix", i = "index", j = "missing", value = "real_symmetric_matrix")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "spin", i = "index", j = "index", value = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "spin", i = "index", j = "missing", value = "numeric")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "spin", i = "index", j = "missing", value = "spin")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("index")  # taken from the Matrix package

a &lt;- rspin(7)
a[2:4] &lt;- 0
a[5:7] &lt;- a[1]*10
a

</code></pre>

<hr>
<h2 id='id'>Multiplicative identities</h2><span id='topic+id'></span><span id='topic+identity'></span><span id='topic+is.id'></span><span id='topic+as.id'></span><span id='topic+is.identity'></span><span id='topic+as.identity'></span><span id='topic+rsm_id'></span><span id='topic+chm_id'></span><span id='topic+qhm_id'></span><span id='topic+spin_id'></span><span id='topic+albert_id'></span><span id='topic+one'></span><span id='topic+as.one'></span>

<h3>Description</h3>

<p>Multiplying a jordan object by the <dfn>identity</dfn> leaves it unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.identity(x)
rsm_id(n,d)
chm_id(n,d)
qhm_id(n,d)
albert_id(n)
spin_id(n=3,d=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_n">n</code></td>
<td>
<p>Length of vector to be created</p>
</td></tr>
<tr><td><code id="id_+3A_d">d</code></td>
<td>
<p>Dimensionality</p>
</td></tr>
<tr><td><code id="id_+3A_x">x</code></td>
<td>
<p>In function <code>as.identity()</code>, a jordan object.  Return
value will be a jordan object of the same dimensionality but entries
equal to the identity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The identity object in the matrix-based classes (<code>jordan_matrix</code>)
is simply the identity matrix.  Function <code>as.identity()</code> takes an
object of any of the five types (<code>rsm</code>, <code>chm</code>, <code>qhm</code>,
<code>spin</code>, or <code>albert</code>) and returns a vector of the same length
and type, but comprising identity elements.
</p>
<p>Class <code>spin</code> has identity
<code class="reqn">\left(1,\mathbf{0}\right)</code>.
</p>


<h3>Value</h3>

<p>A jordan object is returned.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.albert(matrix(sample(1:99,81,replace=TRUE),nrow=27))
I &lt;- as.identity(x)
x == x*I  # should be TRUE


rsm_id(6,3)




</code></pre>

<hr>
<h2 id='jordan'>Create jordan objects</h2><span id='topic+jordan'></span><span id='topic+is.rsm'></span><span id='topic+is.real_symmetric_matrix'></span><span id='topic+is.quaternion_herm_matrix'></span><span id='topic+quaternion_herm_matrix'></span><span id='topic+complex_herm_matrix'></span><span id='topic+is.complex_herm_matrix'></span><span id='topic+real_symmetric_matrix'></span><span id='topic+albert'></span><span id='topic+is.albert'></span><span id='topic+is.jordan'></span><span id='topic+as.spin'></span><span id='topic+is.spin'></span><span id='topic+spin'></span><span id='topic+numeric_compare_jordan'></span>

<h3>Description</h3>

<p>Creation methods for jordan objects</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="jordan_+3A_m">M</code></td>
<td>
<p>A matrix with columns representing independent entries in a
matrix-based Jordan algebra</p>
</td></tr>
<tr><td><code id="jordan_+3A_a">a</code>, <code id="jordan_+3A_v">V</code></td>
<td>
<p>Scalar and vector components of a spin factor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions documented here are the creation methods for the five
types of jordan algebra.
</p>

<ul>
<li><p><code>quaternion_herm_matrix()</code>
</p>
</li>
<li><p><code>complex_herm_matrix()</code>
</p>
</li>
<li><p><code>real_symmetric_matrix()</code>
</p>
</li>
<li><p><code>albert()</code>
</p>
</li>
<li><p><code>spin()</code>
</p>
</li></ul>

<p>(to generate quick &ldquo;get you going&rdquo; Jordan algebra objects, use
the <code>rrsm()</code> family of functions, documented at <code>random.Rd</code>).
</p>


<h3>Value</h3>

<p>Return jordans or Boolean as appropriate</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+random">random</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- real_symmetric_matrix(1:10)  # vector of length 1
as.1matrix(A)                     # in matrix form

complex_herm_matrix(cbind(1:25,2:26))
quaternion_herm_matrix(1:15)

albert(1:27)
spin(-6,cbind(1:12,12:1))


x &lt;- rrsm() ; y &lt;- rrsm() ; z &lt;- rrsm()  # also works with the other Jordans

x*(y*z) - (x*y)*z         # Jordan algebra is not associative...
(x*y)*(x*x) - x*(y*(x*x)) # but satisfies the Jordan identity


</code></pre>

<hr>
<h2 id='jordan-class'>Classes in the  <code>"jordan"</code> package</h2><span id='topic+jordan-class'></span><span id='topic+real_symmetric_matrix-class'></span><span id='topic+complex_herm_matrix-class'></span><span id='topic+quaternion_herm_matrix-class'></span><span id='topic+albert-class'></span><span id='topic+spin-class'></span><span id='topic+jordan_matrix-class'></span><span id='topic+jordan_special-class'></span><span id='topic+index'></span>

<h3>Description</h3>

<p>Various classes in the <span class="pkg">jordan</span> package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>K. McCrimmon 1978. &ldquo;Jordan algebras and their applications&rdquo;.
<em>Bulletin of the American Mathematical Society</em>, Volume 84, Number 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("jordan")
</code></pre>

<hr>
<h2 id='misc'>Miscellaneous Jordan functionality</h2><span id='topic+misc'></span><span id='topic+harmonize_spin_numeric'></span><span id='topic+harmonize_spin_spin'></span><span id='topic+jordan_compare_numeric'></span><span id='topic+mymatrixpower'></span><span id='topic+mymatrixpower_onion'></span><span id='topic+quadraticform'></span><span id='topic+r1'></span><span id='topic+rn'></span><span id='topic+dim+2Cspin-method'></span><span id='topic+length+2Cjordan-method'></span><span id='topic+names+2Cjordan-method'></span><span id='topic+names+3C-+2Cjordan-method'></span><span id='topic+sum+2Cjordan-method'></span>

<h3>Description</h3>

<p>Miscellaneous Jordan functionality that should be
documented somewhere</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonize_spin_numeric(e1,e2)
harmonize_spin_spin(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="misc_+3A_e1">e1</code>, <code id="misc_+3A_e2">e2</code></td>
<td>
<p>Objects to harmonize</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Miscellaneous low-level helper functions.
</p>
<p>The harmonize functions <code>harmonize_spin_numeric()</code> and
<code>harmonize_spin_spin()</code> work for spin objects for the
matrix-based classes <code>onion::harmonize_oo()</code> and
<code>onion::harmonize_on()</code> are used.
</p>


<h3>Value</h3>

<p>These are mostly low-level helper functions; they not
particularly user-friendly.  They generally return either
numeric or Jordan objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='r_to_n'>Sizes of Matrix-based Jordan algebras</h2><span id='topic+r_to_n'></span><span id='topic+r_to_n_rsm'></span><span id='topic+r_to_n_chm'></span><span id='topic+r_to_n_qhm'></span><span id='topic+r_to_n_albert'></span><span id='topic+n_to_r'></span><span id='topic+n_to_r_rsm'></span><span id='topic+n_to_r_chm'></span><span id='topic+n_to_r_qhm'></span><span id='topic+n_to_r_albert'></span>

<h3>Description</h3>

<p>Given the number of rows in a (matrix-based) Jordan object, return the
size of the underlying associative matrix algebra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_to_n_rsm(r)
r_to_n_chm(r)
r_to_n_qhm(r)
r_to_n_albert(r=27)
n_to_r_rsm(n)
n_to_r_chm(n)
n_to_r_qhm(n)
n_to_r_albert(n=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_to_n_+3A_n">n</code></td>
<td>
<p>Integer, underlying associative algebra being matrices of
size <code class="reqn">n\times n</code></p>
</td></tr>
<tr><td><code id="r_to_n_+3A_r">r</code></td>
<td>
<p>Integer, number of rows of independent representation of a
matrix-based jordan object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are here for consistency, and the <code>albert</code> ones for
completeness.
</p>
<p>For the record, they are:
</p>

<ul>
<li><p> Real symmetric matrices, <code>rsm</code>, <code class="reqn">r=n(n+1)/2</code>,
<code class="reqn">n=(\sqrt{1+4r}-1)/2</code>
</p>
</li>
<li><p> Complex Hermitian matrices, <code>chm</code>, <code class="reqn">r=n^2</code>, 
<code class="reqn">n=\sqrt{r}</code>
</p>
</li>
<li><p> Quaternion Hermitian matrices, <code>qhm</code>, <code class="reqn">r=n(2n-1)</code>, 
<code class="reqn">n=(1+\sqrt{1+8r})/4</code>
</p>
</li>
<li><p> Albert algebras, <code class="reqn">r=27</code>, <code class="reqn">n=3</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Return non-negative integers</p>


<h3>Note</h3>

<p>I have not been entirely consistent in my use of these functions.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>r_to_n_qhm(nrow(rqhm()))
</code></pre>

<hr>
<h2 id='random'>Random Jordan objects</h2><span id='topic+random'></span><span id='topic+ralbert'></span><span id='topic+rjordan'></span><span id='topic+rrsm'></span><span id='topic+rchm'></span><span id='topic+rqhm'></span><span id='topic+rspin'></span>

<h3>Description</h3>

<p>Random jordan objects with specified properties</p>


<h3>Usage</h3>

<pre><code class='language-R'>ralbert(n=3)
rrsm(n=3, d=5)
rchm(n=3, d=5)
rqhm(n=3, d=5)
rspin(n=3, d=5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_n">n</code></td>
<td>
<p>Length of random object returned</p>
</td></tr>
<tr><td><code id="random_+3A_d">d</code></td>
<td>
<p>Dimensionality of random object returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions give a quick &ldquo;get you going&rdquo; random Jordan
object to play with.
</p>


<h3>Value</h3>

<p>Return a jordan object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrsm()
ralbert()
rspin()
</code></pre>

<hr>
<h2 id='show'>Print methods</h2><span id='topic+show'></span><span id='topic+top_and_bottom'></span><span id='topic+head_and_tail'></span><span id='topic+spin_show'></span><span id='topic+description'></span><span id='topic+jordan_matrix_show'></span><span id='topic+albert_show'></span><span id='topic+spin_show'></span><span id='topic+description'></span>

<h3>Description</h3>

<p>Show methods, to display objects at the prompt</p>


<h3>Usage</h3>

<pre><code class='language-R'>albert_show(x)
spin_show(x)
jordan_matrix_show(x)
description(x,plural=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_+3A_x">x</code></td>
<td>
<p>Jordan object</p>
</td></tr>
<tr><td><code id="show_+3A_plural">plural</code></td>
<td>
<p>Boolean, indicating whether plural form is to
be given</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The special algebras use a bespoke show method,
<code>jordan_matrix_show()</code> or <code>spin_show()</code>.  If the number of
elements is small, they display a concise representation and modify
the row and column names of the underlying matrix slightly; spin
factors are displayed with the scalar component offset from the vector
component.
</p>
<p>Print methods for special algebras are sensitive to the value of
option <code>head_and_tail</code>, a two-element integer vector indicating
the number of start lines and end lines to print.
</p>
<p>Function <code>description()</code> gives a natural-language description of
its argument, used in the print method.
</p>


<h3>Value</h3>

<p>Returns the argument</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rspin()

rqhm()

rchm()
</code></pre>

<hr>
<h2 id='valid'>Validity methods</h2><span id='topic+valid'></span><span id='topic+validity'></span><span id='topic+valid_rsm'></span><span id='topic+valid_chm'></span><span id='topic+valid_qhm'></span><span id='topic+is_ok_rsm'></span><span id='topic+is_ok_chm'></span><span id='topic+is_ok_qhm'></span><span id='topic+is_ok_albert'></span><span id='topic+is_ok_rsm'></span><span id='topic+valid_albert'></span>

<h3>Description</h3>

<p>Validity methods, to check that objects are well-formed</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_rsm(object)
valid_chm(object)
valid_qhm(object)
valid_albert(object)
is_ok_rsm(r)
is_ok_chm(r)
is_ok_qhm(r)
is_ok_albert(r)
is_ok_rsm(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_+3A_object">object</code></td>
<td>
<p>Putative jordan object</p>
</td></tr>
<tr><td><code id="valid_+3A_r">r</code></td>
<td>
<p>Integer, number of rows in putative jordan object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Validity methods.  The <code>validity_foo()</code> functions test for an object
to be the right type, and the  <code>is_ok_foo()</code> functions test the
number of rows being appropriate for a jordan object of some type; these
functions return an error if not appropriate, or, for
<code>jordan_matrix</code> objects, the size of the matrix worked with.
</p>


<h3>Value</h3>

<p>Return a Boolean</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'> is_ok_qhm(45)   # 5x5 Hermitian quaternionic matrices
#is_ok_qhm(46)   # FALSE
</code></pre>

<hr>
<h2 id='zero'>The zero Jordan object</h2><span id='topic+zero'></span><span id='topic+is_zero_jordan'></span><span id='topic+is.zero+2Cjordan-method'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Package idiom for the zero Jordan object, and testing</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
is_zero_jordan(e1,e2=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_x">x</code>, <code id="zero_+3A_e1">e1</code></td>
<td>
<p>Jordan object to test for zeroness</p>
</td></tr>
<tr><td><code id="zero_+3A_e2">e2</code></td>
<td>
<p>Dummy numeric object to make the <code>Arith</code> method work</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One often wants to test a jordan object for being zero, and natural
idiom would be <code>rchm()==0</code>.  The helper function is
<code>is_zero_jordan()</code>, and the generic is <code>is.zero()</code>.
</p>


<h3>Value</h3>

<p>Returns a Boolean</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rrsm()*0 == 0
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
