<!DOCTYPE html><html><head><title>Help for package qMRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qMRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qMRI-package'>
<p>Methods for Quantitative Magnetic Resonance Imaging ('qMRI')</p></a></li>
<li><a href='#awssigmc'>
<p>Estimate noise variance for multicoil MR systems</p></a></li>
<li><a href='#calculateQI'>
<p>Obtain quantitative maps from estimated ESTATICS parameters.</p></a></li>
<li><a href='#colMT'><p>MT map color scheme</p></a></li>
<li><a href='#estimateESTATICS'>
<p>Estimate parameters in the ESTATICS model.</p></a></li>
<li><a href='#estimateIR'>
<p>Estimate IRMRI parameters</p></a></li>
<li><a href='#estimateIRfluid'><p>Estimate parameters in Inversion Recovery MRI experiments model for CSF voxel</p></a></li>
<li><a href='#estimateIRsolid'>
<p>Estimate parameters in Inversion Recovery MRI experiments mixture model for non-fluid voxel</p></a></li>
<li><a href='#estimateIRsolidfixed'>
<p>Estimate mixture parameter in Inversion Recovery MRI experiments mixture model for non-fluid voxel</p></a></li>
<li><a href='#extract-methods'>
<p>Methods to extract information from objects of class <code>"MPMData"</code>,</p>
<code>"ESTATICSModel"</code>, <code>"sESTATICSModel"</code>, <code>"qMaps"</code>,
<code>"IRdata"</code>, <code>"IRfluid"</code> and <code>"IRmixed"</code>.</a></li>
<li><a href='#generateIRData'>
<p>generate IR MRI example data</p></a></li>
<li><a href='#MREdisplacement'>
<p>Calculate the motion induced signal phase for IR-MRE in biphasic material</p></a></li>
<li><a href='#readIRData'>
<p>Prepare IRMRI dataset</p></a></li>
<li><a href='#readMPMData'>
<p>Read experimental Multi-Parameter Mapping (MPM) data.</p></a></li>
<li><a href='#smoothESTATICS'>
<p>Adaptive smoothing of ESTATICS parameters and MPM data</p></a></li>
<li><a href='#smoothIRSolid'>
<p>Smooth object generated by function <code>estimateIRsolid</code></p></a></li>
<li><a href='#writeESTATICS'>
<p>Write maps of ESTATICS parameters in standardized form as NIfTI files.</p></a></li>
<li><a href='#writeQI'>
<p>Write estimated maps  in standardized form as NIfTI files.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Quantitative Magnetic Resonance Imaging ('qMRI')</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), awsMethods (&ge; 1.0), methods, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>oro.nifti (&ge; 0.9), stringr, aws (&ge; 2.4), adimpro (&ge; 0.9)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of methods for estimation of quantitative maps
    from Multi-Parameter Mapping (MPM) acquisitions (Weiskopf et al. (2013)
    &lt;<a href="https://doi.org/10.3389%2Ffnins.2013.00095">doi:10.3389/fnins.2013.00095</a>&gt;) and analysis of Inversion Recovery MRI data.
    Usage of the package is described in
    Polzehl and Tabelow (2023),
    "Magnetic Resonance Brain Imaging", 2nd Edition, Chapter 6 and 7, Springer, Use R! Series.
    &lt;<a href="https://doi.org/10.1007%2F978-3-031-38949-8">doi:10.1007/978-3-031-38949-8</a>&gt;.
    J. Polzehl and K. Tabelow (2023), "Magnetic Resonance Brain Imaging - Modeling and Data Analysis Using R: Code and Data."
    &lt;<a href="https://doi.org/10.20347%2FWIAS.DATA.6">doi:10.20347/WIAS.DATA.6</a>&gt; provides extensive example code and data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package is Copyright (C) 2015-2024 Weierstrass
Institute for Applied Analysis and Stochastics.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.wias-berlin.de/research/ats/imaging/">https://www.wias-berlin.de/research/ats/imaging/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-22 08:40:06 UTC; tabelow</td>
</tr>
<tr>
<td>Author:</td>
<td>Joerg Polzehl [aut],
  Karsten Tabelow [aut, cre],
  WIAS Berlin [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 21:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='qMRI-package'>
Methods for Quantitative Magnetic Resonance Imaging ('qMRI')
</h2><span id='topic+qMRI-package'></span><span id='topic+qMRI'></span>

<h3>Description</h3>

<p>Implementation of methods for estimation of quantitative maps
    from Multi-Parameter Mapping (MPM) acquisitions (Weiskopf et al. (2013)
    &lt;doi:10.3389/fnins.2013.00095&gt;) and analysis of Inversion Recovery MRI data.
    Usage of the package is described in
    Polzehl and Tabelow (2023),
    &quot;Magnetic Resonance Brain Imaging&quot;, 2nd Edition, Chapter 6 and 7, Springer, Use R! Series.
    &lt;doi:10.1007/978-3-031-38949-8&gt;.
    J. Polzehl and K. Tabelow (2023), &quot;Magnetic Resonance Brain Imaging - Modeling and Data Analysis Using R: Code and Data.&quot;
    &lt;doi:10.20347/WIAS.DATA.6&gt; provides extensive example code and data.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> qMRI</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Methods for Quantitative Magnetic Resonance Imaging ('qMRI')</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.7.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-05-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Joerg", "Polzehl", role = c("aut"),
                    email = "joerg.polzehl@wias-berlin.de"),
             person("Karsten", "Tabelow", role = c("aut", "cre"),
                    email = "karsten.tabelow@wias-berlin.de"),
             person("WIAS Berlin", role = c("cph", "fnd")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5), awsMethods (&gt;= 1.0), methods, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> oro.nifti (&gt;= 0.9), stringr, aws (&gt;= 2.4), adimpro (&gt;= 0.9)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementation of methods for estimation of quantitative maps
    from Multi-Parameter Mapping (MPM) acquisitions (Weiskopf et al. (2013)
    &lt;doi:10.3389/fnins.2013.00095&gt;) and analysis of Inversion Recovery MRI data.
    Usage of the package is described in
    Polzehl and Tabelow (2023),
    "Magnetic Resonance Brain Imaging", 2nd Edition, Chapter 6 and 7, Springer, Use R! Series.
    &lt;doi:10.1007/978-3-031-38949-8&gt;.
    J. Polzehl and K. Tabelow (2023), "Magnetic Resonance Brain Imaging - Modeling and Data Analysis Using R: Code and Data."
    &lt;doi:10.20347/WIAS.DATA.6&gt; provides extensive example code and data.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Copyright: </td><td style="text-align: left;"> This package is Copyright (C) 2015-2024 Weierstrass
Institute for Applied Analysis and Stochastics.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.wias-berlin.de/research/ats/imaging/</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> covr,
testthat,
knitr,
rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Joerg Polzehl [aut],
  Karsten Tabelow [aut, cre],
  WIAS Berlin [cph, fnd]</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
MREdisplacement         Calculate the motion induced signal phase for
                        IR-MRE in biphasic material
awssigmc                Estimate noise variance for multicoil MR
                        systems
calculateQI             Obtain quantitative maps from estimated
                        ESTATICS parameters.
colMT                   MT map color scheme
estimateESTATICS        Estimate parameters in the ESTATICS model.
estimateIR              Estimate IRMRI parameters
estimateIRfluid         Estimate parameters in Inversion Recovery MRI
                        experiments model for CSF voxel
estimateIRsolid         Estimate parameters in Inversion Recovery MRI
                        experiments mixture model for non-fluid voxel
estimateIRsolidfixed    Estimate mixture parameter in Inversion
                        Recovery MRI experiments mixture model for
                        non-fluid voxel
extract.ANY-method      Methods to extract information from objects of
                        class '"MPMData"', '"ESTATICSModel"',
                        '"sESTATICSModel"', '"qMaps"', '"IRdata"',
                        '"IRfluid"' and '"IRmixed"'.
generateIRData          generate IR MRI example data
qMRI-package            Methods for Quantitative Magnetic Resonance
                        Imaging ('qMRI')
readIRData              Prepare IRMRI dataset
readMPMData             Read experimental Multi-Parameter Mapping (MPM)
                        data.
smoothESTATICS          Adaptive smoothing of ESTATICS parameters and
                        MPM data
smoothIRSolid           Smooth object generated by function
                        'estimateIRsolid'
writeESTATICS           Write maps of ESTATICS parameters in
                        standardized form as NIfTI files.
writeQI                 Write estimated maps in standardized form as
                        NIfTI files.
</pre>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>
<p>Maintainer: Karsten Tabelow &lt;karsten.tabelow@wias-berlin.de&gt;
</p>


<h3>References</h3>

<p>Weiskopf, N.; Suckling, J.; Williams, G.; Correia, M. M.; Inkster, B.; Tait, R.;
Ooi, C.; Bullmore, E. T. &amp; Lutti, A. Quantitative multi-parameter mapping of
R1, PD(*), MT, and R2(*) at 3T: a multi-center validation. Front Neurosci,
Wellcome Trust Centre for Neuroimaging, UCL Institute of Neurology, University College
London, UK., 2013, 7, 95
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6 and 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="aws.html#topic+aws-package">aws</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dataDir &lt;- system.file("extdata",package="qMRI")
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
#
#  smooth maps of ESTATICS Parameters
#
setCores(2)
modelMPMsp1 &lt;- smoothESTATICS(modelMPM,
                              kstar = 16,
                              alpha = 0.004,
                              patchsize=1,
                              verbose = TRUE)
#
#  resulting ESTATICS parameter maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
oldpar &lt;- par(mfrow=c(2,4),mar=c(3,3,3,1),mgp=c(2,1,0))
on.exit(par(oldpar))
pnames &lt;- c("T1","MT","PD","R2star")
modelCoeff &lt;- extract(modelMPM,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(pnames[i])
   }
   modelCoeff &lt;- extract(modelMPMsp1,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(paste("smoothed",pnames[i]))
   }
}
#
#  Compute quantitative maps (R1, R2star, PD, MT)
#
qMRIMaps &lt;- calculateQI(modelMPM,
                        b1File = B1File,
                        TR2 = 3.4)
qMRISmoothedp1Maps &lt;- calculateQI(modelMPMsp1,
                                    b1File = B1File,
                                    TR2 = 3.4)
#
#  resulting quantitative maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
par(mfrow=c(2,4),mar=c(3,3,3,1),mgp=c(2,1,0))
nmaps &lt;- c("R1","R2star","PD","MT")
qmap &lt;- extract(qMRIMaps,nmaps)
for (i in 1:4) rimage(qmap[[i]][,11,],main=nmaps[i])
qmap &lt;- extract(qMRISmoothedp1Maps,nmaps)
for (i in 1:4) rimage(qmap[[i]][,11,],main=paste("Smoothed",nmaps[i]))
}
par(oldpar)

</code></pre>

<hr>
<h2 id='awssigmc'>
Estimate noise variance for multicoil MR systems
</h2><span id='topic+awslsigmc'></span><span id='topic+awssigmc'></span>

<h3>Description</h3>

<p>The distribution of image intensity values <code class="reqn">S_i</code> divided by the noise standard deviation in <code class="reqn">K</code>-space <code class="reqn">\sigma</code> 
in dMRI experiments is assumed
to follow a non-central chi-distribution with <code class="reqn">2L</code> degrees of freedom and noncentrality parameter <code class="reqn">\eta</code>, where <code class="reqn">L</code> refers to the number of receiver 
coils in the system and <code class="reqn">\sigma \eta</code> is the signal of interest. This is an idealization in the sense that 
each coil is assumed to have the same contribution at each location. For realistic modeling <code class="reqn">L</code> should 
be a locally smooth function in voxel space that reflects the varying local influence of the receiver coils in the
the reconstruction algorithm used. 
</p>
<p>The functions assume <code class="reqn">L</code> to be known and estimate either a local 
(function <code>awslsigmc</code>) or global ( function <code>awssigmc</code>) 
<code class="reqn">\sigma</code> employing an assumption of local homogeneity for
the noncentrality parameter <code class="reqn">\eta</code>.
</p>
<p>Function <code>afsigmc</code> implements estimates from Aja-Fernandez (2009). 
Function <code>aflsigmc</code> implements the estimate from Aja-Fernandez (2013). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>awssigmc(y, steps, mask = NULL, ncoils = 1, vext = c(1, 1), lambda = 20, 
         h0 = 2, verbose = FALSE, sequence = FALSE, hadj = 1, q = 0.25, 
         qni = .8, method=c("VAR","MAD"))
awslsigmc(y, steps, mask = NULL, ncoils = 1, vext = c(1, 1), lambda = 5, minni = 2, 
         hsig = 5, sigma = NULL, family = c("NCchi"), verbose = FALSE, 
         trace=FALSE, u=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="awssigmc_+3A_y">y</code></td>
<td>

<p>3D array, usually obtained from an object of class <code>dwi</code> as
<code>obj@si[,,,i]</code> for some <code>i</code>, i.e. one 3D image from an dMRI experiment.
Alternatively a vector of length <code>sum(mask)</code> may be suppied together with a brain mask in <code>mask</code>.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_steps">steps</code></td>
<td>

<p>number of steps in adapive weights smoothing, used to reveal the unerlying
mean structure.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_mask">mask</code></td>
<td>

<p>restrict computations to voxel in mask, if <code>is.null(mask)</code> all voxel are used.
In function <code>afsigmc</code> mask should refer to background for <code>method %in% c("modem1chi","bkm2chi","bkm1chi")</code> and to voxel within the head for 
<code>method=="modevn"</code>. 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_ncoils">ncoils</code></td>
<td>

<p>number of coils, or equivalently number of effective degrees of freedom of non-central chi distribution
divided by 2.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_vext">vext</code></td>
<td>

<p>voxel extentions
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_lambda">lambda</code></td>
<td>

<p>scale parameter in adaptive weights smoothing
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_h0">h0</code></td>
<td>

<p>initial bandwidth
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_verbose">verbose</code></td>
<td>

<p>if <code>verbose==TRUE</code> density plots 
and quantiles of local estimates of <code>sigma</code> are provided.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_trace">trace</code></td>
<td>

<p>if <code>trace==TRUE</code> intermediate results for each step are
returned in component tergs for all voxel in mask.
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_sequence">sequence</code></td>
<td>

<p>if <code>sequence=TRUE</code> a vector of estimates for the noise
standard deviation <code>sigma</code> for the individual steps is returned
instead of the final value only.  
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_hadj">hadj</code></td>
<td>

<p>adjustment factor for bandwidth (chosen by <code>bw.nrd</code>) in mode estimation 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_q">q</code></td>
<td>

<p>quantile to be used for interquantile-differences. 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_qni">qni</code></td>
<td>

<p>quantile of distribution of actual sum of weights <code class="reqn">N_i=\sum_j w_{ij}</code> in adaptive smoothing. Only voxel i with <code class="reqn">N_i &gt; q_{qni}(N_.)</code> are used for variance estimation. Should be larger than 0.5.  
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_method">method</code></td>
<td>
<p> in case of function <code>awssigmc</code> the
method for variance estimation, either &quot;VAR&quot; (variance) or &quot;MAD&quot; (mean absolute deviation). In function <code>afsigmc</code> see last column in Table 2 in Aja-Fernandez (2009). 
</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_minni">minni</code></td>
<td>
<p>Minimum sum of weights for updating values of <code>sigma</code>.</p>
</td></tr>
<tr><td><code id="awssigmc_+3A_hsig">hsig</code></td>
<td>
<p>Bandwidth of the median filter.</p>
</td></tr> 
<tr><td><code id="awssigmc_+3A_sigma">sigma</code></td>
<td>
<p>Initial estimate for <code>sigma</code></p>
</td></tr>
<tr><td><code id="awssigmc_+3A_family">family</code></td>
<td>
<p>One of <code>"Gauss"</code> or <code>"NCchi"</code> (default) defining the 
probability distribution to use.</p>
</td></tr> 
<tr><td><code id="awssigmc_+3A_u">u</code></td>
<td>
<p>if <code>verbose==TRUE</code> an array of noncentrality paramters for
comparisons. Internal use for tests only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>sigma</code></td>
<td>
<p>either a scalar or a vector of estimated noise standard deviations.
</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>the estimated mean structure</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>K. Tabelow, H.U. Voss, J. Polzehl, Local estimation of the noise level in MRI using structural adaptation, Medical Image Analysis, 20 (2015), pp. 76&ndash;86.
</p>


<h3>See Also</h3>

<p><code><a href="aws.html#topic+aws-package">aws</a></code>
</p>

<hr>
<h2 id='calculateQI'>
Obtain quantitative maps from estimated ESTATICS parameters.
</h2><span id='topic+calculateQI'></span>

<h3>Description</h3>

<p>Quantitaive imaging parameters are calculated from the estimated parameters
in the ESTATICS model. This involves a correction for magnetic field inhomogeneities
if the information is provided in argument <code>b1File</code> and use of a second
of a second recovery delay TR2 in case of Dual-Exitation FLASH measurements
(Helms 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateQI(mpmESTATICSModel, b1File = NULL, TR2 = 0, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateQI_+3A_mpmestaticsmodel">mpmESTATICSModel</code></td>
<td>

<p>Object of class 'ESTATICSModel' as returned from function <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>.
</p>
</td></tr>
<tr><td><code id="calculateQI_+3A_b1file">b1File</code></td>
<td>

<p>(optional) Name of a file containing a B1-field inhomogeneity map (.nii)
</p>
</td></tr>
<tr><td><code id="calculateQI_+3A_tr2">TR2</code></td>
<td>

<p>second recovery delay TR2 in case of Dual-Exitation FLASH measurements.
</p>
</td></tr>
<tr><td><code id="calculateQI_+3A_verbose">verbose</code></td>
<td>

<p>logical: Monitor process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr><td><code>b1Map</code></td>
<td>
<p> b1Map </p>
</td></tr>
<tr><td><code>R1</code></td>
<td>
<p> Estimated map of R1</p>
</td></tr>
<tr><td><code>R2star</code></td>
<td>
<p> Estimated map of R2star</p>
</td></tr>
<tr><td><code>PD</code></td>
<td>
<p>Estimated map of  PD</p>
</td></tr>
<tr><td><code>MT</code></td>
<td>
<p>Estimated map of  delta (if MT-series was used)</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Type of ESTATICS model used</p>
</td></tr>
<tr><td><code>t1Files</code></td>
<td>
<p>filenames T1</p>
</td></tr>
<tr><td><code>mtFiles</code></td>
<td>
<p>filenames MT</p>
</td></tr>
<tr><td><code>pdFiles</code></td>
<td>
<p>filenames PD</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>brainmask</p>
</td></tr>
</table>
<p>and class-attribute 'qMaps'
.</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Helms, G.; Dathe, H.; Kallenberg, K. &amp; Dechent, P.
High-Resolution Maps of Magnetization Transfer with Inherent Correction
for RF Inhomogeneity and T1 Relaxation Obtained from 3D FLASH MRI Magn.
Res. Med., 2008, 60, 1396-1407
</p>
<p>Weiskopf, N.; Suckling, J.; Williams, G.; Correia, M. M.; Inkster, B.;
Tait, R.; Ooi, C.; Bullmore, E. T. &amp; Lutti, A.
Quantitative multi-parameter mapping of R1, PD(*), MT, and R2(*) at 3T:
a multi-center validation. Front Neurosci,
Wellcome Trust Centre for Neuroimaging, UCL Institute of Neurology,
University College London, UK., 2013, 7, 95
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMPMData">readMPMData</a></code>, <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>,
<code><a href="#topic+smoothESTATICS">smoothESTATICS</a></code>, <code><a href="#topic+writeESTATICS">writeESTATICS</a></code>,
<code><a href="aws.html#topic+awsLocalSigma">awsLocalSigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir &lt;- system.file("extdata",package="qMRI")
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask0.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
# limit calculations to voxel in the central coronal slice
# to reduce execution time of the example
#
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
#
#  resulting ESTATICS parameter maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
oldpar &lt;- par(mfrow=c(2,2),mar=c(3,3,3,1),mgp=c(2,1,0))
on.exit(par(oldpar))
pnames &lt;- c("T1","MT","PD","R2star")
modelCoeff &lt;- extract(modelMPM,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(pnames[i])
   }
}
#
#  Compute quantitative maps (R1, R2star, PD, MT)
#
qMRIMaps &lt;- calculateQI(modelMPM,
                        b1File = B1File,
                        TR2 = 3.4)
#
#  resulting quantitative maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
par(mfrow=c(2,2),mar=c(3,3,3,1),mgp=c(2,1,0))
nmaps &lt;- c("R1","R2star","PD","MT")
qmap &lt;- extract(qMRIMaps,nmaps)
for (i in 1:4){
   rimage(qmap[[i]][,11,],main=nmaps[i])
}
par(oldpar)
}
</code></pre>

<hr>
<h2 id='colMT'>MT map color scheme</h2><span id='topic+colMT'></span>

<h3>Description</h3>

<p>Color map implementing the color scheme for MT maps.
This is the plasma scale from Matplotlib (pyplot)
generated by function plasma from package <span class="pkg">viridisLite</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMT</code></pre>


<h3>Format</h3>

<p>A vector with 256 RGB color values.</p>

<hr>
<h2 id='estimateESTATICS'>
Estimate parameters in the ESTATICS model.
</h2><span id='topic+estimateESTATICS'></span>

<h3>Description</h3>

<p>Evaluation of the
ESTATICS model (Weisskopf (2013) using nonlinear least squares regression
and a quasi-likelihood approach assuming a noncentral chi- or a Rician distribuion
for the data. The latter  should be preferred in case of low SNR (high resolution)
data to avoid biased parameter estimates. Quasi-likelihood estimation requires
a specification of the scale parameter sigma of the data distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateESTATICS(mpmdata, TEScale = 100, dataScale = 1000, method = c("NLR", "QL"),
                 sigma = NULL, L = 1, maxR2star = 50,
                 varest = c("RSS", "data"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateESTATICS_+3A_mpmdata">mpmdata</code></td>
<td>

<p>Object of class MPMData as created by <code><a href="#topic+readMPMData">readMPMData</a></code>.
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_tescale">TEScale</code></td>
<td>

<p>scale factor for TE (used for improved numerical stability)
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_datascale">dataScale</code></td>
<td>

<p>scale factor for image intensities (used for improved numerical stability)
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_method">method</code></td>
<td>

<p>either &quot;NLR&quot; or &quot;QL&quot;. Specifies non-linear regression or quasi-likelihood.
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_sigma">sigma</code></td>
<td>

<p>scale parameter sigma of signal distribution (either a scalar or a 3D array).
(only needed in case of <code>method="QL"</code>.)
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_l">L</code></td>
<td>

<p>effective number of receiver coils (2*L is degrees of freedom of the signal distribution).
L=1 for Rician distribution. (only needed in case of <code>method="QL"</code>.)
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_maxr2star">maxR2star</code></td>
<td>

<p>maximum value allowed for the R2star parameter in the ESTATICS model.
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_varest">varest</code></td>
<td>

<p>For parameter covariance estimation use either residual sum of squares (RSS)
or estimate variances for T1, MT (is available) and PD from higest intensity
images using function <code>awsLocalSigma</code>from package <span class="pkg">aws</span>.
</p>
</td></tr>
<tr><td><code id="estimateESTATICS_+3A_verbose">verbose</code></td>
<td>

<p>logical: Monitor process.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>modelCoeff</code></td>
<td>
<p>Estimated parameter maps</p>
</td></tr>
<tr><td><code>invCov</code></td>
<td>
<p> map of inverse covariance matrices</p>
</td></tr>
<tr><td><code>rsigma</code></td>
<td>
<p>map of residual standard deviations</p>
</td></tr>
<tr><td><code>isConv</code></td>
<td>
<p> convergence indicator map</p>
</td></tr>
<tr><td><code>isThresh</code></td>
<td>
<p> logical map indicating where <code>R2star==maxR2star</code>. </p>
</td></tr>
<tr><td><code>sdim</code></td>
<td>
<p> image dimension</p>
</td></tr>
<tr><td><code>nFiles</code></td>
<td>
<p> number of images</p>
</td></tr>
<tr><td><code>t1Files</code></td>
<td>
<p> vector of T1 filenames</p>
</td></tr>
<tr><td><code>pdFiles</code></td>
<td>
<p> vector of PD filenames</p>
</td></tr>
<tr><td><code>mtFiles</code></td>
<td>
<p> vector of MT filenames</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> model used (depends on specification of MT files)</p>
</td></tr>
<tr><td><code>maskFile</code></td>
<td>
<p> filename of brain mask</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p> brain mask</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p> sigma</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> L</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p> TR values</p>
</td></tr>
<tr><td><code>TE</code></td>
<td>
<p> TE values</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p> Flip angles (FA)</p>
</td></tr>
<tr><td><code>TEScale</code></td>
<td>
<p> TEScale</p>
</td></tr>
<tr><td><code>dataScale</code></td>
<td>
<p>dataScale</p>
</td></tr>
</table>
<p>and class-attribute 'ESTATICSModel'
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Weiskopf, N.; Suckling, J.; Williams, G.; Correia, M. M.; Inkster, B.; Tait, R.;
Ooi, C.; Bullmore, E. T. &amp; Lutti, A. Quantitative multi-parameter mapping of R1,
PD(*), MT, and R2(*) at 3T: a multi-center validation. Front Neurosci,
Wellcome Trust Centre for Neuroimaging, UCL Institute of Neurology,
University College London, UK., 2013, 7, 95
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMPMData">readMPMData</a></code>, <code><a href="#topic+calculateQI">calculateQI</a></code>,
<code><a href="#topic+smoothESTATICS">smoothESTATICS</a></code>, <code><a href="#topic+writeESTATICS">writeESTATICS</a></code>,
<code><a href="aws.html#topic+awsLocalSigma">awsLocalSigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dataDir &lt;- system.file("extdata",package="qMRI")
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask0.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
# Alternatively using Quasi-Likelihood
sigma &lt;- 50
modelMPMQL &lt;- estimateESTATICS(mpm, method = "QL",
                  sigma = array(sigma,mpm$sdim), L = 1)

</code></pre>

<hr>
<h2 id='estimateIR'>
Estimate IRMRI parameters
</h2><span id='topic+estimateIR'></span>

<h3>Description</h3>

<p>Parameter estimation (intensity, relaxation rate, proportion of fluid) in Inversion Recovery MRI data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateIR(IRdataobj, TEScale = 100, dataScale = 1000, method = c("NLR", "QL"),
           varest = c("RSS","data"), fixed = TRUE, smoothMethod=c("PAWS","Depth"),
           kstar = 24, alpha = .025, bysegment = TRUE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateIR_+3A_irdataobj">IRdataobj</code></td>
<td>

<p>4D array of IRMRI signals. First dimension corresponds to Inversion times (InvTime).
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_tescale">TEScale</code></td>
<td>

<p>Internal scale factor for Echo Times. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_datascale">dataScale</code></td>
<td>

<p>Internal scale factor for MR signals. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_method">method</code></td>
<td>

<p>Either <code>"NLS"</code> for nonlinear least squares (ignores Rician bias) or <code>"QL"</code> for Quasi-Likelihood. The second option is more accurate but requires additional information and is computationally more expensive.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_varest">varest</code></td>
<td>

<p>Method to, in case of <code>method="QR"</code>, estimate <code>sigma</code>if not provided. Either from residual sums of squares (<code>"RSS"</code>) or MR signals (<code>"data"</code>) using function <code>varest</code> from package <code>aws</code>. Only to be used in case that no image registration was needed as preprocessing.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_fixed">fixed</code></td>
<td>

<p>Should adaptive smoothing performed for Sx and Rx maps and fx maps reestimated afterwards ?
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_smoothmethod">smoothMethod</code></td>
<td>

<p>Either &quot;PAWS&quot; or &quot;Depth&quot;. the second option is not yet implemented.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_kstar">kstar</code></td>
<td>

<p>number of steps used in PAWS
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_alpha">alpha</code></td>
<td>

<p>significance level for decisions in aws algorithm (suggestion: between 1e-5 and 0.025)
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_bysegment">bysegment</code></td>
<td>

<p><code>TRUE</code>: restrict smoothing to segments from segmentation, <code>FALSE</code>: restrict smoothing to solid mask.
</p>
</td></tr>
<tr><td><code id="estimateIR_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Provide some runtime diagnostics.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the complete pipeline of IRMRI anlysis.
</p>


<h3>Value</h3>

<p>List of class <code>"IRmixed"</code> with components
</p>
<table>
<tr><td><code>IRdata</code></td>
<td>
<p>4D array containing the IRMRI data, first dimension refers to inversion times</p>
</td></tr>
<tr><td><code>InvTimes</code></td>
<td>
<p>vector of inversion times</p>
</td></tr>
<tr><td><code>segm</code></td>
<td>
<p>segmentation codes, 1 for CSF, 2 for GM, 3 for WM, 0 for out of brain</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>noise standard deviation, if not specified estimated fron CSF areas in image with largest inversion time</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>effective number of coils</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>Array of fluid proportions</p>
</td></tr>
<tr><td><code>Sx</code></td>
<td>
<p>Array of maximal signals</p>
</td></tr>
<tr><td><code>Rx</code></td>
<td>
<p>Array of relaxation rates</p>
</td></tr>
<tr><td><code>Sf</code></td>
<td>
<p>Global estimate of maximal fluid signal</p>
</td></tr>
<tr><td><code>Rf</code></td>
<td>
<p>Global estimate of fluid relaxation rate</p>
</td></tr>
<tr><td><code>ICovx</code></td>
<td>
<p>Covariance matrix of estimates <code>fx</code>, <code>Sx</code> and <code>Rx</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Array of provided or estimated noise standard deviations </p>
</td></tr>
<tr><td><code>Convx</code></td>
<td>
<p>Array of convergence indicators</p>
</td></tr>
<tr><td><code>rsdx</code></td>
<td>
<p>Residual standard deviations</p>
</td></tr>
</table>
<p>The arrays contain entries for all voxel with <code>segments%in%1:3</code>.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIRsolidfixed">estimateIRsolidfixed</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## runs about 30 seconds
dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
## estimate all
sIRmix &lt;- estimateIR(IRdata, method="QL")


</code></pre>

<hr>
<h2 id='estimateIRfluid'>Estimate parameters in Inversion Recovery MRI experiments model for CSF voxel 
</h2><span id='topic+estimateIRfluid'></span>

<h3>Description</h3>

<p>The Inversion Recovery MRI signal in voxel containing only CSF follows is modeled as  $S_InvTime = par[1] * abs( 1 - 2 * exp(-InvTime*par[2]) )$ dependings on two parameters. These parameters are assumed to be tissue (and scanner) dependent. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateIRfluid(IRdataobj, TEScale = 100, dataScale = 1000,
method = c("NLR", "QL"), varest = c("RSS", "data"),
verbose = TRUE, lower = c(0, 0), upper = c(2, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateIRfluid_+3A_irdataobj">IRdataobj</code></td>
<td>
<p> Object of class <code>"IRdata"</code> as generated by function <code><a href="#topic+readIRData">readIRData</a></code>.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_tescale">TEScale</code></td>
<td>

<p>Internal scale factor for Echo Times. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_datascale">dataScale</code></td>
<td>

<p>Internal scale factor for MR signals. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_method">method</code></td>
<td>

<p>Either <code>"NLS"</code> for nonlinear least squares (ignores Rician bias) or <code>"QL"</code> for Quasi-Likelihood. The second option is more accurate but requires additional information and is computationally more expensive.  
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_varest">varest</code></td>
<td>

<p>Method to, in case of <code>method="QR"</code>, estimate <code>sigma</code>if not provided. Either from residual sums of squares (<code>"RSS"</code>) or MR signals (<code>"data"</code>) using function <code>varest</code> from package <code>aws</code>. Only to be used in case that no image registration was needed as preprocessing.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Provide some runtime diagnostics.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_lower">lower</code></td>
<td>

<p>Lower bounds for parameter values.
</p>
</td></tr>
<tr><td><code id="estimateIRfluid_+3A_upper">upper</code></td>
<td>

<p>Upper bounds for parameter values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Inversion Recovery MRI signal in voxel containing only CSF follows is modeled as  $S_InvTime = par[1] * abs( 1 - 2 * exp(-InvTime*par[2]) )$ dependings on two parameters. These parameters are assumed to be tissue (and scanner) dependent.
</p>


<h3>Value</h3>

<p>List of class <code>IRfluid</code> with components
</p>
<table>
<tr><td><code>IRdata</code></td>
<td>
<p>4D array containing the IRMRI data, first dimension refers to inversion times</p>
</td></tr>
<tr><td><code>InvTimes</code></td>
<td>
<p>vector of inversion times</p>
</td></tr>
<tr><td><code>segm</code></td>
<td>
<p>segmentation codes, 1 for CSF, 2 for GM, 3 for WM, 0 for out of brain</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>noise standard deviation, if not specified estimated fron CSF areas in image with largest inversion time</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>effective number of coils</p>
</td></tr>
<tr><td><code>Sf</code></td>
<td>
<p>Global estimate of maximal fluid signal</p>
</td></tr>
<tr><td><code>Rf</code></td>
<td>
<p>Global estimate of fluid relaxation rate</p>
</td></tr>
<tr><td><code>Sx</code></td>
<td>
<p>Array of maximal signals</p>
</td></tr>
<tr><td><code>Rx</code></td>
<td>
<p>Array of relaxation rates</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Array of provided or estimated noise standard deviations </p>
</td></tr>
<tr><td><code>Convx</code></td>
<td>
<p>Array of convergence indicators</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>"NLS"</code> for nonlinear regression or <code>"QL"</code> for quasi likelihood.</p>
</td></tr>
<tr><td><code>varest</code></td>
<td>
<p>Method used for variance estimation</p>
</td></tr>
</table>
<p>The arrays only contain entries for fluid voxel.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIR">estimateIR</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIRsolidfixed">estimateIRsolidfixed</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
## estimate fluid
setCores(2) # parallel mode using 2 threads
IRfluid &lt;- estimateIRfluid(IRdata, method="NLR", verbose=FALSE)
cat("Estimated parameters Sf:", IRfluid$Sf, 
                        " Rf:", IRfluid$Rf, "\n")
</code></pre>

<hr>
<h2 id='estimateIRsolid'>
Estimate parameters in Inversion Recovery MRI experiments mixture model for non-fluid voxel 
</h2><span id='topic+estimateIRsolid'></span>

<h3>Description</h3>

<p>The Inversion Recovery MRI signal in non-fluid voxel  follows is modeled as a mixture of a fluid and a solid compartment. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateIRsolid(IRfluidobj, TEScale = 100, dataScale = 1000,
verbose = TRUE, lower = c(0, 0, 0), upper = c(0.95, 2, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateIRsolid_+3A_irfluidobj">IRfluidobj</code></td>
<td>
<p>Object of class <code>"IRfluid"</code> as generated by function <code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>.
</p>
</td></tr>
<tr><td><code id="estimateIRsolid_+3A_tescale">TEScale</code></td>
<td>

<p>Internal scale factor for Echo Times. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRsolid_+3A_datascale">dataScale</code></td>
<td>

<p>Internal scale factor for MR signals. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRsolid_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Provide some runtime diagnostics.
</p>
</td></tr>
<tr><td><code id="estimateIRsolid_+3A_lower">lower</code></td>
<td>

<p>Lower bounds for parameter values.
</p>
</td></tr>
<tr><td><code id="estimateIRsolid_+3A_upper">upper</code></td>
<td>

<p>Upper bounds for parameter values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Inversion Recovery MRI signal in non-fluid voxel  follows is modeled as a mixture of a fluid and a solid compartment.  The function calculates estimates of the maximum signal and recovery rate for the solid compartment and a mixture coefficient (proportion of fluid) for all voxel with <code>segment%in%2:3</code>using results from function <code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>.
</p>


<h3>Value</h3>

<p>List of class <code>IRmixed</code> with components
</p>
<table>
<tr><td><code>IRdata</code></td>
<td>
<p>4D array containing the IRMRI data, first dimension refers to inversion times</p>
</td></tr>
<tr><td><code>InvTimes</code></td>
<td>
<p>vector of inversion times</p>
</td></tr>
<tr><td><code>segm</code></td>
<td>
<p>segmentation codes, 1 for CSF, 2 for GM, 3 for WM, 0 for out of brain</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>noise standard deviation, if not specified estimated fron CSF areas in image with largest inversion time</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>effective number of coils</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>Array of fluid proportions</p>
</td></tr>
<tr><td><code>Sx</code></td>
<td>
<p>Array of maximal signals</p>
</td></tr>
<tr><td><code>Rx</code></td>
<td>
<p>Array of relaxation rates</p>
</td></tr>
<tr><td><code>Sf</code></td>
<td>
<p>Global estimate of maximal fluid signal</p>
</td></tr>
<tr><td><code>Rf</code></td>
<td>
<p>Global estimate of fluid relaxation rate</p>
</td></tr>
<tr><td><code>ICovx</code></td>
<td>
<p>Covariance matrix of estimates <code>fx</code>, <code>Sx</code> and <code>Rx</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Array of provided or estimated noise standard deviations </p>
</td></tr>
<tr><td><code>Convx</code></td>
<td>
<p>Array of convergence indicators</p>
</td></tr>
<tr><td><code>rsdx</code></td>
<td>
<p>Residual standard deviations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>"NLS"</code> for nonlinear regression or <code>"QL"</code> for quasi likelihood.</p>
</td></tr>
<tr><td><code>varest</code></td>
<td>
<p>Method used for variance estimation</p>
</td></tr>
</table>
<p>The arrays contain entries for all voxel with <code>segments%in%1:3</code>.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIR">estimateIR</a></code>, <code><a href="#topic+estimateIRsolidfixed">estimateIRsolidfixed</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## runs about 7 seconds
dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
## estimate fluid
setCores(2) # parallel mode using 2 threads
IRfluid &lt;- estimateIRfluid(IRdata, method="NLR", verbose=FALSE)
cat("Estimated parameters Sf:", IRfluid$Sf, 
                        " Rf:", IRfluid$Rf, "\n")
## estimate solid
IRmix &lt;- estimateIRsolid(IRfluid, verbose=FALSE)

</code></pre>

<hr>
<h2 id='estimateIRsolidfixed'>
Estimate mixture parameter in Inversion Recovery MRI experiments mixture model for non-fluid voxel
</h2><span id='topic+estimateIRsolidfixed'></span>

<h3>Description</h3>

<p>Reestimate proportion of fluid with Sx and Rx fixed after smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateIRsolidfixed(IRmixedobj, TEScale = 100, dataScale = 1000,
verbose = TRUE, lower = c(0), upper = c(0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateIRsolidfixed_+3A_irmixedobj">IRmixedobj</code></td>
<td>
<p> Object of class <code>"IRmixed"</code> as generated by function <code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code> or <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>.
</p>
</td></tr>
<tr><td><code id="estimateIRsolidfixed_+3A_tescale">TEScale</code></td>
<td>

<p>Internal scale factor for Echo Times. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRsolidfixed_+3A_datascale">dataScale</code></td>
<td>

<p>Internal scale factor for MR signals. This influences parameter scales in numerical calculations.
</p>
</td></tr>
<tr><td><code id="estimateIRsolidfixed_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Provide some runtime diagnostics.
</p>
</td></tr>
<tr><td><code id="estimateIRsolidfixed_+3A_lower">lower</code></td>
<td>

<p>lower bound for fx (fluid proportion)
</p>
</td></tr>
<tr><td><code id="estimateIRsolidfixed_+3A_upper">upper</code></td>
<td>

<p>upper bound for fx (fluid proportion)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of class <code>"IRmixed"</code> components
</p>
<table>
<tr><td><code>IRdata</code></td>
<td>
<p>4D array containing the IRMRI data, first dimension refers to inversion times</p>
</td></tr>
<tr><td><code>InvTimes</code></td>
<td>
<p>vector of inversion times</p>
</td></tr>
<tr><td><code>segm</code></td>
<td>
<p>segmentation codes, 1 for CSF, 2 for GM, 3 for WM, 0 for out of brain</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>noise standard deviation, if not specified estimated fron CSF areas in image with largest inversion time</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>effective number of coils</p>
</td></tr>
<tr><td><code>fx</code></td>
<td>
<p>Array of fluid proportions</p>
</td></tr>
<tr><td><code>Sx</code></td>
<td>
<p>Array of maximal signals</p>
</td></tr>
<tr><td><code>Rx</code></td>
<td>
<p>Array of relaxation rates</p>
</td></tr>
<tr><td><code>Sf</code></td>
<td>
<p>Global estimate of maximal fluid signal</p>
</td></tr>
<tr><td><code>Rf</code></td>
<td>
<p>Global estimate of fluid relaxation rate</p>
</td></tr>
<tr><td><code>ICovx</code></td>
<td>
<p>Covariance matrix of estimates <code>fx</code>, <code>Sx</code> and <code>Rx</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Array of provided or estimated noise standard deviations </p>
</td></tr>
<tr><td><code>Convx</code></td>
<td>
<p>Array of convergence indicators</p>
</td></tr>
<tr><td><code>rsdx</code></td>
<td>
<p>Residual standard deviations</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>"NLS"</code> for nonlinear regression or <code>"QL"</code> for quasi likelihood.</p>
</td></tr>
<tr><td><code>varest</code></td>
<td>
<p>Method used for variance estimation</p>
</td></tr>
</table>
<p>The arrays contain entries for all voxel with <code>segments%in%1:3</code>.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIR">estimateIR</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>, <code><a href="#topic+readIRData">readIRData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## runs about 11 seconds 
dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
## estimate fluid
setCores(2) # parallel mode using 2 threads
IRfluid &lt;- estimateIRfluid(IRdata, method="NLR", verbose=FALSE)
cat("Estimated parameters Sf:", IRfluid$Sf, 
                        " Rf:", IRfluid$Rf, "\n")
## estimate solid
IRmix &lt;- estimateIRsolid(IRfluid, verbose=FALSE)
## smoothing 
sIRmix &lt;- smoothIRSolid(IRmix, alpha=1e-4, partial=FALSE, verbose=FALSE)
## reestimate
sIRmix &lt;- estimateIRsolidfixed(sIRmix, verbose=FALSE)

</code></pre>

<hr>
<h2 id='extract-methods'>
Methods to extract information from objects of class <code>"MPMData"</code>,
<code>"ESTATICSModel"</code>, <code>"sESTATICSModel"</code>, <code>"qMaps"</code>,
<code>"IRdata"</code>, <code>"IRfluid"</code> and <code>"IRmixed"</code>.
</h2><span id='topic+extract.ANY-method'></span><span id='topic+extract.MPMData'></span><span id='topic+extract.ESTATICSModel'></span><span id='topic+extract.sESTATICSModel'></span><span id='topic+extract.qMaps'></span><span id='topic+extract.IRdata'></span><span id='topic+extract.IRfluid'></span><span id='topic+extract.IRmixed'></span><span id='topic++5B.ANY-method'></span><span id='topic++5B.MPMData'></span><span id='topic++5B.ESTATICSModel'></span><span id='topic++5B.sESTATICSModel'></span><span id='topic++5B.qMaps'></span><span id='topic++5B.IRdata'></span><span id='topic++5B.IRfluid'></span><span id='topic++5B.IRmixed'></span>

<h3>Description</h3>

<p>The extract-methods extract and/or compute specified statistics from object of class
<code>"MPMData"</code>, <code>"ESTATICSModel"</code>, <code>"sESTATICSModel"</code>, <code>"qMaps"</code>,
<code>"IRdata"</code>, <code>"IRfluid"</code> and <code>"IRmixed"</code>.
The [-methods can be used to reduce objects of class
<code>"MPMData"</code>, <code>"ESTATICSModel"</code>, <code>"sESTATICSModel"</code>, <code>"qMaps"</code>,
<code>"IRdata"</code>, <code>"IRfluid"</code> and <code>"IRmixed"</code> such that they contain a subcube of data and results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MPMData'
extract(x, what, ...)
## S3 method for class 'ESTATICSModel'
extract(x, what, ...)
## S3 method for class 'sESTATICSModel'
extract(x, what, ...)
## S3 method for class 'qMaps'
extract(x, what, ...)
## S3 method for class 'IRdata'
extract(x, what, ...)
## S3 method for class 'IRfluid'
extract(x, what, ...)
## S3 method for class 'IRmixed'
extract(x, what, ...)
## S3 method for class 'MPMData'
x[i, j, k, ...]
## S3 method for class 'ESTATICSModel'
x[i, j, k, ...]
## S3 method for class 'sESTATICSModel'
x[i, j, k, ...]
## S3 method for class 'qMaps'
x[i, j, k, ...]
## S3 method for class 'IRdata'
x[i, j, k, tind, ...]
## S3 method for class 'IRfluid'
x[i, j, k, ...]
## S3 method for class 'IRmixed'
x[i, j, k, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract-methods_+3A_x">x</code></td>
<td>

<p>object of class <code>"MPMData"</code>, <code>"ESTATICSModel"</code>, <code>"sESTATICSModel"</code>
or <code>"qMaps"</code>.
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_what">what</code></td>
<td>

<p>Character vector of of names of statistics to extract. See Methods Section for details.
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_i">i</code></td>
<td>

<p>index vector for first spatial dimension
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_j">j</code></td>
<td>

<p>index vector for second spatial dimension
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_k">k</code></td>
<td>

<p>index vector for third spatial dimension
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_tind">tind</code></td>
<td>

<p>index vector for inversion times
</p>
</td></tr>
<tr><td><code id="extract-methods_+3A_...">...</code></td>
<td>

<p>additional parameters, currently unused.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components carrying the names of the options specified in
argument <code>what</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>class(x) = &quot;ANY&quot;</dt><dd><p> Returns a warning for <code>extract</code></p>
</dd>
<dt>class(x) = &quot;MPMData&quot;</dt><dd>
<p>Depending the occurence of names in <code>what</code> a list with the specified components
is returned
</p>

<ul>
<li><p> ddata: mpm data
</p>
</li>
<li><p> sdim: dimension of image cube
</p>
</li>
<li><p> nFiles: number of images / image files
</p>
</li>
<li><p> t1Files: character - filenames of t1Files
</p>
</li>
<li><p> pdFiles: character - filenames of pdFiles
</p>
</li>
<li><p> mtFiles: character - filenames of mtFiles
</p>
</li>
<li><p> model: Number of the ESTATICS model that can be used
</p>
</li>
<li><p> maskFile: character - filenames of   maskFile
</p>
</li>
<li><p> mask: mask
</p>
</li>
<li><p> TR: vector of TR values
</p>
</li>
<li><p> TE: vector of TE values
</p>
</li>
<li><p> FA: vector of FA values
</p>
</li></ul>

</dd>
<dt>class(x) = &quot;ESTATICSModel&quot;</dt><dd>
<p>Depending the occurence of names in <code>what</code> a list with the specified components
is returned
</p>

<ul>
<li><p> modelCoeff: Estimated parameter maps
</p>
</li>
<li><p> invCov: map of inverse covariance matrices
</p>
</li>
<li><p> rsigma: map of residual standard deviations
</p>
</li>
<li><p> isConv: convergence indicator map
</p>
</li>
<li><p> isThresh: logical map indicating where <code>R2star==maxR2star</code>
</p>
</li>
<li><p> sdim: image dimension
</p>
</li>
<li><p> nFiles: number of images
</p>
</li>
<li><p> t1Files: vector of T1 filenames
</p>
</li>
<li><p> pdFiles: vector of PD filenames
</p>
</li>
<li><p> mtFiles: vector of MT filenames
</p>
</li>
<li><p> model: model used (depends on specification of MT files)
</p>
</li>
<li><p> maskFile: filename of brain mask
</p>
</li>
<li><p> mask: brain mask
</p>
</li>
<li><p> sigma: standard deviation sigma
</p>
</li>
<li><p> L: effective number of receiver coils L
</p>
</li>
<li><p> TR: TR values
</p>
</li>
<li><p> TE: TE values
</p>
</li>
<li><p> FA: Flip angles (FA)
</p>
</li>
<li><p> TEScale: TEScale
</p>
</li>
<li><p> dataScale: dataScale
</p>
</li></ul>

</dd>
<dt>class(x) = &quot;sESTATICSModel&quot;</dt><dd>
<p>Depending the occurence of names in <code>what</code> a list with the specified components
is returned
</p>

<ul>
<li><p> modelCoeff: Estimated parameter maps
</p>
</li>
<li><p> invCov: map of inverse covariance matrices
</p>
</li>
<li><p> rsigma: map of residual standard deviations
</p>
</li>
<li><p> isConv: convergence indicator map
</p>
</li>
<li><p> bi: Sum of weights map from AWS/PAWS
</p>
</li>
<li><p> smoothPar: smooting parameters used in AWS/PAWS
</p>
</li>
<li><p> smoothedData: smoothed mpmData
</p>
</li>
<li><p> isThresh: logical map indicating where <code>R2star==maxR2star</code>
</p>
</li>
<li><p> sdim: image dimension
</p>
</li>
<li><p> nFiles: number of images
</p>
</li>
<li><p> t1Files: vector of T1 filenames
</p>
</li>
<li><p> pdFiles: vector of PD filenames
</p>
</li>
<li><p> mtFiles: vector of MT filenames
</p>
</li>
<li><p> model: model used (depends on specification of MT files)
</p>
</li>
<li><p> maskFile: filename of brain mask
</p>
</li>
<li><p> mask: brain mask
</p>
</li>
<li><p> sigma: sigma
</p>
</li>
<li><p> L: effective number of receiver coils L
</p>
</li>
<li><p> TR: TR values
</p>
</li>
<li><p> TE: TE values
</p>
</li>
<li><p> FA: Flip angles (FA)
</p>
</li>
<li><p> TEScale: TEScale
</p>
</li>
<li><p> dataScale: dataScale
</p>
</li></ul>

</dd>
<dt>class(x) = &quot;qMaps&quot;</dt><dd>
<p>Depending the occurence of names in <code>what</code> a list with the specified components
is returned
</p>

<ul>
<li><p> b1Map: b1Map
</p>
</li>
<li><p> R1: Estimated map of R1
</p>
</li>
<li><p> R2star: Estimated map of R2star
</p>
</li>
<li><p> PD: Estimated map of PD
</p>
</li>
<li><p> MT: Estimated map of delta (if MT-series was used)
</p>
</li>
<li><p> model: Type of ESTATICS model used
</p>
</li>
<li><p> t1Files: filenames T1
</p>
</li>
<li><p> mtFiles: filenames MT
</p>
</li>
<li><p> pdFiles: filenames PD
</p>
</li>
<li><p> mask: brainmask
</p>
</li></ul>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>

<hr>
<h2 id='generateIRData'>
generate IR MRI example data
</h2><span id='topic+generateIRData'></span>

<h3>Description</h3>

<p>The function generates  IR MRI example data for specified parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateIRData(segm, pCSF, pGM, pWM, InvTimes, sigma = 40)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateIRData_+3A_segm">segm</code></td>
<td>

<p>array containing segmentation resuts for an 3D MRI template. Contains 1 for CSF,
2 for Gray Matter and 3 for White Matter
</p>
</td></tr>
<tr><td><code id="generateIRData_+3A_pcsf">pCSF</code></td>
<td>

<p>Parameters (S,R) for CSF
</p>
</td></tr>
<tr><td><code id="generateIRData_+3A_pgm">pGM</code></td>
<td>

<p>Parameters (f,R,S) for Gray Matter
</p>
</td></tr>
<tr><td><code id="generateIRData_+3A_pwm">pWM</code></td>
<td>

<p>Parameters (f,R,S) for White Matter
</p>
</td></tr>
<tr><td><code id="generateIRData_+3A_invtimes">InvTimes</code></td>
<td>

<p>Vector of Inversion Times, length nTimes
</p>
</td></tr>
<tr><td><code id="generateIRData_+3A_sigma">sigma</code></td>
<td>

<p>Noise standard variation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with dimension c(nTimes,dim(segm)) 
</p>


<h3>Note</h3>

<p>used in examples for IR functions
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIR">estimateIR</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>, <code><a href="#topic+readIRData">readIRData</a></code>
</p>

<hr>
<h2 id='MREdisplacement'>
Calculate the motion induced signal phase for IR-MRE in biphasic material 
</h2><span id='topic+MREdisplacement'></span>

<h3>Description</h3>

<p>The function takes magnitude images and phase images (as NIfTI files) recordet with inversion <code>IT1=Inf</code> 
and a second inversion time <code>IT2</code> that nulls the fluid signal. Tissue parameters (Relaxation rates)
are extracted from an object of class <code>"IRmixed"</code> calculated from data of a related IRMRI experiment. </p>


<h3>Usage</h3>

<pre><code class='language-R'>MREdisplacement(MagnFiles1, PhaseFiles1, MagnFiles2, PhaseFiles2, TI2 = 2400,
                IRmixobj, method = c("full", "approx"),rescale=FALSE,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MREdisplacement_+3A_magnfiles1">MagnFiles1</code></td>
<td>

<p>Filenames of magnitude images recorded with inversion time <code>IT=Inf</code> .
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_phasefiles1">PhaseFiles1</code></td>
<td>

<p>Filenames of phase images recorded with inversion time <code>IT=Inf</code> .
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_magnfiles2">MagnFiles2</code></td>
<td>

<p>Filenames of magnitude images recorded with inversion time <code>IT=IT2</code>.
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_phasefiles2">PhaseFiles2</code></td>
<td>

<p>Filenames of phase images recorded with inversion time <code>IT=IT2</code> .
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_ti2">TI2</code></td>
<td>

<p>Inversion time used for <code>MagnFiles2</code> and <code>PhaseFiles2</code>. <code>IT2</code> should be selected to
extinguish the signal intendity for fluid.
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_irmixobj">IRmixobj</code></td>
<td>

<p>Object of class <code>"IRmixed"</code> obtained from a related IRMRI experiment.
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_method">method</code></td>
<td>

<p>Either <code>"full"</code> or <code>"approx"</code>
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_rescale">rescale</code></td>
<td>

<p>Logical, do we need to rescale phase images ? 
</p>
</td></tr>
<tr><td><code id="MREdisplacement_+3A_verbose">verbose</code></td>
<td>

<p>Report scale range of phase images
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first 4 arguments need to be vectors of filenames of identical length with files containing compatible 3D NIfTI images. Object <code>IRmixobj</code> needs to contain a components <code>segm</code> and <code>Rx</code> of compatible dimension that need to be registered to the MRE images.
</p>


<h3>Value</h3>

<p>A list of class <code>"IRMREbiphasic"</code> with components
</p>
<table>
<tr><td><code>phisolid</code></td>
<td>
<p>displacement solid</p>
</td></tr>
<tr><td><code>phifluid</code></td>
<td>
<p>displacement fluid</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIRsolidfixed">estimateIRsolidfixed</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>
</p>

<hr>
<h2 id='readIRData'>
Prepare IRMRI dataset
</h2><span id='topic+readIRData'></span>

<h3>Description</h3>

<p>The function reads IRMRI images given as NIfTI files in t1Files, inversion times and segmentation image(s) aund prepares an object class <code>"IRdata"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIRData(t1Files, InvTimes, segmFile, sigma = NULL, L = 1,
           segmCodes = c("GM", "WM", "CSF"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readIRData_+3A_t1files">t1Files</code></td>
<td>

<p>Names of NIfTI files containing the recorded images.
</p>
</td></tr>
<tr><td><code id="readIRData_+3A_invtimes">InvTimes</code></td>
<td>

<p>Corresponding inversion times
</p>
</td></tr>
<tr><td><code id="readIRData_+3A_segmfile">segmFile</code></td>
<td>

<p>Either a NIfTI file containing a segmentation into GM, WM and CSF or
three files containing probability maps for GM, WM and CSF
</p>
</td></tr>
<tr><td><code id="readIRData_+3A_sigma">sigma</code></td>
<td>

<p>Noise standard deviation
</p>
</td></tr>
<tr><td><code id="readIRData_+3A_l">L</code></td>
<td>

<p>Effective number of coils, L=1 assumes a Rician signal distribution
</p>
</td></tr>
<tr><td><code id="readIRData_+3A_segmcodes">segmCodes</code></td>
<td>

<p>sequence of tissue code in segmFile
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"IRdata"</code> with components
</p>
<table>
<tr><td><code>IRdata</code></td>
<td>
<p>4D array containing the IRMRI data, first dimension refers to inversion times</p>
</td></tr>
<tr><td><code>InvTimes</code></td>
<td>
<p>vector of inversion times</p>
</td></tr>
<tr><td><code>segm</code></td>
<td>
<p>segmentation codes, 1 for CSF, 2 for GM, 3 for WM, 0 for out of brain</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>noise standard deviation, if not specified estimated fron CSF areas in image with largest inversion time</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>effective number of coils</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIR">estimateIR</a></code>,<code><a href="#topic+smoothIRSolid">smoothIRSolid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
</code></pre>

<hr>
<h2 id='readMPMData'>
Read experimental Multi-Parameter Mapping (MPM) data.
</h2><span id='topic+readMPMData'></span>

<h3>Description</h3>

<p>The function reads data generated in Multimodal Parameter Mapping (MPM) experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMPMData(t1Files = NULL, pdFiles = NULL, mtFiles = NULL, maskFile = NULL,
            TR = NULL, TE = NULL, FA = NULL, wghts = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMPMData_+3A_t1files">t1Files</code></td>
<td>

<p>Vector of filenames corresponding to T1 weighted images (in Nifti-Format) with varying TE
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_pdfiles">pdFiles</code></td>
<td>

<p>Vector of filenames corresponding to PD weighted images (in Nifti-Format) with varying TE
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_mtfiles">mtFiles</code></td>
<td>

<p>optional Vector of filenames corresponding to MT weighted images
(in Nifti-Format) with varying TE
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_maskfile">maskFile</code></td>
<td>

<p>optional filename for mask (in Nifti-Format)
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_tr">TR</code></td>
<td>

<p>optional numeric TR vector, if omitted information is extracted from .nii files if possible
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_te">TE</code></td>
<td>

<p>optional numeric TE vector, if omitted information is extracted from .nii files if possible
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_fa">FA</code></td>
<td>

<p>optional numeric FA (flip-angle) vector, if omitted information is extracted from .nii files if possible
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_wghts">wghts</code></td>
<td>

<p>optional weights for MPM data volumes. Only needed is volumes have different data variance, e.g.,
in case of averages of multiple acquisitions.
</p>
</td></tr>
<tr><td><code id="readMPMData_+3A_verbose">verbose</code></td>
<td>

<p>logical - provide information on progress
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr><td><code>ddata</code></td>
<td>
<p>mpm data</p>
</td></tr>
<tr><td><code>sdim</code></td>
<td>
<p> dimension of image cube </p>
</td></tr>
<tr><td><code>nFiles</code></td>
<td>
<p> number of images / image files</p>
</td></tr>
<tr><td><code>t1Files</code></td>
<td>
<p>character - filenames of t1Files</p>
</td></tr>
<tr><td><code>pdFiles</code></td>
<td>
<p>character - filenames of  pdFiles</p>
</td></tr>
<tr><td><code>mtFiles</code></td>
<td>
<p>character - filenames of  mtFiles</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> Number of the ESTATICS model that can be used </p>
</td></tr>
<tr><td><code>maskFile</code></td>
<td>
<p>character - filenames of   maskFile</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p> mask</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p> vector of TR values</p>
</td></tr>
<tr><td><code>TE</code></td>
<td>
<p> vector of TE values</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p> vector of FA values</p>
</td></tr>
</table>
<p>and class-attribute 'mpmData'
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Weiskopf, N.; Suckling, J.; Williams, G.; Correia, M. M.; Inkster, B.; Tait, R.;
Ooi, C.; Bullmore, E. T. &amp; Lutti, A. Quantitative multi-parameter mapping of R1,
PD(*), MT, and R2(*) at 3T: a multi-center validation. Front Neurosci,
Wellcome Trust Centre for Neuroimaging, UCL Institute of Neurology,
University College London, UK., 2013, 7, 95
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>, <code><a href="#topic+calculateQI">calculateQI</a></code>,
<code><a href="#topic+smoothESTATICS">smoothESTATICS</a></code>, <code><a href="#topic+writeESTATICS">writeESTATICS</a></code>,
<code><a href="aws.html#topic+awsLocalSigma">awsLocalSigma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir &lt;- system.file("extdata",package="qMRI")
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
</code></pre>

<hr>
<h2 id='smoothESTATICS'>
Adaptive smoothing of ESTATICS parameters and MPM data
</h2><span id='topic+smoothESTATICS'></span>

<h3>Description</h3>

<p>Performs adaptive smoothing of parameter maps in the ESTATICS model and if
<code>mpmData</code> is specified these data. Implements both vectorized variants of the
Adaptive Weights Smoothing (AWS, Polzehl and Spokoiny (2006))
and patchwise AWS (PAWS, Polzehl et al (2018)) algorithms with weighting schemes determined by
the estimated parameter maps and their covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothESTATICS(mpmESTATICSModel, mpmData = NULL, kstar = 16, alpha = 0.025,
               patchsize = 0, mscbw =5, wghts = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothESTATICS_+3A_mpmestaticsmodel">mpmESTATICSModel</code></td>
<td>

<p>Object of class 'ESTATICSModel' as returned from function <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_mpmdata">mpmData</code></td>
<td>

<p>(optional) Object of class MPMData as created by <code><a href="#topic+readMPMData">readMPMData</a></code> from which
the parameter maps were obtained.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_kstar">kstar</code></td>
<td>

<p>Maximum number of steps.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_alpha">alpha</code></td>
<td>

<p>specifies the scale parameter for the adaptation criterion. smaller values are more restrictive.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_patchsize">patchsize</code></td>
<td>

<p>Patchsize in PAWS, 0 corresponds to AWS, alternative values are 1 and 2.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_mscbw">mscbw</code></td>
<td>

<p>bandwidth for 3D median smoother used to stabilize the covariance estimates.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_wghts">wghts</code></td>
<td>

<p>(optional) voxel size if measurments are not isotropic.
</p>
</td></tr>
<tr><td><code id="smoothESTATICS_+3A_verbose">verbose</code></td>
<td>

<p>logical - provide information on progress
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>modelCoeff</code></td>
<td>
<p>Estimated parameter maps</p>
</td></tr>
<tr><td><code>invCov</code></td>
<td>
<p> map of inverse covariance matrices</p>
</td></tr>
<tr><td><code>isConv</code></td>
<td>
<p> convergence indicator map</p>
</td></tr>
<tr><td><code>bi</code></td>
<td>
<p> Sum of weights map from AWS/PAWS</p>
</td></tr>
<tr><td><code>smoothPar</code></td>
<td>
<p> smooting parameters used in AWS/PAWS</p>
</td></tr>
<tr><td><code>smoothedData</code></td>
<td>
<p> smoothed mpmData</p>
</td></tr>
<tr><td><code>sdim</code></td>
<td>
<p> image dimension</p>
</td></tr>
<tr><td><code>nFiles</code></td>
<td>
<p> number of images</p>
</td></tr>
<tr><td><code>t1Files</code></td>
<td>
<p> vector of T1 filenames</p>
</td></tr>
<tr><td><code>pdFiles</code></td>
<td>
<p> vector of PD filenames</p>
</td></tr>
<tr><td><code>mtFiles</code></td>
<td>
<p> vector of MT filenames</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> model used (depends on specification of MT files)</p>
</td></tr>
<tr><td><code>maskFile</code></td>
<td>
<p> filename of brain mask</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p> brain mask</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p> sigma</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p> L</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p> TR values</p>
</td></tr>
<tr><td><code>TE</code></td>
<td>
<p> TE values</p>
</td></tr>
<tr><td><code>FA</code></td>
<td>
<p> Flip angles (FA)</p>
</td></tr>
<tr><td><code>TEScale</code></td>
<td>
<p> TEScale</p>
</td></tr>
<tr><td><code>dataScale</code></td>
<td>
<p>dataScale</p>
</td></tr>
</table>
<p>and class-attribute 'sESTATICSModel'
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl, V. Spokoiny,  Propagation-separation approach for local likelihood estimation,  Probab. Theory Related Fields  135 (3),  (2006)  , pp. 335&ndash;362.
</p>
<p>J. Polzehl, K. Papafitsorus, K. Tabelow (2018). Patch-wise adaptive weights smoothing. WIAS-Preprint 2520.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMPMData">readMPMData</a></code>, <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dataDir &lt;- system.file("extdata",package="qMRI")
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
#
#  smooth maps of ESTATICS Parameters
#
setCores(2)
modelMPMsp1 &lt;- smoothESTATICS(modelMPM,
                              kstar = 16,
                              alpha = 0.004,
                              patchsize=1,
                              verbose = TRUE)
#
#  resulting ESTATICS parameter maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
oldpar &lt;- par(mfrow=c(2,4),mar=c(3,3,3,1),mgp=c(2,1,0))
on.exit(par(oldpar))
pnames &lt;- c("T1","MT","PD","R2star")
modelCoeff &lt;- extract(modelMPM,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(pnames[i])
   }
modelCoeff &lt;- extract(modelMPMsp1,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(paste("smoothed",pnames[i]))
   }
}
par(oldpar)

</code></pre>

<hr>
<h2 id='smoothIRSolid'>
Smooth object generated by function <code>estimateIRsolid</code>
</h2><span id='topic+smoothIRSolid'></span>

<h3>Description</h3>

<p>Adaptive smoothing of Rx and Sx maps over WM and GM areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothIRSolid(IRmixedobj, kstar = 24, patchsize = 1, alpha = 0.025,
                   mscbw = 5, bysegment=TRUE, partial=TRUE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothIRSolid_+3A_irmixedobj">IRmixedobj</code></td>
<td>

<p>object of class <code>IRmixed</code> generated by function <code>estimateIRsolid</code>
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_kstar">kstar</code></td>
<td>

<p>number of steps for AWS algorithm
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_patchsize">patchsize</code></td>
<td>

<p>patchsize in paws
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_alpha">alpha</code></td>
<td>

<p>significance level for decisions in aws algorithm (suggestion: between 1e-5 and 0.025)
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_mscbw">mscbw</code></td>
<td>

<p>bandwidth for 3D median smoother used to stabilize the covariance estimates.
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_bysegment">bysegment</code></td>
<td>

<p><code>TRUE</code>: restrict smoothing to segments from segmentation, <code>FALSE</code>: restrict smoothing to solid mask.
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_partial">partial</code></td>
<td>

<p><code>TRUE</code>: ignore information concerning parameter <code>fx</code> when smoothing.  
</p>
</td></tr>
<tr><td><code id="smoothIRSolid_+3A_verbose">verbose</code></td>
<td>

<p>logical: Monitor process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses a vectorized version of the AWS algorithm that emloys inverse covariance estimates of the estimated parameters. Local smoothing is done for Rx and Sx maps in ergs which can be assumed to be locally smooth within tissue. No smoothing for fx maps since they may vary.
</p>


<h3>Value</h3>

<p>an object of class <code>"IRmixed"</code>, but with components Sx and Rx replaced. The object carries an additional component <code>bi</code> containing an array of sum of weights characterizing the amount of smoothing.
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 7, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_7&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateIRfluid">estimateIRfluid</a></code>, <code><a href="#topic+estimateIRsolid">estimateIRsolid</a></code>, <code><a href="#topic+estimateIRsolidfixed">estimateIRsolidfixed</a></code>,<code><a href="#topic+estimateIR">estimateIR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## runs about 10 seconds
dataDir0 &lt;- system.file("extdataIR", package = "qMRI")
dataDir &lt;- tempdir("IRdata")
library(oro.nifti)
library(qMRI)
segm &lt;- readNIfTI(file.path(dataDir0,"Brainweb_segm"))
Sf &lt;- 900
Rf &lt;- 0.000285
Sgm &lt;- 400
Rgm &lt;- 0.00075
fgm &lt;- .15
Swm &lt;- 370
Rwm &lt;- 0.0011
fwm &lt;- .05
InvTimes0 &lt;- c(100, 200, 400, 600, 800, 1200, 1600, 2000, 2500, 3000, 
              3500, 4000, 4500, 5000, 6000, 15000)
nTimes &lt;- length(InvTimes0)
sigma &lt;- 40
## generate IR signal
IRdata &lt;- generateIRData(segm, c(Sf,Rf), c(fgm,Rgm,Sgm), c(fwm,Rwm,Swm), InvTimes0, sigma)
for(i in 1:9) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR0",i)))
for(i in 10:nTimes) writeNIfTI(as.nifti(IRdata[i,,,]), 
                         file.path(dataDir,paste0("IR",i)))
## generate IRdata object
t1Files &lt;- list.files(dataDir,"*.nii.gz",full.names=TRUE)
segmFile &lt;- file.path(dataDir0,"Brainweb_segm")
IRdata &lt;- readIRData(t1Files, InvTimes0, segmFile, sigma=sigma,
                     L=1, segmCodes=c("CSF","GM","WM"))
## estimate fluid
setCores(2) # parallel mode using 2 threads
IRfluid &lt;- estimateIRfluid(IRdata, method="NLR", verbose=FALSE)
cat("Estimated parameters Sf:", IRfluid$Sf, 
                        " Rf:", IRfluid$Rf, "\n")
## estimate solid
IRmix &lt;- estimateIRsolid(IRfluid, verbose=FALSE)
## smoothing 
sIRmix &lt;- smoothIRSolid(IRmix, alpha=1e-4, partial=FALSE, verbose=FALSE)

</code></pre>

<hr>
<h2 id='writeESTATICS'>
Write maps of ESTATICS parameters in standardized form as NIfTI files.
</h2><span id='topic+writeESTATICS'></span>

<h3>Description</h3>

<p><code>R2</code>, <code>ST1</code>, <code>SPD</code> and, if available, <code>SMT</code>-maps are written
as compressed NIfTI files into directory the speecified directory.
If <code>class(mpmESTATICSModel) == "sESTATICSModel"</code> and an smoothed data are stored in
<code>mpmESTATICSModel$smoothedData</code> the smoothed data are stored as ompressed NIfTI files
in <code>dir</code> with filenames assembled using <code>prefix</code> and the names of the data source
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeESTATICS(mpmESTATICSModel, dir = NULL, prefix = "estatics", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeESTATICS_+3A_mpmestaticsmodel">mpmESTATICSModel</code></td>
<td>

<p>Object of class 'ESTATICSModel' or 'sESTATICSModel' as returned from function
<code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code> or <code><a href="#topic+smoothESTATICS">smoothESTATICS</a></code>.</p>
</td></tr>
<tr><td><code id="writeESTATICS_+3A_dir">dir</code></td>
<td>

<p>Directory name (or path) for output.
</p>
</td></tr>
<tr><td><code id="writeESTATICS_+3A_prefix">prefix</code></td>
<td>

<p>Prefix for file names
</p>
</td></tr>
<tr><td><code id="writeESTATICS_+3A_verbose">verbose</code></td>
<td>

<p>logical - provide information on progress
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMPMData">readMPMData</a></code>, <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>,
<code><a href="#topic+smoothESTATICS">smoothESTATICS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir &lt;- system.file("extdata",package="qMRI")
outDir &lt;- tempdir()
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask0.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
#
#  resulting ESTATICS parameter maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
oldpar &lt;- par(mfrow=c(2,2),mar=c(3,3,3,1),mgp=c(2,1,0))
on.exit(par(oldpar))
pnames &lt;- c("T1","MT","PD","R2star")
modelCoeff &lt;- extract(modelMPM,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(pnames[i])
   }
}
#
#  write ESTATICS parameter maps
#
writeESTATICS(modelMPM, dir=outDir, prefix="estatics")
par(oldpar)
</code></pre>

<hr>
<h2 id='writeQI'>
Write estimated maps  in standardized form as NIfTI files.
</h2><span id='topic+writeQI'></span>

<h3>Description</h3>

<p>Quantitative <code>R2</code>, <code>R1</code>, <code>PD</code> and, if available, <code>MT</code>-maps are written
as compressed NIfTI files into directory the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeQI(qi, dir = NULL, prefix="qmap", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeQI_+3A_qi">qi</code></td>
<td>

<p>Object of class 'qMaps' as returned from function
<code><a href="#topic+calculateQI">calculateQI</a></code>
</p>
</td></tr>
<tr><td><code id="writeQI_+3A_dir">dir</code></td>
<td>

<p>Directory name (or path) for output.
</p>
</td></tr>
<tr><td><code id="writeQI_+3A_prefix">prefix</code></td>
<td>

<p>Prefix for file names
</p>
</td></tr>
<tr><td><code id="writeQI_+3A_verbose">verbose</code></td>
<td>

<p>logical - provide information on progress
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a><br />
J\&quot;org Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging:
Modeling and Data Analysis Using R, 2nd Edition, Chapter 6, Springer, Use R! Series.
&lt;doi:10.1007/978-3-031-38949-8_6&gt;.
</p>
<p>J. Polzehl and K. Tabelow (2023), Magnetic Resonance Brain Imaging - 
Modeling and Data Analysis Using R: Code and Data.
&lt;doi:10.20347/WIAS.DATA.6&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMPMData">readMPMData</a></code>, <code><a href="#topic+estimateESTATICS">estimateESTATICS</a></code>,<code><a href="#topic+calculateQI">calculateQI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataDir &lt;- system.file("extdata",package="qMRI")
outDir &lt;- tempdir()
#
#  set file names for T1w, MTw and PDw images
#
t1Names &lt;- paste0("t1w_",1:8,".nii.gz")
mtNames &lt;- paste0("mtw_",1:6,".nii.gz")
pdNames &lt;- paste0("pdw_",1:8,".nii.gz")
t1Files &lt;- file.path(dataDir, t1Names)
mtFiles &lt;- file.path(dataDir, mtNames)
pdFiles &lt;- file.path(dataDir, pdNames)
#
#  file names of mask and B1 field map
#
B1File &lt;- file.path(dataDir, "B1map.nii.gz")
maskFile &lt;- file.path(dataDir, "mask0.nii.gz")
#
#  Acquisition parameters (TE, TR, Flip Angle) for T1w, MTw and PDw images
#
TE &lt;- c(2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8,
        2.3, 4.6, 6.9, 9.2, 11.5, 13.8, 16.1, 18.4)
TR &lt;- rep(25, 22)
FA &lt;- c(rep(21, 8), rep(6, 6), rep(6, 8))
#
#   read MPM example data
#
library(qMRI)
mpm &lt;- readMPMData(t1Files, pdFiles, mtFiles,
                   maskFile, TR = TR, TE = TE,
                   FA = FA, verbose = FALSE)
#
#  Estimate Parameters in the ESTATICS model
#
modelMPM &lt;- estimateESTATICS(mpm, method = "NLR")
#
#  resulting ESTATICS parameter maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
oldpar &lt;- par(mfrow=c(2,2),mar=c(3,3,3,1),mgp=c(2,1,0))
on.exit(par(oldpar))
pnames &lt;- c("T1","MT","PD","R2star")
modelCoeff &lt;- extract(modelMPM,"modelCoeff")
for(i in 1:4){
   rimage(modelCoeff[i,,11,])
   title(pnames[i])
   }
}
#
#  Compute quantitative maps (R1, R2star, PD, MT)
#
qMRIMaps &lt;- calculateQI(modelMPM,
                        b1File = B1File,
                        TR2 = 3.4)
#
#  resulting quantitative maps for central coronal slice
#
if(require(adimpro)){
rimage.options(zquantiles=c(.01,.99), ylab="z")
par(mfrow=c(2,2),mar=c(3,3,3,1),mgp=c(2,1,0))
nmaps &lt;- c("R1","R2star","PD","MT")
qmap &lt;- extract(qMRIMaps,nmaps)
for (i in 1:4) rimage(qmap[[i]][,11,],main=nmaps[i])
}
#
#  write qmaps
#
writeQI(qMRIMaps, dir=outDir, prefix="qmap")
par(oldpar)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
