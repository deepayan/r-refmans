<!DOCTYPE html><html><head><title>Help for package mcunit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcunit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expect_bernoulli'><p>Test Bernoulli distribution using buckets</p></a></li>
<li><a href='#expect_mc_iid_chisq'><p>Test iid samples for correct cdf using chisq test</p></a></li>
<li><a href='#expect_mc_iid_ks'><p>Test iid samples for correct cdf using KS test</p></a></li>
<li><a href='#expect_mc_iid_mean'><p>Test iid samples for correct mean</p></a></li>
<li><a href='#expect_mc_test'><p>Test if p-values are coming from the null using a sequential</p>
approach.</a></li>
<li><a href='#expect_mcmc'><p>Test of MCMC chain</p></a></li>
<li><a href='#expect_mcmc_reversible'><p>Test of MCMC chain assuming reversibility of the chain</p></a></li>
<li><a href='#mcunit-package'><p>mcunit: Unit Tests for MC Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Unit Tests for MC Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Axel Gandy &lt;a.gandy@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Unit testing for Monte Carlo methods, particularly Markov Chain Monte Carlo (MCMC) methods, are implemented as extensions of the 'testthat' package. The MCMC methods check whether the MCMC chain has the correct invariant distribution. They do not check other properties of successful samplers such as whether the chain can reach all points, i.e. whether is recurrent. The tests require the ability to sample from the prior and to run steps of the MCMC chain. The methodology is described in Gandy and Scott (2020) &lt;<a href="https://arxiv.org/abs/2001.06465">arXiv:2001.06465</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bitbucket.org/agandy/mcunit/">https://bitbucket.org/agandy/mcunit/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>testthat (&ge; 2.3), stats, rlang, Rdpack (&ge; 0.7), methods,
simctest (&ge; 2.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-01 13:43:14 UTC; jamesscott</td>
</tr>
<tr>
<td>Author:</td>
<td>Axel Gandy [aut, cre],
  James Scott [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-02 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='expect_bernoulli'>Test Bernoulli distribution using buckets</h2><span id='topic+expect_bernoulli'></span>

<h3>Description</h3>

<p>Test if the success probability of a Bernoulli experiment lies
within a desired 'bucket'. This used the sequential procedure
described in
Gandy et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_bernoulli(object, J, ok, epsilon = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_bernoulli_+3A_object">object</code></td>
<td>
<p>Function that performs one sampling step.  Returns 0 or 1.</p>
</td></tr>
<tr><td><code id="expect_bernoulli_+3A_j">J</code></td>
<td>
<p>Buckets to use. A matrix with two rows, each column
describes an interval bucket. Column names give names for
the bucket(s).</p>
</td></tr>
<tr><td><code id="expect_bernoulli_+3A_ok">ok</code></td>
<td>
<p>Name of bucket(s) that pass the Unit test.</p>
</td></tr>
<tr><td><code id="expect_bernoulli_+3A_epsilon">epsilon</code></td>
<td>
<p>Error bound.</p>
</td></tr>
<tr><td><code id="expect_bernoulli_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed on to 'mctest'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>References</h3>

<p>Gandy A, Hahn G, Ding D (2019).
&ldquo;Implementing Monte Carlo Tests with P-value Buckets.&rdquo;
<em>Scandinavian Journal of Statistics</em>.
doi: <a href="https://doi.org/10.1111/sjos.12434">10.1111/sjos.12434</a>, Accepted for publication, 1703.09305, <a href="https://arxiv.org/abs/1703.09305">https://arxiv.org/abs/1703.09305</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   J &lt;- matrix(nrow=2,c(0,0.945, 0.94,0.96, 0.955,1))
   colnames(J) &lt;- c("low","ok","high")
   gen &lt;- function() as.numeric(runif(1)&lt;0.95)
   expect_bernoulli(gen,J=J,ok="ok")
</code></pre>

<hr>
<h2 id='expect_mc_iid_chisq'>Test iid samples for correct cdf using chisq test</h2><span id='topic+expect_mc_iid_chisq'></span>

<h3>Description</h3>

<p>Test if samples are behaving like an iid sample from a given distribution
via the chisq test and a sequential approach. Only works for
discrete distributions taking finitely many values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mc_iid_chisq(object, prob, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mc_iid_chisq_+3A_object">object</code></td>
<td>
<p>A function taking one argument - that generates n univariate iid samples.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_chisq_+3A_prob">prob</code></td>
<td>
<p>A vector of probabilities for finitely many consecutive integers from 0 onward.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_chisq_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   sampler &lt;- function(n) rbinom(n,prob=0.6,size=5)
   expect_mc_iid_chisq(sampler, dbinom(0:5,prob=0.6,size=5))
   testthat::expect_error(expect_mc_iid_chisq(sampler, dbinom(0:5,prob=0.63,size=5)))

</code></pre>

<hr>
<h2 id='expect_mc_iid_ks'>Test iid samples for correct cdf using KS test</h2><span id='topic+expect_mc_iid_ks'></span>

<h3>Description</h3>

<p>Test if samples are behaving like an iid sample from a given CDF
via the KS test and a sequential approach. Only works for
continuous CDFs. Will report a warning if values are discrete
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mc_iid_ks(object, cdf, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mc_iid_ks_+3A_object">object</code></td>
<td>
<p>A function taking one argument - that generates n univariate iid samples.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_ks_+3A_cdf">cdf</code></td>
<td>
<p>A univariate cumulative distribution function, taking exactly one argument.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_ks_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   sampler &lt;- function(n) rnorm(n)
   expect_mc_iid_ks(sampler, pnorm)
</code></pre>

<hr>
<h2 id='expect_mc_iid_mean'>Test iid samples for correct mean</h2><span id='topic+expect_mc_iid_mean'></span>

<h3>Description</h3>

<p>Test if samples are coming from a specific mean. Not guaranteed to
be exact, as it estimates the standard error from the sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mc_iid_mean(object, mean, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mc_iid_mean_+3A_object">object</code></td>
<td>
<p>A function taking one argument - that generates n univariate iid samples.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_mean_+3A_mean">mean</code></td>
<td>
<p>The expected mean of the samples returned from object.</p>
</td></tr>
<tr><td><code id="expect_mc_iid_mean_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   sampler &lt;- function(n) rbinom(n,prob=0.6,size=5)
   expect_mc_iid_mean(sampler, mean=3)
   testthat::expect_error(expect_mc_iid_mean(sampler, mean=2))

</code></pre>

<hr>
<h2 id='expect_mc_test'>Test if p-values are coming from the null using a sequential
approach.</h2><span id='topic+expect_mc_test'></span>

<h3>Description</h3>

<p>Requires as input a generic test that for a given sample size
provides a vector of p-values. Aims to reject if these are not from
the null. Guarantees a bound on the type I error rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mc_test(object, control = NULL, npval = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mc_test_+3A_object">object</code></td>
<td>
<p>A function taking one argument n  - that generates p-values based on a sample size n.</p>
</td></tr>
<tr><td><code id="expect_mc_test_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="expect_mc_test_+3A_npval">npval</code></td>
<td>
<p>number of p-values returned by the test. A Bonferroni correction is applied if &gt;1. Default: 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvalsampler &lt;- function(n){
      x &lt;- sample.int(11,size=n,replace=TRUE)-1;
     chisq.test(tabulate(x+1,nbins=11),
                p=rep(1/11,11))$p.value
}
expect_mc_test(pvalsampler)

</code></pre>

<hr>
<h2 id='expect_mcmc'>Test of MCMC chain</h2><span id='topic+expect_mcmc'></span>

<h3>Description</h3>

<p>Test of MCMC steps having the correct stationary distribution
without assuming reversibility of the chain. Details of this are in
Gandy and Scott (2020); it uses ideas
described in the appendix of
Gandy and Veraart (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mcmc(object, control = NULL, thinning = NULL, joint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mcmc_+3A_object">object</code></td>
<td>
<p>A list describing the MCMC sampler with the following elements:
</p>

<ul>
<li><p> genprior: A function with no arguments that generates a sample of the prior distribution. No default value.
</p>
</li>
<li><p> gendata: A function that takes as input the parameter value (of the type generated by genprior) and returns the observed data as an arbitrary R object. No default value.
</p>
</li>
<li><p> stepMCMC: A function that takes three arguments:
</p>

<ul>
<li><p> theta: the current position of the chain (of the same type as produced by the prior),
</p>
</li>
<li><p> dat: the observed data (of the same type as produced by gendat)
</p>
</li>
<li><p> thinning: the number of steps the chain should take. 1 corresponds to one step.
</p>
</li></ul>

</li>
<li><p> test: Function that takes either one or two arguments, and returns a vector with components which will be used for checking the MCMC sampler. The first argument is interpreted as a parameter value, and if a second argument exists, it is interpreted as a data value. An example is the identity function: function(x) x. Alternatively, if you have access to the model's likelihood function, you could use: function(x,y) likelihood(x,y).
</p>
</li></ul>
</td></tr>
<tr><td><code id="expect_mcmc_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="expect_mcmc_+3A_thinning">thinning</code></td>
<td>
<p>Amount of thinning for the MCMC chain. 1 corresponds to no thinning. Default: automatically computed to ensure an autocorrelation of at most 0.5 at lag 1.</p>
</td></tr>
<tr><td><code id="expect_mcmc_+3A_joint">joint</code></td>
<td>
<p>If TRUE, then the MCMC uses systematic scan of both data and parameters, rather than just updating parameters with the sampler to be tested. Default: FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>References</h3>

<p>Gandy A, Scott J (2020).
&ldquo;Unit Testing for MCMC and other Monte Carlo Methods.&rdquo;
<a href="https://arxiv.org/abs/2001.06465">https://arxiv.org/abs/2001.06465</a>.<br /><br /> Gandy A, Veraart LAM (2017).
&ldquo;A Bayesian Methodology for Systemic Risk Assessment in Financial Networks.&rdquo;
<em>Management Science</em>, <b>63</b>(12), 4428&ndash;4446.
doi: <a href="https://doi.org/10.1287/mnsc.2016.2546">10.1287/mnsc.2016.2546</a>, <a href="https://doi.org/10.1287/mnsc.2016.2546">https://doi.org/10.1287/mnsc.2016.2546</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+expect_mcmc_reversible">expect_mcmc_reversible</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object &lt;- list(genprior=function() rnorm(1),
               gendata=function(theta) rnorm(5,theta),
               stepMCMC=function(theta,data,thinning){
                  f &lt;- function(x) prod(dnorm(data,x))*dnorm(x)  
                  for (i in 1:thinning){
                     thetanew = rnorm(1,mean=theta,sd=1)
                     if (runif(1)&lt;f(thetanew)/f(theta))
                     theta &lt;- thetanew
                  }
                  theta
               }
               )
expect_mcmc(object)
</code></pre>

<hr>
<h2 id='expect_mcmc_reversible'>Test of MCMC chain assuming reversibility of the chain</h2><span id='topic+expect_mcmc_reversible'></span>

<h3>Description</h3>

<p>Test of MCMC steps having the correct stationary distribution
assuming reversibility of the chain. Uses ideas from
Besag and Clifford (1989) as extended to
possible ties in Gandy and Scott (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_mcmc_reversible(
  object,
  control = NULL,
  thinning = NULL,
  nsteps = 10,
  p = 1,
  tolerance = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_mcmc_reversible_+3A_object">object</code></td>
<td>
<p>A list describing the MCMC sampler with the following elements:
</p>

<ul>
<li><p> genprior: A function with no arguments that generates a sample of the prior distribution. No default value.
</p>
</li>
<li><p> gendata: A function that takes as input the parameter value (of the type generated by genprior) and returns the observed data as an arbitrary R object. No default value.
</p>
</li>
<li><p> stepMCMC: A function that takes three arguments:
</p>

<ul>
<li><p> theta: the current position of the chain (of the same type as produced by the prior),
</p>
</li>
<li><p> dat: the observed data (of the same type as produced by gendat)
</p>
</li>
<li><p> thinning: the number of steps the chain should take. 1 corresponds to one step.
</p>
</li></ul>

</li>
<li><p> test: Function that takes either one or two arguments, and returns a vector with components which will be used for checking the MCMC sampler. The first argument is interpreted as a parameter value, and if a second argument exists, it is interpreted as a data value. An example is the identity function: function(x) x. Alternatively, if you have access to the model's likelihood function, you could use: function(x,y) likelihood(x,y).
</p>
</li></ul>
</td></tr>
<tr><td><code id="expect_mcmc_reversible_+3A_control">control</code></td>
<td>
<p>a list controlling the algorithm
</p>

<ul>
<li><p> n number of samples to be taken in the first step. Default: 1e3
</p>
</li>
<li><p> maxseqsteps: Number of sequential attempts to use. Default: 7.
</p>
</li>
<li><p> incn: Factor by which to multiply n from the second  sequential attempt onward. Default: 4.
</p>
</li>
<li><p> level: bound on the type I error, ie the probability of wrongly rejecting a sampler with the correct distribution. Default: 1e-5.
</p>
</li>
<li><p> debug: If positive  then debug information will be printed via 'message()'. Default: 0.
</p>
</li></ul>
</td></tr>
<tr><td><code id="expect_mcmc_reversible_+3A_thinning">thinning</code></td>
<td>
<p>Amount of thinning for the MCMC chain. 1 corresponds to no thinning. Default: automatically computed to ensure an autocorrelation of at most 0.5 at lag 1.</p>
</td></tr>
<tr><td><code id="expect_mcmc_reversible_+3A_nsteps">nsteps</code></td>
<td>
<p>Number of steps of the chain to use. Default: 10.</p>
</td></tr>
<tr><td><code id="expect_mcmc_reversible_+3A_p">p</code></td>
<td>
<p>The probability with which the MCMC updates the parameter as opposed to the data in a given step. If less than 1.0, then the MCMC is a random scan on both data and parameters. Default: 1.0.</p>
</td></tr>
<tr><td><code id="expect_mcmc_reversible_+3A_tolerance">tolerance</code></td>
<td>
<p>Absolute error where value of the samplers are treated as equal. Default: 1e-8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument, invisibly, to allow chaining of expectations.
</p>


<h3>References</h3>

<p>Besag J, Clifford P (1989).
&ldquo;Generalized Monte Carlo significance tests.&rdquo;
<em>Biometrika</em>, <b>76</b>(4), 633&ndash;642.
doi: <a href="https://doi.org/10.1093/biomet/76.4.633">10.1093/biomet/76.4.633</a>, <a href="https://doi.org/10.1093/biomet/76.4.633">https://doi.org/10.1093/biomet/76.4.633</a>.<br /><br /> Gandy A, Scott J (2020).
&ldquo;Unit Testing for MCMC and other Monte Carlo Methods.&rdquo;
<a href="https://arxiv.org/abs/2001.06465">https://arxiv.org/abs/2001.06465</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+expect_mcmc">expect_mcmc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>object &lt;- list(genprior=function() rnorm(1),
               gendata=function(theta) rnorm(5,theta),
               stepMCMC=function(theta,data,thinning){
                  f &lt;- function(x) prod(dnorm(data,x))*dnorm(x)  
                  for (i in 1:thinning){
                     thetanew = rnorm(1,mean=theta,sd=1)
                     if (runif(1)&lt;f(thetanew)/f(theta))
                     theta &lt;- thetanew
                  }
                  theta
               },
               test=function(x) x
               )
expect_mcmc_reversible(object)
</code></pre>

<hr>
<h2 id='mcunit-package'>mcunit: Unit Tests for MC Methods</h2><span id='topic+mcunit'></span><span id='topic+mcunit-package'></span>

<h3>Description</h3>

<p>Unit testing for Monte Carlo methods, particularly Markov Chain Monte Carlo (MCMC) methods, are implemented as extensions of the 'testthat' package. The MCMC methods check whether the MCMC chain has the correct invariant distribution. They do not check other properties of successful samplers such as whether the chain can reach all points, i.e. whether is recurrent. The tests require the ability to sample from the prior and to run steps of the MCMC chain. The methodology is described in Gandy and Scott (2020) &lt;arXiv:2001.06465&gt;.
</p>


<h3>Details</h3>

<p>If you want to test an MCMC sampler then the main function
that you are going to need from this package are
<a href="#topic+expect_mcmc">expect_mcmc</a> and <a href="#topic+expect_mcmc_reversible">expect_mcmc_reversible</a> which
can be used as part of unit testing in the framework of the
testthat package. They test if MCMC algorithms have the correct
invariant distribution.</p>
<pre>If you are testing iid samples then [expect_mc_iid_mean],
[expect_mc_iid_ks], [expect_mc_iid_chisq] and [expect_mc_test]
will be useful.
</pre>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Axel Gandy <a href="mailto:a.gandy@imperial.ac.uk">a.gandy@imperial.ac.uk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> James Scott <a href="mailto:james.scott15@imperial.ac.uk">james.scott15@imperial.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bitbucket.org/agandy/mcunit/">https://bitbucket.org/agandy/mcunit/</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
