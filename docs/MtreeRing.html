<!DOCTYPE html><html><head><title>Help for package MtreeRing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MtreeRing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MtreeRing-package'><p>A Shiny Application for Automatic Measurements of Tree-Ring Widths</p>
on Digital Images</a></li>
<li><a href='#pith_measure'><p>Calibrate ring-width series</p></a></li>
<li><a href='#ring_app_launch'><p>Run Shiny-based Application</p></a></li>
<li><a href='#ring_calculate'><p>Generate a ring-width series</p></a></li>
<li><a href='#ring_detect'><p>Automatic detection of tree-ring borders</p></a></li>
<li><a href='#ring_modify'><p>Edit ring borders visually</p></a></li>
<li><a href='#ring_read'><p>Read and plot a tree-ring image file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Shiny Application for Automatic Measurements of Tree-Ring
Widths on Digital Images</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Jingning Shi [aut, cre],
  Wei Xiang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jingning Shi &lt;snow940220@bjfu.edu.cn&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, shinytest, mockery, spelling</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr (&ge; 1.5), png, jpeg, tiff, bmp, magick, imager, dplR,
spatstat.geom, measuRing, shiny, dplyr, shinydashboard,
shinyWidgets</td>
</tr>
<tr>
<td>Description:</td>
<td>Use morphological image processing and edge detection algorithms to automatically measure tree ring widths on digital images. Users can also manually mark tree rings on species with complex anatomical structures. The arcs of inner-rings and angles of successive inclined ring boundaries are used to correct ring-width series. The package provides a Shiny-based application, allowing R beginners to easily analyze tree ring images and export ring-width series in standard file formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/MtreeRing">https://docs.ropensci.org/MtreeRing</a>,
<a href="https://github.com/ropensci/MtreeRing">https://github.com/ropensci/MtreeRing</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/MtreeRing/issues">https://github.com/ropensci/MtreeRing/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-19 04:42:07 UTC; snow</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-19 22:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='MtreeRing-package'>A Shiny Application for Automatic Measurements of Tree-Ring Widths 
on Digital Images</h2><span id='topic+MtreeRing-package'></span><span id='topic+MtreeRing'></span>

<h3>Description</h3>

<p>Use morphological image processing and edge detection algorithms to 
automatically measure tree ring widths on digital images. Users can also 
manually mark tree rings on species with complex anatomical structures. 
The arcs of inner-rings and angles of successive inclined ring boundaries 
are used to correct ring-width series. The package provides a Shiny-based 
application, allowing R beginners to easily analyze tree ring images and 
export ring-width series in standard file formats.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MtreeRing</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Jingning Shi &lt;snow940220@bjfu.edu.cn&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> TRUE</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Jingning Shi, Wei Xiang</p>

<hr>
<h2 id='pith_measure'>Calibrate ring-width series</h2><span id='topic+pith_measure'></span>

<h3>Description</h3>

<p>This function can calibrate the ring-width series 
using arcs of inner rings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pith_measure(ring.data, inner.arc = TRUE, last.yr = NULL,
  color = "black", border.type = 16, label.cex = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pith_measure_+3A_ring.data">ring.data</code></td>
<td>
<p>A magick image object produced by <code><a href="#topic+ring_read">ring_read</a></code>.</p>
</td></tr>
<tr><td><code id="pith_measure_+3A_inner.arc">inner.arc</code></td>
<td>
<p>A logical value indicating whether to calibrate the 
ring-width series using the arcs of inner rings. See details below.</p>
</td></tr>
<tr><td><code id="pith_measure_+3A_last.yr">last.yr</code></td>
<td>
<p><code>NULL</code> or an integer giving the year of formation 
of the left-most ring. If <code>NULL</code>, border numbers (starting from 1) 
are used instead of years.</p>
</td></tr>
<tr><td><code id="pith_measure_+3A_color">color</code></td>
<td>
<p>Color for labels.</p>
</td></tr>
<tr><td><code id="pith_measure_+3A_border.type">border.type</code></td>
<td>
<p>Symbol for ring borders. See <code>pch</code> in 
<code><a href="graphics.html#topic+points">points</a></code> for possible values and shapes.</p>
</td></tr>
<tr><td><code id="pith_measure_+3A_label.cex">label.cex</code></td>
<td>
<p>The magnification to be used for years or border numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to create a path, and manually mark 
ring borders by clicking on the graphical window. 
</p>
<p>An example demonstrated with pictures can be found in the package vignette. 
Type <code>vignette('pith-MtreeRing')</code> to see this example.
</p>

<ul>
<li>
<p>If <code>inner.arc = TRUE</code>, the ring-width series is calibrated using arcs 
of inner rings (Duncan, 1989).
</p>
<p><b>Step1</b>. You can click the left mouse button to add a horizontal path.
The path should traverse an appropriate arc (read the reference below  
for more details).
</p>
<p><b>Step2</b>. You can add three points to the selected arc by
left-clicking. The first point should be placed on the left endpoint of 
the arc, and the second point is placed on the right endpoint. 
</p>
<p>After adding these two points, a vertical dashed line will be plotted 
automatically according to the (x,y) positions of endpoints you just added. 
The third points should be placed on the intersection of the vertical 
dashed line and the selected arc. 
</p>
<p><b>Step3</b>. you are prompted to mark tree rings along the path by 
left-clicking on the image. Every click draws a point.
Note that the left endpoint of the arc will be considered as the last 
ring border without the need to mark it. 
</p>
<p>After marking tree rings, the identification process does not automatically 
stop by itself. On the Windows platform, the identification process 
can be terminated by clicking the second button and selecting <b>Stop</b> 
from the menu. On the MacOS system, you can press the <b>Escape</b> key to 
terminate this process.
</p>
<p>The ring-width series are corrected using formulas proposed by Duncan (1989).
</p>
</li>
<li>
<p>If <code>inner.arc = FALSE</code>, the user can create a path which matches 
the direction of wood growth. 
</p>
<p><b>Step1</b>. You can add two points by left-clicking on the image. 
Every click draws a point.
A path passing through these two points will be plotted. The path should 
follow the rays from bark to pith.
</p>
<p><b>Step2</b>. You can mark tree rings along the path by left-clicking
on the image. The termination of identification process is similar.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame of the calibrated ring-width series. The measurements 
units are millimeters (mm)
</p>


<h3>Author(s)</h3>

<p>Jingning Shi
</p>


<h3>References</h3>

<p>Duncan R. (1989) 
An evaluation of errors in tree age estimates based on increment cores 
in Kahikatea (Dacrycarpus dacrydiodes).
<em>New Zealand Natural Sciences</em>
<b>16(4)</b>, 1-37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img.path &lt;- system.file("missing_pith.png", package = "MtreeRing")

## Read the image:
t1 &lt;- ring_read(img = img.path, dpi = 1200, plot = FALSE)

## Use the arcs of inner rings to calibrate ring-width series:
t2 &lt;- pith_measure(t1, inner.arc = TRUE, last.yr = 2016)

## Try another method to measure ring widths:
t3 &lt;- pith_measure(t1, inner.arc = FALSE, last.yr = 2016)
</code></pre>

<hr>
<h2 id='ring_app_launch'>Run Shiny-based Application</h2><span id='topic+ring_app_launch'></span>

<h3>Description</h3>

<p>Run a Shiny-based application within the system's default 
web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_app_launch(launch.browser = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_app_launch_+3A_launch.browser">launch.browser</code></td>
<td>
<p>A logical value. 
If <code>FALSE</code>, a built-in browser will be launched automatically 
after the app is started. If <code>TRUE</code>, the system's default 
web browser is used instead. This argument only works for RStudio.
See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>launch.browser = FALSE</code> is not recommended, as the file renaming
does not work on the RStudio built-in browser when saving the data.
</p>
<p>A workflow for the Shiny app can be found here:
<a href="https://ropensci.github.io/MtreeRing/articles/app-MtreeRing.html">https://ropensci.github.io/MtreeRing/articles/app-MtreeRing.html</a>. 
Most steps are demonstrated with a gif
to make the workflow more understandable.
</p>
<p>To stop the app, go to the R console and press the Escape key. 
You can also click the stop sign icon in the
upper right corner of the RStudio console.
</p>


<h3>Author(s)</h3>

<p>Jingning Shi, Wei Xiang
</p>

<hr>
<h2 id='ring_calculate'>Generate a ring-width series</h2><span id='topic+ring_calculate'></span>

<h3>Description</h3>

<p>This function can calculate ring widths according to 
coordinates of detected ring borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_calculate(ring.data, seriesID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_calculate_+3A_ring.data">ring.data</code></td>
<td>
<p>A matrix or array produced by <code><a href="#topic+ring_detect">ring_detect</a></code> 
or <code><a href="#topic+ring_modify">ring_modify</a></code>.</p>
</td></tr>
<tr><td><code id="ring_calculate_+3A_seriesid">seriesID</code></td>
<td>
<p>A character string specifying the column name of 
the ring-width series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. The series ID is the column name 
and years are row names. The measurements units are millimeters (mm).
</p>


<h3>Author(s)</h3>

<p>Jingning Shi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img.path &lt;- system.file("001.png", package = "MtreeRing")

## Read a tree ring image:
t1 &lt;- ring_read(img = img.path, dpi = 1200)

## Split a long core sample into 3 pieces to
## get better display performance and use the
## watershed algorithm to detect ring borders:
t2 &lt;- ring_detect(ring.data = t1, seg = 3, method = 'watershed')

## Calculate ring widths from the attribute list of t2:
rw.df &lt;- ring_calculate(ring.data = t2, seriesID = "940220")
</code></pre>

<hr>
<h2 id='ring_detect'>Automatic detection of tree-ring borders</h2><span id='topic+ring_detect'></span>

<h3>Description</h3>

<p>This function is used to automatically detect tree ring 
borders along the user-defined path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_detect(ring.data, seg = 1, auto.path = TRUE, manual = FALSE,
  method = "canny", incline = FALSE, sample.yr = NULL,
  watershed.threshold = "auto", watershed.adjust = 0.8,
  struc.ele1 = NULL, struc.ele2 = NULL, marker.correction = FALSE,
  default.canny = TRUE, canny.t1, canny.t2, canny.smoothing = 2,
  canny.adjust = 1.4, path.dis = 1, origin = 0,
  border.color = "black", border.type = 16, label.color = "black",
  label.cex = 1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_detect_+3A_ring.data">ring.data</code></td>
<td>
<p>A magick image object produced by <code><a href="#topic+ring_read">ring_read</a></code>.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_seg">seg</code></td>
<td>
<p>An integer specifying the number of image segments.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_auto.path">auto.path</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, a path is automatically 
created at the center of the image. If <code>FALSE</code>, the function allows 
the user to create a sub-image and a path by interactive clickings. 
See details below.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_manual">manual</code></td>
<td>
<p>A logical value indicating whether to skip the automatic 
detection. If <code>TRUE</code>, ring borders are visually identified after 
creating the path. See <code><a href="#topic+ring_modify">ring_modify</a></code> to learn how to mark
tree rings by clicking on the image.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_method">method</code></td>
<td>
<p>A character string specifying how ring borders are detected. 
It requires one of the following characters: <code>"watershed"</code>, 
<code>"canny"</code>, or <code>"lineardetect"</code>. See details below.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_incline">incline</code></td>
<td>
<p>A logical value indicating whether to correct ring widths. 
If <code>TRUE</code>, two horizontal paths are added to the image.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_sample.yr">sample.yr</code></td>
<td>
<p><code>NULL</code> or an integer giving the year of formation 
of the left-most ring. If <code>NULL</code>, use the current year.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_watershed.threshold">watershed.threshold</code></td>
<td>
<p>The threshold used for producing the marker 
image, either a numeric from 0 to 1, or the character &quot;auto&quot; (using the 
Otsu algorithm), or a character of the form &quot;XX%&quot; (e.g., &quot;58%&quot;).</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_watershed.adjust">watershed.adjust</code></td>
<td>
<p>A numeric used to adjust the Otsu threshold. 
The default is 1 which means that the threshold will not be adjusted. 
The sizes of early-wood regions in the marker image will reduce along 
with the decrease of <code>watershed.adjust</code>.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_struc.ele1">struc.ele1</code></td>
<td>
<p><code>NULL</code> or a vector of length two specifying the 
width and height of the first structuring element. If <code>NULL</code>, the 
size of the structuring element is determined by the argument <code>dpi</code>.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_struc.ele2">struc.ele2</code></td>
<td>
<p><code>NULL</code> or a vector of length two specifying the 
width and height of the second structuring element. If <code>NULL</code>, the 
size of the structuring element is determined by the argument <code>dpi</code>.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_marker.correction">marker.correction</code></td>
<td>
<p>A logical value indicating whether to relabel 
early-wood regions by comparing the values of their left-side neighbours.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_default.canny">default.canny</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, upper and lower 
Canny thresholds are determined automatically.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_canny.t1">canny.t1</code></td>
<td>
<p>A numeric giving the threshold for weak edges.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_canny.t2">canny.t2</code></td>
<td>
<p>A numeric giving the threshold for strong edges.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_canny.smoothing">canny.smoothing</code></td>
<td>
<p>An integer specifying the degree of smoothing.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_canny.adjust">canny.adjust</code></td>
<td>
<p>A numeric used as a sensitivity control factor for 
the Canny edge detector. The default is 1 which means that the sensitivity 
will not be adjusted. The number of detected borders will reduce along 
with the increase of this value.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_path.dis">path.dis</code></td>
<td>
<p>A numeric specifying the perpendicular distance between 
two paths when the argument <code>incline = TRUE</code>. The unit is in mm.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_origin">origin</code></td>
<td>
<p>A numeric specifying the origin in smoothed gray to find 
ring borders. See <code><a href="measuRing.html#topic+ringBorders">ringBorders</a></code> from the package 
<code><a href="measuRing.html#topic+measuRing">measuRing</a></code>.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_border.color">border.color</code></td>
<td>
<p>Color for ring borders.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_border.type">border.type</code></td>
<td>
<p>Symbol for ring borders. See <code>pch</code> in 
<code><a href="graphics.html#topic+points">points</a></code> for possible values and their shapes.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_label.color">label.color</code></td>
<td>
<p>Color for years and border numbers.</p>
</td></tr>
<tr><td><code id="ring_detect_+3A_label.cex">label.cex</code></td>
<td>
<p>The magnification to be used for years and border numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>auto.path = FALSE</code>, the user can create a rectangular sub-image 
and a horizontal path by interactively clicking on the tree ring image. 
The automatic detection will be performed within this rectangular 
sub-image. 
To create a sub-image and a path, follow these steps.
</p>

<ul>
<li>
<p>Step 1. Select the left and right edges of the rectangle
</p>
<p>The user can point the mouse at any 
desired locations and click the left mouse button to add each edge. 
</p>
</li>
<li>
<p>Step 2. Select the top and bottom edges of the rectangle
</p>
<p>The user can point the mouse at any desired locations and click the 
left mouse button to add each edge. The width of the rectangle is 
defined as the distance between the top and bottom edges, and should 
not be unnecessarily large to reduce time consumption and memory usage. 
Creating a long and narrow rectangle if possible.
</p>
</li>
<li>
<p>Step 3. Create a path
</p>
<p>After creating the rectangular sub-image, the user can add a horizontal 
path by left-clicking on the sub-image (generally at the center of the 
sub-image, try to choose a clean defect-free area). Ring borders and 
other markers are plotted along this path. If <code>incline = TRUE</code>, 
two paths are added simultaneously.
</p>
</li></ul>

<p>After creating the sub-image and the path, this function will open several 
graphics windows and plot detected ring borders on image segments. The 
number of image segments is controlled by the argument <code>seg</code>.
</p>
<p>Argument <code>method</code> determines how ring borders are identified. 
</p>

<ul>
<li>
<p>If <code>method = "watershed"</code>, this function uses the watershed algorithm 
to obtain ring borders (Soille and Misson, 2001).
</p>
</li>
<li>
<p>If <code>method = "canny"</code>, this function uses the Canny algorithm 
to detect borders.
</p>
</li>
<li>
<p>If <code>method = "lineardetect"</code>, a linear detection algorithm from the 
package <code><a href="measuRing.html#topic+measuRing">measuRing</a></code> is used to identify ring borders (Lara 
et al., 2015). Note that <code>incline = TRUE</code> is not supported in this 
mode, and path will be automatically created at the center of the image. 
</p>
</li></ul>

<p>If the argument <code>method = "watershed"</code> or <code>"canny"</code>, the original 
image is processed by morphological openings and closings using rectangular 
structuring elements of increasing size before detecting borders. The first 
small structuring element is used to remove smaller dark spots in early 
wood regions, and the second large structuring element is used to remove 
light strips in late wood regions. More details about morphological 
processing can be found at Soille and Misson (2001).
</p>


<h3>Value</h3>

<p>A matrix (grayscale image) or array (color image) 
representing the tree-ring image.
</p>


<h3>Note</h3>

<p>This function uses <code><a href="graphics.html#topic+locator">locator</a></code> to record mouse 
positions so it only works on &quot;X11&quot;, &quot;windows&quot; and &quot;quartz&quot; devices.
</p>


<h3>Author(s)</h3>

<p>Jingning Shi
</p>


<h3>References</h3>

<p>Soille, P., Misson, L. (2001)
Tree ring area measurements using morphological image analysis.
<em>Canadian Journal of Forest Research</em>
<b>31</b>, 1074-1083. doi: 10.1139/cjfr-31-6-1074
</p>
<p>Lara, W., Bravo, F., Sierra, C.A. (2015)
measuRing: An R package to measure tree-ring widths from scanned images.
<em>Dendrochronologia</em>
<b>34</b>, 43-50. doi: 10.1016/j.dendro.2015.04.002
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img.path &lt;- system.file("001.png", package = "MtreeRing")

## Read a tree ring image:
t1 &lt;- ring_read(img = img.path, dpi = 1200, plot = FALSE)

## Split a long core sample into 3 pieces to
## get better display performance and use the
## watershed algorithm to detect ring borders:
t2 &lt;- ring_detect(t1, seg = 3, method = 'watershed', border.color = 'green')

</code></pre>

<hr>
<h2 id='ring_modify'>Edit ring borders visually</h2><span id='topic+ring_modify'></span>

<h3>Description</h3>

<p>This function can remove existing ring borders 
or add new borders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_modify(ring.data, del = NULL, del.u = NULL, del.l = NULL,
  add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_modify_+3A_ring.data">ring.data</code></td>
<td>
<p>A matrix or array produced by <code><a href="#topic+ring_detect">ring_detect</a></code>.</p>
</td></tr>
<tr><td><code id="ring_modify_+3A_del">del</code></td>
<td>
<p>A numeric vector giving the border numbers to be removed.</p>
</td></tr>
<tr><td><code id="ring_modify_+3A_del.u">del.u</code></td>
<td>
<p>A numeric vector giving the border numbers to be removed 
on the upper path.</p>
</td></tr>
<tr><td><code id="ring_modify_+3A_del.l">del.l</code></td>
<td>
<p>A numeric vector giving the border numbers to be removed 
on the lower path.</p>
</td></tr>
<tr><td><code id="ring_modify_+3A_add">add</code></td>
<td>
<p>A logical value indicating whether to add new ring borders.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove existing ring borders, or to add new 
borders by interactively clicking on the image segments.
</p>
<p>If the user creates one path (<code>incline = FALSE</code>), the argument 
<code>del</code> is used to remove ring borders. If the user creates two paths 
(<code>incline = TRUE</code>), arguments <code>del.u</code> and <code>del.l</code> are used 
to remove ring borders.
</p>
<p>If <code>add = TRUE</code>, graphics windows opened by <code><a href="#topic+ring_detect">ring_detect</a></code>
will be activated sequentially. When a graphics window is activated, 
the user can add new borders by left-clicking the mouse along the path.
Every click draws a point representing the ring border.
Type <code>vignette('detection-MtreeRing')</code> to see 
an example of adding ring borders.
</p>
<p>The identification process does not automatically stop by itself.
</p>

<ul>
<li>
<p>On the Windows system, the identification process can be terminated by 
pressing the right mouse button and selecting <b>Stop</b> from the menu.
</p>
</li>
<li> 
<p>On the MacOS system, for a X11 device the identification process is 
terminated by pressing any mouse button other than the first, and for a 
quartz device this process is terminated by pressing the <b>ESC</b> key.
</p>
</li></ul>

<p>Once the user terminates the identification process, the current 
graphics window will be closed automatically, and the graphics window of
the following segment is activated. When all graphics windows are closed,
<code>ring_modify</code> will re-open graphics windows and plot new borders.
</p>
<p>This function can perform both deletion and addition in one call.
The removal of ring borders takes precedence over addition.
</p>


<h3>Value</h3>

<p>A matrix (grayscale image) or array (color image)
representing the tree ring image.
</p>


<h3>Author(s)</h3>

<p>Jingning Shi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img.path &lt;- system.file("001.png", package = "MtreeRing")

## Read a tree ring image:
t1 &lt;- ring_read(img = img.path, dpi = 1200)

## Split a long core sample into 3 pieces to
## get better display performance and use the
## watershed algorithm to detect ring borders:
t2 &lt;- ring_detect(ring.data = t1, seg = 3, method = 'watershed')

## Do not modify t2, but create a new array object t3. 
## Remove some borders without adding new borders:
t3 &lt;- ring_modify(ring.data = t2, del = c(1, 3, 5, 19:21), add = FALSE)

</code></pre>

<hr>
<h2 id='ring_read'>Read and plot a tree-ring image file</h2><span id='topic+ring_read'></span>

<h3>Description</h3>

<p>This function can read an image file from the hard disk and 
plot it in a newly-opened graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ring_read(img, dpi = NULL, RGB = c(0.299, 0.587, 0.114),
  plot = FALSE, rotate = 0, magick = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ring_read_+3A_img">img</code></td>
<td>
<p>A character string indicating the path of the image file. 
Supported formats include png, tiff, jpg and bmp.</p>
</td></tr>
<tr><td><code id="ring_read_+3A_dpi">dpi</code></td>
<td>
<p>An integer specifying the dpi of the image file. A minimum of 
300 dpi is required when running automatic detection.</p>
</td></tr>
<tr><td><code id="ring_read_+3A_rgb">RGB</code></td>
<td>
<p>A numeric vector of length 3 giving the weight of RGB channels.</p>
</td></tr>
<tr><td><code id="ring_read_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether to plot the tree ring image 
when reading it. If <code>FALSE</code>, the image is not plotted until
function <code><a href="#topic+ring_detect">ring_detect</a></code> or <code><a href="#topic+pith_measure">pith_measure</a></code> is called.</p>
</td></tr>
<tr><td><code id="ring_read_+3A_rotate">rotate</code></td>
<td>
<p>An integer specifying how many degrees to rotate (clockwise). 
It requires one of the following values:
<code>0</code>, <code>90</code>, <code>180</code> or <code>270</code>.</p>
</td></tr>
<tr><td><code id="ring_read_+3A_magick">magick</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, <code>magick</code> is used to
read the tree ring image. If <code>FALSE</code>,
packages <code>png</code>, <code>jpg</code> and <code>tiff</code> are used instead.
See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proper image preparation has a great influence on the measurement of 
ring widths. A tree-ring image should not contain irrelevant or redundant 
features, such as wooden mounts where cores are glued. The larger the file 
size of an image, the slower the image processing operation will be.
</p>
<p><b>Pith side</b> of a wood sample should be placed on the <b>right side</b> 
of a graphics window. Use <code>rotate</code> to change its position.
</p>
<p>It is highly recommended to use the default value <code>magick = TRUE</code>, 
because <code>magick</code> can significantly reduce the memory usage
when reading a large file.
If image data is stored in a non-standard format, image reading may fail.
In that case you can set <code>magick = FALSE</code> to 
avoid the use of <code>magick</code>.
</p>


<h3>Value</h3>

<p>A magick image object containing the image data.
</p>


<h3>Author(s)</h3>

<p>Jingning Shi
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img.path &lt;- system.file("001.png", package = "MtreeRing")

## Read and plot the image:
t1 &lt;- ring_read(img = img.path, dpi = 1200, plot = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
