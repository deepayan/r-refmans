<!DOCTYPE html><html><head><title>Help for package hedgehog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hedgehog}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hedgehog'><p>Property based testing in R</p></a></li>
<li><a href='#command'><p>State based testing commands</p></a></li>
<li><a href='#discard'><p>Discard a test case</p></a></li>
<li><a href='#expect_sequential'><p>Execute a state machine model</p></a></li>
<li><a href='#forall'><p>Hedgehog property test</p></a></li>
<li><a href='#gen-element'><p>Random Sample Generation</p></a></li>
<li><a href='#gen-monad'><p>Generators</p></a></li>
<li><a href='#gen.actions'><p>Generate a list of possible actions.</p></a></li>
<li><a href='#gen.beta'><p>Generate a float with a gamma distribution</p></a></li>
<li><a href='#gen.c'><p>Generate a vector of values from a generator</p></a></li>
<li><a href='#gen.date'><p>Generate a date between the from and to</p>
dates specified.</a></li>
<li><a href='#gen.example'><p>Sample from a generator.</p></a></li>
<li><a href='#gen.gamma'><p>Generate a float with a gamma distribution</p></a></li>
<li><a href='#gen.list'><p>Generate a list of values, with</p>
length bounded by the size parameter.</a></li>
<li><a href='#gen.no.shrink'><p>Stop a generator from shrinking</p></a></li>
<li><a href='#gen.recursive'><p>Build recursive structures in a way that guarantees termination.</p></a></li>
<li><a href='#gen.run'><p>Run a generator</p></a></li>
<li><a href='#gen.shrink'><p>Helper to create a generator with a</p>
shrink function.</a></li>
<li><a href='#gen.sized'><p>Sized generator creation</p></a></li>
<li><a href='#gen.structure'><p>Generate a structure</p></a></li>
<li><a href='#gen.unif'><p>Generate a float between the from</p>
and to the values specified.</a></li>
<li><a href='#generate'><p>Compose generators</p></a></li>
<li><a href='#shrink.halves'><p>Shrink a number by dividing it into halves.</p></a></li>
<li><a href='#shrink.list'><p>Shrink a list by edging towards the empty list.</p></a></li>
<li><a href='#shrink.removes'><p>Produce permutations of removing num elements from a list.</p></a></li>
<li><a href='#shrink.towards'><p>Shrink an integral number by edging towards a destination.</p></a></li>
<li><a href='#symbolic'><p>A symbolic value.</p></a></li>
<li><a href='#tree'><p>Lazy rose trees</p></a></li>
<li><a href='#tree.replicate'><p>Creating trees of lists</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Property-Based Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-08-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Hedgehog will eat all your bugs.
  'Hedgehog' is a property-based testing package in the spirit
  of 'QuickCheck'. With 'Hedgehog', one can test properties
  of their programs against randomly generated input, providing
  far superior test coverage compared to unit testing. One of the
  key benefits of 'Hedgehog' is integrated shrinking of
  counterexamples, which allows one to quickly find the cause of
  bugs, given salient examples when incorrect behaviour occurs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hedgehog.qa">https://hedgehog.qa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hedgehogqa/r-hedgehog/issues">https://github.com/hedgehogqa/r-hedgehog/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.1.6)</td>
</tr>
<tr>
<td>Depends:</td>
<td>testthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-08-17 11:33:28 UTC; hcampbell</td>
</tr>
<tr>
<td>Author:</td>
<td>Huw Campbell [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Huw Campbell &lt;huw.campbell@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-08-22 16:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='hedgehog'>Property based testing in R</h2><span id='topic+hedgehog'></span><span id='topic+hedgehog-package'></span>

<h3>Description</h3>

<p>Hedgehog is a modern property based testing
system in the spirit of QuickCheck, originally written in Haskell,
but now also available in R.
</p>


<h3>Details</h3>

<p>Software testing is critical when we want to distribute our
work, but unit testing only covers examples we have thought of.
</p>
<p>With hedgehog (integrated into testthat), we can instead test properties
which our programs and functions should have, and allow automatic
generation of tests, which cover more that we could imagine.
</p>
<p>One of the key benefits of Hedgehog is
integrated shrinking of counterexamples, which allows one to quickly
find the cause of bugs, given salient examples when incorrect
behaviour occurs.
</p>


<h3>Options</h3>

<p>- 'hedgehog.tests': Number of tests to run in each property
(Default: '100').
</p>
<p>- 'hedgehog.size': Maximum size parameter to pass to generators
(Default: '50').
</p>
<p>- 'hedgehog.shrinks': Maximum number of shrinks to search for
(Default: '100').
</p>
<p>- 'hedgehog.discards': Maximum number of discards permitted
within a property test before failure
(Default: '100').
</p>


<h3>References</h3>

<p>Campbell, H (2017). hedgehog: Property based testing in R
<strong>The R Journal</strong> under submission.
</p>
<p><a href="https://github.com/hedgehogqa/r-hedgehog">https://github.com/hedgehogqa/r-hedgehog</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(hedgehog)
test_that( "Reverse and concatenate symmetry",
  forall( list( as = gen.c( gen.element(1:100) )
              , bs = gen.c( gen.element(1:100) ))
        , function( as, bs )
            expect_identical ( rev(c(as, bs)), c(rev(bs), rev(as)))
  )
)
</code></pre>

<hr>
<h2 id='command'>State based testing commands</h2><span id='topic+command'></span>

<h3>Description</h3>

<p>This helper function assists one in creating commands
for state machine testing in hedgehog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>command(title, generator, execute, require = function(state, ...) T,
  update = function(state, output, ...) state, ensure = function(state,
  output, ...) NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="command_+3A_title">title</code></td>
<td>
<p>the name of this command, to be shown when
reporting any failing test cases.</p>
</td></tr>
<tr><td><code id="command_+3A_generator">generator</code></td>
<td>
<p>A generator which provides random arguments
for the command, given the current (symbolic) state.
If nothing can be done with the current state, one
should preclude the situation with a requires and
return NULL. Otherwise, it should be a list of
arguments (the empty list is ok for functions which
take no arguments).</p>
</td></tr>
<tr><td><code id="command_+3A_execute">execute</code></td>
<td>
<p>A function from the concrete input,
which executes the true function and returns
concrete output.
Function takes the (possibly named) arguments given
by the generator.</p>
</td></tr>
<tr><td><code id="command_+3A_require">require</code></td>
<td>
<p>A function from the current (symbolic)
state to a bool, indicating if action is currently
applicable.
Function also takes the (possibly named) arguments
given by the generator (this is mostly used in
shrinking, to ensure after a shrink its still
something which could have been generated by the
function generator).</p>
</td></tr>
<tr><td><code id="command_+3A_update">update</code></td>
<td>
<p>A function from state to state, which is
polymorphic over symbolic and concrete inputs and
outputs (as it is used in both action generation and
command execution).
It's critical that one doesn't &quot;inspect&quot; the output
and input values when writing this function.</p>
</td></tr>
<tr><td><code id="command_+3A_ensure">ensure</code></td>
<td>
<p>A post-condition for a command that must be
verified for the command to be considered a success.
This should be a set of testthat expectations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a command structure.
</p>

<hr>
<h2 id='discard'>Discard a test case</h2><span id='topic+discard'></span>

<h3>Description</h3>

<p>Discard a test case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discard()
</code></pre>

<hr>
<h2 id='expect_sequential'>Execute a state machine model</h2><span id='topic+expect_sequential'></span>

<h3>Description</h3>

<p>Executes the list of commands sequentially,
ensuring that all postconditions hold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_sequential(initial.state, actions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_sequential_+3A_initial.state">initial.state</code></td>
<td>
<p>the starting state to
build from which is appropriate for this
state machine generator.</p>
</td></tr>
<tr><td><code id="expect_sequential_+3A_actions">actions</code></td>
<td>
<p>the list of actions which
are to be run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an expectation.
</p>

<hr>
<h2 id='forall'>Hedgehog property test</h2><span id='topic+forall'></span>

<h3>Description</h3>

<p>Check a property holds for all generated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forall(generator, property, tests = getOption("hedgehog.tests", 100),
  size.limit = getOption("hedgehog.size", 50),
  shrink.limit = getOption("hedgehog.shrinks", 100),
  discard.limit = getOption("hedgehog.discards", 100),
  curry = identical(class(generator), "list"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forall_+3A_generator">generator</code></td>
<td>
<p>a generator or list of generators
(potentially nested) to use for value testing.</p>
</td></tr>
<tr><td><code id="forall_+3A_property">property</code></td>
<td>
<p>a function which takes a value from
from the generator and tests some predicated against
it.</p>
</td></tr>
<tr><td><code id="forall_+3A_tests">tests</code></td>
<td>
<p>the number of tests to run</p>
</td></tr>
<tr><td><code id="forall_+3A_size.limit">size.limit</code></td>
<td>
<p>the max size used for the generators</p>
</td></tr>
<tr><td><code id="forall_+3A_shrink.limit">shrink.limit</code></td>
<td>
<p>the maximum number of shrinks to
run when shrinking a value to find the smallest
counterexample.</p>
</td></tr>
<tr><td><code id="forall_+3A_discard.limit">discard.limit</code></td>
<td>
<p>the maximum number of discards to
permit when running the property.</p>
</td></tr>
<tr><td><code id="forall_+3A_curry">curry</code></td>
<td>
<p>whether to curry the arguments passed
to the property, and use do.call to use the list
generated as individual arguments.
When curry is on, the function arity should be the
same as the length of the generated list.
Defaults to <code>T</code> if the input is a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generator used can be defined flexibly, in that
one can pass in a list of generators, or even nest
generators and constant values deeply into the gen
argument and the whole construct will be treated
as a generator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_that( "Reverse and concatenate symmetry",
  forall( list( as = gen.c( gen.element(1:100) )
              , bs = gen.c( gen.element(1:100) ))
        , function( as, bs )
            expect_identical ( rev(c(as, bs)), c(rev(bs), rev(as)))
  )
)

# False example showing minimum shrink:
## Not run: 
test_that( "Reverse is identity",
  forall ( gen.c( gen.element(1:100)), function(x) { expect_identical ( rev(x), c(x) ) } )
)

## End(Not run)
# Falsifiable after 1 tests, and 5 shrinks
# Predicate is falsifiable

# Counterexample:
# [1] 1 2

</code></pre>

<hr>
<h2 id='gen-element'>Random Sample Generation</h2><span id='topic+gen-element'></span><span id='topic+gen.element'></span><span id='topic+gen.int'></span><span id='topic+gen.choice'></span><span id='topic+gen.subsequence'></span><span id='topic+gen.sample'></span><span id='topic+gen.sample.int'></span>

<h3>Description</h3>

<p>Generators which sample from a list or produce random
integer samples. Both single sample, with <code>gen.element</code>;
and multi-sample, with <code>gen.sample</code> and <code>gen.subsequence</code>
are supported; while <code>gen.choice</code> is used to choose from
generators instead of examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.element(x, prob = NULL)

gen.int(n, prob = NULL)

gen.choice(..., prob = NULL)

gen.subsequence(x)

gen.sample(x, size, replace = FALSE, prob = NULL)

gen.sample.int(n, size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen-element_+3A_x">x</code></td>
<td>
<p>a list or vector to sample an element from.</p>
</td></tr>
<tr><td><code id="gen-element_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights for
obtaining the elements of the vector being
sampled.</p>
</td></tr>
<tr><td><code id="gen-element_+3A_n">n</code></td>
<td>
<p>the number which is the maximum integer
sampled from.</p>
</td></tr>
<tr><td><code id="gen-element_+3A_...">...</code></td>
<td>
<p>generators to sample from</p>
</td></tr>
<tr><td><code id="gen-element_+3A_size">size</code></td>
<td>
<p>a non-negative integer or a generator of
one, giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="gen-element_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These generators implement shrinking.
</p>


<h3>Value</h3>

<p><code>gen.element</code> returns an item from the list
or vector; <code>gen.int</code>, an integer up to the value
n; <code>gen.choice</code>, a value from one of given selected
generators; <code>gen.subsequence</code> an ordered subsequence
from the input sequence; and <code>gen.sample</code> a list or
vector (depending on the input) of the inputs.
</p>
<p>For <code>gen.element</code> and <code>gen.choice</code>, shrinking
will move towards the first item; <code>gen.int</code> will
shrink to 1; <code>gen.subsequence</code> will shrink the list
towards being empty; and <code>gen.sample</code> will shrink
towards the original list order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.element(1:10)   # a number
gen.element(c(TRUE,FALSE)) # a boolean
gen.int(10) # a number up to 10
gen.choice(gen.element(1:10), gen.element(letters))
gen.choice(NaN, Inf, gen.unif(-10, 10), prob = c(1,1,10))
gen.subsequence(1:10)

</code></pre>

<hr>
<h2 id='gen-monad'>Generators</h2><span id='topic+gen-monad'></span><span id='topic+gen'></span><span id='topic+gen.and_then'></span><span id='topic+gen.bind'></span><span id='topic+gen.pure'></span><span id='topic+gen.impure'></span><span id='topic+gen.with'></span><span id='topic+gen.map'></span>

<h3>Description</h3>

<p>A Hedgehog generator is a function, which, using R's
random seed, will build a lazy rose tree given a size
parameter, which represent a value to test, as well
as possible shrinks to try in the event of a failure.
Usually, one should compose the provided generators
instead of dealing with the gen contructor itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(t)

gen.and_then(g, f)

gen.bind(f, g)

gen.pure(x)

gen.impure(fg)

gen.with(g, m)

gen.map(m, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen-monad_+3A_t">t</code></td>
<td>
<p>a function producing a tree from a size parameter, usually
an R function producing random values is used.</p>
</td></tr>
<tr><td><code id="gen-monad_+3A_g">g</code></td>
<td>
<p>a generator to map or bind over</p>
</td></tr>
<tr><td><code id="gen-monad_+3A_f">f</code></td>
<td>
<p>a function from a value to new generator, used to
build new generators monadically from a generator's
output</p>
</td></tr>
<tr><td><code id="gen-monad_+3A_x">x</code></td>
<td>
<p>a value to use as a generator</p>
</td></tr>
<tr><td><code id="gen-monad_+3A_fg">fg</code></td>
<td>
<p>a function producing a single value from a size parameter</p>
</td></tr>
<tr><td><code id="gen-monad_+3A_m">m</code></td>
<td>
<p>a function to apply to values produced the generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hedgehog generators are functors and monads, allowing
one to map over them and use their results to create
more complex generators.
</p>
<p>A generator can use R's random seed when constructing
its value, but all shrinks should be deterministic.
</p>
<p>In general, functions which accept a generator can also
be provided with a list of generators nested arbitrarily.
</p>
<p>Generators which are created from impure values (i.e., have
randomness), can be created with <code><a href="#topic+gen.impure">gen.impure</a></code>,
which takes a function from <code>size</code> to a value. When
using this the function will not shrink, so it is best
composed with <code><a href="#topic+gen.shrink">gen.shrink</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate">generate</a></code> for way an alternative, but
equally expressive way to compose generators using R's
&quot;for&quot; loop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a generator which produces a number between
# 1 and 30
one_to_30 &lt;- gen.element(1:30)

# Use this to create a simple vector of 6 numbers
# between 1 and 30.
vector_one_to_30 &lt;- gen.c(of = 6, one_to_30)

# Create a matrix 2 by 3 matrix using said vector
gen.map(function(x) matrix(x, ncol=3), vector_one_to_30)

# To create a generator from a normal R random function
# use gen.impure (this generator does not shrink).
g &lt;- gen.impure(function(size) sample(1:10) )
gen.example(g)
# [1]  5  6  3  4  8 10  2  7  9  1

# Composing generators with `gen.bind` and `gen.with` is
# easy. Here we make a generator which first build a length,
# then, elements of that length.
g &lt;- gen.bind(function(x) gen.c(of = x, gen.element(1:10)), gen.element(2:100))
gen.example ( g )
# [1] 8 6 2 7 5 4 2 2 4 6 4 6 6 3 6 7 8 5 4 6
</code></pre>

<hr>
<h2 id='gen.actions'>Generate a list of possible actions.</h2><span id='topic+gen.actions'></span>

<h3>Description</h3>

<p>Generate a list of possible actions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.actions(initial.state, commands)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.actions_+3A_initial.state">initial.state</code></td>
<td>
<p>the starting state to
build from which is appropriate for this
state machine generator.</p>
</td></tr>
<tr><td><code id="gen.actions_+3A_commands">commands</code></td>
<td>
<p>the list of commands which
we can select choose from. Only commands
appropriate for the state will actually be
selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of actions to run during testing
</p>

<hr>
<h2 id='gen.beta'>Generate a float with a gamma distribution</h2><span id='topic+gen.beta'></span>

<h3>Description</h3>

<p>Shrinks towards the median value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.beta(shape1, shape2, ncp = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.beta_+3A_shape1">shape1</code></td>
<td>
<p>same as shape1 in rbeta</p>
</td></tr>
<tr><td><code id="gen.beta_+3A_shape2">shape2</code></td>
<td>
<p>same as shape2 in rbeta</p>
</td></tr>
<tr><td><code id="gen.beta_+3A_ncp">ncp</code></td>
<td>
<p>same as ncp in rbeta</p>
</td></tr>
</table>

<hr>
<h2 id='gen.c'>Generate a vector of values from a generator</h2><span id='topic+gen.c'></span>

<h3>Description</h3>

<p>Generate a vector of values from a generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.c(generator, from = 1, to = NULL, of = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.c_+3A_generator">generator</code></td>
<td>
<p>a generator used for vector elements</p>
</td></tr>
<tr><td><code id="gen.c_+3A_from">from</code></td>
<td>
<p>minimum length of the list of
elements</p>
</td></tr>
<tr><td><code id="gen.c_+3A_to">to</code></td>
<td>
<p>maximum length of the list of
elements (defaults to size if NULL)</p>
</td></tr>
<tr><td><code id="gen.c_+3A_of">of</code></td>
<td>
<p>the exact length of the list of
elements (exclusive to 'from' and 'to').</p>
</td></tr>
</table>

<hr>
<h2 id='gen.date'>Generate a date between the from and to
dates specified.</h2><span id='topic+gen.date'></span>

<h3>Description</h3>

<p>Shrinks towards the <code>from</code> value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.date(from = as.Date("1900-01-01"), to = as.Date("3000-01-01"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.date_+3A_from">from</code></td>
<td>
<p>a <code>Date</code> value</p>
</td></tr>
<tr><td><code id="gen.date_+3A_to">to</code></td>
<td>
<p>a <code>Date</code> value</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gen.date()
gen.date( from = as.Date("1939-09-01"), to = as.Date("1945-09-02"))
</code></pre>

<hr>
<h2 id='gen.example'>Sample from a generator.</h2><span id='topic+gen.example'></span>

<h3>Description</h3>

<p>Sample from a generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.example(g, size = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.example_+3A_g">g</code></td>
<td>
<p>A generator</p>
</td></tr>
<tr><td><code id="gen.example_+3A_size">size</code></td>
<td>
<p>The sized example to view</p>
</td></tr>
</table>

<hr>
<h2 id='gen.gamma'>Generate a float with a gamma distribution</h2><span id='topic+gen.gamma'></span>

<h3>Description</h3>

<p>Shrinks towards the median value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.gamma(shape, rate = 1, scale = 1/rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.gamma_+3A_shape">shape</code></td>
<td>
<p>same as shape in rgamma</p>
</td></tr>
<tr><td><code id="gen.gamma_+3A_rate">rate</code></td>
<td>
<p>same as rate in rgamma</p>
</td></tr>
<tr><td><code id="gen.gamma_+3A_scale">scale</code></td>
<td>
<p>same as scale in rgamma</p>
</td></tr>
</table>

<hr>
<h2 id='gen.list'>Generate a list of values, with
length bounded by the size parameter.</h2><span id='topic+gen.list'></span>

<h3>Description</h3>

<p>Generate a list of values, with
length bounded by the size parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.list(generator, from = 1, to = NULL, of = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.list_+3A_generator">generator</code></td>
<td>
<p>a generator used for list elements</p>
</td></tr>
<tr><td><code id="gen.list_+3A_from">from</code></td>
<td>
<p>minimum length of the list of
elements</p>
</td></tr>
<tr><td><code id="gen.list_+3A_to">to</code></td>
<td>
<p>maximum length of the list of
elements ( defaults to size if NULL )</p>
</td></tr>
<tr><td><code id="gen.list_+3A_of">of</code></td>
<td>
<p>the exact length of the list of
elements (exclusive to 'from' and 'to').</p>
</td></tr>
</table>

<hr>
<h2 id='gen.no.shrink'>Stop a generator from shrinking</h2><span id='topic+gen.no.shrink'></span>

<h3>Description</h3>

<p>Stop a generator from shrinking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.no.shrink(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.no.shrink_+3A_g">g</code></td>
<td>
<p>a generator we wish to remove shrinking
from</p>
</td></tr>
</table>

<hr>
<h2 id='gen.recursive'>Build recursive structures in a way that guarantees termination.</h2><span id='topic+gen.recursive'></span>

<h3>Description</h3>

<p>This will choose between the recursive and non-recursive terms,
while shrinking the size of the recursive calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.recursive(tails, heads)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.recursive_+3A_tails">tails</code></td>
<td>
<p>a list of generators which should not contain
recursive terms.</p>
</td></tr>
<tr><td><code id="gen.recursive_+3A_heads">heads</code></td>
<td>
<p>a list of generator which may contain recursive
terms.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a tree with integer leaves
treeGen &lt;-
  gen.recursive(
    # The non-recursive cases
    list(
      gen.int(100)
    )
  , # The recursive cases
    list(
      gen.list( treeGen )
    )
  )
</code></pre>

<hr>
<h2 id='gen.run'>Run a generator</h2><span id='topic+gen.run'></span>

<h3>Description</h3>

<p>Samples from a generator or list of generators
producing a (single) lazy rose tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.run(generator, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.run_+3A_generator">generator</code></td>
<td>
<p>A generator</p>
</td></tr>
<tr><td><code id="gen.run_+3A_size">size</code></td>
<td>
<p>The size parameter passed to the
generation functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is different to calling generarator$unGen(size)
in that it also works on (nested) lists of generators
and pure values.
</p>

<hr>
<h2 id='gen.shrink'>Helper to create a generator with a
shrink function.</h2><span id='topic+gen.shrink'></span>

<h3>Description</h3>

<p>shrinker takes an 'a and returns a vector of 'a.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.shrink(shrinker, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.shrink_+3A_shrinker">shrinker</code></td>
<td>
<p>a function takes an 'a and
returning a vector of 'a.</p>
</td></tr>
<tr><td><code id="gen.shrink_+3A_g">g</code></td>
<td>
<p>a generator we wish to add shrinking
to</p>
</td></tr>
</table>

<hr>
<h2 id='gen.sized'>Sized generator creation</h2><span id='topic+gen.sized'></span>

<h3>Description</h3>

<p>Helper for making a gen with a size parameter.
Pass a function which takes an int and returns
a gen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.sized(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.sized_+3A_f">f</code></td>
<td>
<p>the function, taking a size and
returning a generator</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gen.sized ( function(e) gen.element(1:e) )
</code></pre>

<hr>
<h2 id='gen.structure'>Generate a structure</h2><span id='topic+gen.structure'></span>

<h3>Description</h3>

<p>If you can create an object with <code>structure</code>,
you should be able to generate an object with
this function from a generator or list of
generators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.structure(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.structure_+3A_x">x</code></td>
<td>
<p>an object generator which will have various attributes attached to it.</p>
</td></tr>
<tr><td><code id="gen.structure_+3A_...">...</code></td>
<td>
<p>attributes, specified in 'tag = value' form, which will be
attached to generated data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gen.structure accepts the same forms of data
as forall, and is flexible, in that any list
of generators is considered to be a generator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To create a matrix
gen.structure( gen.c(of = 6, gen.element(1:30)), dim = 3:2)

# To create a data frame for testing.
gen.structure (
  list ( gen.c(of = 4, gen.element(2:10))
       , gen.c(of = 4, gen.element(2:10))
       , c('a', 'b', 'c', 'd')
       )
  , names = c('a','b', 'constant')
  , class = 'data.frame'
  , row.names = c('1', '2', '3', '4' ))
</code></pre>

<hr>
<h2 id='gen.unif'>Generate a float between the from
and to the values specified.</h2><span id='topic+gen.unif'></span>

<h3>Description</h3>

<p>Shrinks towards the <code>from</code> value, or
if <code>shrink.median</code> is on, the middle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.unif(from, to, shrink.median = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.unif_+3A_from">from</code></td>
<td>
<p>same as from in runif</p>
</td></tr>
<tr><td><code id="gen.unif_+3A_to">to</code></td>
<td>
<p>same as to in runif</p>
</td></tr>
<tr><td><code id="gen.unif_+3A_shrink.median">shrink.median</code></td>
<td>
<p>whether to shrink
to the middle of the distribution
instead of the low end.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gen.unif(0, 1) # a float between 0 and 1
</code></pre>

<hr>
<h2 id='generate'>Compose generators</h2><span id='topic+generate'></span>

<h3>Description</h3>

<p>Use 'generator' with a for loop over the output of another
generator to create a new, more interesting generator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate(loop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_loop">loop</code></td>
<td>
<p>A 'for' loop expression, where the value
iterated over is another Hedgehog generator.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>[gen-monad()] for FP style ways of sequencing
generators. This function is syntactic sugar over
'gen.and_then' to make it palatable for R users.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_squares   &lt;- generate(for (i in gen.int(10)) i^2)
gen_sq_digits &lt;- generate(for (i in gen_squares) {
  gen.c(of = i, gen.element(1:9))
})
</code></pre>

<hr>
<h2 id='shrink.halves'>Shrink a number by dividing it into halves.</h2><span id='topic+shrink.halves'></span>

<h3>Description</h3>

<p>Shrink a number by dividing it into halves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink.halves(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink.halves_+3A_x">x</code></td>
<td>
<p>number to produce halves of</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>shrink.towards(45)
# 22 11  5  2  1
</code></pre>

<hr>
<h2 id='shrink.list'>Shrink a list by edging towards the empty list.</h2><span id='topic+shrink.list'></span>

<h3>Description</h3>

<p>Shrink a list by edging towards the empty list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink.list(xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink.list_+3A_xs">xs</code></td>
<td>
<p>the list to shrink</p>
</td></tr>
</table>

<hr>
<h2 id='shrink.removes'>Produce permutations of removing num elements from a list.</h2><span id='topic+shrink.removes'></span>

<h3>Description</h3>

<p>Produce permutations of removing num elements from a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink.removes(num, xs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink.removes_+3A_num">num</code></td>
<td>
<p>the number of values to drop</p>
</td></tr>
<tr><td><code id="shrink.removes_+3A_xs">xs</code></td>
<td>
<p>the list to shrink</p>
</td></tr>
</table>

<hr>
<h2 id='shrink.towards'>Shrink an integral number by edging towards a destination.</h2><span id='topic+shrink.towards'></span>

<h3>Description</h3>

<p>Note we always try the destination first, as that is the optimal shrink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrink.towards(destination)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrink.towards_+3A_destination">destination</code></td>
<td>
<p>the value we want to shrink towards.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>shrink.towards (0) (100)
# [0,50,75,88,94,97,99]

shrink.towards(500)(1000)
# [500,750,875,938,969,985,993,997,999]

shrink.towards (-50) (-26)
# [-50,-38,-32,-29,-27]
</code></pre>

<hr>
<h2 id='symbolic'>A symbolic value.</h2><span id='topic+symbolic'></span>

<h3>Description</h3>

<p>These values are the outputs of a computation
during the calculations' construction, and
allow a value to use the results of a previous
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolic(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolic_+3A_var">var</code></td>
<td>
<p>the integer output indicator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Really, this is just an integer, which we use
as a name for a value which will exist later
in the computation.
</p>

<hr>
<h2 id='tree'>Lazy rose trees</h2><span id='topic+tree'></span><span id='topic+tree'></span><span id='topic+tree.map'></span><span id='topic+tree.bind'></span><span id='topic+tree.liftA2'></span><span id='topic+tree.expand'></span><span id='topic+tree.unfold'></span><span id='topic+tree.unfoldForest'></span><span id='topic+tree.sequence'></span>

<h3>Description</h3>

<p>A rose tree is a type of multibranch tree.
This is hedgehog's internal implementation
of a lazy rose tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(root, children_ = list())

tree.map(f, x)

tree.bind(f, x)

tree.liftA2(f, x, y)

tree.expand(shrink, x)

tree.unfold(shrink, a)

tree.unfoldForest(shrink, a)

tree.sequence(trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_+3A_root">root</code></td>
<td>
<p>the root of the rose tree</p>
</td></tr>
<tr><td><code id="tree_+3A_children_">children_</code></td>
<td>
<p>a list of children for the tree.</p>
</td></tr>
<tr><td><code id="tree_+3A_f">f</code></td>
<td>
<p>a function for mapping, binding, or applying</p>
</td></tr>
<tr><td><code id="tree_+3A_x">x</code></td>
<td>
<p>a tree to map or bind over</p>
</td></tr>
<tr><td><code id="tree_+3A_y">y</code></td>
<td>
<p>a tree to map or bind over</p>
</td></tr>
<tr><td><code id="tree_+3A_shrink">shrink</code></td>
<td>
<p>a shrinking function</p>
</td></tr>
<tr><td><code id="tree_+3A_a">a</code></td>
<td>
<p>a value to unfold from</p>
</td></tr>
<tr><td><code id="tree_+3A_trees">trees</code></td>
<td>
<p>a tree, or list or structure potentially
containing trees to turn into a tree of
said structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, one should not be required to
use any of the functions from this module
as the combinators in the gen module
should be expressive enough (if they're
not raise an issue).
</p>

<hr>
<h2 id='tree.replicate'>Creating trees of lists</h2><span id='topic+tree.replicate'></span><span id='topic+tree.replicate'></span><span id='topic+tree.replicateS'></span>

<h3>Description</h3>

<p>Build a tree of a list, potentially
keeping hold of an internal state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree.replicate(num, ma, ...)

tree.replicateS(num, ma, s, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree.replicate_+3A_num">num</code></td>
<td>
<p>the length of the list in the tree</p>
</td></tr>
<tr><td><code id="tree.replicate_+3A_ma">ma</code></td>
<td>
<p>a function which (randomly) creates
new tree to add to the list</p>
</td></tr>
<tr><td><code id="tree.replicate_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to the tree
generating function</p>
</td></tr>
<tr><td><code id="tree.replicate_+3A_s">s</code></td>
<td>
<p>a state used when replicating to
keep track of.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
