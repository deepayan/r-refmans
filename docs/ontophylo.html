<!DOCTYPE html><html><head><title>Help for package ontophylo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ontophylo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_noise_MD'><p>Adding noise to MDS from one stochastic character map</p></a></li>
<li><a href='#add_pseudodata'><p>Add pseudodata</p></a></li>
<li><a href='#anat_plot'><p>Plot Picture</p></a></li>
<li><a href='#color.bar'><p>Color bar</p></a></li>
<li><a href='#derivative_KDE'><p>Calculate KDE derivative over edges</p></a></li>
<li><a href='#discr_Simmap'><p>Reading unsummarized simmap for one tree</p></a></li>
<li><a href='#discr_Simmap_all'><p>Reading unsummarized simmap for a list of trees</p></a></li>
<li><a href='#edge_profiles4plotting'><p>Make edge profiles for plotting</p></a></li>
<li><a href='#edgeplot'><p>Plot edge profiles and contMap</p></a></li>
<li><a href='#estimate_band_W'><p>Estimate bandwidth</p></a></li>
<li><a href='#estimate_edge_KDE'><p>Estimate the normalized Markov KDE</p></a></li>
<li><a href='#estimate_edge_KDE_Markov_kernel_unnorm'><p>Estimate the unnormalized Markov KDE</p></a></li>
<li><a href='#get_descendants_chars'><p>Get characters that are the descendants of a selected ontology term</p></a></li>
<li><a href='#get_path_edges'><p>Get edges IDs from root to a given node.</p></a></li>
<li><a href='#get_rough_state_cols'><p>Multiple character state colors</p></a></li>
<li><a href='#get_state'><p>Get state name for contMap plotting.</p></a></li>
<li><a href='#get_states_path'><p>Get state information about a given path.</p></a></li>
<li><a href='#get_vector_ids_list'><p>Wrapper for getting vector layer IDs for multiple terms</p></a></li>
<li><a href='#get_vector_ids_per_term'><p>Get vector layer IDs for single term</p></a></li>
<li><a href='#HAO'><p>Hymenoptera Anatomy Ontology (HAO)</p></a></li>
<li><a href='#hym_annot'><p>Hymenoptera character annotations</p></a></li>
<li><a href='#hym_graph'><p>Hymenoptera graphics information</p></a></li>
<li><a href='#hym_hm'><p>Hamming distances object (Hymenoptera example)</p></a></li>
<li><a href='#hym_img'><p>Hymenoptera vector image</p></a></li>
<li><a href='#hym_kde'><p>pNHPP rates object (Hymenoptera example)</p></a></li>
<li><a href='#hym_matrix'><p>Hymenoptera character matrix</p></a></li>
<li><a href='#hym_nhpp'><p>Changing times object (Hymenoptera example)</p></a></li>
<li><a href='#hym_stm'><p>Hymenoptera stochastic character maps</p></a></li>
<li><a href='#hym_stm_amalg'><p>Hymenoptera amalgamated stochastic character maps</p></a></li>
<li><a href='#hym_stm_mds'><p>Hymenoptera amalgamated phenome</p></a></li>
<li><a href='#hym_tree'><p>Hymenoptera dated tree</p></a></li>
<li><a href='#integrate_edge_KDE'><p>Calculate KDE integral over edges</p></a></li>
<li><a href='#join_edges'><p>Join neighboring edges in edge profiles.</p></a></li>
<li><a href='#KDE_unnorm_trunc_Markov'><p>KDE for unnormalized Markov kernel vectorized.</p></a></li>
<li><a href='#KDE_unnormalized_scalar_Markov_kernel'><p>KDE for unnormalized Markov kernel.</p></a></li>
<li><a href='#list2edges'><p>Convert list to edge matrix</p></a></li>
<li><a href='#loess_smoothing_KDE'><p>Get loess smoothing for the unnormalized Markov KDE</p></a></li>
<li><a href='#make_colors'><p>Make color palette for image plotting</p></a></li>
<li><a href='#make_colors_relative_scale'><p>Make color palette for image plotting with relative scale</p></a></li>
<li><a href='#make_contMap_KDE'><p>Make contMap KDE object</p></a></li>
<li><a href='#make_data_NHPP_KDE_Markov_kernel'><p>Get NHPP data for all edges (Markov KDE)</p></a></li>
<li><a href='#make_data_NHPP_over_edge_MarkovKDE'><p>Get NHPP data for a given edge (Markov KDE)</p></a></li>
<li><a href='#make_pic'><p>Assign colors to picture ID layers</p></a></li>
<li><a href='#make_postPois_KDE'><p>Make posterior distribution of NHPP</p></a></li>
<li><a href='#mds_plot'><p>Plot morphospace from MDS</p></a></li>
<li><a href='#merge_branch_cat'><p>Merge state bins over branch</p></a></li>
<li><a href='#merge_tree_cat'><p>Merge state bins over a tree</p></a></li>
<li><a href='#merge_tree_cat_list'><p>Merge state bins over a tree list</p></a></li>
<li><a href='#MultiScale.simmap'><p>Multidimensional scaling of character states from one stochastic character map</p></a></li>
<li><a href='#normalize_KDE'><p>Normalize loess smoothing</p></a></li>
<li><a href='#paramo'><p>PARAMO</p></a></li>
<li><a href='#paramo.list'><p>Stack multiple discrete stochastic character map lists</p></a></li>
<li><a href='#path_hamming'><p>Path hamming</p></a></li>
<li><a href='#path_hamming_over_all_edges'><p>Hamming distances for a tree</p></a></li>
<li><a href='#path_hamming_over_trees_KDE'><p>Hamming distances for a list of trees</p></a></li>
<li><a href='#pNHPP'><p>Phylogenetic Non-Homogeneous Poisson Process (pNHPP) method</p></a></li>
<li><a href='#posterior_lambda_KDE'><p>Get analytical posterior</p></a></li>
<li><a href='#posterior_lambda_KDE_Distr'><p>Get distributions of analytical posterior</p></a></li>
<li><a href='#RAC_query'><p>Retrieve all characters under a given set of terms</p></a></li>
<li><a href='#read_Simmap_Rev'><p>Reading stochastic character maps file from ReVBayes</p></a></li>
<li><a href='#stack_stm'><p>Stack two discrete stochastic character maps.</p></a></li>
<li><a href='#stack2'><p>Stack two discrete stochastic character map lists; x and y are the list of state names (i.e. maps).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Ontology-Informed Phylogenetic Comparative Analyses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides new tools for analyzing discrete trait data integrating bio-ontologies and phylogenetics. It expands on the previous work of Tarasov et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fisd%2Fixz009">doi:10.1093/isd/ixz009</a>&gt;. The PARAMO pipeline allows to reconstruct ancestral phenomes treating groups of morphological traits as a single complex character. The pipeline incorporates knowledge from ontologies during the amalgamation of individual character stochastic maps.
  Here we expand the current PARAMO functionality by adding new statistical methods for inferring evolutionary phenome dynamics using non-homogeneous Poisson process (NHPP). The new functionalities include: (1) reconstruction of evolutionary rate shifts of phenomes across lineages and time; (2) reconstruction of morphospace dynamics through time; and (3) estimation of rates of phenome evolution at different levels of anatomical hierarchy (e.g., entire body or specific regions only). The package also includes user-friendly tools for visualizing evolutionary rates of different anatomical regions using vector images of the organisms of interest.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/diegosasso/ontophylo">https://github.com/diegosasso/ontophylo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/diegosasso/ontophylo/issues">https://github.com/diegosasso/ontophylo/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, tidyr, purrr, tibble, ggplot2, stringdist,
ape, phytools, ontologyIndex, RColorBrewer, grid, truncnorm,
fANCOVA, grImport</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, roxygen2, testthat (&ge; 3.0.0), stringr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 08:44:44 UTC; diego</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego S. Porto <a href="https://orcid.org/0000-0002-1657-9606"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sergei Tarasov <a href="https://orcid.org/0000-0001-5237-2330"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diego S. Porto &lt;diegosporto@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 10:33:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_noise_MD'>Adding noise to MDS from one stochastic character map</h2><span id='topic+add_noise_MD'></span>

<h3>Description</h3>

<p>Adds noise to the points in the 2D coordinates in the MDS plot.
# The noise is calculated as var(V)*add.noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise_MD(MD, add.noise)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_noise_MD_+3A_md">MD</code></td>
<td>
<p>tibble. The output of a MD_morpho function.</p>
</td></tr>
<tr><td><code id="add_noise_MD_+3A_add.noise">add.noise</code></td>
<td>
<p>numeric. A vector of length 2 indicating the amount of noise to be added to the x and y coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tibbles as in the output of MD_morpho functions, with noise added.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_mds")
# Select a few taxa from main lineages of Hymenoptera.
tax &lt;- c("Xyela", "Tenthredo", "Orussus", "Pimpla",
         "Ceraphron", "Evania", "Pison",
         "Ibalia", "Proctotrupes", "Chiloe") 
drop_tax &lt;- hym_stm_mds$tip.label[!hym_stm_mds$tip.label %in% tax]
hym_stm_mds &lt;- phytools::drop.tip.simmap(hym_stm_mds, drop_tax)
# Get a sample of amalgamated stochastic map (phenome).
tree &lt;- merge_tree_cat(hym_stm_mds)



  # Multidimensional scaling for an arbitrary tree.
  MD &lt;- suppressWarnings(MultiScale.simmap(tree))

  # Add noise.
  add_noise_MD(MD, c(0.3, 0.3))



</code></pre>

<hr>
<h2 id='add_pseudodata'>Add pseudodata</h2><span id='topic+add_pseudodata'></span>

<h3>Description</h3>

<p>Adds a vector of pseudodata to the path data obtained from the 'make_data_NHPP_KDE_Markov_kernel' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pseudodata(Edge.groups, Pseudo.data, Path.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pseudodata_+3A_edge.groups">Edge.groups</code></td>
<td>
<p>list. A list with groups of edge IDs.</p>
</td></tr>
<tr><td><code id="add_pseudodata_+3A_pseudo.data">Pseudo.data</code></td>
<td>
<p>numeric. A vector with values of pdeusodata.</p>
</td></tr>
<tr><td><code id="add_pseudodata_+3A_path.data">Path.data</code></td>
<td>
<p>numeric. A list of path data obtained from the 'make_data_NHPP_KDE_Markov_kernel' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of path data with the pseudodata added.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_hm", "hym_tree")
# Get hamming data from the head characters.
hm &lt;- hym_hm$head
# Make NHPP path data.
nhpp &lt;- make_data_NHPP_KDE_Markov_kernel(hm, add.psd = FALSE)
# Add pseudo data to path data.
psd &lt;- lapply(nhpp, function(x) -x[x &lt; 100] )
edge_groups &lt;- as.list(1:length(hym_tree$edge.length))
nhpp_psd &lt;- add_pseudodata(Edge.groups = edge_groups, Pseudo.data = psd, Path.data = nhpp)
# Check NHPP path data plus pseudodata for an arbitrary branch.
nhpp_psd[[5]]

</code></pre>

<hr>
<h2 id='anat_plot'>Plot Picture</h2><span id='topic+anat_plot'></span>

<h3>Description</h3>

<p>Wrapper function for making a plot of an object of class 'Picture' using the 'make_pic' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anat_plot(picture, anat_layers, plot_stat, color_palette, scale_lim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anat_plot_+3A_picture">picture</code></td>
<td>
<p>grImport object. A vector image imported in R using the 'readPicture' function from grImport.</p>
</td></tr>
<tr><td><code id="anat_plot_+3A_anat_layers">anat_layers</code></td>
<td>
<p>numeric. A named vector with the layer IDs obtained using the 'get_vector_ids_list' function.</p>
</td></tr>
<tr><td><code id="anat_plot_+3A_plot_stat">plot_stat</code></td>
<td>
<p>numeric. A named vector with values corresponding to the branch statistics to be plotted and names matching the names in the layer IDs.</p>
</td></tr>
<tr><td><code id="anat_plot_+3A_color_palette">color_palette</code></td>
<td>
<p>A character vector or function defining a color palette.</p>
</td></tr>
<tr><td><code id="anat_plot_+3A_scale_lim">scale_lim</code></td>
<td>
<p>numeric. A pair of values defining the lower and upper limits of the scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the object of class 'Picture' with the assigned colors to different anatomical regions.
</p>


<h3>Author(s)</h3>

<p>Diego Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO", "hym_graph", "hym_img", "hym_kde")
# Get picture.
picture &lt;- hym_img
# Get picture layers from three anatomical regions.
terms_list &lt;- as.list(c("HAO:0000397", "HAO:0000576", "HAO:0000626"))
terms_list &lt;- setNames(terms_list, c("head", "mesosoma", "metasoma"))
anat_layers &lt;- get_vector_ids_list(terms = terms_list , ONT = HAO, GR = hym_graph)
# Get mean rates all branches for the three anatomical regions.
plot_stat &lt;- lapply(hym_kde, function(x) unlist(lapply(x$loess.lambda.mean, function(x) mean(x) )) )
plot_stat &lt;- do.call(cbind, plot_stat)
# Add two columns for the other anatomical regions (just for this example).
plot_stat &lt;- cbind(plot_stat, plot_stat*0.75, plot_stat*0.5)
colnames(plot_stat) &lt;- c("head", "mesosoma", "metasoma")
# Select an arbitrary branch.
plot_stat &lt;- plot_stat[5,]
# Set scale.
scale_lim &lt;- range(plot_stat)
# Get color palette.
hm.palette &lt;- colorRampPalette(RColorBrewer::brewer.pal(9, "Spectral"), space = "Lab")

# Plot picture.
anat_plot(picture, anat_layers, plot_stat, hm.palette(100), scale_lim)

</code></pre>

<hr>
<h2 id='color.bar'>Color bar</h2><span id='topic+color.bar'></span>

<h3>Description</h3>

<p>Function to plot the color scale bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color.bar(
  pal,
  min,
  max = -min,
  nticks = 11,
  ticks = seq(min, max, len = nticks),
  title = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color.bar_+3A_pal">pal</code></td>
<td>
<p>character. A vector with color IDs.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_min">min</code></td>
<td>
<p>numeric. Value for lower limit of the scale.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_max">max</code></td>
<td>
<p>numeric. Value for upper limit of the scale.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_nticks">nticks</code></td>
<td>
<p>integer. Number of subdivisions of the scale.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_ticks">ticks</code></td>
<td>
<p>integer. A vector of values for the scale.</p>
</td></tr>
<tr><td><code id="color.bar_+3A_title">title</code></td>
<td>
<p>character. A legend for the scale bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the color scale bar.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat &lt;- runif(10, 0.25, 1)
hm.palette &lt;- colorRampPalette(RColorBrewer::brewer.pal(9, "Spectral"), space = "Lab")
color.bar(hm.palette(100), min = min(stat), max = max(stat),
          ticks = round(c(min(stat), max(stat)/2, max(stat)), 2), title = "")

</code></pre>

<hr>
<h2 id='derivative_KDE'>Calculate KDE derivative over edges</h2><span id='topic+derivative_KDE'></span>

<h3>Description</h3>

<p>Calculates the derivative of the normalized Markov KDE or normalized loess smoothing over edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative_KDE(tree.discr, Edge.KDE.stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="derivative_KDE_+3A_edge.kde.stat">Edge.KDE.stat</code></td>
<td>
<p>list. A list with the estimated normalized or loess smoothing KDEs for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the distribution of the derivatives calculated for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_tree", "hym_kde")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get smoothing of normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
Edge_KDE_stat &lt;- Edge_KDE$loess.lambda.mean
# Calculate derivatives.
Edge_KDE$loess.lambda.mean.deriv &lt;- derivative_KDE(tree_discr, Edge_KDE_stat)
# Check derivatives of some arbitrary branch.
Edge_KDE$loess.lambda.mean.deriv[[5]]

</code></pre>

<hr>
<h2 id='discr_Simmap'>Reading unsummarized simmap for one tree</h2><span id='topic+discr_Simmap'></span>

<h3>Description</h3>

<p>Discretizes tree edges into identical bins given a selected resolution value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr_Simmap(tree, res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discr_Simmap_+3A_tree">tree</code></td>
<td>
<p>simmap or phylo object.</p>
</td></tr>
<tr><td><code id="discr_Simmap_+3A_res">res</code></td>
<td>
<p>integer. A resolution value for the discretization of tree edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simmap or phylo object.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
tree &lt;- hym_stm[[1]][[1]]
stm_discr &lt;- discr_Simmap(tree, res = 100)
# Check some arbitrary branch.
tree$maps[[8]]
stm_discr$maps[[8]]
sum(tree$maps[[8]])
sum(stm_discr$maps[[8]])

</code></pre>

<hr>
<h2 id='discr_Simmap_all'>Reading unsummarized simmap for a list of trees</h2><span id='topic+discr_Simmap_all'></span>

<h3>Description</h3>

<p>Discretizes tree edges of a list of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discr_Simmap_all(tree, res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discr_Simmap_all_+3A_tree">tree</code></td>
<td>
<p>multiSimmap or multiPhylo object.</p>
</td></tr>
<tr><td><code id="discr_Simmap_all_+3A_res">res</code></td>
<td>
<p>integer. A resolution value for the discretization of tree edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multiSimmap or multiPhylo object.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
tree_list &lt;- hym_stm[[1]]
stm_discr_list &lt;- discr_Simmap_all(tree_list, res = 100)
# Check some arbitrary branch of some arbitrary tree.
tree_list[[1]]$maps[[8]]
stm_discr_list[[1]]$maps[[8]]
sum(tree_list[[1]]$maps[[8]])
sum(stm_discr_list[[1]]$maps[[8]])

</code></pre>

<hr>
<h2 id='edge_profiles4plotting'>Make edge profiles for plotting</h2><span id='topic+edge_profiles4plotting'></span>

<h3>Description</h3>

<p>Gets the information necessary for making an edgeplot, where the tree is plotted in a space where the x axis is the time and y axis the scale of the desired statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_profiles4plotting(tree.discr, Edge.KDE.stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_profiles4plotting_+3A_tree.discr">tree.discr</code></td>
<td>
<p>phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="edge_profiles4plotting_+3A_edge.kde.stat">Edge.KDE.stat</code></td>
<td>
<p>list. A list with the distributions of the estimated parameter of KDEs for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with X and Y coordinates and other information necessary for making an edgeplot.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_tree", "hym_kde")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get smoothing of normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
Edge_KDE_stat &lt;- Edge_KDE$loess.lambda.mean
# Make edgeplot nhpp data.
stat_prof &lt;- edge_profiles4plotting(tree_discr, Edge_KDE_stat)

</code></pre>

<hr>
<h2 id='edgeplot'>Plot edge profiles and contMap</h2><span id='topic+edgeplot'></span>

<h3>Description</h3>

<p>Wrapper function for plotting edge profiles and contmap from NHPP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeplot(map_stat, prof_stat, plot.cont = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeplot_+3A_map_stat">map_stat</code></td>
<td>
<p>contMap object. A contMap obtained using the 'make_contMap_KDE' function.</p>
</td></tr>
<tr><td><code id="edgeplot_+3A_prof_stat">prof_stat</code></td>
<td>
<p>tibble. A tibble with the edgeplot information obtained using the 'edge_profiles4plotting' function.</p>
</td></tr>
<tr><td><code id="edgeplot_+3A_plot.cont">plot.cont</code></td>
<td>
<p>logical. Whether to plot also the contMap or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the edge profiles and contMap of the selected statistic (e.g. branch rates).
</p>


<h3>Author(s)</h3>

<p>Diego Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_tree", "hym_kde")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get smoothing of normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
Edge_KDE_stat &lt;- Edge_KDE$loess.lambda.mean
# Make contmap nhpp data.
map_stat &lt;- make_contMap_KDE(tree_discr, Edge_KDE_stat)
# Make edgeplot nhpp data.
prof_stat &lt;- edge_profiles4plotting(tree_discr, Edge_KDE_stat)
# Plot.
suppressWarnings(edgeplot(map_stat, prof_stat))

</code></pre>

<hr>
<h2 id='estimate_band_W'>Estimate bandwidth</h2><span id='topic+estimate_band_W'></span>

<h3>Description</h3>

<p>Estimate the bandwidth for the Markov KDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_band_W(
  tree.discr,
  data.path,
  band.width = c("bw.nrd0", "bw.nrd0", "bw.ucv", "bw.bcv", "bw.SJ")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_band_W_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="estimate_band_W_+3A_data.path">data.path</code></td>
<td>
<p>list. A list of path data obtained from the 'make_data_NHPP_KDE_Markov_kernel' function.</p>
</td></tr>
<tr><td><code id="estimate_band_W_+3A_band.width">band.width</code></td>
<td>
<p>character. Bandwidth selectors for the KDE, as in density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_hm", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get hamming data from the head characters.
hm &lt;- hym_hm$head
# Make NHPP path data.
nhpp_psd &lt;- make_data_NHPP_KDE_Markov_kernel(hm, add.psd = TRUE)
# Calculate bandwidth.
bdw &lt;- estimate_band_W(tree_discr, nhpp_psd, band.width = "bw.nrd0")
mean(bdw)

</code></pre>

<hr>
<h2 id='estimate_edge_KDE'>Estimate the normalized Markov KDE</h2><span id='topic+estimate_edge_KDE'></span>

<h3>Description</h3>

<p>Estimated the normalized Markov KDE for each edge averaged across all possible root-tip paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_edge_KDE(tree.discr, Path.data, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_edge_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="estimate_edge_KDE_+3A_path.data">Path.data</code></td>
<td>
<p>numeric. A list of path data obtained from the 'make_data_NHPP_KDE_Markov_kernel' function.</p>
</td></tr>
<tr><td><code id="estimate_edge_KDE_+3A_h">h</code></td>
<td>
<p>numeric. A value for the bandwidth calculated using the 'estimate_band_W' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the estimated unnormalized ($Maps.mean) and normalized ($Maps.mean.norm) KDEs for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_nhpp", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Make NHPP path data.
nhpp &lt;- hym_nhpp$head
# Add pseudo data to path data.
psd &lt;- lapply(nhpp, function(x) -x[x &lt; 100] )
edge_groups &lt;- as.list(1:length(hym_tree$edge.length))
nhpp_psd &lt;- add_pseudodata(Edge.groups = edge_groups, Pseudo.data = psd, Path.data = nhpp)
# Calculate bandwidth.
bdw &lt;- estimate_band_W(tree_discr, nhpp_psd, band.width = "bw.nrd0")
bdw &lt;- mean(bdw)
# Estimate non-normalized and normalized edge KDE.
Edge_KDE &lt;- estimate_edge_KDE(tree_discr, nhpp_psd, h = bdw)
# Check KDE data for normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean.norm[[5]]
# Check KDE data for non-normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean[[5]]

</code></pre>

<hr>
<h2 id='estimate_edge_KDE_Markov_kernel_unnorm'>Estimate the unnormalized Markov KDE</h2><span id='topic+estimate_edge_KDE_Markov_kernel_unnorm'></span>

<h3>Description</h3>

<p>Estimated the unnormalized Markov KDE for each edge averaged across all possible root-tip paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_edge_KDE_Markov_kernel_unnorm(tree.discr, Path.data, h = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_edge_KDE_Markov_kernel_unnorm_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="estimate_edge_KDE_Markov_kernel_unnorm_+3A_path.data">Path.data</code></td>
<td>
<p>numeric. A list of path data obtained from the 'make_data_NHPP_KDE_Markov_kernel' function.</p>
</td></tr>
<tr><td><code id="estimate_edge_KDE_Markov_kernel_unnorm_+3A_h">h</code></td>
<td>
<p>numeric. A value for the bandwidth calculated using the 'estimate_band_W' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the estimated unnormalized KDEs ($Maps.mean) for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_nhpp", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Make NHPP path data.
nhpp &lt;- hym_nhpp$head
# Add pseudo data to path data.
psd &lt;- lapply(nhpp, function(x) -x[x &lt; 100] )
edge_groups &lt;- as.list(1:length(hym_tree$edge.length))
nhpp_psd &lt;- add_pseudodata(Edge.groups = edge_groups, Pseudo.data = psd, Path.data = nhpp)
# Calculate bandwidth.
bdw &lt;- estimate_band_W(tree_discr, nhpp_psd, band.width = "bw.nrd0")
bdw &lt;- mean(bdw)
# Estimate non-normalized and normalized edge KDE.
Edge_KDE &lt;- estimate_edge_KDE_Markov_kernel_unnorm(tree_discr, nhpp_psd, h = bdw)
# Check KDE data for non-normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean[[5]]

</code></pre>

<hr>
<h2 id='get_descendants_chars'>Get characters that are the descendants of a selected ontology term</h2><span id='topic+get_descendants_chars'></span>

<h3>Description</h3>

<p>Returns all characters located (associated) with a given ontology term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_descendants_chars(ontology, annotations = "auto", terms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_descendants_chars_+3A_ontology">ontology</code></td>
<td>
<p>ontology_index object.</p>
</td></tr>
<tr><td><code id="get_descendants_chars_+3A_annotations">annotations</code></td>
<td>
<p>character. Sets which annotations to use: &quot;auto&quot; means automatic annotations, &quot;manual&quot; means manual annotations.
Alternatively, any other list of element containing annotations can be specified.</p>
</td></tr>
<tr><td><code id="get_descendants_chars_+3A_terms">terms</code></td>
<td>
<p>character. IDs of ontology terms for which descendants are queried.</p>
</td></tr>
<tr><td><code id="get_descendants_chars_+3A_...">...</code></td>
<td>
<p>other parameters for ontologyIndex::get_descendants() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of character IDs.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO")
HAO$terms_selected_id &lt;- list("CH1" = c("HAO:0000653"), "CH2" = c("HAO:0000653"))
get_descendants_chars(HAO, annotations = "manual", "HAO:0000653")

</code></pre>

<hr>
<h2 id='get_path_edges'>Get edges IDs from root to a given node.</h2><span id='topic+get_path_edges'></span>

<h3>Description</h3>

<p>Get edges IDs from root to a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_path_edges(tree.merge, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_path_edges_+3A_tree.merge">tree.merge</code></td>
<td>
<p>simmap object.</p>
</td></tr>
<tr><td><code id="get_path_edges_+3A_node">node</code></td>
<td>
<p>integer.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='get_rough_state_cols'>Multiple character state colors</h2><span id='topic+get_rough_state_cols'></span>

<h3>Description</h3>

<p>Get state colors for ploting stochastic character maps when there many states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rough_state_cols(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rough_state_cols_+3A_tree">tree</code></td>
<td>
<p>simmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with colors associated with state names.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg")
# Get one sample of stochastic map from head.
tree &lt;- hym_stm_amalg$head[[5]]
# Plot one amalgamated stochastic map from head.
phytools::plotSimmap(tree, get_rough_state_cols(tree), 
lwd = 3, pts = FALSE,ftype = "off")

</code></pre>

<hr>
<h2 id='get_state'>Get state name for contMap plotting.</h2><span id='topic+get_state'></span>

<h3>Description</h3>

<p>Internal function. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state(vec, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_+3A_vec">vec</code></td>
<td>
<p>numeric. A vector of intervals defining bins.</p>
</td></tr>
<tr><td><code id="get_state_+3A_x">x</code></td>
<td>
<p>numeric. A target value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diego Porto
</p>

<hr>
<h2 id='get_states_path'>Get state information about a given path.</h2><span id='topic+get_states_path'></span>

<h3>Description</h3>

<p>Get state information about a given path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_states_path(tree.merge, node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_states_path_+3A_tree.merge">tree.merge</code></td>
<td>
<p>simmap object.</p>
</td></tr>
<tr><td><code id="get_states_path_+3A_node">node</code></td>
<td>
<p>integer.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='get_vector_ids_list'>Wrapper for getting vector layer IDs for multiple terms</h2><span id='topic+get_vector_ids_list'></span>

<h3>Description</h3>

<p>Given an ontology_index object, data.frame with ontology term labels, and data.frame with picture information (see examples),
produces a named vector with layer IDs to be used in the 'make_pic' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vector_ids_list(terms_list, ONT, GR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vector_ids_list_+3A_terms_list">terms_list</code></td>
<td>
<p>list. A named list with ontology terms to get layer IDs for.
The first column corresponds to the ontology term labels, the second to the ontology IDs.</p>
</td></tr>
<tr><td><code id="get_vector_ids_list_+3A_ont">ONT</code></td>
<td>
<p>ontology_index object.</p>
</td></tr>
<tr><td><code id="get_vector_ids_list_+3A_gr">GR</code></td>
<td>
<p>data.frame. A data.frame with the picture information. It contains the matches between all ontology term labels and layer IDs in the Picture object.
The first column corresponds to the ontology term labels, the second to the ontology IDs, and the third to the layer IDs in the Picture object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the layer IDs corresponding to or descending from the ontology term label queried.
</p>


<h3>Author(s)</h3>

<p>Diego S. Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO", "hym_graph")
# Get picture layers from three anatomical regions.
terms_list &lt;- as.list(c("HAO:0000397", "HAO:0000576", "HAO:0000626"))
terms_list &lt;- setNames(terms_list, c("head", "mesosoma", "metasoma"))
get_vector_ids_list(terms = terms_list , ONT = HAO, GR = hym_graph)

</code></pre>

<hr>
<h2 id='get_vector_ids_per_term'>Get vector layer IDs for single term</h2><span id='topic+get_vector_ids_per_term'></span>

<h3>Description</h3>

<p>Given an ontology_index object, ontology term label, and data.frame with picture information (see examples),
produces a named vector with layer IDs to be used in the 'make_pic' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vector_ids_per_term(term = "HAO:0000349", ONT, GR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_vector_ids_per_term_+3A_term">term</code></td>
<td>
<p>character. An ontology term label to get the corresponding layer IDs in the Picture object.</p>
</td></tr>
<tr><td><code id="get_vector_ids_per_term_+3A_ont">ONT</code></td>
<td>
<p>ontology_index object.</p>
</td></tr>
<tr><td><code id="get_vector_ids_per_term_+3A_gr">GR</code></td>
<td>
<p>data.frame. A data.frame with the picture information. It contains the matches between all ontology term labels and layer IDs in the Picture object.
The first column corresponds to the ontology term labels, the second to the ontology IDs, and the third to the layer IDs in the Picture object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the layer IDs corresponding to or descending from the ontology term label queried.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO", "hym_graph")
# Get picture layers from head.
get_vector_ids_per_term(term = "HAO:0000397", ONT = HAO, GR = hym_graph)

</code></pre>

<hr>
<h2 id='HAO'>Hymenoptera Anatomy Ontology (HAO)</h2><span id='topic+HAO'></span>

<h3>Description</h3>

<p>The anatomy ontology of Hymenoptera (Yoder et al. 2010). This same ontology was also used in Tarasov et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HAO
</code></pre>


<h3>Format</h3>

<p>List containing various ontological relationships and terms.
</p>


<h3>References</h3>

<p>Tarasov, S., Mikó, I. &amp; Yoder, M.J. (2022) ontoFAST: an r package for interactive and semi-automatic annotation of characters with biological ontologies. Methods in Ecology and Evolution, 13, 324–329.
(<a href="https://doi.org/10.1111/2041-210X.13753">doi:10.1111/2041-210X.13753</a>)
</p>
<p>Yoder MJ, Mikó I, Seltmann KC, Bertone MA, Deans AR. 2010. A Gross Anatomy Ontology for Hymenoptera. PLoS ONE 5 (12): e15991.
(<a href="https://doi.org/10.1371/journal.pone.0015991">doi:10.1371/journal.pone.0015991</a>)
</p>
<p><a href="http://portal.hymao.org/projects/32/public/ontology/">Hymenoptera Anatomy Ontology Portal</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HAO)
</code></pre>

<hr>
<h2 id='hym_annot'>Hymenoptera character annotations</h2><span id='topic+hym_annot'></span>

<h3>Description</h3>

<p>The character annotations from the first example data set used in the showcase analyses in Porto et al. (2023).
The annotations comprise the character ids, ontology term ids, and term labels used for each character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_annot
</code></pre>


<h3>Format</h3>

<p>A data table with three columns and 30 rows; &quot;char_id&quot; contains character ids (e.g., &quot;CH1&quot;, &quot;CH2&quot;, &quot;CH3&quot;);
&quot;onto_id&quot; contains ontology term ids from the HAO ontology (e.g., &quot;HAO:0000234&quot;, &quot;HAO:0000101&quot;, &quot;HAO:0000639&quot;);
&quot;label&quot; contains the respective ontology term labels (e.g., &quot;cranium&quot;, &quot;antenna&quot;, &quot;mouthparts&quot;).
Rows indicate characters.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_annot) 
</code></pre>

<hr>
<h2 id='hym_graph'>Hymenoptera graphics information</h2><span id='topic+hym_graph'></span>

<h3>Description</h3>

<p>Example of annotations of anatomy terms from the Hymenoptera Anatomy Ontology (HAO)
to layers representing anatomical entities in a vector image of a hymenopteran wasp.
This data object is used to run the examples of the ontophyo package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_graph
</code></pre>


<h3>Format</h3>

<p>A data table with three columns; &quot;Term&quot; contains the ontology term labels (e.g., &quot;cranium&quot;, &quot;antenna&quot;);
&quot;ID&quot; contains the respective ontology term ids from the HAO ontology (e.g., &quot;HAO:0000234&quot;, &quot;HAO:0000101&quot;);
&quot;pic_id&quot; contains the layer ids of the corresponding anatomical entities in the vector image of a hymenopteran wasp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_graph)
</code></pre>

<hr>
<h2 id='hym_hm'>Hamming distances object (Hymenoptera example)</h2><span id='topic+hym_hm'></span>

<h3>Description</h3>

<p>Hamming distances data object from the amalgamated characters of &quot;head&quot;
obtained from the first example data set used in the showcase analyses in Porto et al. (2023).
The Hamming distances data object was obtained using the function &quot;path_hamming_over_trees_KDE&quot;.
This data object is used to run the examples of the ontophyo package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_hm
</code></pre>


<h3>Format</h3>

<p>A data table with 11 columns; &quot;t.start&quot; contains the starting times of mapped states; 
&quot;t.end&quot; contains the ending times of mapped states; &quot;States&quot; contains the amalgamated states; 
&quot;Edge.id&quot; contains the edge ids onto the tree; &quot;delta.t&quot; contains the duration of each mapped state;
&quot;Ham.dist&quot; contains the Hamming distances from the root state;
&quot;Ham.dist.n&quot; contains the normalized Hamming distances from the root state;
&quot;Pois.count&quot; contains the number of discrete changes;
&quot;Focal.Edge.id&quot;, &quot;tree.id&quot;, and &quot;tree.tip.id&quot; contain internal ids used by the package functions.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_hm)
</code></pre>

<hr>
<h2 id='hym_img'>Hymenoptera vector image</h2><span id='topic+hym_img'></span>

<h3>Description</h3>

<p>Example of a vector image of a hymenopteran wasp.
The original vector image in PostScript format was converted to XML format using (<a href="https://www.ghostscript.com/">GhostScript</a>)
and the function &quot;PostScriptTrace&quot; from 'grImport' (Murrell, 2009).
Then the XML file was imported into R using the function &quot;readPicture&quot; also from 'grImport'.
This data object is used to run the examples of the ontophyo package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_img
</code></pre>


<h3>Format</h3>

<p>A data object of class &quot;grImport&quot;.
</p>


<h3>References</h3>

<p>Murrell, P. (2009). Importing vector graphics: The grimport package for r. Journal of Statistical Software, 30:1–37.
(<a href="https://doi.org/10.18637/jss.v030.i04">doi:10.18637/jss.v030.i04</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_img)
</code></pre>

<hr>
<h2 id='hym_kde'>pNHPP rates object (Hymenoptera example)</h2><span id='topic+hym_kde'></span>

<h3>Description</h3>

<p>The data object contains pNHPP rates estimated for the amalgamated characters of &quot;head&quot;
obtained from the first example data set used in the showcase analyses in Porto et al. (2023).
The data object contains the estimated rates for all edges of the tree sample;
$Maps.mean and $Maps.mean.norm contain the raw and normalized rates estimated using the function &quot;estimate_edge_KDE&quot;; 
$Maps.mean.loess and $Maps.mean.loess.norm contain the smoothed raw and normalized rates estimated using the function &quot;loess_smoothing_KDE&quot;;
$lambda.mean, $loess.lambda.mean, and $loess.lambda.mean.deriv contain the posteriors estimated for the raw and normalized rates, and its derivative.
This data object is used to run the examples of the ontophyo package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_kde
</code></pre>


<h3>Format</h3>

<p>List containing pNHPP rates estimated for all edges of the tree sample.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_kde)
</code></pre>

<hr>
<h2 id='hym_matrix'>Hymenoptera character matrix</h2><span id='topic+hym_matrix'></span>

<h3>Description</h3>

<p>The character matrix from the first example data set used in the showcase analyses in Porto et al. (2023).
The dataset comprises 30 simulated binary characters and the original matrix was reduced to contain only the 
20 representative taxa used for the package examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_matrix
</code></pre>


<h3>Format</h3>

<p>A data table with 20 rows and 30 columns; each row indicates a species and each column a character.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_matrix) 
</code></pre>

<hr>
<h2 id='hym_nhpp'>Changing times object (Hymenoptera example)</h2><span id='topic+hym_nhpp'></span>

<h3>Description</h3>

<p>Changing times data object from the amalgamated characters of &quot;head&quot;
obtained from the first example data set used in the showcase analyses in Porto et al. (2023).
The changing times data object was obtained using the function &quot;make_data_NHPP_KDE_Markov_kernel&quot;.
This data object is used to run the examples of the ontophyo package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_nhpp
</code></pre>


<h3>Format</h3>

<p>List containing changing times between states for all edges of the tree sample.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_nhpp)
</code></pre>

<hr>
<h2 id='hym_stm'>Hymenoptera stochastic character maps</h2><span id='topic+hym_stm'></span>

<h3>Description</h3>

<p>List of stochastic character maps obtained from all characters of 
the first example data set used in the showcase analyses in Porto et al. (2023). 
Only 50 samples per character were included to reduce file size (originally 100 samples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_stm
</code></pre>


<h3>Format</h3>

<p>List containing 30 objects of class &quot;multiSimmap&quot;.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_stm)
</code></pre>

<hr>
<h2 id='hym_stm_amalg'>Hymenoptera amalgamated stochastic character maps</h2><span id='topic+hym_stm_amalg'></span>

<h3>Description</h3>

<p>List of amalgamated stochastic character maps obtained from  
the first example data set used in the showcase analyses in Porto et al. (2023). 
Character were amalgamated into groups of 10 characters representing 
three anatomical regions of Hymenoptera: &quot;head&quot;, &quot;mesosoma&quot;, and &quot;metasoma&quot;.
Only 50 samples per character were included to reduce file size (originally 100 samples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_stm_amalg
</code></pre>


<h3>Format</h3>

<p>List containing three objects of class &quot;multiPhylo&quot;.
</p>


<h3>References</h3>

<p>Porto, D.S., Uyeda, J., Mikó, I. &amp; Tarasov, S. (2023) Supporting Data: ontophylo: Reconstructing the evolutionary dynamics of phenomes using new ontology-informed phylogenetic methods.
(<a href="https://doi.org/10.5281/zenodo.10285424">doi:10.5281/zenodo.10285424</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_stm_amalg)
</code></pre>

<hr>
<h2 id='hym_stm_mds'>Hymenoptera amalgamated phenome</h2><span id='topic+hym_stm_mds'></span>

<h3>Description</h3>

<p>Example of a stochastic character map obtained from the amalgamation of 394 characters
modified from the matrix of Sharkey et al. (2011) and using the tree from Klopfstein et al. (2013).
The tree was dated using penalized likelihood as implemented in TreePL (Smith &amp; O’Meara, 2012).
This data object is used to run the examples of the ontophyo morphospace application.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_stm_mds
</code></pre>


<h3>Format</h3>

<p>An stochastic character map of class &quot;simmap&quot;.
</p>


<h3>References</h3>

<p>Sharkey, M.J., et al. 2011. Phylogenetic relationships among superfamilies of Hymenoptera. Cladistics 28(1), 80-112.
(<a href="https://doi.org/10.1111/j.1096-0031.2011.00366.x">doi:10.1111/j.1096-0031.2011.00366.x</a>)
</p>
<p>Klopfstein, S., Vilhelmsen, L., Heraty, J.M., Sharkey, M. &amp; Ronquist, F. (2013) The hymenopteran tree of life: evidence from protein-coding genes and objectively aligned ribosomal data. PLoS One, 8, e69344.
(<a href="https://doi.org/10.1371/journal.pone.0069344">doi:10.1371/journal.pone.0069344</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_stm_mds)
</code></pre>

<hr>
<h2 id='hym_tree'>Hymenoptera dated tree</h2><span id='topic+hym_tree'></span>

<h3>Description</h3>

<p>A phylogenetic tree modified from Klopfstein et al. (2013).
The tree was dated using penalized likelihood as implemented in TreePL (Smith &amp; O’Meara, 2012) and
then pruned to contain 20 representative taxa used for the package examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hym_tree
</code></pre>


<h3>Format</h3>

<p>A phylogenetic tree of class &quot;phylo&quot;.
</p>


<h3>References</h3>

<p>Klopfstein, S., Vilhelmsen, L., Heraty, J.M., Sharkey, M. &amp; Ronquist, F. (2013) The hymenopteran tree of life: evidence from protein-coding genes and objectively aligned ribosomal data. PLoS One, 8, e69344.
(<a href="https://doi.org/10.1371/journal.pone.0069344">doi:10.1371/journal.pone.0069344</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hym_tree)
</code></pre>

<hr>
<h2 id='integrate_edge_KDE'>Calculate KDE integral over edges</h2><span id='topic+integrate_edge_KDE'></span>

<h3>Description</h3>

<p>Checks the integral of normalized Markov KDE or normalized loess smoothing over edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_edge_KDE(tree.discr, Edge.KDE.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_edge_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="integrate_edge_KDE_+3A_edge.kde.list">Edge.KDE.list</code></td>
<td>
<p>list. A list with the normalized KDEs or loess smoothing for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value for the integral over all edges.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_kde", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get non-normalized and normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
# Check integrals.
integrate_edge_KDE(tree_discr, Edge_KDE$Maps.mean.norm)
integrate_edge_KDE(tree_discr, Edge_KDE$Maps.mean.loess.norm)

</code></pre>

<hr>
<h2 id='join_edges'>Join neighboring edges in edge profiles.</h2><span id='topic+join_edges'></span>

<h3>Description</h3>

<p>Internal function. Not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_edges(tree.discr, edge.profs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_edges_+3A_tree.discr">tree.discr</code></td>
<td>
<p>phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="join_edges_+3A_edge.profs">edge.profs</code></td>
<td>
<p>tibble. A tibble with edge profile information.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='KDE_unnorm_trunc_Markov'>KDE for unnormalized Markov kernel vectorized.</h2><span id='topic+KDE_unnorm_trunc_Markov'></span>

<h3>Description</h3>

<p>KDE for unnormalized Markov kernel vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDE_unnorm_trunc_Markov(x, h, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KDE_unnorm_trunc_Markov_+3A_x">x</code></td>
<td>
<p>numeric. A vector with global changing times.</p>
</td></tr>
<tr><td><code id="KDE_unnorm_trunc_Markov_+3A_h">h</code></td>
<td>
<p>numeric. The bandwidth value.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
<tr><td><code id="KDE_unnorm_trunc_Markov_+3A_dat">dat</code></td>
<td>
<p>numeric. A vector with path data values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='KDE_unnormalized_scalar_Markov_kernel'>KDE for unnormalized Markov kernel.</h2><span id='topic+KDE_unnormalized_scalar_Markov_kernel'></span>

<h3>Description</h3>

<p>KDE for unnormalized Markov kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDE_unnormalized_scalar_Markov_kernel(x, h, dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KDE_unnormalized_scalar_Markov_kernel_+3A_x">x</code></td>
<td>
<p>numeric. A vector with global changing times.</p>
</td></tr>
<tr><td><code id="KDE_unnormalized_scalar_Markov_kernel_+3A_h">h</code></td>
<td>
<p>numeric. The bandwidth value.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
<tr><td><code id="KDE_unnormalized_scalar_Markov_kernel_+3A_dat">dat</code></td>
<td>
<p>numeric. A vector with path data values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='list2edges'>Convert list to edge matrix</h2><span id='topic+list2edges'></span>

<h3>Description</h3>

<p>Takes a list of charater annotations and creates an edge matrix comprising two columns: from and to.
The list to table conversion can be done using ldply function from plyr package: plyr::ldply(list, rbind).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2edges(annotated.char.list, col_order_inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2edges_+3A_annotated.char.list">annotated.char.list</code></td>
<td>
<p>character list. A character list with ontology annotations.</p>
</td></tr>
<tr><td><code id="list2edges_+3A_col_order_inverse">col_order_inverse</code></td>
<td>
<p>logical. The default creates the first columns consisting of character IDs and the second columns consisting of ontology annotations.
The inverse order changes the columns order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two-column matrix.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>annot_list &lt;- list("CH1" = c("HAO:0000933", "HAO:0000958"), "CH2" = c("HAO:0000833", "HAO:0000258"))
list2edges(annot_list)

</code></pre>

<hr>
<h2 id='loess_smoothing_KDE'>Get loess smoothing for the unnormalized Markov KDE</h2><span id='topic+loess_smoothing_KDE'></span>

<h3>Description</h3>

<p>Calculates loess smoothing for the unnormalized Markov KDE obtained from the 'estimate_edge_KDE_Markov_kernel_unnorm' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loess_smoothing_KDE(tree.discr, Edge.KDE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loess_smoothing_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="loess_smoothing_KDE_+3A_edge.kde">Edge.KDE</code></td>
<td>
<p>list. A list with the estimated unnormalized KDEs ($Maps.mean) for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the loess smoothing calculated for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_kde", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get non-normalized and normalized edge KDE data.
Edge_KDE &lt;- hym_kde$head
# Calculate smoothing of edge KDE data.
Edge_KDE$Maps.mean.loess &lt;- suppressWarnings(loess_smoothing_KDE(tree_discr, Edge_KDE))
# Check smoothing of KDE data for normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean.loess.norm[[5]]
# Check smoothing of KDE data for non-normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean.loess[[5]]

</code></pre>

<hr>
<h2 id='make_colors'>Make color palette for image plotting</h2><span id='topic+make_colors'></span>

<h3>Description</h3>

<p>Produces a color scale for a given statistic of evolutionary rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_colors(Stat, palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_colors_+3A_stat">Stat</code></td>
<td>
<p>numeric. A named vector where values are the statistics, and names are ontology term labels.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_palette">palette</code></td>
<td>
<p>A character vector or function defining a color palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector where elements are color IDs and names are the input ontology term labels.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat &lt;- setNames(runif(5, 0.1, 10), 
c("cranium", "fore_wing", "hind_wing", "pronotum", "propectus") )
hm.palette &lt;- colorRampPalette(RColorBrewer::brewer.pal(9, "Spectral"), space = "Lab")
cols.maps &lt;- make_colors(stat, palette = hm.palette(100))
cols.maps

</code></pre>

<hr>
<h2 id='make_colors_relative_scale'>Make color palette for image plotting with relative scale</h2><span id='topic+make_colors_relative_scale'></span>

<h3>Description</h3>

<p>Produces a relative color scale for a given statistic of evolutionary rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_colors_relative_scale(Stat, palette, lims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_colors_relative_scale_+3A_stat">Stat</code></td>
<td>
<p>numeric. A named vector where values are the statistics, and names are ontology term labels.</p>
</td></tr>
<tr><td><code id="make_colors_relative_scale_+3A_palette">palette</code></td>
<td>
<p>A character vector or function defining a color palette.</p>
</td></tr>
<tr><td><code id="make_colors_relative_scale_+3A_lims">lims</code></td>
<td>
<p>numeric. A pair of values defining the lower and upper limits of the scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector where elements are color IDs and names are the input ontology term labels.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat &lt;- setNames(runif(5, 0.1, 10), 
c("cranium", "fore_wing", "hind_wing", "pronotum", "propectus") )
hm.palette &lt;- colorRampPalette(RColorBrewer::brewer.pal(9, "Spectral"), space = "Lab")
cols.maps &lt;- make_colors_relative_scale(stat, palette = hm.palette(100), 
lims = c(min(stat), max(stat)))
cols.maps

</code></pre>

<hr>
<h2 id='make_contMap_KDE'>Make contMap KDE object</h2><span id='topic+make_contMap_KDE'></span>

<h3>Description</h3>

<p>Produces a contMap object for plotting the NHPP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_contMap_KDE(tree.discr, Edge.KDE.stat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_contMap_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="make_contMap_KDE_+3A_edge.kde.stat">Edge.KDE.stat</code></td>
<td>
<p>list. A list with the distributions of the estimated parameter of KDEs for each edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'contMap' object.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_tree", "hym_kde")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get smoothing of normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
Edge_KDE_stat &lt;- Edge_KDE$loess.lambda.mean
# Make contmap nhpp data.
nhpp_map &lt;- make_contMap_KDE(tree_discr, Edge_KDE_stat)
# Plot contmap.
phytools::plot.contMap(nhpp_map, lwd = 3, outline = FALSE,
legend = FALSE, ftype = "off", plot = FALSE)

</code></pre>

<hr>
<h2 id='make_data_NHPP_KDE_Markov_kernel'>Get NHPP data for all edges (Markov KDE)</h2><span id='topic+make_data_NHPP_KDE_Markov_kernel'></span>

<h3>Description</h3>

<p>Gets data on changing times between states for all edges of a given sample of trees for the Markov kernel density estimator (KDE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_NHPP_KDE_Markov_kernel(Tb.trees, add.psd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_NHPP_KDE_Markov_kernel_+3A_tb.trees">Tb.trees</code></td>
<td>
<p>data.frame. A tibble obtained with the 'path_hamming_over_trees_KDE' function.</p>
</td></tr>
<tr><td><code id="make_data_NHPP_KDE_Markov_kernel_+3A_add.psd">add.psd</code></td>
<td>
<p>logical. Whether to add pseudodata or not. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with changing times between states for all edges of a given sample of trees.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_hm")
# Get hamming data from the head characters.
hm &lt;- hym_hm$head
# Make NHPP path data.
nhpp &lt;- make_data_NHPP_KDE_Markov_kernel(hm)
# Check NHPP path data for an arbitrary branch.
nhpp[[5]]

</code></pre>

<hr>
<h2 id='make_data_NHPP_over_edge_MarkovKDE'>Get NHPP data for a given edge (Markov KDE)</h2><span id='topic+make_data_NHPP_over_edge_MarkovKDE'></span>

<h3>Description</h3>

<p>Gets data on changing times between states for a given edge of a given sample of trees for the Markov kernel density estimator (KDE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_data_NHPP_over_edge_MarkovKDE(Tb.trees, Focal.Edge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_data_NHPP_over_edge_MarkovKDE_+3A_tb.trees">Tb.trees</code></td>
<td>
<p>data.frame. A tibble obtained with the 'path_hamming_over_trees_KDE' function.</p>
</td></tr>
<tr><td><code id="make_data_NHPP_over_edge_MarkovKDE_+3A_focal.edge">Focal.Edge</code></td>
<td>
<p>integer. A value indicating the edge ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with changing times between states for a given edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>
<p>Internal function. Not exported.
</p>

<hr>
<h2 id='make_pic'>Assign colors to picture ID layers</h2><span id='topic+make_pic'></span>

<h3>Description</h3>

<p>Assigns colors to picture ID layers (@paths) of an object of class 'Picture'.
The object should be a PS or ESP vector illustration imported using the grImport package.
Colors are taken from cols.maps argument were the palette indicates the scale of the desired statistics for the evolutionary rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pic(picture, layers, cols.maps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pic_+3A_picture">picture</code></td>
<td>
<p>grImport object. A vector image imported in R using the 'readPicture' function from grImport.</p>
</td></tr>
<tr><td><code id="make_pic_+3A_layers">layers</code></td>
<td>
<p>numeric. A named vector where values indicate the layer IDs in the Picture object and names indicate the anatomy ontology term labels.</p>
</td></tr>
<tr><td><code id="make_pic_+3A_cols.maps">cols.maps</code></td>
<td>
<p>character. A named vector where elements correspond to color IDs and names indicate the anatomy ontology term labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'Picture' with the assigned colors to different anatomical regions.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO", "hym_graph", "hym_img", "hym_kde")
# Get picture.
picture &lt;- hym_img
# Get picture layers from three anatomical regions.
terms_list &lt;- as.list(c("HAO:0000397", "HAO:0000576", "HAO:0000626"))
terms_list &lt;- setNames(terms_list, c("head", "mesosoma", "metasoma"))
anat_layers &lt;- get_vector_ids_list(terms = terms_list , ONT = HAO, GR = hym_graph)
# Get mean rates all branches for the three anatomical regions.
plot_stat &lt;- lapply(hym_kde, function(x) unlist(lapply(x$loess.lambda.mean, function(x) mean(x) )) )
plot_stat &lt;- do.call(cbind, plot_stat)
# Add two columns for the other anatomical regions (just for this example).
plot_stat &lt;- cbind(plot_stat, plot_stat*0.75, plot_stat*0.5)
colnames(plot_stat) &lt;- c("head", "mesosoma", "metasoma")
# Select an arbitrary branch.
plot_stat &lt;- plot_stat[5,]
# Set scale.
scale_lim &lt;- range(plot_stat)
# Get color palette.
hm.palette &lt;- colorRampPalette(RColorBrewer::brewer.pal(9, "Spectral"), space = "Lab")
cols_maps &lt;- make_colors_relative_scale(plot_stat, palette = hm.palette(100),
                                        lims = scale_lim)
# Plot picture.
new_pic &lt;- make_pic(picture, anat_layers, cols_maps)
grImport::grid.picture(new_pic)

</code></pre>

<hr>
<h2 id='make_postPois_KDE'>Make posterior distribution of NHPP</h2><span id='topic+make_postPois_KDE'></span>

<h3>Description</h3>

<p>Produces a posterior distribution from a given list of statistics calculated with the 'posterior_lambda_KDE' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_postPois_KDE(Edge.KDE.stat, lambda.post, lambda.post.stat = "Mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_postPois_KDE_+3A_edge.kde.stat">Edge.KDE.stat</code></td>
<td>
<p>list. A list with the estimated normalized or loess smoothing KDEs for each edge.</p>
</td></tr>
<tr><td><code id="make_postPois_KDE_+3A_lambda.post">lambda.post</code></td>
<td>
<p>list. A list with the distribution statistics calculated with the 'posterior_lambda_KDE' function.</p>
</td></tr>
<tr><td><code id="make_postPois_KDE_+3A_lambda.post.stat">lambda.post.stat</code></td>
<td>
<p>character. A value with the statistic to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the distribution of the selected statistic for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg", "hym_kde")
# Get a sample of ten stochastic maps from head.
tree_list &lt;- hym_stm_amalg$head[1:10]
tree_list &lt;- merge_tree_cat_list(tree_list)
# Calculate posterior poisson statistics.
lambda_post &lt;- posterior_lambda_KDE(tree_list)
# Get smoothing of normalized edge KDE data for mean rates.
Edge_KDE &lt;- hym_kde$head
Edge_KDE_stat &lt;- Edge_KDE$Maps.mean.loess.norm
# Make posterior poisson distribution.
Edge_KDE$lambda.mean &lt;- make_postPois_KDE(Edge_KDE_stat, lambda_post, lambda.post.stat = "Mean")
# Check posterior poisson of some arbitrary branch.
plot(density(Edge_KDE$lambda.mean[[5]]), main = "", xlab = "Rates")

</code></pre>

<hr>
<h2 id='mds_plot'>Plot morphospace from MDS</h2><span id='topic+mds_plot'></span>

<h3>Description</h3>

<p>Wrapper function for plotting morphospaces obtained using the MultiScale.simmap' function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mds_plot(MD, Tslice = max(MD$Points$time))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mds_plot_+3A_md">MD</code></td>
<td>
<p>list. A list with the morphospace information obtained using the 'MultiScale.simmap' function.</p>
</td></tr>
<tr><td><code id="mds_plot_+3A_tslice">Tslice</code></td>
<td>
<p>numeric. The value for the temporal slices to be plotted, from root to tip. For example, if Tslice = 25, then all points in the morphospaces from time 0 (root) to 25 will be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class ggplot with the morphospace to be plotted.
</p>


<h3>Author(s)</h3>

<p>Diego Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Select a few taxa from main lineages of Hymenoptera.
tax &lt;- c("Xyela", "Tenthredo", "Orussus", "Pimpla",
         "Ceraphron", "Evania", "Pison",
         "Ibalia", "Proctotrupes", "Chiloe") 
drop_tax &lt;- hym_stm_mds$tip.label[!hym_stm_mds$tip.label %in% tax]
hym_stm_mds &lt;- phytools::drop.tip.simmap(hym_stm_mds, drop_tax)
# Get a sample of amalgamated stochastic map (phenome).
tree &lt;- merge_tree_cat(hym_stm_mds)

 
  # Multidimensional scaling for an arbitrary tree.
  MD &lt;- suppressWarnings(MultiScale.simmap(tree))

  MD_plot &lt;- mds_plot(MD, Tslice = 10)
  MD_plot
  MD_plot &lt;- mds_plot(MD, Tslice = 50)
  MD_plot
  MD_plot &lt;- mds_plot(MD, Tslice = 200)
  MD_plot
  MD_plot &lt;- mds_plot(MD, Tslice = 280)
  MD_plot



</code></pre>

<hr>
<h2 id='merge_branch_cat'>Merge state bins over branch</h2><span id='topic+merge_branch_cat'></span>

<h3>Description</h3>

<p>Merges identical state bins over the same branch in the discretized stochastic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_branch_cat(br)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_branch_cat_+3A_br">br</code></td>
<td>
<p>numeric or character vector. The branches of the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric or character vector with merged identical bins.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
tree &lt;- hym_stm[[1]][[1]]
stm_discr &lt;- discr_Simmap(tree, res = 100)
# Check some arbitrary branch.
br1 &lt;- stm_discr$maps[[5]]
br1
br2 &lt;- merge_branch_cat(br1)
br2
sum(br1) == br2

</code></pre>

<hr>
<h2 id='merge_tree_cat'>Merge state bins over a tree</h2><span id='topic+merge_tree_cat'></span>

<h3>Description</h3>

<p>Merges identical state bins over a tree in the discretized stochastic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_tree_cat(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_tree_cat_+3A_tree">tree</code></td>
<td>
<p>simmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree with merged identical bins.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
tree &lt;- hym_stm[[1]][[1]]
tree &lt;- discr_Simmap(tree, res = 100)
stm_merg &lt;- merge_tree_cat(tree)
# Check some arbitrary branch.
br1 &lt;- tree$maps[[5]]
br1
br2 &lt;- stm_merg$maps[[5]]
br2
sum(br1) == br2

</code></pre>

<hr>
<h2 id='merge_tree_cat_list'>Merge state bins over a tree list</h2><span id='topic+merge_tree_cat_list'></span>

<h3>Description</h3>

<p>A wrapper function to merge identical state bins over a tree list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_tree_cat_list(tree.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_tree_cat_list_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trees with merged identical bins.
</p>


<h3>Author(s)</h3>

<p>Diego S. Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
tree_list &lt;- hym_stm[[1]]
tree_list &lt;- discr_Simmap_all(tree_list, res = 100)
stm_merg_list &lt;- merge_tree_cat_list(tree_list)
# Check some arbitrary branch of some arbitrary tree.
br1 &lt;- tree_list[[1]]$maps[[5]]
br1
br2 &lt;- stm_merg_list[[1]]$maps[[5]]
br2
sum(br1) == br2

</code></pre>

<hr>
<h2 id='MultiScale.simmap'>Multidimensional scaling of character states from one stochastic character map</h2><span id='topic+MultiScale.simmap'></span>

<h3>Description</h3>

<p>Performs multidimensional scaling (MDS) based on hamming distances among character state vectors from one stochastic character map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiScale.simmap(tree.merge, add.noise = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiScale.simmap_+3A_tree.merge">tree.merge</code></td>
<td>
<p>simmap object. A stochastic character map after being processed by the discr_Simmap and merge_tree_cat functions.</p>
</td></tr>
<tr><td><code id="MultiScale.simmap_+3A_add.noise">add.noise</code></td>
<td>
<p>numeric. A vector of length 2 or NULL. Indicates if noise should be added or not. Useful if there are many identical states occupying the same points in the 2D coordinates of the morphospace plot.
The noise is calculated as var(V)*add.noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tibbles &ndash; Points, Lines, and Edge.map &ndash; correponding to tree branch information to plot.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_mds")
# Select a few taxa from main lineages of Hymenoptera.
tax &lt;- c("Xyela", "Tenthredo", "Orussus", "Pimpla",
         "Ceraphron", "Evania", "Pison",
         "Ibalia", "Proctotrupes", "Chiloe") 
drop_tax &lt;- hym_stm_mds$tip.label[!hym_stm_mds$tip.label %in% tax]
hym_stm_mds &lt;- phytools::drop.tip.simmap(hym_stm_mds, drop_tax)
# Get a sample of amalgamated stochastic map (phenome).
tree &lt;- merge_tree_cat(hym_stm_mds)


  # Multidimensional scaling for an arbitrary tree.
  MD &lt;- suppressWarnings(MultiScale.simmap(tree))



</code></pre>

<hr>
<h2 id='normalize_KDE'>Normalize loess smoothing</h2><span id='topic+normalize_KDE'></span>

<h3>Description</h3>

<p>Normalizes the loess smoothing for the Markov KDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_KDE(tree.discr, Maps.mean.loess)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_KDE_+3A_tree.discr">tree.discr</code></td>
<td>
<p>simmap or phylo object. A discretized tree using the 'discr_Simmap' function.</p>
</td></tr>
<tr><td><code id="normalize_KDE_+3A_maps.mean.loess">Maps.mean.loess</code></td>
<td>
<p>list. A list with the loess smoothing calculated for each edge using the 'loess_smoothing_KDE' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the normalized loess smoothing calculated for each edge.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_kde", "hym_tree")
# Get reference tree.
tree_discr &lt;- discr_Simmap(hym_tree, res = 200)
# Get non-normalized and normalized edge KDE data.
Edge_KDE &lt;- hym_kde$head
# Calculate smoothing of edge KDE data.
Edge_KDE$Maps.mean.loess &lt;- suppressWarnings(loess_smoothing_KDE(tree_discr, Edge_KDE))
# Normalize smoothing edge KDE data.
Edge_KDE$Maps.mean.loess.norm &lt;- normalize_KDE(tree_discr, Edge_KDE$Maps.mean.loess)
# Check smoothing of KDE data for non-normalized mean rates from an arbitrary branch.
Edge_KDE$Maps.mean.loess[[5]]

</code></pre>

<hr>
<h2 id='paramo'>PARAMO</h2><span id='topic+paramo'></span>

<h3>Description</h3>

<p>Wrapper function to perform the final paramo stacking of maps for a set of anatomy ontology terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramo(rac_query, tree.list, ntrees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramo_+3A_rac_query">rac_query</code></td>
<td>
<p>character list. Named list obtained from the RAC_query function.</p>
</td></tr>
<tr><td><code id="paramo_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap or multiPhylo object. Named list with stochastic character maps.</p>
</td></tr>
<tr><td><code id="paramo_+3A_ntrees">ntrees</code></td>
<td>
<p>integer. Number of trees to stack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stacked stochastic character maps.
</p>


<h3>Author(s)</h3>

<p>Diego S. Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char_info &lt;- hym_annot[1:2]
# Query for three anatomical regions.
terms &lt;- c("head", "mesosoma", "metasoma")
query &lt;- RAC_query(char_info, HAO, terms)
# Select the first three characters for each anatomical region.
query &lt;- lapply(query, function(x) x[1:3])
# Subset the list of multiple maps.
tree_list &lt;- hym_stm[unname(unlist(query))]
tree_list &lt;- lapply(tree_list, function(x) discr_Simmap_all(x, res = 100))
tree_list_amalg &lt;- paramo(query, tree_list, ntrees = 50)
tree_list_amalg &lt;- lapply(tree_list_amalg, function(x) do.call(c,x) )
# Get one sample of map from head.
stm_hd &lt;- tree_list_amalg$head[[1]]
# Get one sample of map from mesosoma.
stm_ms &lt;- tree_list_amalg$mesosoma[[1]]
# Get one sample of map from metasoma.
stm_mt &lt;- tree_list_amalg$metasoma[[1]]
# Plot one amalgamated stochastic map from each anatomical region.
phytools::plotSimmap(stm_hd, get_rough_state_cols(stm_hd), 
lwd = 3, pts = FALSE,ftype = "off")
phytools::plotSimmap(stm_ms, get_rough_state_cols(stm_ms), 
lwd = 3, pts = FALSE,ftype = "off")
phytools::plotSimmap(stm_mt, get_rough_state_cols(stm_mt), 
lwd = 3, pts = FALSE,ftype = "off")

</code></pre>

<hr>
<h2 id='paramo.list'>Stack multiple discrete stochastic character map lists</h2><span id='topic+paramo.list'></span>

<h3>Description</h3>

<p>Performs the final stacking of maps for a set of stochastic character maps stored in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramo.list(cc, tree.list, ntrees = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramo.list_+3A_cc">cc</code></td>
<td>
<p>character. Characters IDs to stack.</p>
</td></tr>
<tr><td><code id="paramo.list_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap or multiPhylo object. Named list with stochastic character maps.</p>
</td></tr>
<tr><td><code id="paramo.list_+3A_ntrees">ntrees</code></td>
<td>
<p>integer. Number of trees to stack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of stacked stochastic character maps.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm")
# Select the first five characters.
tree_list &lt;- hym_stm[1:5]
tree_list &lt;- lapply(tree_list, function(x) discr_Simmap_all(x, res = 100))
tree_list_amalg &lt;- paramo.list(names(tree_list), tree_list, ntrees = 50)
tree_list_amalg &lt;- do.call(c, tree_list_amalg)
# Plot one amalgamated stochastic map.
phytools::plotSimmap(tree_list_amalg[[1]], get_rough_state_cols(tree_list_amalg[[1]]),  
lwd = 3, pts = FALSE,ftype = "off")

</code></pre>

<hr>
<h2 id='path_hamming'>Path hamming</h2><span id='topic+path_hamming'></span>

<h3>Description</h3>

<p>Calculates the hamming distance between states for a given path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_hamming(Path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_hamming_+3A_path">Path</code></td>
<td>
<p>data.frame. A tibble with state information about a given path (from root to a given node).
The tibble is the output obtained from the get_states_path function. The columns give information on state changes, time spent on each state, and edge IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input tibble with two additional columns giving information on absolute and normalized hamming distances.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>
<p>Internal function. Not exported.
</p>

<hr>
<h2 id='path_hamming_over_all_edges'>Hamming distances for a tree</h2><span id='topic+path_hamming_over_all_edges'></span>

<h3>Description</h3>

<p>Calculates hamming distances for all paths in a given discretized tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_hamming_over_all_edges(tree.merge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_hamming_over_all_edges_+3A_tree.merge">tree.merge</code></td>
<td>
<p>simmap object. A discretized simmap using the 'discr_Simmap' function where identical state bins were merged using the 'merge_tree_cat' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with information on state changes, time spent on each state, edge IDs, absolute and normalized hamming distances for all edges in a tree.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg")
# Get one sample of stochastic maps from head.
tree &lt;- hym_stm_amalg$head[[1]]
tree &lt;- merge_tree_cat(tree)


  # Calculate hamming distances.
  ph &lt;- suppressWarnings(path_hamming_over_all_edges(tree))
  ph



</code></pre>

<hr>
<h2 id='path_hamming_over_trees_KDE'>Hamming distances for a list of trees</h2><span id='topic+path_hamming_over_trees_KDE'></span>

<h3>Description</h3>

<p>Calculates hamming distances for all paths in each discretized tree of a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_hamming_over_trees_KDE(tree.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_hamming_over_trees_KDE_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with information on state changes, time spent on each state, edge IDs, absolute and normalized hamming distances for all edges and all trees in a list.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg")
# Get ten samples of stochastic maps from head.
tree_list &lt;- hym_stm_amalg$head[1:10]
tree_list &lt;- merge_tree_cat_list(tree_list)


  # Calculate hamming distances.
  ph &lt;- suppressWarnings(path_hamming_over_trees_KDE(tree_list))
  ph



</code></pre>

<hr>
<h2 id='pNHPP'>Phylogenetic Non-Homogeneous Poisson Process (pNHPP) method</h2><span id='topic+pNHPP'></span>

<h3>Description</h3>

<p>Wrapper function for applying the pNHPP method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pNHPP(
  stm_amalg,
  tree = tree,
  res = res,
  add.psd = TRUE,
  band.width = c("bw.nrd0", "bw.nrd0", "bw.ucv", "bw.bcv", "bw.SJ"),
  lambda.post.stat = "Mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pNHPP_+3A_stm_amalg">stm_amalg</code></td>
<td>
<p>multiSimmap object. A list of amalgamated stochastic maps.</p>
</td></tr>
<tr><td><code id="pNHPP_+3A_tree">tree</code></td>
<td>
<p>simmap or phylo object. A reference tree for discretization.</p>
</td></tr>
<tr><td><code id="pNHPP_+3A_res">res</code></td>
<td>
<p>integer. A resolution value for the discretization of tree edges.</p>
</td></tr>
<tr><td><code id="pNHPP_+3A_add.psd">add.psd</code></td>
<td>
<p>logical. Whether to add pseudodata or not in the 'make_data_NHPP_KDE_Markov_kernel' function. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pNHPP_+3A_band.width">band.width</code></td>
<td>
<p>character. Bandwidth selectors for the KDE in the 'estimate_band_W' function.</p>
</td></tr>
<tr><td><code id="pNHPP_+3A_lambda.post.stat">lambda.post.stat</code></td>
<td>
<p>character. A value with the statistic to be used in the 'make_postPois_KDE' function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the estimated Markov KDE for all edges, the contMap object for plotting the NHPP, and the information necessary for making the edgeplot.
</p>


<h3>Author(s)</h3>

<p>Diego Porto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  # Load data.
  data("hym_stm", "hym_stm_amalg")
  # Get a reference tree for discretization.
  tree &lt;- hym_stm[[1]][[1]]
  # Get ten samples of stochastic maps from head.
  tree_list &lt;- hym_stm_amalg$head[1:10]
  # Run the pNHPP method.
  nhpp_test &lt;- pNHPP(tree_list, tree, res = 500,
  add.psd = TRUE, band.width = 'bw.nrd', lambda.post.stat = 'Mean')



</code></pre>

<hr>
<h2 id='posterior_lambda_KDE'>Get analytical posterior</h2><span id='topic+posterior_lambda_KDE'></span>

<h3>Description</h3>

<p>Calculates the required statitics for the posterior distribution of number of state changes across all branches of all trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_lambda_KDE(tree.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_lambda_KDE_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with mean ($Mean), standard deviation ($SD), and 95HPD interval ($Q_2.5 and $Q_97.5) calculated for the posterior distribution.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg")
# Get a sample of ten stochastic maps from head.
tree_list &lt;- hym_stm_amalg$head
tree_list &lt;- merge_tree_cat_list(tree_list[1:10])
# Calculate posterior poisson statistics.
posterior_lambda_KDE(tree_list)

</code></pre>

<hr>
<h2 id='posterior_lambda_KDE_Distr'>Get distributions of analytical posterior</h2><span id='topic+posterior_lambda_KDE_Distr'></span>

<h3>Description</h3>

<p>Simulates a distribution of number of state changes across all branches of all trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_lambda_KDE_Distr(tree.list, n.sim = 10, BR.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_lambda_KDE_Distr_+3A_tree.list">tree.list</code></td>
<td>
<p>multiSimmap object.</p>
</td></tr>
<tr><td><code id="posterior_lambda_KDE_Distr_+3A_n.sim">n.sim</code></td>
<td>
<p>integer. Number of simulations.</p>
</td></tr>
<tr><td><code id="posterior_lambda_KDE_Distr_+3A_br.name">BR.name</code></td>
<td>
<p>character. A label name for the anatomical region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the simulated distribution.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("hym_stm_amalg")
# Get a sample of ten stochastic maps from head.
tree_list &lt;- hym_stm_amalg$head[1:10]
tree_list &lt;- merge_tree_cat_list(tree_list)
# Simulate posterior poisson distribution.
posterior_lambda_KDE_Distr(tree_list, n.sim = 10, BR.name = "head")

</code></pre>

<hr>
<h2 id='RAC_query'>Retrieve all characters under a given set of terms</h2><span id='topic+RAC_query'></span>

<h3>Description</h3>

<p>Returns a named list aggregating characters under a specified set of terms (e.g., body regions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAC_query(char_info, ONT, terms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RAC_query_+3A_char_info">char_info</code></td>
<td>
<p>data.frame. A data.frame with two columns: the first column with character IDs and the second column with ontology IDs.</p>
</td></tr>
<tr><td><code id="RAC_query_+3A_ont">ONT</code></td>
<td>
<p>ontology_index object.</p>
</td></tr>
<tr><td><code id="RAC_query_+3A_terms">terms</code></td>
<td>
<p>character. The set of terms to aggregate characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with character groups.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HAO", "hym_annot")
char_info &lt;- hym_annot[1:2]
# Query for three anatomical regions.
terms &lt;- c("head", "mesosoma", "metasoma")
query &lt;- RAC_query(char_info, HAO, terms)
query 

</code></pre>

<hr>
<h2 id='read_Simmap_Rev'>Reading stochastic character maps file from ReVBayes</h2><span id='topic+read_Simmap_Rev'></span>

<h3>Description</h3>

<p>Imports stochastic character maps file from RevBayes into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_Simmap_Rev(file, start = 1, end = 1, save = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_Simmap_Rev_+3A_file">file</code></td>
<td>
<p>character. Path to the RevBayes file.</p>
</td></tr>
<tr><td><code id="read_Simmap_Rev_+3A_start">start</code></td>
<td>
<p>integer. First tree of the sample to start reading the RevBayes file.</p>
</td></tr>
<tr><td><code id="read_Simmap_Rev_+3A_end">end</code></td>
<td>
<p>integer. Last tree of the sample to finish reading the RevBayes file.</p>
</td></tr>
<tr><td><code id="read_Simmap_Rev_+3A_save">save</code></td>
<td>
<p>character. Name to save output file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree in 'phylip' format.
</p>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rev_stm &lt;- "Iteration\t1\t2\t3\tsimmap\n
0\t{1,2.0}\t((spp1:{1,4.0:0,4.0},spp2:{1,2.0:0,6.0}):{1,0.5});\n
1\t{1,2.0}\t((spp1:{1,2.0:0,6.0},spp2:{1,3.0:0,5.0}):{1,0.5});\n
3\t{1,2.0}\t((spp1:{1,2.0:0,6.0},spp2:{1,3.0:0,5.0}):{1,0.5});"
stm &lt;- read_Simmap_Rev(textConnection(rev_stm, "r"), start = 0, end = 3, save = NULL)
stm &lt;- phytools::read.simmap(text = stm, format = "phylip")
phytools::plotSimmap(stm[[1]])

</code></pre>

<hr>
<h2 id='stack_stm'>Stack two discrete stochastic character maps.</h2><span id='topic+stack_stm'></span>

<h3>Description</h3>

<p>Stack two discrete stochastic character maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_stm(stm.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_stm_+3A_stm.list">stm.list</code></td>
<td>
<p>list. A list of stochastic maps to be amalgamated.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

<hr>
<h2 id='stack2'>Stack two discrete stochastic character map lists; x and y are the list of state names (i.e. maps).</h2><span id='topic+stack2'></span>

<h3>Description</h3>

<p>Stack two discrete stochastic character map lists; x and y are the list of state names (i.e. maps).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack2(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack2_+3A_x">x</code></td>
<td>
<p>list. A list of state names.</p>
</td></tr>
<tr><td><code id="stack2_+3A_y">y</code></td>
<td>
<p>list. A list of state names.
</p>
<p>Internal function. Not exported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sergei Tarasov
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
