<!DOCTYPE html><html lang="en"><head><title>Help for package Rvcg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rvcg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rvcg-package'><p>Interface between R and vcglib libraries for mesh operations</p></a></li>
<li><a href='#checkFaceOrientation'><p>check the orientation of a mesh</p></a></li>
<li><a href='#deprecated'><p>deprecated functions of Rvcg</p></a></li>
<li><a href='#dummyhead'><p>dummyhead - dummy head and landmarks</p></a></li>
<li><a href='#humface'><p>Example mesh and landmarks</p></a></li>
<li><a href='#meshInfo'><p>print number of vertices and triangular faces of a mesh</p></a></li>
<li><a href='#meshintegrity'><p>check if an object of class mesh3d contains valid data</p></a></li>
<li><a href='#nfaces'><p>get number of vertices from a mesh</p></a></li>
<li><a href='#nverts'><p>get number of vertices from a mesh</p></a></li>
<li><a href='#raysearchMulti'><p>Find all intersections of rays and a mesh</p></a></li>
<li><a href='#setRays'><p>helper function to create an object to be processed by vcgRaySearch</p></a></li>
<li><a href='#vcgArea'><p>compute surface area of a triangular mesh</p></a></li>
<li><a href='#vcgBallPivoting'><p>Ball pivoting surface reconstruction</p></a></li>
<li><a href='#vcgBary'><p>get barycenters of all faces of a triangular mesh</p></a></li>
<li><a href='#vcgBorder'><p>find all border vertices and faces of a triangular mesh</p></a></li>
<li><a href='#vcgClean'><p>Clean triangular surface meshes</p></a></li>
<li><a href='#vcgClost'><p>Project coordinates onto a target triangular surface mesh.</p></a></li>
<li><a href='#vcgClostKD'><p>Project coordinates onto a target triangular surface mesh using KD-tree search</p></a></li>
<li><a href='#vcgClostOnKDtreeFromBarycenters'><p>search a KD-tree from Barycenters for multiple closest point searches on a mesh</p></a></li>
<li><a href='#vcgCreateKDtree'><p>create a KD-tree</p></a></li>
<li><a href='#vcgCreateKDtreeFromBarycenters'><p>create a KD-tree from Barycenters for multiple closest point searches on a mesh</p></a></li>
<li><a href='#vcgCurve'><p>calculate curvature of a triangular mesh</p></a></li>
<li><a href='#vcgDijkstra'><p>Compute pseudo-geodesic distances on a triangular mesh</p></a></li>
<li><a href='#vcgFaceNormals'><p>Compute normalized face normals for a mesh.</p></a></li>
<li><a href='#vcgGeodesicPath'><p>Compute geodesic path and path length between vertices on a mesh</p></a></li>
<li><a href='#vcgGeodist'><p>Compute pseudo-geodesic distance between two points on a mesh</p></a></li>
<li><a href='#vcgGetEdge'><p>Get all edges of a triangular mesh</p></a></li>
<li><a href='#vcgImport'><p>Import common mesh file formats.</p></a></li>
<li><a href='#vcgIsolated'><p>Remove isolated pieces from a surface mesh or split into connected components</p></a></li>
<li><a href='#vcgIsosurface'><p>Create Isosurface from 3D-array</p></a></li>
<li><a href='#vcgIsotropicRemeshing'><p>Isotropically remesh a triangular surface mesh</p></a></li>
<li><a href='#vcgKDtree'><p>perform kdtree search for 3D-coordinates.</p></a></li>
<li><a href='#vcgKmeans'><p>fast Kmean clustering for 1D, 2D and 3D data</p></a></li>
<li><a href='#vcgMeshres'><p>calculates the average edge length of a triangular mesh</p></a></li>
<li><a href='#vcgMetro'><p>evaluate the difference between two triangular meshes.</p></a></li>
<li><a href='#vcgNonBorderEdge'><p>Get all non-border edges</p></a></li>
<li><a href='#vcgObjWrite'><p>Export meshes to OBJ-files</p></a></li>
<li><a href='#vcgOffWrite'><p>Export meshes to OFF-files</p></a></li>
<li><a href='#vcgPlyRead'><p>Import ascii or binary PLY files.</p></a></li>
<li><a href='#vcgPlyWrite'><p>Export meshes to PLY-files</p></a></li>
<li><a href='#vcgQEdecim'><p>Performs Quadric Edge Decimation on triangular meshes.</p></a></li>
<li><a href='#vcgRaySearch'><p>check if a mesh is intersected by a set of rays</p></a></li>
<li><a href='#vcgSample'><p>Subsamples points on a mesh surface</p></a></li>
<li><a href='#vcgSearchKDtree'><p>search an existing KD-tree</p></a></li>
<li><a href='#vcgSmooth'><p>Smoothes a triangular mesh</p></a></li>
<li><a href='#vcgSmoothImplicit'><p>Implicit Smoothes a triangular mesh</p></a></li>
<li><a href='#vcgSphere'><p>create platonic objects as triangular meshes</p></a></li>
<li><a href='#vcgStlWrite'><p>Export meshes to STL-files</p></a></li>
<li><a href='#vcgSubdivide'><p>subdivide the triangles of a mesh</p></a></li>
<li><a href='#vcgUniformRemesh'><p>Resample a mesh uniformly</p></a></li>
<li><a href='#vcgUpdateNormals'><p>updates vertex normals of a triangular meshes or point clouds</p></a></li>
<li><a href='#vcgVertexNeighbors'><p>Compute mesh adjacency list representation or the vertex neighborhoods of specific mesh vertices.</p></a></li>
<li><a href='#vcgVFadj'><p>find all faces belonging to each vertex in a mesh</p></a></li>
<li><a href='#vcgVolume'><p>Compute volume for manifold meshes</p></a></li>
<li><a href='#vcgWrlWrite'><p>Export meshes to WRL-files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Manipulations of Triangular Meshes Based on the 'VCGLIB' API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.25</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Operations on triangular meshes based on 'VCGLIB'. This package
    integrates nicely with the R-package 'rgl' to render the meshes processed by
    'Rvcg'. The Visualization and Computer Graphics Library (VCG for short) is
    an open source portable C++ templated library for manipulation, processing
    and displaying with OpenGL of triangle and tetrahedral meshes. The library,
    composed by more than 100k lines of code, is released under the GPL license,
    and it is the base of most of the software tools of the Visual Computing Lab of
    the Italian National Research Council Institute ISTI <a href="https://vcg.isti.cnr.it/">https://vcg.isti.cnr.it/</a>,
    like 'metro' and 'MeshLab'. The 'VCGLIB' source is pulled from trunk
    <a href="https://github.com/cnr-isti-vclab/vcglib">https://github.com/cnr-isti-vclab/vcglib</a> and patched to work with options
    determined by the configure script as well as to work with the header files
    included by 'RcppEigen'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Morpho, rgl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zarquon42b/Rvcg/issues">https://github.com/zarquon42b/Rvcg/issues</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>see files COPYRIGHTS for detailed information</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zarquon42b/Rvcg">https://github.com/zarquon42b/Rvcg</a>,
<a href="https://github.com/cnr-isti-vclab/vcglib">https://github.com/cnr-isti-vclab/vcglib</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 08:17:29 UTC; schlager</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefan Schlager [aut, cre, cph],
  Girinon Francois [ctb],
  Tim Schaefer [ctb],
  Zhengjia Wang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefan Schlager &lt;zarquon42@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rvcg-package'>Interface between R and vcglib libraries for mesh operations</h2><span id='topic+Rvcg'></span><span id='topic+Rvcg-package'></span>

<h3>Description</h3>

<p>Provides meshing functionality from vcglib (meshlab) for R. E.g. mesh
smoothing, mesh decimation, closest point search.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Rvcg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.25</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2025-03-14</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Stefan Schlager
</p>
<p>Maintainer: Stefan Schlager &lt;zarquon42@gmail.com&gt;
</p>


<h3>References</h3>

<p>To be announced
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/zarquon42b/Rvcg">https://github.com/zarquon42b/Rvcg</a>
</p>
</li>
<li> <p><a href="https://github.com/cnr-isti-vclab/vcglib">https://github.com/cnr-isti-vclab/vcglib</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/zarquon42b/Rvcg/issues">https://github.com/zarquon42b/Rvcg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='checkFaceOrientation'>check the orientation of a mesh</h2><span id='topic+checkFaceOrientation'></span>

<h3>Description</h3>

<p>check the orientation of a mesh assuming that expansion along normals increases centroid size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFaceOrientation(x, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkFaceOrientation_+3A_x">x</code></td>
<td>
<p>mesh of class mesh3d</p>
</td></tr>
<tr><td><code id="checkFaceOrientation_+3A_offset">offset</code></td>
<td>
<p>numeric: amount to offset the mesh along the vertex normals. If NULL a reasonable value will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>assuming that a correctly (i.e outward) oriented mesh increases its centroid size when 'growing' outwards, this function tests whether this is the case.
</p>


<h3>Value</h3>

<p>returns TRUE if mesh is oriented correctly and FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dummyhead)
## now we invert faces inwards
checkFaceOrientation(dummyhead.mesh)

if (requireNamespace("Morpho", quietly = TRUE)) {
dummyinward &lt;- Morpho::invertFaces(dummyhead.mesh)
checkFaceOrientation(dummyinward)
}
</code></pre>

<hr>
<h2 id='deprecated'>deprecated functions of Rvcg</h2><span id='topic+deprecated'></span><span id='topic+checkNormOrient'></span>

<h3>Description</h3>

<p>document deprecated functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkNormOrient(...)
</code></pre>

<hr>
<h2 id='dummyhead'>dummyhead - dummy head and landmarks</h2><span id='topic+dummyhead'></span><span id='topic+dummyhead.mesh'></span><span id='topic+dummyhead.lm'></span>

<h3>Description</h3>

<p>A triangular mesh representing a dummyhead - called by data(dummyhead)
</p>


<h3>Format</h3>

<p><code>dummyhead.mesh</code>: triangular mesh representing a dummyhead.
</p>
<p><code>dummyhead.lm</code>: landmarks on mesh 'dummyhead'
</p>

<hr>
<h2 id='humface'>Example mesh and landmarks</h2><span id='topic+humface'></span><span id='topic+humface.lm'></span><span id='topic+humfaceClean'></span>

<h3>Description</h3>

<p>A triangular mesh representing a human face - called by data(humface)
</p>


<h3>Format</h3>

<p><code>humface</code>: triangular mesh representing a human face.
<code>humfaceClean</code>: triangular mesh representing a human face but without errors or isolated pieces.
<code>humface.lm</code>: landmarks on mesh 'humface'- called by data(humface)
</p>

<hr>
<h2 id='meshInfo'>print number of vertices and triangular faces of a mesh</h2><span id='topic+meshInfo'></span>

<h3>Description</h3>

<p>print number of vertices and triangular faces of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshInfo(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshInfo_+3A_x">x</code></td>
<td>
<p>triangular mesh</p>
</td></tr>
</table>

<hr>
<h2 id='meshintegrity'>check if an object of class mesh3d contains valid data</h2><span id='topic+meshintegrity'></span>

<h3>Description</h3>

<p>checks for existance and validity of vertices, faces and vertex normals of an object of class &quot;mesh3d&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meshintegrity(mesh, facecheck = FALSE, normcheck = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meshintegrity_+3A_mesh">mesh</code></td>
<td>
<p>object of class mesh3d</p>
</td></tr>
<tr><td><code id="meshintegrity_+3A_facecheck">facecheck</code></td>
<td>
<p>logical: check the existence of valid triangular faces</p>
</td></tr>
<tr><td><code id="meshintegrity_+3A_normcheck">normcheck</code></td>
<td>
<p>logical: check the existence of valid normals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if mesh data are valid, the mesh is returned, otherwise it stops with an error message.
</p>

<hr>
<h2 id='nfaces'>get number of vertices from a mesh</h2><span id='topic+nfaces'></span>

<h3>Description</h3>

<p>get number of vertices from a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nfaces(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nfaces_+3A_x">x</code></td>
<td>
<p>triangular mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer: number of triangular faces
</p>

<hr>
<h2 id='nverts'>get number of vertices from a mesh</h2><span id='topic+nverts'></span>

<h3>Description</h3>

<p>get number of vertices from a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nverts(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nverts_+3A_x">x</code></td>
<td>
<p>triangular mesh</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer: number of vertices
</p>

<hr>
<h2 id='raysearchMulti'>Find all intersections of rays and a mesh</h2><span id='topic+raysearchMulti'></span>

<h3>Description</h3>

<p>Find all intersections by tracing rays through mesh                                       #
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raysearchMulti(x, mesh, maxtol = 1e+15, threads = 1, offset = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raysearchMulti_+3A_x">x</code></td>
<td>
<p>a triangular mesh of class 'mesh3d' or a list containing vertices and vertex normals (fitting the naming conventions of 'mesh3d'). In the second case x must contain x$vb = 3 x n matrix containing 3D-coordinates and x$normals = 3 x n matrix containing normals associated with x$vb.</p>
</td></tr>
<tr><td><code id="raysearchMulti_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh to be intersected.</p>
</td></tr>
<tr><td><code id="raysearchMulti_+3A_maxtol">maxtol</code></td>
<td>
<p>maximum distance to search along ray</p>
</td></tr>
<tr><td><code id="raysearchMulti_+3A_threads">threads</code></td>
<td>
<p>number of threads used during search.</p>
</td></tr>
<tr><td><code id="raysearchMulti_+3A_offset">offset</code></td>
<td>
<p>amount to offset the hit points along the ray to find the next intersection. This is needed to avoid finding the same intersection over and over again.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function iteratively uses <code><a href="#topic+vcgRaySearch">vcgRaySearch</a></code> to find all intersections of rays and a given surface mesh.
</p>


<h3>Value</h3>

<p>list with following items:
</p>
<table role = "presentation">
<tr><td><code>intersects</code></td>
<td>
<p>a list containing the result of <code><a href="#topic+vcgRaySearch">vcgRaySearch</a></code> at each step of the intersection search</p>
</td></tr>
<tr><td><code>hits</code></td>
<td>
<p>Vector containging number of intersections for each ray</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vcgRaySearch">vcgRaySearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(Morpho); require(rgl)
data(humface)
humface1 &lt;- scalemesh(humface,size=1.1)
mesh &lt;- mergeMeshes(humface,humface1)     #get normals of landmarks
x &lt;- vcgClost(humface.lm, humface)
# offset landmarks along their normals for a negative amount of -5mm
x$vb[1:3,] &lt;- x$vb[1:3,]+x$normals[1:3,]*-5

myint &lt;- raysearchMulti(x,mesh)
wire3d(mesh,col="white")
spheres3d(vert2points(x),radius=0.5,col=3)
plotNormals(x,length=55,lwd=2)
for (i in 1:length(myint$intersects)) {
 spheres3d(vert2points(myint$intersects[[i]])[which(as.logical(myint$intersects[[i]]$quality)),]
                       ,col=i)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='setRays'>helper function to create an object to be processed by vcgRaySearch</h2><span id='topic+setRays'></span>

<h3>Description</h3>

<p>create a search structure from a matrix of coordinates and one of directional vectors to be processed by vcgRaySearch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRays(coords, dirs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setRays_+3A_coords">coords</code></td>
<td>
<p>k x 3 matrix (or a vector of length 3) containing the starting points of the rays</p>
</td></tr>
<tr><td><code id="setRays_+3A_dirs">dirs</code></td>
<td>
<p>k x 3 matrix (or a vector of length 3) containing the directons of the rays. The i-th row of <code>dirs</code> corresponds to the coordinate stored in the i-th row of <code>coords</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;mesh3d&quot; (without faces) and the vertices representing the starting points of the rays and the normals storing the directions.
</p>

<hr>
<h2 id='vcgArea'>compute surface area of a triangular mesh</h2><span id='topic+vcgArea'></span>

<h3>Description</h3>

<p>compute surface area of a triangular mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgArea(mesh, perface = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgArea_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class mesh3d</p>
</td></tr>
<tr><td><code id="vcgArea_+3A_perface">perface</code></td>
<td>
<p>logical: if TRUE, a list containing the overall area, as well as the individual per-face area are reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>surface area of mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgArea(humface)
</code></pre>

<hr>
<h2 id='vcgBallPivoting'>Ball pivoting surface reconstruction</h2><span id='topic+vcgBallPivoting'></span>

<h3>Description</h3>

<p>Ball pivoting surface reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgBallPivoting(
  x,
  radius = 0,
  clustering = 0.2,
  angle = pi/2,
  deleteFaces = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgBallPivoting_+3A_x">x</code></td>
<td>
<p>k x 3 matrix or object of class mesh3d</p>
</td></tr>
<tr><td><code id="vcgBallPivoting_+3A_radius">radius</code></td>
<td>
<p>The radius of the ball pivoting (rolling) over the set of points. Gaps that are larger than the ball radius will not be filled; similarly the small pits that are smaller than the ball radius will be filled. 0 = autoguess.</p>
</td></tr>
<tr><td><code id="vcgBallPivoting_+3A_clustering">clustering</code></td>
<td>
<p>Clustering radius (fraction of ball radius). To avoid the creation of too small triangles, if a vertex is found too close to a previous one, it is clustered/merged with it.</p>
</td></tr>
<tr><td><code id="vcgBallPivoting_+3A_angle">angle</code></td>
<td>
<p>Angle threshold (radians). If we encounter a crease angle that is too large we should stop the ball rolling.</p>
</td></tr>
<tr><td><code id="vcgBallPivoting_+3A_deletefaces">deleteFaces</code></td>
<td>
<p>in case x is a mesh and <code>deleteFaces=TRUE</code>, existing faces will be deleted beforehand.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>triangular face of class mesh3d
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("Morpho", quietly = TRUE)) {
require(Morpho)
data(nose)
nosereko &lt;- vcgBallPivoting(shortnose.lm)
}

</code></pre>

<hr>
<h2 id='vcgBary'>get barycenters of all faces of a triangular mesh</h2><span id='topic+vcgBary'></span>

<h3>Description</h3>

<p>get barycenters of all faces of a triangular mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgBary(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgBary_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x 3 matrix containing 3D-coordinates of the barycenters (where n is the number of faces in <code>mesh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
bary &lt;- vcgBary(humface)
## Not run: 
require(rgl)
points3d(bary,col=2)
wire3d(humface)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgBorder'>find all border vertices and faces of a triangular mesh</h2><span id='topic+vcgBorder'></span>

<h3>Description</h3>

<p>Detect faces and vertices at the borders of a mesh and mark them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgBorder(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgBorder_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bordervb</code></td>
<td>
<p>logical: vector containing boolean value for each vertex, if it is a border vertex.</p>
</td></tr>
<tr><td><code>borderit</code></td>
<td>
<p>logical: vector containing boolean value for each face, if it is a border vertex.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
borders &lt;- vcgBorder(humface)
## view border vertices
## Not run: 
require(rgl)
points3d(t(humface$vb[1:3,])[which(borders$bordervb == 1),],col=2)
wire3d(humface)
require(rgl)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgClean'>Clean triangular surface meshes</h2><span id='topic+vcgClean'></span>

<h3>Description</h3>

<p>Apply several cleaning algorithms to surface meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgClean(mesh, sel = 0, tol = 0, silent = FALSE, iterate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgClean_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="vcgClean_+3A_sel">sel</code></td>
<td>
<p>integer vector selecting cleaning type (see &quot;details&quot;),</p>
</td></tr>
<tr><td><code id="vcgClean_+3A_tol">tol</code></td>
<td>
<p>numeric value determining Vertex Displacement Ratio used for splitting non-manifold vertices.</p>
</td></tr>
<tr><td><code id="vcgClean_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE no console output is issued.</p>
</td></tr>
<tr><td><code id="vcgClean_+3A_iterate">iterate</code></td>
<td>
<p>logical: if TRUE, vcgClean is repeatedly run until nothing more is to be cleaned (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the vector sel determines which operations are performed in which order. E.g. removing degenerate faces may generate unreferenced vertices, thus the ordering of cleaning operations is important, multiple calls are possible (sel=c(1,3,1) will remove unreferenced vertices twice).
available options are:
</p>

<ul>
<li><p>0 = only duplicated vertices and faces are removed
</p>
</li>
<li><p>1 = remove unreferenced vertices
</p>
</li>
<li><p>2 = Remove non-manifold Faces
</p>
</li>
<li><p>3 = Remove degenerate faces
</p>
</li>
<li><p>4 = Remove non-manifold vertices
</p>
</li>
<li><p>5 = Split non-manifold vertices by threshold
</p>
</li>
<li><p>6 = merge close vertices (radius=<code>tol</code>)
</p>
</li>
<li><p>7 = coherently orient faces
</p>
<p>CAVEAT: sel=6 will not work keep vertex colors
</p>
</li></ul>



<h3>Value</h3>

<p>cleaned mesh with an additional entry
</p>
<table role = "presentation">
<tr><td><code>remvert</code></td>
<td>
<p>vector of length = number of vertices before cleaning. Entries = 1 indicate that this vertex was removed; 0 otherwise.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
cleanface &lt;- humface
##add duplicated faces
cleanface$it &lt;- cbind(cleanface$it, cleanface$it[,1:100])
## add duplicated vertices
cleanface$vb &lt;- cbind(cleanface$vb,cleanface$vb[,1:100])
## ad unreferenced vertices
cleanface$vb &lt;- cbind(cleanface$vb,rbind(matrix(rnorm(18),3,6),1))
cleanface &lt;- vcgClean(cleanface, sel=1)
</code></pre>

<hr>
<h2 id='vcgClost'>Project coordinates onto a target triangular surface mesh.</h2><span id='topic+vcgClost'></span>

<h3>Description</h3>

<p>For a set of 3D-coordinates/triangular mesh, the closest matches on a
target surface are determined and normals at as well as distances to
that point are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgClost(
  x,
  mesh,
  sign = TRUE,
  barycentric = FALSE,
  smoothNormals = FALSE,
  borderchk = FALSE,
  tol = 0,
  facenormals = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgClost_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing 3D-coordinates or object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_mesh">mesh</code></td>
<td>
<p>triangular surface mesh stored as object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_sign">sign</code></td>
<td>
<p>logical: if TRUE, signed distances are returned.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_barycentric">barycentric</code></td>
<td>
<p>logical: if TRUE, barycentric coordinates of the hit
points are returned.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_smoothnormals">smoothNormals</code></td>
<td>
<p>logical: if TRUE, laplacian smoothed normals are used.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_borderchk">borderchk</code></td>
<td>
<p>logical: request checking if the hit face is at the border of the mesh.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_tol">tol</code></td>
<td>
<p>maximum distance to search. If distance is beyond that, the original point will be kept and the distance set to NaN. If tol = 0, tol is set to 2*diagonal of the bounding box of <code>mesh</code>.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_facenormals">facenormals</code></td>
<td>
<p>logical: if TRUE only the facenormal of the face the closest point has hit is returned, the weighted average of the surrounding vertex normals otherwise.</p>
</td></tr>
<tr><td><code id="vcgClost_+3A_...">...</code></td>
<td>
<p>additional parameters, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing n vertices as homolougous coordinates.</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing vertex normals.</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>numeric vector containing distances to target.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>3 x m integer matrix containing vertex indices forming triangular
faces.Only available, when x is a mesh.</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>integer vector of length n: if borderchk = TRUE, for each clostest point the value will be 1 if the hit face is at the border of the target mesh and 0 otherwise.</p>
</td></tr> 
<tr><td><code>barycoords</code></td>
<td>
<p>3 x m Matrix containing barycentric coordinates of
closest points; only available if barycentric=TRUE.</p>
</td></tr>
<tr><td><code>faceptr</code></td>
<td>
<p>vector of face indeces on which the closest points are located</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If large part of the reference mesh are far away from the target
surface, calculation can become very slow. In that case, the function
<code>vcgClostKD</code> will be significantly faster.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed
Distance Fields From Triangle Meshes. Informatics and Mathematical
Modelling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
clost &lt;- vcgClost(humface.lm, humface)




</code></pre>

<hr>
<h2 id='vcgClostKD'>Project coordinates onto a target triangular surface mesh using KD-tree search</h2><span id='topic+vcgClostKD'></span>

<h3>Description</h3>

<p>For a set of 3D-coordinates/triangular mesh, the closest matches on a
target surface are determined (by using KD-tree search) and normals at as well as distances to
that point are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgClostKD(
  x,
  mesh,
  sign = TRUE,
  barycentric = FALSE,
  smoothNormals = FALSE,
  borderchk = FALSE,
  k = 50,
  nofPoints = 16,
  maxDepth = 64,
  angdev = NULL,
  weightnorm = FALSE,
  facenormals = FALSE,
  threads = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgClostKD_+3A_x">x</code></td>
<td>
<p>k x 3 matrix containing 3D-coordinates or object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_mesh">mesh</code></td>
<td>
<p>triangular surface mesh stored as object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_sign">sign</code></td>
<td>
<p>logical: if TRUE, signed distances are returned.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_barycentric">barycentric</code></td>
<td>
<p>logical: if TRUE, barycentric coordinates of the hit
points are returned.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_smoothnormals">smoothNormals</code></td>
<td>
<p>logical: if TRUE, laplacian smoothed normals are used.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_borderchk">borderchk</code></td>
<td>
<p>logical: request checking if the hit face is at the border of the mesh.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_k">k</code></td>
<td>
<p>integer: check the kdtree for the<code>k</code> closest faces (using faces' barycenters.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_nofpoints">nofPoints</code></td>
<td>
<p>integer: number of points per cell in the kd-tree (don't change unless you know what you are doing!)</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_maxdepth">maxDepth</code></td>
<td>
<p>integer: depth of the kd-tree (don't change unless you know what you are doing!)</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_angdev">angdev</code></td>
<td>
<p>maximum deviation between reference and target normals. If the none of the k closest triangles match this criterion, the closest point on the closest triangle is returned but the corresponding distance in $quality is set to 1e5.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_weightnorm">weightnorm</code></td>
<td>
<p>logical if angdev is set, this requests the normal of the closest points to be estimated by weighting the surrounding vertex normals. Otherwise, simply the hit face's normal is used (faster but slightly less accurate)</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_facenormals">facenormals</code></td>
<td>
<p>logical: if TRUE only the facenormal of the face the closest point has hit is returned, the weighted average of the surrounding vertex normals otherwise.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_threads">threads</code></td>
<td>
<p>integer: threads to use in closest point search.</p>
</td></tr>
<tr><td><code id="vcgClostKD_+3A_...">...</code></td>
<td>
<p>additional parameters, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing n vertices as homolougous coordinates.</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing vertex normals.</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>numeric vector containing distances to target.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>3 x m integer matrix containing vertex indices forming triangular
faces.Only available, when x is a mesh.</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>integer vector of length n: if borderchk = TRUE, for each clostest point the value will be 1 if the hit face is at the border of the target mesh and 0 otherwise.</p>
</td></tr> 
<tr><td><code>barycoords</code></td>
<td>
<p>3 x m Matrix containing barycentric coordinates of
closest points; only available if barycentric=TRUE.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Other than <code>vcgClost</code> this does not search a grid, but first uses a KD-tree search to find the <code>k</code> closest barycenters for each point and then searches these faces for the closest match.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Baerentzen, Jakob Andreas. &amp; Aanaes, H., 2002. Generating Signed
Distance Fields From Triangle Meshes. Informatics and Mathematical
Modelling.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a></code>
</p>

<hr>
<h2 id='vcgClostOnKDtreeFromBarycenters'>search a KD-tree from Barycenters for multiple closest point searches on a mesh</h2><span id='topic+vcgClostOnKDtreeFromBarycenters'></span>

<h3>Description</h3>

<p>search a KD-tree from Barycenters for multiple closest point searches on a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgClostOnKDtreeFromBarycenters(
  x,
  query,
  k = 50,
  sign = TRUE,
  barycentric = FALSE,
  borderchk = FALSE,
  angdev = NULL,
  weightnorm = FALSE,
  facenormals = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_x">x</code></td>
<td>
<p>object of class &quot;vcgKDtreeWithBarycenters&quot;</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_query">query</code></td>
<td>
<p>matrix or triangular mesh containing coordinates</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_k">k</code></td>
<td>
<p>integer: check the kdtree for the<code>k</code> closest faces (using faces' barycenters).</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_sign">sign</code></td>
<td>
<p>logical: if TRUE, signed distances are returned.</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_barycentric">barycentric</code></td>
<td>
<p>logical: if TRUE, barycentric coordinates of the hit
points are returned.</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_borderchk">borderchk</code></td>
<td>
<p>logical: request checking if the hit face is at the border of the mesh.</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_angdev">angdev</code></td>
<td>
<p>maximum deviation between reference and target normals. If the none of the k closest triangles match this criterion, the closest point on the closest triangle is returned but the corresponding distance in $quality is set to 1e5.</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_weightnorm">weightnorm</code></td>
<td>
<p>logical if angdev is set, this requests the normal of the closest points to be estimated by weighting the surrounding vertex normals. Otherwise, simply the hit face's normal is used (faster but slightly less accurate)</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_facenormals">facenormals</code></td>
<td>
<p>logical: if TRUE only the facenormal of the face the closest point has hit is returned, the weighted average of the surrounding vertex normals otherwise.</p>
</td></tr>
<tr><td><code id="vcgClostOnKDtreeFromBarycenters_+3A_threads">threads</code></td>
<td>
<p>integer: threads to use in closest point search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing n vertices as homolougous coordinates.</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing vertex normals.</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>numeric vector containing distances to target.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>3 x m integer matrix containing vertex indices forming triangular
faces.Only available, when x is a mesh.</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>integer vector of length n: if borderchk = TRUE, for each clostest point the value will be 1 if the hit face is at the border of the target mesh and 0 otherwise.</p>
</td></tr> 
<tr><td><code>barycoords</code></td>
<td>
<p>3 x m Matrix containing barycentric coordinates of
closest points; only available if barycentric=TRUE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgCreateKDtreeFromBarycenters">vcgCreateKDtreeFromBarycenters</a>, <a href="#topic+vcgSearchKDtree">vcgSearchKDtree</a>,  <a href="#topic+vcgCreateKDtree">vcgCreateKDtree</a></code>
</p>

<hr>
<h2 id='vcgCreateKDtree'>create a KD-tree</h2><span id='topic+vcgCreateKDtree'></span>

<h3>Description</h3>

<p>create a KD-tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgCreateKDtree(mesh, nofPointsPerCell = 16, maxDepth = 64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgCreateKDtree_+3A_mesh">mesh</code></td>
<td>
<p>matrix or triangular mesh containing coordinates</p>
</td></tr>
<tr><td><code id="vcgCreateKDtree_+3A_nofpointspercell">nofPointsPerCell</code></td>
<td>
<p>number of points per kd-cell</p>
</td></tr>
<tr><td><code id="vcgCreateKDtree_+3A_maxdepth">maxDepth</code></td>
<td>
<p>maximum tree depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class vcgKDtree containing external pointers to the tree and the target points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgSearchKDtree">vcgSearchKDtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
mytree &lt;- vcgCreateKDtree(humface)
</code></pre>

<hr>
<h2 id='vcgCreateKDtreeFromBarycenters'>create a KD-tree from Barycenters for multiple closest point searches on a mesh</h2><span id='topic+vcgCreateKDtreeFromBarycenters'></span>

<h3>Description</h3>

<p>create a KD-tree from Barycenters for multiple closest point searches on a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgCreateKDtreeFromBarycenters(mesh, nofPointsPerCell = 16, maxDepth = 64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgCreateKDtreeFromBarycenters_+3A_mesh">mesh</code></td>
<td>
<p>matrix or triangular mesh containing coordinates</p>
</td></tr>
<tr><td><code id="vcgCreateKDtreeFromBarycenters_+3A_nofpointspercell">nofPointsPerCell</code></td>
<td>
<p>number of points per kd-cell</p>
</td></tr>
<tr><td><code id="vcgCreateKDtreeFromBarycenters_+3A_maxdepth">maxDepth</code></td>
<td>
<p>maximum tree depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class vcgKDtreeWithBarycenters containing external pointers to the tree, the barycenters and the target mesh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgClostOnKDtreeFromBarycenters">vcgClostOnKDtreeFromBarycenters</a>, <a href="#topic+vcgSearchKDtree">vcgSearchKDtree</a>,  <a href="#topic+vcgCreateKDtree">vcgCreateKDtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(humface);data(dummyhead)
barytree &lt;- vcgCreateKDtreeFromBarycenters(humface)
closest &lt;- vcgClostOnKDtreeFromBarycenters(barytree,dummyhead.mesh,k=50,threads=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgCurve'>calculate curvature of a triangular mesh</h2><span id='topic+vcgCurve'></span>

<h3>Description</h3>

<p>calculate curvature of faces/vertices of a triangular mesh using various methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgCurve(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgCurve_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh (object of class 'mesh3d')</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>gaussvb</code></td>
<td>
<p>per vertex gaussian curvature</p>
</td></tr>
<tr><td><code>meanvb</code></td>
<td>
<p>per vertex mean curvature</p>
</td></tr>
<tr><td><code>RMSvb</code></td>
<td>
<p>per vertex RMS curvature</p>
</td></tr>
<tr><td><code>gaussitmax</code></td>
<td>
<p>per face maximum gaussian curvature of adjacent vertices</p>
</td></tr>
<tr><td><code>borderit</code></td>
<td>
<p>per face information if it is on the mesh's border (0=FALSE, 1=TRUE) </p>
</td></tr>
<tr><td><code>bordervb</code></td>
<td>
<p>per vertex information if it is on the mesh's border (0=FALSE, 1=TRUE)</p>
</td></tr>
<tr><td><code>meanitmax</code></td>
<td>
<p>per face maximum mean curvature of adjacent vertices</p>
</td></tr>
<tr><td><code>K1</code></td>
<td>
<p>Principal Curvature 1</p>
</td></tr>
<tr><td><code>K2</code></td>
<td>
<p>Principal Curvature 2</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
curv &lt;- vcgCurve(humface)
##visualise per vertex mean curvature
## Not run: 
require(Morpho)
meshDist(humface,distvec=curv$meanvb,from=-0.2,to=0.2,tol=0.01)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgDijkstra'>Compute pseudo-geodesic distances on a triangular mesh</h2><span id='topic+vcgDijkstra'></span>

<h3>Description</h3>

<p>Compute pseudo-geodesic distances on a triangular mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgDijkstra(x, vertpointer, maxdist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgDijkstra_+3A_x">x</code></td>
<td>
<p>triangular mesh of class <code>mesh3d</code></p>
</td></tr>
<tr><td><code id="vcgDijkstra_+3A_vertpointer">vertpointer</code></td>
<td>
<p>integer: references indices of vertices on the mesh, typically only a single query vertex.</p>
</td></tr>
<tr><td><code id="vcgDijkstra_+3A_maxdist">maxdist</code></td>
<td>
<p>positive scalar double, the maximal distance to travel along the mesh when computing distances. Leave at <code>NULL</code> to traverse the full mesh. This can be used to speed up the computation if you are only interested in geodesic distances to neighbors within a limited distance around the query vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of shortest distances for each of the vertices to one of the vertices referenced in <code>vertpointer</code>. If <code>maxdis</code>t is in use (not <code>NULL</code>), the distance values for vertices outside the requested <code>maxdist</code> are not computed and appear as <code>0</code>.
</p>


<h3>Note</h3>

<p>Make sure to have a clean manifold mesh. Note that this computes the length of the pseudo-geodesic path (following the edges) between the two vertices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compute geodesic distance between all mesh vertices and the first vertex of a mesh
data(humface)
geo &lt;- vcgDijkstra(humface,1)
if (interactive()) {
require(Morpho);require(rgl)
meshDist(humface,distvec = geo)
spheres3d(vert2points(humface)[1,],col=2)
}
</code></pre>

<hr>
<h2 id='vcgFaceNormals'>Compute normalized face normals for a mesh.</h2><span id='topic+vcgFaceNormals'></span>

<h3>Description</h3>

<p>Compute normalized face normals for a mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgFaceNormals(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgFaceNormals_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d', from <code>rgl</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>3xn numeric matrix of face normals for the mesh, where <code>n</code> is the number of faces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface);
hf_facenormals &lt;- vcgFaceNormals(humface);

</code></pre>

<hr>
<h2 id='vcgGeodesicPath'>Compute geodesic path and path length between vertices on a mesh</h2><span id='topic+vcgGeodesicPath'></span>

<h3>Description</h3>

<p>Compute geodesic path and path length between vertices on a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgGeodesicPath(x, source, targets, maxdist = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgGeodesicPath_+3A_x">x</code></td>
<td>
<p>triangular mesh of class <code>mesh3d</code> from the <code>rgl</code> package.</p>
</td></tr>
<tr><td><code id="vcgGeodesicPath_+3A_source">source</code></td>
<td>
<p>scalar positive integer, the source vertex index.</p>
</td></tr>
<tr><td><code id="vcgGeodesicPath_+3A_targets">targets</code></td>
<td>
<p>positive integer vector, the target vertex indices.</p>
</td></tr>
<tr><td><code id="vcgGeodesicPath_+3A_maxdist">maxdist</code></td>
<td>
<p>numeric, the maximal distance to travel along the mesh edges during geodesic distance computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list with two entries as follows. <code>'paths'</code>: list of integer vectors, representing the paths. <code>'geodist'</code>: double vector, the geodesic distances from the source vertex to all vertices in the graph.
</p>


<h3>Note</h3>

<p>Currently no reachability checks are performed, so you have to be sure that the mesh is connected, or at least that the source and target vertices are reachable from one another.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
p = vcgGeodesicPath(humface,50,c(500,5000))
p$paths[[1]];   # The path 50..500
p$geodist[500]; # Its path length.
</code></pre>

<hr>
<h2 id='vcgGeodist'>Compute pseudo-geodesic distance between two points on a mesh</h2><span id='topic+vcgGeodist'></span>

<h3>Description</h3>

<p>Compute pseudo-geodesic distance between two points on a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgGeodist(x, pt1, pt2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgGeodist_+3A_x">x</code></td>
<td>
<p>triangular mesh of class <code>mesh3d</code></p>
</td></tr>
<tr><td><code id="vcgGeodist_+3A_pt1">pt1</code></td>
<td>
<p>3D coordinate on mesh or index of vertex</p>
</td></tr>
<tr><td><code id="vcgGeodist_+3A_pt2">pt2</code></td>
<td>
<p>3D coordinate on mesh or index of vertex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the geodesic distance between <code>pt1</code> and <code>pt2</code>.
</p>


<h3>Note</h3>

<p>Make sure to have a clean manifold mesh. Note that this computes the length of the pseudo-geodesic path (following the edges) between the two vertices closest to these points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
pt1 &lt;- humface.lm[1,]
pt2 &lt;- humface.lm[5,]
vcgGeodist(humface,pt1,pt2)
</code></pre>

<hr>
<h2 id='vcgGetEdge'>Get all edges of a triangular mesh</h2><span id='topic+vcgGetEdge'></span>

<h3>Description</h3>

<p>Extract all edges from a mesh and retrieve adjacent faces and vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgGetEdge(mesh, unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgGetEdge_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="vcgGetEdge_+3A_unique">unique</code></td>
<td>
<p>logical: if TRUE each edge is only reported once, if FALSE, all occurences are reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe containing:
</p>
<table role = "presentation">
<tr><td><code>vert1</code></td>
<td>
<p>integer indicating the position of the first vertex belonging to this edge</p>
</td></tr>
<tr><td><code>vert2</code></td>
<td>
<p>integer indicating the position of the second vertex belonging to this edge</p>
</td></tr>
<tr><td><code>facept</code></td>
<td>
<p>integer pointing to the (or a, if unique = TRUE) face adjacent to the edge</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>integer indicating if the edge is at the border of the mesh. 0 = no border, 1 = border</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(rgl)
data(humface)
edges &lt;-vcgGetEdge(humface)
## Not run: 
## show first edge
lines3d(t(humface$vb[1:3,])[c(edges$vert1[1],edges$vert2[2]),],col=2,lwd=3)
shade3d(humface, col=3)
## now find the edge - hint: it is at the neck.

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgImport'>Import common mesh file formats.</h2><span id='topic+vcgImport'></span>

<h3>Description</h3>

<p>Import common mesh file formats and store the results in an object of
class &quot;mesh3d&quot; - momentarily only triangular meshes are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgImport(
  file,
  updateNormals = TRUE,
  readcolor = FALSE,
  clean = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgImport_+3A_file">file</code></td>
<td>
<p>character: file to be read.</p>
</td></tr>
<tr><td><code id="vcgImport_+3A_updatenormals">updateNormals</code></td>
<td>
<p>logical: if TRUE and the imported file contais faces,
vertex normals will be (re)calculated. Otherwise, normals will be a matrix containing zeros.</p>
</td></tr>
<tr><td><code id="vcgImport_+3A_readcolor">readcolor</code></td>
<td>
<p>if TRUE, vertex colors and texture (face and vertex) coordinates will be processed - if available, otherwise all vertices will be colored white.</p>
</td></tr>
<tr><td><code id="vcgImport_+3A_clean">clean</code></td>
<td>
<p>if TRUE, duplicated and unreferenced vertices as well as duplicate faces are removed (be careful when importing point clouds).</p>
</td></tr>
<tr><td><code id="vcgImport_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE no console output is issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;mesh3d&quot;
</p>
<p>with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing n vertices as homolougous coordinates</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>3 x m matrix containing vertex indices forming triangular faces</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing vertex normals (homologous coordinates)</p>
</td></tr>
</table>
<p>in case the imported files contains face or vertex quality, these will be stored as vectors named $quality (for vertex quality) and $facequality
</p>
<p>if the imported file contains vertex colors and readcolor = TRUE, these will be saved in $material$color according to &quot;mesh3d&quot; specifications.
</p>


<h3>Note</h3>

<p>currently only meshes with either color or texture can be processed. If both are present, the function will mark the mesh as non-readable.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgSmooth">vcgSmooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgPlyWrite(humface)
readit &lt;- vcgImport("humface.ply")
</code></pre>

<hr>
<h2 id='vcgIsolated'>Remove isolated pieces from a surface mesh or split into connected components</h2><span id='topic+vcgIsolated'></span>

<h3>Description</h3>

<p>Remove isolated pieces from a surface mesh, selected by a
minimum amount of faces or of a diameter below a given threshold.
Also the option only to keep the largest piece can be selected or to split a mesh into connected components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgIsolated(
  mesh,
  facenum = NULL,
  diameter = NULL,
  split = FALSE,
  keep = 0,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgIsolated_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgIsolated_+3A_facenum">facenum</code></td>
<td>
<p>integer: all connected pieces with less components are
removed. If not specified or 0 and diameter is NULL, then only the component
with the most faces is kept.</p>
</td></tr>
<tr><td><code id="vcgIsolated_+3A_diameter">diameter</code></td>
<td>
<p>numeric: all connected pieces smaller diameter are removed
removed. <code>diameter = 0</code> removes all component but the largest ones. This option overrides the option <code>facenum</code>.</p>
</td></tr>
<tr><td><code id="vcgIsolated_+3A_split">split</code></td>
<td>
<p>logical: if TRUE, a list with all connected components (optionally matching requirements facenum/diameter) of the mesh will be returned.</p>
</td></tr>
<tr><td><code id="vcgIsolated_+3A_keep">keep</code></td>
<td>
<p>integer: if split=T, <code>keep</code> specifies the number of largest chunks (number of faces) to keep.</p>
</td></tr>
<tr><td><code id="vcgIsolated_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE no console output is issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the reduced mesh.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(humface)
cleanface &lt;- vcgIsolated(humface)

## End(Not run)

</code></pre>

<hr>
<h2 id='vcgIsosurface'>Create Isosurface from 3D-array</h2><span id='topic+vcgIsosurface'></span>

<h3>Description</h3>

<p>Create Isosurface from 3D-array using Marching Cubes algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgIsosurface(
  vol,
  threshold,
  from = NULL,
  to = NULL,
  spacing = NULL,
  origin = NULL,
  direction = NULL,
  IJK2RAS = diag(c(-1, -1, 1, 1)),
  as.int = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgIsosurface_+3A_vol">vol</code></td>
<td>
<p>an integer valued 3D-array</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_threshold">threshold</code></td>
<td>
<p>threshold for creating the surface</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_from">from</code></td>
<td>
<p>numeric: the lower threshold of a range (overrides <code>threshold</code>)</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_to">to</code></td>
<td>
<p>numeric: the upper threshold of a range (overrides <code>threshold</code>)</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_spacing">spacing</code></td>
<td>
<p>numeric 3D-vector: specifies the voxel dimensons in x,y,z direction.</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_origin">origin</code></td>
<td>
<p>numeric 3D-vector: origin of the original data set, will transpose the mesh onto that origin.</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_direction">direction</code></td>
<td>
<p>a 3x3 direction matrix</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_ijk2ras">IJK2RAS</code></td>
<td>
<p>4x4 IJK2RAS transformation matrix</p>
</td></tr>
<tr><td><code id="vcgIsosurface_+3A_as.int">as.int</code></td>
<td>
<p>logical: if TRUE, the array will be stored as integer (might decrease RAM usage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a triangular mesh of class &quot;mesh3d&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#this is the example from the package "misc3d"
x &lt;- seq(-2,2,len=50)
g &lt;- expand.grid(x = x, y = x, z = x)
v &lt;- array(g$x^4 + g$y^4 + g$z^4, rep(length(x),3))
storage.mode(v) &lt;- "integer"
## Not run: 
mesh &lt;- vcgIsosurface(v,threshold=10)
require(rgl)
wire3d(mesh)
##now smooth it a little bit
wire3d(vcgSmooth(mesh,"HC",iteration=3),col=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgIsotropicRemeshing'>Isotropically remesh a triangular surface mesh</h2><span id='topic+vcgIsotropicRemeshing'></span>

<h3>Description</h3>

<p>Isotropically remesh a triangular surface mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgIsotropicRemeshing(
  x,
  TargetLen = 1,
  FeatureAngleDeg = 10,
  MaxSurfDist = 1,
  iterations = 3,
  Adaptive = FALSE,
  split = TRUE,
  collapse = TRUE,
  swap = TRUE,
  smooth = TRUE,
  project = TRUE,
  surfDistCheck = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgIsotropicRemeshing_+3A_x">x</code></td>
<td>
<p>mesh of class <code>mesh3d</code></p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_targetlen">TargetLen</code></td>
<td>
<p>numeric: edge length of the target surface</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_featureangledeg">FeatureAngleDeg</code></td>
<td>
<p>define Crease angle (in degree).</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_maxsurfdist">MaxSurfDist</code></td>
<td>
<p>Max. surface distance</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_iterations">iterations</code></td>
<td>
<p>ToDo</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_adaptive">Adaptive</code></td>
<td>
<p>enable adaptive remeshing</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_split">split</code></td>
<td>
<p>enable refine step</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_collapse">collapse</code></td>
<td>
<p>enable collapse step</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_swap">swap</code></td>
<td>
<p>enable dge swap</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_smooth">smooth</code></td>
<td>
<p>enable smoothing</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_project">project</code></td>
<td>
<p>enable reprojection step</p>
</td></tr>
<tr><td><code id="vcgIsotropicRemeshing_+3A_surfdistcheck">surfDistCheck</code></td>
<td>
<p>check distance to surface</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the remeshed surface mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(humface)
resampledMesh &lt;- vcgIsotropicRemeshing(humface,TargetLen=2.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgKDtree'>perform kdtree search for 3D-coordinates.</h2><span id='topic+vcgKDtree'></span>

<h3>Description</h3>

<p>perform kdtree search for 3D-coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgKDtree(target, query, k, nofPoints = 16, maxDepth = 64, threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgKDtree_+3A_target">target</code></td>
<td>
<p>n x 3 matrix with 3D coordinates or mesh of class &quot;mesh3d&quot;. These coordinates are to be searched.</p>
</td></tr>
<tr><td><code id="vcgKDtree_+3A_query">query</code></td>
<td>
<p>m x 3 matrix with 3D coordinates or mesh of class &quot;mesh3d&quot;. We seach the closest coordinates in <code>target</code> for each of these.</p>
</td></tr>
<tr><td><code id="vcgKDtree_+3A_k">k</code></td>
<td>
<p>number of neighbours to find</p>
</td></tr>
<tr><td><code id="vcgKDtree_+3A_nofpoints">nofPoints</code></td>
<td>
<p>integer: number of points per cell in the kd-tree (don't change unless you know what you are doing!)</p>
</td></tr>
<tr><td><code id="vcgKDtree_+3A_maxdepth">maxDepth</code></td>
<td>
<p>integer: depth of the kd-tree (don't change unless you know what you are doing!)</p>
</td></tr>
<tr><td><code id="vcgKDtree_+3A_threads">threads</code></td>
<td>
<p>integer: threads to use in closest point search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>
<table role = "presentation">
<tr><td><code>index</code></td>
<td>
<p>integer matrices with indeces of closest points</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>corresponding distances</p>
</td></tr>
</table>

<hr>
<h2 id='vcgKmeans'>fast Kmean clustering for 1D, 2D and 3D data</h2><span id='topic+vcgKmeans'></span>

<h3>Description</h3>

<p>fast Kmean clustering for 1D, 2D and 3D data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgKmeans(x, k = 10, iter.max = 10, getClosest = FALSE, threads = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgKmeans_+3A_x">x</code></td>
<td>
<p>matrix containing coordinates or mesh3d</p>
</td></tr>
<tr><td><code id="vcgKmeans_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="vcgKmeans_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="vcgKmeans_+3A_getclosest">getClosest</code></td>
<td>
<p>logical: if TRUE the indices of the points closest to the k-centers are sought.</p>
</td></tr>
<tr><td><code id="vcgKmeans_+3A_threads">threads</code></td>
<td>
<p>integer: number of threads to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing
</p>
<table role = "presentation">
<tr><td><code>centers</code></td>
<td>
<p>cluster center</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>vector with cluster association for each coordinate</p>
</td></tr>
</table>
<p>If <code>getClosest=TRUE</code>
</p>
<table role = "presentation">
<tr><td><code>selected</code></td>
<td>
<p>vector with indices of points closest to the centers</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vcgSample">vcgSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(Rvcg);require(rgl)
data(humface)
set.seed(42)
clust &lt;- vcgKmeans(humface,k=1000,threads=1)
</code></pre>

<hr>
<h2 id='vcgMeshres'>calculates the average edge length of a triangular mesh</h2><span id='topic+vcgMeshres'></span>

<h3>Description</h3>

<p>calculates the average edge length of a triangular mesh, iterating over all
faces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgMeshres(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgMeshres_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>res</code></td>
<td>
<p>average edge length (a.k.a. mesh resolution)</p>
</td></tr>
<tr><td><code>edgelength</code></td>
<td>
<p>vector containing lengths for each edge</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
mres &lt;- vcgMeshres(humface)
#histogram of edgelength distribution
hist(mres$edgelength)
#visualise average edgelength
points( mres$res, 1000, pch=20, col=2, cex=2)

</code></pre>

<hr>
<h2 id='vcgMetro'>evaluate the difference between two triangular meshes.</h2><span id='topic+vcgMetro'></span>

<h3>Description</h3>

<p>Implementation of the command line tool &quot;metro&quot; to evaluate the difference between two triangular meshes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgMetro(
  mesh1,
  mesh2,
  nSamples = 0,
  nSamplesArea = 0,
  vertSamp = TRUE,
  edgeSamp = TRUE,
  faceSamp = TRUE,
  unrefVert = FALSE,
  samplingType = c("SS", "MC", "SD"),
  searchStruct = c("SGRID", "AABB", "OCTREE", "HGRID"),
  from = 0,
  to = 0,
  colormeshes = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgMetro_+3A_mesh1">mesh1</code></td>
<td>
<p>triangular mesh (object of class 'mesh3d').</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_mesh2">mesh2</code></td>
<td>
<p>triangular mesh (object of class 'mesh3d').</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_nsamples">nSamples</code></td>
<td>
<p>set the required number of samples if 0, this will be set to approx. 10x the face number.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_nsamplesarea">nSamplesArea</code></td>
<td>
<p>set the required number of samples per area unit, override nSamples.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_vertsamp">vertSamp</code></td>
<td>
<p>logical: if FALSE, disable vertex sampling.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_edgesamp">edgeSamp</code></td>
<td>
<p>logical: if FALSE, disable edge sampling.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_facesamp">faceSamp</code></td>
<td>
<p>logical: if FALSE, disable face sampling.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_unrefvert">unrefVert</code></td>
<td>
<p>logical: if FALSE, ignore unreferred vertices.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_samplingtype">samplingType</code></td>
<td>
<p>set the face sampling mode. options are: SS (similar triangles sampling), SD (subdivision sampling), MC (montecarlo sampling).</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_searchstruct">searchStruct</code></td>
<td>
<p>set search structures to use. options are: SGIRD (static Uniform Grid), OCTREE, AABB (AxisAligned Bounding Box Tree), HGRID (Hashed Uniform Grid).</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_from">from</code></td>
<td>
<p>numeric: minimum value for color mapping.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_to">to</code></td>
<td>
<p>numeric: maximum value for color mapping.</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_colormeshes">colormeshes</code></td>
<td>
<p>if TRUE, meshes with vertices colored according to distance are returned</p>
</td></tr>
<tr><td><code id="vcgMetro_+3A_silent">silent</code></td>
<td>
<p>logical: if TRUE, output to console is suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ForwardSampling</code>, <code>BackwardSampling</code></td>
<td>
<p>lists containing information about forward (mesh1 to mesh2) and backward (mesh2 to mesh1) sampling with the following entries</p>
</td></tr>
</table>

<ul>
<li> <p><code>maxdist</code> maximal Hausdorff distance
</p>
</li>
<li> <p><code>meandist</code> mean Hausdorff distance
</p>
</li>
<li> <p><code>RMSdist</code> RMS of the Hausdorff distances
</p>
</li>
<li> <p><code>area</code> mesh area (of <code>mesh1</code> in <code>ForwardSampling</code> and  <code>mesh2</code> in  <code>BackwardSampling</code>)
</p>
</li>
<li> <p><code>RMSdist</code> RMS of the Hausdorff distances
</p>
</li>
<li> <p><code>nvbsamples</code> number of vertices sampled
</p>
</li>
<li> <p><code>nsamples</code> number of samples
</p>
</li></ul>

<table role = "presentation">
<tr><td><code>distances1</code>, <code>distances2</code></td>
<td>
<p>vectors containing vertex distances from mesh1 to mesh2 and mesh2 to mesh1.</p>
</td></tr>
<tr><td><code>forward_hist</code>, <code>backward_hist</code></td>
<td>
<p>Matrices tracking the sampling results</p>
</td></tr>
</table>
<p>if colormeshes == TRUE
</p>
<table role = "presentation">
<tr><td><code>mesh1</code>, <code>mesh2</code></td>
<td>
<p>meshes with color coded distances and an additional entry called quality containing the sampled per-vertex distances</p>
</td></tr>
</table>


<h3>Note</h3>

<p>this is a straightforward implementation of the command line tool metro <a href="http://vcglib.net/metro.html">http://vcglib.net/metro.html</a>
</p>


<h3>References</h3>

<p>P. Cignoni, C. Rocchini and R. Scopigno. Metro: measuring error on simplified surfaces. Computer Graphics Forum, Blackwell Publishers, vol. 17(2), June 1998, pp 167-174
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("Morpho", quietly = TRUE)) {
require(Morpho)
data(humface)
data(dummyhead)
## align humface to dummyhead.mesh
humfalign &lt;- rotmesh.onto(humface,humface.lm,dummyhead.lm)
samp &lt;- vcgMetro(humfalign$mesh,dummyhead.mesh,faceSamp=FALSE,edgeSamp=FALSE)
## create heatmap using Morpho's meshDist function
}

## Not run: 
## create custom heatmaps based on distances
mD &lt;- meshDist(humfalign$mesh,distvec=samp$distances1)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgNonBorderEdge'>Get all non-border edges</h2><span id='topic+vcgNonBorderEdge'></span>

<h3>Description</h3>

<p>Get all non-border edges and both faces adjacent to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgNonBorderEdge(mesh, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgNonBorderEdge_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d</p>
</td></tr>
<tr><td><code id="vcgNonBorderEdge_+3A_silent">silent</code></td>
<td>
<p>logical: suppress output of information about number of border edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe containing:
</p>
<table role = "presentation">
<tr><td><code>vert1</code></td>
<td>
<p>integer indicating the position of the first vertex belonging to this edge</p>
</td></tr>
<tr><td><code>vert2</code></td>
<td>
<p>integer indicating the position of the second vertex belonging to this edge</p>
</td></tr>
<tr><td><code>border</code></td>
<td>
<p>integer indicating if the edge is at the border of the mesh. 0 = no border, 1 = border</p>
</td></tr>
<tr><td><code>face1</code></td>
<td>
<p>integer pointing to the first face adjacent to the edge</p>
</td></tr>
<tr><td><code>face2</code></td>
<td>
<p>integer pointing to the first face adjacent to the edge</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vcgGetEdge">vcgGetEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
edges &lt;-vcgNonBorderEdge(humface)
## show first edge (not at the border)
## Not run: 
require(Morpho)
require(rgl)
lines3d(t(humface$vb[1:3,])[c(edges$vert1[1],edges$vert2[2]),],col=2,lwd=3)

## plot barycenters of adjacent faces
bary &lt;- barycenter(humface)
points3d(bary[c(edges$face1[1],edges$face2[1]),])
shade3d(humface, col=3)
## now find the edge - hint: it is at the neck.

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgObjWrite'>Export meshes to OBJ-files</h2><span id='topic+vcgObjWrite'></span>

<h3>Description</h3>

<p>Export meshes to OBJ-files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgObjWrite(mesh, filename = dataname, writeNormals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgObjWrite_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a numeric matrix with 3-columns</p>
</td></tr>
<tr><td><code id="vcgObjWrite_+3A_filename">filename</code></td>
<td>
<p>character: filename (file extension '.obj' will be added automatically.</p>
</td></tr>
<tr><td><code id="vcgObjWrite_+3A_writenormals">writeNormals</code></td>
<td>
<p>write existing normals to file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgObjWrite(humface,filename = "humface")
unlink("humface.obj")
</code></pre>

<hr>
<h2 id='vcgOffWrite'>Export meshes to OFF-files</h2><span id='topic+vcgOffWrite'></span>

<h3>Description</h3>

<p>Export meshes to OFF-files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgOffWrite(mesh, filename = dataname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgOffWrite_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a numeric matrix with 3-columns</p>
</td></tr>
<tr><td><code id="vcgOffWrite_+3A_filename">filename</code></td>
<td>
<p>character: filename (file extension '.off' will be added automatically.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgOffWrite(humface,filename = "humface")
unlink("humface.off")
</code></pre>

<hr>
<h2 id='vcgPlyRead'>Import ascii or binary PLY files.</h2><span id='topic+vcgPlyRead'></span>

<h3>Description</h3>

<p>Reads Polygon File Format (PLY) files and stores the results in an object of
class &quot;mesh3d&quot; - momentarily only triangular meshes are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgPlyRead(file, updateNormals = TRUE, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgPlyRead_+3A_file">file</code></td>
<td>
<p>character: file to be read.</p>
</td></tr>
<tr><td><code id="vcgPlyRead_+3A_updatenormals">updateNormals</code></td>
<td>
<p>logical: if TRUE and the imported file contais faces,
vertex normals will be (re)calculated.</p>
</td></tr>
<tr><td><code id="vcgPlyRead_+3A_clean">clean</code></td>
<td>
<p>logical: if TRUE, duplicated and unreference vertices will be
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;mesh3d&quot;
</p>
<p>with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>3 x n matrix containing n vertices as homolougous coordinates</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>3 x n matrix containing vertex normals</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>3 x m integer matrix containing vertex indices forming triangular faces</p>
</td></tr>
<tr><td><code>material$color</code></td>
<td>
<p>Per vertex colors if specified in the imported file</p>
</td></tr>
</table>


<h3>Note</h3>

<p>from version 0.8 on this is only a wrapper for vcgImport (to avoid API breaking).
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgSmooth">vcgSmooth</a></code>,
</p>

<hr>
<h2 id='vcgPlyWrite'>Export meshes to PLY-files</h2><span id='topic+vcgPlyWrite'></span><span id='topic+vcgPlyWrite.mesh3d'></span><span id='topic+vcgPlyWrite.matrix'></span>

<h3>Description</h3>

<p>Export meshes to PLY-files (binary or ascii)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgPlyWrite(mesh, filename, binary = TRUE, ...)

## S3 method for class 'mesh3d'
vcgPlyWrite(
  mesh,
  filename = dataname,
  binary = TRUE,
  addNormals = FALSE,
  writeCol = TRUE,
  writeNormals = TRUE,
  ...
)

## S3 method for class 'matrix'
vcgPlyWrite(mesh, filename = dataname, binary = TRUE, addNormals = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgPlyWrite_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a numeric matrix with 3-columns</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_filename">filename</code></td>
<td>
<p>character: filename (file extension '.ply' will be added automatically, if missing.</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_binary">binary</code></td>
<td>
<p>logical: write binary file</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_...">...</code></td>
<td>
<p>additional arguments, currently not used.</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_addnormals">addNormals</code></td>
<td>
<p>logical: compute per-vertex normals and add to file</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_writecol">writeCol</code></td>
<td>
<p>logical: export existing per-vertex color stored in mesh$material$color</p>
</td></tr>
<tr><td><code id="vcgPlyWrite_+3A_writenormals">writeNormals</code></td>
<td>
<p>write existing normals to file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgPlyWrite(humface,filename = "humface")
## remove it 
unlink("humface.ply")
</code></pre>

<hr>
<h2 id='vcgQEdecim'>Performs Quadric Edge Decimation on triangular meshes.</h2><span id='topic+vcgQEdecim'></span>

<h3>Description</h3>

<p>Decimates a mesh by adapting the faces of a mesh either to a target face
number, a percentage or an approximate mesh resolution (a.k.a. mean edge
length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgQEdecim(
  mesh,
  tarface = NULL,
  percent = NULL,
  edgeLength = NULL,
  topo = FALSE,
  quality = TRUE,
  bound = FALSE,
  optiplace = FALSE,
  scaleindi = TRUE,
  normcheck = FALSE,
  qweightFactor = 100,
  qthresh = 0.3,
  boundweight = 1,
  normalthr = pi/2,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgQEdecim_+3A_mesh">mesh</code></td>
<td>
<p>Triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_tarface">tarface</code></td>
<td>
<p>Integer: set number of target faces.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_percent">percent</code></td>
<td>
<p>Numeric: between 0 and 1. Set amount of reduction relative to
existing face number. Overrides tarface argument.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_edgelength">edgeLength</code></td>
<td>
<p>Numeric: tries to decimate according to a target mean edge
length. Under the assumption of regular triangles, the edges are half as
long by dividing the triangle into 4 regular smaller triangles.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_topo">topo</code></td>
<td>
<p>logical: if TRUE, mesh topology is preserved.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_quality">quality</code></td>
<td>
<p>logical: if TRUE, vertex quality is considered.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_bound">bound</code></td>
<td>
<p>logical: if TRUE, mesh boundary is preserved.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_optiplace">optiplace</code></td>
<td>
<p>logical: if TRUE, mesh boundary is preserved (may lead to unwanted distortions in some cases).</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_scaleindi">scaleindi</code></td>
<td>
<p>logical: if TRUE, decimatiion is scale independent.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_normcheck">normcheck</code></td>
<td>
<p>logical: if TRUE, normal directions are considered.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_qweightfactor">qweightFactor</code></td>
<td>
<p>numeric: &gt;= 1. Quality range is mapped into a squared 01 and than into the 1 - QualityWeightFactor range.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_qthresh">qthresh</code></td>
<td>
<p>numeric: Quality threshold for decimation process.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_boundweight">boundweight</code></td>
<td>
<p>numeric: Weight assigned to mesh boundaries.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_normalthr">normalthr</code></td>
<td>
<p>numeric: threshold for normal check in radians.</p>
</td></tr>
<tr><td><code id="vcgQEdecim_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE no console output is issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically an adaption of the cli tridecimator from vcglib
</p>


<h3>Value</h3>

<p>Returns a reduced mesh of class mesh3d.
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgSmooth">vcgSmooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(humface)
##reduce faces to 50% 
decimface &lt;- vcgQEdecim(humface, percent=0.5)
## view
## Not run: 
require(rgl)
shade3d(decimface, col=3)

## some light smoothing
decimface &lt;- vcgSmooth(decimface,iteration = 1)

## End(Not run) 
</code></pre>

<hr>
<h2 id='vcgRaySearch'>check if a mesh is intersected by a set of rays</h2><span id='topic+vcgRaySearch'></span>

<h3>Description</h3>

<p>check if a mesh is intersected by a set of rays (stored as normals)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgRaySearch(x, mesh, mintol = 0, maxtol = 1e+15, mindist = FALSE, threads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgRaySearch_+3A_x">x</code></td>
<td>
<p>a triangular mesh of class 'mesh3d' or a list containing vertices and vertex normals (fitting the naming conventions of 'mesh3d'). In the second case x must contain x$vb = 3 x n matrix containing 3D-coordinates and x$normals = 3 x n matrix containing normals associated with x$vb.</p>
</td></tr>
<tr><td><code id="vcgRaySearch_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh to be intersected.</p>
</td></tr>
<tr><td><code id="vcgRaySearch_+3A_mintol">mintol</code></td>
<td>
<p>minimum distance to target mesh</p>
</td></tr>
<tr><td><code id="vcgRaySearch_+3A_maxtol">maxtol</code></td>
<td>
<p>maximum distance to search along ray</p>
</td></tr>
<tr><td><code id="vcgRaySearch_+3A_mindist">mindist</code></td>
<td>
<p>search both ways (ray and -ray) and select closest point.</p>
</td></tr>
<tr><td><code id="vcgRaySearch_+3A_threads">threads</code></td>
<td>
<p>number of threads used during search.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vcgRaySearch</code> projects a mesh (or set of 3D-coordinates) along a set of given rays (stored as normals) onto a target and return the hit points as well as information if the target mesh was hit at all. If nothing is hit along the ray(within the given thresholds), the ordinary closest point's value will be returned and the corresponding entry in <code>quality</code> will be zero.
</p>


<h3>Value</h3>

<p>list with following items:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing intersection points</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing homogenous coordinates of normals at intersection points</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>integer vector containing a value for each vertex of <code>x</code>: 1 indicates that a ray has intersected 'mesh' , while 0 means not</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>numeric vector: distances to intersection</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
#get normals of landmarks
lms &lt;- vcgClost(humface.lm, humface)
# offset landmarks along their normals for a negative amount of -5mm
lms$vb[1:3,] &lt;- lms$vb[1:3,]+lms$normals[1:3,]*-5
intersect &lt;- vcgRaySearch(lms, humface)
## Not run: 
require(Morpho)
require(rgl)
spheres3d(vert2points(lms),radius=0.5,col=3)
plotNormals(lms,long=5)
spheres3d(vert2points(intersect),col=2) #plot intersections
wire3d(humface,col="white")#'

## End(Not run)

</code></pre>

<hr>
<h2 id='vcgSample'>Subsamples points on a mesh surface</h2><span id='topic+vcgSample'></span>

<h3>Description</h3>

<p>Subsamples surface of a triangular mesh and returns a set of points located on that mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSample(
  mesh,
  SampleNum = 100,
  type = c("km", "pd", "mc"),
  MCsamp = 20,
  geodes = TRUE,
  strict = FALSE,
  iter.max = 100,
  threads = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSample_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d'</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_samplenum">SampleNum</code></td>
<td>
<p>integer: number of sampled points (see <code>details</code> below)</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_type">type</code></td>
<td>
<p>character: seclect sampling type (&quot;mc&quot;=MonteCarlo Sampling, &quot;pd&quot;=PoissonDisk Sampling,&quot;km&quot;=kmean clustering)</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_mcsamp">MCsamp</code></td>
<td>
<p>integer: MonteCarlo sample iterations used in PoissonDisk sampling.</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_geodes">geodes</code></td>
<td>
<p>logical: maximise geodesic distance between sample points (only for Poisson Disk sampling)</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_strict">strict</code></td>
<td>
<p>logical: if <code>type="pd"</code> and the amount of coordinates exceeds <code>SampleNum</code>,  the resulting coordinates will be subsampled again by kmean clustering to reach the requested number.</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_iter.max">iter.max</code></td>
<td>
<p>integer: maximum iterations to use in k-means clustering.</p>
</td></tr>
<tr><td><code id="vcgSample_+3A_threads">threads</code></td>
<td>
<p>integer number of threads to use for k-means clustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Poisson disk subsampling will not generate the exact amount of coordinates specified in <code>SampleNum</code>, depending on <code>MCsamp</code> the result will contain more or less coordinates.
</p>


<h3>Value</h3>

<p>sampled points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
ss &lt;- vcgSample(humface,SampleNum = 500, type="km",threads=1)
## Not run: 
require(rgl)
points3d(ss)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgSearchKDtree'>search an existing KD-tree</h2><span id='topic+vcgSearchKDtree'></span>

<h3>Description</h3>

<p>search an existing KD-tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSearchKDtree(kdtree, query, k, threads = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSearchKDtree_+3A_kdtree">kdtree</code></td>
<td>
<p>object of class vcgKDtree</p>
</td></tr>
<tr><td><code id="vcgSearchKDtree_+3A_query">query</code></td>
<td>
<p>atrix or triangular mesh containing coordinates</p>
</td></tr>
<tr><td><code id="vcgSearchKDtree_+3A_k">k</code></td>
<td>
<p>number of k-closest neighbours to query</p>
</td></tr>
<tr><td><code id="vcgSearchKDtree_+3A_threads">threads</code></td>
<td>
<p>integer: number of threads to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>
<table role = "presentation">
<tr><td><code>index</code></td>
<td>
<p>integer matrices with indeces of closest points</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>corresponding distances</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+vcgCreateKDtree">vcgCreateKDtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(humface);data(dummyhead)
mytree &lt;- vcgCreateKDtree(humface)
## get indices and distances for 10 closest points.
closest &lt;- vcgSearchKDtree(mytree,dummyhead.mesh,k=10,threads=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgSmooth'>Smoothes a triangular mesh</h2><span id='topic+vcgSmooth'></span>

<h3>Description</h3>

<p>Applies different smoothing algorithms on a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSmooth(
  mesh,
  type = c("taubin", "laplace", "HClaplace", "fujiLaplace", "angWeight",
    "surfPreserveLaplace"),
  iteration = 10,
  lambda = 0.5,
  mu = -0.53,
  delta = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSmooth_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgSmooth_+3A_type">type</code></td>
<td>
<p>character: select smoothing algorithm. Available are &quot;taubin&quot;,
&quot;laplace&quot;, &quot;HClaplace&quot;, &quot;fujiLaplace&quot;, &quot;angWeight&quot; (and any sensible
abbreviations).</p>
</td></tr>
<tr><td><code id="vcgSmooth_+3A_iteration">iteration</code></td>
<td>
<p>integer: number of iterations to run.</p>
</td></tr>
<tr><td><code id="vcgSmooth_+3A_lambda">lambda</code></td>
<td>
<p>numeric: parameter for Taubin smooth (see reference below).</p>
</td></tr>
<tr><td><code id="vcgSmooth_+3A_mu">mu</code></td>
<td>
<p>numeric:parameter for Taubin smooth (see reference below).</p>
</td></tr>
<tr><td><code id="vcgSmooth_+3A_delta">delta</code></td>
<td>
<p>numeric: parameter for Scale dependent laplacian smoothing (see
reference below).and maximum allowed angle (in radians) for deviation between normals Laplacian (surface preserving).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms available are Taubin smoothing, Laplacian smoothing and an
improved version of Laplacian smoothing (&quot;HClaplace&quot;). Also available are
Scale dependent laplacian smoothing (&quot;fujiLaplace&quot;) and Laplacian angle
weighted smoothing (&quot;angWeight&quot;)
</p>


<h3>Value</h3>

<p>returns an object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4xn matrix containing n vertices as homolougous coordinates.</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4xn matrix containing vertex normals.</p>
</td></tr>
<tr><td><code>quality</code></td>
<td>
<p>vector: containing distances to target.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>4xm matrix containing vertex indices forming triangular
faces.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The additional parameters for taubin smooth are hardcoded to the
default values of meshlab, as they appear to be the least distorting
</p>


<h3>Author(s)</h3>

<p>Stefan Schlager
</p>


<h3>References</h3>

<p>Taubin G. 1995. Curve and surface smoothing without shrinkage.
In Computer Vision, 1995. Proceedings., Fifth International Conference on,
pages 852 - 857.
</p>
<p>Vollmer J., Mencl R. and Mueller H. 1999. Improved Laplacian Smoothing of
Noisy Surface Meshes. Computer Graphics Forum, 18(3):131 - 138.
</p>
<p>Schroeder, P. and Barr, A. H. (1999). Implicit fairing of irregular meshes
using diffusion and curvature flow: 317-324.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a>,<a href="#topic+vcgClean">vcgClean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
smoothface &lt;- vcgSmooth(humface)
## view
## Not run: 
require(rgl)
shade3d(smoothface, col=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='vcgSmoothImplicit'>Implicit Smoothes a triangular mesh</h2><span id='topic+vcgSmoothImplicit'></span>

<h3>Description</h3>

<p>Applies implicit smoothing algorithms on a triangular mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSmoothImplicit(
  mesh,
  lambda = 0.2,
  useMassMatrix = TRUE,
  fixBorder = FALSE,
  useCotWeight = FALSE,
  degree = 1L,
  lapWeight = 1,
  SmoothQ = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSmoothImplicit_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh stored as object of class &quot;mesh3d&quot;.</p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_lambda">lambda</code></td>
<td>
<p>numeric: the amount of smoothness, useful only if
<code>useMassMatrix</code> is <code>TRUE</code>; default is <code>0.2</code></p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_usemassmatrix">useMassMatrix</code></td>
<td>
<p>logical: whether to use mass matrix to keep the mesh
close to its original position (weighted per area distributed on vertices);
default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_fixborder">fixBorder</code></td>
<td>
<p>logical: whether to fix the border vertices of the mesh;
default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_usecotweight">useCotWeight</code></td>
<td>
<p>logical: whether to use cotangent weight; default is
<code>FALSE</code> (using uniform 'Laplacian')</p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_degree">degree</code></td>
<td>
<p>integer: degrees of 'Laplacian'; default is <code>1</code></p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_lapweight">lapWeight</code></td>
<td>
<p>numeric: weight when <code>useCotWeight</code> is <code>FALSE</code>;
default is <code>1.0</code></p>
</td></tr>
<tr><td><code id="vcgSmoothImplicit_+3A_smoothq">SmoothQ</code></td>
<td>
<p>logical: whether to smooth the quality (distances to target).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class &quot;mesh3d&quot; with:
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4xn matrix containing n vertices as homolougous coordinates.</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4xn matrix containing vertex normals.</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>4xm matrix containing vertex indices forming triangular
faces.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhengjia Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcgPlyRead">vcgPlyRead</a>,<a href="#topic+vcgClean">vcgClean</a>,<a href="#topic+vcgSmooth">vcgSmooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(humface)
smoothface &lt;- vcgSmoothImplicit(humface)
## view
## Not run: 
require(rgl)
shade3d(smoothface, col=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='vcgSphere'>create platonic objects as triangular meshes</h2><span id='topic+vcgSphere'></span><span id='topic+vcgSphericalCap'></span><span id='topic+vcgTetrahedron'></span><span id='topic+vcgDodecahedron'></span><span id='topic+vcgOctahedron'></span><span id='topic+vcgIcosahedron'></span><span id='topic+vcgHexahedron'></span><span id='topic+vcgSquare'></span><span id='topic+vcgBox'></span><span id='topic+vcgCone'></span>

<h3>Description</h3>

<p>create platonic objects as triangular meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSphere(subdivision = 3, normals = TRUE)

vcgSphericalCap(angleRad = pi/2, subdivision = 3, normals = TRUE)

vcgTetrahedron(normals = TRUE)

vcgDodecahedron(normals = TRUE)

vcgOctahedron(normals = TRUE)

vcgIcosahedron(normals = TRUE)

vcgHexahedron(normals = TRUE)

vcgSquare(normals = TRUE)

vcgBox(mesh = vcgSphere(), normals = TRUE)

vcgCone(r1, r2, h, normals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSphere_+3A_subdivision">subdivision</code></td>
<td>
<p>subdivision level for sphere (the larger the denser the mesh will be)</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_normals">normals</code></td>
<td>
<p>if TRUE vertex normals are calculated</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_anglerad">angleRad</code></td>
<td>
<p>angle of the spherical cap</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_mesh">mesh</code></td>
<td>
<p>mesh to take the bounding box from</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_r1">r1</code></td>
<td>
<p>radius1 of the cone</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_r2">r2</code></td>
<td>
<p>radius2 of the cone</p>
</td></tr>
<tr><td><code id="vcgSphere_+3A_h">h</code></td>
<td>
<p>height of the cone</p>
</td></tr>
</table>

<hr>
<h2 id='vcgStlWrite'>Export meshes to STL-files</h2><span id='topic+vcgStlWrite'></span>

<h3>Description</h3>

<p>Export meshes to STL-files (binary or ascii)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgStlWrite(mesh, filename = dataname, binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgStlWrite_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a numeric matrix with 3-columns</p>
</td></tr>
<tr><td><code id="vcgStlWrite_+3A_filename">filename</code></td>
<td>
<p>character: filename (file extension '.stl' will be added automatically.</p>
</td></tr>
<tr><td><code id="vcgStlWrite_+3A_binary">binary</code></td>
<td>
<p>logical: write binary file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgStlWrite(humface,filename = "humface")
unlink("humface.stl")
</code></pre>

<hr>
<h2 id='vcgSubdivide'>subdivide the triangles of a mesh</h2><span id='topic+vcgSubdivide'></span>

<h3>Description</h3>

<p>subdivide the triangles of a mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgSubdivide(
  x,
  threshold = NULL,
  type = c("Butterfly", "Loop"),
  looptype = c("loop", "regularity", "continuity"),
  iterations = 3,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgSubdivide_+3A_x">x</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
<tr><td><code id="vcgSubdivide_+3A_threshold">threshold</code></td>
<td>
<p>minimum edge length to subdivide</p>
</td></tr>
<tr><td><code id="vcgSubdivide_+3A_type">type</code></td>
<td>
<p>character: algorithm used. Options are Butterfly and Loop (see notes)</p>
</td></tr>
<tr><td><code id="vcgSubdivide_+3A_looptype">looptype</code></td>
<td>
<p>character: method for type = loop options are &quot;loop&quot;,&quot;regularity&quot;,&quot;continuity&quot; (see notes)</p>
</td></tr>
<tr><td><code id="vcgSubdivide_+3A_iterations">iterations</code></td>
<td>
<p>integer: number of iterations</p>
</td></tr>
<tr><td><code id="vcgSubdivide_+3A_silent">silent</code></td>
<td>
<p>logical: suppress output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns subdivided mesh
</p>


<h3>Note</h3>

<p>The different algorithms are (from meshlab description):
</p>

<ul>
<li><p><b>Butterfly Subdivision:</b> Apply Butterfly Subdivision Surface algorithm. It is an interpolated method, defined on arbitrary triangular meshes. The scheme is known to be C1 but not C2 on regular meshes
</p>
</li>
<li><p><b>Loop Subdivision:</b> Apply Loop's Subdivision Surface algorithm. It is an approximant subdivision method and it works for every triangle and has rules for extraordinary vertices. Options are &quot;loop&quot; a simple subdivision, &quot;regularity&quot; to enhance the meshe's regularity and &quot;continuity&quot; to enhance the mesh's continuity.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
subdivide &lt;- vcgSubdivide(humface,type="Loop",looptype="regularity")

</code></pre>

<hr>
<h2 id='vcgUniformRemesh'>Resample a mesh uniformly</h2><span id='topic+vcgUniformRemesh'></span>

<h3>Description</h3>

<p>Resample a mesh uniformly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgUniformRemesh(
  x,
  voxelSize = NULL,
  offset = 0,
  discretize = FALSE,
  multiSample = FALSE,
  absDist = FALSE,
  mergeClost = FALSE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgUniformRemesh_+3A_x">x</code></td>
<td>
<p>triangular mesh</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_voxelsize">voxelSize</code></td>
<td>
<p>voxel size for space discretization</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_offset">offset</code></td>
<td>
<p>Offset of the created surface (i.e. distance of the created surface from the original one).</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_discretize">discretize</code></td>
<td>
<p>If TRUE, the position of the intersected edge of the marching cube grid is not computed by linear interpolation, but it is placed in fixed middle position. As a consequence the resampled object will look severely aliased by a stairstep appearance.</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_multisample">multiSample</code></td>
<td>
<p>If TRUE, the distance field is more accurately compute by multisampling the volume (7 sample for each voxel). Much slower but less artifacts.</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_absdist">absDist</code></td>
<td>
<p>If TRUE, an unsigned distance field is computed. In this case you have to choose a not zero Offset and a double surface is built around the original surface, inside and outside.</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_mergeclost">mergeClost</code></td>
<td>
<p>logical: merge close vertices</p>
</td></tr>
<tr><td><code id="vcgUniformRemesh_+3A_silent">silent</code></td>
<td>
<p>logical: suppress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resampled mesh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(humface)
humresample &lt;- vcgUniformRemesh(humface,voxelSize=1,multiSample = TRUE)
require(rgl)
shade3d(humresample,col=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgUpdateNormals'>updates vertex normals of a triangular meshes or point clouds</h2><span id='topic+vcgUpdateNormals'></span>

<h3>Description</h3>

<p>update vertex normals of a triangular meshes or point clouds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgUpdateNormals(mesh, type = 0, pointcloud = c(10, 0), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgUpdateNormals_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a n x 3 matrix containing 3D-coordinates.</p>
</td></tr>
<tr><td><code id="vcgUpdateNormals_+3A_type">type</code></td>
<td>
<p>select the method to compute per-vertex normals: 0=area weighted average of surrounding face normals; 1 = angle weighted vertex normals.</p>
</td></tr>
<tr><td><code id="vcgUpdateNormals_+3A_pointcloud">pointcloud</code></td>
<td>
<p>integer vector of length 2: containing optional parameters for normal calculation of point clouds. The first enty specifies the number of neighbouring points to consider. The second entry specifies the amount of smoothing iterations to be performed.</p>
</td></tr>
<tr><td><code id="vcgUpdateNormals_+3A_silent">silent</code></td>
<td>
<p>logical, if TRUE no console output is issued.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mesh with updated/created normals, or in case <code>mesh</code> is a matrix, a list of class &quot;mesh3d&quot; with
</p>
<table role = "presentation">
<tr><td><code>vb</code></td>
<td>
<p>4 x n matrix containing coordinates (as homologous coordinates</p>
</td></tr>
<tr><td><code>normals</code></td>
<td>
<p>4 x n matrix containing normals (as homologous coordinates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
humface$normals &lt;- NULL # remove normals
humface &lt;- vcgUpdateNormals(humface)
## Not run: 
pointcloud &lt;- t(humface$vb[1:3,]) #get vertex coordinates
pointcloud &lt;- vcgUpdateNormals(pointcloud)

require(Morpho)
plotNormals(pointcloud)#plot normals

## End(Not run)
</code></pre>

<hr>
<h2 id='vcgVertexNeighbors'>Compute mesh adjacency list representation or the vertex neighborhoods of specific mesh vertices.</h2><span id='topic+vcgVertexNeighbors'></span>

<h3>Description</h3>

<p>Compute the <code>k</code>-ring vertex neighborhood for all query vertex indices <code>vi</code>. If only a mesh is passed (parameter <code>x</code>) and the other parameters are left at their default values, this compute the adjacency list representation of the mesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgVertexNeighbors(x, vi = NULL, numstep = 1L, include_self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgVertexNeighbors_+3A_x">x</code></td>
<td>
<p>tmesh3d instance from the <code>rgl</code> package</p>
</td></tr>
<tr><td><code id="vcgVertexNeighbors_+3A_vi">vi</code></td>
<td>
<p>optional, vector of positive vertex indices for which to compute the neighborhoods. All vertices are used if left at the default value <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vcgVertexNeighbors_+3A_numstep">numstep</code></td>
<td>
<p>positive integer, the number of times to extend the neighborhood from the source vertices (the <code>k</code> for computing the <code>k</code>-ring neighborhood). Setting this to high values significantly increases the computational cost.</p>
</td></tr>
<tr><td><code id="vcgVertexNeighbors_+3A_include_self">include_self</code></td>
<td>
<p>logical, whether the returned neighborhood for a vertex <code>i</code> should include <code>i</code> itself.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of positive integer vectors, the neighborhoods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
adjacency_list &lt;- vcgVertexNeighbors(humface)
v500_5ring = vcgVertexNeighbors(humface, vi=c(500), numstep = 5)

</code></pre>

<hr>
<h2 id='vcgVFadj'>find all faces belonging to each vertex in a mesh</h2><span id='topic+vcgVFadj'></span>

<h3>Description</h3>

<p>find all faces belonging to each vertex in a mesh and report their indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgVFadj(mesh)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgVFadj_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class &quot;mesh3d&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing one vector per vertex containgin the indices of the adjacent faces
</p>

<hr>
<h2 id='vcgVolume'>Compute volume for manifold meshes</h2><span id='topic+vcgVolume'></span>

<h3>Description</h3>

<p>Compute volume for manifold meshes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgVolume(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgVolume_+3A_x">x</code></td>
<td>
<p>triangular mesh of class mesh3d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns volume
</p>


<h3>Note</h3>

<p>Please note, that this function only works reliably on watertight, coherently oriented meshes that constitute a manifold. In case your mesh has some issues regarding non-manifoldness or there are isolated pieces flying around, you can use vcgIsolated and vcgClean to remove those.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mysphere &lt;- vcgSphere()
vcgVolume(mysphere)
## Not run: 
## here is an example where the mesh has some non-manifold vertices

mysphere &lt;- vcgSphere(normals=FALSE)
## add a degenerate face
mysphere$it &lt;- cbind(mysphere$it,c(1,2,1))
try(vcgVolume(mysphere))

## fix the error using vcgClean():
vcgVolume(vcgClean(mysphere,sel=0:6,iterate=TRUE))

## End(Not run)


</code></pre>

<hr>
<h2 id='vcgWrlWrite'>Export meshes to WRL-files</h2><span id='topic+vcgWrlWrite'></span>

<h3>Description</h3>

<p>Export meshes to WRL-files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcgWrlWrite(mesh, filename = dataname, writeCol = TRUE, writeNormals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcgWrlWrite_+3A_mesh">mesh</code></td>
<td>
<p>triangular mesh of class 'mesh3d' or a numeric matrix with 3-columns</p>
</td></tr>
<tr><td><code id="vcgWrlWrite_+3A_filename">filename</code></td>
<td>
<p>character: filename (file extension '.wrl' will be added automatically.</p>
</td></tr>
<tr><td><code id="vcgWrlWrite_+3A_writecol">writeCol</code></td>
<td>
<p>logical: export existing per-vertex color stored in mesh$material$color</p>
</td></tr>
<tr><td><code id="vcgWrlWrite_+3A_writenormals">writeNormals</code></td>
<td>
<p>write existing normals to file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(humface)
vcgWrlWrite(humface,filename = "humface")
unlink("humface.wrl")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
