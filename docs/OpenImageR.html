<!DOCTYPE html><html><head><title>Help for package OpenImageR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OpenImageR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Augmentation'><p>image augmentations of a matrix, data frame, array or a list of 3-dimensional arrays (where the third dimension is equal to 3)</p></a></li>
<li><a href='#average_hash'><p>calculation of the 'average hash' of an image</p></a></li>
<li><a href='#convolution'><p>convolution</p></a></li>
<li><a href='#crop_image_secondary'><p>crop an image in R  [ for RGB or grey images ]</p></a></li>
<li><a href='#cropImage'><p>crop an image</p></a></li>
<li><a href='#delationErosion'><p>Delation or Erosion of an image</p></a></li>
<li><a href='#dhash'><p>calculation of the 'dhash' of an image</p></a></li>
<li><a href='#dilationErosion'><p>Dilation or Erosion of an image</p></a></li>
<li><a href='#down_sample_image'><p>downsampling an image ( by a factor ) using gaussian blur</p></a></li>
<li><a href='#edge_detection'><p>edge detection (Frei_chen, LoG, Prewitt, Roberts_cross, Scharr, Sobel)</p></a></li>
<li><a href='#flipImage'><p>flip image horizontally or vertically</p></a></li>
<li><a href='#func_chech_range'><p>function to check the range of values of an image or normalize an image</p></a></li>
<li><a href='#func_transform'><p>secondary function for HOG_apply</p></a></li>
<li><a href='#GaborFeatureExtract'><p>Gabor Feature Extraction</p></a></li>
<li><a href='#gamma_correction'><p>Gamma correction</p></a></li>
<li><a href='#gaussian_kernel'><p>gaussian-kernel</p></a></li>
<li><a href='#getAffineTransform'><p>Get Affine Transform</p></a></li>
<li><a href='#hash_apply'><p>calculate the binary or the hexadecimal hash for a matrix, array or a folder of images for the average_hash, phash or dhash functions</p></a></li>
<li><a href='#HOG'><p>calculate the HOG (Histogram of oriented gradients) for an image</p></a></li>
<li><a href='#HOG_apply'><p>calculate the HOG (Histogram of oriented gradients) for a matrix, array or a folder of images</p></a></li>
<li><a href='#image_thresholding'><p>image thresholding</p></a></li>
<li><a href='#imageShow'><p>display an image</p></a></li>
<li><a href='#invariant_hash'><p>invariant hashing (caclulation of the hamming or the levenshtein distance when the image is flipped, rotated or cropped)</p></a></li>
<li><a href='#laplacian_kernels'><p>laplacian kernels</p></a></li>
<li><a href='#List_2_Array'><p>convert a list of matrices to an array of matrices</p></a></li>
<li><a href='#load_binary'><p>loads either 2- or 3-dimensional data (where the third dimension is equal to 3) from a binary file</p></a></li>
<li><a href='#MinMaxObject'><p>minimum and maximum values of vector, matrix, data frame or array</p></a></li>
<li><a href='#norm_matrix_range'><p>Normalize a matrix to specific range of values</p></a></li>
<li><a href='#NormalizeObject'><p>normalize a vector, matrix or array (in the range between 0 and 1)</p></a></li>
<li><a href='#padding'><p>Padding of matrices or n-dimensional arrays with a user specified value</p></a></li>
<li><a href='#phash'><p>calculation of the 'phash' of an image</p></a></li>
<li><a href='#readImage'><p>this function reads various types of images</p></a></li>
<li><a href='#resizeImage'><p>resize an image using the 'nearest neighbors' or the 'bilinear' method</p></a></li>
<li><a href='#rgb_2gray'><p>convert an RGB image to Gray</p></a></li>
<li><a href='#RGB_to_HSV'><p>Conversion of RGB to HSV colour type</p></a></li>
<li><a href='#RGB_to_Lab'><p>Conversion of RGB to Lab colour type</p></a></li>
<li><a href='#rotateFixed'><p>Rotate an image by 90, 180, 270 degrees</p></a></li>
<li><a href='#rotateImage'><p>Rotate an image using the 'nearest' or 'bilinear' method</p></a></li>
<li><a href='#runUI'><p>launcher for the shiny application</p></a></li>
<li><a href='#sec_gaus_bl'><p>secondary function for downsampling</p></a></li>
<li><a href='#sec_resiz_array'><p>secondary function for 'resizeImage'  [ array ]</p></a></li>
<li><a href='#superpixel_bbox'><p>Bounding box for the superpixel labels</p></a></li>
<li><a href='#superpixel_bbox_subset'><p>Bounding box for a subset of superpixel labels</p></a></li>
<li><a href='#superpixels'><p>SLIC and SLICO superpixel implementations</p></a></li>
<li><a href='#switch_filter'><p>secondary function for edge_detection function</p></a></li>
<li><a href='#switch_hashing'><p>if-else function for hashing</p></a></li>
<li><a href='#switch_invariant'><p>secondary function for invariant_hash</p></a></li>
<li><a href='#translation'><p>image translation</p></a></li>
<li><a href='#uniform_filter'><p>uniform filter (convolution with uniform kernel)</p></a></li>
<li><a href='#verify_image_extension'><p>Verify that the input image extension is valid</p></a></li>
<li><a href='#warpAffine'><p>Warp Affine</p></a></li>
<li><a href='#writeImage'><p>This function writes 2- or 3-dimensional image (where the third dimension is equal to 3) data to a file</p></a></li>
<li><a href='#ZCAwhiten'><p>zca whiten of an image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Image Processing Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlampros/OpenImageR/issues">https://github.com/mlampros/OpenImageR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/OpenImageR">https://github.com/mlampros/OpenImageR</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Incorporates functions for image preprocessing, filtering and image recognition. The package takes advantage of 'RcppArmadillo' to speed up computationally intensive functions. The histogram of oriented gradients descriptor is a modification of the 'findHOGFeatures' function of the 'SimpleCV' computer vision platform, the average_hash(), dhash() and phash() functions are based on the 'ImageHash' python library. The Gabor Feature Extraction functions are based on 'Matlab' code of the paper, "CloudID: Trustworthy cloud-based and cross-enterprise biometric identification" by M. Haghighat, S. Zonouz, M. Abdel-Mottaleb, Expert Systems with Applications, vol. 42, no. 21, pp. 7905-7916, 2015, &lt;<a href="https://doi.org/10.1016%2Fj.eswa.2015.06.025">doi:10.1016/j.eswa.2015.06.025</a>&gt;. The 'SLIC' and 'SLICO' superpixel algorithms were explained in detail in (i) "SLIC Superpixels Compared to State-of-the-art Superpixel Methods", Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine Suesstrunk, IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 34, num. 11, p. 2274-2282, May 2012, &lt;<a href="https://doi.org/10.1109%2FTPAMI.2012.120">doi:10.1109/TPAMI.2012.120</a>&gt; and (ii) "SLIC Superpixels", Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine Suesstrunk, EPFL Technical Report no. 149300, June 2010.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Copyright:</td>
<td>inst/COPYRIGHTS</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libarmadillo: apt-get install -y libarmadillo-dev
(deb), libblas: apt-get install -y libblas-dev (deb),
liblapack: apt-get install -y liblapack-dev (deb),
libarpack++2: apt-get install -y libarpack++2-dev (deb),
gfortran: apt-get install -y gfortran (deb), libjpeg-dev:
apt-get install -y libjpeg-dev (deb), libpng-dev: apt-get
install -y libpng-dev (deb), libfftw3-dev: apt-get install -y
libfftw3-dev (deb), libtiff5-dev: apt-get install -y
libtiff5-dev (deb)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.17), graphics, grDevices, grid, shiny, jpeg,
png, tiff, R6, lifecycle, tools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.8.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-08 07:59:50 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Sight Machine [cph] (findHOGFeatures function of the SimpleCV computer
    vision platform),
  Johannes Buchner [cph] (average_hash, dhash and phash functions of the
    ImageHash python library),
  Mohammad Haghighat [cph] (Gabor Feature Extraction),
  Radhakrishna Achanta [cph] (Author of the C++ code of the SLIC and
    SLICO algorithms (for commercial use please contact the author)),
  Oleh Onyshchak [cph] (Author of the Python code of the WarpAffine
    function)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-08 11:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Augmentation'>image augmentations of a matrix, data frame, array or a list of 3-dimensional arrays (where the third dimension is equal to 3)</h2><span id='topic+Augmentation'></span>

<h3>Description</h3>

<p>image augmentations of a matrix, data frame, array or a list of 3-dimensional arrays (where the third dimension is equal to 3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Augmentation(
  image,
  flip_mode = NULL,
  crop_width = NULL,
  crop_height = NULL,
  resiz_width = 0,
  resiz_height = 0,
  resiz_method = "nearest",
  shift_rows = 0,
  shift_cols = 0,
  rotate_angle = 0,
  rotate_method = "nearest",
  zca_comps = 0,
  zca_epsilon = 0,
  image_thresh = 0,
  padded_value = 0,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Augmentation_+3A_image">image</code></td>
<td>
<p>a matrix, data frame, array or list of 3-dimensional arrays where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_flip_mode">flip_mode</code></td>
<td>
<p>a character string ('horizontal', 'vertical')</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_crop_width">crop_width</code></td>
<td>
<p>an integer specifying the new width of the image, after the image is cropped. Corresponds to the image-rows.</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_crop_height">crop_height</code></td>
<td>
<p>an integer specifying the new height of the image, after the image is cropped. Corresponds to the image-columns.</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_resiz_width">resiz_width</code></td>
<td>
<p>an integer specifying the new width of the image, after the image is resized. Corresponds to the image-rows.</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_resiz_height">resiz_height</code></td>
<td>
<p>an integer specifying the new height of the image, after the image is resized. Corresponds to the image-columns.</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_resiz_method">resiz_method</code></td>
<td>
<p>a string specifying the interpolation method when resizing an image ('nearest', 'bilinear')</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_shift_rows">shift_rows</code></td>
<td>
<p>a positive or negative integer specifying the direction that the rows should be shifted</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_shift_cols">shift_cols</code></td>
<td>
<p>a positive or negative integer specifying the direction that the columns should be shifted</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_rotate_angle">rotate_angle</code></td>
<td>
<p>an integer specifying the rotation angle of the image</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_rotate_method">rotate_method</code></td>
<td>
<p>a string specifying the interpolation method when rotating an image ('nearest', 'bilinear')</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_zca_comps">zca_comps</code></td>
<td>
<p>an integer specifying the number of components to keep by zca whitening, when svd is performed</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_zca_epsilon">zca_epsilon</code></td>
<td>
<p>a float specifying the regularization parameter by zca whitening</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_image_thresh">image_thresh</code></td>
<td>
<p>the threshold parameter, by image thresholding, should be between 0 and 1 if the data is normalized or between 0-255 otherwise</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_padded_value">padded_value</code></td>
<td>
<p>either a numeric value or a numeric vector of length equal to N of an N-dimensional array. If it's not equal to 0 then the values of the shifted rows or columns will be filled with the user-defined padded_value. Applies only to the shift_rows and shift_cols parameters.</p>
</td></tr>
<tr><td><code id="Augmentation_+3A_verbose">verbose</code></td>
<td>
<p>a boolean (TRUE, FALSE). If TRUE, then the total time of the preprocessing task will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes advantage of various methods to accomplish image augmentations. The order of the preprocessing steps, in case that all transformations are applied to an image,
is : 1st flip image, 2nd crop image, 3rd resize image, 4th shift rows or columns, 5th rotate image, 6th zca-whitening and 7th image-thresholding.
</p>


<h3>Value</h3>

<p>the output is of the same type with the input (in case of a data frame it returns a matrix)
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# a matrix
object = matrix(1, 10, 10)

res = Augmentation(object, resiz_width = 8, resiz_height = 8, rotate_angle = 40)


# an array
object = array(0, dim = c(10, 10, 3))

res = Augmentation(object, resiz_width = 8, resiz_height = 8, rotate_angle = 30)


# an array (multiple matrices)
object = array(0, dim = c(10, 10, 10))

res = Augmentation(object, resiz_width = 8, resiz_height = 8, rotate_angle = 20)


# a list of 3-dimensional arrays (where the third dimension is equal to 3)
object = list(array(0, dim = c(10, 10, 3)), array(0, dim = c(10, 10, 3)))

res = Augmentation(object, resiz_width = 8, resiz_height = 8, rotate_angle = 40)

## End(Not run)
</code></pre>

<hr>
<h2 id='average_hash'>calculation of the 'average hash' of an image</h2><span id='topic+average_hash'></span>

<h3>Description</h3>

<p>This function calculates the average hash of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_hash(gray_image, hash_size = 8, MODE = "hash", resize = "nearest")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_hash_+3A_gray_image">gray_image</code></td>
<td>
<p>a (2-dimensional) matrix or data frame</p>
</td></tr>
<tr><td><code id="average_hash_+3A_hash_size">hash_size</code></td>
<td>
<p>an integer specifying the hash size (should be less than number of rows or columns of the gray_image)</p>
</td></tr>
<tr><td><code id="average_hash_+3A_mode">MODE</code></td>
<td>
<p>one of 'hash' (returns the hash of the image), 'binary' (returns binary identifier of the image)</p>
</td></tr>
<tr><td><code id="average_hash_+3A_resize">resize</code></td>
<td>
<p>corresponds to one of 'nearest', 'bilinear' (resizing method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a modification of the 'average_hash' function of the imagehash package [ please consult the COPYRIGHT file ]. The average hash works
in the following way : 1st convert to grayscale, 2nd, reduce the size of an image (for instance to an 8x8 image, to further simplify
the number of computations), 3rd average the resulting colors (for an 8x8 image we average 64 colors), 4th compute the bits by comparing if each color value
is above or below the mean, 5th construct the hash.
</p>


<h3>Value</h3>

<p>either a hash-string or a binary vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
image = readImage(system.file("tmp_images", "1.png", package = "OpenImageR"))

image = rgb_2gray(image)

res_hash = average_hash(image, hash_size = 8, MODE = 'hash')

res_binary = average_hash(image, hash_size = 8, MODE = 'binary')

</code></pre>

<hr>
<h2 id='convolution'>convolution</h2><span id='topic+convolution'></span>

<h3>Description</h3>

<p>convolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolution(image, kernel, mode = "same")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolution_+3A_image">image</code></td>
<td>
<p>either a matrix, data frame or array</p>
</td></tr>
<tr><td><code id="convolution_+3A_kernel">kernel</code></td>
<td>
<p>a kernel in form of a matrix</p>
</td></tr>
<tr><td><code id="convolution_+3A_mode">mode</code></td>
<td>
<p>the convolution mode (one of 'same', 'full')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs convolution using a kernel matrix. When mode 'same' the output object has the same dimensions with the input, whereas
when mode 'full' the rows and columns of the output object equals : ROWS = nrow(image) + nrow(kernel) - 1 and COLUMNS = ncol(image) + ncol(kernel) - 1
</p>


<h3>Value</h3>

<p>either a matrix or an array, depending on the input data
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# kernel
x = matrix(1, nrow = 4, ncol = 4) / 16   # uniform


# matrix
image_matrix = matrix(runif(100), 10, 10)

res = convolution(image_matrix, x, "same")


# array
image_array = array(runif(300), dim = c(10, 10, 3))

res = convolution(image_array, x, "same")

</code></pre>

<hr>
<h2 id='crop_image_secondary'>crop an image in R  [ for RGB or grey images ]</h2><span id='topic+crop_image_secondary'></span>

<h3>Description</h3>

<p>crop an image in R  [ for RGB or grey images ]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_image_secondary(image, new_width, new_height)
</code></pre>

<hr>
<h2 id='cropImage'>crop an image</h2><span id='topic+cropImage'></span>

<h3>Description</h3>

<p>crop an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cropImage(image, new_width, new_height, type = "equal_spaced")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cropImage_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="cropImage_+3A_new_width">new_width</code></td>
<td>
<p>Corresponds to the image-rows. If 'equal_spaced' then the new_width should be numeric of length 1. If 'user_defined' then the new_width should be a sequence of numeric values.</p>
</td></tr>
<tr><td><code id="cropImage_+3A_new_height">new_height</code></td>
<td>
<p>Corresponds to the image-columns. If 'equal_spaced' then the new_height should be numeric of length 1. If 'user_defined' then the new_height should be a sequence of numeric values.</p>
</td></tr>
<tr><td><code id="cropImage_+3A_type">type</code></td>
<td>
<p>a string specifying the type ('equal_spaced' or 'user_defined'). If 'equal_spaced' the image will be cropped towards the center (equal distances horizontaly and verticaly). If 'user_defined' the user specifies the cropped region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function crops an image in two different ways.
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image = readImage(path)

# IF 'equal_spaced':
crop1 = cropImage(image, new_width = 20, new_height = 20, type = 'equal_spaced')

# IF 'user_defined':
crop2 = cropImage(image, new_width = 5:20, new_height = 5:20, type = 'user_defined')

</code></pre>

<hr>
<h2 id='delationErosion'>Delation or Erosion of an image</h2><span id='topic+delationErosion'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
</p>
<p>This function was deprecated because I realized that the name of the function does not correspond to the name of the algorithm (delation -&gt; dilation)
</p>
<p>this function performs delation or erosion to a 2- or 3- dimensional image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delationErosion(image, Filter, method = "delation", threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delationErosion_+3A_image">image</code></td>
<td>
<p>a matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="delationErosion_+3A_filter">Filter</code></td>
<td>
<p>a vector specifying the dimensions of the kernel, which will be used to perform either delation or erosion, such as c(3,3)</p>
</td></tr>
<tr><td><code id="delationErosion_+3A_method">method</code></td>
<td>
<p>one of 'delation', 'erosion'</p>
</td></tr>
<tr><td><code id="delationErosion_+3A_threads">threads</code></td>
<td>
<p>number of cores to run in parallel ( &gt; 1 should be used if image high dimensional )</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes a kernel to perform delation or erosion. The first value of the vector indicates the number of rows of the kernel, whereas
the second value indicates the number of columns.
</p>


<h3>Value</h3>

<p>a matrix or 3-dimensional array where the third dimension is equal to 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res_delate = delationErosion(image, Filter = c(3,3), method = 'delation')

res_erode = delationErosion(image, Filter = c(5,5), method = 'erosion')

# -&gt;

res_dilate = dilationErosion(image, Filter = c(3,3), method = 'dilation')

res_erode = dilationErosion(image, Filter = c(5,5), method = 'erosion')

</code></pre>

<hr>
<h2 id='dhash'>calculation of the 'dhash' of an image</h2><span id='topic+dhash'></span>

<h3>Description</h3>

<p>This function calculates the dhash of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhash(gray_image, hash_size = 8, MODE = "hash", resize = "nearest")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhash_+3A_gray_image">gray_image</code></td>
<td>
<p>a (2-dimensional) matrix or data frame</p>
</td></tr>
<tr><td><code id="dhash_+3A_hash_size">hash_size</code></td>
<td>
<p>an integer specifying the hash size (should be less than number of rows or columns of the gray_image)</p>
</td></tr>
<tr><td><code id="dhash_+3A_mode">MODE</code></td>
<td>
<p>one of 'hash' (returns the hash of the image), 'binary' (returns binary identifier of the image)</p>
</td></tr>
<tr><td><code id="dhash_+3A_resize">resize</code></td>
<td>
<p>corresponds to one of 'nearest', 'bilinear'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a modification of the 'dhash' function of the imagehash package [ please consult the COPYRIGHT file ]. In comparison to
average_hash and phash, the dhash algorithm takes into consideration the difference between adjacent pixels.
</p>


<h3>Value</h3>

<p>either a hash-string or a binary vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
image = readImage(system.file("tmp_images", "3.jpeg", package = "OpenImageR"))

image = rgb_2gray(image)

res_hash = dhash(image, hash_size = 8, MODE = 'hash')

res_binary = dhash(image, hash_size = 8, MODE = 'binary')

</code></pre>

<hr>
<h2 id='dilationErosion'>Dilation or Erosion of an image</h2><span id='topic+dilationErosion'></span>

<h3>Description</h3>

<p>this function performs dilation or erosion to a 2- or 3- dimensional image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dilationErosion(image, Filter, method = "dilation", threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dilationErosion_+3A_image">image</code></td>
<td>
<p>a matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="dilationErosion_+3A_filter">Filter</code></td>
<td>
<p>a vector specifying the dimensions of the kernel, which will be used to perform either dilation or erosion, such as c(3,3)</p>
</td></tr>
<tr><td><code id="dilationErosion_+3A_method">method</code></td>
<td>
<p>one of 'dilation', 'erosion'</p>
</td></tr>
<tr><td><code id="dilationErosion_+3A_threads">threads</code></td>
<td>
<p>number of cores to run in parallel ( &gt; 1 should be used if image high dimensional )</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes a kernel to perform dilation or erosion. The first value of the vector indicates the number of rows of the kernel, whereas
the second value indicates the number of columns.
</p>


<h3>Value</h3>

<p>a matrix or 3-dimensional array where the third dimension is equal to 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res_dilate = dilationErosion(image, Filter = c(3,3), method = 'dilation')

res_erode = dilationErosion(image, Filter = c(5,5), method = 'erosion')

</code></pre>

<hr>
<h2 id='down_sample_image'>downsampling an image ( by a factor ) using gaussian blur</h2><span id='topic+down_sample_image'></span>

<h3>Description</h3>

<p>downsampling an image ( by a factor ) using gaussian blur
</p>


<h3>Usage</h3>

<pre><code class='language-R'>down_sample_image(
  image,
  factor,
  gaussian_blur = FALSE,
  gauss_sigma = 1,
  range_gauss = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="down_sample_image_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="down_sample_image_+3A_factor">factor</code></td>
<td>
<p>a positive number greater or equal to 1.0</p>
</td></tr>
<tr><td><code id="down_sample_image_+3A_gaussian_blur">gaussian_blur</code></td>
<td>
<p>a boolean (TRUE,FALSE) specifying if gaussian blur should be applied when downsampling</p>
</td></tr>
<tr><td><code id="down_sample_image_+3A_gauss_sigma">gauss_sigma</code></td>
<td>
<p>float parameter sigma for the gaussian filter</p>
</td></tr>
<tr><td><code id="down_sample_image_+3A_range_gauss">range_gauss</code></td>
<td>
<p>float number specifying the range of values for the gaussian filter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function downsamples an image with the option to use gaussian blur for optimal output.
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image = readImage(path)

dsamp = down_sample_image(image, factor = 2.0, gaussian_blur = TRUE)

</code></pre>

<hr>
<h2 id='edge_detection'>edge detection (Frei_chen, LoG, Prewitt, Roberts_cross, Scharr, Sobel)</h2><span id='topic+edge_detection'></span>

<h3>Description</h3>

<p>edge detection (Frei_chen, LoG, Prewitt, Roberts_cross, Scharr, Sobel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_detection(
  image,
  method = NULL,
  conv_mode = "same",
  approx = F,
  gaussian_dims = 5,
  sigma = 1,
  range_gauss = 2,
  laplacian_type = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_detection_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array and the third dimension must be equal to 3</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_method">method</code></td>
<td>
<p>the method should be one of 'Frei_chen', 'LoG' (Laplacian of Gaussian), 'Prewitt', 'Roberts_cross', 'Scharr', 'Sobel'</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_conv_mode">conv_mode</code></td>
<td>
<p>the convolution mode should be one of 'same', 'full'</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_approx">approx</code></td>
<td>
<p>if TRUE, approximate calculation of gradient (applies to all filters except for 'LoG')</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_gaussian_dims">gaussian_dims</code></td>
<td>
<p>integer specifying the horizontal and vertical dimensions of the gaussian filter</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_sigma">sigma</code></td>
<td>
<p>float parameter sigma for the gaussian filter</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_range_gauss">range_gauss</code></td>
<td>
<p>float number specifying the range of values for the gaussian filter</p>
</td></tr>
<tr><td><code id="edge_detection_+3A_laplacian_type">laplacian_type</code></td>
<td>
<p>integer value specifying the type for the laplacian kernel (one of 1, 2, 3, 4)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes either a matrix or a 3-dimensional array (where the third dimension is equal to 3) and it performs edge detection using one of the following filters : 'Frei_chen', 'LoG' (Laplacian of Gaussian),
'Prewitt', 'Roberts_cross', 'Scharr', 'Sobel'
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res = edge_detection(image, method = 'Frei_chen', conv_mode = 'same')

</code></pre>

<hr>
<h2 id='flipImage'>flip image horizontally or vertically</h2><span id='topic+flipImage'></span>

<h3>Description</h3>

<p>flip an image row-wise (horizontally) or column-wise (vertically)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipImage(image, mode = "horizontal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flipImage_+3A_image">image</code></td>
<td>
<p>a matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="flipImage_+3A_mode">mode</code></td>
<td>
<p>one of 'horizontal', 'vertical'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function flips an image row-wise or column-wise
</p>


<h3>Value</h3>

<p>a matrix or 3-dimensional array where the third dimension is equal to 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

im = readImage(path)

flp = flipImage(im, mode = 'vertical')

</code></pre>

<hr>
<h2 id='func_chech_range'>function to check the range of values of an image or normalize an image</h2><span id='topic+func_chech_range'></span>

<h3>Description</h3>

<p>function to check the range of values of an image or normalize an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_chech_range(image)
</code></pre>

<hr>
<h2 id='func_transform'>secondary function for HOG_apply</h2><span id='topic+func_transform'></span>

<h3>Description</h3>

<p>secondary function for HOG_apply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>func_transform(image, folder_path, flag_type, RGB_2gray = F)
</code></pre>

<hr>
<h2 id='GaborFeatureExtract'>Gabor Feature Extraction</h2><span id='topic+GaborFeatureExtract'></span>

<h3>Description</h3>

<p>Gabor Feature Extraction
</p>
<p>Gabor Feature Extraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'># init &lt;- GaborFeatureExtract$new()
</code></pre>


<h3>Details</h3>

<p>In case of an RGB image (3-dimensional where the third dimension is equal to 3) one can use the <em>rgb_2gray()</em> to convert the image to a 2-dimensional one
</p>
<p>I added the option <em>downsample_gabor</em> to the original matlab code based on the following question on stackoverflow : <em>https://stackoverflow.com/questions/49119991/feature-extraction-with-gabor-filters</em>
</p>


<h3>Methods</h3>


<dl>
<dt><code>GaborFeatureExtract$new()</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>gabor_filter_bank(scales, orientations, gabor_rows, gabor_columns, plot_data = FALSE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>gabor_feature_extraction(image, scales, orientations, gabor_rows, gabor_columns, downsample_gabor = FALSE, plot_data = FALSE,
                                      downsample_rows = NULL, downsample_cols = NULL, normalize_features = FALSE, threads = 1, vectorize_magnitude = TRUE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>gabor_feature_engine(img_data, img_nrow, img_ncol, scales, orientations, gabor_rows, gabor_columns, downsample_gabor = FALSE,
                                  downsample_rows = NULL, downsample_cols = NULL, normalize_features = FALSE, threads = 1, verbose = FALSE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>plot_gabor(real_matrices, margin_btw_plots = 0.15, thresholding = FALSE)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
<dt><code>plot_multi_images(list_images, par_ROWS, par_COLS)</code></dt><dd></dd>
<dt><code>--------------</code></dt><dd></dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GaborFeatureExtract-new"><code>GaborFeatureExtract$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-gabor_filter_bank"><code>GaborFeatureExtract$gabor_filter_bank()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-gabor_feature_extraction"><code>GaborFeatureExtract$gabor_feature_extraction()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-gabor_feature_engine"><code>GaborFeatureExtract$gabor_feature_engine()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-plot_gabor"><code>GaborFeatureExtract$plot_gabor()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-plot_multi_images"><code>GaborFeatureExtract$plot_multi_images()</code></a>
</p>
</li>
<li> <p><a href="#method-GaborFeatureExtract-clone"><code>GaborFeatureExtract$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GaborFeatureExtract-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$new()</pre></div>


<hr>
<a id="method-GaborFeatureExtract-gabor_filter_bank"></a>



<h4>Method <code>gabor_filter_bank()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$gabor_filter_bank(
  scales,
  orientations,
  gabor_rows,
  gabor_columns,
  plot_data = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>scales</code></dt><dd><p>a numeric value. Number of scales (usually set to 5)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>orientations</code></dt><dd><p>a numeric value. Number of orientations (usually set to 8)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_rows</code></dt><dd><p>a numeric value. Number of rows of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_columns</code></dt><dd><p>a numeric value. Number of columns of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)       ( gabor_filter_bank function )</p>
</dd>
<dt><code>plot_data</code></dt><dd><p>either TRUE or FALSE. If TRUE then data needed for plotting will be returned     ( gabor_filter_bank, gabor_feature_extraction functions )</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GaborFeatureExtract-gabor_feature_extraction"></a>



<h4>Method <code>gabor_feature_extraction()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$gabor_feature_extraction(
  image,
  scales,
  orientations,
  gabor_rows,
  gabor_columns,
  downsample_gabor = FALSE,
  plot_data = FALSE,
  downsample_rows = NULL,
  downsample_cols = NULL,
  normalize_features = FALSE,
  threads = 1,
  verbose = FALSE,
  vectorize_magnitude = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>image</code></dt><dd><p>a 2-dimensional image of type matrix    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>scales</code></dt><dd><p>a numeric value. Number of scales (usually set to 5)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>orientations</code></dt><dd><p>a numeric value. Number of orientations (usually set to 8)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_rows</code></dt><dd><p>a numeric value. Number of rows of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_columns</code></dt><dd><p>a numeric value. Number of columns of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)       ( gabor_filter_bank function )</p>
</dd>
<dt><code>downsample_gabor</code></dt><dd><p>either TRUE or FALSE. If TRUE then downsampling of data will take place. The <em>downsample_rows</em> and <em>downsample_cols</em> should be adjusted accordingly. Downsampling does not affect the output plots but the output <em>gabor_features</em>     ( gabor_feature_extraction function )</p>
</dd>
<dt><code>plot_data</code></dt><dd><p>either TRUE or FALSE. If TRUE then data needed for plotting will be returned     ( gabor_filter_bank, gabor_feature_extraction functions )</p>
</dd>
<dt><code>downsample_rows</code></dt><dd><p>either NULL or a numeric value specifying the factor of downsampling along rows    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>downsample_cols</code></dt><dd><p>either NULL or a numeric value specifying the factor of downsampling along columns    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>normalize_features</code></dt><dd><p>either TRUE or FALSE. If TRUE then the output gabor-features will be normalized to zero mean and unit variance    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>threads</code></dt><dd><p>a numeric value specifying the number of threads to use    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>verbose</code></dt><dd><p>either TRUE or FALSE. If TRUE then information will be printed in the console    ( gabor_feature_extraction, gabor_feature_engine functions )</p>
</dd>
<dt><code>vectorize_magnitude</code></dt><dd><p>either TRUE or FALSE. If TRUE the computed magnitude feature will be returned in the form of a vector, otherwise it will be returned as a list of matrices  ( gabor_feature_extraction function )</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GaborFeatureExtract-gabor_feature_engine"></a>



<h4>Method <code>gabor_feature_engine()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$gabor_feature_engine(
  img_data,
  img_nrow,
  img_ncol,
  scales,
  orientations,
  gabor_rows,
  gabor_columns,
  downsample_gabor = FALSE,
  downsample_rows = NULL,
  downsample_cols = NULL,
  normalize_features = FALSE,
  threads = 1,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>img_data</code></dt><dd><p>a numeric matrix specifying the input data (gabor_feature_engine function)</p>
</dd>
<dt><code>img_nrow</code></dt><dd><p>an integer specifying the number of rows of the input matrix (gabor_feature_engine function)</p>
</dd>
<dt><code>img_ncol</code></dt><dd><p>an integer specifying the number of columns of the input matrix (gabor_feature_engine function)</p>
</dd>
<dt><code>scales</code></dt><dd><p>a numeric value. Number of scales (usually set to 5)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>orientations</code></dt><dd><p>a numeric value. Number of orientations (usually set to 8)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_rows</code></dt><dd><p>a numeric value. Number of rows of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)     ( gabor_filter_bank function )</p>
</dd>
<dt><code>gabor_columns</code></dt><dd><p>a numeric value. Number of columns of the 2-D Gabor filter (an odd integer number, usually set to 39 depending on the image size)       ( gabor_filter_bank function )</p>
</dd>
<dt><code>downsample_gabor</code></dt><dd><p>either TRUE or FALSE. If TRUE then downsampling of data will take place. The <em>downsample_rows</em> and <em>downsample_cols</em> should be adjusted accordingly. Downsampling does not affect the output plots but the output <em>gabor_features</em>     ( gabor_feature_extraction function )</p>
</dd>
<dt><code>downsample_rows</code></dt><dd><p>either NULL or a numeric value specifying the factor of downsampling along rows    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>downsample_cols</code></dt><dd><p>either NULL or a numeric value specifying the factor of downsampling along columns    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>normalize_features</code></dt><dd><p>either TRUE or FALSE. If TRUE then the output gabor-features will be normalized to zero mean and unit variance    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>threads</code></dt><dd><p>a numeric value specifying the number of threads to use    ( gabor_feature_extraction function )</p>
</dd>
<dt><code>verbose</code></dt><dd><p>either TRUE or FALSE. If TRUE then information will be printed in the console    ( gabor_feature_extraction, gabor_feature_engine functions )</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GaborFeatureExtract-plot_gabor"></a>



<h4>Method <code>plot_gabor()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$plot_gabor(
  real_matrices,
  margin_btw_plots = 0.65,
  thresholding = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>real_matrices</code></dt><dd><p>a list of 3-dimensional arrays (where the third dimension is equal to 3). These arrays correspond to the <em>real part</em> of the complex output matrices      ( plot_gabor function )</p>
</dd>
<dt><code>margin_btw_plots</code></dt><dd><p>a float between 0.0 and 1.0 specifying the margin between the multiple output plots      ( plot_gabor function )</p>
</dd>
<dt><code>thresholding</code></dt><dd><p>either TRUE or FALSE. If TRUE then a threshold of 0.5 will be used to push values above 0.5 to 1.0 ( similar to otsu-thresholding )      ( plot_gabor function )</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GaborFeatureExtract-plot_multi_images"></a>



<h4>Method <code>plot_multi_images()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$plot_multi_images(
  list_images,
  par_ROWS,
  par_COLS,
  axes = FALSE,
  titles = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>list_images</code></dt><dd><p>a list containing the images to plot  ( plot_multi_images function )</p>
</dd>
<dt><code>par_ROWS</code></dt><dd><p>a numeric value specifying the number of rows of the plot-grid  ( plot_multi_images function )</p>
</dd>
<dt><code>par_COLS</code></dt><dd><p>a numeric value specifying the number of columns of the plot-grid  ( plot_multi_images function )</p>
</dd>
<dt><code>axes</code></dt><dd><p>a boolean. If TRUE then the X- and Y-range of values (axes) will appear in the output images  ( plot_multi_images function )</p>
</dd>
<dt><code>titles</code></dt><dd><p>either NULL or a character vector specifying the main-titles of the output images. The length of this vector must be the same as the length of the input 'list_images' parameter  ( plot_multi_images function )</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GaborFeatureExtract-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GaborFeatureExtract$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://github.com/mhaghighat/gabor
</p>
<p>https://stackoverflow.com/questions/20608458/gabor-feature-extraction
</p>
<p>https://stackoverflow.com/questions/49119991/feature-extraction-with-gabor-filters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)

init_gb = GaborFeatureExtract$new()

# gabor-filter-bank
#------------------

gb_f = init_gb$gabor_filter_bank(scales = 5, orientations = 8, gabor_rows = 39,

                                 gabor_columns = 39, plot_data = TRUE)


# plot gabor-filter-bank
#-----------------------

plt_f = init_gb$plot_gabor(real_matrices = gb_f$gabor_real, margin_btw_plots = 0.65,

                           thresholding = FALSE)


# read image
#-----------

pth_im = system.file("tmp_images", "car.png", package = "OpenImageR")

im = readImage(pth_im) * 255


# gabor-feature-extract
#----------------------

# gb_im = init_gb$gabor_feature_extraction(image = im, scales = 5, orientations = 8,

#                                          downsample_gabor = TRUE, downsample_rows = 3,

#                                          downsample_cols = 3, gabor_rows = 39, gabor_columns = 39,

#                                          plot_data = TRUE, normalize_features = FALSE,

#                                          threads = 6)


# plot real data of gabor-feature-extract
#----------------------------------------

# plt_im = init_gb$plot_gabor(real_matrices = gb_im$gabor_features_real, margin_btw_plots = 0.65,

#                             thresholding = FALSE)


# feature generation for a matrix of images (such as the mnist data set)
#-----------------------------------------------------------------------

ROWS = 13; COLS = 13; SCAL = 3; ORIEN = 5; nrow_mt = 500; im_width = 12; im_height = 15

set.seed(1)
im_mt = matrix(sample(1:255, nrow_mt * im_width * im_height, replace = TRUE), nrow = nrow_mt,

                      ncol = im_width * im_height)

# gb_ex = init_gb$gabor_feature_engine(img_data = im_mt, img_nrow = im_width, img_ncol = im_height,

#                                      scales = SCAL, orientations = ORIEN, gabor_rows = ROWS,

#                                      gabor_columns = COLS, downsample_gabor = FALSE,

#                                      downsample_rows = NULL, downsample_cols = NULL,

#                                      normalize_features = TRUE, threads = 1, verbose = FALSE)


# plot of multiple image in same figure
#---------------------------------------

list_images = list(im, im, im)

plt_multi = init_gb$plot_multi_images(list_images, par_ROWS = 2, par_COLS = 2)

</code></pre>

<hr>
<h2 id='gamma_correction'>Gamma correction</h2><span id='topic+gamma_correction'></span>

<h3>Description</h3>

<p>Gamma correction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_correction(image, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_correction_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="gamma_correction_+3A_gamma">gamma</code></td>
<td>
<p>a positive value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies gamma correction to a matrix or to a 3-dimensional array where the third dimension is equal to 3. The gamma correction controls the overall brightness of an image.
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image = readImage(path)

filt = gamma_correction(image, gamma = 0.5)

</code></pre>

<hr>
<h2 id='gaussian_kernel'>gaussian-kernel</h2><span id='topic+gaussian_kernel'></span>

<h3>Description</h3>

<p>gaussian-kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel(xy_length = 2, sigma = 1, range_gauss = 2)
</code></pre>

<hr>
<h2 id='getAffineTransform'>Get Affine Transform</h2><span id='topic+getAffineTransform'></span>

<h3>Description</h3>

<p>Get Affine Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAffineTransform(original_points, transformed_points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAffineTransform_+3A_original_points">original_points</code></td>
<td>
<p>a matrix object that corresponds to the original points</p>
</td></tr>
<tr><td><code id="getAffineTransform_+3A_transformed_points">transformed_points</code></td>
<td>
<p>a matrix object that corresponds to the transformed points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>References</h3>

<p>https://github.com/OlehOnyshchak/ImageTransformations/blob/master/AffineTransformation.ipynb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(OpenImageR)

r = 600
c = 600
offset = 50

original_points = matrix(data = c(0, 0, r, 0, 0, c),
                         nrow = 3,
                         ncol = 2,
                         byrow = TRUE)

transformed_points = matrix(data = c(offset, 0, r, offset, 0, c-offset),
                            nrow = 3,
                            ncol = 2,
                            byrow = TRUE)

M_aff = getAffineTransform(original_points = original_points,
                           transformed_points = transformed_points)
M_aff
</code></pre>

<hr>
<h2 id='hash_apply'>calculate the binary or the hexadecimal hash for a matrix, array or a folder of images for the average_hash, phash or dhash functions</h2><span id='topic+hash_apply'></span>

<h3>Description</h3>

<p>This function takes either a matrix, array or a folder and returns either the binary hash features or the hashes (as a character vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash_apply(
  object,
  rows = 28,
  columns = 28,
  hash_size = 8,
  highfreq_factor = 3,
  method = "phash",
  mode = "binary",
  threads = 1,
  resize = "nearest"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_apply_+3A_object">object</code></td>
<td>
<p>a matrix, a data frame, a 3-dimensional array  (where the third dimension is equal to 3) or a path to a folder of files (images)</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_rows">rows</code></td>
<td>
<p>a number specifying the number of rows of the matrix</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_columns">columns</code></td>
<td>
<p>a number specifying the number of columns of the matrix</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_hash_size">hash_size</code></td>
<td>
<p>an integer specifying the hash size.  IF method = 'phash' : the hash_size * highfreq_factor should be less than number of rows or columns of the gray_image.
IF method = 'dhash' or 'average_hash' :  the hash_size should be less than number of rows or columns of the gray_image</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_highfreq_factor">highfreq_factor</code></td>
<td>
<p>an integer specyfing the highfrequency factor (IF method = 'phash' : the hash_size * highfreq_factor should be less than number of rows or columns of the gray_image)</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_method">method</code></td>
<td>
<p>one of 'phash', 'average_hash', 'dhash'</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_mode">mode</code></td>
<td>
<p>one of 'binary', 'hash'</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_threads">threads</code></td>
<td>
<p>the number of cores to run in parallel</p>
</td></tr>
<tr><td><code id="hash_apply_+3A_resize">resize</code></td>
<td>
<p>corresponds to one of 'nearest', 'bilinear' (resizing method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the binary hash or the hexadecimal hash for various types of objects.
</p>


<h3>Value</h3>

<p>If the input is a matrix, data frame or array this function returns a matrix (if mode = 'binary') or a character vector (if mode = 'hex_hash'). If the input is a path to
a folder the function returns a list of length 2, the 1st sublist is a vector with the names of the image files (the order of the files in the vector corresponds to the order of
the rows of the output matrix), the 2nd sublist is a matrix (if mode = 'binary') or a character vector (if mode = 'hex_hash').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = paste0(system.file("tmp_images", "same_type", package = "OpenImageR"), '/')

res_phash = hash_apply(path, method = 'phash', mode = 'binary')

</code></pre>

<hr>
<h2 id='HOG'>calculate the HOG (Histogram of oriented gradients) for an image</h2><span id='topic+HOG'></span>

<h3>Description</h3>

<p>The function is a modification of the 'findHOGFeatures' function of the SimpleCV package [ please consult the COPYRIGHT file ]
The function takes either an RGB (it will be converted to gray) or a gray image and returns a vector of the HOG descriptors.
The main purpose of the function is to create a vector of features, which can be used in classification tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HOG(image, cells = 3, orientations = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HOG_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="HOG_+3A_cells">cells</code></td>
<td>
<p>the number of divisions ( cells )</p>
</td></tr>
<tr><td><code id="HOG_+3A_orientations">orientations</code></td>
<td>
<p>number of orientation bins</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes either a matrix, a data frame or a 3-dimensional array (where the third dimension is equal to 3) and returns a vector with the HOG-descriptors (histogram of oriented gradients).
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res = HOG(image, cells = 3, orientations = 6)

## End(Not run)
</code></pre>

<hr>
<h2 id='HOG_apply'>calculate the HOG (Histogram of oriented gradients) for a matrix, array or a folder of images</h2><span id='topic+HOG_apply'></span>

<h3>Description</h3>

<p>calculate the HOG (Histogram of oriented gradients) for a matrix, array or a folder of images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HOG_apply(
  object,
  cells = 3,
  orientations = 6,
  rows = NULL,
  columns = NULL,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HOG_apply_+3A_object">object</code></td>
<td>
<p>a matrix, a data frame, a 3-dimensional array (where the third dimension is equal to 3) or a path to a folder of files (images)</p>
</td></tr>
<tr><td><code id="HOG_apply_+3A_cells">cells</code></td>
<td>
<p>the number of divisions ( cells )</p>
</td></tr>
<tr><td><code id="HOG_apply_+3A_orientations">orientations</code></td>
<td>
<p>number of orientation bins</p>
</td></tr>
<tr><td><code id="HOG_apply_+3A_rows">rows</code></td>
<td>
<p>a value specifying the number of rows of each image-row of the matrix (required if object is a matrix)</p>
</td></tr>
<tr><td><code id="HOG_apply_+3A_columns">columns</code></td>
<td>
<p>a value specifying the number of columns of each image-row of the matrix (required if object is a matrix)</p>
</td></tr>
<tr><td><code id="HOG_apply_+3A_threads">threads</code></td>
<td>
<p>the number of parallel cores to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input either a matrix, a data frame, a 3-dimensional array (where the third dimension is equal to 3) or a character path to a folder of files (images). It returns the HOG-descriptors
(histogram of oriented gradients) for each row (if matrix or data frame), for each array-slice (if array) or for each file (if path to a folder of images).
</p>


<h3>Value</h3>

<p>If the input is a matrix, data frame or array it returns a matrix of the hog descriptors. If the input is a path to a folder it returns a list of length 2,
the 1st sublist is a vector with the names of the image files (the order of the files in the vector corresponds to the order of the rows of the output matrix),
the 2nd sublist is the matrix of the hog descriptors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

MATR = matrix(runif(75), ncol = 25, nrow = 5)

res = HOG_apply(MATR, cells = 3, orientations = 5, rows = 5, columns = 5, threads = 1)


ARRAY = array(5, dim = c(10, 10, 3))

res = HOG_apply(ARRAY, cells = 3, orientations = 6, threads = 1)


FOLDER_path = paste0(system.file("tmp_images", "same_type", package = "OpenImageR"), '/')

res = HOG_apply(FOLDER_path, cells = 3, orientations = 6, threads = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='image_thresholding'>image thresholding</h2><span id='topic+image_thresholding'></span>

<h3>Description</h3>

<p>image thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_thresholding(image, thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_thresholding_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="image_thresholding_+3A_thresh">thresh</code></td>
<td>
<p>the threshold parameter should be between 0 and 1 if the data is normalized or between 0-255 otherwise</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies thresholding to a matrix or to a 3-dimensional array where the third dimension is equal to 3.
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

filt = image_thresholding(image, thresh = 0.5)

</code></pre>

<hr>
<h2 id='imageShow'>display an image</h2><span id='topic+imageShow'></span>

<h3>Description</h3>

<p>This function displays an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageShow(file_path, clear_viewer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageShow_+3A_file_path">file_path</code></td>
<td>
<p>if file_path is a character string, then a shiny application is utilized. If file_path is a matrix, data.frame OR a 3-dimensional array (where the third dimension is equal to 3) then the grid.raster function of the base grid package is used.</p>
</td></tr>
<tr><td><code id="imageShow_+3A_clear_viewer">clear_viewer</code></td>
<td>
<p>a boolean. If TRUE then the previous image will be removed in the viewer before displaying the next one</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function displays an image using either a character path, a 2- or a 3-dimensional object where the third dimension is equal to 3
</p>


<h3>Value</h3>

<p>displays an image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# path = system.file("tmp_images", "1.png", package = "OpenImageR")

# imageShow(path)

</code></pre>

<hr>
<h2 id='invariant_hash'>invariant hashing (caclulation of the hamming or the levenshtein distance when the image is flipped, rotated or cropped)</h2><span id='topic+invariant_hash'></span>

<h3>Description</h3>

<p>flip-rotate-crop an image and caclulate the hamming or the levenshtein distance for phash, average_hash, dhash
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invariant_hash(
  image,
  new_image,
  method = "phash",
  mode = "binary",
  hash_size = 8,
  highfreq_factor = 4,
  resize = "nearest",
  flip = T,
  rotate = T,
  angle_bidirectional = 10,
  crop = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invariant_hash_+3A_image">image</code></td>
<td>
<p>a 2-dimensional matrix or data frame (only gray-scale images are valid)</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_new_image">new_image</code></td>
<td>
<p>a new image to be compared with the previous input image</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_method">method</code></td>
<td>
<p>one of 'phash', 'average_hash', 'dhash'</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_mode">mode</code></td>
<td>
<p>one of 'binary', 'hash'</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_hash_size">hash_size</code></td>
<td>
<p>an integer specifying the hash size.  IF method = 'phash' : the hash_size * highfreq_factor should be less than number of floor(rows * 0.8) or floor(columns * 0.8) of the gray_image
IF method = 'dhash' or 'average_hash' :  the hash_size should be less than number of floor(rows * 0.8) or floor(columns * 0.8) of the gray_image</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_highfreq_factor">highfreq_factor</code></td>
<td>
<p>an integer specyfing the highfrequency factor (IF method = 'phash' : the hash_size * highfreq_factor should be less than number of floor(rows * 0.8) or
floor(columns * 0.8) of the gray_image)</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_resize">resize</code></td>
<td>
<p>corresponds to one of 'nearest', 'bilinear' (resizing method)</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_flip">flip</code></td>
<td>
<p>if TRUE the new_image will be flipped both horizontal and vertical</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_rotate">rotate</code></td>
<td>
<p>if TRUE the new_image will be rotated for a specified angle (see angle_bidirectional)</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_angle_bidirectional">angle_bidirectional</code></td>
<td>
<p>a float specifying the angle that the images should be rotated in both directions. For instance, if angle_bidirectional = 10 then the image will be rotated for 10 and
350 (360-10) degrees.</p>
</td></tr>
<tr><td><code id="invariant_hash_+3A_crop">crop</code></td>
<td>
<p>if TRUE the new_image will be cropped 10 or 20 percent (equally spaced horizontally and vertically)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following transformations : flips an image (no-flip, horizonal-flip, vertical-flip), rotates an image (no-angle, angle_bidirectional, 360-angle_bidirectional) and
crops an image (no-crop, 10-percent-crop, 20-percent-crop). Depending on the type of mode ('binary', 'hash'), after each transformation the hamming or the levenshtein distance between the two images is calculated.
</p>


<h3>Value</h3>

<p>If flip, rotate and crop are all FALSE then the function returns either the hamming distance (if mode = 'binary') or the levenshtein distance (if mode = 'hash') for the two images.
If any of the flip, rotate, crop is TRUE then it returns the MIN, MAX of the hamming distance (if mode = 'binary') or the MIN,MAX of the levenshtein distance (if mode = 'hash').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

path1 = system.file("tmp_images", "1.png", package = "OpenImageR")

path2 = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image1 = rgb_2gray(readImage(path1))

image2 = rgb_2gray(readImage(path2))

res1 = invariant_hash(image1, image2, hash_size = 3, flip = TRUE, crop = FALSE)

res2 = invariant_hash(image1, image2, mode = 'hash', hash_size = 3, angle_bidirectional = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='laplacian_kernels'>laplacian kernels</h2><span id='topic+laplacian_kernels'></span>

<h3>Description</h3>

<p>laplacian kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_kernels(type = 1)
</code></pre>

<hr>
<h2 id='List_2_Array'>convert a list of matrices to an array of matrices</h2><span id='topic+List_2_Array'></span>

<h3>Description</h3>

<p>convert a list of matrices to an array of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>List_2_Array(data, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="List_2_Array_+3A_data">data</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="List_2_Array_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE then the time taken to complete the task will be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function mainly for the HOG and hash functions. In case that matrices are stored in a list,
this function converts the list to an array of 2-dimensional data.
</p>


<h3>Value</h3>

<p>an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lst = list(matrix(0, 100, 100), matrix(1, 100, 100))

arr = List_2_Array(lst, verbose = FALSE)

</code></pre>

<hr>
<h2 id='load_binary'>loads either 2- or 3-dimensional data (where the third dimension is equal to 3) from a binary file</h2><span id='topic+load_binary'></span>

<h3>Description</h3>

<p>loads either 2- or 3-dimensional data (where the third dimension is equal to 3) from a binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_binary(path, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_binary_+3A_path">path</code></td>
<td>
<p>a character string specifying a file path ( where the binary data is saved )</p>
</td></tr>
<tr><td><code id="load_binary_+3A_type">type</code></td>
<td>
<p>a character string. Either '2d' or '3d' to indicate what kind of data data will be loaded from the specified <em>path</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to load either 2- or 3-dimensional data (where the third dimension is equal to 3) from a binary file. It is used in combination with the <em>superpixels</em> function in case that the <em>write_slic</em> parameter is not an empty string (&quot;&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(OpenImageR)

#------------------------------------------
# assuming the saved data are 2-dimensional
#------------------------------------------

path = "/my_dir/data.bin"

res = load_binary(path, type = '2d')


## End(Not run)

</code></pre>

<hr>
<h2 id='MinMaxObject'>minimum and maximum values of vector, matrix, data frame or array</h2><span id='topic+MinMaxObject'></span>

<h3>Description</h3>

<p>minimum and maximum values of vector, matrix, data frame or array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinMaxObject(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MinMaxObject_+3A_x">x</code></td>
<td>
<p>either a vector, matrix, data frame or array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This helper function returns the minimum and maximum values of a vector, 2-dimensional or 3-dimensional objects (where the third dimension is equal to 3). In case of a vector, matrix or data frame it returns a single value for
the minimum and maximum of the object. In case of an array it returns the minimum and maximum values for each slice of the array.
</p>


<h3>Value</h3>

<p>a list
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vector
x = 1:10

res = MinMaxObject(x)


# matrix
x = matrix(runif(100), 10, 10)

res = MinMaxObject(x)


# data frame
x = data.frame(matrix(runif(100), 10, 10))

res = MinMaxObject(x)


# array
x = array(runif(300), dim = c(10, 10, 3))

res = MinMaxObject(x)

</code></pre>

<hr>
<h2 id='norm_matrix_range'>Normalize a matrix to specific range of values</h2><span id='topic+norm_matrix_range'></span>

<h3>Description</h3>

<p>Normalize a matrix to specific range of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_matrix_range(data, min_value = -1, max_value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_matrix_range_+3A_data">data</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="norm_matrix_range_+3A_min_value">min_value</code></td>
<td>
<p>the new minimum value for the input <em>data</em></p>
</td></tr>
<tr><td><code id="norm_matrix_range_+3A_max_value">max_value</code></td>
<td>
<p>the new maximum value for the input <em>data</em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
mt = matrix(1:48, 8, 6)

res = norm_matrix_range(mt, min_value = -1, max_value = 1)

</code></pre>

<hr>
<h2 id='NormalizeObject'>normalize a vector, matrix or array (in the range between 0 and 1)</h2><span id='topic+NormalizeObject'></span>

<h3>Description</h3>

<p>normalize a vector, matrix or array (in the range between 0 and 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeObject(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizeObject_+3A_x">x</code></td>
<td>
<p>either a vector, matrix, data frame or array</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function which normalizes all pixel values of the object to the range between 0 and 1. The function takes either a vector, matrix, data frame or
array as input and returns a normalized object of the same type (in case of data frame it returns a matrix).
</p>


<h3>Value</h3>

<p>either a normalized vector, matrix, or array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vector
x = 1:10

res = NormalizeObject(x)


# matrix
x = matrix(runif(100), 10, 10)

res = NormalizeObject(x)


# data frame
x = data.frame(matrix(runif(100), 10, 10))

res = NormalizeObject(x)


# array
x = array(runif(300), dim = c(10, 10, 3))

res = NormalizeObject(x)

</code></pre>

<hr>
<h2 id='padding'>Padding of matrices or n-dimensional arrays with a user specified value</h2><span id='topic+padding'></span>

<h3>Description</h3>

<p>Padding of matrices or n-dimensional arrays with a user specified value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padding(input_data, new_rows, new_cols, fill_value = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padding_+3A_input_data">input_data</code></td>
<td>
<p>either a matrix or a 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="padding_+3A_new_rows">new_rows</code></td>
<td>
<p>an integer specifying the new rows of the output matrix or array</p>
</td></tr>
<tr><td><code id="padding_+3A_new_cols">new_cols</code></td>
<td>
<p>an integer specifying the new columns of the output matrix or array</p>
</td></tr>
<tr><td><code id="padding_+3A_fill_value">fill_value</code></td>
<td>
<p>a numeric value to fill the extended rows / columns of the initial input data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>padding</em> function returns a list, where <em>data</em> is the padded / extended matrix or array and <em>padded_start</em>, <em>padded_end</em>, <em>padded_left</em> and <em>padded_right</em> are integer values specifying how
many rows or columsn in up-, down-, left- or right-direction the input matrix or array was padded / extended with the specified fill-value.
</p>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)


#-------
# matrix
#-------

set.seed(1)
mt = matrix(runif(100), 10, 10)

res_mt = padding(mt, 15, 20, fill_value = -1)


#------
# array
#------

lst = list(matrix(1, 10, 10), matrix(2, 10, 10))

arr = List_2_Array(lst, verbose = FALSE)

res_arr = padding(arr, 15, 20, fill_value = mean(as.vector(mt)))

</code></pre>

<hr>
<h2 id='phash'>calculation of the 'phash' of an image</h2><span id='topic+phash'></span>

<h3>Description</h3>

<p>This function calculates the phash of an image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phash(
  gray_image,
  hash_size = 8,
  highfreq_factor = 4,
  MODE = "hash",
  resize = "nearest"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phash_+3A_gray_image">gray_image</code></td>
<td>
<p>a (2-dimensional) matrix or data frame</p>
</td></tr>
<tr><td><code id="phash_+3A_hash_size">hash_size</code></td>
<td>
<p>an integer specifying the hash size (hash_size * highfreq_factor should be less than number of rows or columns of the gray_image)</p>
</td></tr>
<tr><td><code id="phash_+3A_highfreq_factor">highfreq_factor</code></td>
<td>
<p>an integer specyfing the highfrequency factor (hash_size * highfreq_factor should be less than number of rows or columns of the gray_image)</p>
</td></tr>
<tr><td><code id="phash_+3A_mode">MODE</code></td>
<td>
<p>one of 'hash' (returns the hash of the image), 'binary' (returns binary identifier of the image)</p>
</td></tr>
<tr><td><code id="phash_+3A_resize">resize</code></td>
<td>
<p>corresponds to one of 'nearest', 'bilinear' (resizing method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a modification of the 'phash' function of the imagehash package [ please consult the COPYRIGHT file ]. The phash algorithm
extends the average_hash by using the discrete cosine transform.
</p>


<h3>Value</h3>

<p>either a hash-string or a binary vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
image = readImage(system.file("tmp_images", "2.jpg", package = "OpenImageR"))

image = rgb_2gray(image)

res_hash = phash(image, hash_size = 6, highfreq_factor = 3, MODE = 'hash')

res_binary = phash(image, hash_size = 6, highfreq_factor = 3, MODE = 'binary')

</code></pre>

<hr>
<h2 id='readImage'>this function reads various types of images</h2><span id='topic+readImage'></span>

<h3>Description</h3>

<p>Reads images of type .png, .jpeg, .jpg, .tiff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readImage(path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readImage_+3A_path">path</code></td>
<td>
<p>a character string specifying the path to the saved image</p>
</td></tr>
<tr><td><code id="readImage_+3A_...">...</code></td>
<td>
<p>further arguments for the readPNG, readJPEG and readTIFF functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input a string-path and returns the image in a matrix or array form. Supported types of images are .png, .jpeg, .jpg, .tiff.
Extension types similar to .tiff such as .tif, .TIFF, .TIF are also supported
</p>


<h3>Value</h3>

<p>the image in a matrix or array form
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

</code></pre>

<hr>
<h2 id='resizeImage'>resize an image using the 'nearest neighbors' or the 'bilinear' method</h2><span id='topic+resizeImage'></span>

<h3>Description</h3>

<p>resize an image using the 'nearest neighbors' or the 'bilinear' method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resizeImage(image, width, height, method = "nearest", normalize_pixels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resizeImage_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_width">width</code></td>
<td>
<p>a number specifying the new width of the image. Corresponds to the image-rows.</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_height">height</code></td>
<td>
<p>a number specifying the new height of the image. Corresponds to the image-columns.</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_method">method</code></td>
<td>
<p>one of 'nearest', 'bilinear'</p>
</td></tr>
<tr><td><code id="resizeImage_+3A_normalize_pixels">normalize_pixels</code></td>
<td>
<p>a boolean. If TRUE, then the output pixel values will be divided by 255.0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function down- or upsamples an image using the 'nearest neighbors' or the 'bilinear' method
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image = readImage(path)

resiz = resizeImage(image, width = 32, height = 32, method = 'nearest')

</code></pre>

<hr>
<h2 id='rgb_2gray'>convert an RGB image to Gray</h2><span id='topic+rgb_2gray'></span>

<h3>Description</h3>

<p>convert an RGB image to Gray
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb_2gray(RGB_image)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgb_2gray_+3A_rgb_image">RGB_image</code></td>
<td>
<p>a 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an RGB image to gray
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

gray = rgb_2gray(image)

</code></pre>

<hr>
<h2 id='RGB_to_HSV'>Conversion of RGB to HSV colour type</h2><span id='topic+RGB_to_HSV'></span>

<h3>Description</h3>

<p>Conversion of RGB to HSV colour type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGB_to_HSV(input_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGB_to_HSV_+3A_input_data">input_data</code></td>
<td>
<p>a 3-dimensional array (RGB image) where the third dimension is equal to 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meaning: RGB (Red-Green-Blue) to HSV (Hue, Saturation, Value) colour conversion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)

set.seed(1)
array_3d = array(sample(1:255, 675, replace = TRUE), c(15, 15, 3))

res = RGB_to_HSV(array_3d)

</code></pre>

<hr>
<h2 id='RGB_to_Lab'>Conversion of RGB to Lab colour type</h2><span id='topic+RGB_to_Lab'></span>

<h3>Description</h3>

<p>Conversion of RGB to Lab colour type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGB_to_Lab(input_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGB_to_Lab_+3A_input_data">input_data</code></td>
<td>
<p>a 3-dimensional array (RGB image) where the third dimension is equal to 3</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Meaning: RGB (Red-Green-Blue) to LAB (Lightness, A-colour-dimension, B-colour-dimension) colour conversion
</p>


<h3>References</h3>

<p>https://www.epfl.ch/labs/ivrl/research/snic-superpixels/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)

set.seed(1)
array_3d = array(sample(1:255, 675, replace = TRUE), c(15, 15, 3))

res = RGB_to_Lab(array_3d)

</code></pre>

<hr>
<h2 id='rotateFixed'>Rotate an image by 90, 180, 270 degrees</h2><span id='topic+rotateFixed'></span>

<h3>Description</h3>

<p>Rotate an image by 90, 180, 270 degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateFixed(image, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateFixed_+3A_image">image</code></td>
<td>
<p>matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="rotateFixed_+3A_angle">angle</code></td>
<td>
<p>one of 90, 180 and 270 degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is faster than the rotateImage function as it rotates an image for specific angles (90, 180 or 270 degrees).
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "3.jpeg", package = "OpenImageR")

image = readImage(path)

r = rotateFixed(image, 90)

</code></pre>

<hr>
<h2 id='rotateImage'>Rotate an image using the 'nearest' or 'bilinear' method</h2><span id='topic+rotateImage'></span>

<h3>Description</h3>

<p>Rotate an image by angle using the 'nearest' or 'bilinear' method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateImage(image, angle, method = "nearest", mode = "same", threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateImage_+3A_image">image</code></td>
<td>
<p>matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="rotateImage_+3A_angle">angle</code></td>
<td>
<p>specifies the number of degrees</p>
</td></tr>
<tr><td><code id="rotateImage_+3A_method">method</code></td>
<td>
<p>a string specifying the interpolation method when rotating an image ( 'nearest', 'bilinear' )</p>
</td></tr>
<tr><td><code id="rotateImage_+3A_mode">mode</code></td>
<td>
<p>one of 'full', 'same' (same indicates that the ouput image will have the same dimensions with initial image)</p>
</td></tr>
<tr><td><code id="rotateImage_+3A_threads">threads</code></td>
<td>
<p>the number of cores to run in parallel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rotates an image by a user-specified angle
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "2.jpg", package = "OpenImageR")

image = readImage(path)

r = rotateImage(image, 75, threads = 1)

</code></pre>

<hr>
<h2 id='runUI'>launcher for the shiny application</h2><span id='topic+runUI'></span>

<h3>Description</h3>

<p>launcher for the shiny application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUI()
</code></pre>

<hr>
<h2 id='sec_gaus_bl'>secondary function for downsampling</h2><span id='topic+sec_gaus_bl'></span>

<h3>Description</h3>

<p>secondary function for downsampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sec_gaus_bl(image, factor, sigma, range_gauss)
</code></pre>

<hr>
<h2 id='sec_resiz_array'>secondary function for 'resizeImage'  [ array ]</h2><span id='topic+sec_resiz_array'></span>

<h3>Description</h3>

<p>secondary function for 'resizeImage'  [ array ]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sec_resiz_array(image, flag = T)
</code></pre>

<hr>
<h2 id='superpixel_bbox'>Bounding box for the superpixel labels</h2><span id='topic+superpixel_bbox'></span>

<h3>Description</h3>

<p>Bounding box for the superpixel labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superpixel_bbox(superpixel_labels, non_overlapping_superpixels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superpixel_bbox_+3A_superpixel_labels">superpixel_labels</code></td>
<td>
<p>a matrix. The <em>superpixel_labels</em> parameter corresponds to the output <em>labels</em> of the <em>superpixels</em> function</p>
</td></tr>
<tr><td><code id="superpixel_bbox_+3A_non_overlapping_superpixels">non_overlapping_superpixels</code></td>
<td>
<p>either TRUE or FALSE. If TRUE then besides the (x,y) coordinates of each superpixel-segment (matrix), the overlapping indices for each superpixel will be returned (list). See the details section for more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <em>non_overlapping_superpixels</em> parameter is set to <em>FALSE</em> then : the <em>superpixel_bbox</em> function returns the bounding box for the labels of the <em>superpixels</em> function. The
output is a matrix which contains the min and max indices of the x-y-coordinates and the corresponding unique superpixel labels.
</p>
<p>If the <em>non_overlapping_superpixels</em> parameter is set to <em>TRUE</em> then : the <em>superpixel_bbox</em> function returns besides the previously explained matrix also the overlapping indices for each
superpixel. These indices can be used to overwrite pixels with a specific value (say 0.0), which might appear in two superpixels simultaneously. This feature might be useful in case a user
intends to use an algorithm and the separability of superpixel-segments is of importance.
</p>
<p>Therefore in both cases overlapping superpixels will be computed, however if the <em>non_overlapping_superpixels</em> parameter is set to <em>TRUE</em> then also a list of overlapping indices will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)


#-----------
# read image
#-----------

path = system.file("tmp_images", "slic_im.png", package = "OpenImageR")

im = readImage(path)

im = im[,, 1:3]


#--------------------
# compute superpixels
#--------------------

res = superpixels(input_image = im, method = "slic", superpixel = 200,

                  compactness = 20, return_labels = TRUE)


#-------------------------
# compute the bounding box
#-------------------------

bbox = superpixel_bbox(res$labels, non_overlapping_superpixels = FALSE)


#-------------------------------------------
# plot the bounding boxes of the superpixels ( for illustration purposes )
#-------------------------------------------


graphics::plot(1:ncol(im), type='n', xlim = c(ncol(im), 1), ylim = c(1, nrow(im)))

graphics::rasterImage( flipImage(im), 1, 1, ncol(im), nrow(im))


for (i in 1:nrow(bbox)) {

  # the order of the bounding box is c('xmin', 'ymin', 'xmax', 'ymax')
  graphics::rect(bbox[i,3], bbox[i,1], bbox[i,4], bbox[i,2], border = "red", lwd = 2)
}

</code></pre>

<hr>
<h2 id='superpixel_bbox_subset'>Bounding box for a subset of superpixel labels</h2><span id='topic+superpixel_bbox_subset'></span>

<h3>Description</h3>

<p>Bounding box for a subset of superpixel labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superpixel_bbox_subset(superpixel_labels, superpixel_subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superpixel_bbox_subset_+3A_superpixel_labels">superpixel_labels</code></td>
<td>
<p>a matrix. The <em>superpixel_labels</em> parameter corresponds to the output <em>labels</em> of the <em>superpixels</em> function</p>
</td></tr>
<tr><td><code id="superpixel_bbox_subset_+3A_superpixel_subset">superpixel_subset</code></td>
<td>
<p>a numeric or integer vector specifying the subset of superpixel segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should be utilized to return the bounding box for a subset of superpixel segments. To compute the bounding box for all superpixels use the <em>superpixel_bbox</em> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)


#-----------
# read image
#-----------

path = system.file("tmp_images", "slic_im.png", package = "OpenImageR")

im = readImage(path)

im = im[,, 1:3]


#--------------------
# compute superpixels
#--------------------

res = superpixels(input_image = im, method = "slic", superpixel = 200,

                  compactness = 20, return_labels = TRUE)


#-------------------------
# compute the bounding box   ( for subset of superpixels )
#-------------------------

bbox = superpixel_bbox_subset(res$labels, superpixel_subset = c(0, 10, 30))

</code></pre>

<hr>
<h2 id='superpixels'>SLIC and SLICO superpixel implementations</h2><span id='topic+superpixels'></span>

<h3>Description</h3>

<p>SLIC and SLICO superpixel implementations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superpixels(
  input_image,
  method = "slic",
  superpixel = 200,
  compactness = 20,
  return_slic_data = FALSE,
  return_lab_data = FALSE,
  return_labels = FALSE,
  write_slic = "",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superpixels_+3A_input_image">input_image</code></td>
<td>
<p>either a 2-dimensional or a 3-dimensional input image where the third dimension is equal to 3 (the range of the pixel values should be preferably in the range 0 to 255)</p>
</td></tr>
<tr><td><code id="superpixels_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to use. Either &quot;slic&quot; or &quot;slico&quot;</p>
</td></tr>
<tr><td><code id="superpixels_+3A_superpixel">superpixel</code></td>
<td>
<p>a numeric value specifying the number of superpixels to use</p>
</td></tr>
<tr><td><code id="superpixels_+3A_compactness">compactness</code></td>
<td>
<p>a numeric value specifying the compactness parameter. The <em>compactness</em> parameter is needed only if <em>method</em> is &quot;slic&quot;. The &quot;slico&quot; method adaptively chooses the compactness parameter for each superpixel differently.</p>
</td></tr>
<tr><td><code id="superpixels_+3A_return_slic_data">return_slic_data</code></td>
<td>
<p>a boolean. If TRUE then the resulted slic or slico data will be returned</p>
</td></tr>
<tr><td><code id="superpixels_+3A_return_lab_data">return_lab_data</code></td>
<td>
<p>a boolean. If TRUE then the Lab data will be returned ( the Lab-colour format )</p>
</td></tr>
<tr><td><code id="superpixels_+3A_return_labels">return_labels</code></td>
<td>
<p>a boolean. If TRUE then the labels will be returned</p>
</td></tr>
<tr><td><code id="superpixels_+3A_write_slic">write_slic</code></td>
<td>
<p>a character string. If not an empty string (&quot;&quot;) then it should be a path to the output file with extension .bin ( for instance &quot;/my_dir/output.bin&quot; ). The data will be saved in binary format.</p>
</td></tr>
<tr><td><code id="superpixels_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed in the R session</p>
</td></tr>
</table>


<h3>References</h3>

<p>https://www.epfl.ch/labs/ivrl/research/slic-superpixels/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenImageR)

#-------------------
# 3-dimensional data
#-------------------

path = system.file("tmp_images", "slic_im.png", package = "OpenImageR")

im = readImage(path)

res = superpixels(input_image = im, method = "slic", superpixel = 200,

                  compactness = 20, return_slic_data = TRUE)


#-------------------
# 2-dimensional data
#-------------------

im_2d = im[,,1]

res_mt = superpixels(input_image = im_2d, method = "slic", superpixel = 200,

                     compactness = 20, return_slic_data = TRUE)

</code></pre>

<hr>
<h2 id='switch_filter'>secondary function for edge_detection function</h2><span id='topic+switch_filter'></span>

<h3>Description</h3>

<p>secondary function for edge_detection function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_filter(
  kernel,
  conv_mod,
  gaussian_dims = 5,
  sigma = 1,
  laplacian_type = 1,
  range_gauss = 2
)
</code></pre>

<hr>
<h2 id='switch_hashing'>if-else function for hashing</h2><span id='topic+switch_hashing'></span>

<h3>Description</h3>

<p>if-else function for hashing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_hashing(
  object,
  width,
  height,
  hash_size,
  highfreq_factor,
  method,
  mode,
  threads,
  resize
)
</code></pre>

<hr>
<h2 id='switch_invariant'>secondary function for invariant_hash</h2><span id='topic+switch_invariant'></span>

<h3>Description</h3>

<p>secondary function for invariant_hash
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_invariant(method, gray_image, MODE, hash_size, highfreq_factor, resize)
</code></pre>

<hr>
<h2 id='translation'>image translation</h2><span id='topic+translation'></span>

<h3>Description</h3>

<p>shift the position of an image by adding/subtracting a value to/from the X or Y coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translation(image, shift_rows = 0, shift_cols = 0, padded_value = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translation_+3A_image">image</code></td>
<td>
<p>a matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="translation_+3A_shift_rows">shift_rows</code></td>
<td>
<p>a positive or negative integer specifying the direction that the rows should be shifted</p>
</td></tr>
<tr><td><code id="translation_+3A_shift_cols">shift_cols</code></td>
<td>
<p>a positive or negative integer specifying the direction that the columns should be shifted</p>
</td></tr>
<tr><td><code id="translation_+3A_padded_value">padded_value</code></td>
<td>
<p>either a numeric value or a numeric vector of length 3 (corresponding to RGB). If it's not equal to 0 then the values of the shifted rows or columns will be filled with the user-defined padded_value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If shift_rows is not zero then the image will be sifted row-wise (upsides or downsides depending on the sign). If shift_cols is not zero then
the image will be sifted column-wise (right or left depending on the sign).
</p>


<h3>Value</h3>

<p>a matrix or 3-dimensional array where the third dimension is equal to 3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res_tr = translation(image, shift_rows = 10, shift_cols = -10)

</code></pre>

<hr>
<h2 id='uniform_filter'>uniform filter (convolution with uniform kernel)</h2><span id='topic+uniform_filter'></span>

<h3>Description</h3>

<p>uniform filter (convolution with uniform kernel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform_filter(image, size, conv_mode = "same")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform_filter_+3A_image">image</code></td>
<td>
<p>matrix or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="uniform_filter_+3A_size">size</code></td>
<td>
<p>a 2-item vector specifying the horizontal and vertical dimensions of the uniform kernel, e.g. c(3,3)</p>
</td></tr>
<tr><td><code id="uniform_filter_+3A_conv_mode">conv_mode</code></td>
<td>
<p>the convolution mode should be one of 'same', 'full'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies a uniform filter to a matrix or to a 3-dimensional array where the third dimension is equal to 3
</p>


<h3>Value</h3>

<p>depending on the input, either a matrix or an array
</p>


<h3>Author(s)</h3>

<p>Lampros Mouselimis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

filt = uniform_filter(image, c(4,4), conv_mode = "same")

</code></pre>

<hr>
<h2 id='verify_image_extension'>Verify that the input image extension is valid</h2><span id='topic+verify_image_extension'></span>

<h3>Description</h3>

<p>Verify that the input image extension is valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_image_extension(image_path, regex_img = "jpe?g|png|tif$|tiff$")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_image_extension_+3A_image_path">image_path</code></td>
<td>
<p>a character string specifying the path to the saved image</p>
</td></tr>
<tr><td><code id="verify_image_extension_+3A_regex_img">regex_img</code></td>
<td>
<p>a character string specifying the regex used to verify if the image extension is valid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OpenImageR package uses the 'readPNG', 'readJPEG' and 'readTIFF' R packages in the background. Thus, only image file path
extensions that can be processed from these R packages should be used as input to the 'readImage' function
</p>


<h3>Value</h3>

<p>either the image path extension or an error
</p>


<h3>References</h3>

<p>https://github.com/mlampros/OpenImageR/issues/25
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec_img_ext = c('png', 'PNG', 'jpg', 'JPG', 'jpeg', 'JPEG', 'tif', 'TIF', 'tiff', 'TIFF')

vec_valid = sapply(vec_img_ext, function(x) {
  ext_iter = paste(c('example_image', x), collapse = '.')
  verify_image_extension(image_path = ext_iter)
})

all(vec_img_ext == vec_valid)
</code></pre>

<hr>
<h2 id='warpAffine'>Warp Affine</h2><span id='topic+warpAffine'></span>

<h3>Description</h3>

<p>Warp Affine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warpAffine(img, M, R, C, threads = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warpAffine_+3A_img">img</code></td>
<td>
<p>either a matrix or a 3-dimensional array (where the third dimension is equal to 3) with a range of values between 0 and 255</p>
</td></tr>
<tr><td><code id="warpAffine_+3A_m">M</code></td>
<td>
<p>a matrix corresponding to the transformation matrix</p>
</td></tr>
<tr><td><code id="warpAffine_+3A_r">R</code></td>
<td>
<p>a value corresponding to the destination number of rows</p>
</td></tr>
<tr><td><code id="warpAffine_+3A_c">C</code></td>
<td>
<p>a value corresponding to the destination number of columns</p>
</td></tr>
<tr><td><code id="warpAffine_+3A_threads">threads</code></td>
<td>
<p>an integer specifying the number of threads to run in parallel. This parameter applies only if the input &quot;img&quot; parameter is of type matrix.</p>
</td></tr>
<tr><td><code id="warpAffine_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a matrix or a 3-dimensional array (where the third dimension is equal to 3)
</p>


<h3>References</h3>

<p>https://github.com/OlehOnyshchak/ImageTransformations/blob/master/AffineTransformation.ipynb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(OpenImageR)

path = system.file("tmp_images", "landscape.jpg", package = "OpenImageR")
img = readImage(path)
img = img * 255

#.............................
# compute the affine transform
#.............................

r = ncol(img)
c = nrow(img)
offset = 50

original_points = matrix(data = c(0, 0, r, 0, 0, c),
                         nrow = 3,
                         ncol = 2,
                         byrow = TRUE)

transformed_points = matrix(data = c(offset, 0, r, offset, 0, c-offset),
                            nrow = 3,
                            ncol = 2,
                            byrow = TRUE)

M_aff = getAffineTransform(original_points = original_points,
                           transformed_points = transformed_points)

#..............
# 2-dimensional
#..............

img_2d = rgb_2gray(img)

res_2d = warpAffine(img = img_2d,
                    M = M_aff,
                    R = r,
                    C = c,
                    threads = 1,
                    verbose = TRUE)

# imageShow(res_2d)

#..............
# 3-dimensional
#..............

res_3d = warpAffine(img = img,
                    M = M_aff,
                    R = r,
                    C = c,
                    verbose = TRUE)

# imageShow(res_3d)

</code></pre>

<hr>
<h2 id='writeImage'>This function writes 2- or 3-dimensional image (where the third dimension is equal to 3) data to a file</h2><span id='topic+writeImage'></span>

<h3>Description</h3>

<p>This function writes 2- or 3-dimensional image (where the third dimension is equal to 3) data to a file. Supported types are .png, .jpeg, .jpg, .tiff (or .tif, .TIFF, .TIF)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeImage(data, file_name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeImage_+3A_data">data</code></td>
<td>
<p>a 2- or 3-dimensional object (matrix, data frame or array where the third dimension is equal to 3)</p>
</td></tr>
<tr><td><code id="writeImage_+3A_file_name">file_name</code></td>
<td>
<p>a string specifying the name of the new file</p>
</td></tr>
<tr><td><code id="writeImage_+3A_...">...</code></td>
<td>
<p>further arguments for the writePNG, writeJPEG and writeTIFF functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes as input a matrix, data frame or array and saves the data in one of the supported image types ( .png, .jpeg, .jpg, .tiff ).
Extension types similar to .tiff such as .tif, .TIFF, .TIF are also supported
</p>


<h3>Value</h3>

<p>a saved image file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# path = system.file("tmp_images", "1.png", package = "OpenImageR")

# im = readImage(path)

# writeImage(im, 'new_image.jpeg')

</code></pre>

<hr>
<h2 id='ZCAwhiten'>zca whiten of an image</h2><span id='topic+ZCAwhiten'></span>

<h3>Description</h3>

<p>this function performs zca-whitening to a 2- or 3- dimensional image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZCAwhiten(image, k, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZCAwhiten_+3A_image">image</code></td>
<td>
<p>a matrix, data frame or 3-dimensional array where the third dimension is equal to 3</p>
</td></tr>
<tr><td><code id="ZCAwhiten_+3A_k">k</code></td>
<td>
<p>an integer specifying the number of components to keep when svd is performed (reduced dimension representation of the data)</p>
</td></tr>
<tr><td><code id="ZCAwhiten_+3A_epsilon">epsilon</code></td>
<td>
<p>a float specifying the regularization parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whitening (or sphering) is the preprocessing needed for some algorithms. If we are training on images, the raw input is redundant, since adjacent
pixel values are highly correlated. When using whitening the features become less correlated and all features have the same variance.
</p>


<h3>Value</h3>

<p>a matrix or 3-dimensional array where the third dimension is equal to 3
</p>


<h3>References</h3>

<p>http://ufldl.stanford.edu/wiki/index.php/Whitening
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
path = system.file("tmp_images", "1.png", package = "OpenImageR")

image = readImage(path)

res = ZCAwhiten(image, k = 20, epsilon = 0.1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
