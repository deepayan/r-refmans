<!DOCTYPE html><html><head><title>Help for package smof</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smof}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smof-package'>
<p>Scoring Methodology for Ordered Factors</p></a></li>
<li><a href='#smof'><p>Scoring Methodology for Ordered Factors</p></a></li>
<li><a href='#smof-methods'><p>Methods for <code>smof</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scoring Methodology for Ordered Factors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-04</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, survival</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Starting from a given object representing a fitted model (within
  a certain set of model classes) whose linear predictor includes some ordered 
  factor(s) among the explanatory variables, a new model is constructed and
  fitted where each named factor is replaced by a single numeric score, suitably
  chosen so that the new variable produces a fit comparable with the standard
  methodology based on a set of polynomial contrasts. Reference: Azzalini (2023) 
  &lt;<a href="https://doi.org/10.1002%2Fsta4.624">doi:10.1002/sta4.624</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 18:10:43 UTC; aa</td>
</tr>
<tr>
<td>Author:</td>
<td>Adelchi Azzalini <a href="https://orcid.org/0000-0002-7583-1269"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smof-package'>
Scoring Methodology for Ordered Factors
</h2><span id='topic+smof-package'></span>

<h3>Description</h3>

<p>Starting from a given object representing a fitted model (within a
certain set of model classes) whose linear predictor includes some ordered 
factor(s) among the explanatory variables, a new model is constructed and 
fitted where each named factor is  replaced by a single numeric score, 
suitably chosen so that the new variable produces a fit comparable 
with the standard methodology based on a set of polynomial contrasts. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> smof</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Scoring Methodology for Ordered Factors</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-04</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given = "Adelchi", family = "Azzalini", 
                  email = "adelchi.azzalini@unipd.it", role = c("aut", "cre"), 
                  comment = c(ORCID = "0000-0002-7583-1269"))          </td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> ggplot2, survival</td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Starting from a given object representing a fitted model (within
  a certain set of model classes) whose linear predictor includes some ordered 
  factor(s) among the explanatory variables, a new model is constructed and
  fitted where each named factor is replaced by a single numeric score, suitably
  chosen so that the new variable produces a fit comparable with the standard
  methodology based on a set of polynomial contrasts. Reference: Azzalini (2023) 
  &lt;doi:10.1002/sta4.624&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Adelchi Azzalini [aut, cre] (&lt;https://orcid.org/0000-0002-7583-1269&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
print.smof              Methods for 'smof' objects
smof                    Scoring Methodology for Ordered Factors
smof-package            Scoring Methodology for Ordered Factors
</pre>


<h3>Author(s)</h3>

<p>Author: Adelchi Azzalini [aut, cre] (&lt;https://orcid.org/0000-0002-7583-1269&gt;)                   
Maintainer: Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;
</p>


<h3>References</h3>

<p>Azzalini, A. (2023). On the use of ordered factors as explanatory variables.
<em>Stat</em> <b>12</b>, e624. <a href="https://doi.org/10.1002/sta4.624">doi:10.1002/sta4.624</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6) # optional
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4) # optional
obj1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph)        
out0 &lt;- smof(obj1, esoph, "alcgp", distr.type="gh")
print(summary(out0$object)) 
</code></pre>

<hr>
<h2 id='smof'>Scoring Methodology for Ordered Factors</h2><span id='topic+smof'></span>

<h3>Description</h3>

<p>Starting from an object representing a fitted model whose linear
predictor includes some ordered factor(s) among the explanatory variables, a
new model is constructed where each named factor is replaced by a single
numeric score, suitably chosen so that the new variable produces a data
fit comparable with the standard methodology based on a set of polynomial
contrasts. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smof(object, data, factors, distr.type = "gh", fast.fit = FALSE, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smof_+3A_object">object</code></td>
<td>
<p>an object produced by a fitting function; see &lsquo;Details&rsquo;
below for specification of the admissible classes of objects. </p>
</td></tr>
<tr><td><code id="smof_+3A_data">data</code></td>
<td>
<p>the data frame used for producing <code>object</code>.</p>
</td></tr>
<tr><td><code id="smof_+3A_factors">factors</code></td>
<td>
<p>a character vector with the names of the ordered factors of 
<code>data</code> which must be converted to numeric scores.</p>
</td></tr>
<tr><td><code id="smof_+3A_distr.type">distr.type</code></td>
<td>
<p>a character string with the name of the parametric family 
of distributions used to construct the numeric scores.  
See &lsquo;Details&rsquo; for the set of admissible choices; 
default value: <code>"gh"</code>.</p>
</td></tr>
<tr><td><code id="smof_+3A_fast.fit">fast.fit</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating 
whether a fast-fitting procedure must be used. 
This option is available only under certain circumstances specified 
in the &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="smof_+3A_trace">trace</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating 
whether details of the iterative procedure for parameter estimation must 
be printed at each iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>smof</code> implements the methodology proposed by Azzalini (2023),
briefly summarized in the &lsquo;Background&rsquo; section. 
It is recommended to read at least that section in case the referenced paper 
is not examined. The published paper has open access.  
</p>
<p>Start from an <code>object</code> obtained as the outcome from some fitting 
procedure, whose linear predictor includes one or more ordered factor(s)
among the explanatory variables. 
For each ordered factor whose name is included in the vector <code>factors</code>, 
a suitable vector of numeric scores is constructed.
The selection process examines the quantiles of the members of a specified 
parametric  class of distributions  and selects the member with optimizes 
(i.e. minimizes) a pertaining target criterion.
</p>
<p>The admissible parametric families whose quantiles are used to construct 
the scores of the factors are all obtained by monotonic transformations of
a standard normal variate.  
Specifically, the admissible families and corresponding strings to be
specified in <code>distr.type</code> are as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
  Johnson's <code class="reqn">S_U</code>            </td><td style="text-align: left;"> <code class="reqn">\quad</code> </td><td style="text-align: left;"> <code>"SU"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  Tukey's <em>g</em>-and-<em>h</em>  </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"gh"</code>, <code>"g-and-h"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  Jones and Pewsey's <em>sinh-arcsinh</em>
                            </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"sinh-arcsinh"</code>, <code>"SAS"</code>  
</td>
</tr>

</table>

<p>where either string name can be used when two of them are indicated. 
All these families involve two parameters for shape regulation; location and 
scale parameters are not considered, because irrelevant for our purposes.
In each case, the adopted parameterization is the &lsquo;standard&rsquo; one,
but explicit specifications are provided in the reference below.  
The same <code>distr.type</code> is employed for all the components of <code>factors</code>.
</p>
<p>The admissible classes for <code>object</code> are currently as follows,
listed along the corresponding target criteria:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <kbd>class</kbd> </td><td style="text-align: left;"> <kbd>fitting function (package)</kbd> </td><td style="text-align: left;"> <kbd>target criterion</kbd></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">\rule[0.8ex]{5em}{0.02ex}</code></td><td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{12em}{0.02ex}</code></td><td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{10em}{0.02ex}</code></td>
</tr>
<tr>
 <td style="text-align: left;">
   lm           </td><td style="text-align: left;"> lm (stats)         </td><td style="text-align: left;"> sum of squared residuals </td>
</tr>
<tr>
 <td style="text-align: left;">
   mlm          </td><td style="text-align: left;"> lm (stats)         </td><td style="text-align: left;"> [see below] </td>
</tr>
<tr>
 <td style="text-align: left;">
   glm          </td><td style="text-align: left;"> glm (stats)        </td><td style="text-align: left;"> deviance </td>
</tr>
<tr>
 <td style="text-align: left;">
   survreg      </td><td style="text-align: left;"> survreg (survival) </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
 <td style="text-align: left;"> 
   coxph        </td><td style="text-align: left;"> coxph (survival)   </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
   coxph.penal  </td><td style="text-align: left;"> coxph (survival)   </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood 
</td>
</tr>

</table>
 
<p>For an object of class <code>mlm</code>, the target function is formed by summing
terms where the contribution  from the <code class="reqn">j</code>-th response variable is
<code class="reqn">(1-R^2_j)</code>, where <code class="reqn">R^2_j</code> is the <code>r-squared</code> statistic for 
that component of the fitted model. 
Note that, in the case of a single response variable,
its <code class="reqn">(1-R^2)</code> value is equivalent, up to an algebraic transformation, 
to the sum of squared residuals used for <code>lm</code> objects;
hence the chosen target criterion for <code>mlm</code> models is a direct extension
of the one for <code>lm</code>'s.
The above list of classes may be expanded in the future, depending on feedback.
</p>
<p>The rest of this section is slightly of more technical nature, 
and it may be not of interest to the casual user, especially if
the option <code>fast.fit=TRUE</code> is not selected.
Operationally, estimation of the <code>distr.type</code> parameters is performed 
via optimization of the pertaining target criterion,
as indicated by the table above.
For each candidate set of parameters, each factor included in 
<code>factors</code> is replaced by values determined by the 
quantiles of  <code>distr.type</code>  and the current parameters.
The name of the new constructed variable is formed by adding <code>.score</code> 
to the original name.
For instance, an ordered factor called <code>ordfac</code> is replaced 
by the numeric variable <code>ordfac.score</code> both 
in the linear predictor of <code>object</code> and in the <code>data</code> frame.
A call to <code>update</code> using the modified linear predictor and data delivers
a new fitting, with attached a value of the  target criterion.
An interative optimization process the target criterion leads to 
the estimated parameters of <code>distr.type</code>  with a corresponding 
fitted model.
</p>
<p>There are in fact two variants of the procedure. 
What has been just described refers to the more &lsquo;general&rsquo; variant form.
However, in the prominent cases of an <code>object</code> of class <code>lm</code> 
or <code>glm</code>, the procedure can be speeded-up by setting <code>fast.fit=TRUE</code>, 
provided the fitted model is of a basic form, that is, a model specification
via  a formula, and a <code>family</code> in the <code>glm</code> case, without  
non-basic arguments such as <code>offset</code>, <code>subset</code> and alike.
If these non-basic arguments are included in the <code>object</code> call, 
they are ignored for estimation of the <code>distr.type</code> parameter.
However, they are included for producing the final <code>object</code> 
returned by the function. 
With this option, the sequence of calls to <code>lm</code> and <code>glm</code>
involved by the iterative search procedure is replaced by faster calls
to  <code>lm.fit</code> and <code>glm.fit</code>.
Correspondingly, the internal target function (<code>target.fit</code>) is slightly
different from the one used on the more general case (<code>target.gen</code>). 
Since the selection of the parameters involves an iterative process with
dimensionality equal to twice the length of <code>factors</code> and each iteration
involves a new data fitting process, the saving in execution time can be 
substantial in some cases.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the calling statement</p>
</td></tr>
<tr><td><code>new.object</code></td>
<td>
<p>an updated version of the original <code>object</code>, with 
the components of <code>factors</code> in the model replaced by new variables; 
this <code>object</code> is itself a list, whose structure depends on its class.</p>
</td></tr>
<tr><td><code>new.data</code></td>
<td>
<p>a new data frame where the ordered factors are replaced 
by numeric variables representing scores.</p>
</td></tr>
<tr><td><code>distr</code></td>
<td>
<p>a list with two components: [1] <code>type</code>, the name of
of the distribution type; [2] <code>param</code>, a matrix of fitted parameters  
with as many rows as <code>length(factors)</code>.</p>
</td></tr>
<tr><td><code>factor.scores</code></td>
<td>
<p>a list of numeric vectors with the scores assigned 
to the levels of each factor.</p>
</td></tr>   
<tr><td><code>original.factors</code></td>
<td>
<p>a list with the names and the levels of the original 
<code>factors</code>.</p>
</td></tr>    
</table>


<h3>Background</h3>

<p>The methodology proposed in the reference below deals with the presence of 
ordered factors used as explanatory variables, hence included in the linear 
predictor of some model under consideration.
For any given ordered factor with <em>K</em> levels, say, a set of <em>K</em> 
numeric scores is introduced, with a certain value assigned to each factor level.
In the end, the original factor is effectively replaced by a numeric variable.
This scheme represents a refinement of the elementary scoring system based
on the basic sequence <em>1, ..., K</em>, which constitutes a simple 
time-honoured option to deal with ordered factors, 
but it is not always appropriate.
</p>
<p>The actual construction of numeric scores proceeds by selecting <em>K</em> 
quantiles of a distribution belonging to some parametric family.
The adoption of a sufficiently flexible parametric family helps to find
a scoring system best suited for the data under consideration,
hence improving upon the basic sequence <em>1, ..., K</em>.
A concomitant product of this scheme is the identification of numeric values
which indicate how the <em>K</em> levels are &ldquo;really&rdquo; spaced.
Combining these two features, the key feature of the proposal is 
interpretability of the construction.
</p>
<p>The proposed method represents an alternative to the use of polynomial 
contrasts, which is the default action taken by <span class="rlang"><b>R</b></span> for ordered factors;
see the documentation of <code>contr.poly</code>.
</p>
<p>In the proposed logic, the constructed scores are intended to be used, and
interpreted, without further manipulation. Hence, for instance, building a 
polynomial form using one such variable would diverge somewhat from the 
proposed logic, although still conceivable.
With a single numeric variable to represent a given factor, 
one cannot expect to achieve the same numerical fit to the data 
as obtained the polynomial contrasts built for the original factor, 
when these constrasts involve high degrees polynomials, and 
correspondingly several parameters.
However, a range of numerical explorations has indicated that in many cases
the resulting fit is equal or similar to the one achieved via polynomial 
constrasts, with non-negligible simplification in the model specification, 
and easier interpretation, 
</p>
<p>In a nutshell, the aim of the approach is to achieve a satisfactory data fit
while improving an model parsimony, with simple interpretability of the 
score system.
</p>
<p>For a more comprehensive exposition and discussion, see the reference below.
</p>


<h3>Note</h3>

<p>For subsequent computations on the object returned by <code>smof</code>, difficulties 
may arise if the call to the fitting function does not set <code>model=TRUE</code>.
This is not a problem with <code>lm</code> and <code>glm</code>, if their default setting
<code>model=TRUE</code> has not been modified.
The  default setting of <code>coxph</code> is instead <code>model=FALSE</code>.
This implies, for instance, that issuing the <code>survival</code> command   
<code>survfit(smof4$new.object)</code>, right after running 
the code of Example 4 below, would cause an error. 
There exist various ways to overcome this snag; the simplest one is to write  
</p>

<table>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>new.data &lt;- smof4$new.data</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>s &lt;- survfit(smof4$new.object)</code>
</td>
</tr>

</table>
 
<p>This indication is temporary and it may be superseded by a different design 
in future versions of the package.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. (2023). On the use of ordered factors as explanatory variables.
<em>Stat</em> <b>12</b>, e624. <a href="https://doi.org/10.1002/sta4.624">doi:10.1002/sta4.624</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contr.poly">contr.poly</a></code>, <code><a href="stats.html#topic+update">update</a></code>, 
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>, 
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1, reconstructs Table 2 (fist part) of the reference
message("--- Example 1: esoph data ---")
library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6) # optional
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4) # optional
fit1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph) 
message("original fit:") 
print(summary(fit1))      
smof1 &lt;- smof(fit1, esoph, "alcgp", distr.type="SU")
print(smof1, type="b", pch=20, col=4)
print(summary(smof1))
plot(smof1)
#
# Example 2 , reconstructs Table 4 (first part) of the reference
if(require(ggplot2, quietly=TRUE)) {
message("--- Example 2: diamonds data ---")
data(diamonds, package="ggplot2")  
dmd &lt;- data.frame(diamonds[seq(1, 53940, by=100),]) # use a subset of the data
dmd &lt;- dmd[-c(518, 519, 523),] # remove three outliers
contrasts(dmd$cut, 1) &lt;- contr.poly(5) 
fit2 &lt;- lm(sqrt(price) ~ carat + clarity + color + cut, data=dmd)
smof2 &lt;- smof(fit2, dmd,  c("color", "clarity"), distr.type="gh")
message("smof fit:") 
print(smof2)
print(summary(smof2))
plot(smof2, which="clarity")
} # end diamonds example
#
# Example 3
if(require(survival, quietly=TRUE)) {
message("--- Example 3: lung data ---")
lung0 &lt;- lung
lung0$ph.karno &lt;- ordered(lung0$ph.karno)
contrasts(lung0$ph.karno, 3) &lt;- contr.poly(6)
fit3 &lt;- survreg(Surv(time, status) ~ ph.karno, data=lung0)
smof3 &lt;- smof(fit3, lung0, "ph.karno")
print(summary(smof3))
plot(smof3)  # Karnofsky scores do not seem to be linearly spaced
# 
message("--- Example 4: PBC data ---")
data(pbc, package="survival")
pbc$stage &lt;- ordered(pbc$stage)
fit4 &lt;- coxph(Surv(time) ~ strata(status) + stage, data=pbc)
smof4 &lt;- smof(fit4, data=pbc, factors="stage")
print(summary(smof4))
plot(smof4)
} # end of survival examples
</code></pre>

<hr>
<h2 id='smof-methods'>Methods for <code>smof</code> objects</h2><span id='topic+print.smof'></span><span id='topic+plot.smof'></span><span id='topic+predict.smof'></span><span id='topic+summary.smof'></span><span id='topic+print.summary.smof'></span>

<h3>Description</h3>

<p>The list of methods that apply to <code>smof</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smof'
print(x, ...)
## S3 method for class 'smof'
plot(x, which, ...)
## S3 method for class 'smof'
summary(object,  ...)
## S3 method for class 'summary.smof'
print(x, ...)
## S3 method for class 'smof'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smof-methods_+3A_object">object</code></td>
<td>
<p>an object returned by <code>smof</code>.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_x">x</code></td>
<td>
<p>an object returned by <code>smof</code>, except for <code>print.summary.smof</code> 
where <code>x</code> is the outcome of <code>summary.smof</code>.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_which">which</code></td>
<td>
<p>either a vector or a two-elements list; see &lsquo;Details&rsquo;
for full specification.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_newdata">newdata</code></td>
<td>
<p>a data frame which includes ordered factors with the same names
and levels as those in the data frame used to produce <code>object</code>;
see &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_...">...</code></td>
<td>
<p>arguments passsed through to other methods.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>There are two main parts in the outcome of <code>summary.smof</code>. One is the
outcome of the selection of the factor(s) transformation(s); the other part,
denoted <kbd>Final fitting call</kbd>, represents the newly fitted model  
with the original ordered factors  replaced  by numeric scores. 
The corresponding <code>data.frame</code>, denoted <code>new.data</code>, is one 
of the components of the object returned by <code>smof</code>.
</p>
<p>If <code>which</code> is a character vector, its components are interpreted as
names of the <code>factors</code> in the calling statement of the object to be 
plotted, producing a set of
graphs where the numeric scores of each named factor are plotted versus
the equally spaced ticks associated to the original level names.
The same effect is obtained when <code>which</code> is a numeric vector of integers,
which then select the corresponding components of the <code>factors</code> sequence.
</p>
<p>If <code>which</code> is a list, its first element is assumed to be a vector having
the meaning just described. After the pertaining set of graphs has been 
completed,  the second element of the list is passed to the plotting method 
for the object produced by the model fitting procedure.
Currently this option operates only for objects which inherits from class
<code>lm</code>; specifically, it works for objects originated by a call to 
<code>lm</code> or to <code>glm</code>.
</p>
<p>With <code>predict.smof</code>, the outcome of a <code>smof</code> fit is applied 
to new data frame which includes ordered factors analogous to those used to 
compute the <code>smof</code> transformation. 
Only the factors of <code>newdata</code> with the same name as those processed by 
<code>smof</code> to produce <code>object</code> are examined. The levels of these
factors must coincide with or be a subset of those of the original data frame.
</p>
<p>There is a difference between  the role played by <code>predict.smof</code> and  
the one of <code>predict</code> methods for other classes. Usually the returned 
values pertain to the response variable, or to some related entity, 
while here the outcome refers to explanatory variables.
</p>


<h3>Value</h3>

<p>For <code>summary.smof</code>, a list. For <code>predict.smof</code>, a data frame.</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+smof">smof</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6)  
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4)  
fit1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph)      
smof1 &lt;- smof(fit1, esoph, "alcgp")
print(smof1)
print(summary(smof1))
plot(smof1, type="b", pch=19, col="blue")
plot(smof1, which=list(1, 1:4))
predict(smof1, newdata=esoph[seq(1, 88, by=8), ]) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
