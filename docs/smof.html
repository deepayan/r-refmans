<!DOCTYPE html><html lang="en"><head><title>Help for package smof</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smof}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#smof-package'>
<p>Scoring Methodology for Ordered Factors</p></a></li>
<li><a href='#smof'><p>Scoring Methodology for Ordered Factors</p></a></li>
<li><a href='#smof_refit'><p>Re-fitting an existing <code>smof</code> model for improved optimization</p></a></li>
<li><a href='#smof-methods'><p>Methods for <code>smof</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scoring Methodology for Ordered Factors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, survival, nloptr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Starting from a given object representing a fitted model
  (within a certain set of model classes) whose (non-)linear predictor
  includes some ordered factor(s) among the explanatory variables, a new
  model is constructed and fitted where each named factor is replaced by a
  single numeric score, suitably chosen so that the new variable produces a
  fit comparable with the standard methodology based on a set of polynomial
  contrasts. Two variants of the present approach have been developed, one in
  each of the next references: Azzalini (2023) &lt;<a href="https://doi.org/10.1002%2Fsta4.624">doi:10.1002/sta4.624</a>&gt;, (2024)
  &lt;<a href="https://doi.org/10.48550%2FarXiv.2406.15933">doi:10.48550/arXiv.2406.15933</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-10 10:20:40 UTC; aa</td>
</tr>
<tr>
<td>Author:</td>
<td>Adelchi Azzalini <a href="https://orcid.org/0000-0002-7583-1269"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-10 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='smof-package'>
Scoring Methodology for Ordered Factors
</h2><span id='topic+smof-package'></span>

<h3>Description</h3>

<p>Starting from a given object representing a fitted model (within a
certain set of model classes) whose linear predictor includes some ordered 
factor(s) among the explanatory variables, a new model is constructed and 
fitted where each named factor is  replaced by a single numeric score, 
suitably chosen so that the new variable produces a fit comparable 
with the standard methodology based on a set of polynomial contrasts. 
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> smof</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Scoring Methodology for Ordered Factors</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-12-10</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given = "Adelchi", family = "Azzalini", 
                  email = "adelchi.azzalini@unipd.it", role = c("aut", "cre"), 
                  comment = c(ORCID = "0000-0002-7583-1269"))          </td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> ggplot2, survival, nloptr</td>
</tr>
<tr>
 <td style="text-align: left;">
ByteCompile: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Starting from a given object representing a fitted model
  (within a certain set of model classes) whose (non-)linear predictor
  includes some ordered factor(s) among the explanatory variables, a new
  model is constructed and fitted where each named factor is replaced by a
  single numeric score, suitably chosen so that the new variable produces a
  fit comparable with the standard methodology based on a set of polynomial
  contrasts. Two variants of the present approach have been developed, one in
  each of the next references: Azzalini (2023) &lt;doi:10.1002/sta4.624&gt;, (2024)
  &lt;doi:10.48550/arXiv.2406.15933&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Adelchi Azzalini [aut, cre] (&lt;https://orcid.org/0000-0002-7583-1269&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
print.smof              Methods for 'smof' objects
smof                    Scoring Methodology for Ordered Factors
smof-package            Scoring Methodology for Ordered Factors
smof_refit              Re-fitting an existing 'smof' model for
                        improved optimization
</pre>


<h3>Author(s)</h3>

<p>Author: Adelchi Azzalini [aut, cre] (&lt;https://orcid.org/0000-0002-7583-1269&gt;)                   
Maintainer: Adelchi Azzalini &lt;adelchi.azzalini@unipd.it&gt;
</p>


<h3>References</h3>

<p>Azzalini, A. (2023). On the use of ordered factors as explanatory variables.
<em>Stat</em> <b>12</b>, e624. <a href="https://doi.org/10.1002/sta4.624">doi:10.1002/sta4.624</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6) # optional
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4) # optional
obj1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph)        
out0 &lt;- smof(obj1, esoph, "alcgp")
print(summary(out0$object)) 
</code></pre>

<hr>
<h2 id='smof'>Scoring Methodology for Ordered Factors</h2><span id='topic+smof'></span>

<h3>Description</h3>

<p>Starting from an object representing a fitted model whose (non-)linear
predictor includes some ordered factor(s) among the explanatory variables, 
a new model is constructed where each named factor is replaced by a single
numeric score, suitably chosen so that the new variable produces a data
fit comparable with the standard methodology based on a set of polynomial
contrasts. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smof(object, data, factors, scoring, fast.fit = FALSE, original = FALSE,
       f.tail=".score", opt.method="Nelder-Mead", opt.control=list(), verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smof_+3A_object">object</code></td>
<td>
<p>an object produced by a fitting function; see &lsquo;Details&rsquo;
below for specification of the admissible classes of objects. </p>
</td></tr>
<tr><td><code id="smof_+3A_data">data</code></td>
<td>
<p>the data frame used for producing <code>object</code>.</p>
</td></tr>
<tr><td><code id="smof_+3A_factors">factors</code></td>
<td>
<p>a character vector with the names of the ordered factors of 
<code>data</code> which must be converted to numeric scores.</p>
</td></tr>
<tr><td><code id="smof_+3A_scoring">scoring</code></td>
<td>
<p>a list which selects the type of scoring techniques and 
related ingredients.
Its key component is the character string <code>scoring$type</code> with possible
values <code>"distr"</code> and <code>"spline"</code>; the other components of the
list depend on this value, and are described in the  &lsquo;Details&rsquo;.
If the argument <code>scoring</code> is missing, the default value 
<code>list(type="distr", family="gh")</code> is used.</p>
</td></tr>
<tr><td><code id="smof_+3A_fast.fit">fast.fit</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating 
whether a fast-fitting procedure must be used. 
This option is available only under certain circumstances specified 
in the &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="smof_+3A_original">original</code></td>
<td>
<p>a logical value (default value: <code>FALSE</code>) indicating
whether the original <code>object</code> must be included in the returned object.</p>
</td></tr> 
<tr><td><code id="smof_+3A_f.tail">f.tail</code></td>
<td>
<p>a character string representing the suffix to be added to
each factor name when the coresponding numeric variable is constructed
(default value: <code>".score"</code>). It may be suitably adjusted in case the 
supplied string leads to an invalid variable name.</p>
</td></tr>
<tr><td><code id="smof_+3A_opt.method">opt.method</code></td>
<td>
<p>a character string with the name of the numerical 
optimization method, among a set of options. The basic set comprises 
<code>"Nelder-Mead"</code>  (default value), <code>"BFGS"</code>, <code>"nlminb"</code>,
all accessible from the <span class="pkg">stats</span> package;
the first two choices generate a call to the function <code>optim</code>,
while <code>"nlminb"</code> produces a call to <code>nlminb</code>.
In addition, if the package <span class="pkg">nloptr</span> is installed on the local system,
the set of options is enlarged with <code>"newuoa"</code>, <code>"bobyqa"</code>, 
<code>"cobyla"</code>, <code>"sbplx"</code>. 
</p>
</td></tr>    
<tr><td><code id="smof_+3A_opt.control">opt.control</code></td>
<td>
<p>a list passed to the optimization function selected by
<code>opt.method</code> as its <code>control</code> argument.
It must not be used to turn the minimization problem into a
maximization one.</p>
</td></tr>   
<tr><td><code id="smof_+3A_verbose">verbose</code></td>
<td>
<p>a non-negative integer regulating the amount of messages 
displayed; it can be 0 (no messages unless necessary, default value), 
1 (minimal messaging)  or larger than 1 for a more verbose outcome.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>In its original formulation, <code>smof</code> implements the methodology proposed 
by Azzalini (2023), briefly summarized in the &lsquo;Background&rsquo; section.
It is recommended to read at least that section in case the referenced paper 
is not examined. The published paper has open access.  
Later on, since version 1.2.0 of <span class="pkg">smof</span>, a variant methodology has been 
included, based on the use of splines instead of quantile functions,
presented in Azzalini (2024).
</p>
<p>Start from an <code>object</code> obtained as the outcome from some fitting 
procedure, whose linear predictor includes one or more ordered factor(s)
among the explanatory variables. 
For each ordered factor whose name is included in vector <code>factors</code>, 
a suitable vector of numeric scores is constructed.
The selection process examines the quantiles of the members of a specified 
parametric  class of distributions  and selects the member with optimizes 
(i.e. minimizes) a suitable target criterion.
To avoid trivialities, each factor in vector <code>factors</code> must have at 
least three levels.
</p>
<p>There are two quite different options to build the numeric scores assigned
to an ordered factor. The selection of one of these options is made via
the component <code>type</code> of the list <code>scoring</code>, which 
can be either <code>"distr"</code> or <code>"spline"</code>. 
The other components of <code>scoring</code> depends on the chosen <code>type</code> 
and are described below.
</p>
<p>If <code>scoring$type="distr"</code>, the numeric scores are obtained as quantiles
of a probability distribution belonging to a certain parametric family;
this route corresponds to the original construction of <code>smof</code>,
following Azzalini (2023).
The admissible parametric families are all obtained by monotonic 
transformations of a standard normal variate.  
Specifically, the admissible families and corresponding strings to be
specified in <code>scoring$family</code> are as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
  Johnson's <code class="reqn">S_U</code>            </td><td style="text-align: left;"> <code class="reqn">\quad</code> </td><td style="text-align: left;"> <code>"SU"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  Tukey's <em>g</em>-and-<em>h</em>  </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"gh"</code>, <code>"g-and-h"</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  Jones and Pewsey's <code class="reqn">sinh-arcsinh</code>
                            </td><td style="text-align: left;"> </td><td style="text-align: left;"> <code>"sinh-arcsinh"</code>, <code>"SAS"</code>  
</td>
</tr>

</table>

<p>where either string name can be used when two of them are indicated. 
All these families involve two parameters for shape regulation; location and 
scale parameters are not considered, because irrelevant for our purposes.
Of the two shape parameters, the first one regulates asymmetry and can take
any value, while the second one regulates tail thickness and must be positive.
In each case, the adopted parameterization is the &lsquo;standard&rsquo; one,
but explicit specifications are provided in the reference below.  
The same <code>family</code> is employed for all the components of <code>factors</code>.
</p>
<p>Since version 1.2.2 of the package, the selected quantiles are, in the 
final stage, linearly mapped to values in the interval <code class="reqn">(1,K)</code>, 
if <code class="reqn">K</code> denotes the number of levels of the factor under consideration.
This choice is simplifies comparison among different choices of scoring,
in a number of ways: first of all, it highlights the difference from the
traditional scores <code class="reqn">1, 2, \dots, K</code>; next, it facilitates comparison  
among alternative choice of <code>scorinf$family</code>; finally, it it facilitates 
comparison with the scoring produced using spline, to be described shortly,
whose scores range between <code class="reqn">1</code> and <code class="reqn">K</code>.  
An implication of the present choice of mapping quantiles is that the scores
produced now in the example code below differs numerically from the scores
displayed in the examples of Azzalini (2023), but the difference is only 
superficial, since the relative spacings between the old and the
new scores are unchanged, and this is the crucial point. 
However, in case one wants to recover the old type  of outcome, 
this is  possible by including the component <code>scoring</code> in
the call to <code>smof</code> and setting <code>scoring$mapping="none"</code>.
</p>
<p>If <code>scoring$type="spline"</code>, the numeric scores are obtained using
monotonic spline functions. Specifically, the scores are generated using
<code>splinefun</code> with <code>method="monoH.FC"</code>. Since currently this is 
the only admissible form of spline, it does not need to be specified.
What must be specified is <code>scoring$in.knots</code>, the number of internal knots
between the fixed extremal knots <code>1</code> and <code>K</code>, if <code>K</code> denotes
the number of levels of any given factor.  Hence <code>scoring$in.knots</code>
should be an integer vector with as many components as <code>factors</code>;
if a shorter vector is supplied, its values will be recycled.
Each component of <code>in.knots</code> must not exceed the corresponding value 
of <code>K-2</code>.
Since each internal knot involves the selection of two numeric values,
the total number of fitted parameters equals the sum of twice the
<code>in.knots</code> values, summed over the components of <code>factors</code>.
</p>
<p>Estimation of the transformation parameters is performed by a numerical process 
which optimizes a target criterion which depends on <code>class(object)</code>.
This numerical scheme is summarized in Section &lsquo;Computational aspects&rsquo;.
The admissible classes for <code>object</code> are currently as follows,
listed along the corresponding target criteria:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <kbd>class</kbd> </td><td style="text-align: left;"> <kbd>fitting function (package)</kbd> </td><td style="text-align: left;"> <kbd>target criterion</kbd></td>
</tr>
<tr>
 <td style="text-align: left;">
  <code class="reqn">\rule[0.8ex]{5em}{0.02ex}</code></td><td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{12em}{0.02ex}</code></td><td style="text-align: left;"> 
       <code class="reqn">\rule[0.8ex]{10em}{0.02ex}</code></td>
</tr>
<tr>
 <td style="text-align: left;">
   lm           </td><td style="text-align: left;"> lm (stats)         </td><td style="text-align: left;"> sum of squared residuals </td>
</tr>
<tr>
 <td style="text-align: left;">
   mlm          </td><td style="text-align: left;"> lm (stats)         </td><td style="text-align: left;"> [see below] </td>
</tr>
<tr>
 <td style="text-align: left;">
   glm          </td><td style="text-align: left;"> glm (stats)        </td><td style="text-align: left;"> deviance </td>
</tr>
<tr>
 <td style="text-align: left;">
   survreg      </td><td style="text-align: left;"> survreg (survival) </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
 <td style="text-align: left;"> 
   coxph        </td><td style="text-align: left;"> coxph (survival)   </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
   coxph.penal  </td><td style="text-align: left;"> coxph (survival)   </td><td style="text-align: left;"> <code class="reqn">-</code>loglikelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
   gnm          </td><td style="text-align: left;"> gnm (gnm)          </td><td style="text-align: left;"> deviance
</td>
</tr>

</table>
 
<p>For an object of class <code>mlm</code>, the target function is formed by summing
terms where the contribution  from the <code class="reqn">j</code>-th response variable is
<code class="reqn">(1-R^2_j)</code>, where <code class="reqn">R^2_j</code> is the <code>r-squared</code> statistic for 
that component of the fitted model. 
Note that, in the case of a single response variable,
its <code class="reqn">(1-R^2)</code> value is equivalent, up to an algebraic transformation, 
to the sum of squared residuals used for <code>lm</code> objects;
hence the chosen target criterion for <code>mlm</code> models is a direct extension
of the one for <code>lm</code>'s.
The above list of classes may be expanded in the future, depending on feedback.
</p>
<p>The rest of this section is slightly of more technical nature, 
and it may be not of interest to the casual user, especially if
the option <code>fast.fit=TRUE</code> is not selected.
Operationally, estimation of the <code>scoring$family</code> parameters is performed 
via optimization of the pertaining target criterion,
as indicated by the table above.
For each candidate set of parameters, each factor included in 
<code>factors</code> is replaced by values determined by the 
quantiles of  <code>scoring$family</code>  and the current parameters.
The name of the new constructed variable is formed by adding <code>.score</code> 
to the original name.
For instance, an ordered factor called <code>ordfac</code> is replaced 
by the numeric variable <code>ordfac.score</code> both 
in the linear predictor of <code>object</code> and in the <code>data</code> frame.
</p>
<p>If the component <code>scoring$param</code> is not <code>NULL</code>, it is assumed 
to provide initialization values for the parameter search process.
Specifically, if <code>nf</code> denotes the number of elements of <code>factors</code>,
a set of <code>nf</code> vectors must be provided, one for each component of <code>factors</code>.
In case $<code>scoring$type="distr"</code>, <code>scoring$param</code> must be a matrix 
with dimension <code>(nf,2)</code> where each row vector represents the parameters 
for the corresponding element of <code>factor</code>; the second columns of this 
matrix must have positive elements, since they represent tail-weight parameters.
In case $<code>scoring$type="smof"</code>), <code>scoring$param</code> must be a list 
of <code>nf</code> vectors, with lengths <code>2*in.knots</code>.  
In this case, it is assumed that each vector comprises two subvectors of 
ordered values in the range between  <code>1</code> and <code>M</code>, 
where <code>M</code> denotes the number of levels of the corresponding factor.
</p>
<p>For the numerical fitting procedure, there exist in fact two variants.
The more commonly used &lsquo;general&rsquo; variant form is summarized below 
in the already-mentioned Section &lsquo;Computational aspects&rsquo; below.
However, in the prominent cases of an <code>object</code> of class <code>lm</code> 
or <code>glm</code>, the procedure can be speeded-up by setting <code>fast.fit=TRUE</code>, 
under certain conditions indicated next.
One such condition is that <code>scoring$type="distr"</code> is set.
Also, it is required that the fitted model is of a basic form, that is, 
a model specification via  a formula, and a <code>family</code> in the <code>glm</code> case,
without  non-basic arguments such as <code>offset</code>, <code>subset</code> and alike.
If these non-basic arguments are included in the <code>object</code> call, 
they are ignored for estimation of the <code>scoring$family</code> parameter.
However, they are included for producing the final <code>object</code> 
returned by the function. 
With this option, the sequence of calls to <code>lm</code> and <code>glm</code>
involved by the iterative search procedure is replaced by faster calls
to  <code>lm.fit</code> and <code>glm.fit</code>.
Correspondingly, the internal target function (<code>target.fit</code>) is slightly
different from the one used on the more general case (<code>target.gen</code>). 
Since the selection of the parameters involves an iterative process with
dimensionality equal to twice the length of <code>factors</code> and each iteration
involves a new data fitting process, the saving in execution time can be 
appreciable in some cases.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>the calling statement</p>
</td></tr>
<tr><td><code>new.object</code></td>
<td>
<p>an updated version of the original <code>object</code>, with 
the components of <code>factors</code> in the model replaced by new variables; 
this <code>object</code> is itself a list, whose structure depends on its class.</p>
</td></tr>
<tr><td><code>new.data</code></td>
<td>
<p>a new data frame where the ordered factors are replaced 
by numeric variables representing scores.</p>
</td></tr>
<tr><td><code>scoring</code></td>
<td>
<p>a list similar to the input argument with the addition of
the estimates of the parameters.</p>
</td></tr>
<tr><td><code>factor.scores</code></td>
<td>
<p>a list of numeric vectors with the scores assigned 
to the levels of each factor. In case of scores produced by splines, 
attributes with the spline knots are included.</p>
</td></tr>   
<tr><td><code>original.factors</code></td>
<td>
<p>a list with the names and the levels of the original 
<code>factors</code>.</p>
</td></tr> 
<tr><td><code>target.criterion</code></td>
<td>
<p>the final value of the target criterion used for fitting.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>the list returned by numerical optimization function, with an
additional initial item recording <code>opt.method</code>.</p>
</td></tr>
</table>


<h3>Background</h3>

<p>The methodology proposed in the reference below deals with the presence of 
ordered factors used as explanatory variables, hence included in the linear 
predictor of some model under consideration.
For any given ordered factor with <em>K</em> levels, say, a set of <code class="reqn">K</code> 
numeric scores is introduced, with a certain value assigned to each factor level.
In the end, the original factor is effectively replaced by a numeric variable.
This scheme represents a refinement of the elementary scoring system based
on the basic sequence <code class="reqn">1, \dots, K</code>, which constitutes a simple 
time-honoured option to deal with ordered factors, 
but it is not always appropriate.
</p>
<p>There are two variants of the methodology, selected with the value of
the component <code>type</code> of the list <code>scoring</code>.
Here we summarize the working of the original formulation, 
selected by setting <code>scoring$type="distr"</code>;
this happens implicitly if <code>scoring</code> is not specified.
The basic logic dealing with the case <code>scoring$type="spline"</code> is the same, 
even if the technique is different.
The actual construction of numeric scores proceeds by selecting <code class="reqn">K</code> 
quantiles of a distribution belonging to some parametric family.
The adoption of a sufficiently flexible parametric family helps to find
a scoring system best suited for the data under consideration,
hence improving upon the basic sequence <code class="reqn">1, \dots, K</code>.
A concomitant product of this scheme is the identification of numeric values
which indicate how the <code class="reqn">K</code> levels are &ldquo;really&rdquo; spaced.
Combining these two features, the key feature of the proposal is 
interpretability of the construction.
</p>
<p>The proposed method represents an alternative to the use of polynomial 
contrasts, which is the default action taken by <span class="rlang"><b>R</b></span> for ordered factors;
see the documentation of <code>contr.poly</code>.
</p>
<p>In the proposed logic, the constructed scores are intended to be used, and
interpreted, without further manipulation. Hence, for instance, building a 
polynomial form using one such variable would diverge somewhat from the 
proposed logic, although still conceivable.
With a single numeric variable to represent a given factor, 
one cannot expect to achieve the same numerical fit to the data 
as obtained the polynomial contrasts built for the original factor, 
when these constrasts involve high degrees polynomials, and 
correspondingly several parameters.
However, a range of numerical explorations has indicated that in many cases
the resulting fit is equal or similar to the one achieved via polynomial 
constrasts, with non-negligible simplification in the model specification, 
and easier interpretation, 
</p>
<p>In a nutshell, the aim of the approach is to achieve a satisfactory data fit
while improving an model parsimony, with simple interpretability of the 
score system.
</p>
<p>The alternative variant of the methodology is selected by setting  
<code>scoring$type="spline"</code>. The underlying principle is similar to the
one just described, but it makes use of splines instead of quantile functions.
Its operational working is described in the &lsquo;Details&rsquo;.
</p>
<p>For a more comprehensive exposition and discussion, see the references below.
</p>


<h3>Computational aspects</h3>

<p>The fitting step for selecting the transformation(s) parameters proceeds 
by an iterative scheme, whose essence is as follows.
For each choice of the transformation parameter(s), a call to <code>update</code>
of the <code>object</code> provided, using suitably modified linear predictor 
and data, delivers a new fitting, with attached a corresponding value 
of the target criterion.
For this process, work parameters are introduced which are free from the 
constraints implicit in either variant of the procedure, that is, either with 
<code>scoring$type="distr"</code> or with <code>scoring$type="spline"</code>.
An iterative optimization process of the target criterion (using the 
selected <code>opt.method</code>) leads to optimized work parameters. 
In the final stage, the selected work parameters are mapped to actual
model-meaningful parameters which identify a corresponding  fitted model.
</p>
<p>In some cases, the optimization step of <code>smof</code> can run into problems,  
typically when many parameters regulating the numeric scores are involved. 
This situation may be flagged by the warning message
</p>
<pre>Possibly unsatisfactory outcome from optimization function.</pre>
<p>In such a case, further information is printed even if <code>verbose=0</code>.
Since this information simply replicates what is delivered by the optimization 
function selected with <code>opt.method</code>, the documentation of that function 
must be examined to decipher the meaning of the message(s); 
sometimes, this may not be entirely obvious.
</p>
<p>To handle these events, sometimes it suffices to increase the number
of attempted iterations via <code>opt.control</code> and re-run the <code>smof</code>. 
Another simple possibility is to change the selected <code>opt.method</code>.
With more awkward situations, a more elaborate use of <code>opt.control</code> is
required. Alternatively, consider using of the function <code>smof_refit</code>.
</p>


<h3>Note</h3>

<p>For subsequent computations on the object returned by <code>smof</code>, difficulties 
may arise if the call to the fitting function does not set <code>model=TRUE</code>.
This is not a problem with <code>lm</code> and <code>glm</code>, if their default setting
<code>model=TRUE</code> has not been modified.
The  default setting of <code>coxph</code> is instead <code>model=FALSE</code>.
This implies, for instance, that issuing the <code>survival</code> command   
<code>survfit(smof4$new.object)</code>, right after running 
the code of Example 4 below, would cause an error. 
The main route to avoid this issue is to set <code>model=TRUE</code> in the call to
the fitting function, that is, <code>coxph</code> or whatever function is used.
Alternatively, if one does not want to refit an already existing object,
there exist various ways to overcome this snag; the simplest one is to write  
</p>

<table>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>new.data &lt;- smof4$new.data</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>s &lt;- survfit(smof4$new.object)</code>
</td>
</tr>

</table>
 
<p>This indication is temporary and it may be superseded by a different design 
in future versions of the package.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>References</h3>

<p>Azzalini, A. (2023). On the use of ordered factors as explanatory variables.
<em>Stat</em> <b>12</b>, e624. <a href="https://doi.org/10.1002/sta4.624">doi:10.1002/sta4.624</a>
</p>
<p>Azzalini, A. (2024). On the use of splines for representing ordered factors.
<em>arXiv:2406.15933</em>, <a href="https://doi.org/10.48550/arXiv.2406.15933">doi:10.48550/arXiv.2406.15933</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smof_refit">smof_refit</a></code>, 
<code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+contr.poly">contr.poly</a></code>, <code><a href="stats.html#topic+update">update</a></code>, 
<code><a href="stats.html#topic+splinefun">splinefun</a></code>, 
<code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>, 
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1, reconstructs Tables 1 and 2 (second part) of the reference
message("--- Example 1: esoph data ---")
library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6)  
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4)  
fit1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph) 
message("original fit:") 
print(summary(fit1))      
smof1 &lt;- smof(fit1, esoph, "alcgp")
# to select the Johnson's S_U family of distributions, write instead:
# smof1 &lt;- smof(fit1, esoph, "alcgp", scoring=list(type="distr", family="SU"))
print(smof1)
print(summary(smof1))
plot(smof1, type="b", pch=20, col=4)
#
# Example 2 , reconstructs Tables 3 and 4 (first part) of the reference
if(require(ggplot2, quietly=TRUE)) {
message("--- Example 2: diamonds data ---")
data(diamonds, package="ggplot2")  
dmd &lt;- data.frame(diamonds[seq(1, 53940, by=100),]) # use a subset of the data
dmd &lt;- dmd[-c(518, 519, 523),] # remove three outliers
contrasts(dmd$clarity, 3) &lt;- contr.poly(8)  
contrasts(dmd$color, 4) &lt;- contr.poly(7)
contrasts(dmd$cut, 1) &lt;- contr.poly(5) 
fit2 &lt;- lm(sqrt(price) ~ carat + clarity + color + cut, data=dmd)
smof2 &lt;- smof(fit2, dmd,  c("color", "clarity"))
message("smof fit:") 
print(smof2)
print(summary(smof2))
plot(smof2, which="clarity")
} # end diamonds example
#
# Example 3
if(require(survival, quietly=TRUE)) {
message("--- Example 3: lung data ---")
lung0 &lt;- lung
lung0$ph.karno &lt;- ordered(lung0$ph.karno)
contrasts(lung0$ph.karno, 3) &lt;- contr.poly(6)
fit3 &lt;- survreg(Surv(time, status) ~ ph.karno, data=lung0)
smof3 &lt;- smof(fit3, lung0, "ph.karno")
print(summary(smof3))
plot(smof3)  # Karnofsky scores do not seem to be linearly spaced
# 
message("--- Example 4: PBC data ---")
data(pbc, package="survival")
pbc$stage &lt;- ordered(pbc$stage)
fit4 &lt;- coxph(Surv(time) ~ strata(status) + stage, data=pbc)
smof4 &lt;- smof(fit4, data=pbc, factors="stage")
print(summary(smof4))
plot(smof4)
} # end of survival examples
</code></pre>

<hr>
<h2 id='smof_refit'>Re-fitting an existing <code>smof</code> model for improved optimization</h2><span id='topic+smof_refit'></span>

<h3>Description</h3>

<p>Given a model fitted by <code>smof</code>, this function helps 
to improve the achieved fitting level (represented by the value of the target
criterion) by launching new numerical optimizations 
of the underlying target function.
The search process is initiated with parameters randomly chosen
in the vicinity of those of the <code>object</code> provided.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smof_refit(object, searches = 10, sd = 1, opt.control=list(), verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smof_refit_+3A_object">object</code></td>
<td>
<p>an object returned by a call to <code>smof</code>;
that call must include the argument <code>original=TRUE</code>. </p>
</td></tr>
<tr><td><code id="smof_refit_+3A_searches">searches</code></td>
<td>
<p>a positive integer representing the number of attempted searches.</p>
</td></tr>
<tr><td><code id="smof_refit_+3A_sd">sd</code></td>
<td>
<p>the standard deviation of the zero-mean normal variates used 
for earch search to generate the initial set of parameters from which 
to initiate a numerical optimization.</p>
</td></tr>
<tr><td><code id="smof_refit_+3A_opt.control">opt.control</code></td>
<td>
<p>a list passed to the optimization function (the same used 
to create <code>object</code>) as its <code>control</code> argument. 
It must not be used to turn the minimization problem into a maximization one.</p>
</td></tr>      
<tr><td><code id="smof_refit_+3A_verbose">verbose</code></td>
<td>
<p>an integer regulating the amount of messages displayed;
it can be 0 (no messages), 1 (default value) or larger than 1 for 
a more verbose outcome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Section &lsquo;Computational aspects&rsquo; of the <code>smof</code> documentation
provides some simple suggestions to overcome numerical difficulties arising  
in the fitting process.
For harder problems, <code>smof_refit</code> aims at improving the results obtained 
by an initial call to <code>smof</code> via a sequence of calls to <code>smof</code> itself, 
each time starting from the last best fit obtained up to that point.
</p>
<p>In &lsquo;regular&rsquo; situations, it is expected that the main usage of this 
function is to  improve the fitting of models produced with 
<code>scoring$type="spline"</code>, since this option typically generates a model 
with more parameters than an equivalent model with <code>scoring$type="distr"</code>,
hence generally more problematic at the optimization step. 
</p>
<p>Since the initial values of each optimization step are randomly generated
(in the vicininy of the best known parameter set), 
it is advisable to make a preliminary call to <code>set.seed</code>, to ensure
replicability of the results.
</p>


<h3>Value</h3>

<p>an object of class <code>smof</code></p>


<h3>See Also</h3>

<p><code><a href="#topic+smof">smof</a></code>,  <code><a href="base.html#topic+set.seed">set.seed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(esoph)
fit &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph)
smof2 &lt;- smof(fit, esoph, c("agegp", "alcgp"), 
             scoring=list(type="spline", in.knots=c(2,1)), original=TRUE)
set.seed(1)             
smof2a &lt;- smof_refit(smof2, searches=4, opt.control=list(maxit=50))
# smof2b &lt;- smof_refit(smof2a)  # further improvement can be attempted
</code></pre>

<hr>
<h2 id='smof-methods'>Methods for <code>smof</code> objects</h2><span id='topic+print.smof'></span><span id='topic+plot.smof'></span><span id='topic+predict.smof'></span><span id='topic+summary.smof'></span><span id='topic+print.summary.smof'></span><span id='topic+coef.smof'></span><span id='topic+anova.smof'></span>

<h3>Description</h3>

<p>The list of methods that apply to <code>smof</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smof'
print(x, ...)
## S3 method for class 'smof'
plot(x, which, ...)
## S3 method for class 'smof'
summary(object,  ...)
## S3 method for class 'summary.smof'
print(x, ...)
## S3 method for class 'smof'
predict(object, newdata, ...)
## S3 method for class 'smof'
coef(object, complete=FALSE, ...)
## S3 method for class 'smof'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smof-methods_+3A_object">object</code></td>
<td>
<p>an object returned by <code>smof</code>.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_x">x</code></td>
<td>
<p>an object returned by <code>smof</code>, except for <code>print.summary.smof</code> 
where <code>x</code> is the outcome of <code>summary.smof</code>.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_which">which</code></td>
<td>
<p>either a vector or a two-elements list; see &lsquo;Details&rsquo;
for full specification.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_newdata">newdata</code></td>
<td>
<p>a data frame which includes ordered factors with the same names
and levels as those in the data frame used to produce <code>object</code>;
see &lsquo;Details&rsquo; for additional information.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_complete">complete</code></td>
<td>
<p>logical value (default: <code>FALSE</code>); when <code>TRUE</code>, the
coefficients of the fitted model are included after the parameters of the 
scoring transformation.</p>
</td></tr>
<tr><td><code id="smof-methods_+3A_...">...</code></td>
<td>
<p>arguments passed through to other methods. For <code>anova</code> it is ignored.</p>
</td></tr>   
</table>


<h3>Details</h3>

<p>There are two main parts in the outcome of <code>summary.smof</code>. One is the
outcome of the selection of the factor(s) transformation(s); the other part,
denoted <kbd>Final fitting call</kbd>, represents the newly fitted model  
with the original ordered factors  replaced  by numeric scores. 
The corresponding <code>data.frame</code>, denoted <code>new.data</code>, is one 
of the components of the object returned by <code>smof</code>.
</p>
<p>If <code>which</code> is a character vector, its components are interpreted as
names of the <code>factors</code> in the calling statement of the object to be 
plotted, producing a set of
graphs where the numeric scores of each named factor are plotted versus
the equally spaced ticks associated to the original level names.
The same effect is obtained when <code>which</code> is a numeric vector of integers,
which then select the corresponding components of the <code>factors</code> sequence.
</p>
<p>If <code>which</code> is a list, its first element is assumed to be a vector having
the meaning just described. After the pertaining set of graphs has been 
completed,  the second element of the list is passed to the plotting method 
for the object produced by the model fitting procedure.
Currently this option operates only for objects which inherits from class
<code>lm</code>; specifically, it works for objects originated by a call to 
<code>lm</code> or to <code>glm</code>.
</p>
<p>With <code>predict.smof</code>, the outcome of a <code>smof</code> fit is applied 
to new data frame which includes ordered factors analogous to those used to 
compute the <code>smof</code> transformation. 
Only the factors of <code>newdata</code> with the same name as those processed by 
<code>smof</code> to produce <code>object</code> are examined. The levels of these
factors must coincide with or be a subset of those of the original data frame.
</p>
<p>Note the difference between the role played by <code>predict.smof</code> and  
the one of <code>predict</code> methods for most other classes. Usually the 
returned values pertain to the response variable, or to some related entity, 
while here the outcome refers to explanatory variables.
</p>


<h3>Value</h3>

<p>For <code>summary.smof</code>, a list of class <code>summary.smof</code>. 
For <code>predict.smof</code>, a data frame.
For <code>plot.smof</code>, <code>NULL</code> with graphical side effects. 
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini</p>


<h3>See Also</h3>

<p><code><a href="#topic+smof">smof</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
data(esoph)
contrasts(esoph$agegp, 2) &lt;- contr.poly(6)  
contrasts(esoph$tobgp, 1) &lt;- contr.poly(4)  
fit1 &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp + alcgp, family=binomial(), data=esoph)      
smof1 &lt;- smof(fit1, esoph, "alcgp")
print(smof1)
print(summary(smof1))
plot(smof1, type="b", pch=19, col="blue")
plot(smof1, which=list(1, 1:4))
predict(smof1, newdata=esoph[seq(1, 88, by=8), ]) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
