<!DOCTYPE html><html><head><title>Help for package genBaRcode</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genBaRcode}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.createPatternFile'><p>Internal function</p></a></li>
<li><a href='#.generateColors'><p>Color list generation</p></a></li>
<li><a href='#.getBarcodeFilter'><p>Internal function</p></a></li>
<li><a href='#.getDiagonalIndex'><p>Index Generation</p></a></li>
<li><a href='#.getMinDist'><p>Distance calculation</p></a></li>
<li><a href='#.getWobblePos'><p>getWobblePos</p></a></li>
<li><a href='#.hex2rgbColor'><p>Converts hex colors into gephi usable rgb colors</p></a></li>
<li><a href='#.revComp'><p>DNA string manipulation</p></a></li>
<li><a href='#.revComp_EqLength'><p>DNA string manipulation for equal string sizes</p></a></li>
<li><a href='#.revComp_UneqLength'><p>DNA string manipulation for unequal string sizes</p></a></li>
<li><a href='#.testDirIdentifier'><p>Internal function</p></a></li>
<li><a href='#asBCdat'><p>Data Type Conversion</p></a></li>
<li><a href='#BC_dat'><p>Barcode distribution of an example experiment.</p></a></li>
<li><a href='#BC_dat_EC'><p>Barcode distribution of an example experiment.</p></a></li>
<li><a href='#BCdat-class'><p>BCdat class.</p></a></li>
<li><a href='#com_pair'><p>Compairing two BCdat Objects</p></a></li>
<li><a href='#createGDF'><p>Creating a gdf File</p></a></li>
<li><a href='#error_correction_circlePlot'><p>Circle Plot</p></a></li>
<li><a href='#error_correction_clustered_HDs'><p>Clustered HD Plot</p></a></li>
<li><a href='#error_correction_treePlot'><p>Tree Plot</p></a></li>
<li><a href='#errorCorrection'><p>Error Correction</p></a></li>
<li><a href='#extractBarcodes'><p>Barcode extraction</p></a></li>
<li><a href='#genBaRcode_app'><p>Shiny App</p></a></li>
<li><a href='#generateKirchenplot'><p>Plotting a Kirchenplot</p></a></li>
<li><a href='#generateTimeSeriesData'><p>Generating Time Series Data Object</p></a></li>
<li><a href='#getBackbone'><p>Accessing the Barcode Backbone slot of a BCdat objects.</p></a></li>
<li><a href='#getBackboneSelection'><p>Predefined Barcode Backbone Sequences</p></a></li>
<li><a href='#getLabel'><p>Accessing the Label slot of a BCdat objects.</p></a></li>
<li><a href='#getReads'><p>Accessing the Read-Count slot of a BCdat objects.</p></a></li>
<li><a href='#getResultsDir'><p>Accessing the Results Directory slot of a BCdat objects.</p></a></li>
<li><a href='#ggplotDistanceGraph'><p>Plotting a Distance Network</p></a></li>
<li><a href='#ggplotDistanceGraph_EC'><p>Plotting a Distance Network (error correction)</p></a></li>
<li><a href='#hybridsIdentification'><p>Identifies hybrid barcodes</p></a></li>
<li><a href='#plotClusterGgTree'><p>Plotting a Cluster ggTree</p></a></li>
<li><a href='#plotClusterTree'><p>Plotting a Cluster Tree</p></a></li>
<li><a href='#plotDistanceIgraph'><p>Plotting a Distance Network</p></a></li>
<li><a href='#plotDistanceVisNetwork'><p>Plotting a Distance Network</p></a></li>
<li><a href='#plotDistanceVisNetwork_EC'><p>Plotting a Distance Network (error correction)</p></a></li>
<li><a href='#plotNucFrequency'><p>Plotting Nucleotide Frequency</p></a></li>
<li><a href='#plotQualityScoreDis'><p>Plotting Quality Score Distribution</p></a></li>
<li><a href='#plotQualityScorePerCycle'><p>Plotting Quality Score per Cycle</p></a></li>
<li><a href='#plotReadFrequencies'><p>Plotting a Barplot</p></a></li>
<li><a href='#plotSeqLogo'><p>Plots a sequence logo</p></a></li>
<li><a href='#plotTimeSeries'><p>Plotting Time Series Data</p></a></li>
<li><a href='#plotVennDiagram'><p>Plotting a VennDiagram</p></a></li>
<li><a href='#prepareDatObject'><p>Data Object Preparation</p></a></li>
<li><a href='#processingRawData'><p>Data processing</p></a></li>
<li><a href='#qualityFiltering'><p>Quality Filtering</p></a></li>
<li><a href='#readBCdat'><p>Data Input</p></a></li>
<li><a href='#setBackbone'><p>Replacing the Barcode Backbone slot of a BCdat objects.</p></a></li>
<li><a href='#setLabel'><p>Replacing the Label slot of a BCdat objects.</p></a></li>
<li><a href='#setReads'><p>Replacing the Read-Count slot of a BCdat objects.</p></a></li>
<li><a href='#setResultsDir'><p>Replacing the Results Directory slot of a BCdat objects.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis and Visualization Tools for Genetic Barcode Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Author:</td>
<td>Lars Thielecke &lt;lars.thielecke@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Thielecke &lt;lars.thielecke@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the necessary functions to identify and extract a selection of already available barcode constructs (Cornils, K. et al. (2014) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgku081">doi:10.1093/nar/gku081</a>&gt;) and freely choosable barcode designs from next generation sequence (NGS) data. Furthermore, it offers the possibility to account for sequence errors, the calculation of barcode similarities and provides a variety of visualisation tools (Thielecke, L. et al. (2017) &lt;<a href="https://doi.org/10.1038%2Fsrep43249">doi:10.1038/srep43249</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, RColorBrewer, ape, ggnetwork, ggplot2, ggraph,
igraph, network, phangorn, stringdist, visNetwork, reshape2,
S4Vectors, shiny, ggtree, dplyr, VennDiagram, futile.logger,
future, future.apply, tools, ShortRead, Biostrings</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'BCdata-class.R' 'BCdata-class-methods.R'
'analysis_functions.R' 'data.R' 'error_correction_function.R'
'helper_functions.R' 'plot_functions.R' 'raw_data_processing.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 11:14:34 UTC; thiella</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 13:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.createPatternFile'>Internal function</h2><span id='topic+.createPatternFile'></span>

<h3>Description</h3>

<p>Creates a search file for a command line grep search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.createPatternFile(bc_backbone, patterns_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".createPatternFile_+3A_bc_backbone">bc_backbone</code></td>
<td>
<p>a character string (barcode pattern).</p>
</td></tr>
<tr><td><code id=".createPatternFile_+3A_patterns_file">patterns_file</code></td>
<td>
<p>a character string (file name)</p>
</td></tr>
</table>

<hr>
<h2 id='.generateColors'>Color list generation</h2><span id='topic+.generateColors'></span>

<h3>Description</h3>

<p>Generates a collection of colors for a list of barcodes based on their identified minimum hamming distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.generateColors(minHD, type = "rainbow", alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".generateColors_+3A_minhd">minHD</code></td>
<td>
<p>a numeric vector of all the minimum hamming distances.</p>
</td></tr>
<tr><td><code id=".generateColors_+3A_type">type</code></td>
<td>
<p>a character string. Possible Values are &quot;rainbow&quot;, &quot;heat.colors&quot;, &quot;topo.colors&quot;, &quot;greens&quot;, &quot;wild&quot;.</p>
</td></tr>
<tr><td><code id=".generateColors_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value between 0 and 1, modifies colour transparency.</p>
</td></tr>
</table>

<hr>
<h2 id='.getBarcodeFilter'>Internal function</h2><span id='topic+.getBarcodeFilter'></span>

<h3>Description</h3>

<p>Identifies the barcode positions within the barcode backbone and generates a awk command.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getBarcodeFilter(wobble_pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getBarcodeFilter_+3A_wobble_pos">wobble_pos</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>

<hr>
<h2 id='.getDiagonalIndex'>Index Generation</h2><span id='topic+.getDiagonalIndex'></span>

<h3>Description</h3>

<p>Generates a matrix index to create a square triangular matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDiagonalIndex(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDiagonalIndex_+3A_n">n</code></td>
<td>
<p>an integer indicating the size of the resulting index matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a locigal matrix of size <code>n</code> x <code>n</code>
</p>

<hr>
<h2 id='.getMinDist'>Distance calculation</h2><span id='topic+.getMinDist'></span>

<h3>Description</h3>

<p>Calculates the minimum distance to a set of predefined barcodes for a given list of barcode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getMinDist(BC_dat, ori_BCs, m = "hamming")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getMinDist_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object</p>
</td></tr>
<tr><td><code id=".getMinDist_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a character vector containing barcodes to which the minimal hamming distance will be calculated.</p>
</td></tr>
<tr><td><code id=".getMinDist_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>

<hr>
<h2 id='.getWobblePos'>getWobblePos</h2><span id='topic+.getWobblePos'></span>

<h3>Description</h3>

<p>Extracts barcode positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getWobblePos(bc_backbone = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getWobblePos_+3A_bc_backbone">bc_backbone</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='.hex2rgbColor'>Converts hex colors into gephi usable rgb colors</h2><span id='topic+.hex2rgbColor'></span>

<h3>Description</h3>

<p>Converts hex colors into gephi usable rgb colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hex2rgbColor(colrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".hex2rgbColor_+3A_colrs">colrs</code></td>
<td>
<p>a character vector containing a list of hex colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color vector.
</p>

<hr>
<h2 id='.revComp'>DNA string manipulation</h2><span id='topic+.revComp'></span>

<h3>Description</h3>

<p>Converts a vector of character strings (DNA sequences) into its reverse complement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.revComp(seq_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".revComp_+3A_seq_dat">seq_dat</code></td>
<td>
<p>a character vector containing DNA sequences</p>
</td></tr>
</table>

<hr>
<h2 id='.revComp_EqLength'>DNA string manipulation for equal string sizes</h2><span id='topic+.revComp_EqLength'></span>

<h3>Description</h3>

<p>Converts a vector of equally long character strings into its reverse complement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.revComp_EqLength(seq_dat, word_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".revComp_EqLength_+3A_seq_dat">seq_dat</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id=".revComp_EqLength_+3A_word_length">word_length</code></td>
<td>
<p>an integer giving the word length.</p>
</td></tr>
</table>

<hr>
<h2 id='.revComp_UneqLength'>DNA string manipulation for unequal string sizes</h2><span id='topic+.revComp_UneqLength'></span>

<h3>Description</h3>

<p>Converts a vector of unequally long character strings into the reverse complement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.revComp_UneqLength(seq_dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".revComp_UneqLength_+3A_seq_dat">seq_dat</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='.testDirIdentifier'>Internal function</h2><span id='topic+.testDirIdentifier'></span>

<h3>Description</h3>

<p>Checks directory paths for correctness and if nessesary corrects them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.testDirIdentifier(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".testDirIdentifier_+3A_s">s</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>

<hr>
<h2 id='asBCdat'>Data Type Conversion</h2><span id='topic+asBCdat'></span>

<h3>Description</h3>

<p>Converts a data.frame into a BCdat object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asBCdat(dat, label = "empty", BC_backbone = "none", resDir = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asBCdat_+3A_dat">dat</code></td>
<td>
<p>a data.frame object with two columns containing read counts and barcode sequences.</p>
</td></tr>
<tr><td><code id="asBCdat_+3A_label">label</code></td>
<td>
<p>a optional character string used as label.</p>
</td></tr>
<tr><td><code id="asBCdat_+3A_bc_backbone">BC_backbone</code></td>
<td>
<p>a optional character string, describing the barcode backbone structure.</p>
</td></tr>
<tr><td><code id="asBCdat_+3A_resdir">resDir</code></td>
<td>
<p>a optional character string, identifying the path to the results directory, default is current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>

<hr>
<h2 id='BC_dat'>Barcode distribution of an example experiment.</h2><span id='topic+BC_dat'></span>

<h3>Description</h3>

<p>A dataset containing an example BCdat object which consists of 98 barcode sequences and with no error correction yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BC_dat
</code></pre>


<h3>Format</h3>

<p>A S4 data object with the following slots:
</p>

<dl>
<dt>class</dt><dd><p>sequence overview</p>
</dd>
<dt>barcode read counts</dt><dd><p>a data frame consisting of read counts and barcode sequences</p>
</dd>
<dt>results dir</dt><dd><p>path to a directory for any kind of results</p>
</dd>
<dt>barcode backbone</dt><dd><p>a string clarifying the barcode backbone structure</p>
</dd>
<dt>label</dt><dd><p>character string, used as label for file names etc.</p>
</dd>
</dl>



<h3>Details</h3>

<p>BC_dat:
</p>

<hr>
<h2 id='BC_dat_EC'>Barcode distribution of an example experiment.</h2><span id='topic+BC_dat_EC'></span>

<h3>Description</h3>

<p>A dataset containing an example BCdat object after error-correction which consists of 10 barcode sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BC_dat_EC
</code></pre>


<h3>Format</h3>

<p>A S4 data object with the following slots:
</p>

<dl>
<dt>class</dt><dd><p>sequence overview</p>
</dd>
<dt>barcode read counts</dt><dd><p>a data frame consisting of read counts and barcode sequences</p>
</dd>
<dt>results dir</dt><dd><p>path to a directory for any kind of results</p>
</dd>
<dt>barcode backbone</dt><dd><p>a string clarifying the barcode backbone structure</p>
</dd>
<dt>label</dt><dd><p>character string, used as label for file names etc.</p>
</dd>
</dl>



<h3>Details</h3>

<p>BC_dat_EC:
</p>

<hr>
<h2 id='BCdat-class'>BCdat class.</h2><span id='topic+BCdat-class'></span><span id='topic+BCdat'></span>

<h3>Description</h3>

<p>BCdat class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>reads</code></dt><dd><p>data.frame containing barcode sequences and their corresponding read counts.</p>
</dd>
<dt><code>results_dir</code></dt><dd><p>character string of the working directory path.</p>
</dd>
<dt><code>label</code></dt><dd><p>character string identifying the particular experiment (will be part of the names of any file created).</p>
</dd>
<dt><code>BC_backbone</code></dt><dd><p>character string of the used barcode design (also called barcode backbone).</p>
</dd>
</dl>

<hr>
<h2 id='com_pair'>Compairing two BCdat Objects</h2><span id='topic+com_pair'></span>

<h3>Description</h3>

<p>Compairing two BCdat Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>com_pair(BC_dat1 = NULL, BC_dat2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="com_pair_+3A_bc_dat1">BC_dat1</code></td>
<td>
<p>the first BCdat object.</p>
</td></tr>
<tr><td><code id="com_pair_+3A_bc_dat2">BC_dat2</code></td>
<td>
<p>the second BCdat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the shared and the unqiue barcodes.
</p>

<hr>
<h2 id='createGDF'>Creating a gdf File</h2><span id='topic+createGDF'></span>

<h3>Description</h3>

<p>createGDF creates a data file usable with the free graph visualisation tool gephi. The nodes
represent barcodes and its respective size reflects the corresponding read counts. Edges between nodes indicate
a distance between two barcodes of maximal <code>minD</code>.
If <code>ori_BCs</code> is provided the node color refelects the distance of a particular barcode to one
of the provided barcode sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGDF(
  BC_dat,
  minDist = 1,
  loga = TRUE,
  ori_BCs = NULL,
  col_type = "rainbow",
  m = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGDF_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="createGDF_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance value for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="createGDF_+3A_loga">loga</code></td>
<td>
<p>a logical value indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="createGDF_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing the barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="createGDF_+3A_col_type">col_type</code></td>
<td>
<p>character sting, choosing one of the available color palettes.</p>
</td></tr>
<tr><td><code id="createGDF_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(BC_dat)
createGDFFile(BC_dat, minDist = 1, loga = TRUE, ori_BCs = NULL, col_type = "rainbow")


## End(Not run)
</code></pre>

<hr>
<h2 id='error_correction_circlePlot'>Circle Plot</h2><span id='topic+error_correction_circlePlot'></span>

<h3>Description</h3>

<p>creates a circle plot based on the additional data gathered by the error_correction function (EC_analysis needs to be set to TRUE). This function is intended to visualize the error correction procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_correction_circlePlot(edges, vertices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_correction_circlePlot_+3A_edges">edges</code></td>
<td>
<p>a data frame containing edge definitions by two columns calles &quot;from&quot; and &quot;to&quot;. Such data frame will be returned by the error_correction function with the EC_analysis parameter set to TRUE.</p>
</td></tr>
<tr><td><code id="error_correction_circlePlot_+3A_vertices">vertices</code></td>
<td>
<p>a data frame with at least one column containing a list of nodes (also returned by the error_correction function with the EC_analysis parameter set to TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>

<hr>
<h2 id='error_correction_clustered_HDs'>Clustered HD Plot</h2><span id='topic+error_correction_clustered_HDs'></span>

<h3>Description</h3>

<p>This function will create a jitter plot displaying the maximal distances within each of the barcode sequence clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_correction_clustered_HDs(datEC, size = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_correction_clustered_HDs_+3A_datec">datEC</code></td>
<td>
<p>a BC_dat object, returned by the error_correction function with the EC_analysis parameter set to TRUE.</p>
</td></tr>
<tr><td><code id="error_correction_clustered_HDs_+3A_size">size</code></td>
<td>
<p>a numeric value, specifying the dot size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>

<hr>
<h2 id='error_correction_treePlot'>Tree Plot</h2><span id='topic+error_correction_treePlot'></span>

<h3>Description</h3>

<p>creates a Tree Plot visualising of the barcode clustering as part of the error correction process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_correction_treePlot(edges, vertices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_correction_treePlot_+3A_edges">edges</code></td>
<td>
<p>a data frame containing edge definitions by two columns calles &quot;from&quot; and &quot;to&quot;. Such data frame will be returned by the error_correction function with the EC_analysis parameter set to TRUE.</p>
</td></tr>
<tr><td><code id="error_correction_treePlot_+3A_vertices">vertices</code></td>
<td>
<p>a data frame with at least one column containing a list of nodes (also returned by the error_correction function with the EC_analysis parameter set to TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>

<hr>
<h2 id='errorCorrection'>Error Correction</h2><span id='topic+errorCorrection'></span>

<h3>Description</h3>

<p>Corrects a list of equally long (barcode) sequences. Based on calculated hamming distances
as a measure of similarity, highly similar sequences are clustered together and the cluster label will
be the respective sequence with the highest read count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorCorrection(
  BC_dat,
  maxDist,
  save_it = FALSE,
  cpus = 1,
  strategy = "sequential",
  m = "hamming",
  type = "standard",
  only_EC_BCs = TRUE,
  EC_analysis = FALSE,
  start_small = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorCorrection_+3A_bc_dat">BC_dat</code></td>
<td>
<p>one or a list of BCdat objects, containing the necessary sequences.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_maxdist">maxDist</code></td>
<td>
<p>an integer value representing the maximal hamming distance for which it is allowed to
cluster two sequences together.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_save_it">save_it</code></td>
<td>
<p>a logical value. If TRUE the data will be saved as csv-file.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_cpus">cpus</code></td>
<td>
<p>an integer value, in case multiple BCdat objects are provided a CPU number greater than one
would allow for a parallelized calculation (one CPU per BCdat object).</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_strategy">strategy</code></td>
<td>
<p>since the future package is used for parallelisation a strategy has to be stated, the default is &quot;sequential&quot;  (cpus = 1) and &quot;multiprocess&quot; (cpus &gt; 1). It is not necessary to chose a certain strategy, since it will be adjusted accordingly to the number of cpus which were choosen. For further information please read future::plan() R-Documentation.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information)</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_type">type</code></td>
<td>
<p>there are different error correction strategies avalable (&quot;standard&quot;, &quot;connectivity based&quot;, &quot;graph based&quot;, &quot;clustering&quot;).</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_only_ec_bcs">only_EC_BCs</code></td>
<td>
<p>a logical value. If TRUE only informations about barcodes which are still present after error correction will be saved. Only meaningful if EC_analysis is set to TRUE.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_ec_analysis">EC_analysis</code></td>
<td>
<p>a logical value. If TRUE additional error correction details will be returned, which can also be visualised with the respective &quot;error correction&quot; plots.</p>
</td></tr>
<tr><td><code id="errorCorrection_+3A_start_small">start_small</code></td>
<td>
<p>a logical value. If TRUE, the error correcton type &quot;standard&quot; will cluster always the smallest highly similar BC with the BC of interest. IF FALSE, the error correcton type &quot;standard&quot; will adapt its cluster strategy and cluster always BC of interest with the most frequent highly similar BC.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
BC_dat_EC &lt;- errorCorrection(BC_dat, maxDist = 8, save_it = FALSE, m = "hamming")
</code></pre>

<hr>
<h2 id='extractBarcodes'>Barcode extraction</h2><span id='topic+extractBarcodes'></span>

<h3>Description</h3>

<p>Extracts barcodes according to the given barcode design from a fastq file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractBarcodes(
  dat,
  label,
  results_dir = "./",
  mismatch = 0,
  indels = FALSE,
  bc_backbone,
  full_output = FALSE,
  cpus = 1,
  strategy = "sequential",
  wobble_extraction = TRUE,
  dist_measure = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractBarcodes_+3A_dat">dat</code></td>
<td>
<p>a ShortReadQ object.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_label">label</code></td>
<td>
<p>a character string.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_results_dir">results_dir</code></td>
<td>
<p>a character string which contains the path to the results directory.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_mismatch">mismatch</code></td>
<td>
<p>an positive integer value, default is 0, if greater values are provided they indicate the number of allowed mismatches when identifing the barcode constructe.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_indels">indels</code></td>
<td>
<p>under construction.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_bc_backbone">bc_backbone</code></td>
<td>
<p>a character string or character vector describing the barcode design, variable positions have to be marked with the letter 'N'.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_full_output">full_output</code></td>
<td>
<p>a logical value. If TRUE additional output files will be generated in order to identify errors.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_cpus">cpus</code></td>
<td>
<p>an integer value, indicating the number of available cpus.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_strategy">strategy</code></td>
<td>
<p>since the future package is used for parallelisation a strategy has to be stated, the default is &quot;sequential&quot;  (cpus = 1) and &quot;multiprocess&quot; (cpus &gt; 1). For further information please read future::plan() R-Documentation.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_wobble_extraction">wobble_extraction</code></td>
<td>
<p>a logical value. If TRUE, single reads will be stripped of the backbone and only the &quot;wobble&quot; positions will be left.</p>
</td></tr>
<tr><td><code id="extractBarcodes_+3A_dist_measure">dist_measure</code></td>
<td>
<p>a character value. If &quot;bc_backbone = 'none'&quot;, single reads will be clustered based on a distance measure.
Available distance methods are Optimal string aligment (&quot;osa&quot;), Levenshtein (&quot;lv&quot;), Damerau-Levenshtein (&quot;dl&quot;), Hamming (&quot;hamming&quot;), Longest common substring (&quot;lcs&quot;), q-gram (&quot;qgram&quot;), cosine (&quot;cosine&quot;), Jaccard (&quot;jaccard&quot;), Jaro-Winkler (&quot;jw&quot;),
distance based on soundex encoding (&quot;soundex&quot;). For more detailed information see stringdist function of the stringdist-package for more information)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>one or a list of frequency table(s) of barcode sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

bc_backbone &lt;- "ACTNNCGANNCTTNNCGANNCTTNNGGANNCTANNACTNNCGANNCTTNNCGANNCTTNNGGANNCTANNACTNNCGANN"
source_dir &lt;- system.file("extdata", package = "genBaRcode")
dat &lt;- ShortRead::readFastq(dirPath = source_dir, pattern = "test_data.fastq.gz")

extractBarcodes(dat, label = "test", results_dir = getwd(), mismatch = 0,
indels = FALSE, bc_backbone)


## End(Not run)
</code></pre>

<hr>
<h2 id='genBaRcode_app'>Shiny App</h2><span id='topic+genBaRcode_app'></span>

<h3>Description</h3>

<p>Launches the corresponding shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBaRcode_app(dat_dir = system.file("extdata", package = "genBaRcode"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genBaRcode_app_+3A_dat_dir">dat_dir</code></td>
<td>
<p>a character string, identifying the path to one or more fast(q) files which shall be analysed, default is the
path to the package inherent example fastq file</p>
</td></tr>
</table>

<hr>
<h2 id='generateKirchenplot'>Plotting a Kirchenplot</h2><span id='topic+generateKirchenplot'></span>

<h3>Description</h3>

<p>Generates a barplot based on read counts. If <code>ori_BCs</code> is provided the bar color reflects the
distance between a particular barcode to one of the provided barcode sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateKirchenplot(
  BC_dat,
  ori_BCs = NULL,
  ori_BCs2 = NULL,
  loga = TRUE,
  col_type = NULL,
  m = "hamming",
  setLabels = c("BC-Set 1", "Rest", "BC-Set 2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateKirchenplot_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing known barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_ori_bcs2">ori_BCs2</code></td>
<td>
<p>a vector of character strings containing a 2nd set of known barcode sequences (also without the fixed positions).</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_loga">loga</code></td>
<td>
<p>a logical value, indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_col_type">col_type</code></td>
<td>
<p>character string, choosing one of the availabe color palettes (&quot;rainbow&quot;, &quot;heat.colors&quot;, &quot;topo.colors&quot;, &quot;greens&quot;, &quot;wild&quot; - see package &quot;grDevices&quot;)</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information). If neither 'ori_BCs' nor 'ori_BCs2' are provided with input the choice of 'm' does not matter.</p>
</td></tr>
<tr><td><code id="generateKirchenplot_+3A_setlabels">setLabels</code></td>
<td>
<p>a character vector, containing three strings serving as plot labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='generateTimeSeriesData'>Generating Time Series Data Object</h2><span id='topic+generateTimeSeriesData'></span>

<h3>Description</h3>

<p>Generates a matrix containing barcodes sequences as rows and consecutive measurements at columns. It serves as
the necessary data object for the plotting function 'plotTimeSeries'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTimeSeriesData(BC_dat_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTimeSeriesData_+3A_bc_dat_list">BC_dat_list</code></td>
<td>
<p>a list of BCdat objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing every identified barcode and its read count per time point/measurement.
</p>

<hr>
<h2 id='getBackbone'>Accessing the Barcode Backbone slot of a BCdat objects.</h2><span id='topic+getBackbone'></span>

<h3>Description</h3>

<p>Accessing the Barcode Backbone slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBackbone(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBackbone_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
getBackbone(BC_dat)

</code></pre>

<hr>
<h2 id='getBackboneSelection'>Predefined Barcode Backbone Sequences</h2><span id='topic+getBackboneSelection'></span>

<h3>Description</h3>

<p>allows the user to choose between predefined backbone sequences. Excecution of the function without any parameter
value will display all available backbone sequences. The id parameter will accept the name of the backbone or the
rownumber of the shown selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBackboneSelection(id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBackboneSelection_+3A_id">id</code></td>
<td>
<p>an integer or character value in order to choose a specific backbone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getBackboneSelection()
getBackboneSelection(2)
getBackboneSelection("BC32-Venus")
</code></pre>

<hr>
<h2 id='getLabel'>Accessing the Label slot of a BCdat objects.</h2><span id='topic+getLabel'></span>

<h3>Description</h3>

<p>Accessing the Label slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLabel(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLabel_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
getLabel(BC_dat)

</code></pre>

<hr>
<h2 id='getReads'>Accessing the Read-Count slot of a BCdat objects.</h2><span id='topic+getReads'></span>

<h3>Description</h3>

<p>Accessing the Read-Count slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReads(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReads_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the read count table of the object paramter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
getReads(BC_dat)

</code></pre>

<hr>
<h2 id='getResultsDir'>Accessing the Results Directory slot of a BCdat objects.</h2><span id='topic+getResultsDir'></span>

<h3>Description</h3>

<p>Accessing the Results Directory slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResultsDir(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getResultsDir_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
getResultsDir(BC_dat)

</code></pre>

<hr>
<h2 id='ggplotDistanceGraph'>Plotting a Distance Network</h2><span id='topic+ggplotDistanceGraph'></span>

<h3>Description</h3>

<p>ggplotDistanceGraph will create a graph-like visualisation (ripple plot) of the corresponding barcode sequences
and their similarity based on the ggplot2 and the ggnetwork packages. The nodes represent the barcode sequences and their
respective size reflects the corresponding read counts. Edges between nodes indicate a distance between two barcodes
of maximal <code>minDist</code>.
If <code>ori_BCs</code> is provided the node color also refelects the distance of a particular barcode to one of the initial
barcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotDistanceGraph(
  BC_dat,
  minDist = 1,
  loga = TRUE,
  ori_BCs = NULL,
  lay = "fruchtermanreingold",
  complete = FALSE,
  col_type = "rainbow",
  m = "hamming",
  scale_nodes = 1,
  scale_edges = 1,
  legend_size = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotDistanceGraph_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_loga">loga</code></td>
<td>
<p>a logical value, indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing the barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_lay">lay</code></td>
<td>
<p>a character string, identifying the prefered layout algorithm (see ggnetwork layout option, &quot;?gplot.layout&quot;). Default value is &quot;fruchtermanreingold&quot;, but possible are also &quot;circle&quot;, &quot;eigen&quot;, &quot;kamadakawai&quot;, &quot;spring&quot; and many more. Or the user provides a two-column matrix with as many rows as there are nodes in the network, in which case the matrix is used as nodes coordinates.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_complete">complete</code></td>
<td>
<p>a logical value. If TRUE, every node will have at least one edge.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_col_type">col_type</code></td>
<td>
<p>a character sting, choosing one of the available color palettes (&quot;rainbow&quot;, &quot;heat.colors&quot;, &quot;topo.colors&quot;, &quot;greens&quot;, &quot;wild&quot; - see package &quot;grDevices&quot;).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_scale_nodes">scale_nodes</code></td>
<td>
<p>a numeric value, scaling the node size.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_scale_edges">scale_edges</code></td>
<td>
<p>a numeric value, scaling the edge size.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_+3A_legend_size">legend_size</code></td>
<td>
<p>a numeric value, scaling the legend symbol size, if legend_size equals 0, the legend will be dismissed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data(BC_dat)
ggplotDistanceGraph(BC_dat, minDist = 1, loga = TRUE, ori_BCs = NULL, lay = "fruchtermanreingold",
complete = FALSE, col_type = "rainbow")


## End(Not run)

</code></pre>

<hr>
<h2 id='ggplotDistanceGraph_EC'>Plotting a Distance Network (error correction)</h2><span id='topic+ggplotDistanceGraph_EC'></span>

<h3>Description</h3>

<p>ggplotDistanceGraph will create a graph-like visualisation (ripple plot) of the corresponding barcode sequences
and their similarity based on the ggplot2 and the ggnetwork packages. The nodes represent the barcode sequences and their
respective size reflects the corresponding read counts. Edges between nodes indicate a distance between two barcodes
of maximal <code>minDist</code>.
If <code>ori_BCs</code> is provided the node color also refelects the distance of a particular barcode to one of the initial
barcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotDistanceGraph_EC(
  BC_dat,
  BC_dat_EC,
  minDist = 1,
  loga = TRUE,
  equal_node_sizes = TRUE,
  BC_threshold = NULL,
  ori_BCs = NULL,
  lay = "fruchtermanreingold",
  complete = FALSE,
  col_type = "rainbow",
  m = "hamming",
  scale_nodes = 1,
  scale_edges = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_bc_dat_ec">BC_dat_EC</code></td>
<td>
<p>the error corrected BCdat object (the EC_analysis parameter needs to be set to TRUE).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_loga">loga</code></td>
<td>
<p>a logical value, indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_equal_node_sizes">equal_node_sizes</code></td>
<td>
<p>a logical value. If TRUE, every node will have the same size.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_bc_threshold">BC_threshold</code></td>
<td>
<p>a nnumeric value, limiting the number of barcodes for which their error correction &quot;history&quot; will be colored (if BC_threshold = 5 then the five biggest barcodes will be evaluated)</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing barcode sequences (without the fixed positions of the barcode construct). Similar to BC_threshold but allowing for barcode identification via sequence.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_lay">lay</code></td>
<td>
<p>a character string, identifying the prefered layout algorithm (see ggnetwork layout option).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_complete">complete</code></td>
<td>
<p>a logical value. If TRUE, every node will have at least one edge.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_col_type">col_type</code></td>
<td>
<p>a character sting, choosing one of the available color palettes.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_scale_nodes">scale_nodes</code></td>
<td>
<p>a numeric value, scaling the node size.</p>
</td></tr>
<tr><td><code id="ggplotDistanceGraph_EC_+3A_scale_edges">scale_edges</code></td>
<td>
<p>a numeric value, scaling the edge size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='hybridsIdentification'>Identifies hybrid barcodes</h2><span id='topic+hybridsIdentification'></span>

<h3>Description</h3>

<p>Experimental function to identify hybrid barcodes which can occure due to unfinished synthesis of a template
in-between PCR cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybridsIdentification(dat, min_seq_length = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hybridsIdentification_+3A_dat">dat</code></td>
<td>
<p>a character vector containing barcode sequences or a BCdat object.</p>
</td></tr>
<tr><td><code id="hybridsIdentification_+3A_min_seq_length">min_seq_length</code></td>
<td>
<p>a positive integer value indicating the minimal length of the two barcodes which give rise to a hybrid barcode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a hybrid-free frequency table of barcode sequences
</p>

<hr>
<h2 id='plotClusterGgTree'>Plotting a Cluster ggTree</h2><span id='topic+plotClusterGgTree'></span>

<h3>Description</h3>

<p>Generates a tree plot based on a herachical clustering of the complete distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterGgTree(BC_dat, tree_est = "NJ", type = "rectangular", m = "hamming")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterGgTree_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotClusterGgTree_+3A_tree_est">tree_est</code></td>
<td>
<p>a character string, indicating the particular cluster algorithm, possible algorithms are &quot;Neighbor-Joining&quot; (&quot;NJ&quot;) and &quot;Unweighted Pair Group Method&quot; (&quot;UPGMA&quot;).</p>
</td></tr>
<tr><td><code id="plotClusterGgTree_+3A_type">type</code></td>
<td>
<p>a character string, the graph layout style ('rectangular', 'slanted', 'fan', 'circular', 'radial', 'equal_angle' or 'daylight').</p>
</td></tr>
<tr><td><code id="plotClusterGgTree_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggtree object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(BC_dat)
plotClusterGgTree(BC_dat, tree_est = "UPGMA", type = "circular")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotClusterTree'>Plotting a Cluster Tree</h2><span id='topic+plotClusterTree'></span>

<h3>Description</h3>

<p>Generates a tree plot based on a herachical clustering of the complete distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterTree(
  BC_dat,
  tree_est = "NJ",
  type = "unrooted",
  tipLabel = FALSE,
  m = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterTree_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotClusterTree_+3A_tree_est">tree_est</code></td>
<td>
<p>a character string, indicating the particular cluster algorithm, possible algorithms are &quot;Neighbor-Joining&quot; (&quot;NJ&quot;) and &quot;Unweighted Pair Group Method&quot; (&quot;UPGMA&quot;).</p>
</td></tr>
<tr><td><code id="plotClusterTree_+3A_type">type</code></td>
<td>
<p>a character string, the graph layout style (&quot;unrooted&quot;, &quot;phylogram&quot;, &quot;cladogram&quot;, &quot;fan&quot;, &quot;radial&quot;).</p>
</td></tr>
<tr><td><code id="plotClusterTree_+3A_tiplabel">tipLabel</code></td>
<td>
<p>a logical value, indicating the use of labeled tree leaves.</p>
</td></tr>
<tr><td><code id="plotClusterTree_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>

<hr>
<h2 id='plotDistanceIgraph'>Plotting a Distance Network</h2><span id='topic+plotDistanceIgraph'></span>

<h3>Description</h3>

<p>plotDistanceIgraph will create a graph-like visualisation (ripple plot) of the corresponding barcode sequences
and their similarity based on the igraph package. The nodes represent the barcode sequences and their
respective size reflects the corresponding read counts. Edges between nodes indicate a distance between two barcodes
of maximal <code>minD</code>.
If <code>ori_BCs</code> is provided the node color also refelects the distance of a particular barcode to one of the initial
barcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistanceIgraph(
  BC_dat,
  minDist = 1,
  loga = TRUE,
  ori_BCs = NULL,
  threeD = FALSE,
  complete = FALSE,
  col_type = "rainbow",
  leg_pos = "left",
  inset = -0.125,
  title = "Distance",
  m = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistanceIgraph_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance value for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_loga">loga</code></td>
<td>
<p>a logical value, indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing the barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_threed">threeD</code></td>
<td>
<p>a logical value to chose between 2D and 3D visualisation.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_complete">complete</code></td>
<td>
<p>a logical value. If TRUE, every node will have at least one edge.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_col_type">col_type</code></td>
<td>
<p>a character sting, choosing one of the available color palettes.</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_leg_pos">leg_pos</code></td>
<td>
<p>a character string, containing the position of the legend (e.g. topleft), if NULL no legend will be plotted</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_inset">inset</code></td>
<td>
<p>a numeric value, specifying the distance from the margins as a fraction of the plot region</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_title">title</code></td>
<td>
<p>a character string, containing the legend title</p>
</td></tr>
<tr><td><code id="plotDistanceIgraph_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an igraph object.
</p>

<hr>
<h2 id='plotDistanceVisNetwork'>Plotting a Distance Network</h2><span id='topic+plotDistanceVisNetwork'></span>

<h3>Description</h3>

<p>plotDistanceVisNetwork will create a graph-like visualisation (ripple plot) of the corresponding barcode sequences
and their similarity based on the ggplot2 and the ggnetwork packages. The nodes represent the barcode sequences and their
respective size reflects the corresponding read counts. Edges between nodes indicate a distance between two barcodes
of maximal <code>minDist</code>.
If <code>ori_BCs</code> is provided the node color also refelects the distance of a particular barcode to one of the given
barcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistanceVisNetwork(
  BC_dat,
  minDist = 1,
  loga = TRUE,
  ori_BCs = NULL,
  complete = FALSE,
  col_type = "rainbow",
  m = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistanceVisNetwork_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance value for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_loga">loga</code></td>
<td>
<p>a logical value indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing the barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_complete">complete</code></td>
<td>
<p>a logical value. If TRUE, every node will have at least one edge.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_col_type">col_type</code></td>
<td>
<p>a character sting, choosing one of the available color palettes.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a visNetwork object.
</p>

<hr>
<h2 id='plotDistanceVisNetwork_EC'>Plotting a Distance Network (error correction)</h2><span id='topic+plotDistanceVisNetwork_EC'></span>

<h3>Description</h3>

<p>plotDistanceVisNetwork will create a graph-like visualisation (ripple plot) of the corresponding barcode sequences
and their similarity based on the ggplot2 and the ggnetwork packages. The nodes represent the barcode sequences and their
respective size reflects the corresponding read counts. Edges between nodes indicate a distance between two barcodes
of maximal <code>minDist</code>.
If <code>ori_BCs</code> is provided the effects of the error correction function will be color-coded only for those sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistanceVisNetwork_EC(
  BC_dat,
  BC_dat_EC,
  minDist = 1,
  loga = TRUE,
  equal_node_sizes = TRUE,
  BC_threshold = NULL,
  ori_BCs = NULL,
  complete = FALSE,
  col_type = "rainbow",
  m = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_bc_dat_ec">BC_dat_EC</code></td>
<td>
<p>the corresponding error corrected BCdat object (EC_analysis has to be TRUE)</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_mindist">minDist</code></td>
<td>
<p>an integer value representing the maximal distance value for which the graph will
contain edges.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_loga">loga</code></td>
<td>
<p>a logical value indicating the use or non-use of logarithmic read count values.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_equal_node_sizes">equal_node_sizes</code></td>
<td>
<p>a logical value. If TRUE, every node will have the sames size.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_bc_threshold">BC_threshold</code></td>
<td>
<p>an integer value representing the number of barcodes for which the color-coding should be applied (starting with the barcodes with the most read counts).</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_ori_bcs">ori_BCs</code></td>
<td>
<p>a vector of character strings containing the barcode sequences (without the fixed positions of the barcode construct).</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_complete">complete</code></td>
<td>
<p>a logical value. If TRUE, every node will have at least one edge.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_col_type">col_type</code></td>
<td>
<p>a character sting, choosing one of the available color palettes.</p>
</td></tr>
<tr><td><code id="plotDistanceVisNetwork_EC_+3A_m">m</code></td>
<td>
<p>a character string, Method for distance calculation, default value is Hamming distance. Possible values
are &quot;osa&quot;, &quot;lv&quot;, &quot;dl&quot;, &quot;hamming&quot;, &quot;lcs&quot;, &quot;qgram&quot;, &quot;cosine&quot;, &quot;jaccard&quot;, &quot;jw&quot;, &quot;soundex&quot; (see stringdist function
of the stringdist-package for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a visNetwork object.
</p>

<hr>
<h2 id='plotNucFrequency'>Plotting Nucleotide Frequency</h2><span id='topic+plotNucFrequency'></span>

<h3>Description</h3>

<p>Creates a plot visualising the nucleotide frequency within the entire fastq file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNucFrequency(source_dir, file_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNucFrequency_+3A_source_dir">source_dir</code></td>
<td>
<p>a character string containing the path to the sequencing file.</p>
</td></tr>
<tr><td><code id="plotNucFrequency_+3A_file_name">file_name</code></td>
<td>
<p>a character string containng the name of the sequencing file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>

<hr>
<h2 id='plotQualityScoreDis'>Plotting Quality Score Distribution</h2><span id='topic+plotQualityScoreDis'></span>

<h3>Description</h3>

<p>Creates a plot of the quality values accommodated by the fastq file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQualityScoreDis(source_dir, file_name, type = "median", rel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQualityScoreDis_+3A_source_dir">source_dir</code></td>
<td>
<p>a character string of the path to the source directory.</p>
</td></tr>
<tr><td><code id="plotQualityScoreDis_+3A_file_name">file_name</code></td>
<td>
<p>a character string of the file name.</p>
</td></tr>
<tr><td><code id="plotQualityScoreDis_+3A_type">type</code></td>
<td>
<p>a character string, possible values are &quot;mean&quot; and &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="plotQualityScoreDis_+3A_rel">rel</code></td>
<td>
<p>a logical value. If TRUE the y-axis will show relative frequency instead of the absolut counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

source_dir &lt;- system.file("extdata", package = "genBaRcode")

plotQualityScoreDis(source_dir, file_name = "test_data.fastq", type = "mean")


## End(Not run)
</code></pre>

<hr>
<h2 id='plotQualityScorePerCycle'>Plotting Quality Score per Cycle</h2><span id='topic+plotQualityScorePerCycle'></span>

<h3>Description</h3>

<p>Visualises the mean, median, 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQualityScorePerCycle(source_dir, file_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQualityScorePerCycle_+3A_source_dir">source_dir</code></td>
<td>
<p>a character string containing the path to the sequencing file.</p>
</td></tr>
<tr><td><code id="plotQualityScorePerCycle_+3A_file_name">file_name</code></td>
<td>
<p>a character string containng the name of the sequencing file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>

<hr>
<h2 id='plotReadFrequencies'>Plotting a Barplot</h2><span id='topic+plotReadFrequencies'></span>

<h3>Description</h3>

<p>Generates a barplot visualising the abundances of unique read count frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotReadFrequencies(
  BC_dat,
  b = 30,
  bw = NULL,
  show_it = FALSE,
  log = FALSE,
  dens = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotReadFrequencies_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="plotReadFrequencies_+3A_b">b</code></td>
<td>
<p>an integer value, defining the number of bins. Overridden by bw. Defaults to 30. (see '?ggplot2::geom_histogram')</p>
</td></tr>
<tr><td><code id="plotReadFrequencies_+3A_bw">bw</code></td>
<td>
<p>an integer value, defining the width of the bins.</p>
</td></tr>
<tr><td><code id="plotReadFrequencies_+3A_show_it">show_it</code></td>
<td>
<p>a logical vaue. If TRUE, the respective values are printed on the console?</p>
</td></tr>
<tr><td><code id="plotReadFrequencies_+3A_log">log</code></td>
<td>
<p>a logical vaue. If TRUE, the y-axis will be on a log scale.</p>
</td></tr>
<tr><td><code id="plotReadFrequencies_+3A_dens">dens</code></td>
<td>
<p>a logical vaue. If TRUE, the density of the read frequencies will be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
plotReadFrequencies &lt;- function(BC_dat, b = 10, show_it = TRUE)
</code></pre>

<hr>
<h2 id='plotSeqLogo'>Plots a sequence logo</h2><span id='topic+plotSeqLogo'></span>

<h3>Description</h3>

<p>Plots a sequence logo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSeqLogo(BC_dat, colrs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSeqLogo_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a chatacter vector or BCdat object containing the respective sequences</p>
</td></tr>
<tr><td><code id="plotSeqLogo_+3A_colrs">colrs</code></td>
<td>
<p>a character vector containing the desired colors for the nucleotides A, T, C, G and N (in that order)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='plotTimeSeries'>Plotting Time Series Data</h2><span id='topic+plotTimeSeries'></span>

<h3>Description</h3>

<p>Uses the result of the generateTimeSeriesData function as inout and generates a visualisation of the clonal
contributions over a number of given time points (similar to a stacked barplot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimeSeries(
  ov_dat,
  colr = NULL,
  tp = NULL,
  x_label = "time",
  y_label = "contribution"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeSeries_+3A_ov_dat">ov_dat</code></td>
<td>
<p>a numeric matrix consisting of all time points as columns and all barcode sequences as rows and the corresponding read counts as numerical values (see function <code>generateTimeSeriesData()</code>).</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_colr">colr</code></td>
<td>
<p>a vector of character strings identifying a certain color palette.</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_tp">tp</code></td>
<td>
<p>a numeric vector containing the time points of measurement (in case of unequally distributed time points).</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_x_label">x_label</code></td>
<td>
<p>a character string providing the x-axis label.</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_y_label">y_label</code></td>
<td>
<p>a character string providing the y-axis label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ov_dat &lt;- matrix(round(runif(1:100, min = 0, max = 1000)), ncol = 5)
rownames(ov_dat) &lt;- paste("barcode", 1:20)
plotTimeSeries(ov_dat)
</code></pre>

<hr>
<h2 id='plotVennDiagram'>Plotting a VennDiagram</h2><span id='topic+plotVennDiagram'></span>

<h3>Description</h3>

<p>plotVennDiagramm will create a Venn Diagram ans is based on the VennDiagram package.
It accepts a list of BCdat objects and will return a ggplot2 output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVennDiagram(
  BC_dat,
  alpha_value = 0.4,
  colrs = NA,
  border_color = NA,
  plot_title = "",
  legend_sort = NULL,
  annotationSize = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVennDiagram_+3A_bc_dat">BC_dat</code></td>
<td>
<p>a list of BCdat objects.</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_alpha_value">alpha_value</code></td>
<td>
<p>color transparency value [0-1].</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_colrs">colrs</code></td>
<td>
<p>a character vector containing the desired colors, if NA the colors will be chosen automatically.</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_border_color">border_color</code></td>
<td>
<p>a character value specifying the desired border color, if NA no border will be drawn.</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_plot_title">plot_title</code></td>
<td>
<p>a character value.</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_legend_sort">legend_sort</code></td>
<td>
<p>a character or factor vector in case the order of legend items needs to be changed.</p>
</td></tr>
<tr><td><code id="plotVennDiagram_+3A_annotationsize">annotationSize</code></td>
<td>
<p>an integer value specifying the venn diagramm internal text size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object.
</p>

<hr>
<h2 id='prepareDatObject'>Data Object Preparation</h2><span id='topic+prepareDatObject'></span>

<h3>Description</h3>

<p>generates BCdat object after barcode backbone identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareDatObject(dat, results_dir, label, bc_backbone, min_reads, save_it)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareDatObject_+3A_dat">dat</code></td>
<td>
<p>a tbl_df object (e.g. created by dplyr::count)</p>
</td></tr>
<tr><td><code id="prepareDatObject_+3A_results_dir">results_dir</code></td>
<td>
<p>a character string which contains the path to the results directory.</p>
</td></tr>
<tr><td><code id="prepareDatObject_+3A_label">label</code></td>
<td>
<p>a character string which serves as a label for every kind of created output file.</p>
</td></tr>
<tr><td><code id="prepareDatObject_+3A_bc_backbone">bc_backbone</code></td>
<td>
<p>a character string describing the barcode design, variable positions have to be marked with the letter 'N'.</p>
</td></tr>
<tr><td><code id="prepareDatObject_+3A_min_reads">min_reads</code></td>
<td>
<p>positive integer value, all extracted barcode sequences with a read count smaller than min_reads will be excluded from the results</p>
</td></tr>
<tr><td><code id="prepareDatObject_+3A_save_it">save_it</code></td>
<td>
<p>a logical value. If TRUE, the raw data will be saved as a csv-file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>

<hr>
<h2 id='processingRawData'>Data processing</h2><span id='topic+processingRawData'></span>

<h3>Description</h3>

<p>Reads the corresponding fast(a/q) file(s), extracts the defined barcode constructs and counts them. Optionally,
a Phred-Score based quality filtering will be conducted and the results will be saved within a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processingRawData(
  file_name,
  source_dir,
  results_dir = NULL,
  mismatch = 0,
  indels = FALSE,
  label = "",
  bc_backbone,
  bc_backbone_label = NULL,
  min_score = 30,
  min_reads = 2,
  save_it = TRUE,
  seqLogo = FALSE,
  cpus = 1,
  strategy = "sequential",
  full_output = FALSE,
  wobble_extraction = TRUE,
  dist_measure = "hamming"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processingRawData_+3A_file_name">file_name</code></td>
<td>
<p>a character string or a character vector, containing the file name(s).</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_source_dir">source_dir</code></td>
<td>
<p>a character string which contains the path to the source files.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_results_dir">results_dir</code></td>
<td>
<p>a character string which contains the path to the results directory. If no value is assigned the source_dir will automatically also become the results_dir.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_mismatch">mismatch</code></td>
<td>
<p>an positive integer value, default is 0, if greater values are provided they indicate the number of allowed mismtaches when identifying the barcode constructes.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_indels">indels</code></td>
<td>
<p>a logical value. If TRUE the chosen number of mismatches will be interpreted as edit distance and allow for insertions and deletions as well (currently under construction).</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_label">label</code></td>
<td>
<p>a character string which serves as a label for every kind of created output file.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_bc_backbone">bc_backbone</code></td>
<td>
<p>a character string describing the barcode design, variable positions have to be marked with the letter 'N'. If only a clustering of the sequenced reads should be applied bc_backbone is expecting the string &quot;none&quot; and the mismatch parameter will then be interpreted as maximum dissimilarity for which two reads will be clustered together.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_bc_backbone_label">bc_backbone_label</code></td>
<td>
<p>a character vector, an optional list of barcode backbone names serving as additional identifier within file names and BCdat labels. If not provided ordinary numbers will serve as alternative.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_min_score">min_score</code></td>
<td>
<p>a positive integer value, all fastq sequence with an average score smaller
then min_score will be excluded, if min_score = 0 there will be no quality score filtering</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_min_reads">min_reads</code></td>
<td>
<p>positive integer value, all extracted barcode sequences with a read count smaller than min_reads will be excluded from the results</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_save_it">save_it</code></td>
<td>
<p>a logical value. If TRUE, the raw data will be saved as a csv-file.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_seqlogo">seqLogo</code></td>
<td>
<p>a logical value. If TRUE, the sequence logo of the entire NGS file will be generated and saved.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_cpus">cpus</code></td>
<td>
<p>an integer value, indicating the number of available cpus.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_strategy">strategy</code></td>
<td>
<p>since the future package is used for parallelisation a strategy has to be stated, the default is &quot;sequential&quot;  (cpus = 1) and &quot;multisession&quot; (cpus &gt; 1). For further information please read future::plan() R-Documentation.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_full_output">full_output</code></td>
<td>
<p>a logical value. If TRUE, additional output files will be generated.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_wobble_extraction">wobble_extraction</code></td>
<td>
<p>a logical value. If TRUE, single reads will be stripped of the backbone and only the &quot;wobble&quot; positions will be left.</p>
</td></tr>
<tr><td><code id="processingRawData_+3A_dist_measure">dist_measure</code></td>
<td>
<p>a character value. If &quot;bc_backbone = 'none'&quot;, single reads will be clustered based on a distance measure.
Available distance methods are Optimal string aligment (&quot;osa&quot;), Levenshtein (&quot;lv&quot;), Damerau-Levenshtein (&quot;dl&quot;), Hamming (&quot;hamming&quot;), Longest common substring (&quot;lcs&quot;), q-gram (&quot;qgram&quot;), cosine (&quot;cosine&quot;), Jaccard (&quot;jaccard&quot;), Jaro-Winkler (&quot;jw&quot;),
distance based on soundex encoding (&quot;soundex&quot;). For more detailed information see stringdist function of the stringdist-package for more information)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object which will include read counts, barcode sequences, the results directory and the search barcode backbone.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bc_backbone &lt;- "ACTNNCGANNCTTNNCGANNCTTNNGGANNCTANNACTNNCGANNCTTNNCGANNCTTNNGGANNCTANNACTNNCGANN"

source_dir &lt;- system.file("extdata", package = "genBaRcode")

BC_dat &lt;- processingRawData(file_name = "test_data.fastq.gz", source_dir,
          results_dir = "/my/test/directory/", mismatch = 2, label = "test", bc_backbone,
          min_score = 30, indels = FALSE, min_reads = 2, save_it = FALSE, seqLogo = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='qualityFiltering'>Quality Filtering</h2><span id='topic+qualityFiltering'></span>

<h3>Description</h3>

<p>Excludes all sequences of a given fastq file below a certain quality value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualityFiltering(file_name, source_dir, min_score = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qualityFiltering_+3A_file_name">file_name</code></td>
<td>
<p>a character string containing the name of the source file.</p>
</td></tr>
<tr><td><code id="qualityFiltering_+3A_source_dir">source_dir</code></td>
<td>
<p>a character string containing the path to the source directory.</p>
</td></tr>
<tr><td><code id="qualityFiltering_+3A_min_score">min_score</code></td>
<td>
<p>an integer value representing the minimal average phred score a read has to achieve in order to be accepted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ShortRead object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
source_dir &lt;- system.file("extdata", package = "genBaRcode")
qualityFiltering(file_name = "test_data.fastq.gz", source_dir,
results_dir = getwd(), min_score = 30)

## End(Not run)
</code></pre>

<hr>
<h2 id='readBCdat'>Data Input</h2><span id='topic+readBCdat'></span>

<h3>Description</h3>

<p>Reads a data table (csv-file) and returns a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBCdat(path, label = "", BC_backbone = "", file_name, s = ";")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readBCdat_+3A_path">path</code></td>
<td>
<p>a character string containing the path to a saved read count table (two columns containing read counts and barcode
sequences).</p>
</td></tr>
<tr><td><code id="readBCdat_+3A_label">label</code></td>
<td>
<p>a character string containing a label of the data set.</p>
</td></tr>
<tr><td><code id="readBCdat_+3A_bc_backbone">BC_backbone</code></td>
<td>
<p>a character string containing the barcode structure information.</p>
</td></tr>
<tr><td><code id="readBCdat_+3A_file_name">file_name</code></td>
<td>
<p>a character string containing the name of the file to read in.</p>
</td></tr>
<tr><td><code id="readBCdat_+3A_s">s</code></td>
<td>
<p>a character value, identifying the column separating char.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>

<hr>
<h2 id='setBackbone'>Replacing the Barcode Backbone slot of a BCdat objects.</h2><span id='topic+setBackbone'></span>

<h3>Description</h3>

<p>Replacing the Barcode Backbone slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBackbone(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setBackbone_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="setBackbone_+3A_value">value</code></td>
<td>
<p>a character string consisting of exclusively IUPAC-nucleotide-code conform letters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
new_backbone &lt;- getBackboneSelection("BC32-T-Sapphire")
BC_dat_new &lt;- setBackbone(BC_dat, new_backbone)

</code></pre>

<hr>
<h2 id='setLabel'>Replacing the Label slot of a BCdat objects.</h2><span id='topic+setLabel'></span>

<h3>Description</h3>

<p>Replacing the Label slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setLabel(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setLabel_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="setLabel_+3A_value">value</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
new_label &lt;- "foo-bar"
BC_dat_new &lt;- setLabel(BC_dat, new_label)

</code></pre>

<hr>
<h2 id='setReads'>Replacing the Read-Count slot of a BCdat objects.</h2><span id='topic+setReads'></span>

<h3>Description</h3>

<p>Replacing the Read-Count slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setReads(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setReads_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="setReads_+3A_value">value</code></td>
<td>
<p>a data.frame caontaining two columns called &quot;read_count&quot; and &quot;barcode&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
require("dplyr")

bcs &lt;- unlist(lapply(1:20, function(x) {
           c("A", "C", "T", "G") %&gt;% sample(replace = TRUE, size = 32) %&gt;% paste0(collapse = "")
       }))
new_read_count_table &lt;- data.frame(read_count = sample(1:1000, size = 20), barcode = bcs)
BC_dat_new &lt;- setReads(BC_dat, new_read_count_table)

</code></pre>

<hr>
<h2 id='setResultsDir'>Replacing the Results Directory slot of a BCdat objects.</h2><span id='topic+setResultsDir'></span>

<h3>Description</h3>

<p>Replacing the Results Directory slot of a BCdat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setResultsDir(object, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setResultsDir_+3A_object">object</code></td>
<td>
<p>a BCdat object.</p>
</td></tr>
<tr><td><code id="setResultsDir_+3A_value">value</code></td>
<td>
<p>a character string of an existing path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a BCdat object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BC_dat)
new_path &lt;- getwd()
BC_dat_new &lt;- setResultsDir(BC_dat, new_path)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
