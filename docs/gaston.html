<!DOCTYPE html><html><head><title>Help for package gaston</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gaston}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AGT'><p>AGT data set</p></a></li>
<li><a href='#as.bed.matrix'><p> Creation of a bed.matrix</p></a></li>
<li><a href='#association.test'><p> Association Test</p></a></li>
<li><a href='#bed.loadings'><p> SNP loadings</p></a></li>
<li><a href='#bed.matrix-class'><p>Class <code>"bed.matrix"</code></p></a></li>
<li><a href='#DM'><p>Dominance Matrix</p></a></li>
<li><a href='#dupli'><p>Small data set to illustrate <code>SNP.rm.duplicates</code></p></a></li>
<li><a href='#gaston-package'><p> gaston</p></a></li>
<li><a href='#GRM'><p> Genetic Relationship Matrix</p></a></li>
<li><a href='#is.autosome'><p> Autosomes and X, Y, MT chromosomes</p></a></li>
<li><a href='#LCT'><p>LCT data set</p></a></li>
<li><a href='#LD'><p> Linkage Disequilibrium</p></a></li>
<li><a href='#LD.clump'><p> LD clumping</p></a></li>
<li><a href='#LD.plot'><p> Plot Linkage Disequilibrium</p></a></li>
<li><a href='#LD.thin'><p> LD thinning</p></a></li>
<li><a href='#lik.contour'><p> Contour plot for two parameters likelihood</p></a></li>
<li><a href='#lmm.aireml'><p> Linear mixed model fitting with AIREML</p></a></li>
<li><a href='#lmm.diago'><p> Linear mixed model fitting with the diagonalization trick</p></a></li>
<li><a href='#lmm.diago.likelihood'><p> Likelihood of a linear mixed model</p></a></li>
<li><a href='#lmm.restricted.likelihood'><p> Likelihood of a linear mixed model</p></a></li>
<li><a href='#lmm.simu'><p> Linear mixed model data simulation</p></a></li>
<li><a href='#logistic.mm.aireml'><p> Logistic mixed model fitting with Penalized Quasi-Likelihood / AIREML</p></a></li>
<li><a href='#manhattan'><p> Manhattan plot</p></a></li>
<li><a href='#qqplot.pvalues'><p> QQ plot of p-values</p></a></li>
<li><a href='#random.pm'><p> Random square definite positive matrix</p></a></li>
<li><a href='#read.bed.matrix'><p> Read a <code>bed.matrix</code></p></a></li>
<li><a href='#read.vcf'><p> Create a <code>bed.matrix</code> from VCF files</p></a></li>
<li><a href='#reshape.GRM'><p> Reshape a Genetic Relationship Matrix</p></a></li>
<li><a href='#score.fixed.linear/score.fixed.logistic'><p> Score Test for Covariates with Fixed Effects in Linear or Logistic Mixed Model</p></a></li>
<li><a href='#score.variance.linear/score.variance.logistic'><p> Variance Component Test in Linear or Logistic Mixed Model</p></a></li>
<li><a href='#select.inds'><p> Subsetting from a <code>bed.matrix</code></p></a></li>
<li><a href='#select.snps'><p> Subsetting from a <code>bed.matrix</code></p></a></li>
<li><a href='#set.dist'><p> Set Genetic Distance</p></a></li>
<li><a href='#set.genomic.sex'><p> Genomic Sex</p></a></li>
<li><a href='#set.hwe'><p> Hardy-Weinberg Equilibrium</p></a></li>
<li><a href='#set.stats'><p> Basic statistics for a <code>bed.matrix</code></p></a></li>
<li><a href='#SNP.duplicated'><p> Duplicated SNPs</p></a></li>
<li><a href='#SNP.match'><p> SNP matching</p></a></li>
<li><a href='#SNP.rm.duplicates'><p> Remove duplicated SNPs</p></a></li>
<li><a href='#Tests'><p> Evaluation of a condition on SNPS or individuals in a <code>bed.matrix</code></p></a></li>
<li><a href='#TTN'><p>TTN data set</p></a></li>
<li><a href='#write.bed.matrix'><p> Save a <code>bed.matrix</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Data Handling (QC, GRM, LD, PCA) &amp; Linear Mixed Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-06</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Manipulation of genetic data (SNPs). Computation of GRM and dominance matrix, LD, heritability with efficient algorithms for linear mixed model (AIREML). Dandine et al &lt;<a href="https://doi.org/10.1159%2F000488519">doi:10.1159/000488519</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, RcppEigen</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp, RcppParallel, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 07:41:21 UTC; rv</td>
</tr>
<tr>
<td>Author:</td>
<td>Hervé Perdry [cre, aut, cph],
  Claire Dandine-Roulland [aut, cph],
  Deepak Bandyopadhyay [cph] (C++ gzstream class),
  Lutz Kettner [cph] (C++ gzstream class)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hervé Perdry &lt;herve.perdry@universite-paris-saclay.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AGT'>AGT data set</h2><span id='topic+AGT'></span><span id='topic+AGT.gen'></span><span id='topic+AGT.fam'></span><span id='topic+AGT.bim'></span><span id='topic+AGT.pop'></span>

<h3>Description</h3>

<p>These data have been extracted from the 1000 Genomes data.
The data set contains the genotype matrix <code>AGT.gen</code>, the pedigree matrix <code>AGT.fam</code> and a matrix <code>AGT.bim</code>,
corresponding to 503 individuals of European populations and 361 SNPs on chromosome 1, on a ~100kb segment 
containing the Angiotensinogen gene. There is also a factor <code>AGT.pop</code>, which gives the population from which each
individual is drawn (CEU = Utah residents of Northern Western European ancestry, FIN = Finnish, GBR = England and Scottland, 
IBS = Iberian, TSI = Toscani).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(AGT) </code></pre>


<h3>Format</h3>

<p>There are three data objects in the dataset:
</p>

<dl>
<dt><code>AGT.gen</code></dt><dd><p> Genotype matrix </p>
</dd>
<dt><code>AGT.fam</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.fam</code> file  </p>
</dd>
<dt><code>AGT.bim</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.bim</code> file </p>
</dd>
<dt><code>AGT.pop</code></dt><dd><p> Factor giving the population from which each individual is drawn </p>
</dd>
</dl>



<h3>Source</h3>

<p> The data were obtained from the 1000 Genomes project (see <a href="https://www.internationalgenome.org/">https://www.internationalgenome.org/</a>). </p>


<h3>References</h3>

<p>McVean et al, 2012, <em>An integrated map of genetic variation from 1,092 human genomes</em>, Nature <b>491, 56-65</b> doi:10.1038/nature11632 </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)
x
</code></pre>

<hr>
<h2 id='as.bed.matrix'> Creation of a bed.matrix </h2><span id='topic+as.bed.matrix'></span>

<h3>Description</h3>

<p> Creates a bed.matrix using a numeric matrix and two data frame for ped / snps slots </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
as.bed.matrix(x, fam, bim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.bed.matrix_+3A_x">x</code></td>
<td>
<p> A numeric matrix </p>
</td></tr>
<tr><td><code id="as.bed.matrix_+3A_fam">fam</code></td>
<td>
<p> (Optionnal) A data frame (the contents of a .fam file) </p>
</td></tr>
<tr><td><code id="as.bed.matrix_+3A_bim">bim</code></td>
<td>
<p> (Optionnal) A data frame (the contents of a .bim file) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame <code>fam</code> should have columns named &quot;famid&quot;, &quot;id&quot;, &quot;father&quot;, &quot;mother&quot;, &quot;sex&quot; and &quot;pheno&quot;.
The data frame <code>bim</code> should have columns named &quot;chr&quot;, &quot;id&quot;, &quot;dist&quot;, &quot;pos&quot;, &quot;A1&quot; and &quot;A2&quot;. 
</p>


<h3>Value</h3>

<p>A bed.matrix condensing all three arguments.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bed.matrix-class">bed.matrix-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)
x
</code></pre>

<hr>
<h2 id='association.test'> Association Test </h2><span id='topic+association.test'></span>

<h3>Description</h3>

<p> Association tests between phenotype and SNPs. </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
association.test(x, Y = x@ped$pheno, X = matrix(1, nrow(x)),
                 method = c("lm", "lmm"), response = c("quantitative", "binary"), 
                 test = c("score", "wald", "lrt"), K, eigenK, beg = 1, 
                 end = ncol(x), p = 0, tol = .Machine$double.eps^0.25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="association.test_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="association.test_+3A_y">Y</code></td>
<td>
<p> The phenotype vector. Default is the column (<code>pheno</code>) of <code>x@ped</code> </p>
</td></tr>
<tr><td><code id="association.test_+3A_x">X</code></td>
<td>
<p> A covariable matrix. The default is a column vector of ones, to include an intercept in the model </p>
</td></tr>
<tr><td><code id="association.test_+3A_method">method</code></td>
<td>
<p> Method to use: <code>"lm"</code> for (generalized) linear model, and <code>"lmm"</code> for (generalized) linear mixed model </p>
</td></tr>
<tr><td><code id="association.test_+3A_response">response</code></td>
<td>
<p> Is <code>"Y"</code> a quantitative or a binary phenotype?</p>
</td></tr>
<tr><td><code id="association.test_+3A_test">test</code></td>
<td>
<p> Which test to use. For binary phenotypes, <code>test = "score"</code> is mandatory</p>
</td></tr>
<tr><td><code id="association.test_+3A_k">K</code></td>
<td>
<p> A Genetic Relationship Matrix (as produced by <code><a href="#topic+GRM">GRM</a></code>), or a list of such matrices. For <code>test = "score"</code>. </p>
</td></tr>
<tr><td><code id="association.test_+3A_eigenk">eigenK</code></td>
<td>
<p> Eigen decomposition of the Genetic Relationship Matrix (as produced by the function <code>eigen</code>). 
For <code>test = "wald"</code> or <code>"lrt"</code>. </p>
</td></tr>
<tr><td><code id="association.test_+3A_beg">beg</code></td>
<td>
<p> Index of the first SNP tested for association </p>
</td></tr>
<tr><td><code id="association.test_+3A_end">end</code></td>
<td>
<p> Index of the last SNP tested for association </p>
</td></tr>
<tr><td><code id="association.test_+3A_p">p</code></td>
<td>
<p> Number of Principal Components to include in the model with fixed effect (for <code>test = "wald"</code> or <code>"lrt"</code>) </p>
</td></tr>
<tr><td><code id="association.test_+3A_tol">tol</code></td>
<td>
<p> Parameter for the likelihood maximization (as in <code>optimize</code>) </p>
</td></tr>
<tr><td><code id="association.test_+3A_...">...</code></td>
<td>
<p> Additional parameters for <code><a href="#topic+lmm.aireml">lmm.aireml</a></code> or <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code> (if <code>test = "score"</code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests the association between the phenotype and requested SNPs in <code>x</code>.
</p>
<p>If <code>method = "lm"</code> and <code>response = "quantitative"</code> are used, a simple linear regression 
is performed to test each SNP in the considered interval. Precisely, the following model is
considered for each SNP,
</p>
<p style="text-align: center;"><code class="reqn"> Y = (X|PC)\alpha + G\beta + \varepsilon </code>
</p>

<p>with <code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>,
<code class="reqn">G</code> the genotype vector of the SNP, 
<code class="reqn">X</code> the covariates matrix, and <code class="reqn">PC</code> the matrix of the first <code class="reqn">p</code> principal components.
A Wald test is performed, independently of the value of <code>test</code>.
</p>
<p>If<code>method = "lm"</code> and <code>response = "binary"</code>, a similar model is used for a logistic 
regression (Wald test).
</p>
<p>If <code>method = "lmm"</code> and <code>response = "quantitative"</code>, the following model in considered for each SNP
</p>
<p style="text-align: center;"><code class="reqn"> Y = (X|PC)\alpha + G\beta + \omega + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega \sim N(0,\tau K) </code> and <code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
<code class="reqn">G</code> is the genotype vector of the SNP, <code class="reqn">K</code> is a Genetic Relationship Matrix (GRM)
<code class="reqn">X</code> the covariates matrix, and <code class="reqn">PC</code> the matrix of the first <code class="reqn">p</code> principal components.
</p>
<p>If <code>test = "score"</code>, all parameters are estimated with the same procedure as in 
<code><a href="#topic+lmm.aireml">lmm.aireml</a></code> and the argument <code>K</code> is used to specify the GRM matrix (or a list of GRM
matrices for inclusion of several random effects in the model). If <code>p</code> is positive, the paramater <code>eigenK</code>
needs to be given as well.
For Wald and LRT tests the procedure used is the same as in <code><a href="#topic+lmm.diago">lmm.diago</a></code> and <code>eigenK</code> is used to 
specify the GRM matrix.
</p>
<p>If <code>method = "lmm"</code> and <code>response = "binary"</code>, the following model in considered for each SNP
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit}(P[Y=1| X, G, \omega])  = X\alpha + G\beta + \omega</code>
</p>

<p>with <code class="reqn"> \omega \sim N(0,\tau K) </code>. 
<code class="reqn">G</code> is the genotype vector of the SNP, <code class="reqn">K</code> is a Genetic Relationship Matrix (GRM),
<code class="reqn">X</code> the covariable matrix. A score test is performed, independently of the value of <code>test</code>.
All parameters under null model are estimated with the same procedure as in <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code>.
In case of convergence problems of the null problem, the user can try several starting values (in particular
with parameter <code>tau</code>, trying e.g. <code>tau = 0.1</code> or another value).
It is possible to give a list of matrices in parameter <code>K</code> for inclusion of several random effects in the model.
If <code>p</code> is positive, the paramater <code>eigenK</code> needs to be given as well.
</p>
<p>Note: this function is not multithreaded. Wald test with Linear Mixed Models are computationally intensive, 
to run a GWAS with such tests consider using <code>association.test.parallel</code> in package <code>gaston.utils</code> 
(on github). Association tests with dosages can be done with <code>association.test.dosage</code> and 
<code>association.test.dosage.parallel</code> in the same package.
</p>


<h3>Value</h3>

<p>A data frame, giving for each considered SNP, its position, id, alleles, and 
some of the following columns depending on the values of <code>method</code> and <code>test</code>:
</p>
<table>
<tr><td><code>score</code></td>
<td>
<p>Score statistic for each SNP</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>Estimated value of <code class="reqn">\tau \over {\tau + \sigma^2}</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Estimated value of <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Estimated standard deviation of the <code class="reqn">\beta</code> estimation</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>Value of the Likelihood Ratio Test</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The corresponding p-value</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+qqplot.pvalues">qqplot.pvalues</a></code>, <code><a href="#topic+manhattan">manhattan</a></code>,  <code><a href="#topic+lmm.diago">lmm.diago</a></code>,  
<code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code>, <code><a href="stats.html#topic+optimize">optimize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data(TTN)
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)
standardize(x) &lt;- "p"

# simulate quantitative phenotype with effect of SNP #631
set.seed(1)
y &lt;- x %*% c(rep(0,630),0.5,rep(0,ncol(x)-631)) + rnorm(nrow(x))

# association test with linear model 
test &lt;- association.test(x, y, method="lm", response = "quanti")

# a p-values qq plot
qqplot.pvalues(test)

# a small Manhattan plot 
# hihlighting the link between p-values and LD with SNP #631
lds &lt;- LD(x, 631, c(1,ncol(x)))
manhattan(test, col = rgb(lds,0,0), pch = 20)

# use y to simulate a binary phenotype
y1 &lt;- as.numeric(y &gt; mean(y))

# logistic regression
t_binary &lt;- association.test(x, y1, method = "lm", response = "binary")
# another small Manhattan plot
manhattan(t_binary, col = rgb(lds,0,0), pch = 20)

</code></pre>

<hr>
<h2 id='bed.loadings'> SNP loadings </h2><span id='topic+bed.loadings'></span>

<h3>Description</h3>

<p> Compute the loadings corresponding to given PCs. </p>


<h3>Usage</h3>

<pre><code class='language-R'> bed.loadings(x, pc) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed.loadings_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="bed.loadings_+3A_pc">pc</code></td>
<td>
<p> A matrix with Principal Components in columns </p>
</td></tr>
</table>


<h3>Value</h3>

<p> A matrix with the corresponding loadings in columns. </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>Examples</h3>

<pre><code class='language-R'># load chr2 data set (~10k SNPs in low LD)
x &lt;- read.bed.matrix( system.file("extdata", "chr2.bed", package="gaston") )

# Compute Genetic Relationship Matrix
standardize(x) &lt;- "p"
K &lt;- GRM(x)

# Eigen decomposition
eiK &lt;- eigen(K)
# deal with small negative eigen values
eiK$values[ eiK$values &lt; 0 ] &lt;- 0

# Note: the eigenvectors are normalized, to compute 'true' PCs
# multiply them by the square root of the associated eigenvalues
PC &lt;- sweep(eiK$vectors, 2, sqrt(eiK$values), "*")

# Compute loadings for the 2 first PCs 
# one can use PC[,1:2] instead of eiK$vectors[,1:2] as well
L &lt;- bed.loadings(x, eiK$vectors[,1:2])
dim(L)
head(L)

# the loadings are normalized
colSums(L**2)

# Verify that these are loadings
head( (x %*% L) / sqrt(ncol(x)-1) )
head( PC[,1:2] )

</code></pre>

<hr>
<h2 id='bed.matrix-class'>Class <code>"bed.matrix"</code></h2><span id='topic+bed.matrix-class'></span><span id='topic+bed.matrix'></span><span id='topic++5B+2Cbed.matrix+2Clogical+2Clogical+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Clogical+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Clogical+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Cmissing+2Clogical+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Cnumeric+2Clogical+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cbed.matrix+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic++25+2A+25+2Cbed.matrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2Cbed.matrix-method'></span><span id='topic++25+2A+25+2Cbed.matrix+2Cvector-method'></span><span id='topic++25+2A+25+2Cvector+2Cbed.matrix-method'></span><span id='topic+as.matrix+2Cbed.matrix-method'></span><span id='topic+matrix+2Cdata.frameOrNULL+2Cdata.frameOrNULL-method'></span><span id='topic+standardize'></span><span id='topic+standardize+2Cbed.matrix-method'></span><span id='topic+standardize+3C-'></span><span id='topic+standardize+3C-+2Cbed.matrix-method'></span><span id='topic+coerce+2Cbed.matrix+2Cmatrix-method'></span><span id='topic+coerce+2Cmatrix+2Cbed.matrix-method'></span><span id='topic+coerce+2Cbed.matrix+2Cvector-method'></span><span id='topic+coerce+2Cvector+2Cbed.matrix-method'></span><span id='topic+dim+2Cbed.matrix-method'></span><span id='topic+head+2Cbed.matrix-method'></span><span id='topic+mu'></span><span id='topic+mu+2Cbed.matrix-method'></span><span id='topic+mu+3C-'></span><span id='topic+mu+3C-+2Cbed.matrix-method'></span><span id='topic+p'></span><span id='topic+p+2Cbed.matrix-method'></span><span id='topic+p+3C-'></span><span id='topic+p+3C-+2Cbed.matrix-method'></span><span id='topic+show+2Cbed.matrix-method'></span><span id='topic+sigma'></span><span id='topic+sigma+2Cbed.matrix-method'></span><span id='topic+sigma+3C-'></span><span id='topic+sigma+3C-+2Cbed.matrix-method'></span><span id='topic+rbind'></span><span id='topic+rbind+2Cbed.matrix-method'></span><span id='topic+cbind'></span><span id='topic+cbind+2Cbed.matrix-method'></span>

<h3>Description</h3>

<p> S4 class for SNP genotype matrices </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("bed.matrix", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ped</code>:</dt><dd> <p><code>data.frame</code> containing information for each individual: <code>famid</code> = Family ID, 
<code>id</code> = Individual ID, <code>father</code> = Father ID, <code>mother</code> = Mother ID, <code>sex</code> = Sex and <code>pheno</code> = Phenotype. 
Can also contain individuals statistic, for example: <code>N0</code>, <code>N1</code> and <code>N2</code> = Number of genotypes equal to 0, 1 and 2 respectively, 
<code>NAs</code> = Number of missing genotypes, <code>callrate</code> = Individual callrate.</p>
</dd>
<dt><code>snps</code>:</dt><dd> <p><code>data.frame</code> containing information for each SNP: <code>chr</code> = Chromosome, <code>id</code> = SNP ID,
<code>dist</code> = Genetic Distance, <code>pos</code> = Physical position, <code>A1</code> = Reference Allele, <code>A2</code> = Alternative Allele.
Can also contain SNPs statistic, for example: <code>N0</code>, <code>N1</code> and <code>N2</code> = Number of genotypes equal to 0, 1 and 2 repectively,
<code>NAs</code> = Number of missing genotypes, <code>callrate</code> = SNP callrate, <code>maf</code> = Minor allele frequency), <code>hz</code> = heterozygosity</p>
</dd>
<dt><code>bed</code>:</dt><dd> <p><code>externalptr</code> (pointing to the genotype matrix). </p>
</dd>
<dt><code>p</code>:</dt><dd> <p><code>vector</code> or <code>NULL</code> for allelic frequencies (allèle <code>A2</code>).</p>
</dd>
<dt><code>mu</code>:</dt><dd> <p><code>vector</code> or <code>NULL</code> for genotype means (usually <code>mu = 2*p</code>).</p>
</dd>
<dt><code>sigma</code>:</dt><dd> <p><code>vector</code> or <code>NULL</code> for genotypic standard deviation</p>
</dd>
<dt><code>standardize_p</code>:</dt><dd> <p><code>logical</code>. If <code>TRUE</code>, the genotype matrix is standardized using means <code>2*p</code> 
and genotypic standard deviation <code>sqrt(2*p*(1-p))</code></p>
</dd>
<dt><code>standardize_mu_sigma</code>:</dt><dd> <p><code>logical</code>. If <code>TRUE</code>, the genotype matrix is standardize using means
<code>mu</code> and genotypic standard deviation <code>sigma</code>.</p>
</dd>
</dl>

<p>For more details please check the vignette.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "bed.matrix", i = "numeric" or "logical" or "missing",</code><br /><code>j = "numeric" or "logical" or "missing", drop = "missing")</code>: 
<br /> Extract a sub-matrix (a new <code>bed.matrix</code>). </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "bed.matrix", y = "matrix" or "vector")</code>: 
<br /> Right matrix multiplication of the genotype matrix (possibly centered and reduced) with a <code>matrix</code> or a <code>vector</code>. </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix" or "vector", y = "bed.matrix")</code>: 
<br /> Left matrix multiplication of the genotype matrix with a <code>matrix</code> or a <code>vector</code>. </p>
</dd>
<dt>as.matrix</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Convert a <code>bed.matrix</code> into a <code>matrix</code>.
The resulting matrix can be huge, use this method only for a small bed.matrix! </p>
</dd>
<dt>standardize</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Get the standardize parameter of <code>bed.matrix</code>. Can be &quot;none&quot;, &quot;p&quot; or &quot;mu_sigma&quot;. </p>
</dd>
<dt>standardize&lt;-</dt><dd><p><code>signature(x = "bed.matrix")</code>:
<br /> Set the standardize parameter of a <code>bed.matrix</code>. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Get the number of individuals (rows) and the number of SNPs (columns). </p>
</dd>
<dt>head</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Print the head of the genotype matrix of a <code>bed.matrix</code> object. </p>
</dd>
<dt>mu</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Get the <code>mu</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>mu&lt;-</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Set the <code>mu</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>p</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Get the <code>p</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>p&lt;-</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Set the <code>p</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "bed.matrix")</code>: 
<br /> Displays basic information about a <code>bed.matrix</code>. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Get the <code>sigma</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>sigma&lt;-</dt><dd><p><code>signature(x = "bed.matrix")</code>: 
<br /> Set the <code>sigma</code> slot of a <code>bed.matrix</code>. </p>
</dd>
<dt>cbind</dt><dd><p><code>signature(... = "bed.matrix")</code>: 
<br /> Combine a sequence of <code>bed.matrix</code> by columns. </p>
</dd>
<dt>rbind</dt><dd><p><code>signature(... = "bed.matrix")</code>: 
<br /> Combine a sequence of <code>bed.matrix</code> by rows. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.bed.matrix">read.bed.matrix</a></code>, <code><a href="#topic+write.bed.matrix">write.bed.matrix</a></code>,
<code><a href="#topic+set.stats">set.stats</a></code>, <code><a href="#topic+select.snps">select.snps</a></code>, <code><a href="#topic+select.inds">select.inds</a></code>, <code><a href="#topic+GRM">GRM</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("bed.matrix")

# Conversion example
data(LCT)
x1 &lt;- as(LCT.gen, "bed.matrix")
x1
head(x1@ped)
head(x1@snps)

# the function as.bed.matrix is an alternative
x2 &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)
x2
head(x2@ped)
head(x2@snps)
</code></pre>

<hr>
<h2 id='DM'>Dominance Matrix</h2><span id='topic+DM'></span>

<h3>Description</h3>

<p>Compute the Dominance Matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'> DM(x, which.snps, autosome.only = TRUE, chunk = 1L) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DM_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="DM_+3A_which.snps">which.snps</code></td>
<td>
<p> Logical vector, giving which snps to use in the computation.  The default is to use all autosomal SNPs</p>
</td></tr>
<tr><td><code id="DM_+3A_autosome.only">autosome.only</code></td>
<td>
<p> If <code>TRUE</code>, only autosomal SNPs will be considered. </p>
</td></tr>
<tr><td><code id="DM_+3A_chunk">chunk</code></td>
<td>
<p> Parameter for the parallelization: how many SNPs are treated by each task</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dominance Matrix (DM) gives for each pair of individuals an estimation of 
their probability of sharing two alleles Identical By Descent. 
</p>
<p>It is computed by a moment estimator,
<code class="reqn">{1\over q} ZZ'</code> with <code class="reqn">Z</code> the matrix with entries
<code class="reqn">p \over 1-p</code>, <code class="reqn">-1</code>, <code class="reqn">1-p \over p</code> according to the
values 0, 1, 2 in the genotype matrix <code>x</code> (here <code class="reqn">p</code> is the
frequency of the alternate allele, and <code class="reqn">q</code> is the number of SNPs
(<code>ncol(x)</code>).
</p>


<h3>Value</h3>

<p> A symmetric square matrix of dimension equal to the number of individuals.
Each entry can be interpreted as an estimated probability of sharing two alleles IBD 
— as it is a moment estimator, the value can (and will) fall outside of the range (0,1). </p>


<h3>See Also</h3>

 <p><code><a href="#topic+GRM">GRM</a></code>, <code><a href="#topic+reshape.GRM">reshape.GRM</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># load chr2 data set (~10k SNPs in low LD)
x &lt;- read.bed.matrix( system.file("extdata", "chr2.bed", package="gaston") )

# Compute Dominance Matrix
D &lt;- DM(x)
dim(D)

</code></pre>

<hr>
<h2 id='dupli'>Small data set to illustrate <code><a href="#topic+SNP.rm.duplicates">SNP.rm.duplicates</a></code></h2><span id='topic+dupli'></span><span id='topic+dupli.gen'></span><span id='topic+dupli.ped'></span><span id='topic+dupli.bim'></span><span id='topic+dupli.pop'></span>

<h3>Description</h3>

<p>The SNPs in this data frame are as follows:
</p>

<dl>
<dt>SNP 1.</dt><dd><p> Unduplicated SNP </p>
</dd>
<dt>SNPs 2a and 2b.</dt><dd><p> Two duplicated SNPs with identical alleles </p>
</dd>
<dt>SNPs 3a and 3b.</dt><dd><p> Two duplicated SNPs with swapped alleles </p>
</dd>
<dt>SNPs 4a and 4b.</dt><dd><p> Two duplicated SNPs with flipped reference strand </p>
</dd>
<dt>SNPs 5a and 5b.</dt><dd><p> Two duplicated SNPs with swapped alleles and flipped reference strand </p>
</dd>
<dt>SNPs 6a and 6b.</dt><dd><p> Two duplicated SNPs with incompatible alleles </p>
</dd>
<dt>SNPs 7a and 7b.</dt><dd><p> Two duplicated SNPs including one monomorphic SNP (one allele set to <code>"0"</code>) </p>
</dd>
<dt>SNPs 8a, 8b and 8c.</dt><dd><p> Three duplicated SNPs </p>
</dd>
<dt>SNPs 9a, 9b and 9c.</dt><dd><p> Three duplicated SNPs with incompatible alleles </p>
</dd>
</dl>


<h3>Usage</h3>

<pre><code class='language-R'> data(dupli) </code></pre>


<h3>Format</h3>

<p>There are three data objects in the dataset:
</p>

<dl>
<dt><code>dupli.gen</code></dt><dd><p> Genotype matrix </p>
</dd>
<dt><code>dupli.ped</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.fam</code> file  </p>
</dd>
<dt><code>dupli.bim</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.bim</code> file </p>
</dd>
</dl>



<h3>See Also</h3>

 <p><code><a href="#topic+SNP.rm.duplicates">SNP.rm.duplicates</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dupli)
x &lt;- as.bed.matrix(dupli.gen, fam = dupli.ped, bim = dupli.bim)
</code></pre>

<hr>
<h2 id='gaston-package'> gaston </h2><span id='topic+gaston-package'></span><span id='topic+gaston'></span>

<h3>Description</h3>

<p>Manipulation of genetic data (SNPs), computation of Genetic Relationship Matrix, Linkage Disequilibrium, etc. 
Efficient algorithms for Linear Mixed Model (AIREML, diagonalisation trick).</p>


<h3>Introducing gaston</h3>

<p>Gaston offers functions for efficient manipulation of 
large genotype (SNP) matrices, and state-of-the-art implementation of algorithms
to fit Linear Mixed Models, that can be used to compute heritability 
estimates or to perform association tests.
</p>
<p>Thanks to the packages <code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code>, 
<code><a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a></code>,
<code><a href="RcppEigen.html#topic+RcppEigen-package">RcppEigen</a></code>, gaston 
functions are mainly written in C++. 
</p>
<p>Many functions are multithreaded;
the number of threads can be setted through <code>RcppParallel</code>
function <code><a href="RcppParallel.html#topic+setThreadOptions">setThreadOptions</a></code>.
It is advised to try several values for the number of threads, as 
using too many threads might be conterproductive due to an important
overhead.
</p>
<p>Some functions have a <code>verbose</code> argument, which controls the
function verbosity. To mute all functions at once you can use 
<code>options(gaston.verbose = FALSE)</code>.
</p>


<h3>Genotype matrices</h3>

<p>An S4 class for genotype matrices is defined, named <code><a href="#topic+bed.matrix">bed.matrix</a></code>.
Each row corresponds to an individual, and each column to a SNP. They can
be read from files using <code><a href="#topic+read.bed.matrix">read.bed.matrix</a></code> 
and saved using <code><a href="#topic+write.bed.matrix">write.bed.matrix</a></code>.  The function <code><a href="#topic+read.vcf">read.vcf</a></code> reads
VCF files.
</p>
<p>In first approach, a bed.matrix behaves as a &quot;read-only&quot; matrix containing only 
0, 1, 2 and NAs, unless the genotypes are standardized (use <code><a href="#topic+standardize+3C-">standardize&lt;-</a></code>).
They are stored in a compact form, each genotype being coded on 2 bits (hence
4 genotypes per byte).
</p>
<p>Bed.matrices can be converted to numerical matrices with <code><a href="base.html#topic+as.matrix">as.matrix</a></code>,
and multiplied with numeric vectors or matrices with <code>%*%</code> (this 
feature can be used e.g. to simulate quantitative phenotypes, see a basic example in the example
section of <code><a href="#topic+association.test">association.test</a></code>).
</p>
<p>It is possible to subset bed.matrices just as base matrices, writing e.g.
<code>x[1:100,]</code> to extract the first 100 individuals, or <code>x[1:100,1000:1999]</code>
for extract the SNPs 1000 to 1999 for these 100 individuals. The use of logical
vectors for subsetting is allowed too. The functions 
<code><a href="#topic+select.inds">select.inds</a></code> and <code><a href="#topic+select.snps">select.snps</a></code> can also be used for 
subsetting with a nice syntax.
</p>
<p>Some basic descriptive statistics can be added to a bed.matrix with <code><a href="#topic+set.stats">set.stats</a></code> (since
<code>gaston 1.4</code>, this function is called by default by all functions that create a bed.matrix, unless
<code>options(gaston.auto.set.stats = FALSE)</code> was set.
Hardy-Weinberg Equilibrium can be tested for all SNPs with <code><a href="#topic+set.hwe">set.hwe</a></code>. 
</p>


<h3>Crossproducts of standardized matrices</h3>

<p>If <code class="reqn">X</code> is a standardized <code class="reqn">n\times q</code> genotype matrix, a Genetic Relationship Matrix 
(GRM) of the individuals can be computed as
</p>
<p style="text-align: center;"><code class="reqn"> GRM = {1\over q-1} XX’ </code>
</p>

<p>where <code class="reqn">q</code> is the number of SNPs. 
This computation is done by the function <code><a href="#topic+GRM">GRM</a></code>.  The eigen decomposition of the GRM produces
the Principal Components (PC) of the data set. If needed, the loadings 
corresponding to the PCs can be retrieved using <code><a href="#topic+bed.loadings">bed.loadings</a></code>.
</p>
<p>Doing the above crossproduct in the reverse order produces a moment estimate of the Linkage Disequilibrium:
</p>
<p style="text-align: center;"><code class="reqn"> LD = {1\over n-1} X’X </code>
</p>

<p>where <code class="reqn">n</code> is the number of individuals. This computation is done by the function
<code><a href="#topic+LD">LD</a></code> (usually, only parts of the whole LD matrix is computed). This method is 
also used by <code><a href="#topic+LD.thin">LD.thin</a></code> to extract a set of SNPs in low linkage disequilibrium
(it is often recommended to perform this operation before computing the GRM).
</p>


<h3>Linear Mixed Models</h3>

<p><code><a href="#topic+lmm.aireml">lmm.aireml</a></code> is a function for linear mixed models parameter estimation
and BLUP computations. 
</p>
<p>The model considered is of the form
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega_i \sim N(0,\tau_i K_i) </code> for <code class="reqn"> i \in 1, \dots,k </code> and
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>Note that very often in genetics a mixed model is written as
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + Zu + \varepsilon </code>
</p>

<p>with <code class="reqn">Z</code> a standardized genotype matrix, and <code class="reqn">u\sim N(0, \tau I_q)</code>. In that case, 
denoting <code class="reqn">\omega = Zu</code>, <code class="reqn">\omega \sim N(0, \tau ZZ')</code>
and letting <code class="reqn">K=ZZ'</code> we get a mixed model of the previous form.
</p>
<p>When <code class="reqn">k=1</code> in the above general model (only one random term <code class="reqn">\omega</code>), the likelihood
can be computed very efficiently using the eigen decomposition of 
<code class="reqn">K = \mathrm{var}(\omega)</code>. This &quot;diagonalization trick&quot; 
is used in <code><a href="#topic+lmm.diago.likelihood">lmm.diago.likelihood</a></code> and <code><a href="#topic+lmm.diago">lmm.diago</a></code>, to compute 
the likelihood and for parameter estimation, respectively. 
</p>
<p>Two small functions complete this set of functions: <code><a href="#topic+lmm.simu">lmm.simu</a></code>, to 
simulate data under a linear mixed model, and <code><a href="#topic+random.pm">random.pm</a></code>, to generate
random positive matrices. Both are used in examples and can be useful for data simulation.
</p>


<h3>Author(s)</h3>

<p>Hervé Perdry and Claire Dandine-Roulland
</p>
<p>Maintainer: Hervé Perdry
</p>

<hr>
<h2 id='GRM'> Genetic Relationship Matrix</h2><span id='topic+GRM'></span>

<h3>Description</h3>

<p>Compute the Genetic Relationship Matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'> GRM(x, which.snps, autosome.only = TRUE, chunk = 1L) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRM_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="GRM_+3A_which.snps">which.snps</code></td>
<td>
<p> Logical vector, giving which snps to use in the computation.  The default is to use all autosomal SNPs</p>
</td></tr>
<tr><td><code id="GRM_+3A_autosome.only">autosome.only</code></td>
<td>
<p> If <code>TRUE</code>, only autosomal SNPs will be considered. </p>
</td></tr>
<tr><td><code id="GRM_+3A_chunk">chunk</code></td>
<td>
<p> Parameter for the parallelization: how many SNPs are treated by each task</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Genetic Relationship Matrix (GRM) is computed by the formula <code class="reqn">{1\over q}XX'</code>, 
with <code class="reqn">X</code> the standardized genotype matrix and <code class="reqn">q</code> the number of SNPs
(<code>ncol(x)</code>).
</p>
<p>If <code>x</code> is not standardized before this computation, the function
will use <code>standardize(x) &lt;- "p"</code> by default.
</p>


<h3>Value</h3>

<p> The GRM is a symmetric square matrix of dimension equal to the number of individuals.
Each entry can be interpreted as an estimated kinship coefficient between individuals, although some 
authors might disagree. Note in particular that some entries will be negative.</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+DM">DM</a></code>, <code><a href="#topic+reshape.GRM">reshape.GRM</a></code>, <code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="#topic+lmm.diago">lmm.diago</a></code>, <code><a href="#topic+standardize">standardize</a></code>, <code><a href="#topic+bed.loadings">bed.loadings</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># load chr2 data set (~10k SNPs in low LD)
x &lt;- read.bed.matrix( system.file("extdata", "chr2.bed", package="gaston") )

# Compute Genetic Relationship Matrix
K &lt;- GRM(x)
dim(K)
</code></pre>

<hr>
<h2 id='is.autosome'> Autosomes and X, Y, MT chromosomes </h2><span id='topic+is.autosome'></span><span id='topic+is.chr.x'></span><span id='topic+is.chr.y'></span><span id='topic+is.chr.mt'></span>

<h3>Description</h3>

<p>Test if a chromosome id corresponds to an autosome or to X, Y, MT chromosomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.autosome(chr)
  is.chr.x(chr)
  is.chr.y(chr)
  is.chr.mt(chr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.autosome_+3A_chr">chr</code></td>
<td>
<p> A vector of chromosome ids </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions work by comparing the ids given in parameters with 
the options <code>gaston.autosomes</code>, <code>gaston.chr.x</code>, <code>gaston.chr.y</code>,
<code>gaston.chr.mt</code>.
</p>
<p>For example, <code>is.autosome(chr)</code> is a short cut for 
<code>chr %in% getOption("gaston.autosomes")</code>.
</p>


<h3>Value</h3>

 
<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry </p>

<hr>
<h2 id='LCT'>LCT data set</h2><span id='topic+LCT'></span><span id='topic+LCT.gen'></span><span id='topic+LCT.fam'></span><span id='topic+LCT.bim'></span><span id='topic+LCT.pop'></span>

<h3>Description</h3>

<p>These data have been extracted from the 1000 Genomes data.
The data set contains the genotype matrix <code>LCT.gen</code>, the pedigree matrix <code>LCT.fam</code> and a matrix <code>LCT.bim</code>,
corresponding to 503 individuals of European populations and 607 SNPs on chromosome 2, on a ~300kb segment 
containing the Lactase gene. There is also a factor <code>LCT.pop</code>, which gives the population from which each
individual is drawn (CEU = Utah residents of Northern Western European ancestry, FIN = Finnish, GBR = England and Scottland, 
IBS = Iberian, TSI = Toscani).
</p>
<p>Note that the SNP rs4988235 is associated with lactase persistence / lactose intolerence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(LCT) </code></pre>


<h3>Format</h3>

<p>There are three data objects in the dataset:
</p>

<dl>
<dt><code>LCT.gen</code></dt><dd><p> Genotype matrix </p>
</dd>
<dt><code>LCT.fam</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.fam</code> file  </p>
</dd>
<dt><code>LCT.bim</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.bim</code> file </p>
</dd>
<dt><code>LCT.pop</code></dt><dd><p> Factor giving the population from which each individual is drawn </p>
</dd>
</dl>



<h3>Source</h3>

<p> The data were obtained from the 1000 Genomes project (see <a href="https://www.internationalgenome.org/">https://www.internationalgenome.org/</a>). </p>


<h3>References</h3>

<p>McVean et al, 2012, <em>An integrated map of genetic variation from 1,092 human genomes</em>, Nature <b>491, 56-65</b> doi:10.1038/nature11632 </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)
x
which(x@snps$id == "rs4988235")
</code></pre>

<hr>
<h2 id='LD'> Linkage Disequilibrium </h2><span id='topic+LD'></span>

<h3>Description</h3>

<p> Compute Linkage Disequilibrium (LD) between given SNPs. </p>


<h3>Usage</h3>

<pre><code class='language-R'> LD(x, lim, lim2, measure = c("r2", "r", "D"), trim = TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="LD_+3A_lim">lim</code></td>
<td>
<p> Range of SNPs for which the LD is computed </p>
</td></tr>
<tr><td><code id="LD_+3A_lim2">lim2</code></td>
<td>
<p> (Optional) Second range of SNPs (see Details) </p>
</td></tr>
<tr><td><code id="LD_+3A_measure">measure</code></td>
<td>
<p> The LD measure </p>
</td></tr>
<tr><td><code id="LD_+3A_trim">trim</code></td>
<td>
 <p><code>Logical</code>. If <code>TRUE</code>, the values above 1 or below -1 are replaced by 1 and -1 respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lim2</code> is missing, the LD is computed between all SNPs with indices between <code>lim[1]</code> and <code>lim[2]</code>; 
else, the LD is computed between the SNPs in the range given by <code>lim</code> and those in the range given by <code>lim2</code>.
</p>
<p>Note that the LD estimates are moment estimates (which are less precise than Maximum Likelihood Estimates). 
If <code>standardize(x) = "none"</code>, <code>x</code> will be standardized
using <code>x@mu</code> and <code>x@sigma</code>. If <code>standardize(x) = "p"</code>, the moment estimates can produce <code class="reqn">r</code>
values outside of the range <code class="reqn">[-1;1]</code>, hence the parameter <code>trim</code>. We recommend to set
<code>standardize(x) &lt;- "mu"</code> (trimming can still be necessary due to rounding errors).
</p>


<h3>Value</h3>

<p>A matrix of LD values.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+LD.thin">LD.thin</a></code>,  <code><a href="#topic+LD.plot">LD.plot</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute LD
ld.x &lt;- LD(x, c(1,ncol(x)))

# Plot a tiny part of the LD matrix
LD.plot( ld.x[1:20,1:20], snp.positions = x@snps$pos[1:20] )
</code></pre>

<hr>
<h2 id='LD.clump'> LD clumping </h2><span id='topic+LD.clump'></span>

<h3>Description</h3>

<p> Construct group of SNPs in LD with 'top associated SNPs' </p>


<h3>Usage</h3>

<pre><code class='language-R'>LD.clump(x, p, r2.threshold, p.threshold, max.dist = 500e3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD.clump_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="LD.clump_+3A_p">p</code></td>
<td>
<p> A vector of p-values, or a data frame including p-values, such as sent back by <code><a href="#topic+association.test">association.test</a></code> </p>
</td></tr> 
<tr><td><code id="LD.clump_+3A_r2.threshold">r2.threshold</code></td>
<td>
<p> The maximum LD (measured by <code class="reqn">r^2</code>) between SNPs in a group </p>
</td></tr>
<tr><td><code id="LD.clump_+3A_p.threshold">p.threshold</code></td>
<td>
<p> The threshold used to define associated SNPs </p>
</td></tr>
<tr><td><code id="LD.clump_+3A_max.dist">max.dist</code></td>
<td>
<p> The maximum distance for which the LD is computed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The p-values provided through argument <code>p</code> are assumed to correspond to the result of an association test with the SNPs of <code>x</code>.
</p>
<p>The aim of the function is to construct cluster of SNPs in strong LD with associated SNPs.
The algorithm first seeks the SNP with the lowest p-value (below <code>p.threshold</code>) ; this SNP will be the 'index' of a cluster. 
The corresponding cluster is constructed by aggregating SNPs that are in LD (above <code>r2.threshold</code>) with the index. The cluster's name 
is the position of the index SNP.
The processus is repeated on the SNPs which are not yet attributed to a cluster, until there is no associated SNP 
(ie SNP with a p-value below <code>threshold</code>) left.
The remaining SNPs are attributed to cluster 0. 
</p>
<p>The LD is computed only for SNP pairs for which distance is inferior to <code>max.dist</code>, expressed in number of bases: above this 
distance it is assumed to be null.
</p>


<h3>Value</h3>

<p>If <code>p</code> was a data frame, then the function returns the same data frame with to extra columns, <code>cluster</code> and <code>is.index</code>.
If <code>p</code> was a vector of p-values, it returns a data frame with columns <code>chr</code>, <code>id</code>, <code>pos</code>, <code>p</code>, <code>cluster</code> 
and <code>is.index</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+LD">LD</a></code>, <code><a href="#topic+LD.thin">LD.thin</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a bed matrix
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)
standardize(x) &lt;- "p"
     
# simulate quantitative phenotype with effect of SNPs #108 and #631
beta &lt;- numeric(ncol(x))
beta[c(108,631)] &lt;- 0.5
set.seed(1)
y &lt;- x %*% beta + rnorm(nrow(x))
     
# association test with linear model 
test &lt;- association.test(x, y, method="lm", response = "quanti")

# LD clumping
test &lt;- LD.clump(x, test, r2.threshold = 0.25, p.threshold = 1e-8)

# use as.factor for a quick-and-dirty cluster colouring on the manhattan plot 
manhattan(test, col = as.factor(test$cluster), pch = 20)
</code></pre>

<hr>
<h2 id='LD.plot'> Plot Linkage Disequilibrium </h2><span id='topic+LD.plot'></span>

<h3>Description</h3>

<p> Pretty plot of a Linkage Disequilibrium (LD) matrix </p>


<h3>Usage</h3>

<pre><code class='language-R'> LD.plot(LD, snp.positions, max.dist = Inf, depth = nrow(LD), 
                graphical.par = list(mar = c(0,0,0,0)), cex.ld, cex.snp,
                polygon.par = list(border = "white"), 
                color.scheme = function(ld) rgb(1,1-abs(ld),1-abs(ld)),
                write.snp.id = TRUE, write.ld = function(ld) sprintf("%.2f", ld),
                draw.chr = TRUE, above.space = 1 + 2*write.snp.id + draw.chr, 
                below.space = 1, pdf.file, finalize.pdf = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD.plot_+3A_ld">LD</code></td>
<td>
<p>A symmetric LD matrix (such as produced by <code>LD</code></p>
</td></tr>
<tr><td><code id="LD.plot_+3A_snp.positions">snp.positions</code></td>
<td>
<p>A vector of SNP positions</p>
</td></tr>
<tr><td><code id="LD.plot_+3A_max.dist">max.dist</code></td>
<td>
<p>Maximal distance above which the LD is not plotted</p>
</td></tr>
<tr><td><code id="LD.plot_+3A_depth">depth</code></td>
<td>
<p>Maximal number of neighbouring SNPs for which the LD is plotted</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_graphical.par">graphical.par</code></td>
<td>
<p>A list of graphical parameters for function <code>par</code></p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_cex.ld">cex.ld</code></td>
<td>
<p>The magnification to be used for LD values (if missing, an ad-hoc value is computed)</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_cex.snp">cex.snp</code></td>
<td>
<p>The magnification to be used for SNPs ids (if missing, an ad-hoc value is computed)</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_polygon.par">polygon.par</code></td>
<td>
<p>A list of parameters for function <code>polygon</code></p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_color.scheme">color.scheme</code></td>
<td>
<p>A function to set the background color of a cell</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_write.snp.id">write.snp.id</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code>, SNP ids will be displayed above the plot</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_write.ld">write.ld</code></td>
<td>
<p><code>NULL</code>, or a function which outputs the string used for displaying a LD value in a cell</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_draw.chr">draw.chr</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code>, a chromosome with SNP positions is sketched above the plot </p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_above.space">above.space</code></td>
<td>
<p>Space above the plot (in user units = height of a cell)</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_below.space">below.space</code></td>
<td>
<p>Space below the plot (in user units = height of a cell)</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_pdf.file">pdf.file</code></td>
<td>
<p>The name of a pdf file in which to plot the LD matrix. If missing, current plot device will be used</p>
</td></tr>  
<tr><td><code id="LD.plot_+3A_finalize.pdf">finalize.pdf</code></td>
<td>
<p><code>Logical</code>. If <code>TRUE</code>, <code>dev.off()</code> will be called to finalize the pdf file</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function displays a LD plot similar to Haploview plots. 
</p>
<p>To add anotations to the plot, it is useful to know that each cell has width and height equal 
to one user unit, the first cell in the upper row being centered at coordinates <code>(1.5, -0.5)</code>.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+LD">LD</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute LD
ld.x &lt;- LD(x, c(1,ncol(x)))

# Plot a tiny part of the LD matrix
LD.plot( ld.x[1:20,1:20], snp.positions = x@snps$pos[1:20] )

# Customize the plot
LD.plot( ld.x[1:20,1:20], snp.positions = x@snps$pos[1:20], 
         graphical.par = list(cex = 1.3, bg = "gray"), 
         polygon.par = list(border = NA), write.ld = NULL )
## Not run: 
# Plotting the whole matrix in X11 display is very long (lots of polygons)
# but it is ok with a pdf file
# (please uncomment to run)
#LD.plot(ld.x, snp.positions = x@snps$pos, max.dist = 50e3, write.ld = NULL, pdf.file = "LDAGT.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='LD.thin'> LD thinning </h2><span id='topic+LD.thin'></span>

<h3>Description</h3>

<p> Select SNPs in LD below a given threshold. </p>


<h3>Usage</h3>

<pre><code class='language-R'>LD.thin(x, threshold, max.dist = 500e3, beg = 1, end = ncol(x),
        which.snps, dist.unit = c("bases", "indices", "cM"), 
        extract = TRUE, keep = c("left", "right", "random"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD.thin_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_threshold">threshold</code></td>
<td>
<p> The maximum LD (measured by <code class="reqn">r^2</code>) between SNPs </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_max.dist">max.dist</code></td>
<td>
<p> The maximum distance for which the LD is computed </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_beg">beg</code></td>
<td>
<p> The index of the first SNP to consider </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_end">end</code></td>
<td>
<p> The index of the last SNP to consider </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_which.snps">which.snps</code></td>
<td>
<p> Logical vector, giving which SNPs are considerd. The default is to use all SNPs</p>
</td></tr>
<tr><td><code id="LD.thin_+3A_dist.unit">dist.unit</code></td>
<td>
<p> Distance unit in <code>max.dist</code> </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_extract">extract</code></td>
<td>
<p> A <code>logical</code> indicating whether the function return a <code>bed.matrix</code> (<code>TRUE</code>) 
or a logical vector indicating which SNPs are selected (<code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="LD.thin_+3A_keep">keep</code></td>
<td>
<p> Which SNP is selected in a pair with LD above <code>threshold</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SNPs to keep are selected by a greedy algorithm. The LD is computed only for SNP pairs for which distance is inferior to 
<code>max.dist</code>, expressed in number of bases if <code>dist.unit = "bases"</code>, in number of SNPs if <code>dist.unit = "indices"</code>,
or in centiMorgan if <code>dist.unit = "cM"</code>. 
</p>
<p>The argument <code>which.snps</code> allows to consider only a subset of SNPs.
</p>
<p>The algorithm tries to keep the largest possible number of SNPs: it is not appropriate to select tag-SNPs.
</p>


<h3>Value</h3>

<p>If <code>extract = TRUE</code>, a <code><a href="#topic+bed.matrix">bed.matrix</a></code> extracted from <code>x</code> with SNPs in pairwise LD below the given threshold.
If <code>extract = FALSE</code>, a logical vector of length <code>end - beg + 1</code>, where <code>TRUE</code> indicates that 
the corresponding SNPs is selected.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+LD">LD</a></code>, <code><a href="#topic+set.dist">set.dist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(TTN)
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)

# Select SNPs in LD r^2 &lt; 0.4, max.dist = 500 kb
y &lt;- LD.thin(x, threshold = 0.4, max.dist = 500e3)
y

# Verifies that there is no SNP pair with LD r^2 &gt; 0.4
# (note that the matrix ld.y has ones on the diagonal)
ld.y &lt;- LD( y, lim = c(1, ncol(y)) )
sum( ld.y &gt; 0.4 )  
</code></pre>

<hr>
<h2 id='lik.contour'> Contour plot for two parameters likelihood </h2><span id='topic+lik.contour'></span>

<h3>Description</h3>

<p> Create a contour plot (superimposed with a heat map) </p>


<h3>Usage</h3>

<pre><code class='language-R'> lik.contour(x, y, z, levels = NULL, nlevels = 11, heat = TRUE, col.heat = NULL, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lik.contour_+3A_x">x</code>, <code id="lik.contour_+3A_y">y</code>, <code id="lik.contour_+3A_z">z</code></td>
<td>
<p> As in <code>contour</code> </p>
</td></tr>
<tr><td><code id="lik.contour_+3A_levels">levels</code></td>
<td>
<p> As in <code>contour</code>. If <code>NULL</code>, the function computes appropriate levels. </p>
</td></tr>
<tr><td><code id="lik.contour_+3A_nlevels">nlevels</code></td>
<td>
<p> As in <code>contour</code> </p>
</td></tr>
<tr><td><code id="lik.contour_+3A_heat">heat</code></td>
<td>
<p> If <code>TRUE</code>, a heat map is superimposed to the contour plot </p>
</td></tr>
<tr><td><code id="lik.contour_+3A_col.heat">col.heat</code></td>
<td>
<p> Vector of heat colors</p>
</td></tr>
<tr><td><code id="lik.contour_+3A_...">...</code></td>
<td>
<p> Additional arguments to <code>image</code> and <code>contour</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function is a wrapper for <code>contour</code>, with a different method to compute
a default value for levels. If <code>heat = TRUE</code>, a heatmap produced by <code>image</code> is added to the plot.
See <code><a href="graphics.html#topic+contour">contour</a></code> for details on parameters. </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.diago.likelihood">lmm.diago.likelihood</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix
K &lt;- GRM(x)

# eigen decomposition of K
eiK &lt;- eigen(K)

# simulate a phenotype
set.seed(1)
y &lt;- 1 + lmm.simu(tau = 1, sigma2 = 2, eigenK = eiK)$y

# Likelihood
TAU &lt;- seq(0.5,2.5,length=30)
S2 &lt;- seq(1,3,length=30)
lik1 &lt;- lmm.diago.likelihood(tau = TAU, s2 = S2, Y = y, eigenK = eiK)
lik.contour(TAU, S2, lik1, heat = TRUE, xlab = "tau", ylab = "sigma^2")
</code></pre>

<hr>
<h2 id='lmm.aireml'> Linear mixed model fitting with AIREML </h2><span id='topic+lmm.aireml'></span>

<h3>Description</h3>

<p>Estimate the parameters of a linear mixed model, 
using Average Information Restricted Maximum Likelihood (AIREML) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmm.aireml(Y, X = matrix(1, nrow = length(Y)), K,
           EMsteps = 0L, EMsteps_fail = 1L, EM_alpha = 1,
           min_tau, min_s2 = 1e-06, theta, constraint = TRUE, max_iter = 50L,
           eps = 1e-05, verbose = getOption("gaston.verbose", TRUE),
           contrast = FALSE, get.P = FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm.aireml_+3A_y">Y</code></td>
<td>
<p> Phenotype vector </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_x">X</code></td>
<td>
<p> Covariable matrix. By default, a column of ones to include an intercept in the model </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_k">K</code></td>
<td>
<p> A positive definite matrix or a <code>list</code> of such matrices </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_emsteps">EMsteps</code></td>
<td>
<p> Number of EM steps ran prior the AIREML </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_emsteps_fail">EMsteps_fail</code></td>
<td>
<p> Number of EM steps performed when the AIREML algorithm fail to improve the likelihood value </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_em_alpha">EM_alpha</code></td>
<td>
<p> Tweaking parameter for the EM (see Details) </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_min_tau">min_tau</code></td>
<td>
<p> Minimal value for model parameter <code class="reqn">\tau</code> (if missing, will be set to <code class="reqn">10^{-6}</code>)</p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_min_s2">min_s2</code></td>
<td>
<p> Minimal value for model parameter <code class="reqn">\sigma^2</code> </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_theta">theta</code></td>
<td>
<p> (Optional) Optimization starting point <code>theta = c(sigma^2, tau)</code> </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_constraint">constraint</code></td>
<td>
<p> If <code>TRUE</code>, the model parameters respect the contraints given by <code>min_tau</code> and <code>min_s2</code> </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_max_iter">max_iter</code></td>
<td>
<p> Maximum number of iterations </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_eps">eps</code></td>
<td>
<p> The algorithm stops when the gradient norm is lower than this parameter </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the algorithm progress </p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_contrast">contrast</code></td>
<td>
<p> If <code>TRUE</code>, use a contrast matrix to compute the Restricted Likelihood (usually slower)</p>
</td></tr>
<tr><td><code id="lmm.aireml_+3A_get.p">get.P</code></td>
<td>
<p>If <code>TRUE</code>, the function sends back the last matrix <code class="reqn">P</code> computed in the optimization process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the parameters of the following linear mixed model, using AIREML algorithm:
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega_i \sim N(0,\tau_i K_i) </code> for <code class="reqn"> i \in 1, \dots,k </code> and 
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>The variance matrices <code class="reqn">K_1</code>, ..., <code class="reqn">K_k</code>, are specified through the parameter <code>K</code>.
</p>
<p>If <code>EMsteps</code> is positive, the function will use this number of EM steps to compute a better starting point
for the AIREML algorithm. Setting <code>EMsteps</code> to a value higher than <code>max_iter</code> leads to an EM optimization.
It can happen that after an AIREML step, the likelihood did not increase: if this 
happens, the functions falls back to <code>EMsteps_fail</code> EM steps. The parameter <code>EM_alpha</code> can be set to 
a value higher than <code class="reqn">1</code> to attempt to accelerate EM convergence; this could also result in uncontrolled
behaviour and should be used with care.
</p>
<p>After convergence, the function also compute Best Linear Unbiased Predictors (BLUPs) for 
<code class="reqn">\beta</code> and <code class="reqn">\omega</code>, and an 
estimation of the participation of the fixed effects to the variance of <code class="reqn">Y</code>.
</p>


<h3>Value</h3>

<p>A named list with members:
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p> Estimate of the model parameter <code class="reqn">\sigma^2</code> </p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p> Estimate(s) of the model parameter(s) <code class="reqn">\tau_1, \dots, \tau_k</code> </p>
</td></tr>
<tr><td><code>logL</code></td>
<td>
<p> Value of log-likelihood </p>
</td></tr>
<tr><td><code>logL0</code></td>
<td>
<p> Value of log-likelihood under the null model (without random effect) </p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p> Number of iterations done </p>
</td></tr>
<tr><td><code>norm_grad</code></td>
<td>
<p> Last computed gradient's norm </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p> Last computed value of matrix P (see reference) </p>
</td></tr>
<tr><td><code>Py</code></td>
<td>
<p> Last computed value of vector Py (see reference) </p>
</td></tr>
<tr><td><code>BLUP_omega</code></td>
<td>
<p> BLUPs of random effects </p>
</td></tr>
<tr><td><code>BLUP_beta</code></td>
<td>
<p> BLUPs of fixed effects <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>varbeta</code></td>
<td>
<p> Variance matrix for <code class="reqn">\beta</code> estimates </p>
</td></tr>
<tr><td><code>varXbeta</code></td>
<td>
<p> Participation of fixed effects to variance of Y </p>
</td></tr>
</table>
<p>If <code>get.P = TRUE</code>, there is an additional member:
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>The last matrix <code class="reqn">P</code> computed in the AIREML step</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>References</h3>

<p>Gilmour, A. R., Thompson, R., &amp; Cullis, B. R. (1995), <em>Average information REML: an efficient algorithm for variance parameter estimation in linear mixed models</em>, Biometrics, <b>1440-1450</b></p>


<h3>See Also</h3>

<p><code><a href="#topic+lmm.diago">lmm.diago</a></code>, <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code>, <code><a href="#topic+lmm.simu">lmm.simu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix
standardize(x) &lt;- "p"
K &lt;- GRM(x)

# Simulate a quantitative genotype under the LMM
set.seed(1)
y &lt;- 1 + x %*% rnorm(ncol(x), sd = 1)/sqrt(ncol(x)) + rnorm(nrow(x), sd = sqrt(2))

# Estimates
estimates &lt;- lmm.aireml(y, K = K, verbose = FALSE)
str(estimates)
</code></pre>

<hr>
<h2 id='lmm.diago'> Linear mixed model fitting with the diagonalization trick </h2><span id='topic+lmm.diago'></span>

<h3>Description</h3>

<p>Estimate the parameters of a linear mixed model, using the &quot;diagonalization trick&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> lmm.diago(Y, X = matrix(1, nrow=length(Y)), eigenK, p = 0, 
                  method = c("newton", "brent"), min_h2 = 0, max_h2 = 1,
                  verbose = getOption("gaston.verbose", TRUE), 
                  tol = .Machine$double.eps^0.25) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm.diago_+3A_y">Y</code></td>
<td>
<p> Phenotype vector </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_x">X</code></td>
<td>
<p> Covariable matrix </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_eigenk">eigenK</code></td>
<td>
<p> Eigen decomposition of <code class="reqn">K</code> (a positive symmetric matrix)</p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_p">p</code></td>
<td>
<p> Number of Principal Components included in the mixed model with fixed effect </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_method">method</code></td>
<td>
<p> Optimization method to use </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_min_h2">min_h2</code></td>
<td>
<p> Minimum admissible value </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_max_h2">max_h2</code></td>
<td>
<p> Maximum admissible value </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function actions </p>
</td></tr>
<tr><td><code id="lmm.diago_+3A_tol">tol</code></td>
<td>
<p> Accuracy of estimation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the parameters of the following linear mixed model, computing the restricted likelihood as in <code>lmm.diago.likelihood</code>,
and using either a Newton algorithm, or Brent algorithm as in <code><a href="stats.html#topic+optimize">optimize</a></code>:
</p>
<p style="text-align: center;"><code class="reqn"> Y = (X|PC)\beta + \omega + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega \sim N(0,\tau K) </code> and
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>The matrix <code class="reqn">K</code> is given through its eigen decomposition, as produced by <code>eigenK = eigen(K, symmetric = TRUE)</code>.
The matrix <code class="reqn">(X|PC)</code> is the concatenation of the covariable matrix <code class="reqn">X</code> and  
of the first <code class="reqn">p</code> eigenvectors of <code class="reqn">K</code>, included in the model with fixed effects.
</p>


<h3>Value</h3>

<p>If the parameter <code>p</code> is a scalar, a list with following elements :
</p>
<table>
<tr><td><code>sigma2</code></td>
<td>
<p> Estimate of the model parameter <code class="reqn">\sigma^2</code> </p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p> Estimate(s) of the model parameter(s) <code class="reqn">\tau_1, \dots, \tau_k</code> </p>
</td></tr>
<tr><td><code>Py</code></td>
<td>
<p> Last computed value of vector Py (see reference) </p>
</td></tr>
<tr><td><code>BLUP_omega</code></td>
<td>
<p> BLUPs of random effects </p>
</td></tr>
<tr><td><code>BLUP_beta</code></td>
<td>
<p> BLUPs of fixed effects <code class="reqn">\beta</code> (only the components corresponding to <code class="reqn">X</code>)</p>
</td></tr>
<tr><td><code>Xbeta</code></td>
<td>
<p> Estimate of <code class="reqn">(X|PC)\beta</code> </p>
</td></tr>
<tr><td><code>varbeta</code></td>
<td>
<p> Variance matrix for <code class="reqn">\beta</code> estimates (only the components corresponding to <code class="reqn">X</code>) </p>
</td></tr>
<tr><td><code>varXbeta</code></td>
<td>
<p> Participation of fixed effects to variance of Y </p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p> Number of Principal Components included in the linear mixed model with fixed effect </p>
</td></tr>
</table>
<p>If the paramer <code>p</code> is a vector of length <code>&gt; 1</code>, a <code>list</code> of lists as described above,
one for each value in <code>p</code>.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.diago.likelihood">lmm.diago.likelihood</a></code>, <code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="stats.html#topic+optimize">optimize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix
K &lt;- GRM(x)

# eigen decomposition of K
eiK &lt;- eigen(K)

# simulate a phenotype
set.seed(1)
y &lt;- 1 + lmm.simu(tau = 1, sigma2 = 2, eigenK = eiK)$y

# Estimations
R &lt;- lmm.diago(Y = y, eigenK = eiK, p = c(0,10))
str(R)
</code></pre>

<hr>
<h2 id='lmm.diago.likelihood'> Likelihood of a linear mixed model </h2><span id='topic+lmm.diago.likelihood'></span><span id='topic+lmm.diago.profile.likelihood'></span>

<h3>Description</h3>

<p>Compute the Restricted or the Full Likelihood of a linear mixed model, using the &quot;diagonalization trick&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> lmm.diago.likelihood(tau, s2, h2, Y, X, eigenK, p = 0) 
 lmm.diago.profile.likelihood(tau, s2, h2, Y, X, eigenK, p = 0) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm.diago.likelihood_+3A_tau">tau</code></td>
<td>
<p> Value(s) of model parameter (see Details) </p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_s2">s2</code></td>
<td>
<p>  Value(s) of model parameter (see Details) </p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_h2">h2</code></td>
<td>
<p>  Value(s) of heritability (see Details) </p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_y">Y</code></td>
<td>
<p> Phenotype vector </p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_x">X</code></td>
<td>
<p> Covariable matrix </p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_eigenk">eigenK</code></td>
<td>
<p> Eigen decomposition of <code class="reqn">K</code> (a positive symmetric matrix)</p>
</td></tr>
<tr><td><code id="lmm.diago.likelihood_+3A_p">p</code></td>
<td>
<p> Number of Principal Components included in the mixed model with fixed effect </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theses function respectively compute the Restricted and the Profile Likelihood under the linear 
mixed model
</p>
<p style="text-align: center;"><code class="reqn"> Y = (X|PC)\beta + \omega + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega \sim N(0,\tau K) </code> and 
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>. 
</p>
<p>The matrix <code class="reqn">K</code> is given through its eigen decomposition, as produced by <code>eigenK = eigen(K, symmetric = TRUE)</code>.
The matrix <code class="reqn">(X|PC)</code> is the concatenation of the covariable matrix <code class="reqn">X</code> and 
of the first <code class="reqn">p</code> eigenvectors of <code class="reqn">K</code>, included in the model with fixed effects.
</p>
<p>If both <code>tau</code> and <code>s2</code> (for <code class="reqn">\sigma^2</code>) are provided, <code>lmm.diago.likelihood</code>
computes the restricted
likelihood for these values of the parameters; if these parameters are vectors of length <code class="reqn">&gt; 1</code>,
then a matrix of likelihood values is computed. 
</p>
<p>The function <code>lmm.diago.profile.likelihood</code> computes the full likelihood, profiled for <code class="reqn">\beta</code>.
That is, the value <code class="reqn">\beta</code> which maximizes the full likelihood for the given values of <code class="reqn">\tau</code>
and <code class="reqn">\sigma^2</code> is computed, and then the full likelihood is computed.
</p>
<p>If <code>h2</code> is provided, both functions compute <code class="reqn">\tau</code> and <code class="reqn">\sigma^2</code> which
maximizes the likelihood under the constraint <code class="reqn"> {\tau \over \tau + \sigma^2 } = h^2 </code>,
and output these values as well as the likelihood value at this point.
</p>


<h3>Value</h3>

<p>If <code>tau</code> and <code>s2</code> are provided, the corresponding likelihood values.
</p>
<p>If <code>tau</code> or <code>s2</code> are missing, and <code>h2</code> is provided, a named list with members
</p>
<table>
<tr><td><code>tau</code></td>
<td>
<p> Corresponding values of <code class="reqn">\tau</code> </p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p> Corresponding values of <code class="reqn">\sigma^2</code></p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p> Corresponding likelihood values </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.restricted.likelihood">lmm.restricted.likelihood</a></code>, <code><a href="#topic+lmm.profile.restricted.likelihood">lmm.profile.restricted.likelihood</a></code>,  <code><a href="#topic+lmm.diago">lmm.diago</a></code>, <code><a href="#topic+lmm.aireml">lmm.aireml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix
K &lt;- GRM(x)

# eigen decomposition of K
eiK &lt;- eigen(K)

# simulate a phenotype
set.seed(1)
y &lt;- 1 + lmm.simu(tau = 1, sigma2 = 2, eigenK = eiK)$y
     
# Likelihood
TAU &lt;- seq(0.5,1.5,length=30)
S2 &lt;- seq(1,3,length=30)
lik1 &lt;- lmm.diago.likelihood(tau = TAU, s2 = S2, Y = y, eigenK = eiK)

H2 &lt;- seq(0,1,length=51)
lik2 &lt;- lmm.diago.likelihood(h2 = H2, Y = y, eigenK = eiK)

# Plotting
par(mfrow=c(1,2))
lik.contour(TAU, S2, lik1, heat = TRUE, xlab = "tau", ylab = "sigma^2")
lines(lik2$tau, lik2$sigma2)
plot(H2, exp(lik2$likelihood), type="l", xlab="h^2", ylab = "likelihood")
</code></pre>

<hr>
<h2 id='lmm.restricted.likelihood'> Likelihood of a linear mixed model </h2><span id='topic+lmm.restricted.likelihood'></span><span id='topic+lmm.profile.restricted.likelihood'></span>

<h3>Description</h3>

<p>Compute the Restricted or the Full Likelihood of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 lmm.restricted.likelihood(Y, X = matrix(1, nrow = length(Y)), K, tau, s2)
 lmm.profile.restricted.likelihood(Y, X = matrix(1, nrow = length(Y)), K, h2) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm.restricted.likelihood_+3A_y">Y</code></td>
<td>
<p> Phenotype vector </p>
</td></tr>
<tr><td><code id="lmm.restricted.likelihood_+3A_x">X</code></td>
<td>
<p> Covariable matrix </p>
</td></tr>
<tr><td><code id="lmm.restricted.likelihood_+3A_k">K</code></td>
<td>
<p> A positive definite matrix or a <code>list</code> of such matrices </p>
</td></tr>
<tr><td><code id="lmm.restricted.likelihood_+3A_tau">tau</code></td>
<td>
<p> Value(s) of parameter(s) <code class="reqn">\tau</code>  </p>
</td></tr>
<tr><td><code id="lmm.restricted.likelihood_+3A_s2">s2</code></td>
<td>
<p>  Value of parameter <code class="reqn">\sigma^2</code> </p>
</td></tr>
<tr><td><code id="lmm.restricted.likelihood_+3A_h2">h2</code></td>
<td>
<p>  Value(s) of heritability  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theses function respectively compute the Restricted and the Profile Likelihood under the linear 
mixed model
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega_i \sim N(0,\tau_i K_i) </code> for <code class="reqn"> i \in 1, \dots,k </code> and
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>The variance matrices <code class="reqn">K_1</code>, ..., <code class="reqn">K_k</code>, are specified through the parameter <code>K</code>.
The parameter <code>tau</code> should be a vector of length <code class="reqn">k</code>.
</p>
<p>The function <code>lmm.restricted.likelihood</code> computes the restricted
likelihood for the given values of <code class="reqn">\tau</code> and <code class="reqn">\sigma^2</code>.
Whenever <code class="reqn">k = 1</code>, it is similar to <code>lmm.diago.likelihood(tau, s2, Y = Y, X = X, eigenK = eigen(K))</code> 
which should be prefered (with a preliminary computation of <code>eigen(K)</code>).
</p>
<p>The function <code>lmm.profile.restricted.likelihood</code> computes a profile restricted
likelihood: the values of <code class="reqn">\tau</code> and <code class="reqn">\sigma^2</code> which
maximizes the likelihood are computed under the constraint 
<code class="reqn"> {\tau \over \tau + \sigma^2 } = h^2 </code>, 
and the profiled likelihood value for these parameters is computed.
Whenever <code class="reqn">k = 1</code>, it is similar to <code>lmm.diago.likelihood(h2 = h2, Y = Y, X = X, eigenK = eigen(K))</code>. 
</p>


<h3>Value</h3>

<p>The restricted likelihood value.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.diago.likelihood">lmm.diago.likelihood</a></code>, <code><a href="#topic+lmm.diago">lmm.diago</a></code>, <code><a href="#topic+lmm.aireml">lmm.aireml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix and its eigen decomposition
K &lt;- GRM(x)
eiK &lt;- eigen(K)

# simulate a phenotype
set.seed(1)
y &lt;- 1 + lmm.simu(tau = 1, sigma2 = 2, eigenK = eiK)$y

# compute restricted likelihood for tau = 0.2 and s2 = 0.8
lmm.restricted.likelihood(y, K=K, tau = 0.2, s2 = 0.8)

# compute profile restricted likelihood for h2 = 0.2
lmm.profile.restricted.likelihood(y, K=K, h2 = 0.2)

# identity with the values computed with the diagonalisation trick
lmm.diago.likelihood(tau = 0.2, s2 = 0.8, Y = y, eigenK = eiK)
lmm.diago.likelihood(h2 = 0.2, Y = y, eigenK = eiK)
</code></pre>

<hr>
<h2 id='lmm.simu'> Linear mixed model data simulation</h2><span id='topic+lmm.simu'></span>

<h3>Description</h3>

<p>Simulate data under a linear mixed model, using the eigen decomposition
of the variance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> lmm.simu(tau, sigma2, K, eigenK = eigen(K), X, beta) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm.simu_+3A_tau">tau</code></td>
<td>
<p> Model parameter </p>
</td></tr>
<tr><td><code id="lmm.simu_+3A_sigma2">sigma2</code></td>
<td>
<p> Model parameter </p>
</td></tr>
<tr><td><code id="lmm.simu_+3A_k">K</code></td>
<td>
<p> (Optional) A positive symmetric matrix <code class="reqn">K</code> </p>
</td></tr>
<tr><td><code id="lmm.simu_+3A_eigenk">eigenK</code></td>
<td>
<p> Eigen decomposition of <code class="reqn">K</code> </p>
</td></tr>
<tr><td><code id="lmm.simu_+3A_x">X</code></td>
<td>
<p> Covariable matrix </p>
</td></tr>
<tr><td><code id="lmm.simu_+3A_beta">beta</code></td>
<td>
<p> Fixed effect vector of covariables </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are simulated under the following linear mixed model :
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\beta + \omega + \varepsilon </code>
</p>

<p>with <code class="reqn"> \omega \sim N(0,\tau K) </code> and
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
</p>
<p>The simulation uses <code class="reqn">K</code> only through its eigen decomposition; the parameter
<code>K</code> is therefore optional.
</p>


<h3>Value</h3>

<p>A named list with two members:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> Simulated value of <code class="reqn">Y</code> </p>
</td></tr>
<tr><td><code>omega</code></td>
<td>
<p>Simulated value of <code class="reqn">\omega</code>  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+random.pm">random.pm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random positive matrix 
set.seed(1)
R &lt;- random.pm(503)

# simulate data with a "polygenic component" 
y &lt;-  lmm.simu(0.3, 1, eigenK = R$eigen)
str(y)
</code></pre>

<hr>
<h2 id='logistic.mm.aireml'> Logistic mixed model fitting with Penalized Quasi-Likelihood / AIREML </h2><span id='topic+logistic.mm.aireml'></span>

<h3>Description</h3>

<p>Estimate the parameters of a logistic linear mixed model using the Penalized
Quasi-Likelihood with an AIREML step for the linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic.mm.aireml(Y, X = matrix(1, nrow = length(Y)), K, 
                   min_tau, tau, beta, constraint = TRUE, max.iter = 50L, eps = 1e-5,
                   verbose = getOption("gaston.verbose",TRUE), get.P = FALSE, EM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic.mm.aireml_+3A_y">Y</code></td>
<td>
<p> Binary phenotype vector </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_x">X</code></td>
<td>
<p> Covariable matrix. By default, a column of ones to include an intercept in the model </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_k">K</code></td>
<td>
<p> A positive definite matrix or a <code>list</code> of such matrices </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_min_tau">min_tau</code></td>
<td>
<p> Minimal value for model parameter <code class="reqn">\tau</code> (if missing, will be set to <code class="reqn">10^{-6}</code>)</p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_tau">tau</code></td>
<td>
<p> (Optional) Optimization starting point for variance component(s) <code>tau</code> </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_beta">beta</code></td>
<td>
<p> (Optional) Optimization starting point for fixed effect(s) <code>beta</code> </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_constraint">constraint</code></td>
<td>
<p> If <code>TRUE</code>, the model parameters respect the contraints given by <code>min_tau</code> </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_max.iter">max.iter</code></td>
<td>
<p> Maximum number of iterations </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_eps">eps</code></td>
<td>
<p> The algorithm stops when the gradient norm is lower than this parameter </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the algorithm progress </p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_get.p">get.P</code></td>
<td>
<p>If <code>TRUE</code>, the function sends back the last matrix <code class="reqn">P</code> computed in the optimization process</p>
</td></tr>
<tr><td><code id="logistic.mm.aireml_+3A_em">EM</code></td>
<td>
<p>If <code>TRUE</code>, the AIREML step is replaced by an EM step</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the parameters of the following logistic mixed model:
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit}(P[Y=1|X,\omega_1,\ldots,\omega_k])  = X\beta + \omega_1 + \ldots + \omega_k</code>
</p>

<p>with <code class="reqn"> \omega_i \sim N(0,\tau_i K_i) </code> for <code class="reqn"> i \in 1, \dots,k </code>.
</p>
<p>The estimation is based on the Penalized Quasi-Likelihood with an AIREML step for the linear model
(the algorithm is similar to the algorithm described in Chen et al 2016). If <code>EM = TRUE</code>
the AIREML step is replaced by an EM step. In this case the convergence will be much slower, 
you're advised to use a large value of <code>max.iter</code>.
</p>
<p>The variance matrices <code class="reqn">K_1</code>, ..., <code class="reqn">K_k</code>, are specified through the parameter <code>K</code>.
</p>
<p>After convergence, the function also compute Best Linear Unbiased Predictors (BLUPs) for 
<code class="reqn">\beta</code> and <code class="reqn">\omega</code>.
</p>


<h3>Value</h3>

<p>A named list with members:
</p>
<table>
<tr><td><code>tau</code></td>
<td>
<p> Estimate(s) of the model parameter(s) <code class="reqn">\tau_1, \dots, \tau_k</code> </p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p> Number of iterations done </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p> Last computed value of matrix P (see reference) </p>
</td></tr>
<tr><td><code>BLUP_omega</code></td>
<td>
<p> BLUPs of random effects </p>
</td></tr>
<tr><td><code>BLUP_beta</code></td>
<td>
<p> BLUPs of fixed effects <code class="reqn">\beta</code></p>
</td></tr>
<tr><td><code>varbeta</code></td>
<td>
<p> Variance matrix for <code class="reqn">\beta</code> estimates </p>
</td></tr>
</table>
<p>If <code>get.P = TRUE</code>, there is an additional member:
</p>
<table>
<tr><td><code>P</code></td>
<td>
<p>The last matrix <code class="reqn">P</code> computed in the AIREML step</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gilmour, A. R., Thompson, R., &amp; Cullis, B. R. (1995), <em>Average information REML: an efficient algorithm for variance
parameter estimation in linear mixed models</em>, Biometrics, <b>1440-1450</b>
</p>
<p>Chen, Han et al. (2016), <em>Control for Population Structure and Relatedness for Binary Traits in Genetic Association Studies via
Logistic Mixed Models</em>, The American Journal of Human Genetics, <b>653&ndash;666</b></p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="#topic+lmm.diago">lmm.diago</a></code>, <code><a href="#topic+lmm.simu">lmm.simu</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)

# Compute Genetic Relationship Matrix
standardize(x) &lt;- "p"
K &lt;- GRM(x)

# Simulate a quantitative genotype under the LMM
set.seed(1)
mu &lt;- 1 + x %*% rnorm(ncol(x), sd = 2)/sqrt(ncol(x))
pi &lt;- 1/(1+exp(-mu))
y &lt;- 1*( runif(length(pi))&lt;pi )

# Estimates
estimates &lt;- logistic.mm.aireml(y, K = K, verbose = FALSE)
str(estimates)
</code></pre>

<hr>
<h2 id='manhattan'> Manhattan plot </h2><span id='topic+manhattan'></span>

<h3>Description</h3>

<p> Draws a Manhattan plot </p>


<h3>Usage</h3>

<pre><code class='language-R'> manhattan(x, bty = "n", chrom.col = c("black", "gray50"), thinning = TRUE, ... ) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattan_+3A_x">x</code></td>
<td>
<p> A data.frame with columns named <code>chr</code>, <code>pos</code> and <code>p</code>. </p>
</td></tr>
<tr><td><code id="manhattan_+3A_bty">bty</code></td>
<td>
<p> Type of box to draw about the plot. Default is to draw none. </p>
</td></tr>
<tr><td><code id="manhattan_+3A_thinning">thinning</code></td>
<td>
 <p><code>Logical</code>. If <code>TRUE</code>, not all points are displayed. </p>
</td></tr>
<tr><td><code id="manhattan_+3A_chrom.col">chrom.col</code></td>
<td>
<p> Alternating colors for chromosomes. </p>
</td></tr>
<tr><td><code id="manhattan_+3A_...">...</code></td>
<td>
<p> Graphical parameters to be passed to <code>plot</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is only one chromosome value in <code>x$chr</code>, the x-axis will be labeled with the SNP
position. In the general case, the x-axis is labeled with the chromosome name and the color
of the points alternates between the colors in <code>chrom.col</code>.
</p>
<p>The default value <code>bty = "n"</code> should give the best result for GWAS Manhattan plots. 
See <code><a href="graphics.html#topic+par">par</a></code> for other possible values of <code>bty</code> and their meaning.
</p>
<p>The thinning procedure suppress some points to avoid generating too heavy graphs. The user 
should check that setting <code>thinning = FALSE</code> does not change the final aspect of the 
plot. 
</p>


<h3>Value</h3>

<p>An invisible copy of <code>x</code> is returned, in which a column <code>coord</code> has been added  
if there is more than one chromosome value in <code>x$chr</code>. This column contains the x-coordinates of each
SNP on the plot, and should prove helpful to annotate it. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+association.test">association.test</a></code>, <code><a href="#topic+qqplot.pvalues">qqplot.pvalues</a></code>, 
<code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+points.default">points.default</a></code> </p>

<hr>
<h2 id='qqplot.pvalues'> QQ plot of p-values </h2><span id='topic+qqplot.pvalues'></span>

<h3>Description</h3>

<p> Draws a QQ plot of p-values </p>


<h3>Usage</h3>

<pre><code class='language-R'> qqplot.pvalues(p, col.abline = "red", CB = TRUE, col.CB = "gray80", 
                       CB.level = 0.95, thinning = TRUE, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot.pvalues_+3A_p">p</code></td>
<td>
<p> A vector of p-values, or a data.frame with a column named <code>p</code> </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_col.abline">col.abline</code></td>
<td>
<p> Color of the line of slope 1. Set to <code>NA</code> to suppress. </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_cb">CB</code></td>
<td>
 <p><code>Logical</code>. If <code>TRUE</code>, a confidence band is included in the plot. </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_col.cb">col.CB</code></td>
<td>
<p> The color of the confidence band. </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_cb.level">CB.level</code></td>
<td>
<p> The level of the confidence band. </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_thinning">thinning</code></td>
<td>
 <p><code>Logical</code>. If <code>TRUE</code>, not all points are displayed. </p>
</td></tr>
<tr><td><code id="qqplot.pvalues_+3A_...">...</code></td>
<td>
<p> Graphical parameters to be passed to <code>plot</code> and <code>points</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p> The QQ plot is on the <code class="reqn">-\log_{10}</code> scale, as is usual when reporting
GWAS results. 
</p>
<p>The confidence band is not a global confidence region: it is the mere juxtaposition 
of confidence intervals for each quantile. Moreover it assumes independance of the
p-values, an hypothesis hich is false for the p-values resulting from an association 
test in presence of linkage disequilibrium. Therefore, the probability that some of the
points lie outsite of this band is greater that <code>CB.level</code>.
</p>
<p>The thinning procedure suppress some points to avoid generating too heavy graphs. The user 
should check that setting <code>thinning = FALSE</code> does not change the final aspect of the 
QQ plot. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+association.test">association.test</a></code>, <code><a href="#topic+manhattan">manhattan</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code>, 
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+points.default">points.default</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># a vector of uniform p-values
p &lt;- runif(1e6)
qqplot.pvalues(p)
# if we don't thin the points, using pch = "." is advised
qqplot.pvalues(p, pch = ".", cex = 2, thinning = FALSE)
</code></pre>

<hr>
<h2 id='random.pm'> Random square definite positive matrix </h2><span id='topic+random.pm'></span>

<h3>Description</h3>

<p> Generate a random definite positive matrix with specified dimension </p>


<h3>Usage</h3>

<pre><code class='language-R'> random.pm(n, values) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.pm_+3A_n">n</code></td>
<td>
<p> Dimension of matrix </p>
</td></tr>
<tr><td><code id="random.pm_+3A_values">values</code></td>
<td>
<p> (Optional) A numeric vector of dimension n : the eigenvalues of the matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>values</code> isn't given, it is chosen (deterministically) 
so that the eigenvalues of the resulting matrix are 
similar to eigenvalues observed on Genetic Relationship Matrices.
</p>
<p>The random matrix is generated as <code class="reqn"> U diag( values ) U' </code>
with <code class="reqn">U</code> a random orthogonal matrix.
</p>


<h3>Value</h3>

<p>A named list with members:
</p>
<table>
<tr><td><code>K</code></td>
<td>
<p> A <code>n x n</code> symmetric positive matrix </p>
</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p> The eigen decomposition of <code>K</code> as <code>eigen(K)</code> would output it </p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.simu">lmm.simu</a></code>, <code><a href="base.html#topic+eigen">eigen</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a random positive matrix 
set.seed(1)
R &lt;- random.pm(500)
str(R)
</code></pre>

<hr>
<h2 id='read.bed.matrix'> Read a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+read.bed.matrix'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+bed.matrix">bed.matrix</a></code> from a <code>.bed</code> file, and either
a <code>.rds</code> file or a <code>.bim</code> and a <code>.fam</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.bed.matrix(basename, bed = paste(basename, ".bed", sep=""), 
                          fam = paste(basename, ".fam", sep=""),
                          bim = paste(basename, ".bim", sep=""), 
                          rds = paste(basename, ".rds", sep=""),
                          verbose = getOption("gaston.verbose",TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.bed.matrix_+3A_basename">basename</code></td>
<td>
<p> Basename of all files </p>
</td></tr>
<tr><td><code id="read.bed.matrix_+3A_bed">bed</code></td>
<td>
<p> Name of the <code>.bed</code> file </p>
</td></tr>
<tr><td><code id="read.bed.matrix_+3A_fam">fam</code></td>
<td>
<p> Name of the <code>.fam</code> file </p>
</td></tr>
<tr><td><code id="read.bed.matrix_+3A_bim">bim</code></td>
<td>
<p> Name of the <code>.bim</code> file </p>
</td></tr>
<tr><td><code id="read.bed.matrix_+3A_rds">rds</code></td>
<td>
<p> Name of the <code>.rds</code> file (ignored if <code>NULL</code>) </p>
</td></tr>
<tr><td><code id="read.bed.matrix_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function actions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>.bed</code>, <code>.fam</code> and <code>.bim</code> files follow the PLINK specifications
(<a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>).
</p>
<p>If a <code>.rds</code> file exists (created by <code>write.bed.matrix</code>), 
the <code>.fam</code> and <code>.bim</code> files will be ignored. 
To ignore an existing <code>.rds</code> file, set <code>rds = NULL</code>.
</p>
<p>If the <code>.bed</code> file does not exist, and <code>basename</code> ends by <code>".bed"</code>,
the function will try to generate a new basename by trimming the extension out. This
allows to write <code>read.bed.matrix("file.bed")</code> instead of <code>read.bed.matrix("file")</code>.
</p>
<p>If the option <code>gaston.auto.set.stats</code> is set to <code>TRUE</code> (the default), 
the function <code>set.stats</code> will be called before returning the <code>bed.matrix</code>,
unless a <code>.rds</code> file is present: in this case, the <code>bed.matrix</code> obtained
is identical to the <code>bed.matrix</code> saved with <code>write.bed.matrix</code>.
</p>


<h3>Value</h3>

<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+write.bed.matrix">write.bed.matrix</a></code>, <code><a href="#topic+set.stats">set.stats</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Read RDS and bed files
x &lt;- read.bed.matrix( system.file("extdata", "LCT.bed", package="gaston") )
x
</code></pre>

<hr>
<h2 id='read.vcf'> Create a <code><a href="#topic+bed.matrix">bed.matrix</a></code> from VCF files </h2><span id='topic+read.vcf'></span>

<h3>Description</h3>

<p> Create a <code><a href="#topic+bed.matrix">bed.matrix</a></code> from a <code>.vcf</code> file.</p>


<h3>Usage</h3>

<pre><code class='language-R'> read.vcf(file, max.snps, get.info = FALSE, convert.chr = TRUE, 
                 verbose = getOption("gaston.verbose",TRUE)) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.vcf_+3A_file">file</code></td>
<td>
<p> The name of the VCF file to read</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_max.snps">max.snps</code></td>
<td>
<p> The maximal number of SNPs to read </p>
</td></tr>
<tr><td><code id="read.vcf_+3A_get.info">get.info</code></td>
<td>
<p> If <code>TRUE</code>, the INFO field from the VCF file will integrated
in <code>@ped$info</code></p>
</td></tr>
<tr><td><code id="read.vcf_+3A_convert.chr">convert.chr</code></td>
<td>
<p> If <code>TRUE</code>, chromosomes ids <code>"X"</code>, <code>"Y"</code> and <code>"MT"</code>
will be converted in their numeric equivalents</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function progress </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vcf format is described in <a href="https://github.com/samtools/hts-specs">https://github.com/samtools/hts-specs</a>
</p>
<p>In addition to the usual data in the slot <code>@snps</code>, the bed.matrices produced by <code>read.vcf</code> have
<code>@snps$quality</code> and <code>@snps$filter</code> columns corresponding to the QUAL and FILTER fields in the VCF
file. If <code>get.info = TRUE</code>, an additionnal column <code>@snps$info</code> is added, corresponding to the
INFO field.
</p>
<p>The information about individuals in VCF files is incomplete: in the slot <code>@ped</code>, the columns
<code>@ped$famid</code> and <code>@ped$id</code> will both contain the sample id; sex and phenotypes will be set
to unknown.
</p>
<p>The function currently assumes that the <code>GT</code> field is the first field in the genotypes format.
If it is not the case, the variants are discarded.
</p>


<h3>Value</h3>

<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.bed.matrix">read.bed.matrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read vcf file (from file name)
filepath &lt;-system.file("extdata", "LCT.vcf.gz", package="gaston")
x1 &lt;- read.vcf( filepath )
x1
</code></pre>

<hr>
<h2 id='reshape.GRM'> Reshape a Genetic Relationship Matrix</h2><span id='topic+reshape.GRM'></span>

<h3>Description</h3>

<p>Reshapes a GRM into a data frame listing relationship of (possibly all) pairs of individuals.
Options are provided to specify ranges of relationship values to include or exclude. This
is useful in the Quality Control process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> reshape.GRM(K, include = c(-Inf, +Inf), exclude) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape.GRM_+3A_k">K</code></td>
<td>
<p> A symmetric matrix (such as produced by <code><a href="#topic+GRM">GRM</a></code>) </p>
</td></tr>
<tr><td><code id="reshape.GRM_+3A_include">include</code></td>
<td>
<p> Range of values to include (default is to include all values) </p>
</td></tr>
<tr><td><code id="reshape.GRM_+3A_exclude">exclude</code></td>
<td>
<p> Range of values to exclude (default it to exclude nothing) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relationship between individuals <code class="reqn">i</code> and <code class="reqn">j</code> is the coefficient <code class="reqn">k_{ij}</code>
in the matrix <code class="reqn">K</code>. The functions lists all pair <code class="reqn">i, j</code> with <code class="reqn">i &lt; j</code> and <code class="reqn">k_{ij}</code>
in the range defined by <code>include</code> and outside the range defined by <code>exclude</code>. 
</p>


<h3>Value</h3>

<p>A data frame with three columns named <code>i</code>, <code>j</code>, <code>k</code>.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+GRM">GRM</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># load chr2 data set (~10k SNPs in low LD)
x &lt;- read.bed.matrix( system.file("extdata", "chr2.bed", package="gaston") )

# Compute Genetic Relationship Matrix
K &lt;- GRM(x)

# List all pairs if individuals with a relationship above 0.07
pairs &lt;- reshape.GRM(K, exclude = c(-Inf, 0.07))

# Exclude first individual from each such pair
x1 &lt;- x[ -pairs$i, ]
</code></pre>

<hr>
<h2 id='score.fixed.linear+2Fscore.fixed.logistic'> Score Test for Covariates with Fixed Effects in Linear or Logistic Mixed Model </h2><span id='topic+score.fixed.linear'></span><span id='topic+score.fixed.logistic'></span>

<h3>Description</h3>

<p> Score Test for association between covariates and phenotype.</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
score.fixed.linear(x, Y, X = matrix(1, length(Y)), K, ...)
score.fixed.logistic(x, Y, X = matrix(1, length(Y)), K, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.fixed.linear+2B2Fscore.fixed.logistic_+3A_x">x</code></td>
<td>
<p> A matrix of covariates </p>
</td></tr>
<tr><td><code id="score.fixed.linear+2B2Fscore.fixed.logistic_+3A_y">Y</code></td>
<td>
<p> The phenotype vector </p>
</td></tr>
<tr><td><code id="score.fixed.linear+2B2Fscore.fixed.logistic_+3A_x">X</code></td>
<td>
<p> A covariable matrix. The default is a column vector of ones, to include an intercept in the model </p>
</td></tr>
<tr><td><code id="score.fixed.linear+2B2Fscore.fixed.logistic_+3A_k">K</code></td>
<td>
<p> A positive definite matrix or a <code>list</code> of such matrices </p>
</td></tr>
<tr><td><code id="score.fixed.linear+2B2Fscore.fixed.logistic_+3A_...">...</code></td>
<td>
<p> Optional arguments used to fit null model in <code>lmm.aireml</code> or <code>logistic.mm.aireml</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>score.fixed.linear</code> considers the linear mixed model
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\alpha + x\beta + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>whereas the <code>score.fixed.logistic</code> function considers the following logistic model
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit}(P[Y=1|X,x,\omega_1,\ldots,\omega_k])  = X\alpha + x\beta + \omega_1 + \ldots + \omega_k</code>
</p>

<p>with <code class="reqn"> \omega_j \sim N(0,\tau_j K_j) </code> where <code class="reqn">K_j</code> are Genetic Relationship Matrix (GRM), <code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>
and fixed effects <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>
<p>The two functions give score test for
<code class="reqn">H_0</code> : <code class="reqn">\beta=0</code> vs <code class="reqn">H_1</code> : <code class="reqn">\beta\neq 0</code>.  
In this aim, all parameters under null model are estimated with <code>lmm.aireml</code> or <code>logistic.mm.aireml</code>.
</p>


<h3>Value</h3>

<p>A named list of values:
</p>
<table>
<tr><td><code>score</code></td>
<td>
<p> Estimated score </p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p> The corresponding p-value </p>
</td></tr>
<tr><td><code>log.p</code></td>
<td>
<p> The logarithm of corresponding p-value </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)
standardize(x) &lt;- "p"

# Calculate GRM et its eigen decomposition
k &lt;- GRM(x)
eig &lt;- eigen(k)
eig$values &lt;- round(eig$values, 5)

# generate covariate matrix
set.seed(1)
X &lt;- cbind( rbinom(nrow(x), 1, prob=1/2), rnorm(nrow(x)) )


# simulate quantitative phenotype with polygenic component and covariate effects
y &lt;- X %*% c(-1,0.5) + lmm.simu(0.3,1,eigenK=eig)$y

t &lt;- score.fixed.linear(X, y, K=k, verbose=FALSE)
str(t)


# simulate binary phenotype with polygenic component and covariate effects
mu &lt;- X %*% c(-1,0.5) + lmm.simu(1, 0, eigenK=eig)$y
pi &lt;- 1/(1+exp(-mu))
y &lt;- 1*( runif(length(pi))&lt;pi )

tt &lt;- score.fixed.logistic(X, y, K=k, verbose=FALSE)
str(tt)
</code></pre>

<hr>
<h2 id='score.variance.linear+2Fscore.variance.logistic'> Variance Component Test in Linear or Logistic Mixed Model</h2><span id='topic+score.variance.linear'></span><span id='topic+score.variance.logistic'></span>

<h3>Description</h3>

<p> Test if a variance component is significaly different from 0 using score test in a Linear or Logistic Mixed Model. </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
score.variance.linear(K0, Y, X = matrix(1, length(Y)), K, acc_davies=1e-10, ...)
score.variance.logistic(K0, Y, X = matrix(1, length(Y)), K, acc_davies=1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_k0">K0</code></td>
<td>
<p> A positive definite matrix </p>
</td></tr>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_y">Y</code></td>
<td>
<p> The phenotype vector </p>
</td></tr>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_x">X</code></td>
<td>
<p> A covariate matrix. The default is a column vector of ones, to include an intercept in the model </p>
</td></tr>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_k">K</code></td>
<td>
<p> A positive definite matrix or a <code>list</code> of such matrices </p>
</td></tr>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_acc_davies">acc_davies</code></td>
<td>
<p> Accuracy in Davies method used to compute p-value </p>
</td></tr>
<tr><td><code id="score.variance.linear+2B2Fscore.variance.logistic_+3A_...">...</code></td>
<td>
<p> Optional arguments used to fit null model with <code>lmm.aireml</code> of <code>logistic.mm.aireml</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>score.variance.linear</code>, we consider the linear mixed model
</p>
<p style="text-align: center;"><code class="reqn"> Y = X\alpha + \gamma + \omega_1 + \ldots + \omega_k + \varepsilon </code>
</p>

<p>or, in <code>score.variance.logistic</code>, we consider the following logistic model
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{logit}(P[Y=1|X,x,\omega_1,\ldots,\omega_k]) = X\alpha + \gamma + \omega_1 + \ldots + \omega_k</code>
</p>

<p>with <code class="reqn"> \gamma\sim N(0,\kappa K_0)\gamma</code>, <code class="reqn"> \omega_j \sim N(0,\tau_j K_j) </code>,
<code class="reqn"> \varepsilon \sim N(0,\sigma^2 I_n) </code>.
<code class="reqn">K_0</code> and <code class="reqn">K_j</code> are Genetic Relationship Matrix (GRM).  
</p>
<p><code>score.variance.linear </code> and <code>score.variance.logistic</code> functions permit to test
</p>
<p style="text-align: center;"><code class="reqn">H_0 : \kappa=0 \mbox{ vs } H_1 : \kappa&gt;0</code>
</p>

<p>with, for linear mixed model, the score
</p>
<p style="text-align: center;"><code class="reqn"> Q = Y'P_OK_0P_0Y/2 </code>
</p>

<p>or, for logistic mixed model, the score
</p>
<p style="text-align: center;"><code class="reqn"> Q = (Y-\pi_0)'K_0(Y-\pi_0)/2 </code>
</p>

<p>where <code class="reqn">P_0</code> is the last matrix <code class="reqn">P</code> computed in the optimization process for null model and <code class="reqn">\pi_0</code> the vector of fitted values under null logistic model.
</p>
<p>The associated p-value is computed with Davies method.
</p>
<p>In this aim, all parameters under null model are estimated with <code>lmm.aireml</code> or <code>logistic.mm.aireml</code>.
The p-value corresponding to the estimated score is computed using Davies method implemented in 'CompQuadForm' R package.
</p>


<h3>Value</h3>

<p>A named list of values:
</p>
<table>
<tr><td><code>score</code></td>
<td>
<p> Estimated score </p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p> The corresponding p-value </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>References</h3>

<p>Davies R.B. (1980) <em>Algorithm AS 155: The Distribution of a Linear Combination of chi-2 Random Variables</em>,
Journal of the Royal Statistical Society. Series C (Applied Statistics), <b>323-333</b></p>


<h3>See Also</h3>

 <p><code><a href="#topic+lmm.aireml">lmm.aireml</a></code>, <code><a href="#topic+logistic.mm.aireml">logistic.mm.aireml</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(AGT)
x &lt;- as.bed.matrix(AGT.gen, AGT.fam, AGT.bim)
standardize(x) &lt;- "p"

# Calculate GRM et its eigen decomposition
K0 &lt;- GRM(x)
eig &lt;- eigen(K0)
eig$values &lt;- round(eig$values, 5)

# generate an other positive matrix (to play the role of the second GRM)
set.seed(1)
R &lt;- random.pm(nrow(x))


# simulate quantitative phenotype with two polygenic components
y &lt;- lmm.simu(0.1,1,eigenK=eig)$y + lmm.simu(0.2,0,eigenK=R$eigen)$y

t &lt;- score.variance.linear(K0, y, K=R$K, verbose=FALSE)
str(t)


# simulate binary phenotype with two polygenic components
mu &lt;- lmm.simu(0.1,0.5,eigenK=eig)$y + lmm.simu(0.2,0,eigenK=R$eigen)$y
pi &lt;- 1/(1+exp(-mu))
y &lt;- 1*(runif(length(pi))&lt;pi)

tt &lt;- score.variance.logistic(K0, y, K=R$K, verbose=FALSE)
str(tt)
</code></pre>

<hr>
<h2 id='select.inds'> Subsetting from a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+select.inds'></span>

<h3>Description</h3>

<p>Returns subset of individuals satisfying a condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> select.inds(x, condition) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.inds_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="select.inds_+3A_condition">condition</code></td>
<td>
<p> Condition used to select individuals </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditions can involve global variables and all variables defined
in the data frame <code>x@ped</code>, in particular
</p>

<ul>
<li> <p><code>famid</code>, <code>id</code>, <code>father</code>, <code>mother</code>, <code>sex</code>, <code>pheno</code>
</p>
</li>
<li><p> If basic stats have been computed (see <code><a href="#topic+set.stats">set.stats</a></code>), 
<code>N0</code>, <code>N1</code>, <code>N2</code>, <code>NAs</code>, <code>callrate</code>, etc.
</p>
</li></ul>

<p>If some condition evaluate to <code>NA</code> (e.g. <code>sex == 1</code> when <code>sex</code> is undefined for some individuals), 
a warning is issued and the corresponding individuals are removed.
</p>


<h3>Value</h3>

<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, containing the selected individuals only </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+select.snps">select.snps</a></code>, <code><a href="#topic+set.stats">set.stats</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)

# Select individuals with a call rate &gt; 95% 
# and more than 5% of heterozygous genotypes
y &lt;- select.inds(x, callrate &gt; 0.95 &amp; N1/(N0+N1+N2) &gt; 0.05)
y
</code></pre>

<hr>
<h2 id='select.snps'> Subsetting from a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+select.snps'></span>

<h3>Description</h3>

<p>Returns subset of SNPs satisfying a condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> select.snps(x, condition) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.snps_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="select.snps_+3A_condition">condition</code></td>
<td>
<p> Condition used to select SNPs </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditions can involve global variables and all variables defined
in the data frame <code>x@snps</code>, in particular
</p>

<ul>
<li> <p><code>chr</code>, <code>id</code>, <code>dist</code>, <code>pos</code>, <code>A1</code>, <code>A2</code>
</p>
</li>
<li><p> If basic stats have been computed (see <code><a href="#topic+set.stats">set.stats</a></code>), <code>N0</code>, <code>N1</code>, <code>N2</code>, <code>NAs</code>, <code>callrate</code>, <code>maf</code>, <code>hz</code>, etc.
</p>
</li>
<li><p> If Hardy-Weinberg Equilibrium test has been performed (see <code><a href="#topic+set.hwe">set.hwe</a></code>), <code>hwe</code>.
</p>
</li></ul>

<p>If some condition evaluate to <code>NA</code> (e.g. <code>maf &gt; 0</code> when <code>maf</code> is undefined for some SNPs), 
a warning is issued and the corresponding SNPs are removed.
</p>


<h3>Value</h3>

<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, containing the selected SNPs only </p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+select.snps">select.snps</a></code>, <code><a href="#topic+set.stats">set.stats</a></code>, <code><a href="#topic+set.hwe">set.hwe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)

# Select SNPs with a maf &gt; 5%
y &lt;- select.snps(x, maf &gt; 0.05)
y
</code></pre>

<hr>
<h2 id='set.dist'> Set Genetic Distance </h2><span id='topic+set.dist'></span>

<h3>Description</h3>

<p>Returns an updated <code><a href="#topic+bed.matrix">bed.matrix</a></code> with genetic 
distances in centimorgan computed from the variant positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'> set.dist(x, map, verbose = getOption("gaston.verbose", TRUE)) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.dist_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="set.dist_+3A_map">map</code></td>
<td>
<p> The genetic map, given by a list of data frames (see Details) </p>
</td></tr>
<tr><td><code id="set.dist_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function actions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A map is a list of data frames, with names corresponding to chromosomes.
Each of these data frames must have columns <code>pos</code> and <code>dist</code> corresponding
to positions in bp and cM, respectively.
</p>
<p>Such maps are too large to be included in a CRAN package. You can get two genetic
maps for the Human Genome (build 36 and 37) in the package <code>HumanGeneticMap</code>  
on GitHub.
</p>
<p>To install this package, run
</p>
<p><code> install.packages("HumanGeneticMap", repos="https://genostats.github.io/R/") </code>
</p>
<p>You can then use this function with <code>set.dist(x, HumanGeneticMap::genetic.map.b36)</code>
for example, for positions on the build 36. Use <code>map = HumanGeneticMap::genetic.map.b37</code>) 
for the build 37.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, with updated values in <code>x@snps$dist</code>.
</p>

<hr>
<h2 id='set.genomic.sex'> Genomic Sex </h2><span id='topic+set.genomic.sex'></span>

<h3>Description</h3>

<p>Returns an updated <code><a href="#topic+bed.matrix">bed.matrix</a></code> with a new variable for the genomic sex
of each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> set.genomic.sex(x, plot = FALSE, verbose = getOption("gaston.verbose",TRUE)) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.genomic.sex_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="set.genomic.sex_+3A_plot">plot</code></td>
<td>
<p> If <code>TRUE</code>, plots the variables used for the clustering </p>
</td></tr>
<tr><td><code id="set.genomic.sex_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, displays information on the function actions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each individual, the function uses the hetorozygosity rate for SNPs on X chromosome, 
and the call rate for SNPs on the Y chromosomes (both statistics computed by <code><a href="#topic+set.stats">set.stats</a></code>), 
to cluster the individuals using <code><a href="stats.html#topic+kmeans">kmeans</a></code>. 
</p>
<p>If <code>plot = TRUE</code>, a plot is produced with the two variables used and the clusters
determined by <code><a href="stats.html#topic+kmeans">kmeans</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, with a new variable <code>x@ped$genomic.sex</code>
containing the genomic sex for each individual.
</p>


<h3>Author(s)</h3>

<p>Hervé Perdry</p>


<h3>See Also</h3>

 <p><code><a href="#topic+set.stats">set.stats</a></code>, <code><a href="#topic+set.hwe">set.hwe</a></code> </p>

<hr>
<h2 id='set.hwe'> Hardy-Weinberg Equilibrium </h2><span id='topic+set.hwe'></span>

<h3>Description</h3>

<p>Returns an updated <code><a href="#topic+bed.matrix">bed.matrix</a></code> with a new variable for the <code class="reqn">p</code>-values of an
Hardy-Weinberg Equilibrium test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> set.hwe(x, method = c("chisquare", "exact"),
           verbose = getOption("gaston.verbose", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.hwe_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="set.hwe_+3A_method">method</code></td>
<td>
<p> The method to use, either &quot;chisquare&quot; or &quot;exact&quot;  </p>
</td></tr>
<tr><td><code id="set.hwe_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function actions </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two tests of Hardy-Weinberg Equilibrium are proposed:
</p>

<ul>
<li><p> if <code>method = "chisquare"</code>, the good old Chi-square test
</p>
</li>
<li><p> if <code>method = "exact"</code>, Haldane's exact test (see Wigginton et al)
</p>
</li></ul>

<p>The function <code>set.stats</code> will be called first if necessary.
</p>
<p>The <code class="reqn">p</code>-value is set to <code class="reqn">1.0</code> for SNPs on chromosomes Y and MT. For SNPs on
chromosomes X, currently, the test is performed using only the genotypic counts of women.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, with a new variable <code>x@snps$hwe</code>
containing the <code class="reqn">p</code>-values for each SNP.
</p>


<h3>Author(s)</h3>

<p>Hervé Perdry and Claire Dandine-Roulland</p>


<h3>References</h3>

<p> Wigginton, J. E., Cutler, D. J., &amp; Abecasis, G. R. (2005). <em>A note on exact tests of Hardy-Weinberg equilibrium</em>. The American Journal of Human Genetics, <b>76(5)</b>, <b>887-893</b> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+set.stats">set.stats</a></code>, <code><a href="#topic+set.genomic.sex">set.genomic.sex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)

# Compute Hardy-Weinberg p-values
x &lt;- set.hwe(x)
head( x@snps[,c("id","hwe")] )
</code></pre>

<hr>
<h2 id='set.stats'> Basic statistics for a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+set.stats'></span><span id='topic+set.stats.ped'></span><span id='topic+set.stats.snps'></span>

<h3>Description</h3>

<p>Return an updated <code><a href="#topic+bed.matrix">bed.matrix</a></code> with new variables for 
several basic statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.stats(x, set.p = TRUE, set.mu_sigma = TRUE, 
          verbose = getOption("gaston.verbose",TRUE))

set.stats.snps(x, set.p = TRUE, set.mu_sigma = TRUE, 
               verbose = getOption("gaston.verbose",TRUE)) 

set.stats.ped(x, verbose = getOption("gaston.verbose",TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.stats_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="set.stats_+3A_set.p">set.p</code></td>
<td>
<p> If <code>TRUE</code>, <code>x@p</code> is updated </p>
</td></tr>
<tr><td><code id="set.stats_+3A_set.mu_sigma">set.mu_sigma</code></td>
<td>
<p> If <code>TRUE</code>, <code>x@mu</code> and <code>x@sigma</code> are updated </p>
</td></tr>
<tr><td><code id="set.stats_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code>, display information on the function actions </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set.stats</code> is called by default by all functions that create a bed.matrix, unless
the global option <code>gaston.auto.set.stats</code> is <code>FALSE</code> (cf example below).
</p>
<p><code>set.stats</code> and <code>set.stats.ped</code> update <code>x@ped</code>, adding the following variables: 
</p>

<ul>
<li> <p><code>N0</code>, <code>N1</code>, <code>N2</code> and <code>NAs</code> give for each individual the number of 
autosomal SNPs with a genotype equal to 0, 1, 2 and missing, respectively
</p>
</li>
<li> <p><code>N0.x</code>, <code>N1.x</code>, <code>N2.x</code> and <code>NAs.x</code> idem for chromosome X
</p>
</li>
<li> <p><code>N0.y</code>, <code>N1.y</code>, <code>N2.y</code> and <code>NAs.y</code> idem for chromosome Y
</p>
</li>
<li> <p><code>N0.mt</code>, <code>N1.mt</code>, <code>N2.mt</code> and <code>NAs.mt</code> idem for mitochondrial SNPs
</p>
</li>
<li> <p><code>callrate</code>, <code>callrate.x</code>, <code>callrate.y</code>, <code>callrate.mt</code> 
is the individual callrate for autosomal, X, Y, mitochondrial SNPs
</p>
</li>
<li> <p><code>hz</code>, <code>hz.x</code>, <code>hz.y</code>, <code>hz.mt</code> is the individual heterozygosity 
for autosomal, X, Y, mitochondrial SNPs
</p>
</li></ul>

<p><code>set.stats</code> and <code>set.stats.snps</code> update <code>x@snps</code>, adding the following variables:
</p>

<ul>
<li> <p><code>N0</code>, <code>N1</code>, <code>N2</code> and <code>NAs</code> give for each SNP the number of individuals
with a genotype equal to 0, 1, 2 and missing, respectively
</p>
</li>
<li> <p><code>N0.f</code>, <code>N1.f</code>, <code>N2.f</code> and <code>NAs.f</code> give, only for SNPs on chromosome X, 
the number of female individuals with a genotype equal to 0, 1, 2 and missing, respectively
</p>
</li>
<li> <p><code>callrate</code> is the SNP callrate (for Y linked SNPs, the callrate is computed usin
males only).
</p>
</li>
<li> <p><code>maf</code> is the Minor Allele Frequency 
</p>
</li>
<li> <p><code>hz</code> is the SNP heterozygosity (for X linked SNPs, the heterozygosity is computed
using females only).
</p>
</li></ul>

<p>If <code>set.p = TRUE</code>, <code>x@p</code> is updated with the alternate allele frequency.
</p>
<p>If <code>set.mu_sigma = TRUE</code>, <code>x@mu</code> is updated with the genotype mean (equal to <code>2*x@p</code>)
and <code>x@sigma</code> with the genotype standard deviation (should be approximately <code>sqrt(2*x@p*(1-x@p))</code>
under Hardy-Weinberg Equilibrium).
</p>


<h3>Value</h3>

 
<p>A <code><a href="#topic+bed.matrix">bed.matrix</a></code> similar to <code>x</code>, with slots updated as described above.
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+set.hwe">set.hwe</a></code>, <code><a href="#topic+set.genomic.sex">set.genomic.sex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Disable auto set stats :
options(gaston.auto.set.stats = FALSE)

# Load data
data(TTN)
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)
str(x@ped)
str(x@snps)

# Compute statistics
x &lt;- set.stats(x)
str(x@ped)
str(x@snps)

# restore default behavior
options(gaston.auto.set.stats = TRUE)
</code></pre>

<hr>
<h2 id='SNP.duplicated'> Duplicated SNPs </h2><span id='topic+SNP.duplicated'></span>

<h3>Description</h3>

<p> Determines which SNPs are duplicates of previous SNPs
and returns their indices. </p>


<h3>Usage</h3>

<pre><code class='language-R'> SNP.duplicated(x, by = "chr:pos") </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNP.duplicated_+3A_x">x</code></td>
<td>
<p> A bed.matrix or a data.frame </p>
</td></tr>
<tr><td><code id="SNP.duplicated_+3A_by">by</code></td>
<td>
<p> The criterium used to determined if SNP is duplicated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is a bed.matrix, the data.frame <code>x@bed</code> will be used.
The columns that will be taken in consideration
Are <code>id</code>, <code>chr</code>, <code>pos</code>, <code>A1</code>, and <code>A2</code>. Not all columns
are mandatory, depending on the value of <code>by</code>.
</p>
<p>The possible values for <code>by</code> are <code>"chr:pos"</code>, <code>"chr:pos:alleles"</code>, <code>"id"</code>, 
<code>"id:chr:pos"</code> and <code>"id:chr:pos:alleles"</code>. 
The default is <code>by = "chr:pos"</code>, which means that two SNPs are considered as duplicated if they have
same <code>chr</code> and <code>pos</code> values. 
</p>
<p>Currently, when using a criterium involving alleles, this function does not consider the possibility
of alleles swaps or reference strand flips.
</p>


<h3>Value</h3>

<p>An integer vector of indices of SNPs which are duplicates of previously seen SNPs. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+SNP.match">SNP.match</a></code> </p>

<hr>
<h2 id='SNP.match'> SNP matching </h2><span id='topic+SNP.match'></span>

<h3>Description</h3>

<p> Returns a vector of the positions of (first) SNP matching of
its first argument in its second. </p>


<h3>Usage</h3>

<pre><code class='language-R'> SNP.match(x, table, by = "chr:pos:alleles") </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNP.match_+3A_x">x</code></td>
<td>
<p> A bed.matrix or a data.frame</p>
</td></tr>
<tr><td><code id="SNP.match_+3A_table">table</code></td>
<td>
<p> A bed.matrix or a data.frame</p>
</td></tr>
<tr><td><code id="SNP.match_+3A_by">by</code></td>
<td>
<p> The criterium used to matchSNPs </p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is a bed.matrix, the data.frame <code>x@bed</code> will be used; the 
same holds for <code>table</code>. The columns that will be taken in consideration
are <code>id</code>, <code>chr</code>, <code>pos</code>, <code>A1</code>, and <code>A2</code>. Not all columns
are mandatory (see below). 
</p>
<p>The matching criterium is specified by parameter <code>by</code>.
There are 5 possible criteria : (i) matching by chromosome and position 
with <code>by = "chr:pos"</code>, (ii) matching by chromosome, position, and alleles
with <code>by = "chr:pos:alleles"</code>, (iii) matching by id with <code>by = "id"</code>,
(iv) matching by id, chromosome and position with <code>by  = "id:chr:pos"</code>, 
and (v) matching by id, chromosome, position and alleles with <code>by = "id:chr:pos:alleles"</code>.
</p>
<p>For each SNP in <code>x</code>, the function looks for the position of the first
matching SNP in <code>table</code>. If alleles are included in the matching criterium
(ie if allele columns <code>A1</code> and <code>A2</code> are present in x), the function 
also checks for SNP matching with swapped alleles (a SNP A/C would match a 
SNP C/A), or with reference strand flipped (i.e. a SNP A/C would match a SNP T/G) 
or both (a SNP A/C would match a SNP G/T).
</p>
<p>This function should prove useful for data set merging.
</p>


<h3>Value</h3>

<p>A named list with one or three members, depending on whether alleles are included
in the matching criterium.
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>An integer vector giving the position of first match in <code>table</code>, or <code>NA</code> if there is no match</p>
</td></tr>
<tr><td><code>swap</code></td>
<td>
<p>A logical vector indicating whether the match is with swapped alleles</p>
</td></tr>
<tr><td><code>flip</code></td>
<td>
<p>A logical vector indicating whether the match is with flipped strand</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+SNP.duplicated">SNP.duplicated</a></code> </p>

<hr>
<h2 id='SNP.rm.duplicates'> Remove duplicated SNPs </h2><span id='topic+SNP.rm.duplicates'></span>

<h3>Description</h3>

<p> Remove duplicated SNPs, taking into account possible genotype mismatches </p>


<h3>Usage</h3>

<pre><code class='language-R'> SNP.rm.duplicates(x, by = "chr:pos", na.keep = TRUE, incomp.rm = TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SNP.rm.duplicates_+3A_x">x</code></td>
<td>
<p> A bed.matrix </p>
</td></tr>
<tr><td><code id="SNP.rm.duplicates_+3A_by">by</code></td>
<td>
<p> The criterium used to determine duplicates </p>
</td></tr>
<tr><td><code id="SNP.rm.duplicates_+3A_na.keep">na.keep</code></td>
<td>
<p> If <code>TRUE</code>, duplicated genotypes which are missing for at 
least one SNP are set to <code>NA</code>. </p>
</td></tr>
<tr><td><code id="SNP.rm.duplicates_+3A_incomp.rm">incomp.rm</code></td>
<td>
<p> If <code>TRUE</code>, duplicated SNPs with allele incompatibility are
removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Positions of duplicated SNPs are determined using <code><a href="#topic+SNP.duplicated">SNP.duplicated</a></code>
using parameter <code>by</code> (we recommend to use <code>"chr:pos"</code>, the default).
</p>
<p>Then the function considers the possibility of alleles swaps or reference strand flips.
In case of allele incompatibility, the SNPs can be removed or not (according to <code>incomp.rm</code>
parameter).
</p>
<p>When alleles can be matched, only one of the two SNPs is conserved. If there are 
genotype incompatibilities between the duplicates for some individuals, these genotypes are set 
to <code>NA</code>. The parameter <code>na.keep</code> settles the case of genotypes missing in one
of the SNPs.
</p>
<p>Moreover the function takes special care of SNP with possible alleles <code>"0"</code>. 
This case occurs for monomorphic SNPs, when data are read from a <code>.ped</code> file; for
example, a whole column of <code>A A</code>'s will result in a SNP with alleles <code>"A"</code> and
<code>"0"</code>. If there's a duplicate of the SNP with a few, says, <code>A C</code>'s in it,
it will have alleles <code>"A"</code> and <code>"C"</code>. In that case, <code><a href="#topic+SNP.duplicated">SNP.duplicated</a></code> 
with <code>by = "chr:pos:alleles"</code> will not consider these SNPs as duplicates. 
</p>


<h3>Value</h3>

<p>A bed.matrix without duplicated SNPs. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+SNP.match">SNP.match</a></code>, <code><a href="#topic+SNP.duplicated">SNP.duplicated</a></code>, <code><a href="#topic+dupli">dupli</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Use example data of 10 individuals with 7 duplicated SNPs
data(dupli)
x &lt;- as.bed.matrix(dupli.gen, fam = dupli.ped, bim = dupli.bim)

# There are any duplicated positions:
dupli.bim

x1 &lt;- SNP.rm.duplicates(x)
# By default (na.keep = TRUE), as soon as the genotype is missing
# in one of the SNPs it is set to missing 
# (here looking at duplicated SNPs 2a and 2b)
as.matrix(x[,2:3])
as.matrix(x1[,2])

# With na.keep = FALSE 
x2 &lt;- SNP.rm.duplicates(x, na.keep = FALSE)
as.matrix(x2[,2])

# Let's examinate SNP 3.a and 3.b (swapped alleles)
as.matrix(x[,4:5])
as.matrix(x1[,3])
as.matrix(x2[,3])

# and so on... (see also ?dupli)
</code></pre>

<hr>
<h2 id='Tests'> Evaluation of a condition on SNPS or individuals in a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+test.inds'></span><span id='topic+test.snps'></span><span id='topic+which.inds'></span><span id='topic+which.snps'></span>

<h3>Description</h3>

<p>Evaluate a condition and return logical vector or indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'> test.snps(x, condition, na.to.false = TRUE) 
        test.inds(x, condition, na.to.false = TRUE) 
        which.snps(x, condition) 
        which.inds(x, condition) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tests_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="Tests_+3A_condition">condition</code></td>
<td>
<p> Condition used to select SNPs </p>
</td></tr>
<tr><td><code id="Tests_+3A_na.to.false">na.to.false</code></td>
<td>
<p> If <code>TRUE</code>, <code>NA</code>s are replaced by <code>FALSE</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditions can involve global variables and all variables defined
in the data frame <code>x@snps</code>, in particular for <code>test.snps</code> and <code>which.snps</code>
</p>

<ul>
<li> <p><code>chr</code>, <code>id</code>, <code>dist</code>, <code>pos</code>, <code>A1</code>, <code>A2</code>
</p>
</li>
<li><p> If basic stats have been computed (see <code><a href="#topic+set.stats">set.stats</a></code>), <code>N0</code>, <code>N1</code>, <code>N2</code>, <code>NAs</code>, <code>callrate</code>, <code>maf</code>, <code>hz</code>, etc.
</p>
</li>
<li><p> If Hardy-Weinberg Equilibrium test has been performed (see <code><a href="#topic+set.hwe">set.hwe</a></code>), <code>hwe</code>.
</p>
</li></ul>

<p>and for  <code>test.inds</code> and <code>which.inds</code>
</p>

<ul>
<li> <p><code>famid</code>, <code>id</code>, <code>father</code>, <code>mother</code>, <code>sex</code>, <code>pheno</code>
</p>
</li>
<li><p> If basic stats have been computed (see <code><a href="#topic+set.stats">set.stats</a></code>),
<code>N0</code>, <code>N1</code>, <code>N2</code>, <code>NAs</code>, <code>callrate</code>, etc.
</p>
</li></ul>



<h3>Value</h3>

 <p><code>test.snps</code> and <code>test.inds</code> return a logical vector of length <code>ncol(x)</code> and <code>nrow(x)</code> respectively. <code>which.snps(x, condition)</code> is
equivalent to <code>which(test.snps(x, condition))</code> and <code>which.inds(x, condition)</code> to <code>which(test.inds(x, condition))</code>.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+select.snps">select.snps</a></code>, <code><a href="#topic+select.inds">select.inds</a></code>, <code><a href="#topic+set.stats">set.stats</a></code>, <code><a href="#topic+set.hwe">set.hwe</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)

# SNPs and individuals with a callrate &lt; 100%
w &lt;- test.snps(x, callrate &lt; 1)
table(w)
which.snps(x, callrate &lt; 1)
which.inds(x, callrate &lt; 1)
</code></pre>

<hr>
<h2 id='TTN'>TTN data set</h2><span id='topic+TTN'></span><span id='topic+TTN.gen'></span><span id='topic+TTN.fam'></span><span id='topic+TTN.bim'></span><span id='topic+TTN.pop'></span>

<h3>Description</h3>

<p>These data have been extracted from the 1000 Genomes data.
The data set contains the genotype matrix <code>TTN.gen</code>, the pedigree matrix <code>TTN.fam</code> and a matrix <code>TTN.bim</code>,
corresponding to 503 individuals of European populations and 733 SNPs on chromosome 2, on a ~600kb segment 
containing the Titin gene. There is also a factor <code>TTN.pop</code>, which gives the population from which each
individual is drawn (CEU = Utah residents of Northern Western European ancestry, FIN = Finnish, GBR = England and Scottland, 
IBS = Iberian, TSI = Toscani).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> data(TTN) </code></pre>


<h3>Format</h3>

<p>There are three data objects in the dataset:
</p>

<dl>
<dt><code>TTN.gen</code></dt><dd><p> Genotype matrix </p>
</dd>
<dt><code>TTN.fam</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.fam</code> file  </p>
</dd>
<dt><code>TTN.bim</code></dt><dd><p> Data frame containing all variables corresponding to a <code>.bim</code> file </p>
</dd>
<dt><code>TTN.pop</code></dt><dd><p> Factor giving the population from which each individual is drawn </p>
</dd>
</dl>



<h3>Source</h3>

<p> The data were obtained from the 1000 Genomes project (see <a href="https://www.internationalgenome.org/">https://www.internationalgenome.org/</a>). </p>


<h3>References</h3>

<p>McVean et al, 2012, <em>An integrated map of genetic variation from 1,092 human genomes</em>, Nature <b>491, 56-65</b> doi:10.1038/nature11632 </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TTN)
x &lt;- as.bed.matrix(TTN.gen, TTN.fam, TTN.bim)
x
</code></pre>

<hr>
<h2 id='write.bed.matrix'> Save a <code><a href="#topic+bed.matrix">bed.matrix</a></code> </h2><span id='topic+write.bed.matrix'></span>

<h3>Description</h3>

<p>Save a <code><a href="#topic+bed.matrix">bed.matrix</a></code> in several files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.bed.matrix(x, basename, bed = paste(basename, ".bed", sep=""),   
                              fam = paste(basename, ".fam", sep=""),
                              bim = paste(basename, ".bim", sep=""), 
                              rds = paste(basename, ".rds", sep=""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.bed.matrix_+3A_x">x</code></td>
<td>
<p> A <code><a href="#topic+bed.matrix">bed.matrix</a></code> </p>
</td></tr>
<tr><td><code id="write.bed.matrix_+3A_basename">basename</code></td>
<td>
<p> Basename of all files </p>
</td></tr>
<tr><td><code id="write.bed.matrix_+3A_bed">bed</code></td>
<td>
<p> Name of the <code>.bed</code> file </p>
</td></tr>
<tr><td><code id="write.bed.matrix_+3A_fam">fam</code></td>
<td>
<p> Name of the <code>.fam</code> file </p>
</td></tr>
<tr><td><code id="write.bed.matrix_+3A_bim">bim</code></td>
<td>
<p> Name of the <code>.bim</code> file </p>
</td></tr>
<tr><td><code id="write.bed.matrix_+3A_rds">rds</code></td>
<td>
<p> Name of the <code>.rds</code> file </p>
</td></tr>
</table>


<h3>Details</h3>

<p> If any of <code>bed</code>, <code>fam</code>, <code>bim</code> and <code>rds</code> is <code>NULL</code>,
the corresponding file will not be written. 
</p>
<p>The <code>.fam</code> and <code>.bim</code> files are useful for reading files with other softwares.
The <code>.rds</code> file can be read by <code>read.bed.matrix</code>.
</p>
<p>The <code>.bed</code>, <code>.fam</code> and <code>.bim</code> files follow the PLINK specifications
(<a href="http://zzz.bwh.harvard.edu/plink/binary.shtml">http://zzz.bwh.harvard.edu/plink/binary.shtml</a>).
</p>


<h3>Author(s)</h3>

<p> Hervé Perdry and Claire Dandine-Roulland </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.bed.matrix">read.bed.matrix</a></code>, <code><a href="base.html#topic+saveRDS">saveRDS</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
data(LCT)
x &lt;- as.bed.matrix(LCT.gen, LCT.fam, LCT.bim)

# Write object in LCT.bed and LCT.RData
## Not run: 
write.bed.matrix(x, "LCT")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
