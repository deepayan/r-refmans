<!DOCTYPE html><html><head><title>Help for package mRpostman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mRpostman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mRpostman-package'><p>An IMAP client for R</p></a></li>
<li><a href='#%&gt;%'><p>Common Pipe operator</p></a></li>
<li><a href='#AND'><p>Relational-operator-function to construct a custom search statement</p></a></li>
<li><a href='#before'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#clean_msg_text'><p>Extract text from MIME level</p></a></li>
<li><a href='#configure_imap'><p>IMAP Connection Configuration</p></a></li>
<li><a href='#decode_mime_header'><p>Decode RFC 2047 quoted-printable and base64 MIME headers and strings</p></a></li>
<li><a href='#flag'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#ImapCon'><p>An IMAP Connection Class</p></a></li>
<li><a href='#larger_than'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#list_attachments'><p>List attachments and content-disposition types</p></a></li>
<li><a href='#metadata_options'><p>Message Metadata Options</p></a></li>
<li><a href='#older_than'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#on'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#OR'><p>Relational-operator-function to construct a custom search statement</p></a></li>
<li><a href='#sent_before'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#sent_on'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#sent_since'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#since'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#smaller_than'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#string'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
<li><a href='#younger_than'><p>Criterion constructor function to be combined in a custom search statement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An IMAP Client for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-17</td>
</tr>
<tr>
<td>Description:</td>
<td>An easy-to-use IMAP client that provides tools for message searching,
    selective fetching of message attributes, mailbox management, attachment extraction, 
    and several other IMAP features, paving the way for e-mail data analysis in R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, R6, stringr, stringi, magrittr, assertthat, base64enc,
utils, rvest, xml2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://allanvc.github.io/mRpostman/">https://allanvc.github.io/mRpostman/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/allanvc/mRpostman/issues/">https://github.com/allanvc/mRpostman/issues/</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libcurl: libcurl-devel (rpm) or
libcurl4-openssl-dev (deb)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-17 07:33:52 UTC; allan</td>
</tr>
<tr>
<td>Author:</td>
<td>Allan Quadros <a href="https://orcid.org/0000-0003-3250-5380"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Paul Smith [ctb],
  Kurt Hornik [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Allan Quadros &lt;allanvcq@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-17 07:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='mRpostman-package'>An IMAP client for R</h2><span id='topic+mRpostman-package'></span><span id='topic+mRpostman'></span>

<h3>Description</h3>

<p><span class="pkg">mRpostman</span> is an easy-to-use IMAP client that provides tools for message searching,
selective fetching of message attributes, mailbox management, attachment extraction,
and several other IMAP features, paving the way for e-mail data analysis in <span class="rlang"><b>R</b></span>.
</p>


<h3>Author(s)</h3>

<p>Author &amp; Mantainer: Allan Quadros <a href="mailto:allanvcq@gmail.com">allanvcq@gmail.com</a>
</p>


<h3>References</h3>

<p>Crispin, M. (2003), <em>INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1</em>, RFC 3501, March 2003, <a href="https://www.rfc-editor.org/rfc/rfc3501">https://www.rfc-editor.org/rfc/rfc3501</a>.
</p>
<p>Heinlein, P. and Hartleben, P. (2008). <em>The Book of IMAP: Building a Mail Server with Courier and Cyrus</em>. No Starch Press. ISBN 978-1-59327-177-0.
</p>
<p>Ooms, J. (2020). <em>curl: A Modern and Flexible Web Client for R</em>. R package version 4.3, <a href="https://CRAN.R-project.org/package=curl">https://CRAN.R-project.org/package=curl</a>.
</p>
<p>Stenberg, D. <em>Libcurl - The Multiprotocol File Transfer Library</em>, <a href="https://curl.se/libcurl/">https://curl.se/libcurl/</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><code>mRpostman official website</code>: <a href="https://allanvc.github.io/mRpostman/">https://allanvc.github.io/mRpostman/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Common Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Common Pipe operator
</p>

<hr>
<h2 id='AND'>Relational-operator-function to construct a custom search statement</h2><span id='topic+AND'></span>

<h3>Description</h3>

<p>Relational-operator-function to construct a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AND(..., negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AND_+3A_...">...</code></td>
<td>
<p>a combination of criteria constructor functions with its arguments.</p>
</td></tr>
<tr><td><code id="AND_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for
&quot;NOT search_criterion&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "30-Ago-2019" AND SMALLER than 512KB.
res &lt;- con$search(request = AND(sent_since(date_char = "30-Ago-2019"),
                                smaller_than(size = 512000)))

## End(Not run)
</code></pre>

<hr>
<h2 id='before'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+before'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>before(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="before_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="before_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages BEFORE "17-Apr-2019" AND NOT SMALLER than 512KB.
res &lt;- con$search(request = AND(before(date_char = "17-Apr-2019"),
                                smaller_than(size = 512000, negate = TRUE)))

## End(Not run)
</code></pre>

<hr>
<h2 id='clean_msg_text'>Extract text from MIME level</h2><span id='topic+clean_msg_text'></span>

<h3>Description</h3>

<p>Extract text from MIME level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_msg_text(msg_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_msg_text_+3A_msg_list">msg_list</code></td>
<td>
<p>A <code>list</code> with the MIME level 1 of the body or text content
of the messages fetched with <a href="#method-fetch_body"><code>ImapCon$fetch_body()</code></a> or
<a href="#method-fetch_text"><code>ImapCon$fetch_text()</code></a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the decoded messages if applicable.
</p>


<h3>References</h3>

<p>Moore, K. (1996), MIME (Multipurpose Internet Mail Extensions) Part
Three: Message Header Extensions for Non-ASCII
Text, RFC 2047, November 1996, https://tools.ietf.org/html/rfc2047.
</p>
<p>Freed, N., Borenstein, N. (1996), Multipurpose Internet Mail Extensions
(MIME) Part One: Format of Internet Message Bodies, RFC 2045, November 1996,
https://tools.ietf.org/html/rfc2045.
</p>
<p>Internal parts of this object, regarding the quoted printable type,
were borrowed from https://github.com/hrbrmstr/hrbrmisc/blob/master/R/qp.r with
slight modifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ids &lt;- con$search_since(date_char = "01-Apr-2020", use_uid = TRUE)

fetch_res &lt;- ids %&gt;%
  con$fetch_body(use_uid = TRUE, mime_level = 1L)

clean_text_list &lt;- clean_msg_text(msg_list = fetch_res)

## End(Not run)
</code></pre>

<hr>
<h2 id='configure_imap'>IMAP Connection Configuration</h2><span id='topic+configure_imap'></span>

<h3>Description</h3>

<p>Configure and create a new IMAP connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configure_imap(
  url,
  username,
  password = NULL,
  xoauth2_bearer = NULL,
  use_ssl = TRUE,
  verbose = FALSE,
  buffersize = 16000,
  timeout_ms = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="configure_imap_+3A_url">url</code></td>
<td>
<p>A character string containing the IMAP server address</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_username">username</code></td>
<td>
<p>A character string containing the username.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_password">password</code></td>
<td>
<p>A character string containing the user's password.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_xoauth2_bearer">xoauth2_bearer</code></td>
<td>
<p>A character string containing the oauth2 bearer token.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_use_ssl">use_ssl</code></td>
<td>
<p>A logical indicating the use or not of Secure Sockets Layer
encryption when connecting to the IMAP server. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_verbose">verbose</code></td>
<td>
<p>If <code>FALSE</code>, mutes the flow of information between the
server and the client. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_buffersize">buffersize</code></td>
<td>
<p>The size in bytes for the receive buffer. Default is
16000 bytes or 16kb, which means it will use the libcurl's default value.
According to the libcurl's documentation, the maximum buffersize is 512kb
(or 512000 bytes), but any number passed to <code>buffersize</code> is treated
as a request, not an order.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_timeout_ms">timeout_ms</code></td>
<td>
<p>Time in milliseconds (ms) to wait for the execution or
re-execution of a command. Default is 0, which means that no timeout limit is
set.</p>
</td></tr>
<tr><td><code id="configure_imap_+3A_...">...</code></td>
<td>
<p>Further curl parameters (see <code>curl::curl_options</code>) that
can be used with the IMAP protocol. Only for advanced users.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new 'ImapCon' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# w/ Plain authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  password=rstudioapi::askForPassword(),
  verbose = TRUE)

# w/ OAuth2.0 authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  verbose = TRUE,
  xoauth2_bearer = "XX.Ya9...")

## End(Not run)
</code></pre>

<hr>
<h2 id='decode_mime_header'>Decode RFC 2047 quoted-printable and base64 MIME headers and strings</h2><span id='topic+decode_mime_header'></span>

<h3>Description</h3>

<p>Decode RFC 2047 quoted-printable and base64 MIME headers and strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_mime_header(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode_mime_header_+3A_string">string</code></td>
<td>
<p>A <code>character</code> vector containing a string to be decoded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A decoded <code>character</code> vector if applicable.
</p>


<h3>Note</h3>

<p>The RFC 2047 (Moore, 1996) presents an encoded-word syntax to be used by e-mail
clients to display body text and header information in character sets
other than ASCII. According to the manual, non-ASCII content is encoded as
an ASCII text string as follows: <code>=?&lt;charset&gt;?&lt;encoding&gt;?&lt;encoded-text&gt;?=</code>.
The encoding can be of two types: &quot;B&quot; for &quot;BASE64&quot;, or &quot;Q&quot; for quoted-
printable content (Freed and Borentein, 1996). Besides the standard RFC 2047
decoding, this function also enables users to decode content that does not
strictly follow the <code>=?&lt;charset&gt;?&lt;encoding&gt;?&lt;encoded-text&gt;?=</code> RFC 2047
syntax, i.e. cases where only the encoded text part is present, such as the
quoted-printable pattern in the string <code>"Estat=EDstica"</code> (Estatística,
which is the equivalent word, in Portuguese, for Statistics).
</p>


<h3>References</h3>

<p>Moore, K. (1996), MIME (Multipurpose Internet Mail Extensions) Part
Three: Message Header Extensions for Non-ASCII
Text, RFC 2047, November 1996, https://tools.ietf.org/html/rfc2047.
</p>
<p>Freed, N., Borenstein, N. (1996), Multipurpose Internet Mail Extensions
(MIME) Part One: Format of Internet Message Bodies, RFC 2045, November 1996,
https://tools.ietf.org/html/rfc2045.
</p>
<p>Internal parts of this object, regarding the quoted printable type,
were borrowed from https://github.com/hrbrmstr/hrbrmisc/blob/master/R/qp.r with
slight modifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The examples below runs smoothly on any computer. The 'dontrun' flag is just to skip CRAN checks.

# Simple quoted-printable string - Portuguese example
qp_encoded &lt;- "Minist=E9rio_da_Educa=E7=E3o"
decoded_string &lt;- decode_mime_header(string = qp_encoded)

# Simple quoted-printable string - French example
qp_encoded &lt;- "sur la route =C3=A0 suivre les voil=C3=A0 bient=C3=B4t qui te d=C3=A9gradent"
decoded_string &lt;- decode_mime_header(string = qp_encoded)

# RFC 2047 quoted-printable header - Portuguese example
qp_encoded &lt;- "=?iso-8859-1?Q?DIDEC_Capacita=E7=E3o?="
decoded_string &lt;- decode_mime_header(string = qp_encoded)

# RFC 2047 quoted-printable - German example
qp_encoded &lt;- "=?UTF-8?Q?stern=2Ede_-_t=C3=A4glich?="
decoded_string &lt;- decode_mime_header(string = qp_encoded)

# RFC 2047 base64 - Portuguese example
b64_encoded &lt;- "=?utf-8?B?Sk9BTkEgRlVTQ08gTE9CTyBubyBUZWFtcw==?="
decoded_string &lt;- decode_mime_header(string = b64_encoded)

## End(Not run)

</code></pre>

<hr>
<h2 id='flag'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+flag'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag(name, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_+3A_name">name</code></td>
<td>
<p>A string containing one or more flags to search for. Use
<a href="#method-list_flags"><code>ImapCon$list_flags()</code></a> to list the flags
in a selected mail folder.</p>
</td></tr>
<tr><td><code id="flag_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages with Flag "UNSEEN" AND NOT Smaller Than  512KB.
res &lt;- con$search(request = AND(flag("UNSEEN"),
                                smaller_than(size = 512000, negate = TRUE)))

## End(Not run)
</code></pre>

<hr>
<h2 id='ImapCon'>An IMAP Connection Class</h2><span id='topic+ImapCon'></span>

<h3>Description</h3>

<p>Configure an IMAP connection using the <code>ImapCon</code> <code>R6</code>
class.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ImapCon-new"><code>ImapCon$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_url"><code>ImapCon$reset_url()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_username"><code>ImapCon$reset_username()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_use_ssl"><code>ImapCon$reset_use_ssl()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_verbose"><code>ImapCon$reset_verbose()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_buffersize"><code>ImapCon$reset_buffersize()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_timeout_ms"><code>ImapCon$reset_timeout_ms()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_password"><code>ImapCon$reset_password()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-reset_xoauth2_bearer"><code>ImapCon$reset_xoauth2_bearer()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_mail_folders"><code>ImapCon$list_mail_folders()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-select_folder"><code>ImapCon$select_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-examine_folder"><code>ImapCon$examine_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-create_folder"><code>ImapCon$create_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-rename_folder"><code>ImapCon$rename_folder()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-list_flags"><code>ImapCon$list_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search"><code>ImapCon$search()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_larger_than"><code>ImapCon$search_larger_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_smaller_than"><code>ImapCon$search_smaller_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_before"><code>ImapCon$search_before()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_since"><code>ImapCon$search_since()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_on"><code>ImapCon$search_on()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_period"><code>ImapCon$search_period()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_before"><code>ImapCon$search_sent_before()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_since"><code>ImapCon$search_sent_since()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_on"><code>ImapCon$search_sent_on()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_sent_period"><code>ImapCon$search_sent_period()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_flag"><code>ImapCon$search_flag()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_older_than"><code>ImapCon$search_older_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_younger_than"><code>ImapCon$search_younger_than()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-search_string"><code>ImapCon$search_string()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_body"><code>ImapCon$fetch_body()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_header"><code>ImapCon$fetch_header()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_metadata"><code>ImapCon$fetch_metadata()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_text"><code>ImapCon$fetch_text()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-copy_msg"><code>ImapCon$copy_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-move_msg"><code>ImapCon$move_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_count"><code>ImapCon$esearch_count()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-delete_msg"><code>ImapCon$delete_msg()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-expunge"><code>ImapCon$expunge()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_min_id"><code>ImapCon$esearch_min_id()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-esearch_max_id"><code>ImapCon$esearch_max_id()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-add_flags"><code>ImapCon$add_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-replace_flags"><code>ImapCon$replace_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-remove_flags"><code>ImapCon$remove_flags()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-get_attachments"><code>ImapCon$get_attachments()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_attachments_list"><code>ImapCon$fetch_attachments_list()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>
</p>
</li>
<li> <p><a href="#method-ImapCon-clone"><code>ImapCon$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ImapCon-new"></a>



<h4>Method <code>new()</code></h4>

<p>Configure and create a new IMAP connection.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$new(
  url,
  username,
  password = NULL,
  xoauth2_bearer = NULL,
  use_ssl = TRUE,
  verbose = FALSE,
  buffersize = 16000,
  timeout_ms = 0,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>A character string containing the IMAP server address</p>
</dd>
<dt><code>username</code></dt><dd><p>A character string containing the username.</p>
</dd>
<dt><code>password</code></dt><dd><p>A character string containing the user's password.</p>
</dd>
<dt><code>xoauth2_bearer</code></dt><dd><p>A character string containing the oauth2 bearer token.</p>
</dd>
<dt><code>use_ssl</code></dt><dd><p>A logical indicating the use or not of Secure Sockets Layer
encryption when connecting to the IMAP server. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>FALSE</code>, mutes the flow of information between the
server and the client. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>buffersize</code></dt><dd><p>The size in bytes for the receive buffer. Default is
16000 bytes or 16kb, which means it will use the libcurl's default value.
According to the libcurl's documentation, the maximum buffersize is 512kb
(or 512000 bytes), but any number passed to <code>buffersize</code> is treated
as a request, not an order.</p>
</dd>
<dt><code>timeout_ms</code></dt><dd><p>Time in milliseconds (ms) to wait for the execution or
re-execution of a command. Default is 0, which means that no timeout limit is
set.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further curl parameters (see <code>curl::curl_options</code>) that
can be used with the IMAP protocol. Only for advanced users.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'ImapCon' object.
</p>


<hr>
<a id="method-ImapCon-reset_url"></a>



<h4>Method <code>reset_url()</code></h4>

<p>Reset the previously informed url
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_url(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A character string containing a new url to be set.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_username"></a>



<h4>Method <code>reset_username()</code></h4>

<p>Reset the previously informed username
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_username(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A character string containing a new username to be set.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_use_ssl"></a>



<h4>Method <code>reset_use_ssl()</code></h4>

<p>Reset the previously informed use_ssl parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_use_ssl(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A logical indicating the use or not of Secure Sockets Layer
encryption when connecting to the IMAP server. Default is <code>TRUE</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_verbose"></a>



<h4>Method <code>reset_verbose()</code></h4>

<p>Reset the previously informed verbose parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_verbose(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>If <code>FALSE</code>, mutes the flow of information between the
server and the client.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_buffersize"></a>



<h4>Method <code>reset_buffersize()</code></h4>

<p>Reset the previously informed buffersize parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_buffersize(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>The size in bytes for the receive buffer. Default is
16000 bytes or 16kb, which means it will use the libcurl's default value.
According to the libcurl's documentation, the maximum buffersize is 512kb
(or 512000 bytes), but any number passed to <code>buffersize</code> is treated
as a request, not an order.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_timeout_ms"></a>



<h4>Method <code>reset_timeout_ms()</code></h4>

<p>Reset the previously informed buffersize parameter
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_timeout_ms(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Time in milliseconds (ms) to wait for the execution or
re-execution of a command. Default is 0, which means that no timeout limit is
set.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_password"></a>



<h4>Method <code>reset_password()</code></h4>

<p>Reset the previously informed password
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_password(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A character string containing the user's password.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-reset_xoauth2_bearer"></a>



<h4>Method <code>reset_xoauth2_bearer()</code></h4>

<p>Reset the previously informed oauth2 bearer token
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$reset_xoauth2_bearer(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A character string containing the oauth2 bearer token.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ImapCon-list_server_capabilities"></a>



<h4>Method <code>list_server_capabilities()</code></h4>

<p>List the server's IMAP capabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_server_capabilities(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A character <code>vector</code> containing the server's IMAP capabilities.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
cap &lt;- con$list_server_capabilities()
cap
}
</pre>
</div>


<hr>
<a id="method-ImapCon-list_mail_folders"></a>



<h4>Method <code>list_mail_folders()</code></h4>

<p>List mail folders in a mailbox.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_mail_folders(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the mail folder names and their inherent
structure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
folders &lt;- con$list_mail_folders()
folders
}
</pre>
</div>


<hr>
<a id="method-ImapCon-select_folder"></a>



<h4>Method <code>select_folder()</code></h4>

<p>Select a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$select_folder(name, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A string containing the name of an existing mail folder on the
user's mailbox.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the mail folder names and their inherent
structure.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_mail_folder(name = "INBOX")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-examine_folder"></a>



<h4>Method <code>examine_folder()</code></h4>

<p>Examine the number of messages in a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$examine_folder(name = NULL, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A <code>character</code> string containing the name of an existing
mail folder on the user's mailbox. If no name is passed, the command
will be executed using the previously selected mail folder name.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>vector</code> (with names <code>"EXISTS"</code> and <code>"RECENT"</code>)
containing the number of messages in each category.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
con$examine_folder()

# or directly:
con$examine_folder("Sent")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-create_folder"></a>



<h4>Method <code>create_folder()</code></h4>

<p>Create a new mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$create_folder(name, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A string containing the name of the new mail folder to be
created.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$create_folder(name = "New Folder Name")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-rename_folder"></a>



<h4>Method <code>rename_folder()</code></h4>

<p>Rename a mail folder.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$rename_folder(
  name = NULL,
  new_name,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A string containing the name of the new mail folder to be
renamed. If no name is passed, the command will be executed using the
previously selected mail folder name.</p>
</dd>
<dt><code>new_name</code></dt><dd><p>A string containing the new name to be assigned.</p>
</dd>
<dt><code>reselect</code></dt><dd><p>A logical. If <code>TRUE</code>, calls
<code>select_folder(name = to_folder)</code> under the hood before returning
the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "Folder A")
con$rename_folder(new_name = "Folder B")
# or directly:
con$rename_folder(name = "Folder A", new_name = "Folder B")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-list_flags"></a>



<h4>Method <code>list_flags()</code></h4>

<p>List flags in a selected mail folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$list_flags(retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> in case the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
con$list_flags()
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search"></a>



<h4>Method <code>search()</code></h4>

<p>Execute a custom search
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search(
  request,
  negate = FALSE,
  use_uid = FALSE,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>A string directly specifying what to search or
constructed by a combination of relational-operator-helper-functions <code><a href="#topic+OR">OR</a></code>
and <code><a href="#topic+AND">AND</a></code>, and criteria helper functions such as
<code><a href="#topic+before">before</a></code>, <code><a href="#topic+since">since</a></code>, <code><a href="#topic+on">on</a></code>,
<code><a href="#topic+sent_before">sent_before</a></code>, <code><a href="#topic+sent_since">sent_since</a></code>, <code><a href="#topic+sent_on">sent_on</a></code>,
<code><a href="#topic+flag">flag</a></code>, <code><a href="#topic+string">string</a></code>, <code><a href="#topic+smaller_than">smaller_than</a></code>,
<code><a href="#topic+larger_than">larger_than</a></code>, <code><a href="#topic+younger_than">younger_than</a></code>, or
<code><a href="#topic+younger_than">younger_than</a></code>.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> containing the flags (<code>character vector</code>),
the permanent flags (<code>character vector</code>), and an indication if custom
flags are allowed by the server (<code>logical vector</code>).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# ex1
con$search(OR(before(date_char = "17-Apr-2015"),
              string(expr = "John", where = "FROM")))

# ex2
con$search(AND(smaller_than(size = "512000"),
               string(expr = "John", where = "FROM"),
               string(expr = "@ksu.edu", where = "CC")))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_larger_than"></a>



<h4>Method <code>search_larger_than()</code></h4>

<p>Search by size (LARGER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_larger_than(
  size,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt><dd><p>An integer specifying the size in bytes to be used as the
search criterion.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with size larger than 512Kb
con$search_larger_than(size = 512000))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_smaller_than"></a>



<h4>Method <code>search_smaller_than()</code></h4>

<p>Search by size (SMALLER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_smaller_than(
  size,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt><dd><p>An integer specifying the size in bytes to be used as the
search criterion.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with size smaller than 512Kb
con$search_smaller_than(size = 512000))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_before"></a>



<h4>Method <code>search_before()</code></h4>

<p>Search by internal date (BEFORE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_before(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_before(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_since"></a>



<h4>Method <code>search_since()</code></h4>

<p>Search by internal date (SINCE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_since(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.
<code>POSIX*</code> like objects, since IMAP servers use this uncommon date format.
<code>POSIX*</code> like, since IMAP servers like this not so common date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages with date since "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_since(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_on"></a>



<h4>Method <code>search_on()</code></h4>

<p>Search by internal date (ON)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_on(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_on(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_period"></a>



<h4>Method <code>search_period()</code></h4>

<p>Search by internal date (Period)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_period(
  since_date_char,
  before_date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>since_date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>before_date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_before"></a>



<h4>Method <code>search_sent_before()</code></h4>

<p>Search by origination date  (RFC 2822 Header - SENT BEFORE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_before(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_before(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_since"></a>



<h4>Method <code>search_sent_since()</code></h4>

<p>Search by origination date (RFC 2822 Header - SENT SINCE)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_since(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_since(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_on"></a>



<h4>Method <code>search_sent_on()</code></h4>

<p>Search by origination date (RFC 2822 Header - SENT ON)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_on(
  date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_sent_on(date = "02-Jan-2020", use_uid = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_sent_period"></a>



<h4>Method <code>search_sent_period()</code></h4>

<p>Search by origination date (RFC 2822 Header - SENT Period)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_sent_period(
  since_date_char,
  before_date_char,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>since_date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>before_date_char</code></dt><dd><p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this uncommon date format.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_sent_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_flag"></a>



<h4>Method <code>search_flag()</code></h4>

<p>Search by flag(s)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_flag(
  name,
  negate = FALSE,
  use_uid = FALSE,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>A string containing one or more flags to search for. Use
<a href="#method-list_flags"><code>ImapCon$list_flags()</code></a> to list the flags
in a selected mail folder.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages in the mail folder that are marked as "SEEN" AND
#.. "ANSWERED"
con$search_flag(name = c("SEEN", "ANSWERED"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_older_than"></a>



<h4>Method <code>search_older_than()</code></h4>

<p>Search WITHIN a specific time (OLDER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_older_than(
  seconds,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seconds</code></dt><dd><p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (not older than 3600 seconds)
con$search_older_than(seconds = 3600, negate = TRUE)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_younger_than"></a>



<h4>Method <code>search_younger_than()</code></h4>

<p>Search WITHIN a specific time (YOUNGER)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_younger_than(
  seconds,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seconds</code></dt><dd><p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_younger_than(seconds = 3600)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-search_string"></a>



<h4>Method <code>search_string()</code></h4>

<p>Search by string or expression
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$search_string(
  expr,
  where,
  negate = FALSE,
  use_uid = FALSE,
  flag = NULL,
  esearch = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>expr</code></dt><dd><p>A character string specifying the word or expression to search
for in messages.</p>
</dd>
<dt><code>where</code></dt><dd><p>A mandatory character string specifying in which
message's Section or Header Field to search for the provided string.</p>
</dd>
<dt><code>negate</code></dt><dd><p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERION&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flag</code></dt><dd><p>An optional argument that sets one or more flags as an additional
filter to the search. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder. Default is <code>NULL</code>.</p>
</dd>
<dt><code>esearch</code></dt><dd><p>A logical. Default is <code>FALSE</code>. If the IMAP server has
<code>ESEARCH</code> capability, it can be used to optimize search results. It
will condense the results: instead of writing down the whole sequences of messages'
ids, such as <code>{1 2 3 4 5}</code>, it will be presented as <code>{1:5}</code>,
which decreases transmission costs. This argument can be used along with
<code>buffersize</code> to avoid results stripping. Check if your IMAP server
supports <code>ESEARCH</code> with
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_string(expr = "@k-state.edu", where = "FROM")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_body"></a>



<h4>Method <code>fetch_body()</code></h4>

<p>Fetch message body (message's full content)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_body(
  msg_id,
  use_uid = FALSE,
  mime_level = NULL,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>mime_level</code></dt><dd><p>An <code>integer</code> specifying MIME multipart to fetch from
the message's body. Default is <code>NULL</code>, which retrieves the full body content.</p>
</dd>
<dt><code>peek</code></dt><dd><p>If <code>TRUE</code>, it does not mark messages as &quot;read&quot; after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt><dd><p><code>NULL</code> or a character string with format
&quot;startchar.endchar&quot; indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt><dd><p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt><dd><p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results (saving to disk) using the pipe
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body(write_to_disk = TRUE, keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")

con$fetch_body(msg = res, write_to_disk = TRUE, keep_in_mem = FALSE)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_header"></a>



<h4>Method <code>fetch_header()</code></h4>

<p>Fetch message header
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_header(
  msg_id,
  use_uid = FALSE,
  fields = NULL,
  negate_fields = FALSE,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>fields</code></dt><dd><p>An optional <code>character vector</code> specifying which field(s)
will be fetched from the message's header. If none is specified, it will
fetch the full header.</p>
</dd>
<dt><code>negate_fields</code></dt><dd><p>If <code>TRUE</code>, negates the operation and seeks for
&quot;NOT in the field&quot;. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>peek</code></dt><dd><p>If <code>TRUE</code>, it does not mark messages as &quot;read&quot; after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt><dd><p><code>NULL</code> or a character string with format
&quot;startchar.endchar&quot; indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt><dd><p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt><dd><p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results (also saving to disk) using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "CC") %&gt;%
  con$fetch_header()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "CC")
out &lt;- con$fetch_header()

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_metadata"></a>



<h4>Method <code>fetch_metadata()</code></h4>

<p>Fetch message metadata
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_metadata(
  msg_id,
  use_uid = FALSE,
  attribute = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>attribute</code></dt><dd><p>An optional <code>character vector</code> specifying one or more
attributes of the metadata of a message to fetch. See <a href="#topic+metadata_options">metadata_options</a>.</p>
</dd>
<dt><code>write_to_disk</code></dt><dd><p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt><dd><p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
<dt><code>peek</code></dt><dd><p>If <code>TRUE</code>, it does not mark messages as &quot;read&quot; after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt><dd><p><code>NULL</code> or a character string with format
&quot;startchar.endchar&quot; indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the results using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_metadata()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_metadata(msg = res)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_text"></a>



<h4>Method <code>fetch_text()</code></h4>

<p>Fetch message text
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_text(
  msg_id,
  use_uid = FALSE,
  peek = TRUE,
  partial = NULL,
  write_to_disk = FALSE,
  keep_in_mem = TRUE,
  mute = FALSE,
  base64_decode = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>peek</code></dt><dd><p>If <code>TRUE</code>, it does not mark messages as &quot;read&quot; after
fetching. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>partial</code></dt><dd><p><code>NULL</code> or a character string with format
&quot;startchar.endchar&quot; indicating the size (in characters) of a message slice
to fetch. Default is <code>NULL</code>, which will fetch the full specified content.</p>
</dd>
<dt><code>write_to_disk</code></dt><dd><p>If <code>TRUE</code>, writes the fetched content of each message
to a text file in a local folder inside the working directory, also
returning the results with <code>invisible()</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep_in_mem</code></dt><dd><p>If <code>TRUE</code>, keeps a copy of each fetch result while
the operation is being performed with <code>write_to_disk = TRUE</code>. Default
is <code>FALSE</code>, and it can only be set <code>TRUE</code> when
<code>write_to_disk = TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. It provides a confirmation message if the
command is successfully executed. It is only effective when <code>write_to_disk = TRUE</code>
and <code>keep_in_mem = FALSE</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>base64_decode</code></dt><dd><p>If <code>TRUE</code>, tries to guess and decode the fetched
text from base64 format to <code>character</code>. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents or a logical if
<code>write_to_disk = TRUE</code> and <code>keep_in_mem = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and partially fetch the results using the pipe
# first 200 characters, writing to disk, silence results in the console
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_text(partial = "0.200",
                 write_to_disk = TRUE,
                 keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_text(msg = res,
               partial = "0.200",
               write_to_disk = TRUE,
               keep_in_mem = FALSE)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-copy_msg"></a>



<h4>Method <code>copy_msg()</code></h4>

<p>Copy message(s) between the selected folder and another one
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$copy_msg(
  msg_id,
  use_uid = FALSE,
  to_folder,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>to_folder</code></dt><dd><p>A <code>character</code> string specifying the folder to which
the messages will be copied.</p>
</dd>
<dt><code>reselect</code></dt><dd><p>A logical. If <code>TRUE</code>, calls
<a href="#method-select_folder"><code>ImapCon$select_folder(name = to_folder)</code></a>
under the hood before returning the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$copy(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$copy(msg = res, to_folder = "Sent")

}
</pre>
</div>


<hr>
<a id="method-ImapCon-move_msg"></a>



<h4>Method <code>move_msg()</code></h4>

<p>Move message(s) between the selected folder and another one
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$move_msg(
  msg_id,
  use_uid = FALSE,
  to_folder,
  reselect = TRUE,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>to_folder</code></dt><dd><p>A <code>character</code> string specifying the folder to which
the messages will be copied.</p>
</dd>
<dt><code>reselect</code></dt><dd><p>A logical. If <code>TRUE</code>, calls
<a href="#method-select_folder"><code>ImapCon$select_folder(name = to_folder)</code></a>
under the hood before returning the output. Default is <code>TRUE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$move(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$move(msg = res, to_folder = "Sent")

}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_count"></a>



<h4>Method <code>esearch_count()</code></h4>

<p>Count the number of messages with a specific flag(s) in a
folder (depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_count(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt><dd><p>A mandatory parameter that specifies one or more flags as a
filter to the counting operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the number
of messages in the folder that meet the specified criteria.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-delete_msg"></a>



<h4>Method <code>delete_msg()</code></h4>

<p>Delete message(s) in the selected mail folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$delete_msg(msg_id, use_uid = FALSE, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# delete
con$delete_msg(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-expunge"></a>



<h4>Method <code>expunge()</code></h4>

<p>Permanently removes all or specific messages marked as deleted from the selected folder
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$expunge(msg_uid = NULL, mute = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_uid</code></dt><dd><p>A <code>numeric vector</code> containing one or more messages UIDs.
Only UIDs are allowed in this operation (note the &quot;u&quot; in msg_<em>u</em>id).</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the operation is successful.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))
}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_min_id"></a>



<h4>Method <code>esearch_min_id()</code></h4>

<p>Search the minimum message id in the selected mail folder
(depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_min_id(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt><dd><p>A mandatory parameter that specifies one or more flags as a
filter to the searching operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the minimum
message id in the folder.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Answered"
con$esearch_min_id(flag = "Answered")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-esearch_max_id"></a>



<h4>Method <code>esearch_max_id()</code></h4>

<p>Search the maximum message id in the selected mail folder
(depend on ESEARCH capability)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$esearch_max_id(flag, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>flag</code></dt><dd><p>A mandatory parameter that specifies one or more flags as a
filter to the searching operation. Use <a href="#method-list_flags"><code>ImapCon$list_flags()</code></a>
to list the flags in a selected mail folder.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, results will be
presented as message sequence numbers. A message sequence number is a
message's relative position to the oldest message in a mail folder. It may
change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier,
and results are presented as such. UIDs are always the same during the
life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A numeric <code>vector</code> of length <code>1</code> containing the maximum
message id in the folder.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Seen"
con$esearch_max_id(flag = "Seen")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-add_flags"></a>



<h4>Method <code>add_flags()</code></h4>

<p>Add flags to one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$add_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_set,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_set</code></dt><dd><p>A <code>character vector</code> containing one or more flag
names to add to the specified message ids. If the flag to be set is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Add the "\Seen" permanent flag to the messages received in the last hour
con$search_younger_than(seconds = 3600) %&gt;% # depends on the WITHIN extension
  con$add_flags(flags_to_set = "\\Seen")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-replace_flags"></a>



<h4>Method <code>replace_flags()</code></h4>

<p>Replace the current flags of one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$replace_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_set,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_set</code></dt><dd><p>A <code>character vector</code> containing one or more flag
names that will replace the current ones. If the flag to be set is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Replace the current flags of the messages in the search results for the
#.. flags "\UNSEEN" and "\Flagged"
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$replace_flags(flags_to_set = c("\\UNSEEN", "\\Flagged")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-remove_flags"></a>



<h4>Method <code>remove_flags()</code></h4>

<p>Remove flag(s) of one or more messages
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$remove_flags(
  msg_id,
  use_uid = FALSE,
  flags_to_unset,
  mute = FALSE,
  retries = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>flags_to_unset</code></dt><dd><p>A <code>character vector</code> containing one or more
flag names that will be unset (removed). If the flag to be removed is a
system flag, such as <code>\SEEN</code>, <code>\ANSWERED</code>, the name should be
preceded by two backslashes <code>\</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command.
Default is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An invisible <code>numeric vector</code> containing the message ids.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# Remove the the "\SEEN" flag from the messages in the search result
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$remove_flags(flags_to_unset = "\\UNSEEN")
}
</pre>
</div>


<hr>
<a id="method-ImapCon-get_attachments"></a>



<h4>Method <code>get_attachments()</code></h4>

<p>Extract attached file(s) from fetched message(s)
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$get_attachments(
  msg_list,
  content_disposition = "both",
  override = FALSE,
  mute = FALSE,
  as_is = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_list</code></dt><dd><p>A <code>list</code> with the body or text content of the messages
fetched with <a href="#method-fetch_body"><code>ImapCon$fetch_body()</code></a> or
<a href="#method-fetch_text"><code>ImapCon$fetch_text()</code></a>.</p>
</dd>
<dt><code>content_disposition</code></dt><dd><p>A <code>string</code> indicating which type of
&quot;Content-Disposition&quot; attachments should be retrieved. Default is
<code>"both"</code>, which retrieves regular attachments (&quot;Content-Disposition:
attachment&quot;) and  inline attachments (&quot;Content-Disposition: inline&quot;).</p>
</dd>
<dt><code>override</code></dt><dd><p>A <code>logical</code>. Provides a confirmation message if the
command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>as_is</code></dt><dd><p>If <code>TRUE</code> then write out attachments without base64
decoding. Default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code> if the operation is successful. The files are saved
locally.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# example 1
con$select_folder(name = "INBOX")
con$search_string(expr = "@gmail", where = "CC") %&gt;%
  con$fetch_text(write_to_disk = TRUE) %&gt;% # saving the message's content as txt files
  con$get_attachments()

# example 2
res &lt;- con$search_string(expr = "@gmail", where = "CC") %&gt;%
out &lt;- con$fetch_body(msg = res)
con$get_attachments(msg_list = out)
}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_attachments_list"></a>



<h4>Method <code>fetch_attachments_list()</code></h4>

<p>Fetch attachments' list
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_attachments_list(msg_id, use_uid = FALSE, retries = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
out &lt; con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments_list()
out

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_attachments_list(msg = res)
out

}
</pre>
</div>


<hr>
<a id="method-ImapCon-fetch_attachments"></a>



<h4>Method <code>fetch_attachments()</code></h4>

<p>Fetch message attachments
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$fetch_attachments(
  msg_id,
  use_uid = FALSE,
  content_disposition = "both",
  override = FALSE,
  mute = FALSE,
  retries = 1,
  as_is = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>msg_id</code></dt><dd><p>A <code>numeric vector</code> containing one or more message ids.</p>
</dd>
<dt><code>use_uid</code></dt><dd><p>Default is <code>FALSE</code>. In this case, the operation will
be performed using message sequence numbers. A message sequence number
is a message's relative position to the oldest message in a mail folder.
It may change after deleting or moving messages. If a message is deleted,
sequence numbers are reordered to fill the gap. If <code>TRUE</code>, the
command will be performed using the <code>"UID"</code> or unique identifier.
UIDs are always the same during the life cycle of a message in a mail folder.</p>
</dd>
<dt><code>content_disposition</code></dt><dd><p>A <code>string</code> indicating which type of
&quot;Content-Disposition&quot; attachments should be retrieved. The options are
<code>both</code>, <code>attachment</code>, and <code>inline</code>. Default is
<code>"both"</code>, which retrieves regular attachments (&quot;Content-Disposition:
attachment&quot;) and  inline attachments (&quot;Content-Disposition: inline&quot;).</p>
</dd>
<dt><code>override</code></dt><dd><p>A <code>logical</code>. Provides a confirmation message if the
command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>mute</code></dt><dd><p>A <code>logical</code>. If <code>TRUE</code>, mutes the confirmation message
when the command is successfully executed. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>retries</code></dt><dd><p>Number of attempts to connect and execute the command. Default
is <code>1</code>.</p>
</dd>
<dt><code>as_is</code></dt><dd><p>If <code>TRUE</code> then write out attachments without base64
decoding. Default is <code>FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>list</code> with the fetch contents.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments() # the attachments will be downloaded to disk


# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_attachments(msg = res)

}
</pre>
</div>


<hr>
<a id="method-ImapCon-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ImapCon$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p><a href="#method-new"><code>ImapCon$new()</code></a>: The <code><a href="#topic+configure_imap">configure_imap</a></code>
should be preferred instead of <code>ImapCon$new()</code>.
</p>
<p><a href="#method-search"><code>ImapCon$search()</code></a>: IMAP queries follows
Polish notation, i.e. operators such as <code>OR</code> come before arguments,
e.g. &quot;OR argument1 argument2&quot;. Therefore, the relational-operator-helper-functions
in this package should be used like the following examples:
<code>OR(before("17-Apr-2015"), string("FROM", "John"))</code>. Even though there
is no &quot;AND&quot; operator in IMAP, this package adds a helper function
<code><a href="#topic+AND">AND</a></code> to indicate multiples arguments that must be searched
together, e.g. <code>AND(since("01-Jul-2018"), smaller_than(16000))</code>.
</p>
<p><a href="#method-sent_before"><code>ImapCon$sent_before()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be &quot;slower&quot; than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_since"><code>ImapCon$search_sent_since()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be &quot;slower&quot; than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_on"><code>ImapCon$search_sent_on()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be &quot;slower&quot; than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_sent_period"><code>ImapCon$search_sent_period()</code></a>: Search
operations that use the origination/RFC-2822 Header date
tend to be &quot;slower&quot; than those that use the internal date. Although the
overhead is minimum, the difference is due to the fact that the internal date
is kept on a database, while the origination date has to be retrieved from
inside the message. Therefore, the server needs to access each message when
executing this type of search. Despite this fact, both dates tend to be the
same.
</p>
<p><a href="#method-search_older_than"><code>ImapCon$search_older_than()</code></a>:
To be able to use this functionality, the server must support the
<code>WITHIN</code> capability. You can check it by running
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.
</p>
<p><a href="#method-search_older_than"><code>ImapCon$search_older_than()</code></a>:
To be able to use this functionality, the server must support the
<code>WITHIN</code> capability. You can check it by running
<a href="#method-list_server_capabilities"><code>ImapCon$list_server_capabilities()</code></a>.
</p>
<p><a href="#method-search_string"><code>ImapCon$search_string()</code></a>: Using
<code>where = "TEXT"</code>, may produce unexpected results since it
will perform the search on raw data, i.e. the searched expression may be
truncated by special formating characters such as <code>\r\n</code> for example.
It is recommended to perform this type of search using <code>where = "BODY"</code>,
instead of <code>"TEXT"</code> (<cite>Heinlein, P. and Hartleben, P. (2008)</cite>).
</p>
<p><a href="#method-esearch_count"><code>ImapCon$esearch_count()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-esearch_min_id"><code>ImapCon$esearch_min_id()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-esearch_max_id"><code>ImapCon$esearch_max_id()</code></a>: This
operation depends on the <code>ESEARCH</code> extension.
</p>
<p><a href="#method-add_flags"><code>ImapCon$add_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-add_flags"><code>ImapCon$add_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-replace_flags"><code>ImapCon$replace_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-replace_flags"><code>ImapCon$replace_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-remove_flags"><code>ImapCon$remove_flags()</code></a>: Unlike the
search operations, the add/replace/delete flags operations
demand system flag names to be preceded by two backslashes <code>"\\"</code>.
</p>
<p><a href="#method-remove_flags"><code>ImapCon$remove_flags()</code></a>: <code>add_flags</code>,
<code>remove_flags</code>, and <code>replace_flags</code> accept not only flags but
also keywords (any word not beginning with two backslashes) which are
custom flags defined by the user.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>:
This method is to be used after the body or the
text part of one or more messages were fetched. This makes sense if the
user is interested in keeping the message content (body or text) besides
downloading the message attachments. Nonetheless, this is not the
recommended approach if the user is only interested in downloading the files
as the previous fetching operation will probably be costly. In this last
case, the recommendation is to use
<a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a> as
it will only fetch the attachment part.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>: All
attachments will be stored in a folder labeled with the message id
inside the <code>working directory &gt; servername &gt; foldername</code>.
This function currently handles only attachments
encoded as <code>base64</code> text. It tries to guess all file extensions while
decoding the text, but it may not be possible to do so in some circumstances.
If it happens, you can try to change the file extension directly by renaming
the file.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>: The
&quot;Content-Disposition&quot; header specifies if the multipart electronic
messages will be presented as a main document with a list of separate
attachments (&quot;Content-Disposition: attachment&quot;) or as a single document
with the various parts displayed inline. The first requires positive action
on the part of the recipient (downloading the file, for example) whereas inline
components are displayed automatically when the message is viewed
(<cite>Troost, R., Dorner, S., and K. Moore, Ed. (1997)</cite>). You can choose
to download <code>both</code>, or only one type of attachment, using the
argument <code>content_disposition</code>.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>: All
attachments will be stored in a folder labeled with the message id
inside the <code>working directory &gt; servername &gt; foldername</code>.
This function currently handles only attachments
encoded as <code>base64</code> text. It tries to guess all file extensions while
decoding the text, but it may not be possible to do so in some circumstances.
If it happens, you can try to change the file extension directly by renaming
the file.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>: The
&quot;Content-Disposition&quot; header specifies if the multipart electronic
messages will be presented as a main document with a list of separate
attachments (&quot;Content-Disposition: attachment&quot;) or as a single document
with the various parts displayed inline. The first requires positive action
on the part of the recipient (downloading the file, for example) whereas inline
components are displayed automatically when the message is viewed
(<cite>Troost, R., Dorner, S., and K. Moore, Ed. (1997)</cite>). You can choose
to download <code>both</code>, or only one type of attachment, using the
argument <code>content_disposition</code>.
</p>


<h3>References</h3>

<p><a href="#method-search_string"><code>ImapCon$search_string()</code></a>:
Heinlein, P. and Hartleben, P. (2008). The Book of IMAP: Building a
Mail Server with Courier and Cyrus. No Starch Press. ISBN 978-1-59327-177-0.
</p>
<p><a href="#method-get_attachments"><code>ImapCon$get_attachments()</code></a>:
Troost, R., Dorner, S., and K. Moore (1997), Communicating
Presentation Information in Internet Messages: The Content-Disposition
Header Field, RFC 2183, August 1997, https://www.rfc-editor.org/rfc/rfc2183.
</p>
<p><a href="#method-fetch_attachments"><code>ImapCon$fetch_attachments()</code></a>:
Troost, R., Dorner, S., and K. Moore (1997), Communicating
Presentation Information in Internet Messages: The Content-Disposition
Header Field, RFC 2183, DOI 10.17487/RFC2183, August 1997,
https://www.rfc-editor.org/rfc/rfc2183.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>
<p>Other attachments: 
<code><a href="#topic+list_attachments">list_attachments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# w/ Plain authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  password=rstudioapi::askForPassword(),
  verbose = TRUE)

# OR
con &lt;- ImapCon$new(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  password=rstudioapi::askForPassword(),
  verbose = TRUE)

# w/ OAuth2.0 authentication
con &lt;- configure_imap(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  verbose = TRUE,
  xoauth2_bearer = "XX.Ya9...")

# OR
con &lt;- ImapCon$new(
  url="imaps://outlook.office365.com",
  username="user@agency.gov.br",
  verbose = TRUE,
  xoauth2_bearer = "XX.Ya9...")


## End(Not run)



## ------------------------------------------------
## Method `ImapCon$list_server_capabilities`
## ------------------------------------------------

## Not run: 
cap &lt;- con$list_server_capabilities()
cap

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$list_mail_folders`
## ------------------------------------------------

## Not run: 
folders &lt;- con$list_mail_folders()
folders

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$select_folder`
## ------------------------------------------------

## Not run: 
con$select_mail_folder(name = "INBOX")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$examine_folder`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
con$examine_folder()

# or directly:
con$examine_folder("Sent")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$create_folder`
## ------------------------------------------------

## Not run: 
con$create_folder(name = "New Folder Name")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$rename_folder`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "Folder A")
con$rename_folder(new_name = "Folder B")
# or directly:
con$rename_folder(name = "Folder A", new_name = "Folder B")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$list_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
con$list_flags()

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# ex1
con$search(OR(before(date_char = "17-Apr-2015"),
              string(expr = "John", where = "FROM")))

# ex2
con$search(AND(smaller_than(size = "512000"),
               string(expr = "John", where = "FROM"),
               string(expr = "@ksu.edu", where = "CC")))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_larger_than`
## ------------------------------------------------

## Not run: 
# search for messages with size larger than 512Kb
con$search_larger_than(size = 512000))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_smaller_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with size smaller than 512Kb
con$search_smaller_than(size = 512000))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_before`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_before(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_since`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages with date since "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_since(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_on`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_on(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_period`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_before`
## ------------------------------------------------

## Not run: 
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_before(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_since`
## ------------------------------------------------

## Not run: 
# search for messages with date before "02-Jan-2020", presenting the
# .. results as unique identifiers (UID)
con$search_sent_since(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_on`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for messages received on date "02-Jan-2020", presenting the
#... results as unique identifiers (UID)
con$search_sent_on(date = "02-Jan-2020", use_uid = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_sent_period`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder, EXCEPT (negate = TRUE) by
#... those received between the dates "02-Jan-2020" and "22-Mar-2020"
con$search_sent_period(since_date_char = "02-Jan-2020",
                  before_date_char = "22-Mar-2020",
                  negate = TRUE))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_flag`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages in the mail folder that are marked as "SEEN" AND
#.. "ANSWERED"
con$search_flag(name = c("SEEN", "ANSWERED"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_older_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (not older than 3600 seconds)
con$search_older_than(seconds = 3600, negate = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_younger_than`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_younger_than(seconds = 3600)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$search_string`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# search for all messages received in the last hour (younger than 3600 seconds)
con$search_string(expr = "@k-state.edu", where = "FROM")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_body`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results (saving to disk) using the pipe
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body(write_to_disk = TRUE, keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")

con$fetch_body(msg = res, write_to_disk = TRUE, keep_in_mem = FALSE)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_header`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results (also saving to disk) using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "CC") %&gt;%
  con$fetch_header()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "CC")
out &lt;- con$fetch_header()


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_metadata`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the results using the pipe
out &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_metadata()

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_metadata(msg = res)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_text`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and partially fetch the results using the pipe
# first 200 characters, writing to disk, silence results in the console
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_text(partial = "0.200",
                 write_to_disk = TRUE,
                 keep_in_mem = FALSE)

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_text(msg = res,
               partial = "0.200",
               write_to_disk = TRUE,
               keep_in_mem = FALSE)


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$copy_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$copy(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$copy(msg = res, to_folder = "Sent")


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$move_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and copy the results to another folder
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$move(to_folder = "Sent")

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$move(msg = res, to_folder = "Sent")


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_count`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$delete_msg`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# delete
con$delete_msg(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$expunge`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# count the number of messages marked as "Flagged" and "Answered"
con$esearch_count(flag = c("Flagged", "Answered"))

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_min_id`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Answered"
con$esearch_min_id(flag = "Answered")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$esearch_max_id`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Search the minimum id of messages marked as "Seen"
con$esearch_max_id(flag = "Seen")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$add_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Add the "\Seen" permanent flag to the messages received in the last hour
con$search_younger_than(seconds = 3600) %&gt;% # depends on the WITHIN extension
  con$add_flags(flags_to_set = "\\Seen")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$replace_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Replace the current flags of the messages in the search results for the
#.. flags "\UNSEEN" and "\Flagged"
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$replace_flags(flags_to_set = c("\\UNSEEN", "\\Flagged")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$remove_flags`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# Remove the the "\SEEN" flag from the messages in the search result
con$search_since(date_char = "20-Aug-2020") %&gt;%
  con$remove_flags(flags_to_unset = "\\UNSEEN")

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$get_attachments`
## ------------------------------------------------

## Not run: 
# example 1
con$select_folder(name = "INBOX")
con$search_string(expr = "@gmail", where = "CC") %&gt;%
  con$fetch_text(write_to_disk = TRUE) %&gt;% # saving the message's content as txt files
  con$get_attachments()

# example 2
res &lt;- con$search_string(expr = "@gmail", where = "CC") %&gt;%
out &lt;- con$fetch_body(msg = res)
con$get_attachments(msg_list = out)

## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_attachments_list`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
out &lt; con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments_list()
out

# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
out &lt;- con$fetch_attachments_list(msg = res)
out


## End(Not run)

## ------------------------------------------------
## Method `ImapCon$fetch_attachments`
## ------------------------------------------------

## Not run: 
con$select_folder(name = "INBOX")
# do a search and fetch the attachments' list of the messages
con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_attachments() # the attachments will be downloaded to disk


# or using a traditional approach
res &lt;- con$search_string(expr = "@k-state.edu", where = "FROM")
con$fetch_attachments(msg = res)


## End(Not run)
</code></pre>

<hr>
<h2 id='larger_than'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+larger_than'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>larger_than(size, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="larger_than_+3A_size">size</code></td>
<td>
<p>An integer specifying the number of seconds to be used as
search criterion.</p>
</td></tr>
<tr><td><code id="larger_than_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages containing the string "XYZ@k-state.edu" in the
#   "FROM" field OR those that are LARGER than 512KB.
res &lt;- con$search(request = OR(string(expr = "XYZ@k-state.edu",
                                      where = "FROM"),
                               larger_than(size = 512000)))

## End(Not run)

</code></pre>

<hr>
<h2 id='list_attachments'>List attachments and content-disposition types</h2><span id='topic+list_attachments'></span>

<h3>Description</h3>

<p>List attachments and content-disposition types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_attachments(msg_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_attachments_+3A_msg_list">msg_list</code></td>
<td>
<p>A <code>list</code> containing the messages (body or text) fetched
from the server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>data.frames</code> containing the filenames and its
<code>Content-Disposition</code> types for each fetched message.
</p>


<h3>Note</h3>

<p>Please, note that this is an independent function and not an R6 method
that depends on the connection object. Therefore, it should be called alone
without the ImapCon object.
</p>


<h3>See Also</h3>

<p>Other attachments: 
<code><a href="#topic+ImapCon">ImapCon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con$select_folder(name = "INBOX")
# do a search followed by a fetch operation, then extract the attachments' list
out &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body()
att_list &lt;- list_attachments(msg_list = out)

# or
att_list &lt;- con$search_string(expr = "@k-state.edu", where = "FROM") %&gt;%
  con$fetch_body() %&gt;%
  list_attachments()

## End(Not run)
</code></pre>

<hr>
<h2 id='metadata_options'>Message Metadata Options</h2><span id='topic+metadata_options'></span>

<h3>Description</h3>

<p>List Metadata fields used in messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metadata_options()
</code></pre>


<h3>Value</h3>

<p>A <code>vector</code> containing message metadata fields.
</p>


<h3>Note</h3>

<p>This function lists message metadata used by
IMAP servers, according to the RFC 2060 (Crispin, 1996).
</p>


<h3>References</h3>

<p>Crispin, M., &quot;Internet Message Access Protocol - Version 4rev1&quot;,
RFC 2060, <a href="https://doi.org/10.17487/RFC2060">doi:10.17487/RFC2060</a>, December 1996,
<a href="https://www.rfc-editor.org/info/rfc2060">https://www.rfc-editor.org/info/rfc2060</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(mRpostman)
metadata_options()


## End(Not run)
</code></pre>

<hr>
<h2 id='older_than'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+older_than'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>older_than(seconds, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="older_than_+3A_seconds">seconds</code></td>
<td>
<p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</td></tr>
<tr><td><code id="older_than_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To be able to use this functionality, the server must support the
<code>WITHIN</code> capability.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages containing the string "XYZ@k-state.edu" in the
#   "FROM" field AND those that are OLDER than 3600 seconds (1 hour).
res &lt;- con$search(request = AND(string(expr = "XYZ@k-state.edu",
                                      where = "FROM"),
                               older_than(seconds = 3600)))

## End(Not run)

</code></pre>

<hr>
<h2 id='on'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+on'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="on_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "17-Apr-2019" AND SMALLER than 512KB.
res &lt;- con$search(request = OR(on(date_char = "30-Jun-2019"),
                               on(date_char = "22-Mar-2018")))
# search for messages received ON "30-Jun-2019" OR ON "22-Mar-2018".


## End(Not run)
</code></pre>

<hr>
<h2 id='OR'>Relational-operator-function to construct a custom search statement</h2><span id='topic+OR'></span>

<h3>Description</h3>

<p>Relational-operator-function to construct a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OR(..., negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OR_+3A_...">...</code></td>
<td>
<p>a combination of criteria constructor functions with its arguments.</p>
</td></tr>
<tr><td><code id="OR_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for
&quot;NOT search_criterion&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "30-Ago-2019" OR SMALLER than 512KB.
res &lt;- con$search(request = OR(sent_since(date_char = "30-Ago-2019"),
                                smaller_than(size = 512000)))

## End(Not run)
</code></pre>

<hr>
<h2 id='sent_before'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+sent_before'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sent_before(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sent_before_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="sent_before_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "30-Ago-2019" AND SMALLER than 512KB.
res &lt;- con$search(request = AND(sent_since(date_char = "30-Ago-2019"),
                                smaller_than(size = 512000)))

## End(Not run)
</code></pre>

<hr>
<h2 id='sent_on'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+sent_on'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sent_on(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sent_on_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="sent_on_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "30-Ago-2019" OR LARGER than 512KB.
res &lt;- con$search(request = OR(sent_since(date_char = "30-Jun-2020"),
                               larger_than(size = 512000)))

## End(Not run)
</code></pre>

<hr>
<h2 id='sent_since'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+sent_since'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sent_since(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sent_since_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="sent_since_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SENT SINCE "22-Mar-2020" OR containing the STRING
#  "congratulations" in the subject.
res &lt;- con$search(request = AND(sent_since(date_char = "22-Mar-2020"),
                                string(expr = "congratulations",
                                       where = "SUBJECT")))

## End(Not run)
</code></pre>

<hr>
<h2 id='since'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+since'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>since(date_char, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="since_+3A_date_char">date_char</code></td>
<td>
<p>A <code>character string</code> with format &quot;DD-Mon-YYYY&quot;, e.g.
&quot;01-Apr-2019&quot;. We opt not to use <code>Date</code> or <code>POSIX*</code> like
objects, since IMAP servers use this unusual date format.</p>
</td></tr>
<tr><td><code id="since_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A search string to be used as a <code>request</code> parameter in
<code>ImapCon$search()</code> function.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages SINCE "17-Apr-2019" AND SMALLER than 512KB.
res &lt;- con$search(request = AND(since(date_char = "17-Apr-2019"),
                                smaller_than(size = 512000)))

## End(Not run)
</code></pre>

<hr>
<h2 id='smaller_than'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+smaller_than'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smaller_than(size, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smaller_than_+3A_size">size</code></td>
<td>
<p>An integer specifying the number of seconds to be used as
search criterion.</p>
</td></tr>
<tr><td><code id="smaller_than_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+string">string</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages containing the string "XYZ@k-state.edu" in the
# "FROM" field OR those that are SMALLER than 512KB.
res &lt;- con$search(request = OR(string(expr = "XYZ@k-state.edu",
                                      where = "FROM"),
                               smaller_than(size = 512000)))

## End(Not run)

</code></pre>

<hr>
<h2 id='string'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+string'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string(expr, where, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_+3A_expr">expr</code></td>
<td>
<p>A character string specifying the word or expression to search
for in messages.</p>
</td></tr>
<tr><td><code id="string_+3A_where">where</code></td>
<td>
<p>A mandatory character string specifying in which
message's Section or Header Field to search for the provided string.</p>
</td></tr>
<tr><td><code id="string_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+younger_than">younger_than</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages containing the string "XYZ@k-state.edu" in the
#   "FROM" AND the string "@gmail.com" in the "CC" field.
res &lt;- con$search(request = AND(string(expr = "XYZ@k-state.edu",
                                      where = "FROM"),
                               string(expr = "@gmail.com",
                                      where = "CC")))

## End(Not run)

</code></pre>

<hr>
<h2 id='younger_than'>Criterion constructor function to be combined in a custom search statement</h2><span id='topic+younger_than'></span>

<h3>Description</h3>

<p>Criterion constructor function to be combined in a custom search statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>younger_than(seconds, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="younger_than_+3A_seconds">seconds</code></td>
<td>
<p>An integer specifying the number of seconds to be used as
the search criterion.</p>
</td></tr>
<tr><td><code id="younger_than_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, negates the search and seeks for &quot;NOT SEARCH
CRITERIA&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To be able to use this functionality, the server must support the
<code>WITHIN</code> capability.
</p>


<h3>See Also</h3>

<p>Other custom search: 
<code><a href="#topic+AND">AND</a>()</code>,
<code><a href="#topic+ImapCon">ImapCon</a></code>,
<code><a href="#topic+OR">OR</a>()</code>,
<code><a href="#topic+before">before</a>()</code>,
<code><a href="#topic+flag">flag</a>()</code>,
<code><a href="#topic+larger_than">larger_than</a>()</code>,
<code><a href="#topic+older_than">older_than</a>()</code>,
<code><a href="#topic+on">on</a>()</code>,
<code><a href="#topic+sent_before">sent_before</a>()</code>,
<code><a href="#topic+sent_on">sent_on</a>()</code>,
<code><a href="#topic+sent_since">sent_since</a>()</code>,
<code><a href="#topic+since">since</a>()</code>,
<code><a href="#topic+smaller_than">smaller_than</a>()</code>,
<code><a href="#topic+string">string</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select folder &amp; search
con$select_folder(name = "INBOX")
# search for messages containing the string "XYZ@k-state.edu" in the
#   "FROM" field AND those that are YOUNGER than 3600 seconds (1 hour).
res &lt;- con$search(request = AND(string(expr = "XYZ@k-state.edu",
                                      where = "FROM"),
                               younger_than(seconds = 3600)))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
