<!DOCTYPE html><html><head><title>Help for package sievePH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sievePH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggplot_sieve'><p>Plotting Univariate Mark-Specific Proportional Hazards Model Fits Using <code>ggplot</code></p></a></li>
<li><a href='#kernel_sievePH'><p>Nonparametric Kernel-Smoothed Stratified Mark-Specific Proportional Hazards</p>
Model with a Univariate Continuous Mark, Fully Observed in All Failures.</a></li>
<li><a href='#kernel_sievePHaipw'><p>Nonparametric Kernel-Smoothed Stratified Mark-Specific Proportional Hazards</p>
Model with a Univariate Continuous Mark, Missing-at-Random in Some Failures</a></li>
<li><a href='#plot.summary.sievePH'><p>Plotting Mark-Specific Proportional Hazards Model Fits</p></a></li>
<li><a href='#sievePH'><p>Semiparametric Estimation of Coefficients in a Mark-Specific Proportional Hazards</p>
Model with a Multivariate Continuous Mark, Fully Observed in All Failures</a></li>
<li><a href='#sievePHaipw'><p>Semiparametric Augmented Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model</p>
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</a></li>
<li><a href='#sievePHipw'><p>Semiparametric Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model</p>
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</a></li>
<li><a href='#summary.kernel_sievePH'><p>Summarizing Nonparametric Kernel-Smoothed Stratified Mark-Specific</p>
Proportional Hazards Model Fits</a></li>
<li><a href='#summary.sievePH'><p>Summarizing Mark-Specific Proportional Hazards Model Fits</p></a></li>
<li><a href='#testDensRatioGOF'><p>Goodness-of-Fit Test of the Validity of a Univariate or Multivariate Mark Density Ratio Model</p></a></li>
<li><a href='#testIndepTimeMark'><p>Kolmogorov-Smirnov-Type Test of Conditional Independence between the Time-to-Event</p>
and a Multivariate Mark Given Treatment</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sieve Analysis Methods for Proportional Hazards Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a suite of semiparametric and nonparametric kernel-smoothed estimation and testing procedures for continuous mark-specific stratified hazard ratio (treatment/placebo) models in a randomized treatment efficacy trial with a time-to-event endpoint. Semiparametric methods, allowing multivariate marks, are described in Juraska M and Gilbert PB (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. Biometrics 69(2):328-337 &lt;<a href="https://doi.org/10.1111%2Fbiom.12016">doi:10.1111/biom.12016</a>&gt;, and in Juraska M and Gilbert PB (2016), Mark-specific hazard ratio model with missing multivariate marks. Lifetime Data Analysis 22(4):606-25 &lt;<a href="https://doi.org/10.1007%2Fs10985-015-9353-9">doi:10.1007/s10985-015-9353-9</a>&gt;. Nonparametric kernel-smoothed methods, allowing univariate marks only, are described in Sun Y and Gilbert PB (2012), Estimation of stratified mark‐specific proportional hazards models with missing marks. Scandinavian Journal of Statistics}, 39(1):34-52 &lt;<a href="https://doi.org/10.1111%2Fj.1467-9469.2011.00746.x">doi:10.1111/j.1467-9469.2011.00746.x</a>&gt;, and in Gilbert PB and Sun Y (2015), Inferences on relative failure rates in stratified mark-specific proportional hazards models with missing marks, with application to human immunodeficiency virus vaccine efficacy trials. Journal of the Royal Statistical Society Series C: Applied Statistics, 64(1):49-73 &lt;<a href="https://doi.org/10.1111%2Frssc.12067">doi:10.1111/rssc.12067</a>&gt;. Both semiparametric and nonparametric approaches consider two scenarios: (1) the mark is fully observed in all subjects who experience the event of interest, and (2) the mark is subject to missingness-at-random in subjects who experience the event of interest. For models with missing marks, estimators are implemented based on (i) inverse probability weighting (IPW) of complete cases (for the semiparametric framework), and (ii) augmentation of the IPW estimating functions by leveraging correlations between the mark and auxiliary data to 'impute' the augmentation term for subjects with missing marks (for both the semiparametric and nonparametric framework). The augmented IPW estimators are doubly robust and recommended for use with incomplete mark data. The semiparametric methods make two key assumptions: (i) the time-to-event is assumed to be conditionally independent of the mark given treatment, and (ii) the weight function in the semiparametric density ratio/biased sampling model is assumed to be exponential. Diagnostic testing procedures for evaluating validity of both assumptions are implemented. Summary and plotting functions are provided for estimation and inferential results.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mjuraska/sievePH">https://github.com/mjuraska/sievePH</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjuraska/sievePH/issues">https://github.com/mjuraska/sievePH/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, survival, ggplot2, ggpubr, scales, plyr, np</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-16 23:17:51 UTC; mjuraska</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Juraska [aut, cre],
  Li Li [ctb],
  Stephanie Wu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Juraska &lt;mjuraska@fredhutch.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggplot_sieve'>Plotting Univariate Mark-Specific Proportional Hazards Model Fits Using <code>ggplot</code></h2><span id='topic+ggplot_sieve'></span>

<h3>Description</h3>

<p><code>ggplot</code>-style plotting for univariate marks. Point and interval estimates of the mark-specific treatment effect parameter specified by component 
<code>contrast</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> or <code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code> are plotted, together with scatter and box plots of the observed mark values by treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_sieve(
  x,
  mark = NULL,
  tx = NULL,
  xlim = NULL,
  ylim = NULL,
  xtickAt = NULL,
  xtickLab = NULL,
  ytickAt = NULL,
  ytickLab = NULL,
  tickLabSize = 14,
  xlab = NULL,
  ylab = NULL,
  axisLabSize = 15,
  title = NULL,
  titleSize = 16,
  subtitle = NULL,
  subtitleSize = 10,
  txLab = c("Placebo", "Treatment"),
  txLabSize = 5,
  legendLabSize = 12,
  legendPosition = c(0.96, 1.08),
  legendJustification = c(1, 1),
  estLineSize = 1.6,
  ciLineSize = 1.2,
  boxplotWidth = 0.8,
  jitterFactor = 0.1,
  jitterSeed = 0,
  pointColor = c("blue", "red3"),
  pointSize = 1.7,
  bottomPlotMargin = c(-0.5, 0.3, 0, 0),
  topPlotMargin = c(0, 0.3, -0.12, 1.83),
  plotHeights = c(0.33, 0.67)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_sieve_+3A_x">x</code></td>
<td>
<p>an object returned by <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> or <code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_mark">mark</code></td>
<td>
<p>a numeric vector specifying a univariate continuous mark. For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the x-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector of length 2 specifying the y-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xtickat">xtickAt</code></td>
<td>
<p>a numeric vector specifying the position of x-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xticklab">xtickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>xtickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>xtickAt</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ytickat">ytickAt</code></td>
<td>
<p>a numeric vector specifying the position of y-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_yticklab">ytickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>ytickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>ytickAt</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ticklabsize">tickLabSize</code></td>
<td>
<p>a numeric value specifying the font size of tickmark labels along both axes in the bottom panel (<code>14</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_axislabsize">axisLabSize</code></td>
<td>
<p>a numeric value specifying the font size of both axis labels in the bottom panel (<code>15</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_title">title</code></td>
<td>
<p>a character string specifying the plot title (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_titlesize">titleSize</code></td>
<td>
<p>a numeric value specifying the font size of the plot title (<code>16</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_subtitle">subtitle</code></td>
<td>
<p>a character string specifying the plot subtitle (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_subtitlesize">subtitleSize</code></td>
<td>
<p>a numeric value specifying the font size of the plot subtitle (<code>10</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_txlab">txLab</code></td>
<td>
<p>a character vector of length 2 specifying the placebo and treatment labels (in this order). The default labels are <code>placebo</code> and <code>treatment</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_txlabsize">txLabSize</code></td>
<td>
<p>a numeric value specifying the font size of labels <code>txLab</code> (<code>5</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendlabsize">legendLabSize</code></td>
<td>
<p>a numeric value specifying the font size of legend labels in the bottom panel (<code>11</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendposition">legendPosition</code></td>
<td>
<p>a numeric vector of length 2 specifying the position of the legend in the bottom panel (<code>c(0.96, 1.08)</code> by default), passed on to argument <code>legend.position</code> in <code>theme()</code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendjustification">legendJustification</code></td>
<td>
<p>a numeric vector of length 2 specifying the justification of the legend in the bottom panel (<code>c(1, 1)</code> by default), passed on to argument <code>legend.justification</code> in <code>theme()</code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_estlinesize">estLineSize</code></td>
<td>
<p>a numeric value specifying the line width for the point estimate of the mark-specific treatment effect (<code>1.6</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_cilinesize">ciLineSize</code></td>
<td>
<p>a numeric value specifying the line width for the confidence limits for the mark-specific treatment effect (<code>1.2</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_boxplotwidth">boxplotWidth</code></td>
<td>
<p>a numeric value specifying the width of each box in the box plot (<code>0.8</code>) by default</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_jitterfactor">jitterFactor</code></td>
<td>
<p>a numeric value specifying the amount of vertical jitter (<code>0.1</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_jitterseed">jitterSeed</code></td>
<td>
<p>a numeric value setting the seed of R's random number generator for jitter in the scatter plot (<code>0</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_pointcolor">pointColor</code></td>
<td>
<p>a character vector of length 2 color-coding the placebo and treatment group (in this order) in the scatter plot (<code>c("blue", "red3")</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_pointsize">pointSize</code></td>
<td>
<p>a numeric value specifying the size of data points in the scatter plot (<code>1.7</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_bottomplotmargin">bottomPlotMargin</code></td>
<td>
<p>a numeric vector, using cm as the unit, passed on to argument <code>plot.margin</code> in <code>theme()</code> for the bottom panel (<code>c(-0.5, 0.3, 0, 0)</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_topplotmargin">topPlotMargin</code></td>
<td>
<p>a numeric vector, using <code>"lines"</code> as the unit, passed on to argument <code>plot.margin</code> in <code>theme()</code> for the top panel (<code>c(0, 0.3, -0.12, 1.83)</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_plotheights">plotHeights</code></td>
<td>
<p>a numeric vector specifying relative heights of the top and bottom panels (<code>c(0.33, 0.67)</code> by default) passed on to argument <code>heights</code> in <code>ggpubr::ggarrange()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+sievePH">sievePH</a></code>, <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+kernel_sievePH">kernel_sievePH</a></code>, <code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
markRng &lt;- range(mark, na.rm=TRUE)

# fit a model with a univariate mark using the sievePH method
fit1 &lt;- sievePH(eventTime, eventInd, mark, tx)
sfit1 &lt;- summary(fit1, markGrid=seq(markRng[1], markRng[2], length.out=10))
print(ggplot_sieve(sfit1, mark, tx))

# fit a model with a univariate mark using the kernel_sievePH method
fit2 &lt;- kernel_sievePH(eventTime, eventInd, mark, tx,
                      tau = 3, tband = 0.5, hband = 0.3, nvgrid = 20, 
                      nboot = NULL)
sfit2 &lt;- summary(fit2)
print(ggplot_sieve(sfit2, mark, tx))

</code></pre>

<hr>
<h2 id='kernel_sievePH'>Nonparametric Kernel-Smoothed Stratified Mark-Specific Proportional Hazards
Model with a Univariate Continuous Mark, Fully Observed in All Failures.</h2><span id='topic+kernel_sievePH'></span>

<h3>Description</h3>

<p><code>kernel_sievePH</code> implements estimation and hypothesis testing method of
Sun et al. (2009) for a mark-specific proportional hazards model. The methods
allow separate baseline mark-specific hazard functions for different baseline
subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_sievePH(
  eventTime,
  eventInd,
  mark,
  tx,
  zcov = NULL,
  strata = NULL,
  formulaPH = ~tx,
  tau = NULL,
  tband = NULL,
  hband = NULL,
  nvgrid = 100,
  a = NULL,
  b = NULL,
  ntgrid = NULL,
  nboot = 500,
  seed = NULL,
  maxit = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_sievePH_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored
event time.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if
event, 0 if right-censored).</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_mark">mark</code></td>
<td>
<p>a numeric vector specifying a univariate continuous mark. No
missing values are permitted for subjects with <code>eventInd = 1</code>. For
subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should be
set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0
if placebo).</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_zcov">zcov</code></td>
<td>
<p>a data frame with one row per subject specifying possibly
time-dependent covariate(s) (not including <code>tx</code>). If no covariate is
used, <code>zcov</code> should be set to the default of <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by
default). If specified, a separate mark-specific baseline hazard is assumed
for each stratum.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_formulaph">formulaPH</code></td>
<td>
<p>a one-sided formula object (on the right side of the
<code>~</code> operator) specifying the linear predictor in the proportional
hazards model. Available variables to be used in the formula include
<code>tx</code> and variable(s) in <code>zcov</code>. By default, <code>formulaPH</code> is
specified as <code>~ tx</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_tau">tau</code></td>
<td>
<p>a numeric value specifying the duration of study follow-up period.
Failures beyond <code>tau</code> are treated right-censored. There needs to be at
least <code class="reqn">10\%</code> of subjects (as a rule of thumb) remaining uncensored by
<code>tau</code> for the estimation to be stable. By default, <code>tau</code> is set
as the maximum of <code>eventTime</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_tband">tband</code></td>
<td>
<p>a numeric value between 0 and <code>tau</code> specifying the
bandwidth of the kernel smoothing function over time. By default,
<code>tband</code> is set as (<code>tau</code>-min(<code>eventTime</code>))/5.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_hband">hband</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the bandwidth of the
kernel smoothing function over mark. By default, <code>hband</code> is set as
<code class="reqn">4\sigma n^{-1/3}</code> where <code class="reqn">\sigma</code> is the estimated standard
deviation of the observed marks for uncensored failure times and <code class="reqn">n</code> is
the number of subjects in the dataset. Larger bandwidths are recommended
for higher percentages of missing marks.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_nvgrid">nvgrid</code></td>
<td>
<p>an integer value (100 by default) specifying the number of
equally spaced mark values between the minimum and maximum of the observed
mark for which the treatment effects are evaluated.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_a">a</code></td>
<td>
<p>a numeric value between the minimum and maximum of observed mark
values specifying the lower bound of the range for testing the null
hypotheses <code class="reqn">H_{10}: HR(v) = 1</code> and <code class="reqn">H_{20}: HR(v)</code> does not depend
on <code class="reqn">v</code>, for <code class="reqn">v \in [a, b]</code>; By default, <code>a</code> is set as
<code>(max(mark) - min(mark))/nvgrid + min(mark)</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_b">b</code></td>
<td>
<p>a numeric value between the minimum and maximum of observed mark
specifying the upper bound of the range for testing the null hypotheses
<code class="reqn">H_{10}: HR(v) = 1</code> and <code class="reqn">H_{20}: HR(v)</code> does not depend on <code class="reqn">v</code>,
for <code class="reqn">v \in [a, b]</code>; By default, <code>b</code> is set as <code class="reqn">max(mark)</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_ntgrid">ntgrid</code></td>
<td>
<p>an integer value (<code>NULL</code> by default) specifying the number
of equally spaced time points for which the mark-specific baseline hazard
functions are evaluated. If <code>NULL</code>, baseline hazard functions are not
evaluated.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap iterations (500 by default) for simulating
the distributions of test statistics. If <code>NULL</code>, the hypotheses tests
are not performed.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_seed">seed</code></td>
<td>
<p>an integer specifying the random number generation seed for
reproducing the test statistics and p-values. By default, a specific seed
is not set.</p>
</td></tr>
<tr><td><code id="kernel_sievePH_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to attempt for convergence in
estimation. The default is 6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kernel_sievePH</code> analyzes data from a randomized
placebo-controlled trial that evaluates treatment efficacy for a
time-to-event endpoint with a continuous mark. The parameter of interest is
the ratio of the conditional mark-specific hazard functions
(treatment/placebo), which is based on a stratified mark-specific
proportional hazards model. This model assumes no parametric form for the
baseline hazard function nor the treatment effect across different mark
values.
</p>


<h3>Value</h3>

<p>An object of class <code>kernel_sievePH</code> which can be processed by
<code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code> to obtain or print a summary of the
results. An object of class <code>kernel_sievePH</code> is a list containing the
following components:
</p>

<ul>
<li> <p><code>H10</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{10}: HR(v) = 1</code> for v
<code class="reqn">\in [a, b]</code>. Columns <code>TSUP1</code> and <code>Tint1</code> include test
statistics and p-values for testing <code class="reqn">H_{10}</code> vs. <code class="reqn">H_{1a}: HR(v) \neq
1</code> for any v <code class="reqn">\in [a, b]</code> (general alternative). Columns <code>TSUP1m</code>
and <code>Tint1m</code> include test statistics and p-values for testing
<code class="reqn">H_{10}</code> vs. <code class="reqn">H_{1m}: HR(v) \leq 1</code> with strict inequality for some v
in <code class="reqn">[a, b]</code> (monotone alternative). <code>TSUP1</code> and <code>TSUP1m</code> are
based on extensions of the classic Kolmogorov-Smirnov supremum-based test.
<code>Tint1</code> and <code>Tint1m</code> are based on generalizations of the
integration-based Cramer-von Mises test. <code>Tint1</code> and <code>Tint1m</code>
involve integration of deviations over the whole range of the mark. If
<code>nboot</code> is <code>NULL</code>, <code>H10</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>H20</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{20}</code>: HR(v) does not
depend on v <code class="reqn">\in [a, b]</code>. Columns <code>TSUP2</code> and <code>Tint2</code> include
test statistics and p-values for testing <code class="reqn">H_{20}</code> vs. <code class="reqn">H_{2a}</code>: HR
depends on v <code class="reqn">\in [a, b]</code> (general alternative). Columns <code>TSUP2m</code>
and <code>Tint2m</code> include test statistics and p-values for testing
<code class="reqn">H_{20}</code> vs. <code class="reqn">H_{2m}</code>: HR increases as v increases <code class="reqn">\in [a, b]</code>
(monotone alternative). <code>TSUP2</code> and <code>TSUP2m</code> are based on
extensions of the classic Kolmogorov-Smirnov supremum-based test.
<code>Tint2</code> and <code>Tint2m</code> are based on generalizations of the
integration-based Cramer-von Mises test. <code>Tint2</code> and <code>Tint2m</code>
involve integration of deviations over the whole range of the mark. If
<code>nboot</code> is <code>NULL</code>, <code>H20</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>estBeta</code>: a data frame summarizing point estimates and standard
errors of the mark-specific coefficients for treatment at equally-spaced
values between the minimum and the maximum of the observed mark values.
</p>
</li>
<li> <p><code>cBproc1</code>: a data frame containing equally-spaced mark values in
the column <code>Mark</code>, test processes <code class="reqn">Q^{(1)}(v)</code> for observed data in
the column <code>Observed</code>, and <code class="reqn">Q^{(1)}(v)</code> for <code>nboot</code> independent
sets of normal samples in the columns S1, S2, <code class="reqn">\cdots</code>. If
<code>nboot</code> is <code>NULL</code>, <code>cBproc1</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>cBproc2</code>: a data frame containing equally-spaced mark values in
the column <code>Mark</code>, test processes <code class="reqn">Q^{(2)}(v)</code> for observed data in
the column <code>Observed</code>, and <code class="reqn">Q^{(2)}(v)</code> for <code>nboot</code> independent
sets of normal samples in the columns S1, S2, <code class="reqn">\cdots</code>. If
<code>nboot</code> is <code>NULL</code>, <code>cBproc2</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>Lambda0</code>: an array of dimension K x nvgrid x ntgrid for the
kernel-smoothed baseline hazard function <code class="reqn">\lambda_{0k}, k = 1, \dots,
  K</code> where <code class="reqn">K</code> is the number of strata. If <code>ntgrid</code> is <code>NULL</code>
(by default), <code>Lambda0</code> is returned as <code>NULL</code>.</p>
</li></ul>



<h3>References</h3>

<p>Sun, Y., Gilbert, P. B., &amp; McKeague, I. W. (2009). Proportional
hazards models with continuous marks. <em>Annals of statistics</em>, 37(1),
394.
</p>
<p>Yang, G., Sun, Y., Qi, L., &amp; Gilbert, P. B. (2017). Estimation of
stratified mark-specific proportional hazards models under two-phase
sampling with application to HIV vaccine efficacy trials. <em>Statistics
in biosciences</em>, 9, 259-283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240410)
beta &lt;- 2.1
gamma &lt;- -1.3
n &lt;- 200
tx &lt;- rep(0:1, each = n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(gamma)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
alpha &lt;- function(b){ log((1 - exp(-2)) * (b - 2) / (2 * (exp(b - 2) - 1))) }
mark0 &lt;- log(1 - (1 - exp(-2)) * runif(n / 2)) / (-2)
mark1 &lt;- log(1 + (beta - 2) * (1 - exp(-2)) * runif(n / 2) / (2 * exp(alpha(beta)))) /
  (beta - 2)
mark &lt;- ifelse(eventInd == 1, c(mark0, mark1), NA)
# the true TE(v) curve underlying the data-generating mechanism is:
# TE(v) = 1 - exp{alpha(beta) + beta * v + gamma}

# complete-case estimation discards rows with a missing mark
fit &lt;- kernel_sievePH(eventTime, eventInd, mark, tx, tau = 3, tband = 0.5,
                      hband = 0.3, nvgrid = 20, nboot = 20)

</code></pre>

<hr>
<h2 id='kernel_sievePHaipw'>Nonparametric Kernel-Smoothed Stratified Mark-Specific Proportional Hazards
Model with a Univariate Continuous Mark, Missing-at-Random in Some Failures</h2><span id='topic+kernel_sievePHaipw'></span>

<h3>Description</h3>

<p><code>kernel_sievePH</code> implements estimation methods of Sun and Gilbert (2012)
and hypothesis testing methods of Gilbert and Sun (2015) for a mark-specific
proportional hazards model accommodating that some failures have a missing
mark. The methods allow separate baseline mark-specific hazard functions for
different baseline subgroups. Missing marks are handled via augmented IPW
(AIPW) approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_sievePHaipw(
  eventTime,
  eventInd,
  mark,
  tx,
  aux = NULL,
  auxType = NULL,
  zcov = NULL,
  strata = NULL,
  formulaPH = ~tx,
  formulaMiss = NULL,
  formulaAux = NULL,
  tau = NULL,
  tband = NULL,
  hband = NULL,
  nvgrid = 100,
  a = NULL,
  b = NULL,
  ntgrid = NULL,
  nboot = 500,
  seed = NULL,
  maxit = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_sievePHaipw_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored
event time.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if
event, 0 if right-censored).</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_mark">mark</code></td>
<td>
<p>a numeric vector specifying a univariate continuous mark subject
to missingness at random. Missing mark values should be set to <code>NA</code>.
For subjects with <code>eventInd = 0</code>, the value in <code>mark</code> should also
be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0
if placebo).</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_aux">aux</code></td>
<td>
<p>a numeric vector specifying a binary or a continuous auxiliary
covariate which may be potentially useful for predicting missingness, i.e,
the probability of missing, and for informing about the distribution of
missing marks. The mark missingness model only requires that the auxiliary
covariates be observed in subjects who experienced the event of interest.
For subjects with <code>eventInd = 0</code>, the value in <code>aux</code> may be set
to <code>NA</code>. If no auxiliary covariate is used, set <code>aux</code> to the
default of <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_auxtype">auxType</code></td>
<td>
<p>a character string describing the data type of <code>aux</code> if
<code>aux</code> is used. Data types allowed include &quot;binary&quot; and &quot;continuous&quot;.
If <code>aux</code> is not used, <code>auxType</code> should be set to the default of
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_zcov">zcov</code></td>
<td>
<p>a data frame with one row per subject specifying possibly
time-dependent covariate(s) (not including <code>tx</code>). If no covariate is
used, <code>zcov</code> should be set to the default of <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by
default). If specified, a separate mark-specific baseline hazard is assumed
for each stratum. It also allows the models of the probability of
complete-case and of the mark distribution to differ across strata.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_formulaph">formulaPH</code></td>
<td>
<p>a one-sided formula object (on the right side of the
<code>~</code> operator) specifying the linear predictor in the proportional
hazards model. Available variables to be used in the formula include
<code>tx</code> and variable(s) in <code>zcov</code>. By default, <code>formulaPH</code> is
specified as <code>~ tx</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_formulamiss">formulaMiss</code></td>
<td>
<p>a one-sided formula object (on the right side of the
<code>~</code> operator) specifying the linear predictor in the logistic
regression model used for predicting the probability of observing the mark.
<code>formulaMiss</code> must be provided for the <code>AIPW</code> method. Available
variables to be used in the formula include <code>eventTime</code>, <code>tx</code>,
<code>aux</code>, and variable(s) in <code>zcov</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_formulaaux">formulaAux</code></td>
<td>
<p>a one-sided formula object (on the right side of the
<code>~</code> operator) specifying the variables used for estimating the
conditional distribution of <code>aux</code>. If <code>aux</code> is binary, the
formula specifies the linear predictor in a logistic regression and if
<code>aux</code> is continuous, the formula provides a symbolic description of
variables used in kernel conditional density estimation. <code>formulaAux</code>
is optional for the <code>AIPW</code> estimation procedure. Available variables
to be used in the formula include <code>eventTime</code>, <code>tx</code>, <code>mark</code>,
and variable(s) in <code>zcov</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_tau">tau</code></td>
<td>
<p>a numeric value specifying the duration of study follow-up period.
Failures beyond <code>tau</code> are treated right-censored. There needs to be at
least <code class="reqn">10\%</code> of subjects (as a rule of thumb) remaining uncensored by
<code>tau</code> for the estimation to be stable. By default, <code>tau</code> is set
as the maximum of <code>eventTime</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_tband">tband</code></td>
<td>
<p>a numeric value between 0 and <code>tau</code> specifying the
bandwidth of the kernel smoothing function over time. By default,
<code>tband</code> is set as (<code>tau</code>-min(<code>eventTime</code>))/5.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_hband">hband</code></td>
<td>
<p>a numeric value between 0 and 1 specifying the bandwidth of the
kernel smoothing function over mark. By default, <code>hband</code> is set as
<code class="reqn">4\sigma n^{-1/3}</code> where <code class="reqn">\sigma</code> is the estimated standard
deviation of the observed marks for uncensored failure times and <code class="reqn">n</code> is
the number of subjects in the dataset. Larger bandwidths are recommended
for higher percentages of missing marks.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_nvgrid">nvgrid</code></td>
<td>
<p>an integer value (100 by default) specifying the number of
equally spaced mark values between the minimum and maximum of the observed
mark for which the treatment effects are evaluated.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_a">a</code></td>
<td>
<p>a numeric value between the minimum and maximum of observed mark
values specifying the lower bound of the range for testing the null
hypotheses <code class="reqn">H_{10}: HR(v) = 1</code> and <code class="reqn">H_{20}: HR(v)</code> does not depend
on <code class="reqn">v</code>, for <code class="reqn">v \in [a, b]</code>; By default, <code>a</code> is set as
<code>(max(mark) - min(mark))/nvgrid + min(mark)</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_b">b</code></td>
<td>
<p>a numeric value between the minimum and maximum of observed mark
specifying the upper bound of the range for testing the null hypotheses
<code class="reqn">H_{10}: HR(v) = 1</code> and <code class="reqn">H_{20}: HR(v)</code> does not depend on <code class="reqn">v</code>,
for <code class="reqn">v \in [a, b]</code>; By default, <code>b</code> is set as <code class="reqn">max(mark)</code>.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_ntgrid">ntgrid</code></td>
<td>
<p>an integer value (<code>NULL</code> by default) specifying the number
of equally spaced time points for which the mark-specific baseline hazard
functions are evaluated. If <code>NULL</code>, baseline hazard functions are not
evaluated.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap iterations (500 by default) for simulating
the distributions of test statistics. If <code>NULL</code>, the hypotheses tests
are not performed.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_seed">seed</code></td>
<td>
<p>an integer specifying the random number generation seed for
reproducing the test statistics and p-values. By default, a specific seed
is not set.</p>
</td></tr>
<tr><td><code id="kernel_sievePHaipw_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to attempt for convergence in
estimation. The default is 6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kernel_sievePH</code> analyzes data from a randomized
placebo-controlled trial that evaluates treatment efficacy for a
time-to-event endpoint with a continuous mark. The parameter of interest is
the ratio of the conditional mark-specific hazard functions
(treatment/placebo), which is based on a stratified mark-specific
proportional hazards model. This model assumes no parametric form for the
baseline hazard function nor the treatment effect across different mark
values. For data with missing marks, the estimation procedure leverages
auxiliary predictors of whether the mark is observed and augments the IPW
estimator with auxiliary predictors of the missing mark value.
</p>


<h3>Value</h3>

<p>An object of class <code>kernel_sievePH</code> which can be processed by
<code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code> to obtain or print a summary of the
results. An object of class <code>kernel_sievePH</code> is a list containing the
following components:
</p>

<ul>
<li> <p><code>H10</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{10}: HR(v) = 1</code> for v
<code class="reqn">\in [a, b]</code>. Columns <code>TSUP1</code> and <code>Tint1</code> include test
statistics and p-values for testing <code class="reqn">H_{10}</code> vs. <code class="reqn">H_{1a}: HR(v) \neq
1</code> for any v <code class="reqn">\in [a, b]</code> (general alternative). Columns <code>TSUP1m</code>
and <code>Tint1m</code> include test statistics and p-values for testing
<code class="reqn">H_{10}</code> vs. <code class="reqn">H_{1m}: HR(v) \leq 1</code> with strict inequality for some v
in <code class="reqn">[a, b]</code> (monotone alternative). <code>TSUP1</code> and <code>TSUP1m</code> are
based on extensions of the classic Kolmogorov-Smirnov supremum-based test.
<code>Tint1</code> and <code>Tint1m</code> are based on generalizations of the
integration-based Cramer-von Mises test. <code>Tint1</code> and <code>Tint1m</code>
involve integration of deviations over the whole range of the mark. If
<code>nboot</code> is <code>NULL</code>, <code>H10</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>H20</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{20}</code>: HR(v) does not
depend on v <code class="reqn">\in [a, b]</code>. Columns <code>TSUP2</code> and <code>Tint2</code> include
test statistics and p-values for testing <code class="reqn">H_{20}</code> vs. <code class="reqn">H_{2a}</code>: HR
depends on v <code class="reqn">\in [a, b]</code> (general alternative). Columns <code>TSUP2m</code>
and <code>Tint2m</code> include test statistics and p-values for testing
<code class="reqn">H_{20}</code> vs. <code class="reqn">H_{2m}</code>: HR increases as v increases <code class="reqn">\in [a, b]</code>
(monotone alternative). <code>TSUP2</code> and <code>TSUP2m</code> are based on
extensions of the classic Kolmogorov-Smirnov supremum-based test.
<code>Tint2</code> and <code>Tint2m</code> are based on generalizations of the
integration-based Cramer-von Mises test. <code>Tint2</code> and <code>Tint2m</code>
involve integration of deviations over the whole range of the mark. If
<code>nboot</code> is <code>NULL</code>, <code>H20</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>estBeta</code>: a data frame summarizing point estimates and standard
errors of the mark-specific coefficients for treatment at equally-spaced
values between the minimum and the maximum of the observed mark values.
</p>
</li>
<li> <p><code>cBproc1</code>: a data frame containing equally-spaced mark values in
the column <code>Mark</code>, test processes <code class="reqn">Q^{(1)}(v)</code> for observed data in
the column <code>Observed</code>, and <code class="reqn">Q^{(1)}(v)</code> for <code>nboot</code> independent
sets of normal samples in the columns S1, S2, <code class="reqn">\cdots</code>. If
<code>nboot</code> is <code>NULL</code>, <code>cBproc1</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>cBproc2</code>: a data frame containing equally-spaced mark values in
the column <code>Mark</code>, test processes <code class="reqn">Q^{(2)}(v)</code> for observed data in
the column <code>Observed</code>, and <code class="reqn">Q^{(2)}(v)</code> for <code>nboot</code> independent
sets of normal samples in the columns S1, S2, <code class="reqn">\cdots</code>. If
<code>nboot</code> is <code>NULL</code>, <code>cBproc2</code> is returned as <code>NULL</code>.
</p>
</li>
<li> <p><code>Lambda0</code>: an array of dimension K x nvgrid x ntgrid for the
kernel-smoothed baseline hazard function <code class="reqn">\lambda_{0k}, k = 1, \dots,
  K</code> where <code class="reqn">K</code> is the number of strata. If <code>ntgrid</code> is <code>NULL</code>
(by default), <code>Lambda0</code> is returned as <code>NULL</code>.</p>
</li></ul>



<h3>References</h3>

<p>Gilbert, P. B. and Sun, Y. (2015). Inferences on relative failure
rates in stratified mark-specific proportional hazards models with missing
marks, with application to human immunodeficiency virus vaccine efficacy
trials. <em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, 64(1), 49-73.
</p>
<p>Sun, Y. and Gilbert, P. B. (2012). Estimation of stratified mark‐specific
proportional hazards models with missing marks. <em>Scandinavian Journal of
Statistics</em>, 39(1), 34-52.
</p>
<p>Yang, G., Sun, Y., Qi, L., &amp; Gilbert, P. B. (2017). Estimation of
stratified mark-specific proportional hazards models under two-phase
sampling with application to HIV vaccine efficacy trials. <em>Statistics
in biosciences</em>, 9, 259-283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240410)
beta &lt;- 2.1
gamma &lt;- -1.3
n &lt;- 200
tx &lt;- rep(0:1, each = n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(gamma)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
alpha &lt;- function(b){ log((1 - exp(-2)) * (b - 2) / (2 * (exp(b - 2) - 1))) }
mark0 &lt;- log(1 - (1 - exp(-2)) * runif(n / 2)) / (-2)
mark1 &lt;- log(1 + (beta - 2) * (1 - exp(-2)) * runif(n / 2) / (2 * exp(alpha(beta)))) /
  (beta - 2)
mark &lt;- ifelse(eventInd == 1, c(mark0, mark1), NA)
# the true TE(v) curve underlying the data-generating mechanism is:
# TE(v) = 1 - exp{alpha(beta) + beta * v + gamma}

# a binary auxiliary covariate
A &lt;- sapply(exp(-0.5 - 0.2 * mark) / (1 + exp(-0.5 - 0.2 * mark)),
            function(p){ ifelse(is.na(p), NA, rbinom(1, 1, p)) })
linPred &lt;- 1 + 0.4 * tx - 0.2 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, n)
while (sum(R, na.rm = TRUE) &lt; 10){
  R[eventInd == 1] &lt;- sapply(probs[eventInd == 1],
                             function(p){ rbinom(1, 1, p) })
}
# a missing-at-random mark
mark[eventInd == 1] &lt;- ifelse(R[eventInd == 1] == 1, mark[eventInd == 1], NA)

# AIPW estimation; auxiliary covariate is used (not required)
fit &lt;- kernel_sievePHaipw(eventTime, eventInd, mark, tx, aux = A,
                          auxType = "binary", formulaMiss = ~ eventTime,
                          formulaAux = ~ eventTime + tx + mark,
                          tau = 3, tband = 0.5, hband = 0.3, nvgrid = 20,
                          nboot = 20)

</code></pre>

<hr>
<h2 id='plot.summary.sievePH'>Plotting Mark-Specific Proportional Hazards Model Fits</h2><span id='topic+plot.summary.sievePH'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>summary.sievePH</code> and <code>summary.kernel_sievePH</code>. For univariate marks, it plots point and interval estimates of the mark-specific treatment effect parameter specified by <code>contrast</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, and,
optionally, scatter/box plots of the observed mark values by treatment. For bivariate marks, plotting is restricted to the point estimate, which is displayed as a surface. No plotting is provided for marks of higher dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sievePH'
plot(
  x,
  mark = NULL,
  tx = NULL,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  xtickAt = NULL,
  xtickLab = NULL,
  ytickAt = NULL,
  ytickLab = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  txLab = c("Placebo", "Treatment"),
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summary.sievePH_+3A_x">x</code></td>
<td>
<p>an object returned by <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> or <code><a href="#topic+summary.kernel_sievePH">summary.kernel_sievePH</a></code></p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>. For <code>summary.kernel_sievePH</code>, <code>mark</code> must be univariate.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the x-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector of length 2 specifying the y-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_zlim">zlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the z-axis range in a 3-dimensional plot (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xtickat">xtickAt</code></td>
<td>
<p>a numeric vector specifing the position of x-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xticklab">xtickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>xtickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>xtickAt</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ytickat">ytickAt</code></td>
<td>
<p>a numeric vector specifing the position of y-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_yticklab">ytickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>ytickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>ytickAt</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_zlab">zlab</code></td>
<td>
<p>a character string specifying the z-axis label in a 3-dimensional plot (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_txlab">txLab</code></td>
<td>
<p>a character vector of length 2 specifying the placebo and treatment labels (in this order). The default labels are <code>placebo</code> and <code>treatment</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_title">title</code></td>
<td>
<p>a character string specifying the plot title (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For bivariate marks, <code>markGrid</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> must have equally spaced values for each component.
</p>


<h3>Value</h3>

<p>None. The function is called solely for plot generation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sievePH">sievePH</a></code>, <code><a href="#topic+sievePHipw">sievePHipw</a></code>, <code><a href="#topic+sievePHaipw">sievePHaipw</a></code> and <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
markRng &lt;- range(mark, na.rm=TRUE)

# fit a model with a univariate mark
fit &lt;- sievePH(eventTime, eventInd, mark, tx)
sfit &lt;- summary(fit, markGrid=seq(markRng[1], markRng[2], length.out=10))
plot(sfit, mark, tx)

</code></pre>

<hr>
<h2 id='sievePH'>Semiparametric Estimation of Coefficients in a Mark-Specific Proportional Hazards
Model with a Multivariate Continuous Mark, Fully Observed in All Failures</h2><span id='topic+sievePH'></span>

<h3>Description</h3>

<p><code>sievePH</code> implements the semiparametric estimation method of Juraska and Gilbert (2013) for the multivariate mark-
specific hazard ratio in the competing risks failure time analysis framework. It employs (i) the semiparametric
method of maximum profile likelihood estimation in the treatment-to-placebo mark density
ratio model (Qin, 1998) and (ii) the ordinary method of maximum partial likelihood estimation of the overall log hazard ratio in the Cox model.
<code>sievePH</code> requires that the multivariate mark data are fully observed in all failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePH(eventTime, eventInd, mark, tx, strata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePH_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored time to the event of interest</p>
</td></tr>
<tr><td><code id="sievePH_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePH_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
No missing values are permitted for subjects with <code>eventInd = 1</code>. For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePH_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePH_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePH</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the method of Qin (1998), while the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
Both estimators are consistent and asymptotically normal. The joint asymptotic distribution of the estimators is detailed in Juraska and Gilbert (2013).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619–630.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# fit a model with a univariate mark
fit &lt;- sievePH(eventTime, eventInd, mark1, tx)

# fit a model with a bivariate mark
fit &lt;- sievePH(eventTime, eventInd, data.frame(mark1, mark2), tx)

</code></pre>

<hr>
<h2 id='sievePHaipw'>Semiparametric Augmented Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</h2><span id='topic+sievePHaipw'></span>

<h3>Description</h3>

<p><code>sievePHaipw</code> implements the semiparametric augmented inverse probability weighted (AIPW) complete-case estimation method of Juraska and Gilbert (2015) for the multivariate mark-
specific hazard ratio, with the mark subject to missingness at random. It extends Juraska and Gilbert (2013) by (i) weighting complete cases (i.e., subjects with complete marks) by the inverse of their estimated
probabilities given auxiliary covariates and/or treatment, and (ii) adding an augmentation term (the conditional expected profile score given auxiliary covariates and/or treatment) to the IPW estimating equations in the density
ratio model for increased efficiency and robustness to mis-specification of the missingness model (Robins et al., 1994). The probabilities of observing the mark are estimated by fitting a logistic regression model with a user-specified linear predictor.
The mean profile score vector (the augmentation term) in the density ratio model is estimated by fitting a linear regression model with a user-specified linear predictor. Coefficients in the treatment-to-placebo mark density ratio model
(Qin, 1998) are estimated by solving the AIPW estimating equations. The ordinary method of maximum partial likelihood estimation is employed for estimating the overall log hazard ratio in the Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePHaipw(
  eventTime,
  eventInd,
  mark,
  tx,
  aux = NULL,
  strata = NULL,
  formulaMiss,
  formulaScore
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePHaipw_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored event time</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark subject to missingness at random. Missing mark values should be set to <code>NA</code>.
For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should also be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_aux">aux</code></td>
<td>
<p>a data frame specifying auxiliary covariates predictive of the probability of observing the mark. The mark missingness model only requires that the auxiliary covariates be observed in subjects who experienced the event of interest. For subjects with <code>eventInd = 0</code>, the value(s) in <code>aux</code> may be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_formulamiss">formulaMiss</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the logistic regression model used for predicting the probability of observing
the mark. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_formulascore">formulaScore</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the linear regression model used for predicting the expected profile score
vector (the augmentation term) in the AIPW estimating equations in the density ratio model. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePHaipw</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the AIPW complete-case estimation method, following Robins et al. (1994) and extending Qin (1998), and
the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
The asymptotic properties of the AIPW complete-case estimator are detailed in Juraska and Gilbert (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M., and Gilbert, P. B. (2015), Mark-specific hazard ratio model with missing multivariate marks. <em>Lifetime Data Analysis</em> 22(4): 606-25.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>
<p>Robins, J. M., Rotnitzky, A., and Zhao, L. P. (1994), Estimation of regression coefficients when some regressors are not always observed. <em>Journal of the American Statistical Association</em> 89(427): 846-866.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 2, 5), rbeta(n / 2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 1, 3), rbeta(n / 2, 5, 1)), NA)
# a continuous auxiliary covariate
A &lt;- (mark1 + 0.4 * runif(n)) / 1.4
linPred &lt;- -0.8 + 0.4 * tx + 0.8 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, length(probs))
while (sum(R, na.rm=TRUE) &lt; 10){
  R[eventInd==1] &lt;- sapply(probs[eventInd==1], function(p){ rbinom(1, 1, p) })
}
# produce missing-at-random marks
mark1[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark1[eventInd==1], NA)
mark2[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark2[eventInd==1], NA)

# fit a model with a bivariate mark
fit &lt;- sievePHaipw(eventTime, eventInd, mark=data.frame(mark1, mark2), tx,
                   aux=data.frame(A), formulaMiss= ~ tx * A, formulaScore= ~ tx * A + I(A^2))

</code></pre>

<hr>
<h2 id='sievePHipw'>Semiparametric Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</h2><span id='topic+sievePHipw'></span>

<h3>Description</h3>

<p><code>sievePHipw</code> implements the semiparametric inverse probability weighted (IPW) complete-case estimation method of Juraska and Gilbert (2015) for the multivariate mark-
specific hazard ratio, with the mark subject to missingness at random. It extends Juraska and Gilbert (2013) by weighting complete cases by the inverse of their estimated
probabilities given auxiliary covariates and/or treatment. The probabilities are estimated by fitting a logistic regression model with a user-specified linear predictor.
Coefficients in the treatment-to-placebo mark density ratio model (Qin, 1998) are estimated by solving the IPW estimating equations. The ordinary method of maximum partial likelihood
estimation is employed for estimating the overall log hazard ratio in the Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePHipw(
  eventTime,
  eventInd,
  mark,
  tx,
  aux = NULL,
  strata = NULL,
  formulaMiss
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePHipw_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored event time</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark subject to missingness at random. Missing mark values should be set to <code>NA</code>.
For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should also be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_aux">aux</code></td>
<td>
<p>a data frame specifying auxiliary covariates predictive of the probability of observing the mark. The mark missingness model only requires that the auxiliary covariates be observed in subjects who experienced the event of interest. For subjects with <code>eventInd = 0</code>, the value(s) in <code>aux</code> may be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_formulamiss">formulaMiss</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the logistic regression model used for predicting the probability of observing
the mark. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePHipw</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the IPW complete-case estimation method, extending Qin (1998), and
the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
The asymptotic properties of the IPW complete-case estimator are detailed in Juraska and Gilbert (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M., and Gilbert, P. B. (2015), Mark-specific hazard ratio model with missing multivariate marks. <em>Lifetime Data Analysis</em> 22(4): 606-25.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 2, 5), rbeta(n / 2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 1, 3), rbeta(n / 2, 5, 1)), NA)
# a continuous auxiliary covariate
A &lt;- (mark1 + 0.4 * runif(n)) / 1.4
linPred &lt;- -0.8 + 0.4 * tx + 0.8 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, length(probs))
while (sum(R, na.rm=TRUE) &lt; 10){
  R[eventInd==1] &lt;- sapply(probs[eventInd==1], function(p){ rbinom(1, 1, p) })
}
# produce missing-at-random marks
mark1[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark1[eventInd==1], NA)
mark2[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark2[eventInd==1], NA)

# fit a model with a bivariate mark
fit &lt;- sievePHipw(eventTime, eventInd, mark=data.frame(mark1, mark2), tx,
                  aux=data.frame(A), formulaMiss= ~ tx * A)

</code></pre>

<hr>
<h2 id='summary.kernel_sievePH'>Summarizing Nonparametric Kernel-Smoothed Stratified Mark-Specific
Proportional Hazards Model Fits</h2><span id='topic+summary.kernel_sievePH'></span><span id='topic+print.summary.kernel_sievePH'></span>

<h3>Description</h3>

<p><code>summary</code> method for an object of class <code>kernel_sievePH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kernel_sievePH'
summary(
  object,
  contrast = c("te", "hr", "loghr"),
  sieveAlternative = c("twoSided", "oneSided"),
  confLevel = 0.95,
  ...
)

## S3 method for class 'summary.kernel_sievePH'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.kernel_sievePH_+3A_object">object</code></td>
<td>
<p>an object of class <code>kernel_sievePH</code>, a result of a call to
<code><a href="#topic+kernel_sievePH">kernel_sievePH</a></code> and <code><a href="#topic+kernel_sievePHaipw">kernel_sievePHaipw</a></code>.</p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the treatment effect parameter
of interest. The default value is <code>"te"</code> (treatment efficacy); other
options are <code>"hr"</code> (hazard ratio) and <code>"loghr"</code> (log hazard
ratio).</p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_sievealternative">sieveAlternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis for the sieve tests, which can be either <code>"twoSided"</code>
(default) or <code>"oneSided"</code>.</p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level (0.95 by default) of reported
confidence intervals</p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.kernel_sievePH</code>, usually a result of a call to <code>summary.kernel_sievePH</code></p>
</td></tr>
<tr><td><code id="summary.kernel_sievePH_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing (4 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.kernel_sievePH</code> prints a formatted summary of
results. Inference about coefficients in the kernel-smoothed mark-specific
proportional hazards model is tabulated. Additionally, a summary is
generated
from the tests of two relevant null hypotheses: (1) {<code class="reqn">H_0: HR(v)=1</code> for
all <code class="reqn">v</code>}, and (2) {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. For the tests
of (2), <code>sieveAlternative</code> controls the choice of the alternative
hypothesis.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.kernel_sievePH</code>, which is a list
with the following components:
</p>

<ul>
<li> <p><code>estBeta</code>: a data frame summarizing point estimates and standard
errors of the mark-specific coefficients for treatment.
</p>
</li>
<li> <p><code>HRunity.2sided</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{10}: HR(v) = 1</code> vs.
<code class="reqn">H_{1a}: HR(v) \neq 1</code> for any v <code class="reqn">\in [a, b]</code> (general
alternative). <code>TSUP1</code> is based on an extension of the classic Kolmogorov-Smirnov
supremum-based test. <code>Tint1</code> is a generalization
of the integration-based Cramer-von Mises test.
</p>
</li>
<li> <p><code>HRunity.1sided</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{10}: HR(v) = 1</code> vs.
<code class="reqn">H_{1m}: HR(v) \leq 1</code> with strict inequality for some v <code class="reqn">\in [a, b]</code>
(monotone alternative). <code>TSUP1m</code> is based on an extension of the classic
Kolmogorov-Smirnov supremum-based test. <code>Tint1m</code> is a generalization
of the integration-based Cramer-von Mises test.
</p>
</li>
<li> <p><code>HRconstant.2sided</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{20}</code>: HR(v) does not depend on v
<code class="reqn">\in [a, b]</code> vs. <code class="reqn">H_{2a}</code>: HR depends on v <code class="reqn">\in [a, b]</code>
(general alternative). <code>TSUP2</code> is based on an extension of the classic
Kolmogorov-Smirnov supremum-based test. <code>Tint2</code> is a generalization
of the integration-based Cramer-von Mises test.
This component is available if <code>sieveAlternative="twoSided"</code>.
</p>
</li>
<li> <p><code>HRconstant.1sided</code>: a data frame with test statistics (first row) and
corresponding p-values (second row) for testing <code class="reqn">H_{20}</code>: HR(v) does not depend on v
<code class="reqn">\in [a, b]</code> vs. <code class="reqn">H_{2m}</code>: HR increases as v increases <code class="reqn">\in [a, b]</code>
(monotone alternative). <code>TSUP2m</code> is based on an extension of the classic
Kolmogorov-Smirnov supremum-based test. <code>Tint2m</code> is a generalization
of the integration-based Cramer-von Mises test.
This component is available if <code>sieveAlternative="oneSided"</code>.
</p>
</li>
<li> <p><code>te</code>: a data frame summarizing point and interval estimates of the
mark-specific treatment efficacy on the grid of mark values defined by
<code>nvgrid</code> spanning from the minimum and maximum of the mark (available if <code>contrast="te"</code>).
The confidence level is specified by <code>confLevel</code>.
</p>
</li>
<li> <p><code>hr</code>: a data frame summarizing point and interval estimates of the
mark-specific hazard ratio on the grid of mark values defined by
<code>nvgrid</code> spanning from the minimum and maximum of the mark (available if
<code>contrast="hr"</code>). The confidence level is specified by <code>confLevel</code>.
</p>
</li>
<li> <p><code>loghr</code>: a data frame summarizing point and interval estimates of
the mark-specific log hazard ratio on the grid of mark values defined by
<code>nvgrid</code> spanning from the minimum and maximum of the mark (available if
<code>contrast="loghr"</code>). The confidence level is specified by
<code>confLevel</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Gilbert, P. B. and Sun, Y. (2015). Inferences on relative failure rates in
stratified mark-specific proportional hazards models with missing marks, with
application to human immunodeficiency virus vaccine efficacy trials.
<em>Journal of the Royal Statistical Society Series C: Applied Statistics</em>,
64(1), 49-73.
</p>
<p>Sun, Y. and Gilbert, P. B. (2012). Estimation of stratified mark‐specific
proportional hazards models with missing marks. <em>Scandinavian Journal of
Statistics</em>, 39(1), 34-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel_sievePH">kernel_sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20240410)
beta &lt;- 2.1
gamma &lt;- -1.3
n &lt;- 200
tx &lt;- rep(0:1, each = n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(gamma)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
alpha &lt;- function(b){ log((1 - exp(-2)) * (b - 2) / (2 * (exp(b - 2) - 1))) }
mark0 &lt;- log(1 - (1 - exp(-2)) * runif(n / 2)) / (-2)
mark1 &lt;- log(1 + (beta - 2) * (1 - exp(-2)) * runif(n / 2) / (2 * exp(alpha(beta)))) /
  (beta - 2)
mark &lt;- ifelse(eventInd == 1, c(mark0, mark1), NA)
# the true TE(v) curve underlying the data-generating mechanism is:
# TE(v) = 1 - exp{alpha(beta) + beta * v + gamma}

# a binary auxiliary covariate
A &lt;- sapply(exp(-0.5 - 0.2 * mark) / (1 + exp(-0.5 - 0.2 * mark)),
            function(p){ ifelse(is.na(p), NA, rbinom(1, 1, p)) })
linPred &lt;- 1 + 0.4 * tx - 0.2 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, n)
while (sum(R, na.rm = TRUE) &lt; 10){
  R[eventInd == 1] &lt;- sapply(probs[eventInd == 1],
                             function(p){ rbinom(1, 1, p) })
}
# a missing-at-random mark
mark[eventInd == 1] &lt;- ifelse(R[eventInd == 1] == 1, mark[eventInd == 1], NA)

# AIPW estimation; auxiliary covariate is used (not required)
fit &lt;- kernel_sievePHaipw(eventTime, eventInd, mark, tx, aux = A,
                          auxType = "binary", formulaMiss = ~ eventTime,
                          formulaAux = ~ eventTime + tx + mark,
                          tau = 3, tband = 0.5, hband = 0.3, nvgrid = 20,
                          nboot = 20)
sfit &lt;- summary(fit)
# print the formatted summary
sfit
# treatment efficacy estimates on the grid
sfit$te

</code></pre>

<hr>
<h2 id='summary.sievePH'>Summarizing Mark-Specific Proportional Hazards Model Fits</h2><span id='topic+summary.sievePH'></span><span id='topic+print.summary.sievePH'></span>

<h3>Description</h3>

<p><code>summary</code> method for an object of class <code>sievePH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sievePH'
summary(
  object,
  markGrid,
  contrast = c("te", "hr", "loghr"),
  sieveAlternative = c("twoSided", "oneSided"),
  confLevel = 0.95,
  ...
)

## S3 method for class 'summary.sievePH'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sievePH_+3A_object">object</code></td>
<td>
<p>an object of class <code>sievePH</code>, usually a result of a call to <code><a href="#topic+sievePH">sievePH</a></code></p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_markgrid">markGrid</code></td>
<td>
<p>a matrix specifying a grid of multivariate mark values, where rows correspond to different values on the (multivariate) grid and columns correspond to components of the mark. A numeric vector is allowed
for univariate marks. The point and interval estimates of the <code>contrast</code> are calculated on this grid.</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the treatment effect parameter of interest. The default value is <code>"te"</code> (treatment efficacy); other options are <code>"hr"</code> (hazard ratio) and <code>"loghr"</code> (log hazard ratio).</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_sievealternative">sieveAlternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis for the sieve tests, which can be either <code>"twoSided"</code> (default) or, in case of a univariate mark, <code>"oneSided"</code>.
The one-sided option is unavailable for a multivariate mark.</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level (0.95 by default) of reported confidence intervals</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sievePH</code>, usually a result of a call to <code>summary.sievePH</code></p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing (4 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.sievePH</code> prints a formatted summary of results. Inference about coefficients in the mark-specific proportional hazards model is tabulated. Additionally, a summary is generated
from the likelihood-ratio and Wald tests of two relevant null hypotheses: (1) {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>}, and (2) {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. For the tests of (2) and a univariate
mark, <code>sieveAlternative</code> controls the choice of the alternative hypothesis.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.sievePH</code>, which is a list with the following components:
</p>

<ul>
<li> <p><code>coef</code>: a data frame summarizing point and interval estimates of the density ratio model coefficients and the marginal log hazard ratio (the confidence level is specified by <code>confLevel</code>), and p-values from the
two-sided Wald test of the null hypothesis that the parameter equals zero
</p>
</li>
<li> <p><code>pLR.HRunity.2sided</code>: a numeric vector with two named components: <code>pLR.dRatio.2sided</code> is a p-value from the two-sided profile likelihood-ratio test of the null hypothesis <code class="reqn">H_0: \beta=0</code>, where <code class="reqn">\beta</code> is the
vector of mark coefficients in the mark density ratio model, and <code>pLR.cox.2sided</code> is a p-value from the two-sided partial likelihood-ratio test of the null hypothesis <code class="reqn">H_0: \gamma=0</code>, where <code class="reqn">\gamma</code> is the
marginal log hazard ratio in the Cox model. The two p-values are intended for the use of the Simes (1986) procedure as described on page 4 in Juraska and Gilbert (2013).
</p>
</li>
<li> <p><code>pWald.HRunity.2sided</code>: a p-value from the two-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>}
</p>
</li>
<li> <p><code>pWtWald.HRunity.1sided</code>: a p-value from the one-sided weighted Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>} against the alternative hypothesis {<code class="reqn">H_1: HR &lt; 1</code> and <code class="reqn">HR(v)</code> is
increasing in each component of <code class="reqn">v</code>}
</p>
</li>
<li> <p><code>pLR.HRconstant.2sided</code>: a p-value from the two-sided profile likelihood-ratio test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. This component is available if <code>sieveAlternative="twoSided"</code>.
</p>
</li>
<li> <p><code>pLR.HRconstant.1sided</code>: a numeric vector with two named components: <code>pLR.dRatio.2sided</code> is a p-value from the two-sided profile likelihood-ratio test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>},
and <code>estBeta</code> is the point estimate of the univariate mark coefficient in the density ratio model. This component is available if the mark is univariate and <code>sieveAlternative="oneSided"</code>.
</p>
</li>
<li> <p><code>pWald.HRconstant.2sided</code>: a p-value from the two-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. This component is available if <code>sieveAlternative="twoSided"</code>.
</p>
</li>
<li> <p><code>pWald.HRconstant.1sided</code>: a p-value from the one-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>} against the alternative hypothesis {<code class="reqn">H_1: HR(v)</code> is increasing in <code class="reqn">v</code>}.
This component is available if the mark is univariate and <code>sieveAlternative="oneSided"</code>.
</p>
</li>
<li> <p><code>te</code>: a data frame summarizing point and interval estimates of the mark-specific treatment efficacy on the grid of mark values in <code>markGrid</code> (available if <code>contrast="te"</code>). The confidence level is specified
by <code>confLevel</code>.
</p>
</li>
<li> <p><code>hr</code>: a data frame summarizing point and interval estimates of the mark-specific hazard ratio on the grid of mark values in <code>markGrid</code> (available if <code>contrast="hr"</code>). The confidence level is specified by
<code>confLevel</code>.
</p>
</li>
<li> <p><code>loghr</code>: a data frame summarizing point and interval estimates of the mark-specific log hazard ratio on the grid of mark values in <code>markGrid</code> (available if <code>contrast="loghr"</code>). The confidence level is specified by
<code>confLevel</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sievePH">sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# fit a model with a bivariate mark
fit &lt;- sievePH(eventTime, eventInd, data.frame(mark1, mark2), tx)
sfit &lt;- summary(fit, markGrid=matrix(c(0.3, 0.3, 0.6, 0.3, 0.3, 0.6, 0.6, 0.6),
                                     ncol=2, byrow=TRUE))
# print the formatted summary
sfit
# treatment efficacy estimates on the grid
sfit$te

</code></pre>

<hr>
<h2 id='testDensRatioGOF'>Goodness-of-Fit Test of the Validity of a Univariate or Multivariate Mark Density Ratio Model</h2><span id='topic+testDensRatioGOF'></span>

<h3>Description</h3>

<p><code>testDensRatioGoF</code> implements the complete-case goodness-of-fit test of Qin and Zhang (1997) for evaluating the validity of the specified mark density ratio model used for modeling a component of
the mark-specific hazard ratio model in Juraska and Gilbert (2013). Multivariate marks are accommodated. Subjects who experienced the event of interest but their mark is missing are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensRatioGOF(
  eventInd,
  mark,
  tx,
  DRcoef = NULL,
  DRlambda = NULL,
  iter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensRatioGOF_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_drcoef">DRcoef</code></td>
<td>
<p>a numeric vector of the coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi) = \exp\{\phi^T (1, v)\}</code> in the density ratio model. If <code>NULL</code> (default), the maximum profile likelihood estimates (Qin, 1998)
of the coefficients are computed.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_drlambda">DRlambda</code></td>
<td>
<p>the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter). If <code>NULL</code> (default), the maximum profile likelihood estimate (Qin, 1998)
of the Lagrange multiplier is computed.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations (1000 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>testDensRatioGoF</code> performs a goodness-of-fit test for the exponential form of the weight function, i.e., <code class="reqn">g(v, \phi) = \exp\{\phi^T (1, v)\}</code>. Other weight functions are not considered.
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<ul>
<li> <p><code>teststat</code>: the value of the Kolmogorov-Smirnov-type test statistic
</p>
</li>
<li> <p><code>pval</code>: the bootstrap p-value from the Kolmogorov-Smirnov-type test of validity of the mark density ratio model
</p>
</li>
<li> <p><code>DRcoef</code>: the input object if different from <code>NULL</code> or a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: the input object if different from <code>NULL</code> or an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code>
</p>
</li></ul>



<h3>References</h3>

<p>Qin, J., &amp; Zhang, B. (1997). A goodness-of-fit test for logistic regression models based on case-control data. <em>Biometrika</em>, 84(3), 609-618.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# test goodness-of-fit for a univariate mark
testDensRatioGOF(eventInd, mark1, tx, iter=15)

# test goodness-of-fit for a bivariate mark
testDensRatioGOF(eventInd, data.frame(mark1, mark2), tx, iter=15)

</code></pre>

<hr>
<h2 id='testIndepTimeMark'>Kolmogorov-Smirnov-Type Test of Conditional Independence between the Time-to-Event
and a Multivariate Mark Given Treatment</h2><span id='topic+testIndepTimeMark'></span>

<h3>Description</h3>

<p>A nonparametric Komogorov-Smirnov-type test of the null hypothesis that the time-to-event <code class="reqn">T</code> and a possibly multivariate mark <code class="reqn">V</code> are conditionally independent given treatment <code class="reqn">Z</code>
as described in Juraska and Gilbert (2013). The conditional independence is a necessary assumption for parameter identifiability in the time-independent density ratio model. A bootstrap
algorithm is used to compute the p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testIndepTimeMark(data, iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testIndepTimeMark_+3A_data">data</code></td>
<td>
<p>a data frame restricted to subjects in a given treatment group with the following columns (in this order): the observed right-censored time to the event of interest,
the event indicator (1 if event, 0 if right-censored), and the mark variable (one column for each component, if multivariate)</p>
</td></tr>
<tr><td><code id="testIndepTimeMark_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations (1000 by default) used for computing the p-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is the supremum of the difference between the estimated conditional joint cumulative distribution function (cdf) of <code class="reqn">(T,V)</code> given <code class="reqn">Z</code> and the product of
the estimated conditional cdfs of <code class="reqn">T</code> and <code class="reqn">V</code> given <code class="reqn">Z</code>. The joint cdf is estimated by the nonparametric maximum likelihood estimator developed by
Huang and Louis (1998). The marginal cdf of <code class="reqn">T</code> is estimated as one minus the Kaplan-Meier estimator for the conditional survival function of <code class="reqn">T</code>, and the
cdf of <code class="reqn">V</code> is estimated as the empirical cdf of the observed values of <code class="reqn">V</code>. A bootstrap algorithm is used to compute the p-value.
</p>


<h3>Value</h3>

<p>Returns the bootstrap p-value from the test of conditional independence between <code class="reqn">T</code> and <code class="reqn">V</code> given <code class="reqn">Z</code>.
</p>


<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>
<p>Huang, Y. and Louis, T. (1998), Nonparametric estimation of the joint distribution of survival time and mark variables. <em>Biometrika</em> 85, 785–798.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# perform the test for a univariate mark in the placebo group
testIndepTimeMark(data.frame(eventTime, eventInd, mark1)[tx==0, ], iter=20)

# perform the test for a bivariate mark in the placebo group
testIndepTimeMark(data.frame(eventTime, eventInd, mark1, mark2)[tx==0, ], iter=20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
