<!DOCTYPE html><html><head><title>Help for package sievePH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sievePH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggplot_sieve'><p>Plotting Univariate Mark-Specific Proportional Hazards Model Fits Using <code>ggplot</code></p></a></li>
<li><a href='#plot.summary.sievePH'><p>Plotting Mark-Specific Proportional Hazards Model Fits</p></a></li>
<li><a href='#sievePH'><p>Semiparametric Estimation of Coefficients in a Mark-Specific Proportional Hazards</p>
Model with a Multivariate Continuous Mark, Fully Observed in All Failures</a></li>
<li><a href='#sievePHaipw'><p>Semiparametric Augmented Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model</p>
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</a></li>
<li><a href='#sievePHipw'><p>Semiparametric Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model</p>
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</a></li>
<li><a href='#summary.sievePH'><p>Summarizing Mark-Specific Proportional Hazards Model Fits</p></a></li>
<li><a href='#testDensRatioGOF'><p>Goodness-of-Fit Test of the Validity of a Univariate or Multivariate Mark Density Ratio Model</p></a></li>
<li><a href='#testIndepTimeMark'><p>Kolmogorov-Smirnov-Type Test of Conditional Independence between the Time-to-Event</p>
and a Multivariate Mark Given Treatment</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sieve Analysis Methods for Proportional Hazards Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements semiparametric estimation and testing procedures for a continuous, possibly multivariate, mark-specific hazard ratio (treatment/placebo) of an event of interest in a randomized treatment efficacy trial with a time-to-event endpoint, as described in Juraska M and Gilbert PB (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. Biometrics 69(2):328 337 &lt;<a href="https://doi.org/10.1111%2Fbiom.12016">doi:10.1111/biom.12016</a>&gt;, and in Juraska M and Gilbert PB (2016), Mark-specific hazard ratio model with missing multivariate marks. Lifetime Data Analysis 22(4): 606-25 &lt;<a href="https://doi.org/10.1007%2Fs10985-015-9353-9">doi:10.1007/s10985-015-9353-9</a>&gt;. The former considers continuous multivariate marks fully observed in all subjects who experience the event of interest, whereas the latter extends the previous work to allow multivariate marks that are subject to missingness-at-random. For models with missing marks, two estimators are implemented based on (i) inverse probability weighting (IPW) of complete cases, and (ii) augmentation of the IPW estimating functions by leveraging correlations between the mark and auxiliary data to 'impute' the expected profile score vectors for subjects with missing marks. The augmented IPW estimator is doubly robust and recommended for use with incomplete mark data. The methods make two key assumptions: (i) the time-to-event is assumed to be conditionally independent of the mark given treatment, and (ii) the weight function in the semiparametric density ratio/biased sampling model is assumed to be exponential. Diagnostic testing procedures for evaluating validity of both assumptions are implemented. Summary and plotting functions are provided for estimation and inferential results.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mjuraska/sievePH">https://github.com/mjuraska/sievePH</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mjuraska/sievePH/issues">https://github.com/mjuraska/sievePH/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, survival, ggplot2, ggpubr, scales</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-03 18:08:16 UTC; mjuraska</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Juraska [aut, cre],
  Stephanie Wu [ctb],
  Li Li [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Juraska &lt;mjuraska@fredhutch.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-03 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggplot_sieve'>Plotting Univariate Mark-Specific Proportional Hazards Model Fits Using <code>ggplot</code></h2><span id='topic+ggplot_sieve'></span>

<h3>Description</h3>

<p><code>ggplot</code>-style plotting for univariate marks. Point and interval estimates of the mark-specific treatment effect parameter specified by component  <code>contrast</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> are plotted, together with scatter and box plots of the observed mark values by treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_sieve(
  x,
  mark = NULL,
  tx = NULL,
  xlim = NULL,
  ylim = NULL,
  xtickAt = NULL,
  xtickLab = NULL,
  ytickAt = NULL,
  ytickLab = NULL,
  tickLabSize = 14,
  xlab = NULL,
  ylab = NULL,
  axisLabSize = 15,
  title = NULL,
  titleSize = 16,
  subtitle = NULL,
  subtitleSize = 10,
  txLab = c("Placebo", "Treatment"),
  txLabSize = 5,
  legendLabSize = 12,
  legendPosition = c(0.96, 1.08),
  legendJustification = c(1, 1),
  estLineSize = 1.6,
  ciLineSize = 1.2,
  boxplotWidth = 0.8,
  jitterFactor = 0.1,
  jitterSeed = 0,
  pointColor = c("blue", "red3"),
  pointSize = 1.7,
  bottomPlotMargin = c(-0.5, 0.3, 0, 0),
  topPlotMargin = c(0, 0.3, -0.12, 1.83),
  plotHeights = c(0.33, 0.67)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_sieve_+3A_x">x</code></td>
<td>
<p>an object returned by <code><a href="#topic+summary.sievePH">summary.sievePH</a></code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_mark">mark</code></td>
<td>
<p>a numeric vector specifying a univariate continuous mark. For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the x-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector of length 2 specifying the y-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xtickat">xtickAt</code></td>
<td>
<p>a numeric vector specifying the position of x-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xticklab">xtickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>xtickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>xtickAt</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ytickat">ytickAt</code></td>
<td>
<p>a numeric vector specifying the position of y-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_yticklab">ytickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>ytickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>ytickAt</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ticklabsize">tickLabSize</code></td>
<td>
<p>a numeric value specifying the font size of tickmark labels along both axes in the bottom panel (<code>14</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_axislabsize">axisLabSize</code></td>
<td>
<p>a numeric value specifying the font size of both axis labels in the bottom panel (<code>15</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_title">title</code></td>
<td>
<p>a character string specifying the plot title (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_titlesize">titleSize</code></td>
<td>
<p>a numeric value specifying the font size of the plot title (<code>16</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_subtitle">subtitle</code></td>
<td>
<p>a character string specifying the plot subtitle (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_subtitlesize">subtitleSize</code></td>
<td>
<p>a numeric value specifying the font size of the plot subtitle (<code>10</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_txlab">txLab</code></td>
<td>
<p>a character vector of length 2 specifying the placebo and treatment labels (in this order). The default labels are <code>placebo</code> and <code>treatment</code>.</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_txlabsize">txLabSize</code></td>
<td>
<p>a numeric value specifying the font size of labels <code>txLab</code> (<code>5</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendlabsize">legendLabSize</code></td>
<td>
<p>a numeric value specifying the font size of legend labels in the bottom panel (<code>11</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendposition">legendPosition</code></td>
<td>
<p>a numeric vector of length 2 specifying the position of the legend in the bottom panel (<code>c(0.96, 1.08)</code> by default), passed on to argument <code>legend.position</code> in <code>theme()</code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_legendjustification">legendJustification</code></td>
<td>
<p>a numeric vector of length 2 specifying the justification of the legend in the bottom panel (<code>c(1, 1)</code> by default), passed on to argument <code>legend.justification</code> in <code>theme()</code></p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_estlinesize">estLineSize</code></td>
<td>
<p>a numeric value specifying the line width for the point estimate of the mark-specific treatment effect (<code>1.6</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_cilinesize">ciLineSize</code></td>
<td>
<p>a numeric value specifying the line width for the confidence limits for the mark-specific treatment effect (<code>1.2</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_boxplotwidth">boxplotWidth</code></td>
<td>
<p>a numeric value specifying the width of each box in the box plot (<code>0.8</code>) by default</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_jitterfactor">jitterFactor</code></td>
<td>
<p>a numeric value specifying the amount of vertical jitter (<code>0.1</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_jitterseed">jitterSeed</code></td>
<td>
<p>a numeric value setting the seed of R's random number generator for jitter in the scatter plot (<code>0</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_pointcolor">pointColor</code></td>
<td>
<p>a character vector of length 2 color-coding the placebo and treatment group (in this order) in the scatter plot (<code>c("blue", "red3")</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_pointsize">pointSize</code></td>
<td>
<p>a numeric value specifying the size of data points in the scatter plot (<code>1.7</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_bottomplotmargin">bottomPlotMargin</code></td>
<td>
<p>a numeric vector, using cm as the unit, passed on to argument <code>plot.margin</code> in <code>theme()</code> for the bottom panel (<code>c(-0.5, 0.3, 0, 0)</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_topplotmargin">topPlotMargin</code></td>
<td>
<p>a numeric vector, using <code>"lines"</code> as the unit, passed on to argument <code>plot.margin</code> in <code>theme()</code> for the top panel (<code>c(0, 0.3, -0.12, 1.83)</code> by default)</p>
</td></tr>
<tr><td><code id="ggplot_sieve_+3A_plotheights">plotHeights</code></td>
<td>
<p>a numeric vector specifying relative heights of the top and bottom panels (<code>c(0.33, 0.67)</code> by default) passed on to argument <code>heights</code> in <code>ggpubr::ggarrange()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+sievePH">sievePH</a></code> and <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
markRng &lt;- range(mark, na.rm=TRUE)

# fit a model with a univariate mark
fit &lt;- sievePH(eventTime, eventInd, mark, tx)
sfit &lt;- summary(fit, markGrid=seq(markRng[1], markRng[2], length.out=10))
print(ggplot_sieve(sfit, mark, tx))

</code></pre>

<hr>
<h2 id='plot.summary.sievePH'>Plotting Mark-Specific Proportional Hazards Model Fits</h2><span id='topic+plot.summary.sievePH'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>summary.sievePH</code>. For univariate marks, it plots point and interval estimates of the mark-specific treatment effect parameter specified by <code>contrast</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, and,
optionally, scatter/box plots of the observed mark values by treatment. For bivariate marks, plotting is restricted to the point estimate, which is displayed as a surface. No plotting is provided for marks of higher dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sievePH'
plot(
  x,
  mark = NULL,
  tx = NULL,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  xtickAt = NULL,
  xtickLab = NULL,
  ytickAt = NULL,
  ytickLab = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  txLab = c("Placebo", "Treatment"),
  title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summary.sievePH_+3A_x">x</code></td>
<td>
<p>an object returned by <code><a href="#topic+summary.sievePH">summary.sievePH</a></code></p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the x-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector of length 2 specifying the y-axis range (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_zlim">zlim</code></td>
<td>
<p>a numeric vector of length 2 specifying the z-axis range in a 3-dimensional plot (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xtickat">xtickAt</code></td>
<td>
<p>a numeric vector specifing the position of x-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xticklab">xtickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>xtickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>xtickAt</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ytickat">ytickAt</code></td>
<td>
<p>a numeric vector specifing the position of y-axis tickmarks (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_yticklab">ytickLab</code></td>
<td>
<p>a numeric vector specifying labels for tickmarks listed in <code>ytickAt</code>. If <code>NULL</code> (default), the labels are determined by <code>ytickAt</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_zlab">zlab</code></td>
<td>
<p>a character string specifying the z-axis label in a 3-dimensional plot (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_txlab">txLab</code></td>
<td>
<p>a character vector of length 2 specifying the placebo and treatment labels (in this order). The default labels are <code>placebo</code> and <code>treatment</code>.</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_title">title</code></td>
<td>
<p>a character string specifying the plot title (<code>NULL</code> by default)</p>
</td></tr>
<tr><td><code id="plot.summary.sievePH_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For bivariate marks, <code>markGrid</code> in <code><a href="#topic+summary.sievePH">summary.sievePH</a></code> must have equally spaced values for each component.
</p>


<h3>Value</h3>

<p>None. The function is called solely for plot generation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sievePH">sievePH</a></code>, <code><a href="#topic+sievePHipw">sievePHipw</a></code>, <code><a href="#topic+sievePHaipw">sievePHaipw</a></code> and <code><a href="#topic+summary.sievePH">summary.sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
markRng &lt;- range(mark, na.rm=TRUE)

# fit a model with a univariate mark
fit &lt;- sievePH(eventTime, eventInd, mark, tx)
sfit &lt;- summary(fit, markGrid=seq(markRng[1], markRng[2], length.out=10))
plot(sfit, mark, tx)

</code></pre>

<hr>
<h2 id='sievePH'>Semiparametric Estimation of Coefficients in a Mark-Specific Proportional Hazards
Model with a Multivariate Continuous Mark, Fully Observed in All Failures</h2><span id='topic+sievePH'></span>

<h3>Description</h3>

<p><code>sievePH</code> implements the semiparametric estimation method of Juraska and Gilbert (2013) for the multivariate mark-
specific hazard ratio in the competing risks failure time analysis framework. It employs (i) the semiparametric
method of maximum profile likelihood estimation in the treatment-to-placebo mark density
ratio model (Qin, 1998) and (ii) the ordinary method of maximum partial likelihood estimation of the overall log hazard ratio in the Cox model.
<code>sievePH</code> requires that the multivariate mark data are fully observed in all failures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePH(eventTime, eventInd, mark, tx, strata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePH_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored time to the event of interest</p>
</td></tr>
<tr><td><code id="sievePH_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePH_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
No missing values are permitted for subjects with <code>eventInd = 1</code>. For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePH_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePH_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePH</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the method of Qin (1998), while the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
Both estimators are consistent and asymptotically normal. The joint asymptotic distribution of the estimators is detailed in Juraska and Gilbert (2013).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619–630.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# fit a model with a univariate mark
fit &lt;- sievePH(eventTime, eventInd, mark1, tx)

# fit a model with a bivariate mark
fit &lt;- sievePH(eventTime, eventInd, data.frame(mark1, mark2), tx)

</code></pre>

<hr>
<h2 id='sievePHaipw'>Semiparametric Augmented Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</h2><span id='topic+sievePHaipw'></span>

<h3>Description</h3>

<p><code>sievePHaipw</code> implements the semiparametric augmented inverse probability weighted (AIPW) complete-case estimation method of Juraska and Gilbert (2015) for the multivariate mark-
specific hazard ratio, with the mark subject to missingness at random. It extends Juraska and Gilbert (2013) by (i) weighting complete cases (i.e., subjects with complete marks) by the inverse of their estimated
probabilities given auxiliary covariates and/or treatment, and (ii) adding an augmentation term (the conditional expected profile score given auxiliary covariates and/or treatment) to the IPW estimating equations in the density
ratio model for increased efficiency and robustness to mis-specification of the missingness model (Robins et al., 1994). The probabilities of observing the mark are estimated by fitting a logistic regression model with a user-specified linear predictor.
The mean profile score vector (the augmentation term) in the density ratio model is estimated by fitting a linear regression model with a user-specified linear predictor. Coefficients in the treatment-to-placebo mark density ratio model
(Qin, 1998) are estimated by solving the AIPW estimating equations. The ordinary method of maximum partial likelihood estimation is employed for estimating the overall log hazard ratio in the Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePHaipw(
  eventTime,
  eventInd,
  mark,
  tx,
  aux = NULL,
  strata = NULL,
  formulaMiss,
  formulaScore
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePHaipw_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored event time</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark subject to missingness at random. Missing mark values should be set to <code>NA</code>.
For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should also be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_aux">aux</code></td>
<td>
<p>a data frame specifying auxiliary covariates predictive of the probability of observing the mark. The mark missingness model only requires that the auxiliary covariates be observed in subjects who experienced the event of interest. For subjects with <code>eventInd = 0</code>, the value(s) in <code>aux</code> may be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_formulamiss">formulaMiss</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the logistic regression model used for predicting the probability of observing
the mark. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
<tr><td><code id="sievePHaipw_+3A_formulascore">formulaScore</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the linear regression model used for predicting the expected profile score
vector (the augmentation term) in the AIPW estimating equations in the density ratio model. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePHaipw</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the AIPW complete-case estimation method, following Robins et al. (1994) and extending Qin (1998), and
the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
The asymptotic properties of the AIPW complete-case estimator are detailed in Juraska and Gilbert (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M., and Gilbert, P. B. (2015), Mark-specific hazard ratio model with missing multivariate marks. <em>Lifetime Data Analysis</em> 22(4): 606-25.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>
<p>Robins, J. M., Rotnitzky, A., and Zhao, L. P. (1994), Estimation of regression coefficients when some regressors are not always observed. <em>Journal of the American Statistical Association</em> 89(427): 846-866.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 2, 5), rbeta(n / 2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 1, 3), rbeta(n / 2, 5, 1)), NA)
# a continuous auxiliary covariate
A &lt;- (mark1 + 0.4 * runif(n)) / 1.4
linPred &lt;- -0.8 + 0.4 * tx + 0.8 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, length(probs))
while (sum(R, na.rm=TRUE) &lt; 10){
  R[eventInd==1] &lt;- sapply(probs[eventInd==1], function(p){ rbinom(1, 1, p) })
}
# produce missing-at-random marks
mark1[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark1[eventInd==1], NA)
mark2[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark2[eventInd==1], NA)

# fit a model with a bivariate mark
fit &lt;- sievePHaipw(eventTime, eventInd, mark=data.frame(mark1, mark2), tx,
                   aux=data.frame(A), formulaMiss= ~ tx * A, formulaScore= ~ tx * A + I(A^2))

</code></pre>

<hr>
<h2 id='sievePHipw'>Semiparametric Inverse Probability Weighted Complete-Case Estimation of Coefficients in a Mark-Specific Proportional Hazards Model
with a Multivariate Continuous Mark, Missing-at-Random in Some Failures</h2><span id='topic+sievePHipw'></span>

<h3>Description</h3>

<p><code>sievePHipw</code> implements the semiparametric inverse probability weighted (IPW) complete-case estimation method of Juraska and Gilbert (2015) for the multivariate mark-
specific hazard ratio, with the mark subject to missingness at random. It extends Juraska and Gilbert (2013) by weighting complete cases by the inverse of their estimated
probabilities given auxiliary covariates and/or treatment. The probabilities are estimated by fitting a logistic regression model with a user-specified linear predictor.
Coefficients in the treatment-to-placebo mark density ratio model (Qin, 1998) are estimated by solving the IPW estimating equations. The ordinary method of maximum partial likelihood
estimation is employed for estimating the overall log hazard ratio in the Cox model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sievePHipw(
  eventTime,
  eventInd,
  mark,
  tx,
  aux = NULL,
  strata = NULL,
  formulaMiss
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sievePHipw_+3A_eventtime">eventTime</code></td>
<td>
<p>a numeric vector specifying the observed right-censored event time</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark subject to missingness at random. Missing mark values should be set to <code>NA</code>.
For subjects with <code>eventInd = 0</code>, the value(s) in <code>mark</code> should also be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_aux">aux</code></td>
<td>
<p>a data frame specifying auxiliary covariates predictive of the probability of observing the mark. The mark missingness model only requires that the auxiliary covariates be observed in subjects who experienced the event of interest. For subjects with <code>eventInd = 0</code>, the value(s) in <code>aux</code> may be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_strata">strata</code></td>
<td>
<p>a numeric vector specifying baseline strata (<code>NULL</code> by default). If specified, a stratified Cox model is fit for estimating the marginal hazard ratio (i.e., a separate baseline hazard is assumed for each stratum). No stratification is used in estimation of the mark density ratio.</p>
</td></tr>
<tr><td><code id="sievePHipw_+3A_formulamiss">formulaMiss</code></td>
<td>
<p>a one-sided formula object specifying (on the right side of the <code>~</code> operator) the linear predictor in the logistic regression model used for predicting the probability of observing
the mark. All terms in the formula except <code>tx</code> must be evaluable in the data frame <code>aux</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sievePHipw</code> considers data from a randomized placebo-controlled treatment efficacy trial with a time-to-event endpoint.
The parameter of interest, the mark-specific hazard ratio, is the ratio (treatment/placebo) of the conditional mark-specific hazard functions.
It factors as the product of the mark density ratio (treatment/placebo) and the ordinary marginal hazard function ignoring mark data.
The mark density ratio is estimated using the IPW complete-case estimation method, extending Qin (1998), and
the marginal hazard ratio is estimated using <code>coxph()</code> in the <code>survival</code> package.
The asymptotic properties of the IPW complete-case estimator are detailed in Juraska and Gilbert (2015).
</p>


<h3>Value</h3>

<p>An object of class <code>sievePH</code> which can be processed by
<code><a href="#topic+summary.sievePH">summary.sievePH</a></code> to obtain or print a summary of the results. An object of class
<code>sievePH</code> is a list containing the following components:
</p>

<ul>
<li> <p><code>DRcoef</code>: a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter)
</p>
</li>
<li> <p><code>DRconverged</code>: a logical value indicating whether the estimation procedure in the density ratio model converged
</p>
</li>
<li> <p><code>logHR</code>: an estimate of the marginal log hazard ratio from <code>coxph()</code> in the <code>survival</code> package
</p>
</li>
<li> <p><code>cov</code>: the estimated joint covariance matrix of <code>DRcoef</code> and <code>logHR</code>
</p>
</li>
<li> <p><code>coxphFit</code>: an object returned by the call of <code>coxph()</code>
</p>
</li>
<li> <p><code>nPlaEvents</code>: the number of events observed in the placebo group
</p>
</li>
<li> <p><code>nTxEvents</code>: the number of events observed in the treatment group
</p>
</li>
<li> <p><code>mark</code>: the input object
</p>
</li>
<li> <p><code>tx</code>: the input object
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M., and Gilbert, P. B. (2015), Mark-specific hazard ratio model with missing multivariate marks. <em>Lifetime Data Analysis</em> 22(4): 606-25.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.sievePH">summary.sievePH</a></code>, <code><a href="#topic+plot.summary.sievePH">plot.summary.sievePH</a></code>, <code><a href="#topic+testIndepTimeMark">testIndepTimeMark</a></code> and <code><a href="#topic+testDensRatioGOF">testDensRatioGOF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n / 2)
tm &lt;- c(rexp(n / 2, 0.2), rexp(n / 2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 2, 5), rbeta(n / 2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n / 2, 1, 3), rbeta(n / 2, 5, 1)), NA)
# a continuous auxiliary covariate
A &lt;- (mark1 + 0.4 * runif(n)) / 1.4
linPred &lt;- -0.8 + 0.4 * tx + 0.8 * A
probs &lt;- exp(linPred) / (1 + exp(linPred))
R &lt;- rep(NA, length(probs))
while (sum(R, na.rm=TRUE) &lt; 10){
  R[eventInd==1] &lt;- sapply(probs[eventInd==1], function(p){ rbinom(1, 1, p) })
}
# produce missing-at-random marks
mark1[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark1[eventInd==1], NA)
mark2[eventInd==1] &lt;- ifelse(R[eventInd==1]==1, mark2[eventInd==1], NA)

# fit a model with a bivariate mark
fit &lt;- sievePHipw(eventTime, eventInd, mark=data.frame(mark1, mark2), tx,
                  aux=data.frame(A), formulaMiss= ~ tx * A)

</code></pre>

<hr>
<h2 id='summary.sievePH'>Summarizing Mark-Specific Proportional Hazards Model Fits</h2><span id='topic+summary.sievePH'></span><span id='topic+print.summary.sievePH'></span>

<h3>Description</h3>

<p><code>summary</code> method for an object of class <code>sievePH</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sievePH'
summary(
  object,
  markGrid,
  contrast = c("te", "hr", "loghr"),
  sieveAlternative = c("twoSided", "oneSided"),
  confLevel = 0.95,
  ...
)

## S3 method for class 'summary.sievePH'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sievePH_+3A_object">object</code></td>
<td>
<p>an object of class <code>sievePH</code>, usually a result of a call to <code><a href="#topic+sievePH">sievePH</a></code></p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_markgrid">markGrid</code></td>
<td>
<p>a matrix specifying a grid of multivariate mark values, where rows correspond to different values on the (multivariate) grid and columns correspond to components of the mark. A numeric vector is allowed
for univariate marks. The point and interval estimates of the <code>contrast</code> are calculated on this grid.</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_contrast">contrast</code></td>
<td>
<p>a character string specifying the treatment effect parameter of interest. The default value is <code>"te"</code> (treatment efficacy); other options are <code>"hr"</code> (hazard ratio) and <code>"loghr"</code> (log hazard ratio).</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_sievealternative">sieveAlternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis for the sieve tests, which can be either <code>"twoSided"</code> (default) or, in case of a univariate mark, <code>"oneSided"</code>.
The one-sided option is unavailable for a multivariate mark.</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_conflevel">confLevel</code></td>
<td>
<p>the confidence level (0.95 by default) of reported confidence intervals</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.sievePH</code>, usually a result of a call to <code>summary.sievePH</code></p>
</td></tr>
<tr><td><code id="summary.sievePH_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing (4 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.sievePH</code> prints a formatted summary of results. Inference about coefficients in the mark-specific proportional hazards model is tabulated. Additionally, a summary is generated
from the likelihood-ratio and Wald tests of two relevant null hypotheses: (1) {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>}, and (2) {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. For the tests of (2) and a univariate
mark, <code>sieveAlternative</code> controls the choice of the alternative hypothesis.
</p>


<h3>Value</h3>

<p>An object of class <code>summary.sievePH</code>, which is a list with the following components:
</p>

<ul>
<li> <p><code>coef</code>: a data frame summarizing point and interval estimates of the density ratio model coefficients and the marginal log hazard ratio (the confidence level is specified by <code>confLevel</code>), and p-values from the
two-sided Wald test of the null hypothesis that the parameter equals zero
</p>
</li>
<li> <p><code>pLR.HRunity.2sided</code>: a numeric vector with two named components: <code>pLR.dRatio.2sided</code> is a p-value from the two-sided profile likelihood-ratio test of the null hypothesis <code class="reqn">H_0: \beta=0</code>, where <code class="reqn">\beta</code> is the
vector of mark coefficients in the mark density ratio model, and <code>pLR.cox.2sided</code> is a p-value from the two-sided partial likelihood-ratio test of the null hypothesis <code class="reqn">H_0: \gamma=0</code>, where <code class="reqn">\gamma</code> is the
marginal log hazard ratio in the Cox model. The two p-values are intended for the use of the Simes (1986) procedure as described on page 4 in Juraska and Gilbert (2013).
</p>
</li>
<li> <p><code>pWald.HRunity.2sided</code>: a p-value from the two-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>}
</p>
</li>
<li> <p><code>pWtWald.HRunity.1sided</code>: a p-value from the one-sided weighted Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=1</code> for all <code class="reqn">v</code>} against the alternative hypothesis {<code class="reqn">H_1: HR &lt; 1</code> and <code class="reqn">HR(v)</code> is
increasing in each component of <code class="reqn">v</code>}
</p>
</li>
<li> <p><code>pLR.HRconstant.2sided</code>: a p-value from the two-sided profile likelihood-ratio test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. This component is available if <code>sieveAlternative="twoSided"</code>.
</p>
</li>
<li> <p><code>pLR.HRconstant.1sided</code>: a numeric vector with two named components: <code>pLR.dRatio.2sided</code> is a p-value from the two-sided profile likelihood-ratio test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>},
and <code>estBeta</code> is the point estimate of the univariate mark coefficient in the density ratio model. This component is available if the mark is univariate and <code>sieveAlternative="oneSided"</code>.
</p>
</li>
<li> <p><code>pWald.HRconstant.2sided</code>: a p-value from the two-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>}. This component is available if <code>sieveAlternative="twoSided"</code>.
</p>
</li>
<li> <p><code>pWald.HRconstant.1sided</code>: a p-value from the one-sided Wald test of the null hypothesis {<code class="reqn">H_0: HR(v)=HR</code> for all <code class="reqn">v</code>} against the alternative hypothesis {<code class="reqn">H_1: HR(v)</code> is increasing in <code class="reqn">v</code>}.
This component is available if the mark is univariate and <code>sieveAlternative="oneSided"</code>.
</p>
</li>
<li> <p><code>te</code>: a data frame summarizing point and interval estimates of the mark-specific treatment efficacy on the grid of mark values in <code>markGrid</code> (available if <code>contrast="te"</code>). The confidence level is specified
by <code>confLevel</code>.
</p>
</li>
<li> <p><code>hr</code>: a data frame summarizing point and interval estimates of the mark-specific hazard ratio on the grid of mark values in <code>markGrid</code> (available if <code>contrast="hr"</code>). The confidence level is specified by
<code>confLevel</code>.
</p>
</li>
<li> <p><code>te</code>: a data frame summarizing point and interval estimates of the mark-specific log hazard ratio on the grid of mark values in <code>markGrid</code> (available if <code>contrast="loghr"</code>). The confidence level is specified by
<code>confLevel</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sievePH">sievePH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# fit a model with a bivariate mark
fit &lt;- sievePH(eventTime, eventInd, data.frame(mark1, mark2), tx)
sfit &lt;- summary(fit, markGrid=matrix(c(0.3, 0.3, 0.6, 0.3, 0.3, 0.6, 0.6, 0.6),
                                     ncol=2, byrow=TRUE))
# print the formatted summary
sfit
# treatment efficacy estimates on the grid
sfit$te

</code></pre>

<hr>
<h2 id='testDensRatioGOF'>Goodness-of-Fit Test of the Validity of a Univariate or Multivariate Mark Density Ratio Model</h2><span id='topic+testDensRatioGOF'></span>

<h3>Description</h3>

<p><code>testDensRatioGoF</code> implements the complete-case goodness-of-fit test of Qin and Zhang (1997) for evaluating the validity of the specified mark density ratio model used for modeling a component of
the mark-specific hazard ratio model in Juraska and Gilbert (2013). Multivariate marks are accommodated. Subjects who experienced the event of interest but their mark is missing are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensRatioGOF(
  eventInd,
  mark,
  tx,
  DRcoef = NULL,
  DRlambda = NULL,
  iter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensRatioGOF_+3A_eventind">eventInd</code></td>
<td>
<p>a numeric vector indicating the event of interest (1 if event, 0 if right-censored)</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_mark">mark</code></td>
<td>
<p>either a numeric vector specifying a univariate continuous mark or a data frame specifying a multivariate continuous mark.
For subjects with a right-censored time-to-event, the value(s) in <code>mark</code> should be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_tx">tx</code></td>
<td>
<p>a numeric vector indicating the treatment group (1 if treatment, 0 if placebo)</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_drcoef">DRcoef</code></td>
<td>
<p>a numeric vector of the coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi) = \exp\{\phi^T (1, v)\}</code> in the density ratio model. If <code>NULL</code> (default), the maximum profile likelihood estimates (Qin, 1998)
of the coefficients are computed.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_drlambda">DRlambda</code></td>
<td>
<p>the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code> (that arises by profiling out the nuisance parameter). If <code>NULL</code> (default), the maximum profile likelihood estimate (Qin, 1998)
of the Lagrange multiplier is computed.</p>
</td></tr>
<tr><td><code id="testDensRatioGOF_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations (1000 by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>testDensRatioGoF</code> performs a goodness-of-fit test for the exponential form of the weight function, i.e., <code class="reqn">g(v, \phi) = \exp\{\phi^T (1, v)\}</code>. Other weight functions are not considered.
</p>


<h3>Value</h3>

<p>Returns a list containing the following components:
</p>

<ul>
<li> <p><code>teststat</code>: the value of the Kolmogorov-Smirnov-type test statistic
</p>
</li>
<li> <p><code>pval</code>: the bootstrap p-value from the Kolmogorov-Smirnov-type test of validity of the mark density ratio model
</p>
</li>
<li> <p><code>DRcoef</code>: the input object if different from <code>NULL</code> or a numeric vector of estimates of coefficients <code class="reqn">\phi</code> in the weight function <code class="reqn">g(v, \phi)</code> in the density ratio model
</p>
</li>
<li> <p><code>DRlambda</code>: the input object if different from <code>NULL</code> or an estimate of the Lagrange multiplier in the profile score functions for <code class="reqn">\phi</code>
</p>
</li></ul>



<h3>References</h3>

<p>Qin, J., &amp; Zhang, B. (1997). A goodness-of-fit test for logistic regression models based on case-control data. <em>Biometrika</em>, 84(3), 609-618.
</p>
<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328-337.
</p>
<p>Qin, J. (1998), Inferences for case-control and semiparametric two-sample density ratio models. <em>Biometrika</em> 85, 619-630.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# test goodness-of-fit for a univariate mark
testDensRatioGOF(eventInd, mark1, tx, iter=20)

# test goodness-of-fit for a bivariate mark
testDensRatioGOF(eventInd, data.frame(mark1, mark2), tx, iter=20)

</code></pre>

<hr>
<h2 id='testIndepTimeMark'>Kolmogorov-Smirnov-Type Test of Conditional Independence between the Time-to-Event
and a Multivariate Mark Given Treatment</h2><span id='topic+testIndepTimeMark'></span>

<h3>Description</h3>

<p>A nonparametric Komogorov-Smirnov-type test of the null hypothesis that the time-to-event <code class="reqn">T</code> and a possibly multivariate mark <code class="reqn">V</code> are conditionally independent given treatment <code class="reqn">Z</code>
as described in Juraska and Gilbert (2013). The conditional independence is a necessary assumption for parameter identifiability in the time-independent density ratio model. A bootstrap
algorithm is used to compute the p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testIndepTimeMark(data, iter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testIndepTimeMark_+3A_data">data</code></td>
<td>
<p>a data frame restricted to subjects in a given treatment group with the following columns (in this order): the observed right-censored time to the event of interest,
the event indicator (1 if event, 0 if right-censored), and the mark variable (one column for each component, if multivariate)</p>
</td></tr>
<tr><td><code id="testIndepTimeMark_+3A_iter">iter</code></td>
<td>
<p>the number of bootstrap iterations (1000 by default) used for computing the p-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test statistic is the supremum of the difference between the estimated conditional joint cumulative distribution function (cdf) of <code class="reqn">(T,V)</code> given <code class="reqn">Z</code> and the product of
the estimated conditional cdfs of <code class="reqn">T</code> and <code class="reqn">V</code> given <code class="reqn">Z</code>. The joint cdf is estimated by the nonparametric maximum likelihood estimator developed by
Huang and Louis (1998). The marginal cdf of <code class="reqn">T</code> is estimated as one minus the Kaplan-Meier estimator for the conditional survival function of <code class="reqn">T</code>, and the
cdf of <code class="reqn">V</code> is estimated as the empirical cdf of the observed values of <code class="reqn">V</code>. A bootstrap algorithm is used to compute the p-value.
</p>


<h3>Value</h3>

<p>Returns the bootstrap p-value from the test of conditional independence between <code class="reqn">T</code> and <code class="reqn">V</code> given <code class="reqn">Z</code>.
</p>


<h3>References</h3>

<p>Juraska, M. and Gilbert, P. B. (2013), Mark-specific hazard ratio model with multivariate continuous marks: an application to vaccine efficacy. <em>Biometrics</em> 69(2):328–337.
</p>
<p>Huang, Y. and Louis, T. (1998), Nonparametric estimation of the joint distribution of survival time and mark variables. <em>Biometrika</em> 85, 785–798.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
tx &lt;- rep(0:1, each=n/2)
tm &lt;- c(rexp(n/2, 0.2), rexp(n/2, 0.2 * exp(-0.4)))
cens &lt;- runif(n, 0, 15)
eventTime &lt;- pmin(tm, cens, 3)
eventInd &lt;- as.numeric(tm &lt;= pmin(cens, 3))
mark1 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 2, 5), rbeta(n/2, 2, 2)), NA)
mark2 &lt;- ifelse(eventInd==1, c(rbeta(n/2, 1, 3), rbeta(n/2, 5, 1)), NA)

# perform the test for a univariate mark in the placebo group
testIndepTimeMark(data.frame(eventTime, eventInd, mark1)[tx==0, ], iter=20)

# perform the test for a bivariate mark in the placebo group
testIndepTimeMark(data.frame(eventTime, eventInd, mark1, mark2)[tx==0, ], iter=20)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
