<!DOCTYPE html><html lang="en"><head><title>Help for package SimCorrMix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimCorrMix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimCorrMix'><p>Simulation of Correlated Data with Multiple Variable Types Including Continuous and Count Mixture Distributions</p></a></li>
<li><a href='#calc_mixmoments'><p>Find Standardized Cumulants of a Continuous Mixture Distribution by Method of Moments</p></a></li>
<li><a href='#contmixvar1'><p>Generation of One Continuous Variable with a Mixture Distribution Using the Power Method Transformation</p></a></li>
<li><a href='#corr_error'><p>Error Loop to Correct Final Correlation of Simulated Variables</p></a></li>
<li><a href='#corrvar'><p>Generation of Correlated Ordinal, Continuous (mixture and non-mixture), and/or Count (Poisson and Negative Binomial,</p>
regular and zero-inflated) Variables: Correlation Method 1</a></li>
<li><a href='#corrvar2'><p>Generation of Correlated Ordinal, Continuous (mixture and non-mixture), and/or Count (Poisson and Negative Binomial,</p>
regular and zero-inflated) Variables: Correlation Method 2</a></li>
<li><a href='#intercorr'><p>Calculate Intermediate MVN Correlation for Ordinal, Continuous, Poisson, or Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_cat_nb'><p>Calculate Intermediate MVN Correlation for Ordinal - Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_cat_pois'><p>Calculate Intermediate MVN Correlation for Ordinal - Poisson Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_cont'><p>Calculate Intermediate MVN Correlation for Continuous Variables Generated by Polynomial Transformation Method</p></a></li>
<li><a href='#intercorr_cont_nb'><p>Calculate Intermediate MVN Correlation for Continuous - Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_cont_nb2'><p>Calculate Intermediate MVN Correlation for Continuous - Negative Binomial Variables: Correlation Method 2</p></a></li>
<li><a href='#intercorr_cont_pois'><p>Calculate Intermediate MVN Correlation for Continuous - Poisson Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_cont_pois2'><p>Calculate Intermediate MVN Correlation for Continuous - Poisson Variables: Correlation Method 2</p></a></li>
<li><a href='#intercorr_nb'><p>Calculate Intermediate MVN Correlation for Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_pois'><p>Calculate Intermediate MVN Correlation for Poisson Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr_pois_nb'><p>Calculate Intermediate MVN Correlation for Poisson - Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#intercorr2'><p>Calculate Intermediate MVN Correlation for Ordinal, Continuous, Poisson, or Negative Binomial Variables: Correlation Method 2</p></a></li>
<li><a href='#maxcount_support'><p>Calculate Maximum Support Value for Count Variables: Correlation Method 2</p></a></li>
<li><a href='#norm_ord'><p>Calculate Correlations of Ordinal Variables Obtained from Discretizing Normal Variables</p></a></li>
<li><a href='#ord_norm'><p>Calculate Intermediate MVN Correlation to Generate Variables Treated as Ordinal</p></a></li>
<li><a href='#plot_simpdf_theory'><p>Plot Simulated Probability Density Function and Target PDF by Distribution Name or Function for Continuous or Count Variables</p></a></li>
<li><a href='#plot_simtheory'><p>Plot Simulated Data and Target Distribution Data by Name or Function for Continuous or Count Variables</p></a></li>
<li><a href='#rho_M1M2'><p>Approximate Correlation between Two Continuous Mixture Variables M1 and M2</p></a></li>
<li><a href='#rho_M1Y'><p>Approximate Correlation between Continuous Mixture Variable M1 and Random Variable Y</p></a></li>
<li><a href='#summary_var'><p>Summary of Simulated Variables</p></a></li>
<li><a href='#validcorr'><p>Determine Correlation Bounds for Ordinal, Continuous, Poisson, and/or Negative Binomial Variables: Correlation Method 1</p></a></li>
<li><a href='#validcorr2'><p>Determine Correlation Bounds for Ordinal, Continuous, Poisson, and/or Negative Binomial Variables: Correlation Method 2</p></a></li>
<li><a href='#validpar'><p>Parameter Check for Simulation or Correlation Validation Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Correlated Data with Multiple Variable Types
Including Continuous and Count Mixture Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Allison Cynthia Fialkowski</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Allison Cynthia Fialkowski &lt;allijazz@uab.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate continuous (normal, non-normal, or mixture distributions), binary, ordinal, 
    and count (regular or zero-inflated, Poisson or Negative Binomial) variables with a specified 
    correlation matrix, or one continuous variable with a mixture distribution.  This package can 
    be used to simulate data sets that mimic real-world clinical or genetic data sets (i.e., 
    plasmodes, as in Vaughan et al., 2009 &lt;<a href="https://doi.org/10.1016%2Fj.csda.2008.02.032">doi:10.1016/j.csda.2008.02.032</a>&gt;).  The methods 
    extend those found in the 'SimMultiCorrData' R package.  Standard normal variables with an 
    imposed intermediate correlation matrix are transformed to generate the desired distributions.  
    Continuous variables are simulated using either Fleishman (1978)'s third order 
    &lt;<a href="https://doi.org/10.1007%2FBF02293811">doi:10.1007/BF02293811</a>&gt; or Headrick (2002)'s fifth order 
    &lt;<a href="https://doi.org/10.1016%2FS0167-9473%2802%2900072-5">doi:10.1016/S0167-9473(02)00072-5</a>&gt; polynomial transformation method (the power method 
    transformation, PMT).  Non-mixture distributions require the user to specify mean, variance, 
    skewness, standardized kurtosis, and standardized fifth and sixth cumulants.  Mixture 
    distributions require these inputs for the component distributions plus the mixing 
    probabilities.  Simulation occurs at the component level for continuous mixture 
    distributions.  The target correlation matrix is specified in terms of correlations with 
    components of continuous mixture variables.  These components are transformed into the 
    desired mixture variables using random multinomial variables based on the mixing 
    probabilities.  However, the package provides functions to approximate expected correlations 
    with continuous mixture variables given target correlations with the components. Binary and 
    ordinal variables are simulated using a modification of ordsample() in package 'GenOrd'.  
    Count variables are simulated using the inverse CDF method.  There are two simulation 
    pathways which calculate intermediate correlations involving count variables differently.  
    Correlation Method 1 adapts Yahav and Shmueli's 2012 method &lt;<a href="https://doi.org/10.1002%2Fasmb.901">doi:10.1002/asmb.901</a>&gt; and 
    performs best with large count variable means and positive correlations or small means and 
    negative correlations.  Correlation Method 2 adapts Barbiero and Ferrari's 2015 
    modification of the 'GenOrd' package &lt;<a href="https://doi.org/10.1002%2Fasmb.2072">doi:10.1002/asmb.2072</a>&gt; and performs best under the 
    opposite scenarios.  The optional error loop may be used to improve the accuracy of the 
    final correlation matrix.  The package also contains functions to calculate the 
    standardized cumulants of continuous mixture distributions, check parameter inputs, 
    calculate feasible correlation boundaries, and summarize and plot simulated variables.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), SimMultiCorrData (&ge; 0.2.1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>BB, nleqslv, MASS, mvtnorm, Matrix, VGAM, triangle, ggplot2,
grid, stats, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, printr, bookdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AFialkowski/SimCorrMix">https://github.com/AFialkowski/SimCorrMix</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-01 12:57:48 UTC; Allison</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-01 13:31:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimCorrMix'>Simulation of Correlated Data with Multiple Variable Types Including Continuous and Count Mixture Distributions</h2><span id='topic+SimCorrMix'></span><span id='topic+SimCorrMix-package'></span>

<h3>Description</h3>

<p><span class="pkg">SimCorrMix</span> generates continuous (normal, non-normal, or mixture distributions), binary, ordinal, and count
(Poisson or Negative Binomial, regular or zero-inflated) variables with a specified correlation matrix, or one continuous variable
with a mixture distribution.  This package can be used to simulate data sets that mimic real-world clinical or genetic data sets
(i.e. plasmodes, as in Vaughan et al., 2009, doi: <a href="http://doi.org/10.1016/j.csda.2008.02.032">10.1016/j.csda.2008.02.032</a>).  The methods extend those found in the
<span class="pkg">SimMultiCorrData</span> package.  Standard normal variables with an imposed intermediate correlation matrix are transformed to
generate the desired distributions.  Continuous variables are simulated using either Fleishman's third-order
(doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order (doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) power method transformation (PMT).
Non-mixture distributions require the user to specify mean, variance, skewness, standardized kurtosis, and standardized fifth and
sixth cumulants.  Mixture distributions require these inputs for the component distributions plus the mixing probabilities.  Simulation
occurs at the component-level for continuous mixture distributions.  The target correlation matrix is specified in terms of
correlations with components of continuous mixture variables.  These components are transformed into
the desired mixture variables using random multinomial variables based on the mixing probabilities.  However, the package provides functions to approximate expected
correlations with continuous mixture variables given target correlations with the components.  Binary and ordinal variables are simulated using a modification of
<code><a href="GenOrd.html#topic+GenOrd-package">GenOrd-package</a></code>'s <code><a href="GenOrd.html#topic+ordsample">ordsample</a></code> function.  Count variables are simulated using the inverse
CDF method.  There are two simulation pathways which calculate intermediate correlations involving count variables differently.
Correlation Method 1 adapts Yahav and Shmueli's 2012 method (doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>) and performs best with large count variable means and
positive correlations or small means and negative correlations.  Correlation Method 2 adapts Barbiero and
Ferrari's 2015 modification of <code><a href="GenOrd.html#topic+GenOrd-package">GenOrd-package</a></code> (doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>) and performs best under the opposite scenarios.
The optional error loop may be used to improve the accuracy of the final correlation matrix.  The package also provides functions to calculate the standardized
cumulants of continuous mixture distributions, check parameter inputs, calculate feasible correlation boundaries, and summarize and plot simulated variables.
</p>


<h3>Vignettes</h3>

<p>There are several vignettes which accompany this package to help the user understand the simulation and analysis methods.
</p>
<p>1) <b>Comparison of Correlation Methods 1 and 2</b> describes the two simulation pathways that can be followed for generation of
correlated data.
</p>
<p>2) <b>Continuous Mixture Distributions</b> demonstrates how to simulate one continuous mixture variable using
<code><a href="#topic+contmixvar1">contmixvar1</a></code> and gives a step-by-step guideline for comparing a simulated distribution to the target
distribution.
</p>
<p>3) <b>Expected Cumulants and Correlations for Continuous Mixture Variables</b> derives the equations used by the function
<code><a href="#topic+calc_mixmoments">calc_mixmoments</a></code> to find the mean, standard deviation, skew, standardized kurtosis, and standardized fifth
and sixth cumulants for a continuous mixture variable.  The vignette also explains how the functions
<code><a href="#topic+rho_M1M2">rho_M1M2</a></code> and <code><a href="#topic+rho_M1Y">rho_M1Y</a></code> approximate the expected correlations with continuous mixture
variables based on the target correlations with the components.
</p>
<p>4) <b>Overall Workflow for Generation of Correlated Data</b> gives a step-by-step guideline to follow with an example containing
continuous non-mixture and mixture, ordinal, zero-inflated Poisson, and zero-inflated Negative Binomial variables.  It executes both
correlated data simulation functions with and without the error loop.
</p>
<p>5) <b>Variable Types</b> describes the different types of variables that can be simulated in <span class="pkg">SimCorrMix</span>, details the algorithm
involved in the optional error loop that helps to minimize correlation errors, and explains how the feasible correlation boundaries are
calculated for each of the two simulation pathways.
</p>


<h3>Functions</h3>

<p>This package contains 3 <em>simulation</em> functions:
</p>
<p><code><a href="#topic+contmixvar1">contmixvar1</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, and <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>
<p>4 data description (<em>summary</em>) function:
</p>
<p><code><a href="#topic+calc_mixmoments">calc_mixmoments</a></code>, <code><a href="#topic+summary_var">summary_var</a></code>, <code><a href="#topic+rho_M1M2">rho_M1M2</a></code>, <code><a href="#topic+rho_M1Y">rho_M1Y</a></code>
</p>
<p>2 <em>graphing</em> functions:
</p>
<p><code><a href="#topic+plot_simpdf_theory">plot_simpdf_theory</a></code>, <code><a href="#topic+plot_simtheory">plot_simtheory</a></code>
</p>
<p>3 <em>support</em> functions:
</p>
<p><code><a href="#topic+validpar">validpar</a></code>, <code><a href="#topic+validcorr">validcorr</a></code>, <code><a href="#topic+validcorr2">validcorr2</a></code>
</p>
<p>and 16 <em>auxiliary</em> functions (should not normally be called by the user, but are called by other functions):
</p>
<p><code><a href="#topic+corr_error">corr_error</a></code>, <code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+intercorr2">intercorr2</a></code>,
<code><a href="#topic+intercorr_cat_nb">intercorr_cat_nb</a></code>, <code><a href="#topic+intercorr_cat_pois">intercorr_cat_pois</a></code>, <br />
<code><a href="#topic+intercorr_cont_nb">intercorr_cont_nb</a></code>, <code><a href="#topic+intercorr_cont_nb2">intercorr_cont_nb2</a></code>,
<code><a href="#topic+intercorr_cont_pois">intercorr_cont_pois</a></code>, <code><a href="#topic+intercorr_cont_pois2">intercorr_cont_pois2</a></code>, <br />
<code><a href="#topic+intercorr_cont">intercorr_cont</a></code>, <code><a href="#topic+intercorr_nb">intercorr_nb</a></code>, <code><a href="#topic+intercorr_pois">intercorr_pois</a></code>,
<code><a href="#topic+intercorr_pois_nb">intercorr_pois_nb</a></code>, <code><a href="#topic+maxcount_support">maxcount_support</a></code>,
<code><a href="#topic+ord_norm">ord_norm</a></code>, <code><a href="#topic+norm_ord">norm_ord</a></code>
</p>


<h3>References</h3>

<p>Amatya A &amp; Demirtas H (2015). Simultaneous generation of multivariate mixed data with Poisson and normal marginals.
Journal of Statistical Computation and Simulation, 85(15):3129-39. doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>.
</p>
<p>Barbiero A &amp; Ferrari PA (2015). Simulation of correlated Poisson variables. Applied Stochastic Models in
Business and Industry, 31:669-80. doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.
</p>
<p>Barbiero A &amp; Ferrari PA (2015). GenOrd: Simulation of Discrete Random Variables with Given
Correlation Matrix and Marginal Distributions. R package version 1.4.0. <br /> <a href="https://CRAN.R-project.org/package=GenOrd">https://CRAN.R-project.org/package=GenOrd</a>
</p>
<p>Carnell R (2017). triangle: Provides the Standard Distribution Functions for the Triangle Distribution. R package version 0.11.
<a href="https://CRAN.R-project.org/package=triangle">https://CRAN.R-project.org/package=triangle</a>.
</p>
<p>Davenport JW, Bezder JC, &amp; Hathaway RJ (1988). Parameter Estimation for Finite Mixture Distributions.
Computers &amp; Mathematics with Applications, 15(10):819-28.
</p>
<p>Demirtas H (2006). A method for multivariate ordinal data generation given marginal distributions and correlations. Journal of Statistical
Computation and Simulation, 76(11):1017-1025. <br /> doi: <a href="http://doi.org/10.1080/10629360600569246">10.1080/10629360600569246</a>.
</p>
<p>Demirtas H (2014). Joint Generation of Binary and Nonnormal Continuous Data. Biometrics &amp; Biostatistics, S12.
</p>
<p>Demirtas H &amp; Hedeker D (2011). A practical way for computing approximate lower and upper correlation bounds.
American Statistician, 65(2):104-109. doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>.
</p>
<p>Demirtas H, Hedeker D, &amp; Mermelstein RJ (2012). Simulation of massive public health data by power polynomials.
Statistics in Medicine, 31(27):3337-3346. doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>.
</p>
<p>Emrich LJ &amp; Piedmonte MR (1991). A Method for Generating High-Dimensional Multivariate Binary Variables. The American Statistician, 45(4): 302-4.
doi: <a href="http://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>.
</p>
<p>Everitt BS (1996). An Introduction to Finite Mixture Distributions. Statistical Methods in Medical Research, 5(2):107-127. doi: <a href="http://doi.org/10.1177/096228029600500202">10.1177/096228029600500202</a>.
</p>
<p>Ferrari PA &amp; Barbiero A (2012). Simulating ordinal data. Multivariate Behavioral Research, 47(4): 566-589.
doi: <a href="http://doi.org/10.1080/00273171.2012.692630">10.1080/00273171.2012.692630</a>.
</p>
<p>Fialkowski AC (2018). SimMultiCorrData: Simulation of Correlated Data with Multiple Variable Types. R package version 0.2.2.
<a href="https://CRAN.R-project.org/package=SimMultiCorrData">https://CRAN.R-project.org/package=SimMultiCorrData</a>.
</p>
<p>Fleishman AI (1978). A Method for Simulating Non-normal Distributions. Psychometrika, 43:521-532. doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>.
</p>
<p>Frechet M (1951). Sur les tableaux de correlation dont les marges sont donnees.  Ann. l'Univ. Lyon SectA, 14:53-77.
</p>
<p>Hasselman B (2018). nleqslv: Solve Systems of Nonlinear Equations. R package version 3.3.2.
<a href="https://CRAN.R-project.org/package=nleqslv">https://CRAN.R-project.org/package=nleqslv</a>
</p>
<p>Headrick TC (2002). Fast Fifth-order Polynomial Transforms for Generating Univariate and Multivariate
Non-normal Distributions. Computational Statistics &amp; Data Analysis, 40(4):685-711. doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>.
(<a href="http://www.sciencedirect.com/science/article/pii/S0167947302000725">ScienceDirect</a>)
</p>
<p>Headrick TC, Kowalchuk RK (2007). The Power Method Transformation: Its Probability Density Function, Distribution
Function, and Its Further Use for Fitting Data. Journal of Statistical Computation and Simulation, 77:229-249. doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>.
</p>
<p>Headrick TC, Sawilowsky SS (1999). Simulating Correlated Non-normal Distributions: Extending the Fleishman Power
Method. Psychometrika, 64:25-35. doi: <a href="http://doi.org/10.1007/BF02294317">10.1007/BF02294317</a>.
</p>
<p>Headrick TC, Sheng Y, &amp; Hodis FA (2007). Numerical Computing and Graphics for the Power Method Transformation Using
Mathematica. Journal of Statistical Software, 19(3):1 - 17. <br /> doi: <a href="http://doi.org/10.18637/jss.v019.i03">10.18637/jss.v019.i03</a>.
</p>
<p>Higham N (2002). Computing the nearest correlation matrix - a problem from finance; IMA Journal of Numerical Analysis 22:329-343.
</p>
<p>Hoeffding W. Scale-invariant correlation theory. In: Fisher NI, Sen PK, editors. The collected works of Wassily Hoeffding.
New York: Springer-Verlag; 1994. p. 57-107.
</p>
<p>Ismail N &amp; Zamani H (2013). Estimation of Claim Count Data Using Negative Binomial, Generalized Poisson, Zero-Inflated Negative Binomial and
Zero-Inflated Generalized Poisson Regression Models. Casualty Actuarial Society E-Forum 41(20):1-28.
</p>
<p>Kendall M &amp; Stuart A (1977). The Advanced Theory of Statistics, 4th Edition. Macmillan, New York.
</p>
<p>Lambert D (1992). Zero-Inflated Poisson Regression, with an Application to Defects in Manufacturing. Technometrics 34(1):1-14.
</p>
<p>Olsson U, Drasgow F, &amp; Dorans NJ (1982). The Polyserial Correlation Coefficient. Psychometrika, 47(3):337-47.
doi: <a href="http://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>.
</p>
<p>Pearson RK (2011). Exploring Data in Engineering, the Sciences, and Medicine. In. New York: Oxford University Press.
</p>
<p>Schork NJ, Allison DB, &amp; Thiel B (1996). Mixture Distributions in Human Genetics Research. Statistical Methods in Medical Research,
5:155-178. doi: <a href="http://doi.org/10.1177/096228029600500204">10.1177/096228029600500204</a>.
</p>
<p>Vale CD &amp; Maurelli VA (1983). Simulating Multivariate Nonnormal Distributions. Psychometrika, 48:465-471. doi: <a href="http://doi.org/10.1007/BF02293687">10.1007/BF02293687</a>.
</p>
<p>Vaughan LK, Divers J, Padilla M, Redden DT, Tiwari HK, Pomp D, Allison DB (2009). The use of plasmodes as a supplement to simulations:
A simple example evaluating individual admixture estimation methodologies. Comput Stat Data Anal, 53(5):1755-66.
doi: <a href="http://doi.org/10.1016/j.csda.2008.02.032">10.1016/j.csda.2008.02.032</a>.
</p>
<p>Yahav I &amp; Shmueli G (2012). On Generating Multivariate Poisson Data in Management Science Applications. Applied Stochastic
Models in Business and Industry, 28(1):91-102. doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>
<p>Zhang X, Mallick H, &amp; Yi N (2016). Zero-Inflated Negative Binomial Regression for Differential Abundance Testing in Microbiome
Studies. Journal of Bioinformatics and Genomics 2(2):1-9. doi: <a href="http://doi.org/10.18454/jbg.2016.2.2.1">10.18454/jbg.2016.2.2.1</a>.
</p>


<h3>See Also</h3>

<p>Useful link: <a href="https://github.com/AFialkowski/SimMultiCorrData">https://github.com/AFialkowski/SimMultiCorrData</a>, <a href="https://github.com/AFialkowski/SimCorrMix">https://github.com/AFialkowski/SimCorrMix</a>
</p>

<hr>
<h2 id='calc_mixmoments'>Find Standardized Cumulants of a Continuous Mixture Distribution by Method of Moments</h2><span id='topic+calc_mixmoments'></span>

<h3>Description</h3>

<p>This function uses the method of moments to calculate the expected mean, standard deviation, skewness,
standardized kurtosis, and standardized fifth and sixth cumulants for a continuous mixture variable based on the distributions
of its components.  The result can be used as input to <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> or for comparison to a
simulated mixture variable from <code><a href="#topic+contmixvar1">contmixvar1</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, or
<code><a href="#topic+corrvar2">corrvar2</a></code>.  See the <b>Expected Cumulants and Correlations for Continuous Mixture Variables</b> vignette
for equations of the cumulants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mixmoments(mix_pis = NULL, mix_mus = NULL, mix_sigmas = NULL,
  mix_skews = NULL, mix_skurts = NULL, mix_fifths = NULL,
  mix_sixths = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_mixmoments_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a vector of mixing probabilities that sum to 1 for the component distributions</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a vector of means for the component distributions</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a vector of standard deviations for the component distributions</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a vector of skew values for the component distributions</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a vector of standardized kurtoses for the component distributions</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the component distributions; keep NULL if using <code>method</code> = &quot;Fleishman&quot;
to generate continuous variables</p>
</td></tr>
<tr><td><code id="calc_mixmoments_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the component distributions; keep NULL if using <code>method</code> = &quot;Fleishman&quot;
to generate continuous variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the mean, standard deviation, skewness, standardized kurtosis, and standardized fifth and sixth cumulants
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mixture of Normal(-2, 1) and Normal(2, 1)
calc_mixmoments(mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2),
  mix_sigmas = c(1, 1), mix_skews = c(0, 0), mix_skurts = c(0, 0),
  mix_fifths = c(0, 0), mix_sixths = c(0, 0))

</code></pre>

<hr>
<h2 id='contmixvar1'>Generation of One Continuous Variable with a Mixture Distribution Using the Power Method Transformation</h2><span id='topic+contmixvar1'></span>

<h3>Description</h3>

<p>This function simulates one continuous mixture variable.  Mixture distributions describe random variables that
are drawn from more than one component distribution.  For a random variable <code class="reqn">Y_{mix}</code> from a finite continuous mixture
distribution with <code class="reqn">k</code> components, the probability density function (PDF) can be described by:
</p>
<p style="text-align: center;"><code class="reqn">h_Y(y) = \sum_{i=1}^{k} \pi_i f_{Yi}(y), \sum_{i=1}^{k} \pi_i = 1.</code>
</p>

<p>The <code class="reqn">\pi_i</code> are mixing parameters which determine the weight of each component distribution <code class="reqn">f_{Yi}(y)</code> in the overall
probability distribution.  As long as each component has a valid PDF, the overall distribution <code class="reqn">h_Y(y)</code> has a valid PDF.
The main assumption is statistical independence between the process of randomly selecting the component distribution and the
distributions themselves.  Each component <code class="reqn">Y_i</code> is generated using either Fleishman's third-order (<code>method</code> = &quot;Fleishman&quot;,
doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order (<code>method</code> = &quot;Polynomial&quot;,
doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) power method transformation (PMT).  It works by matching standardized
cumulants &ndash; the first four (mean, variance, skew, and standardized kurtosis) for Fleishman's method, or the first six (mean,
variance, skew, standardized kurtosis, and standardized fifth and sixth cumulants) for Headrick's method.  The transformation is
expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = c_0 + c_1 * Z + c_2 * Z^2 + c_3 * Z^3 + c_4 * Z^4 + c_5 * Z^5,  Z \sim N(0,1),</code>
</p>

<p>where <code class="reqn">c_4</code> and <code class="reqn">c_5</code> both equal <code class="reqn">0</code> for Fleishman's method.  The real constants are calculated by <br />
<code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  These components are then transformed to the desired mixture variable using a
random multinomial variable generated based on the mixing probabilities.  There are no parameter input checks in order to decrease
simulation time.  All inputs should be checked prior to simulation with <code><a href="#topic+validpar">validpar</a></code>.  Summaries for the
simulation results can be obtained with <code><a href="#topic+summary_var">summary_var</a></code>.
</p>
<p>Mixture distributions provide a useful way for describing heterogeneity in a population, especially when an outcome is a
composite response from multiple sources.  The vignette <b>Variable Types</b> provides more information about simulation of mixture
variables and the required parameters.  The vignette <b>Expected Cumulants and Correlations for Continuous Mixture Variables</b>
gives the equations for the expected cumulants of a mixture variable.  In addition, Headrick &amp; Kowalchuk (2007,
doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>) outlined a general method for comparing a simulated distribution <code class="reqn">Y</code> to a given theoretical
distribution <code class="reqn">Y^*</code>.  These steps can be found in the <b>Continuous Mixture Distributions</b> vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contmixvar1(n = 10000, method = c("Fleishman", "Polynomial"), means = 0,
  vars = 1, mix_pis = NULL, mix_mus = NULL, mix_sigmas = NULL,
  mix_skews = NULL, mix_skurts = NULL, mix_fifths = NULL,
  mix_sixths = NULL, mix_Six = list(), seed = 1234, cstart = list(),
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contmixvar1_+3A_n">n</code></td>
<td>
<p>the sample size (i.e. the length of the simulated variable; default = 10000)</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_method">method</code></td>
<td>
<p>the method used to generate the component variables.  &quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_means">means</code></td>
<td>
<p>mean for the mixture variable (default = 0)</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_vars">vars</code></td>
<td>
<p>variance for the mixture variable (default = 1)</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a vector of mixing probabilities that sum to 1 for the component distributions</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a vector of means for the component distributions</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a vector of standard deviations for the component distributions</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a vector of skew values for the component distributions</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a vector of standardized kurtoses for the component distributions</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the component distributions; keep NULL if using <code>method</code> = &quot;Fleishman&quot;
to generate continuous variables</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the component distributions; keep NULL if using <code>method</code> = &quot;Fleishman&quot;
to generate continuous variables</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_mix_six">mix_Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the component distributions of <code class="reqn">Y_{mix}</code>;
use <code>NULL</code> if no correction is desired for a given component; if no correction is desired for any component keep as
<code>mix_Six = list()</code> (not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_cstart">cstart</code></td>
<td>
<p>a list of length equal to the total number of mixture components containing initial values for root-solving
algorithm used in <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If user specified, each list element must be input as a matrix.
For <code>method</code> = &quot;Fleishman&quot;, each should have 3 columns for <code class="reqn">c_1, c_2, c_3</code>;
for <code>method</code> = &quot;Polynomial&quot;, each should have 5 columns for <code class="reqn">c_1, c_2, c_3, c_4, c_5</code>.  If no starting values are specified for
a given component, that list element should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="contmixvar1_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints total simulation time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>constants</code> a data.frame of the constants
</p>
<p><code>Y_comp</code> a data.frame of the components of the mixture variable
</p>
<p><code>Y_mix</code> a data.frame of the generated mixture variable
</p>
<p><code>sixth_correction</code> the sixth cumulant correction values for <code>Y_comp</code>
</p>
<p><code>valid.pdf</code> &quot;TRUE&quot; if constants generate a valid PDF, else &quot;FALSE&quot;
</p>
<p><code>Time</code> the total simulation time in minutes
</p>


<h3>Overview of Simulation Process</h3>

<p>1) A check is performed to see if any distributions are repeated within the parameter inputs, i.e. if the mixture variable
contains 2 components with the same standardized cumulants.  These are noted so that the constants are only calculated once.
</p>
<p>2) The constants are calculated for each component variable using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If no
solutions are found that generate a valid power method PDF, the function will return constants that produce an invalid PDF
(or a stop error if no solutions can be found).  Possible solutions include: 1) changing the seed, or 2) using a <code>mix_Six</code>
list with vectors of sixth cumulant correction values (if <code>method</code> = &quot;Polynomial&quot;).  Errors regarding constant
calculation are the most probable cause of function failure.
</p>
<p>3) A matrix <code>X_cont</code> of dim <code>n x length(mix_pis)</code> of standard normal variables is generated and singular-value decomposition is done to
remove any correlation.  The <code>constants</code> are applied to <code>X_cont</code> to create the component variables <code>Y</code> with the desired distributions.
</p>
<p>4) A random multinomial variable <code>M = rmultinom(n, size = 1, prob = mix_pis)</code> is generated using <code>stats::rmultinom</code>.
The continuous mixture variable <code>Y_mix</code> is created from the component variables <code>Y</code> based on this multinomial variable.
That is, if <code>M[i, k_i] = 1</code>, then <code>Y_mix[i] = Y[i, k_i]</code>.  A location-scale transformation is done on <code>Y_mix</code> to give it mean <code>means</code> and variance <code>vars</code>.
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code><a href="SimMultiCorrData.html#topic+fleish">fleish</a></code> or
<code><a href="SimMultiCorrData.html#topic+poly">poly</a></code> converged when using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If this happens,
the simulation will stop.  It may help to first use <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> for each component variable to
determine if a sixth cumulant correction value is needed.  The solutions can be used as starting values (see <code>cstart</code> below).
If the standardized cumulants are obtained from <code>calc_theory</code>, the user may need to use rounded values as inputs (i.e.
<code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code> to determine the boundary for a given set of cumulants.
</p>


<h3>References</h3>

<p>See references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="#topic+validpar">validpar</a></code>, <code><a href="#topic+summary_var">summary_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Mixture of Normal(-2, 1) and Normal(2, 1)
Nmix &lt;- contmixvar1(n = 1000, "Polynomial", means = 0, vars = 1,
  mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2), mix_sigmas = c(1, 1),
  mix_skews = c(0, 0), mix_skurts = c(0, 0), mix_fifths = c(0, 0),
  mix_sixths = c(0, 0))
## Not run: 
# Mixture of Beta(6, 3), Beta(4, 1.5), and Beta(10, 20)
Stcum1 &lt;- calc_theory("Beta", c(6, 3))
Stcum2 &lt;- calc_theory("Beta", c(4, 1.5))
Stcum3 &lt;- calc_theory("Beta", c(10, 20))
mix_pis &lt;- c(0.5, 0.2, 0.3)
mix_mus &lt;- c(Stcum1[1], Stcum2[1], Stcum3[1])
mix_sigmas &lt;- c(Stcum1[2], Stcum2[2], Stcum3[2])
mix_skews &lt;- c(Stcum1[3], Stcum2[3], Stcum3[3])
mix_skurts &lt;- c(Stcum1[4], Stcum2[4], Stcum3[4])
mix_fifths &lt;- c(Stcum1[5], Stcum2[5], Stcum3[5])
mix_sixths &lt;- c(Stcum1[6], Stcum2[6], Stcum3[6])
mix_Six &lt;- list(seq(0.01, 10, 0.01), c(0.01, 0.02, 0.03),
  seq(0.01, 10, 0.01))
Bstcum &lt;- calc_mixmoments(mix_pis, mix_mus, mix_sigmas, mix_skews,
  mix_skurts, mix_fifths, mix_sixths)
Bmix &lt;- contmixvar1(n = 10000, "Polynomial", Bstcum[1], Bstcum[2]^2,
  mix_pis, mix_mus, mix_sigmas, mix_skews, mix_skurts, mix_fifths,
  mix_sixths, mix_Six)
Bsum &lt;- summary_var(Y_comp = Bmix$Y_comp, Y_mix = Bmix$Y_mix, means = means,
  vars = vars, mix_pis = mix_pis, mix_mus = mix_mus,
  mix_sigmas = mix_sigmas, mix_skews = mix_skews, mix_skurts = mix_skurts,
  mix_fifths = mix_fifths, mix_sixths = mix_sixths)

## End(Not run)
</code></pre>

<hr>
<h2 id='corr_error'>Error Loop to Correct Final Correlation of Simulated Variables</h2><span id='topic+corr_error'></span>

<h3>Description</h3>

<p>This function attempts to correct the final pairwise correlations of simulated variables to be within <code>epsilon</code>
of the target correlations.  It updates the intermediate normal correlation iteratively in a loop until either the maximum error
is less than epsilon or the number of iterations exceeds <code>maxit</code>.  This function would not ordinarily be called directly by
the user.  The function is a modification of  Barbiero &amp; Ferrari's <code><a href="GenOrd.html#topic+ordcont">ordcont</a></code> function in
<code><a href="GenOrd.html#topic+GenOrd-package">GenOrd-package</a></code>.  The <code><a href="GenOrd.html#topic+ordcont">ordcont</a></code> function has been modified in the following ways:
</p>
<p>1) It works for continuous, ordinal (r &gt;= 2 categories), and count (regular or zero-inflated, Poisson or Negative Binomial) variables.
</p>
<p>2) The initial correlation check has been removed because the intermediate correlation matrix
<code>Sigma</code> from <code><a href="#topic+corrvar">corrvar</a></code> or <code><a href="#topic+corrvar2">corrvar2</a></code> has already been
checked for positive-definiteness and used to generate variables.
</p>
<p>3) Eigenvalue decomposition is done on <code>Sigma</code> to impose the correct intermediate correlations on the normal variables.
If <code>Sigma</code> is not positive-definite, the negative eigenvalues are replaced with 0.
</p>
<p>4) The final positive-definite check has been removed.
</p>
<p>5) The intermediate correlation update function was changed to accommodate more situations.
</p>
<p>6) Allowing specifications for the sample size and the seed for reproducibility.
</p>
<p>The vignette <b>Variable Types</b> describes the algorithm used in the error loop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_error(n = 10000, k_cat = 0, k_cont = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), means = NULL, vars = NULL,
  constants = NULL, marginal = list(), support = list(), lam = NULL,
  p_zip = 0, size = NULL, mu = NULL, p_zinb = 0, seed = 1234,
  epsilon = 0.001, maxit = 1000, rho0 = NULL, Sigma = NULL,
  rho_calc = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corr_error_+3A_n">n</code></td>
<td>
<p>the sample size</p>
</td></tr>
<tr><td><code id="corr_error_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous variables (these may be regular continuous variables or components of continuous mixture variables)</p>
</td></tr>
<tr><td><code id="corr_error_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of Poisson (regular or zero-inflated) variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of Negative Binomial (regular or zero-inflated) variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_method">method</code></td>
<td>
<p>the method used to generate the continuous variables.  &quot;Fleishman&quot; uses a third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="corr_error_+3A_means">means</code></td>
<td>
<p>a vector of means for the continuous variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the continuous variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="corr_error_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td></tr>
<tr><td><code id="corr_error_+3A_support">support</code></td>
<td>
<p>a list of length equal <code>k_cat</code>; the i-th element is a vector of containing the r
ordered support values; if not provided, the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="corr_error_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the zero-inflated
Poisson variables (see <code>VGAM::dzipois</code>)</p>
</td></tr>
<tr><td><code id="corr_error_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="corr_error_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables; order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="corr_error_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="corr_error_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation</p>
</td></tr>
<tr><td><code id="corr_error_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlation; smaller epsilons take more time</p>
</td></tr>
<tr><td><code id="corr_error_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use to find the intermediate correlation; the
correction loop stops when either the iteration number passes <code>maxit</code> or <code>epsilon</code> is reached</p>
</td></tr>
<tr><td><code id="corr_error_+3A_rho0">rho0</code></td>
<td>
<p>the target correlation matrix</p>
</td></tr>
<tr><td><code id="corr_error_+3A_sigma">Sigma</code></td>
<td>
<p>the intermediate correlation matrix previously used in <code><a href="#topic+corrvar">corrvar</a></code>
or <code><a href="#topic+corrvar2">corrvar2</a></code></p>
</td></tr>
<tr><td><code id="corr_error_+3A_rho_calc">rho_calc</code></td>
<td>
<p>the final correlation matrix calculated in <code><a href="#topic+corrvar">corrvar</a></code>
or <code><a href="#topic+corrvar2">corrvar2</a></code> before execution of <code><a href="#topic+corr_error">corr_error</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>Sigma</code> the intermediate MVN correlation matrix resulting from the error loop
</p>
<p><code>rho_calc</code> the calculated final correlation matrix generated from Sigma
</p>
<p><code>Y_cat</code> the ordinal variables
</p>
<p><code>Y</code> the continuous (mean 0, variance 1) variables
</p>
<p><code>Y_cont</code> the continuous variables with desired mean and variance
</p>
<p><code>Y_pois</code> the Poisson variables
</p>
<p><code>Y_nb</code> the Negative Binomial variables
</p>
<p><code>niter</code> a matrix containing the number of iterations required for each variable pair
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrvar">corrvar</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>

<hr>
<h2 id='corrvar'>Generation of Correlated Ordinal, Continuous (mixture and non-mixture), and/or Count (Poisson and Negative Binomial,
regular and zero-inflated) Variables: Correlation Method 1</h2><span id='topic+corrvar'></span>

<h3>Description</h3>

<p>This function simulates <code>k_cat</code> ordinal (<code class="reqn">r \ge 2</code> categories), <code>k_cont</code> continuous non-mixture,
<code>k_mix</code> continuous mixture, <code>k_pois</code> Poisson (regular and zero-inflated), and/or <code>k_nb</code> Negative Binomial
(regular and zero-inflated) variables with a specified correlation matrix <code>rho</code>.  The variables are generated from
multivariate normal variables with intermediate correlation matrix <code>Sigma</code>, calculated by <code><a href="#topic+intercorr">intercorr</a></code>,
and then transformed.  The intermediate correlations involving count variables are determined using <strong>correlation method 1</strong>.
The <em>ordering</em> of the variables in <code>rho</code> must be 1st ordinal, 2nd continuous non-mixture,
3rd components of the continuous mixture, 4th regular Poisson, 5th zero-inflated Poisson, 6th regular NB, and 7th zero-inflated NB.
Note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_mix</code>, <code>k_pois</code>, and/or <code>k_nb</code> to be 0.
Simulation occurs at the component-level for continuous mixture distributions.  The target correlation matrix is specified in terms of
correlations with components of continuous mixture variables.  There are no parameter input checks
in order to decrease simulation time.  All inputs should be checked prior to simulation with <code><a href="#topic+validpar">validpar</a></code>
and <code><a href="#topic+validcorr">validcorr</a></code>.  Summaries for the simulation results can be obtained with <code><a href="#topic+summary_var">summary_var</a></code>.
</p>
<p>All continuous variables are simulated using either Fleishman's third-order (<code>method</code> = &quot;Fleishman&quot;, doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order
(<code>method</code> = &quot;Polynomial&quot;, doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) power method transformation.  It works by matching standardized
cumulants &ndash; the first four (mean, variance, skew, and standardized kurtosis) for Fleishman's method, or the first six (mean,
variance, skew, standardized kurtosis, and standardized fifth and sixth cumulants) for Headrick's method.  The transformation is
expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = c_0 + c_1 * Z + c_2 * Z^2 + c_3 * Z^3 + c_4 * Z^4 + c_5 * Z^5,  Z \sim N(0,1),</code>
</p>

<p>where <code class="reqn">c_4</code> and <code class="reqn">c_5</code> both equal <code class="reqn">0</code> for Fleishman's method.  The real constants are calculated by <br />
<code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  Continuous mixture variables are generated componentwise and then transformed to
the desired mixture variables based on random multinomial variables generated from the mixing probabilities.  Ordinal variables
(<code class="reqn">r \ge 2</code> categories) are generated by discretizing the standard normal
variables at quantiles.  These quantiles are determined by evaluating the inverse standard normal CDF at the cumulative
probabilities defined by each variable's marginal distribution.  Count variables are generated using the inverse CDF method.  The
CDF of a standard normal variable has a uniform distribution.  The appropriate quantile function (F_Y)^(-1) is applied to
this uniform variable with the designated parameters to generate the count variable: Y = (F_Y)^(-1)(Phi(Z)).  The Negative
Binomial variable represents the number of failures which occur in a sequence of Bernoulli trials before the target number of
successes is achieved.  Zero-inflated Poisson or NB variables are obtained by setting the probability of a structural zero to be
greater than 0.  The optional error loop attempts to correct the final pairwise correlations to be within a user-specified
precision value (<code>epsilon</code>) of the target correlations.
</p>
<p>The vignette <b>Variable Types</b> discusses how each of the different variables are generated and describes the required parameters.
</p>
<p>The vignette <b>Overall Workflow for Generation of Correlated Data</b> provides a detailed example discussing the step-by-step simulation process and comparing correlation methods 1 and 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrvar(n = 10000, k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0,
  k_nb = 0, method = c("Fleishman", "Polynomial"), means = NULL,
  vars = NULL, skews = NULL, skurts = NULL, fifths = NULL,
  sixths = NULL, Six = list(), mix_pis = list(), mix_mus = list(),
  mix_sigmas = list(), mix_skews = list(), mix_skurts = list(),
  mix_fifths = list(), mix_sixths = list(), mix_Six = list(),
  marginal = list(), support = list(), lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, rho = NULL,
  seed = 1234, errorloop = FALSE, epsilon = 0.001, maxit = 1000,
  use.nearPD = TRUE, nrand = 100000, Sigma = NULL, cstart = list(),
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrvar_+3A_n">n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable; default = 10000)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_k_mix">k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables.
&quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="corrvar_+3A_means">means</code></td>
<td>
<p>a vector of means for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="corrvar_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="corrvar_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_six">Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br />
ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>; if no correction is desired for <code class="reqn">Y_{cont_i}</code>, set the i-th
list component equal to <code>NULL</code>; if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_mix_six">mix_Six</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_support">support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector containing the r ordered support values;
if not provided (i.e. <code>support = list()</code>), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="corrvar_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="corrvar_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="corrvar_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_errorloop">errorloop</code></td>
<td>
<p>if TRUE, uses <code><a href="#topic+corr_error">corr_error</a></code> to attempt to correct final pairwise correlations to be within
<code>epsilon</code> of target pairwise correlations (default = FALSE)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlations (default = 0.001)
in the calculation of ordinal intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code> or in the error loop</p>
</td></tr>
<tr><td><code id="corrvar_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code> or in the error loop</p>
</td></tr>
<tr><td><code id="corrvar_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>TRUE to convert the overall intermediate correlation matrix to the nearest positive definite matrix with <code>Matrix::nearPD</code> if
necessary; if FALSE the negative eigenvalues are replaced with 0 if necessary</p>
</td></tr>
<tr><td><code id="corrvar_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating intermediate correlations with
<code><a href="#topic+intercorr">intercorr</a></code> (default = 10000)</p>
</td></tr>
<tr><td><code id="corrvar_+3A_sigma">Sigma</code></td>
<td>
<p>an intermediate correlation matrix to use if the user wants to provide one, else it is calculated within by
<code><a href="#topic+intercorr">intercorr</a></code></p>
</td></tr>
<tr><td><code id="corrvar_+3A_cstart">cstart</code></td>
<td>
<p>a list of length equal to <code>k_cont</code> + the total number of mixture components containing initial values for root-solving
algorithm used in <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If user specified, each list element must be input as a matrix.
For <code>method</code> = &quot;Fleishman&quot;, each should have 3 columns for <code class="reqn">c_1, c_2, c_3</code>;
for <code>method</code> = &quot;Polynomial&quot;, each should have 5 columns for <code class="reqn">c_1, c_2, c_3, c_4, c_5</code>.  If no starting values are specified for
a given component, that list element should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrvar_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints simulation messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose components vary based on the type of simulated variables.
</p>
<p>If <b>ordinal variables</b> are produced: <code>Y_cat</code> the ordinal variables,
</p>
<p>If <b>continuous variables</b> are produced:
</p>
<p><code>constants</code> a data.frame of the constants,
</p>
<p><code>Y_cont</code> the continuous non-mixture variables,
</p>
<p><code>Y_comp</code> the components of the continuous mixture variables,
</p>
<p><code>Y_mix</code> the continuous mixture variables,
</p>
<p><code>sixth_correction</code> a list of sixth cumulant correction values,
</p>
<p><code>valid.pdf</code> a vector where the i-th element is &quot;TRUE&quot; if the constants for the i-th continuous variable generate a valid PDF, else &quot;FALSE&quot;
</p>
<p>If <b>Poisson variables</b> are produced: <code>Y_pois</code> the regular and zero-inflated Poisson variables,
</p>
<p>If <b>Negative Binomial variables</b> are produced: <code>Y_nb</code> the regular and zero-inflated Negative Binomial variables,
</p>
<p>Additionally, the following elements:
</p>
<p><code>Sigma</code> the intermediate correlation matrix (after the error loop),
</p>
<p><code>Error_Time</code> the time in minutes required to use the error loop,
</p>
<p><code>Time</code> the total simulation time in minutes,
</p>
<p><code>niter</code> a matrix of the number of iterations used for each variable in the error loop,
</p>


<h3>Overview of Correlation Method 1</h3>

<p>The intermediate correlations used in method 1 are more simulation based than those in method 2, which means that accuracy
increases with sample size and the number of repetitions.  In addition, specifying the seed allows for reproducibility.  In
addition, method 1 differs from method 2 in the following ways:
</p>
<p>1) The intermediate correlation for <b>count variables</b> is based on the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>), which
uses a simulation based, logarithmic transformation of the target correlation.  This method becomes less accurate as the variable mean
gets closer to zero.
</p>
<p>2) The <b>ordinal - count variable</b> correlations are based on an extension of the method of Amatya &amp; Demirtas (2015,
doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>), in which
the correlation correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between the count
variable and the normal variable used to generate it and a simulated upper bound on the correlation between an ordinal variable
and the normal variable used to generate it (see Demirtas &amp; Hedeker, 2011, doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>).
</p>
<p>3) The <b>continuous - count variable</b> correlations are based on an extension of the methods of Amatya &amp; Demirtas (2015) and
Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>), in which the correlation correction factor is the product of the upper Frechet-Hoeffding bound
on the correlation between the count variable and the normal variable used to generate it and the power method correlation
between the continuous variable and the normal variable used to generate it (see Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>).
The intermediate correlations are the ratio of the target correlations to the correction factor.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for more information and a step-by-step overview of the simulation process.
</p>


<h3>Choice of Fleishman's third-order or Headrick's fifth-order method</h3>

<p>Using the fifth-order approximation allows additional control over the fifth and sixth moments of the generated distribution, improving
accuracy.  In addition, the range of feasible standardized kurtosis (<code class="reqn">\gamma_2</code>) values, given skew (<code class="reqn">\gamma_1</code>) and standardized fifth (<code class="reqn">\gamma_3</code>) and sixth
(<code class="reqn">\gamma_4</code>) cumulants, is larger than with Fleishman's method (see <code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code>).
For example, the Fleishman method can not be used to generate a non-normal distribution with a ratio of
<code class="reqn">\gamma_1^2/\gamma_2 &gt; 9/14</code> (see Headrick &amp; Kowalchuk, 2007).  This eliminates the Chi-squared family of distributions, which has
a constant ratio of <code class="reqn">\gamma_1^2/\gamma_2 = 2/3</code>.  The fifth-order method also generates more distributions with valid PDF's.
However, if the fifth and sixth cumulants are unknown or do not exist, the Fleishman approximation should be used.
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code><a href="SimMultiCorrData.html#topic+fleish">fleish</a></code> or
<code><a href="SimMultiCorrData.html#topic+poly">poly</a></code> converged when using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If this happens,
the simulation will stop.  It may help to first use <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> for each continuous variable to
determine if a sixth cumulant correction value is needed.  The solutions can be used as starting values (see <code>cstart</code> below).
If the standardized cumulants are obtained from <code>calc_theory</code>, the user may need to use rounded values as inputs (i.e.
<code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code> to determine the boundary for a given set of cumulants.
</p>
<p>3) The feasibility of the final correlation matrix <code>rho</code>, given the
distribution parameters, should be checked first using <code><a href="#topic+validcorr">validcorr</a></code>.  This function either checks
if a given <code>rho</code> is plausible or returns the lower and upper final correlation limits.  It should be noted that even if a target
correlation matrix is within the &quot;plausible range,&quot; it still may not be possible to achieve the desired matrix.  This happens most
frequently when generating ordinal variables or using negative correlations.  The error loop frequently fixes these problems.
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="#topic+validpar">validpar</a></code>, <code><a href="#topic+validcorr">validcorr</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corr_error">corr_error</a></code>, <code><a href="#topic+summary_var">summary_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sim1 &lt;- corrvar(n = 1000, k_cat = 1, k_cont = 1, method = "Polynomial",
  means = 0, vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), support = list(0:2),
  rho = matrix(c(1, 0.4, 0.4, 1), 2, 2), quiet = TRUE)

## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, rho = Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed)

# simulate without the error loop
Sim2 &lt;- corrvar(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed, epsilon = 0.01)

names(Sim2)

# simulate with the error loop
Sim2_EL &lt;- corrvar(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial",
  means, vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus,
  mix_sigmas, mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six,
  marginal, support, lam, p_zip, size, prob, mu = NULL, p_zinb, Rey,
  seed, errorloop = TRUE, epsilon = 0.01)

names(Sim2_EL)

## End(Not run)


</code></pre>

<hr>
<h2 id='corrvar2'>Generation of Correlated Ordinal, Continuous (mixture and non-mixture), and/or Count (Poisson and Negative Binomial,
regular and zero-inflated) Variables: Correlation Method 2</h2><span id='topic+corrvar2'></span>

<h3>Description</h3>

<p>This function simulates <code>k_cat</code> ordinal (<code class="reqn">r \ge 2</code> categories), <code>k_cont</code> continuous non-mixture,
<code>k_mix</code> continuous mixture, <code>k_pois</code> Poisson (regular and zero-inflated), and/or <code>k_nb</code> Negative Binomial
(regular and zero-inflated) variables with a specified correlation matrix <code>rho</code>.  The variables are generated from
multivariate normal variables with intermediate correlation matrix <code>Sigma</code>, calculated by <code><a href="#topic+intercorr2">intercorr2</a></code>,
and then transformed.  The intermediate correlations involving count variables are determined using <strong>correlation method 2</strong>.
The <em>ordering</em> of the variables in <code>rho</code> must be 1st ordinal, 2nd continuous non-mixture,
3rd components of the continuous mixture, 4th regular Poisson, 5th zero-inflated Poisson, 6th regular NB, and 7th zero-inflated NB.
Note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_mix</code>, <code>k_pois</code>, and/or <code>k_nb</code> to be 0.
Simulation occurs at the component-level for continuous mixture distributions.  The target correlation matrix is specified in terms of
correlations with components of continuous mixture variables.  There are no parameter input checks
in order to decrease simulation time.  All inputs should be checked prior to simulation with <code><a href="#topic+validpar">validpar</a></code>
and <code><a href="#topic+validcorr2">validcorr2</a></code>.  Summaries for the simulation results can be obtained with <code><a href="#topic+summary_var">summary_var</a></code>.
</p>
<p>All continuous variables are simulated using either Fleishman's third-order (<code>method</code> = &quot;Fleishman&quot;, doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order
(<code>method</code> = &quot;Polynomial&quot;, doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) power method transformation.  It works by matching standardized
cumulants &ndash; the first four (mean, variance, skew, and standardized kurtosis) for Fleishman's method, or the first six (mean,
variance, skew, standardized kurtosis, and standardized fifth and sixth cumulants) for Headrick's method.  The transformation is
expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y = c_0 + c_1 * Z + c_2 * Z^2 + c_3 * Z^3 + c_4 * Z^4 + c_5 * Z^5,  Z \sim N(0,1),</code>
</p>

<p>where <code class="reqn">c_4</code> and <code class="reqn">c_5</code> both equal <code class="reqn">0</code> for Fleishman's method.  The real constants are calculated by <br />
<code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  Continuous mixture variables are generated componentwise and then transformed to
the desired mixture variables based on random multinomial variables generated from the mixing probabilities.  Ordinal variables
(<code class="reqn">r \ge 2</code> categories) are generated by discretizing the standard normal
variables at quantiles.  These quantiles are determined by evaluating the inverse standard normal CDF at the cumulative
probabilities defined by each variable's marginal distribution.  Count variables are generated using the inverse CDF method.  The
CDF of a standard normal variable has a uniform distribution.  The appropriate quantile function (F_Y)^(-1) is applied to
this uniform variable with the designated parameters to generate the count variable: Y = (F_Y)^(-1)(Phi(Z)).  The Negative
Binomial variable represents the number of failures which occur in a sequence of Bernoulli trials before the target number of
successes is achieved.  Zero-inflated Poisson or NB variables are obtained by setting the probability of a structural zero to be
greater than 0.  The optional error loop attempts to correct the final pairwise correlations to be within a user-specified
precision value (<code>epsilon</code>) of the target correlations.
</p>
<p>The vignette <b>Variable Types</b> discusses how each of the different variables are generated and describes the required parameters.
</p>
<p>The vignette <b>Overall Workflow for Generation of Correlated Data</b> provides a detailed example discussing the step-by-step simulation process and comparing correlation methods 1 and 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrvar2(n = 10000, k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0,
  k_nb = 0, method = c("Fleishman", "Polynomial"), means = NULL,
  vars = NULL, skews = NULL, skurts = NULL, fifths = NULL,
  sixths = NULL, Six = list(), mix_pis = list(), mix_mus = list(),
  mix_sigmas = list(), mix_skews = list(), mix_skurts = list(),
  mix_fifths = list(), mix_sixths = list(), mix_Six = list(),
  marginal = list(), support = list(), lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, pois_eps = 0.0001,
  nb_eps = 0.0001, rho = NULL, seed = 1234, errorloop = FALSE,
  epsilon = 0.001, maxit = 1000, use.nearPD = TRUE, Sigma = NULL,
  cstart = list(), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrvar2_+3A_n">n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable; default = 10000)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_k_mix">k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables.
&quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_means">means</code></td>
<td>
<p>a vector of means for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_six">Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br />
ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>; if no correction is desired for <code class="reqn">Y_{cont_i}</code>, set the i-th
list component equal to <code>NULL</code>; if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mix_six">mix_Six</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_support">support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector containing the r ordered support values;
if not provided (i.e. <code>support = list()</code>), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_pois_eps">pois_eps</code></td>
<td>
<p>a vector of length <code>k_pois</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_nb_eps">nb_eps</code></td>
<td>
<p>a vector of length <code>k_nb</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_errorloop">errorloop</code></td>
<td>
<p>if TRUE, uses <code><a href="#topic+corr_error">corr_error</a></code> to attempt to correct final pairwise correlations to be within
<code>epsilon</code> of target pairwise correlations (default = FALSE)</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlations (default = 0.001)
in the calculation of ordinal intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code> or in the error loop</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code> or in the error loop</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>TRUE to convert the overall intermediate correlation matrix to the nearest positive definite matrix with <code>Matrix::nearPD</code> if
necessary; if FALSE the negative eigenvalues are replaced with 0 if necessary</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_sigma">Sigma</code></td>
<td>
<p>an intermediate correlation matrix to use if the user wants to provide one, else it is calculated within by
<code><a href="#topic+intercorr2">intercorr2</a></code></p>
</td></tr>
<tr><td><code id="corrvar2_+3A_cstart">cstart</code></td>
<td>
<p>a list of length equal to <code>k_cont</code> + the total number of mixture components containing initial values for root-solving
algorithm used in <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If user specified, each list element must be input as a matrix.
For <code>method</code> = &quot;Fleishman&quot;, each should have 3 columns for <code class="reqn">c_1, c_2, c_3</code>;
for <code>method</code> = &quot;Polynomial&quot;, each should have 5 columns for <code class="reqn">c_1, c_2, c_3, c_4, c_5</code>.  If no starting values are specified for
a given component, that list element should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrvar2_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints simulation messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose components vary based on the type of simulated variables.
</p>
<p>If <b>ordinal variables</b> are produced: <code>Y_cat</code> the ordinal variables,
</p>
<p>If <b>continuous variables</b> are produced:
</p>
<p><code>constants</code> a data.frame of the constants,
</p>
<p><code>Y_cont</code> the continuous non-mixture variables,
</p>
<p><code>Y_comp</code> the components of the continuous mixture variables,
</p>
<p><code>Y_mix</code> the continuous mixture variables,
</p>
<p><code>sixth_correction</code> a list of sixth cumulant correction values,
</p>
<p><code>valid.pdf</code> a vector where the i-th element is &quot;TRUE&quot; if the constants for the i-th continuous variable generate a valid PDF, else &quot;FALSE&quot;
</p>
<p>If <b>Poisson variables</b> are produced: <code>Y_pois</code> the regular and zero-inflated Poisson variables,
</p>
<p>If <b>Negative Binomial variables</b> are produced: <code>Y_nb</code> the regular and zero-inflated Negative Binomial variables,
</p>
<p>Additionally, the following elements:
</p>
<p><code>Sigma</code> the intermediate correlation matrix (after the error loop),
</p>
<p><code>Error_Time</code> the time in minutes required to use the error loop,
</p>
<p><code>Time</code> the total simulation time in minutes,
</p>
<p><code>niter</code> a matrix of the number of iterations used for each variable in the error loop,
</p>


<h3>Overview of Method 2</h3>

<p>The intermediate correlations used in method 2 are less simulation based than those in method 1, and no seed is needed.
Their calculations involve greater utilization of correction loops which make iterative adjustments until a maximum error
has been reached (if possible).  In addition, method 2 differs from method 1 in the following ways:
</p>
<p>1) The intermediate correlations involving <b>count variables</b> are based on the methods of Barbiero &amp; Ferrari (2012,
doi: <a href="http://doi.org/10.1080/00273171.2012.692630">10.1080/00273171.2012.692630</a>, 2015, doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>).
The Poisson or Negative Binomial support is made finite by removing a small user-specified value (i.e. 1e-06) from the total
cumulative probability.  This truncation factor may differ for each count variable.  The count variables are subsequently
treated as ordinal and intermediate correlations are calculated using the correction loop of
<code><a href="#topic+ord_norm">ord_norm</a></code>.
</p>
<p>2) The <b>continuous - count variable</b> correlations are based on an extension of the method of Demirtas et al. (2012,
doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>), and the count
variables are treated as ordinal.  The correction factor is the product of the power method correlation between the
continuous variable and the normal variable used to generate it (see Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>)
and the point-polyserial correlation between the ordinalized count variable and the normal variable used to generate it (see Olsson et al., 1982,
doi: <a href="http://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>).
The intermediate correlations are the ratio of the target correlations to the correction factor.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for more information and a step-by-step overview of the simulation process.
</p>


<h3>Choice of Fleishman's third-order or Headrick's fifth-order method</h3>

<p>Using the fifth-order approximation allows additional control over the fifth and sixth moments of the generated distribution, improving
accuracy.  In addition, the range of feasible standardized kurtosis (<code class="reqn">\gamma_2</code>) values, given skew (<code class="reqn">\gamma_1</code>) and standardized fifth (<code class="reqn">\gamma_3</code>) and sixth
(<code class="reqn">\gamma_4</code>) cumulants, is larger than with Fleishman's method (see <code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code>).
For example, the Fleishman method can not be used to generate a non-normal distribution with a ratio of
<code class="reqn">\gamma_1^2/\gamma_2 &gt; 9/14</code> (see Headrick &amp; Kowalchuk, 2007).  This eliminates the Chi-squared family of distributions, which has
a constant ratio of <code class="reqn">\gamma_1^2/\gamma_2 = 2/3</code>.  The fifth-order method also generates more distributions with valid PDF's.
However, if the fifth and sixth cumulants are unknown or do not exist, the Fleishman approximation should be used.
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code><a href="SimMultiCorrData.html#topic+fleish">fleish</a></code> or
<code><a href="SimMultiCorrData.html#topic+poly">poly</a></code> converged when using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If this happens,
the simulation will stop.  It may help to first use <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> for each continuous variable to
determine if a sixth cumulant correction value is needed.  The solutions can be used as starting values (see <code>cstart</code> below).
If the standardized cumulants are obtained from <code>calc_theory</code>, the user may need to use rounded values as inputs (i.e.
<code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code> to determine the boundary for a given set of cumulants.
</p>
<p>3) The feasibility of the final correlation matrix <code>rho</code>, given the
distribution parameters, should be checked first using <code><a href="#topic+validcorr2">validcorr2</a></code>.  This function either checks
if a given <code>rho</code> is plausible or returns the lower and upper final correlation limits.  It should be noted that even if a target
correlation matrix is within the &quot;plausible range,&quot; it still may not be possible to achieve the desired matrix.  This happens most
frequently when generating ordinal variables or using negative correlations.  The error loop frequently fixes these problems.
</p>


<h3>References</h3>

<p>Barbiero A &amp; Ferrari PA (2015). Simulation of correlated Poisson variables. Applied Stochastic Models in
Business and Industry, 31:669-80. doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.
</p>
<p>Barbiero A &amp; Ferrari PA (2015). GenOrd: Simulation of Discrete Random Variables with Given
Correlation Matrix and Marginal Distributions. R package version 1.4.0. <br /> <a href="https://CRAN.R-project.org/package=GenOrd">https://CRAN.R-project.org/package=GenOrd</a>
</p>
<p>Davenport JW, Bezder JC, &amp; Hathaway RJ (1988). Parameter Estimation for Finite Mixture Distributions.
Computers &amp; Mathematics with Applications, 15(10):819-28.
</p>
<p>Demirtas H (2006). A method for multivariate ordinal data generation given marginal distributions and correlations. Journal of Statistical
Computation and Simulation, 76(11):1017-1025. <br /> doi: <a href="http://doi.org/10.1080/10629360600569246">10.1080/10629360600569246</a>.
</p>
<p>Demirtas H (2014). Joint Generation of Binary and Nonnormal Continuous Data. Biometrics &amp; Biostatistics, S12.
</p>
<p>Demirtas H, Hedeker D, &amp; Mermelstein RJ (2012). Simulation of massive public health data by power polynomials.
Statistics in Medicine, 31(27):3337-3346. doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>.
</p>
<p>Everitt BS (1996). An Introduction to Finite Mixture Distributions. Statistical Methods in Medical Research, 5(2):107-127. doi: <a href="http://doi.org/10.1177/096228029600500202">10.1177/096228029600500202</a>.
</p>
<p>Ferrari PA &amp; Barbiero A (2012). Simulating ordinal data. Multivariate Behavioral Research, 47(4): 566-589.
doi: <a href="http://doi.org/10.1080/00273171.2012.692630">10.1080/00273171.2012.692630</a>.
</p>
<p>Fialkowski AC (2018). SimMultiCorrData: Simulation of Correlated Data with Multiple Variable Types. R package version 0.2.2.
<a href="https://CRAN.R-project.org/package=SimMultiCorrData">https://CRAN.R-project.org/package=SimMultiCorrData</a>.
</p>
<p>Fleishman AI (1978). A Method for Simulating Non-normal Distributions. Psychometrika, 43:521-532. doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>.
</p>
<p>Headrick TC (2002). Fast Fifth-order Polynomial Transforms for Generating Univariate and Multivariate
Non-normal Distributions. Computational Statistics &amp; Data Analysis, 40(4):685-711. doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>.
(<a href="http://www.sciencedirect.com/science/article/pii/S0167947302000725">ScienceDirect</a>)
</p>
<p>Headrick TC (2004). On Polynomial Transformations for Simulating Multivariate Nonnormal Distributions.
Journal of Modern Applied Statistical Methods, 3(1):65-71. doi: <a href="http://doi.org/10.22237/jmasm/1083370080">10.22237/jmasm/1083370080</a>.
</p>
<p>Headrick TC, Kowalchuk RK (2007). The Power Method Transformation: Its Probability Density Function, Distribution
Function, and Its Further Use for Fitting Data. Journal of Statistical Computation and Simulation, 77:229-249. doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>.
</p>
<p>Headrick TC, Sawilowsky SS (1999). Simulating Correlated Non-normal Distributions: Extending the Fleishman Power
Method. Psychometrika, 64:25-35. doi: <a href="http://doi.org/10.1007/BF02294317">10.1007/BF02294317</a>.
</p>
<p>Headrick TC, Sheng Y, &amp; Hodis FA (2007). Numerical Computing and Graphics for the Power Method Transformation Using
Mathematica. Journal of Statistical Software, 19(3):1 - 17. <br /> doi: <a href="http://doi.org/10.18637/jss.v019.i03">10.18637/jss.v019.i03</a>.
</p>
<p>Higham N (2002). Computing the nearest correlation matrix - a problem from finance; IMA Journal of Numerical Analysis 22:329-343.
</p>
<p>Ismail N &amp; Zamani H (2013). Estimation of Claim Count Data Using Negative Binomial, Generalized Poisson, Zero-Inflated Negative Binomial and
Zero-Inflated Generalized Poisson Regression Models. Casualty Actuarial Society E-Forum 41(20):1-28.
</p>
<p>Lambert D (1992). Zero-Inflated Poisson Regression, with an Application to Defects in Manufacturing. Technometrics 34(1):1-14.
</p>
<p>Olsson U, Drasgow F, &amp; Dorans NJ (1982). The Polyserial Correlation Coefficient. Psychometrika, 47(3):337-47.
doi: <a href="http://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>.
</p>
<p>Pearson RK (2011). Exploring Data in Engineering, the Sciences, and Medicine. In. New York: Oxford University Press.
</p>
<p>Schork NJ, Allison DB, &amp; Thiel B (1996). Mixture Distributions in Human Genetics Research. Statistical Methods in Medical Research,
5:155-178. doi: <a href="http://doi.org/10.1177/096228029600500204">10.1177/096228029600500204</a>.
</p>
<p>Vale CD &amp; Maurelli VA (1983). Simulating Multivariate Nonnormal Distributions. Psychometrika, 48:465-471. doi: <a href="http://doi.org/10.1007/BF02293687">10.1007/BF02293687</a>.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>
<p>Zhang X, Mallick H, &amp; Yi N (2016). Zero-Inflated Negative Binomial Regression for Differential Abundance Testing in Microbiome
Studies. Journal of Bioinformatics and Genomics 2(2):1-9. doi: <a href="http://doi.org/10.18454/jbg.2016.2.2.1">10.18454/jbg.2016.2.2.1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="#topic+validpar">validpar</a></code>, <code><a href="#topic+validcorr2">validcorr2</a></code>,
<code><a href="#topic+intercorr2">intercorr2</a></code>, <code><a href="#topic+corr_error">corr_error</a></code>, <code><a href="#topic+summary_var">summary_var</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sim1 &lt;- corrvar2(n = 1000, k_cat = 1, k_cont = 1, method = "Polynomial",
  means = 0, vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), support = list(0:2),
  rho = matrix(c(1, 0.4, 0.4, 1), 2, 2), quiet = TRUE)

## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
pois_eps &lt;- 0.0001
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2
nb_eps &lt;- 0.0001

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps, nb_eps, Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr2(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps, nb_eps, Rey, seed)

# simulate without the error loop
Sim2 &lt;- corrvar2(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps, nb_eps, Rey, seed,
  epsilon = 0.01)

names(Sim2)

# simulate with the error loop
Sim2_EL &lt;- corrvar2(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial",
  means, vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus,
  mix_sigmas, mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six,
  marginal, support, lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps,
  nb_eps, Rey, seed, errorloop = TRUE, epsilon = 0.01)

names(Sim2_EL)

## End(Not run)
</code></pre>

<hr>
<h2 id='intercorr'>Calculate Intermediate MVN Correlation for Ordinal, Continuous, Poisson, or Negative Binomial Variables: Correlation Method 1</h2><span id='topic+intercorr'></span>

<h3>Description</h3>

<p>This function calculates a <code>k x k</code> intermediate matrix of correlations, where <code>k = k_cat + k_cont +</code>
<code>k_pois + k_nb</code>, to be used in simulating variables with <code><a href="#topic+corrvar">corrvar</a></code>.  The <code>k_cont</code> includes regular continuous variables
and components of continuous mixture variables.  The ordering of the variables must be
ordinal, continuous non-mixture, components of continuous mixture variables, regular Poisson, zero-inflated Poisson, regular Negative
Binomial (NB), and zero-inflated NB (note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_pois</code>, and/or <code>k_nb</code> to be 0).
There are no parameter input checks in order to decrease simulation time.  All inputs should be checked prior to simulation with
<code><a href="#topic+validpar">validpar</a></code>.  There is a message given if the calculated
intermediate correlation matrix <code>Sigma</code> is not positive-definite because it may not be possible to find a MVN correlation
matrix that will produce the desired marginal distributions.  This function is called by the simulation function
<code><a href="#topic+corrvar">corrvar</a></code>, and would only be used separately if the user wants to first find the intermediate correlation matrix.
This matrix <code>Sigma</code> can be used as an input to <code><a href="#topic+corrvar">corrvar</a></code>.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for information about calculations by variable pair type and the differences between
this function and <code><a href="#topic+intercorr2">intercorr2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr(k_cat = 0, k_cont = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), constants = NULL,
  marginal = list(), support = list(), lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, rho = NULL,
  seed = 1234, epsilon = 0.001, maxit = 1000, nrand = 100000,
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables and components of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses a third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;) like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1; default = list())</p>
</td></tr>
<tr><td><code id="intercorr_+3A_support">support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of containing the r
ordered support values; if not provided (i.e. <code>support</code> = list()), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="intercorr_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="intercorr_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="intercorr_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the pairwise correlations (default = 0.001)
in the calculation of ordinal intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code></p>
</td></tr>
<tr><td><code id="intercorr_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code></p>
</td></tr>
<tr><td><code id="intercorr_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating intermediate correlations (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints simulation messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the intermediate MVN correlation matrix
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrvar">corrvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma1 &lt;- intercorr(k_cat = 1, k_cont = 1, method = "Polynomial",
  constants = matrix(c(0, 1, 0, 0, 0, 0), 1, 6), marginal = list(0.3),
  support = list(c(0, 1)), rho = matrix(c(1, 0.4, 0.4, 1), 2, 2),
  quiet = TRUE)
## Not run: 
# 1 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
seed &lt;- 1234

# Mixture of N(-2, 1) and N(2, 1)
constants &lt;- rbind(c(0, 1, 0, 0, 0, 0), c(0, 1, 0, 0, 0, 0))

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 2
Rey &lt;- matrix(0.35, 5, 5)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0

Sigma2 &lt;- intercorr(k_cat, k_cont, k_pois, k_nb, "Polynomial", constants,
  marginal, support, lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed)

## End(Not run)
</code></pre>

<hr>
<h2 id='intercorr_cat_nb'>Calculate Intermediate MVN Correlation for Ordinal - Negative Binomial Variables: Correlation Method 1</h2><span id='topic+intercorr_cat_nb'></span>

<h3>Description</h3>

<p>This function calculates the <code>k_cat x k_nb</code> intermediate matrix of correlations for the <code>k_cat</code> ordinal (<code class="reqn">r &gt;=
    2</code> categories) and <code>k_nb</code> Negative Binomial variables required to produce the target correlations in <code>rho_cat_nb</code>. It extends the method of Amatya &amp; Demirtas (2015, doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>)
to ordinal - Negative Binomial pairs and allows for regular or zero-inflated NB variables.  Here, the intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable
discretized to produce an ordinal variable Y1, and Z2 is the standard normal variable used to generate a Negative Binomial
variable via the inverse CDF method) is calculated by dividing the target correlation by a correction factor.  The
correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between a Negative Binomial variable
and the normal variable used to generate it and a simulated GSC upper bound on the correlation between an ordinal variable and the normal variable used to generate it (see Demirtas &amp; Hedeker, 2011,
doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>).  The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and <code><a href="#topic+corrvar">corrvar</a></code>.
This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cat_nb(rho_cat_nb = NULL, marginal = list(), size = NULL,
  mu = NULL, p_zinb = 0, nrand = 100000, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cat_nb_+3A_rho_cat_nb">rho_cat_nb</code></td>
<td>
<p>a <code>k_cat x k_nb</code> matrix of target correlations among ordinal and Negative Binomial variables; the NB variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_cat_nb_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cat x k_nb</code> matrix whose rows represent the <code>k_cat</code> ordinal variables and columns represent the
<code>k_nb</code> Negative Binomial variables
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+intercorr_cat_pois">intercorr_cat_pois</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_cat_pois'>Calculate Intermediate MVN Correlation for Ordinal - Poisson Variables: Correlation Method 1</h2><span id='topic+intercorr_cat_pois'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_cat x k_pois</code> intermediate matrix of correlations for the <code>k_cat</code> ordinal (<code class="reqn">r &gt;=
    2</code> categories) and <code>k_pois</code> Poisson variables required to produce the target correlations in <code>rho_cat_pois</code>. It extends the method of Amatya &amp; Demirtas (2015, doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>)
to ordinal - Poisson pairs and allows for regular or zero-inflated Poisson variables.
Here, the intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable discretized to produce an
ordinal variable Y1, and Z2 is the standard normal variable used to generate a Poisson variable via the inverse CDF method) is
calculated by dividing the target correlation by a correction factor.  The correction factor is the product of the
upper Frechet-Hoeffding bound on the correlation between a Poisson variable and the normal variable used to generate it
and a simulated GSC upper bound on the correlation between an ordinal variable and the normal variable used to generate it (see
Demirtas &amp; Hedeker, 2011, doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>).  The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and
<code><a href="#topic+corrvar">corrvar</a></code>.  This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cat_pois(rho_cat_pois = NULL, marginal = list(), lam = NULL,
  p_zip = 0, nrand = 100000, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cat_pois_+3A_rho_cat_pois">rho_cat_pois</code></td>
<td>
<p>a <code>k_cat x k_pois</code> matrix of target correlations among ordinal and Poisson variables; the Poisson variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cat_pois_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td></tr>
<tr><td><code id="intercorr_cat_pois_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr_cat_pois_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_cat_pois_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_cat_pois_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cat x k_pois</code> matrix whose rows represent the <code>k_cat</code> ordinal variables and columns represent the <code>k_pois</code> Poisson variables
</p>


<h3>References</h3>

<p>Amatya A &amp; Demirtas H (2015). Simultaneous generation of multivariate mixed data with Poisson and normal marginals.
Journal of Statistical Computation and Simulation, 85(15):3129-39. doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>.
</p>
<p>Demirtas H &amp; Hedeker D (2011). A practical way for computing approximate lower and upper correlation bounds.
American Statistician, 65(2):104-109. doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>.
</p>
<p>Frechet M (1951). Sur les tableaux de correlation dont les marges sont donnees.  Ann. l'Univ. Lyon SectA, 14:53-77.
</p>
<p>Hoeffding W. Scale-invariant correlation theory. In: Fisher NI, Sen PK, editors. The collected works of Wassily Hoeffding.
New York: Springer-Verlag; 1994. p. 57-107.
</p>
<p>Yahav I &amp; Shmueli G (2012). On Generating Multivariate Poisson Data in Management Science Applications. Applied Stochastic
Models in Business and Industry, 28(1):91-102. doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_cont'>Calculate Intermediate MVN Correlation for Continuous Variables Generated by Polynomial Transformation Method</h2><span id='topic+intercorr_cont'></span>

<h3>Description</h3>

<p>This function finds the intermediate correlation for standard normal random variables
which are used in Fleishman's third-order (doi: <a href="http://doi.org/10.1007/BF02293811">10.1007/BF02293811</a>) or Headrick's fifth-order
(doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>) polynomial transformation method (PMT) using <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.  It is used in
<code><a href="#topic+intercorr">intercorr</a></code> and <code><a href="#topic+intercorr2">intercorr2</a></code> and would not ordinarily be called by the user.  The
correlations are found pairwise so that eigen-value or principal components decomposition should be done on the resulting <code>Sigma</code>
matrix. The <b>Comparison of Correlation Methods 1 and 2</b> vignette contains the equations which were derived by Headrick and Sawilowsky
(doi: <a href="http://doi.org/10.1007/BF02294317">10.1007/BF02294317</a>) or Headrick (doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cont(method = c("Fleishman", "Polynomial"), constants = NULL,
  rho_cont = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cont_+3A_method">method</code></td>
<td>
<p>the method used to generate the continuous variables.  &quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_cont_+3A_constants">constants</code></td>
<td>
<p>a matrix with each row a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by
<code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_+3A_rho_cont">rho_cont</code></td>
<td>
<p>a matrix of target correlations among continuous variables, does not have to be symmetric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the intermediate matrix of correlations with the same dimensions as <code>rho_cont</code>
</p>


<h3>References</h3>

<p>Please see additional references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>
<p>Fialkowski AC (2018). SimMultiCorrData: Simulation of Correlated Data with Multiple Variable Types. R package version 0.2.2.
<a href="https://CRAN.R-project.org/package=SimMultiCorrData">https://CRAN.R-project.org/package=SimMultiCorrData</a>.
</p>
<p>Headrick TC (2002). Fast Fifth-order Polynomial Transforms for Generating Univariate and Multivariate
Non-normal Distributions. Computational Statistics &amp; Data Analysis, 40(4):685-711. doi: <a href="http://doi.org/10.1016/S0167-9473(02)00072-5">10.1016/S0167-9473(02)00072-5</a>.
(<a href="http://www.sciencedirect.com/science/article/pii/S0167947302000725">ScienceDirect</a>)
</p>
<p>Headrick TC, Kowalchuk RK (2007). The Power Method Transformation: Its Probability Density Function, Distribution
Function, and Its Further Use for Fitting Data. Journal of Statistical Computation and Simulation, 77:229-249. doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>.
</p>
<p>Headrick TC, Sawilowsky SS (1999). Simulating Correlated Non-normal Distributions: Extending the Fleishman Power
Method. Psychometrika, 64:25-35. doi: <a href="http://doi.org/10.1007/BF02294317">10.1007/BF02294317</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+intercorr2">intercorr2</a></code>, <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
</p>

<hr>
<h2 id='intercorr_cont_nb'>Calculate Intermediate MVN Correlation for Continuous - Negative Binomial Variables: Correlation Method 1</h2><span id='topic+intercorr_cont_nb'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_cont x k_nb</code> intermediate matrix of correlations for the <code>k_cont</code> continuous and
<code>k_nb</code> Negative Binomial variables. It extends the method of Amatya &amp; Demirtas (2015, doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>) to
continuous variables generated using Headrick's fifth-order polynomial transformation and regular or zero-inflated NB variables.
Here, the intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable transformed using Headrick's fifth-order
or Fleishman's third-order method to produce a continuous variable Y1, and Z2 is the standard normal variable used to generate a
Negative Binomial variable via the inverse CDF method) is calculated by dividing the target correlation by a correction factor.
The correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between a Negative Binomial variable and
the normal variable used to generate it and the power method correlation (described in Headrick &amp; Kowalchuk, 2007,
doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>) between Y1 and Z1.  The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and
<code><a href="#topic+corrvar">corrvar</a></code>.  This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cont_nb(method = c("Fleishman", "Polynomial"), constants = NULL,
  rho_cont_nb = NULL, size = NULL, mu = NULL, p_zinb = 0,
  nrand = 100000, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cont_nb_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses a third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_rho_cont_nb">rho_cont_nb</code></td>
<td>
<p>a <code>k_cont x k_nb</code> matrix of target correlations among continuous and Negative Binomial variables; the NB variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cont x k_nb</code> matrix whose rows represent the <code>k_cont</code> continuous variables and columns represent the
<code>k_nb</code> Negative Binomial variables
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+intercorr_cont_pois">intercorr_cont_pois</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_cont_nb2'>Calculate Intermediate MVN Correlation for Continuous - Negative Binomial Variables: Correlation Method 2</h2><span id='topic+intercorr_cont_nb2'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_cont x k_nb</code> intermediate matrix of correlations for the <code>k_cont</code> continuous and
<code>k_nb</code> Negative Binomial variables. It extends the methods of Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>) and
Barbiero &amp; Ferrari (2015, doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>) by:
</p>
<p>1) including non-normal continuous and regular or zero-inflated Negative Binomial variables
</p>
<p>2) allowing the continuous variables to be generated via Fleishman's third-order or Headrick's fifth-order transformation, and
</p>
<p>3) since the count variables are treated as ordinal, using the point-polyserial and polyserial correlations to calculate the
intermediate correlations (similar to <code><a href="SimMultiCorrData.html#topic+findintercorr_cont_cat">findintercorr_cont_cat</a></code> in <br />
<code><a href="SimMultiCorrData.html#topic+SimMultiCorrData">SimMultiCorrData</a></code>).
</p>
<p>Here, the intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable transformed using Headrick's fifth-order
or Fleishman's third-order method to produce a continuous variable Y1, and Z2 is the standard normal variable used to generate a
Negative Binomial variable via the inverse CDF method) is calculated by dividing the target correlation by a correction factor.  The
correction factor is the product of the point-polyserial correlation between Y2 and Z2 (described in Olsson et al., 1982,
doi: <a href="http://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>) and the power method correlation (described in Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>)
between Y1 and Z1.  After the maximum support value has been found using <code><a href="#topic+maxcount_support">maxcount_support</a></code>, the point-polyserial correlation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Y2,Z2} = \frac{1}{\sigma_{Y2}} \sum_{j = 1}^{r-1} \phi(\tau_{j})(y2_{j+1} - y2_{j})</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">\phi(\tau) = (2\pi)^{-1/2} * exp(-0.5 \tau^2)</code>
</p>
<p>  Here, <code class="reqn">y_{j}</code> is the j-th support
value and <code class="reqn">\tau_{j}</code> is <code class="reqn">\Phi^{-1}(\sum_{i=1}^{j} Pr(Y = y_{i}))</code>.  The power method correlation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Y1, Z1} = c_1 + 3c_3 + 15c_5,</code>
</p>
<p> where <code class="reqn">c_5 = 0</code> if <code>method</code> = &quot;Fleishman&quot;.  The function is used in
<code><a href="#topic+intercorr2">intercorr2</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code>.  This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cont_nb2(method = c("Fleishman", "Polynomial"), constants = NULL,
  rho_cont_nb = NULL, nb_marg = list(), nb_support = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cont_nb2_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb2_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_nb2_+3A_rho_cont_nb">rho_cont_nb</code></td>
<td>
<p>a <code>k_cont x k_nb</code> matrix of target correlations among continuous and Negative Binomial variables; the NB variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cont_nb2_+3A_nb_marg">nb_marg</code></td>
<td>
<p>a list of length equal to <code>k_nb</code> ordered 1st regular and 2nd zero-inflated; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
this is created within <code><a href="#topic+intercorr2">intercorr2</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_nb2_+3A_nb_support">nb_support</code></td>
<td>
<p>a list of length equal to <code>k_nb</code> ordered 1st regular and 2nd zero-inflated; the i-th element is a vector of containing the r
ordered support values, with a minimum of 0 and maximum determined via <code><a href="#topic+maxcount_support">maxcount_support</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cont x k_nb</code> matrix whose rows represent the <code>k_cont</code> continuous variables and columns represent the
<code>k_nb</code> Negative Binomial variables
</p>


<h3>References</h3>

<p>Please see references in <code><a href="#topic+intercorr_cont_pois2">intercorr_cont_pois2</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="SimMultiCorrData.html#topic+power_norm_corr">power_norm_corr</a></code>,
<code><a href="#topic+intercorr2">intercorr2</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>

<hr>
<h2 id='intercorr_cont_pois'>Calculate Intermediate MVN Correlation for Continuous - Poisson Variables: Correlation Method 1</h2><span id='topic+intercorr_cont_pois'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_cont x k_pois</code> intermediate matrix of correlations for the <code>k_cont</code> continuous and
<code>k_pois</code> Poisson variables. It extends the method of Amatya &amp; Demirtas (2015, doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>) to continuous
variables generated using Headrick's fifth-order polynomial transformation and zero-inflated Poisson variables.  Here, the
intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable transformed using Headrick's fifth-order or
Fleishman's third-order method to produce a continuous variable Y1, and Z2 is the standard normal variable used to generate a
Poisson variable via the inverse CDF method) is calculated by dividing the target correlation by a correction factor.  The
correction factor is the product of the upper Frechet-Hoeffding bound on the correlation between a Poisson variable and the
normal variable used to generate it and the power method correlation (described in Headrick &amp; Kowalchuk, 2007,
doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>) between Y1 and Z1.  The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and
<code><a href="#topic+corrvar">corrvar</a></code>.  This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cont_pois(method = c("Fleishman", "Polynomial"), constants = NULL,
  rho_cont_pois = NULL, lam = NULL, p_zip = 0, nrand = 100000,
  seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cont_pois_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses a third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_rho_cont_pois">rho_cont_pois</code></td>
<td>
<p>a <code>k_cont x k_pois</code> matrix of target correlations among continuous and Poisson variables; the Poisson variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cont x k_pois</code> matrix whose rows represent the <code>k_cont</code> continuous variables and columns represent the
<code>k_pois</code> Poisson variables
</p>


<h3>References</h3>

<p>Amatya A &amp; Demirtas H (2015). Simultaneous generation of multivariate mixed data with Poisson and normal marginals.
Journal of Statistical Computation and Simulation, 85(15):3129-39. doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>.
</p>
<p>Demirtas H &amp; Hedeker D (2011). A practical way for computing approximate lower and upper correlation bounds.
American Statistician, 65(2):104-109. doi: <a href="http://doi.org/10.1198/tast.2011.10090">10.1198/tast.2011.10090</a>.
</p>
<p>Frechet M (1951). Sur les tableaux de correlation dont les marges sont donnees.  Ann. l'Univ. Lyon SectA, 14:53-77.
</p>
<p>Headrick TC, Kowalchuk RK (2007). The Power Method Transformation: Its Probability Density Function, Distribution
Function, and Its Further Use for Fitting Data. Journal of Statistical Computation and Simulation, 77:229-249. doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>.
</p>
<p>Hoeffding W. Scale-invariant correlation theory. In: Fisher NI, Sen PK, editors. The collected works of Wassily Hoeffding.
New York: Springer-Verlag; 1994. p. 57-107.
</p>
<p>Yahav I &amp; Shmueli G (2012). On Generating Multivariate Poisson Data in Management Science Applications. Applied Stochastic
Models in Business and Industry, 28(1):91-102. doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+power_norm_corr">power_norm_corr</a></code>, <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_cont_pois2'>Calculate Intermediate MVN Correlation for Continuous - Poisson Variables: Correlation Method 2</h2><span id='topic+intercorr_cont_pois2'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_cont x k_pois</code> intermediate matrix of correlations for the <code>k_cont</code> continuous and
<code>k_pois</code> Poisson variables. It extends the methods of Demirtas et al. (2012, doi: <a href="http://doi.org/10.1002/sim.5362">10.1002/sim.5362</a>) and
Barbiero &amp; Ferrari (2015, doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>) by:
</p>
<p>1) including non-normal continuous and regular or zero-inflated Poisson variables
</p>
<p>2) allowing the continuous variables to be generated via Fleishman's third-order or Headrick's fifth-order transformation, and
</p>
<p>3) since the count variables are treated as ordinal, using the point-polyserial and polyserial correlations to calculate the
intermediate correlations (similar to <code><a href="SimMultiCorrData.html#topic+findintercorr_cont_cat">findintercorr_cont_cat</a></code>) in <br />
<code><a href="SimMultiCorrData.html#topic+SimMultiCorrData">SimMultiCorrData</a></code>).
</p>
<p>Here, the intermediate correlation between Z1 and Z2 (where Z1 is the standard normal variable transformed using Headrick's fifth-order
or Fleishman's third-order method to produce a continuous variable Y1, and Z2 is the standard normal variable used to generate a
Poisson variable via the inverse CDF method) is calculated by dividing the target correlation by a correction factor.  The
correction factor is the product of the point-polyserial correlation between Y2 and Z2 (described in Olsson et al., 1982,
doi: <a href="http://doi.org/10.1007/BF02294164">10.1007/BF02294164</a>) and the power method correlation (described in Headrick &amp; Kowalchuk, 2007, doi: <a href="http://doi.org/10.1080/10629360600605065">10.1080/10629360600605065</a>)
between Y1 and Z1.  After the maximum support value has been found using <code><a href="#topic+maxcount_support">maxcount_support</a></code>, the point-polyserial correlation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Y2,Z2} = \frac{1}{\sigma_{Y2}} \sum_{j = 1}^{r-1} \phi(\tau_{j})(y2_{j+1} - y2_{j})</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">\phi(\tau) = (2\pi)^{-1/2} * exp(-0.5 \tau^2)</code>
</p>
<p>  Here, <code class="reqn">y_{j}</code> is the j-th support
value and <code class="reqn">\tau_{j}</code> is <code class="reqn">\Phi^{-1}(\sum_{i=1}^{j} Pr(Y = y_{i}))</code>.  The power method correlation is given by:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Y1, Z1} = c_1 + 3c_3 + 15c_5,</code>
</p>
<p> where <code class="reqn">c_5 = 0</code> if <code>method</code> = &quot;Fleishman&quot;.  The function is used in
<code><a href="#topic+intercorr2">intercorr2</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code>.  This function would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_cont_pois2(method = c("Fleishman", "Polynomial"),
  constants = NULL, rho_cont_pois = NULL, pois_marg = list(),
  pois_support = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_cont_pois2_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois2_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;), like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_pois2_+3A_rho_cont_pois">rho_cont_pois</code></td>
<td>
<p>a <code>k_cont x k_pois</code> matrix of target correlations among continuous and Poisson variables; the Poisson variables
should be ordered 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_cont_pois2_+3A_pois_marg">pois_marg</code></td>
<td>
<p>a list of length equal to <code>k_pois</code> ordered 1st regular and 2nd zero-inflated; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
this is created within <code><a href="#topic+intercorr2">intercorr2</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code></p>
</td></tr>
<tr><td><code id="intercorr_cont_pois2_+3A_pois_support">pois_support</code></td>
<td>
<p>a list of length equal to <code>k_pois</code> ordered 1st regular and 2nd zero-inflated; the i-th element is a vector of containing the r
ordered support values, with a minimum of 0 and maximum determined via <code><a href="#topic+maxcount_support">maxcount_support</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>k_cont x k_pois</code> matrix whose rows represent the <code>k_cont</code> continuous variables and columns represent the
<code>k_pois</code> Poisson variables
</p>


<h3>References</h3>

<p>Please see additional references in <code><a href="#topic+intercorr_cont_pois">intercorr_cont_pois</a></code>.
</p>
<p>Barbiero A &amp; Ferrari PA (2015). Simulation of correlated Poisson variables. Applied Stochastic Models in
Business and Industry, 31:669-80. doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="SimMultiCorrData.html#topic+power_norm_corr">power_norm_corr</a></code>,
<code><a href="#topic+intercorr2">intercorr2</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>

<hr>
<h2 id='intercorr_nb'>Calculate Intermediate MVN Correlation for Negative Binomial Variables: Correlation Method 1</h2><span id='topic+intercorr_nb'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_nb x k_nb</code> intermediate matrix of correlations for the Negative Binomial variables by
extending the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>). The intermediate correlation between Z1 and Z2 (the
standard normal variables used to generate the Negative Binomial variables Y1 and Y2 via the inverse CDF method) is
calculated using a logarithmic transformation of the target correlation.  First, the upper and lower Frechet-Hoeffding bounds
(mincor, maxcor) on <code class="reqn">\rho_{Y1, Y2}</code> are simulated.  Then the intermediate correlation is found as follows:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Z1, Z2} = \frac{1}{b} * log(\frac{\rho_{Y1, Y2} - c}{a}),</code>
</p>

<p>where <code class="reqn">a = -(maxcor * mincor)/(maxcor + mincor)</code>, <code class="reqn">b = log((maxcor + a)/a)</code>, and <code class="reqn">c = -a</code>.
The function adapts code from Amatya &amp; Demirtas' (2016) package <code><a href="PoisNor.html#topic+PoisNor-package">PoisNor-package</a></code> by:
</p>
<p>1) allowing specifications for the number of random variates and the seed for reproducibility
</p>
<p>2) providing the following checks: if <code>Sigma_(Z1, Z2)</code> &gt; 1, <code>Sigma_(Z1, Z2)</code> is set to 1; if <code>Sigma_(Z1, Z2)</code> &lt; -1,
<code>Sigma_(Z1, Z2)</code> is set to -1
</p>
<p>3) simulating regular and zero-inflated Negative Binomial variables.
</p>
<p>The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and <code><a href="#topic+corrvar">corrvar</a></code> and would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_nb(rho_nb = NULL, size = NULL, mu = NULL, p_zinb = 0,
  nrand = 100000, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_nb_+3A_rho_nb">rho_nb</code></td>
<td>
<p>a <code>k_nb x k_nb</code> matrix of target correlations ordered 1st regular and 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_nb_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr_nb_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr_nb_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_nb_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_nb_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>k_nb x k_nb</code> intermediate correlation matrix for the Negative Binomial variables
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+intercorr_pois">intercorr_pois</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr_pois">intercorr_pois</a></code>, <code><a href="#topic+intercorr_pois_nb">intercorr_pois_nb</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_pois'>Calculate Intermediate MVN Correlation for Poisson Variables: Correlation Method 1</h2><span id='topic+intercorr_pois'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_pois x k_pois</code> intermediate matrix of correlations for the
Poisson variables using the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>). The intermediate correlation between Z1 and Z2
(the standard normal variables used to generate the Poisson variables Y1 and Y2 via the inverse CDF method) is
calculated using a logarithmic transformation of the target correlation.  First, the upper and lower Frechet-Hoeffding bounds
(mincor, maxcor) on <code class="reqn">\rho_{Y1, Y2}</code> are simulated.  Then the intermediate correlation is found as follows:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Z1, Z2} = \frac{1}{b} * log(\frac{\rho_{Y1, Y2} - c}{a}),</code>
</p>

<p>where <code class="reqn">a = -(maxcor * mincor)/(maxcor + mincor)</code>, <code class="reqn">b = log((maxcor + a)/a)</code>, and <code class="reqn">c = -a</code>.
The function adapts code from Amatya &amp; Demirtas' (2016) package <code><a href="PoisNor.html#topic+PoisNor-package">PoisNor-package</a></code> by:
</p>
<p>1) allowing specifications for the number of random variates and the seed for reproducibility
</p>
<p>2) providing the following checks: if <code>Sigma_(Z1, Z2)</code> &gt; 1, <code>Sigma_(Z1, Z2)</code> is set to 1; if <code>Sigma_(Z1, Z2)</code> &lt; -1,
<code>Sigma_(Z1, Z2)</code> is set to -1
</p>
<p>3) simulating regular and zero-inflated Poisson variables.
</p>
<p>The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and <code><a href="#topic+corrvar">corrvar</a></code> and would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_pois(rho_pois = NULL, lam = NULL, p_zip = 0, nrand = 100000,
  seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_pois_+3A_rho_pois">rho_pois</code></td>
<td>
<p>a <code>k_pois x k_pois</code> matrix of target correlations ordered 1st regular and 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_pois_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr_pois_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_pois_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_pois_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>k_pois x k_pois</code> intermediate correlation matrix for the Poisson variables
</p>


<h3>References</h3>

<p>Amatya A &amp; Demirtas H (2015). Simultaneous generation of multivariate mixed data with Poisson and normal marginals.
Journal of Statistical Computation and Simulation, 85(15):3129-39. doi: <a href="http://doi.org/10.1080/00949655.2014.953534">10.1080/00949655.2014.953534</a>.
</p>
<p>Demirtas H &amp; Hedeker D (2011). A practical way for computing approximate lower and upper correlation bounds.
American Statistician, 65(2):104-109.
</p>
<p>Frechet M (1951). Sur les tableaux de correlation dont les marges sont donnees.  Ann. l'Univ. Lyon SectA, 14:53-77.
</p>
<p>Hoeffding W. Scale-invariant correlation theory. In: Fisher NI, Sen PK, editors. The collected works of Wassily Hoeffding.
New York: Springer-Verlag; 1994. p. 57-107.
</p>
<p>Yahav I &amp; Shmueli G (2012). On Generating Multivariate Poisson Data in Management Science Applications. Applied Stochastic
Models in Business and Industry, 28(1):91-102. doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr_nb">intercorr_nb</a></code>, <code><a href="#topic+intercorr_pois_nb">intercorr_pois_nb</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr_pois_nb'>Calculate Intermediate MVN Correlation for Poisson - Negative Binomial Variables: Correlation Method 1</h2><span id='topic+intercorr_pois_nb'></span>

<h3>Description</h3>

<p>This function calculates a <code>k_pois x k_nb</code> intermediate matrix of correlations for the
Poisson and Negative Binomial variables by extending the method of Yahav &amp; Shmueli (2012, doi: <a href="http://doi.org/10.1002/asmb.901">10.1002/asmb.901</a>). The intermediate
correlation between Z1 and Z2 (the standard normal variables used to generate the Poisson and Negative Binomial variables Y1 and Y2
via the inverse CDF method) is calculated using a logarithmic transformation of the target correlation.  First, the upper and lower
Frechet-Hoeffding bounds (mincor, maxcor) on <code class="reqn">\rho_{Y1, Y2}</code> are simulated.  Then the intermediate correlation is found as follows:
</p>
<p style="text-align: center;"><code class="reqn">\rho_{Z1, Z2} = \frac{1}{b} * log(\frac{\rho_{Y1, Y2} - c}{a}),</code>
</p>

<p>where <code class="reqn">a = -(maxcor * mincor)/(maxcor + mincor)</code>, <code class="reqn">b = log((maxcor + a)/a)</code>, and <code class="reqn">c = -a</code>.
The function adapts code from Amatya &amp; Demirtas' (2016) package <code><a href="PoisNor.html#topic+PoisNor-package">PoisNor-package</a></code> by:
</p>
<p>1) allowing specifications for the number of random variates and the seed for reproducibility
</p>
<p>2) providing the following checks: if <code>Sigma_(Z1, Z2)</code> &gt; 1, <code>Sigma_(Z1, Z2)</code> is set to 1; if <code>Sigma_(Z1, Z2)</code> &lt; -1,
<code>Sigma_(Z1, Z2)</code> is set to -1
</p>
<p>3) simulating regular and zero-inflated Poisson and Negative Binomial variables.
</p>
<p>The function is used in <code><a href="#topic+intercorr">intercorr</a></code> and <code><a href="#topic+corrvar">corrvar</a></code> and would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr_pois_nb(rho_pois_nb = NULL, lam = NULL, p_zip = 0,
  size = NULL, mu = NULL, p_zinb = 0, nrand = 100000, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr_pois_nb_+3A_rho_pois_nb">rho_pois_nb</code></td>
<td>
<p>a <code>k_pois x k_nb</code> matrix of target correlations; order of each type should be 1st regular, 2nd zero-inflated</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_nrand">nrand</code></td>
<td>
<p>the number of random numbers to generate in calculating the bound (default = 10000)</p>
</td></tr>
<tr><td><code id="intercorr_pois_nb_+3A_seed">seed</code></td>
<td>
<p>the seed used in random number generation (default = 1234)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the <code>k_pois x k_nb</code> intermediate correlation matrix whose rows represent the <code>k_pois</code> Poisson variables and
columns represent the <code>k_nb</code> Negative Binomial variables
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+intercorr_pois">intercorr_pois</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr_pois">intercorr_pois</a></code>, <code><a href="#topic+intercorr_nb">intercorr_nb</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>
</p>

<hr>
<h2 id='intercorr2'>Calculate Intermediate MVN Correlation for Ordinal, Continuous, Poisson, or Negative Binomial Variables: Correlation Method 2</h2><span id='topic+intercorr2'></span>

<h3>Description</h3>

<p>This function calculates a <code>k x k</code> intermediate matrix of correlations, where <code>k = k_cat + k_cont +</code>
<code>k_pois + k_nb</code>, to be used in simulating variables with <code><a href="#topic+corrvar2">corrvar2</a></code>.  The <code>k_cont</code> includes regular continuous variables
and components of continuous mixture variables.  The ordering of the variables must be
ordinal, continuous non-mixture, components of continuous mixture variables, regular Poisson, zero-inflated Poisson, regular Negative
Binomial (NB), and zero-inflated NB (note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_pois</code>, and/or <code>k_nb</code> to be 0).
There are no parameter input checks in order to decrease simulation time.  All inputs should be checked prior to simulation with
<code><a href="#topic+validpar">validpar</a></code>.  There is a message given if the calculated
intermediate correlation matrix <code>Sigma</code> is not positive-definite because it may not be possible to find a MVN correlation
matrix that will produce the desired marginal distributions.  This function is called by the simulation function
<code><a href="#topic+corrvar2">corrvar2</a></code>, and would only be used separately if the user wants to first find the intermediate correlation matrix.
This matrix <code>Sigma</code> can be used as an input to <code><a href="#topic+corrvar2">corrvar2</a></code>.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for information about calculations by variable pair type and the differences between
this function and <code><a href="#topic+intercorr">intercorr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intercorr2(k_cat = 0, k_cont = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), constants = NULL,
  marginal = list(), support = list(), lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, pois_eps = 0.0001,
  nb_eps = 0.0001, rho = NULL, epsilon = 0.001, maxit = 1000,
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intercorr2_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables and components of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> continuous variables.  &quot;Fleishman&quot; uses a third-order polynomial transformation
and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_constants">constants</code></td>
<td>
<p>a matrix with <code>k_cont</code> rows, each a vector of constants c0, c1, c2, c3 (if <code>method</code> = &quot;Fleishman&quot;) or
c0, c1, c2, c3, c4, c5 (if <code>method</code> = &quot;Polynomial&quot;) like that returned by <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code></p>
</td></tr>
<tr><td><code id="intercorr2_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1; default = list())</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_support">support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of containing the r
ordered support values; if not provided (i.e. <code>support</code> = list()), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="intercorr2_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_pois_eps">pois_eps</code></td>
<td>
<p>a vector of length <code>k_pois</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_nb_eps">nb_eps</code></td>
<td>
<p>a vector of length <code>k_nb</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="intercorr2_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="intercorr2_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the pairwise correlations (default = 0.001)
in the calculation of ordinal intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code></p>
</td></tr>
<tr><td><code id="intercorr2_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) in the calculation of ordinal
intermediate correlations with <code><a href="#topic+ord_norm">ord_norm</a></code></p>
</td></tr>
<tr><td><code id="intercorr2_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints simulation messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the intermediate MVN correlation matrix
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrvar2">corrvar2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma1 &lt;- intercorr2(k_cat = 1, k_cont = 1, method = "Polynomial",
  constants = matrix(c(0, 1, 0, 0, 0, 0), 1, 6), marginal = list(0.3),
  support = list(c(0, 1)), rho = matrix(c(1, 0.4, 0.4, 1), 2, 2),
  quiet = TRUE)
## Not run: 

# 1 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
# The defaults of pois_eps &lt;- nb_eps &lt;- 0.0001 are used.

# Mixture of N(-2, 1) and N(2, 1)
constants &lt;- rbind(c(0, 1, 0, 0, 0, 0), c(0, 1, 0, 0, 0, 0))

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 2
Rey &lt;- matrix(0.35, 5, 5)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0

Sigma2 &lt;- intercorr2(k_cat, k_cont, k_pois, k_nb, "Polynomial", constants,
  marginal, support, lam, p_zip, size, prob, mu = NULL, p_zinb, rho = Rey)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxcount_support'>Calculate Maximum Support Value for Count Variables: Correlation Method 2</h2><span id='topic+maxcount_support'></span>

<h3>Description</h3>

<p>This function calculates the maximum support value for count variables by extending the method of Barbiero &amp;
Ferrari (2015, doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>) to include regular and zero-inflated Poisson and Negative Binomial variables.  In order for
count variables to be treated as ordinal in the calculation of the intermediate MVN correlation matrix, their infinite support must
be truncated (made finite).  This is done by setting the total cumulative probability equal to 1 - a small user-specified value
(<code>pois_eps</code> or <code>nb_eps</code>).  The maximum support value equals the inverse CDF applied to this result.  The truncation values
may differ for each variable.  The function is used in <code><a href="#topic+intercorr2">intercorr2</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code> and
would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxcount_support(k_pois = 0, k_nb = 0, lam = NULL, p_zip = 0,
  size = NULL, prob = NULL, mu = NULL, p_zinb = 0, pois_eps = NULL,
  nb_eps = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxcount_support_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of Poisson variables</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of Negative Binomial variables</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the regular and zero-inflated Poisson variables (see <code>stats::dpois</code>);
the order should be 1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_pois_eps">pois_eps</code></td>
<td>
<p>a vector of length <code>k_pois</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="maxcount_support_+3A_nb_eps">nb_eps</code></td>
<td>
<p>a vector of length <code>k_nb</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with <code>k_pois + k_nb</code> rows; the column names are:
</p>
<p><code>Distribution</code> Poisson or Negative Binomial
</p>
<p><code>Number</code> the variable index
</p>
<p><code>Max</code> the maximum support value
</p>


<h3>References</h3>

<p>Barbiero A &amp; Ferrari PA (2015). Simulation of correlated Poisson variables. Applied Stochastic Models in
Business and Industry, 31:669-80. doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercorr2">intercorr2</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>

<hr>
<h2 id='norm_ord'>Calculate Correlations of Ordinal Variables Obtained from Discretizing Normal Variables</h2><span id='topic+norm_ord'></span>

<h3>Description</h3>

<p>This function calculates the correlation of ordinal variables (or variables treated as &quot;ordinal&quot;), with given marginal
distributions, obtained from discretizing standard normal variables with a specified correlation matrix.  The function modifies
Barbiero &amp; Ferrari's <code><a href="GenOrd.html#topic+contord">contord</a></code> function in <code><a href="GenOrd.html#topic+GenOrd-package">GenOrd-package</a></code>.  It uses
<code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code> function from the <strong>mvtnorm</strong> package to calculate multivariate normal cumulative probabilities
defined by the normal quantiles obtained at <code>marginal</code> and the supplied correlation matrix <code>Sigma</code>.  This function is used
within <code><a href="#topic+ord_norm">ord_norm</a></code> and would not ordinarily be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_ord(marginal = list(), Sigma = NULL, support = list(),
  Spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_ord_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to the number of variables; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td></tr>
<tr><td><code id="norm_ord_+3A_sigma">Sigma</code></td>
<td>
<p>the correlation matrix of the multivariate standard normal variable</p>
</td></tr>
<tr><td><code id="norm_ord_+3A_support">support</code></td>
<td>
<p>a list of length equal to the number of variables; the i-th element is a vector of containing the r
ordered support values; if not provided (i.e. support = list()), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="norm_ord_+3A_spearman">Spearman</code></td>
<td>
<p>if TRUE, Spearman's correlations are used (and support is not required); if FALSE (default) Pearson's correlations
are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation matrix of the ordinal variables
</p>


<h3>References</h3>

<p>Please see references in <code><a href="#topic+ord_norm">ord_norm</a></code>.
</p>
<p>Alan Genz, Frank Bretz, Tetsuhisa Miwa, Xuefei Mi, Friedrich Leisch, Fabian Scheipl, Torsten Hothorn (2018).
mvtnorm: Multivariate Normal and t Distributions. R package version 1.0-8. <a href="https://CRAN.R-project.org/package=mvtnorm">https://CRAN.R-project.org/package=mvtnorm</a>.
</p>
<p>Alan Genz, Frank Bretz (2009), Computation of Multivariate Normal and t Probabilities. Lecture Notes in Statistics, Vol. 195.,
Springer-Verlag, Heidelberg. ISBN 978-3-642-01688-2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ord_norm">ord_norm</a></code>
</p>

<hr>
<h2 id='ord_norm'>Calculate Intermediate MVN Correlation to Generate Variables Treated as Ordinal</h2><span id='topic+ord_norm'></span>

<h3>Description</h3>

<p>This function calculates the intermediate MVN correlation needed to generate a variable described by
a discrete marginal distribution and associated finite support.  This includes ordinal (<code class="reqn">r \ge 2</code> categories) variables
or variables that are treated as ordinal (i.e. count variables in the Barbiero &amp; Ferrari, 2015 method used in
<code><a href="#topic+corrvar2">corrvar2</a></code>, doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>).  The function is a modification of Barbiero &amp; Ferrari's
<code><a href="GenOrd.html#topic+ordcont">ordcont</a></code> function in <code><a href="GenOrd.html#topic+GenOrd-package">GenOrd-package</a></code>.
It works by setting the intermediate MVN correlation equal to the target correlation and updating each intermediate pairwise
correlation until the final pairwise correlation is within <code>epsilon</code> of the target correlation or the maximum number of
iterations has been reached.  This function uses <code><a href="#topic+norm_ord">norm_ord</a></code> to calculate the ordinal correlation obtained
from discretizing the normal variables generated from the intermediate correlation matrix.  The <code><a href="GenOrd.html#topic+ordcont">ordcont</a></code> has been modified in the following ways:
</p>
<p>1) the initial correlation check has been removed because this is done within the simulation functions
</p>
<p>2) the final positive-definite check has been removed
</p>
<p>3) the intermediate correlation update function was changed to accommodate more situations
</p>
<p>This function would not ordinarily be called by the user.  Note that this will return a matrix that is NOT positive-definite
because this is corrected for in the simulation functions <code><a href="#topic+corrvar">corrvar</a></code> and <code><a href="#topic+corrvar2">corrvar2</a></code>
using the method of Higham (2002) and the <code><a href="Matrix.html#topic+nearPD">nearPD</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ord_norm(marginal = list(), rho = NULL, support = list(),
  epsilon = 0.001, maxit = 1000, Spearman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ord_norm_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to the number of variables; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1)</p>
</td></tr>
<tr><td><code id="ord_norm_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix</p>
</td></tr>
<tr><td><code id="ord_norm_+3A_support">support</code></td>
<td>
<p>a list of length equal to the number of variables; the i-th element is a vector of containing the r
ordered support values; if not provided (i.e. support = list()), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="ord_norm_+3A_epsilon">epsilon</code></td>
<td>
<p>the maximum acceptable error between the final and target pairwise correlations (default = 0.001);
smaller values take more time</p>
</td></tr>
<tr><td><code id="ord_norm_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations to use (default = 1000) to find the intermediate correlation; the
correction loop stops when either the iteration number passes <code>maxit</code> or <code>epsilon</code> is reached</p>
</td></tr>
<tr><td><code id="ord_norm_+3A_spearman">Spearman</code></td>
<td>
<p>if TRUE, Spearman's correlations are used (and support is not required); if FALSE (default) Pearson's correlations
are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<p><code>SigmaC</code> the intermediate MVN correlation matrix
</p>
<p><code>rho0</code> the calculated final correlation matrix generated from <code>SigmaC</code>
</p>
<p><code>rho</code> the target final correlation matrix
</p>
<p><code>niter</code> a matrix containing the number of iterations required for each variable pair
</p>
<p><code>maxerr</code> the maximum final error between the final and target correlation matrices
</p>


<h3>References</h3>

<p>Barbiero A, Ferrari PA (2015). Simulation of correlated Poisson variables. Applied Stochastic Models
in Business and Industry, 31:669-80. doi: <a href="http://doi.org/10.1002/asmb.2072">10.1002/asmb.2072</a>.
</p>
<p>Barbiero A, Ferrari PA (2015). GenOrd: Simulation of Discrete Random Variables with Given
Correlation Matrix and Marginal Distributions. R package version 1.4.0. <br />
<a href="https://CRAN.R-project.org/package=GenOrd">https://CRAN.R-project.org/package=GenOrd</a>
</p>
<p>Ferrari PA, Barbiero A (2012). Simulating ordinal data, Multivariate Behavioral Research, 47(4):566-589. doi: <a href="http://doi.org/10.1080/00273171.2012.692630">10.1080/00273171.2012.692630</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corrvar">corrvar</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>, <code><a href="#topic+norm_ord">norm_ord</a></code>,
<code><a href="#topic+intercorr">intercorr</a></code>, <code><a href="#topic+intercorr2">intercorr2</a></code>
</p>

<hr>
<h2 id='plot_simpdf_theory'>Plot Simulated Probability Density Function and Target PDF by Distribution Name or Function for Continuous or Count Variables</h2><span id='topic+plot_simpdf_theory'></span>

<h3>Description</h3>

<p>This plots the PDF of simulated continuous or count (regular or zero-inflated, Poisson or Negative Binomial) data and
overlays the target PDF (if <code>overlay</code> = TRUE), which is specified by distribution name (plus up to 4 parameters) or PDF
function <code>fx</code> (plus support bounds).  If a continuous target distribution is provided (<code>cont_var = TRUE</code>), the simulated
data <code class="reqn">y</code> is scaled and then transformed (i.e. <code class="reqn">y = sigma * scale(y) + mu</code>) so that it has the same mean (<code class="reqn">mu</code>) and
variance (<code class="reqn">sigma^2</code>) as the target distribution.  The PDF's of continuous variables are shown as lines (using
<code><a href="ggplot2.html#topic+geom_density">geom_density</a></code> and <code>ggplot2::geom_line</code>).  It works for valid or invalid power method PDF's.
The PMF's of count variables are shown as vertical bar graphs (using <code>ggplot2::geom_col</code>).  The function returns a
<code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> object so the user can save it or modify it as necessary.  The graph parameters
(i.e. <code>title</code>, <code>sim_color</code>, <code>sim_lty</code>, <code>sim_size</code>, <code>target_color</code>, <code>target_lty</code>, <code>target_size</code>,
<code>legend.position</code>, <code>legend.justification</code>, <code>legend.text.size</code>, <code>title.text.size</code>,
<code>axis.text.size</code>, and <code>axis.title.size</code>) are inputs to the <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> functions so information about
valid inputs can be obtained from that package's documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simpdf_theory(sim_y, title = "Simulated Probability Density Function",
  ylower = NULL, yupper = NULL, sim_color = "dark blue", sim_lty = 1,
  sim_size = 1, col_width = 0.5, overlay = TRUE, cont_var = TRUE,
  target_color = "dark green", target_lty = 2, target_size = 1,
  Dist = c("Benini", "Beta", "Beta-Normal", "Birnbaum-Saunders", "Chisq",
  "Dagum", "Exponential", "Exp-Geometric", "Exp-Logarithmic", "Exp-Poisson",
  "F", "Fisk", "Frechet", "Gamma", "Gaussian", "Gompertz", "Gumbel",
  "Kumaraswamy", "Laplace", "Lindley", "Logistic", "Loggamma", "Lognormal",
  "Lomax", "Makeham", "Maxwell", "Nakagami", "Paralogistic", "Pareto", "Perks",
  "Rayleigh", "Rice", "Singh-Maddala", "Skewnormal", "t", "Topp-Leone",
  "Triangular", "Uniform", "Weibull", "Poisson", "Negative_Binomial"),
  params = NULL, fx = NULL, lower = NULL, upper = NULL,
  legend.position = c(0.975, 0.9), legend.justification = c(1, 1),
  legend.text.size = 10, title.text.size = 15, axis.text.size = 10,
  axis.title.size = 13)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_simpdf_theory_+3A_sim_y">sim_y</code></td>
<td>
<p>a vector of simulated data</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_title">title</code></td>
<td>
<p>the title for the graph (default = &quot;Simulated Probability Density Function&quot;)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_ylower">ylower</code></td>
<td>
<p>the lower y value to use in the plot (default = NULL, uses minimum simulated y value) on the x-axis</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_yupper">yupper</code></td>
<td>
<p>the upper y value (default = NULL, uses maximum simulated y value) on the x-axis</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_sim_color">sim_color</code></td>
<td>
<p>the line color for the simulated PDF (or column fill color in the case of
<code>Dist</code> = &quot;Poisson&quot; or &quot;Negative_Binomial&quot;)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_sim_lty">sim_lty</code></td>
<td>
<p>the line type for the simulated PDF (default = 1, solid line)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_sim_size">sim_size</code></td>
<td>
<p>the line width for the simulated PDF</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_col_width">col_width</code></td>
<td>
<p>width of column for simulated/target PMF of count variables (default = 0.5)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_overlay">overlay</code></td>
<td>
<p>if TRUE (default), the target distribution is also plotted given either a distribution name (and parameters)
or PDF function fx (with bounds = ylower, yupper)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_cont_var">cont_var</code></td>
<td>
<p>TRUE (default) for continuous variables, FALSE for count variables</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_target_color">target_color</code></td>
<td>
<p>the line color for the target PDF (or column fill color in the case of
<code>Dist</code> = &quot;Poisson&quot; or &quot;Negative_Binomial&quot;)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_target_lty">target_lty</code></td>
<td>
<p>the line type for the target PDF (default = 2, dashed line)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_target_size">target_size</code></td>
<td>
<p>the line width for the target PDF</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_dist">Dist</code></td>
<td>
<p>name of the distribution. The possible values are: &quot;Benini&quot;, &quot;Beta&quot;, &quot;Beta-Normal&quot;, &quot;Birnbaum-Saunders&quot;, &quot;Chisq&quot;,
&quot;Exponential&quot;, &quot;Exp-Geometric&quot;, &quot;Exp-Logarithmic&quot;, &quot;Exp-Poisson&quot;, &quot;F&quot;, &quot;Fisk&quot;, &quot;Frechet&quot;, &quot;Gamma&quot;, &quot;Gaussian&quot;, &quot;Gompertz&quot;,
&quot;Gumbel&quot;, &quot;Kumaraswamy&quot;, &quot;Laplace&quot;, &quot;Lindley&quot;, &quot;Logistic&quot;, <br />&quot;Loggamma&quot;, &quot;Lognormal&quot;, &quot;Lomax&quot;, &quot;Makeham&quot;, &quot;Maxwell&quot;,
&quot;Nakagami&quot;, &quot;Paralogistic&quot;, &quot;Pareto&quot;, &quot;Perks&quot;, &quot;Rayleigh&quot;, &quot;Rice&quot;, &quot;Singh-Maddala&quot;, <br />&quot;Skewnormal&quot;, &quot;t&quot;, &quot;Topp-Leone&quot;, &quot;Triangular&quot;,
&quot;Uniform&quot;, &quot;Weibull&quot;, &quot;Poisson&quot;, and &quot;Negative_Binomial&quot;.
Please refer to the documentation for each package (either <code><a href="stats.html#topic+stats-package">stats-package</a></code>, <code><a href="VGAM.html#topic+VGAM-package">VGAM-package</a></code>, or
<code><a href="triangle.html#topic+triangle">triangle</a></code>) for information on appropriate parameter inputs.</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_params">params</code></td>
<td>
<p>a vector of parameters (up to 4) for the desired distribution (keep NULL if <code>fx</code> supplied instead); for
Poisson variables, must be lambda (mean) and the probability of a structural zero (use 0 for regular Poisson variables); for
Negative Binomial variables, must be size, mean and the probability of a structural zero (use 0 for regular NB variables)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_fx">fx</code></td>
<td>
<p>a PDF input as a function of x only, i.e. <code>fx = function(x) 0.5 * (x - 1)^2</code>; must return a scalar
(keep NULL if <code>Dist</code> supplied instead)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_lower">lower</code></td>
<td>
<p>the lower support bound for <code>fx</code></p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_upper">upper</code></td>
<td>
<p>the upper support bound for <code>fx</code></p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of the legend</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_legend.justification">legend.justification</code></td>
<td>
<p>the justification of the legend</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_legend.text.size">legend.text.size</code></td>
<td>
<p>the size of the legend labels</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_title.text.size">title.text.size</code></td>
<td>
<p>the size of the plot title</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>the size of the axes text (tick labels)</p>
</td></tr>
<tr><td><code id="plot_simpdf_theory_+3A_axis.title.size">axis.title.size</code></td>
<td>
<p>the size of the axes titles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> object.
</p>


<h3>References</h3>

<p>Please see the references for <code><a href="#topic+plot_simtheory">plot_simtheory</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+calc_theory">calc_theory</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using normal mixture variable from contmixvar1 example
Nmix &lt;- contmixvar1(n = 1000, "Polynomial", means = 0, vars = 1,
  mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2), mix_sigmas = c(1, 1),
  mix_skews = c(0, 0), mix_skurts = c(0, 0), mix_fifths = c(0, 0),
  mix_sixths = c(0, 0))
plot_simpdf_theory(Nmix$Y_mix[, 1],
  title = "Mixture of Normal Distributions",
  fx = function(x) 0.4 * dnorm(x, -2, 1) + 0.6 * dnorm(x, 2, 1),
  lower = -5, upper = 5)
## Not run: 
# Mixture of Beta(6, 3), Beta(4, 1.5), and Beta(10, 20)
Stcum1 &lt;- calc_theory("Beta", c(6, 3))
Stcum2 &lt;- calc_theory("Beta", c(4, 1.5))
Stcum3 &lt;- calc_theory("Beta", c(10, 20))
mix_pis &lt;- c(0.5, 0.2, 0.3)
mix_mus &lt;- c(Stcum1[1], Stcum2[1], Stcum3[1])
mix_sigmas &lt;- c(Stcum1[2], Stcum2[2], Stcum3[2])
mix_skews &lt;- c(Stcum1[3], Stcum2[3], Stcum3[3])
mix_skurts &lt;- c(Stcum1[4], Stcum2[4], Stcum3[4])
mix_fifths &lt;- c(Stcum1[5], Stcum2[5], Stcum3[5])
mix_sixths &lt;- c(Stcum1[6], Stcum2[6], Stcum3[6])
mix_Six &lt;- list(seq(0.01, 10, 0.01), c(0.01, 0.02, 0.03),
  seq(0.01, 10, 0.01))
Bstcum &lt;- calc_mixmoments(mix_pis, mix_mus, mix_sigmas, mix_skews,
  mix_skurts, mix_fifths, mix_sixths)
Bmix &lt;- contmixvar1(n = 10000, "Polynomial", Bstcum[1], Bstcum[2]^2,
  mix_pis, mix_mus, mix_sigmas, mix_skews, mix_skurts, mix_fifths,
  mix_sixths, mix_Six)
plot_simpdf_theory(Bmix$Y_mix[, 1], title = "Mixture of Beta Distributions",
  fx = function(x) mix_pis[1] * dbeta(x, 6, 3) + mix_pis[2] *
    dbeta(x, 4, 1.5) + mix_pis[3] * dbeta(x, 10, 20), lower = 0, upper = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_simtheory'>Plot Simulated Data and Target Distribution Data by Name or Function for Continuous or Count Variables</h2><span id='topic+plot_simtheory'></span>

<h3>Description</h3>

<p>This plots simulated continuous or count (regular or zero-inflated, Poisson or Negative Binomial) data and overlays data
(if <code>overlay</code> = TRUE) generated from the target distribution.  The target is specified by name (plus up to 4 parameters) or
PDF function <code>fx</code> (plus support bounds).  Due to the integration involved in finding the CDF from the PDF supplied by
<code>fx</code>, only continuous <code>fx</code> may be supplied.  Both are plotted as histograms (using <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>).
If a continuous target distribution is specified (<code>cont_var = TRUE</code>), the simulated data <code class="reqn">y</code> is
scaled and then transformed (i.e. <code class="reqn">y = sigma * scale(y) + mu</code>) so that it has the same mean (<code class="reqn">mu</code>) and variance
(<code class="reqn">sigma^2</code>) as the target distribution.  It works for valid or invalid power method PDF's.  It returns a
<code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> object so the user can save it or
modify it as necessary.  The graph parameters (i.e. <code>title</code>, <code>sim_color</code>, <code>target_color</code>,
<code>legend.position</code>, <code>legend.justification</code>, <code>legend.text.size</code>, <code>title.text.size</code>,
<code>axis.text.size</code>, and <code>axis.title.size</code>) are inputs to the <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> functions so information about
valid inputs can be obtained from that package's documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_simtheory(sim_y, title = "Simulated Data Values", ylower = NULL,
  yupper = NULL, sim_color = "dark blue", overlay = TRUE,
  cont_var = TRUE, target_color = "dark green", binwidth = NULL,
  nbins = 100, Dist = c("Benini", "Beta", "Beta-Normal",
  "Birnbaum-Saunders", "Chisq", "Dagum", "Exponential", "Exp-Geometric",
  "Exp-Logarithmic", "Exp-Poisson", "F", "Fisk", "Frechet", "Gamma", "Gaussian",
  "Gompertz", "Gumbel", "Kumaraswamy", "Laplace", "Lindley", "Logistic",
  "Loggamma", "Lognormal", "Lomax", "Makeham", "Maxwell", "Nakagami",
  "Paralogistic", "Pareto", "Perks", "Rayleigh", "Rice", "Singh-Maddala",
  "Skewnormal", "t", "Topp-Leone", "Triangular", "Uniform", "Weibull",
  "Poisson", "Negative_Binomial"), params = NULL, fx = NULL, lower = NULL,
  upper = NULL, seed = 1234, sub = 1000, legend.position = c(0.975,
  0.9), legend.justification = c(1, 1), legend.text.size = 10,
  title.text.size = 15, axis.text.size = 10, axis.title.size = 13)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_simtheory_+3A_sim_y">sim_y</code></td>
<td>
<p>a vector of simulated data</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_title">title</code></td>
<td>
<p>the title for the graph (default = &quot;Simulated Data Values&quot;)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_ylower">ylower</code></td>
<td>
<p>the lower y value to use in the plot (default = NULL, uses minimum simulated y value) on the y-axis</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_yupper">yupper</code></td>
<td>
<p>the upper y value (default = NULL, uses maximum simulated y value) on the y-axis</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_sim_color">sim_color</code></td>
<td>
<p>the histogram fill color for the simulated variable (default = &quot;dark blue&quot;)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_overlay">overlay</code></td>
<td>
<p>if TRUE (default), the target distribution is also plotted given either a distribution name (and parameters)
or PDF function fx (with support bounds = lower, upper)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_cont_var">cont_var</code></td>
<td>
<p>TRUE (default) for continuous variables, FALSE for count variables</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_target_color">target_color</code></td>
<td>
<p>the histogram fill color for the target distribution (default = &quot;dark green&quot;)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_binwidth">binwidth</code></td>
<td>
<p>the width of bins to use when creating the histograms (default = NULL)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_nbins">nbins</code></td>
<td>
<p>the number of bins to use when creating the histograms (default = 100); overridden by <code>binwidth</code></p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_dist">Dist</code></td>
<td>
<p>name of the distribution. The possible values are: &quot;Benini&quot;, &quot;Beta&quot;, &quot;Beta-Normal&quot;, &quot;Birnbaum-Saunders&quot;, &quot;Chisq&quot;,
&quot;Exponential&quot;, &quot;Exp-Geometric&quot;, &quot;Exp-Logarithmic&quot;, &quot;Exp-Poisson&quot;, &quot;F&quot;, &quot;Fisk&quot;, &quot;Frechet&quot;, &quot;Gamma&quot;, &quot;Gaussian&quot;, &quot;Gompertz&quot;,
&quot;Gumbel&quot;, &quot;Kumaraswamy&quot;, &quot;Laplace&quot;, &quot;Lindley&quot;, &quot;Logistic&quot;, <br />&quot;Loggamma&quot;, &quot;Lognormal&quot;, &quot;Lomax&quot;, &quot;Makeham&quot;, &quot;Maxwell&quot;,
&quot;Nakagami&quot;, &quot;Paralogistic&quot;, &quot;Pareto&quot;, &quot;Perks&quot;, &quot;Rayleigh&quot;, &quot;Rice&quot;, &quot;Singh-Maddala&quot;, <br />&quot;Skewnormal&quot;, &quot;t&quot;, &quot;Topp-Leone&quot;, &quot;Triangular&quot;,
&quot;Uniform&quot;, &quot;Weibull&quot;, &quot;Poisson&quot;, and &quot;Negative_Binomial&quot;.
Please refer to the documentation for each package (either <code><a href="stats.html#topic+stats-package">stats-package</a></code>, <code><a href="VGAM.html#topic+VGAM-package">VGAM-package</a></code>, or
<code><a href="triangle.html#topic+triangle">triangle</a></code>) for information on appropriate parameter inputs.</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_params">params</code></td>
<td>
<p>a vector of parameters (up to 4) for the desired distribution (keep NULL if <code>fx</code> supplied instead); for
Poisson variables, must be lambda (mean) and the probability of a structural zero (use 0 for regular Poisson variables); for
Negative Binomial variables, must be size, mean and the probability of a structural zero (use 0 for regular NB variables)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_fx">fx</code></td>
<td>
<p>a PDF input as a function of x only, i.e. <code>fx = function(x) 0.5 * (x - 1)^2</code>; must return a scalar
(keep NULL if <code>Dist</code> supplied instead)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_lower">lower</code></td>
<td>
<p>the lower support bound for a supplied <code>fx</code>, else keep NULL (note: if an error is thrown from <code>uniroot</code>,
try a slightly higher lower bound; i.e., 0.0001 instead of 0)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_upper">upper</code></td>
<td>
<p>the upper support bound for a supplied <code>fx</code>, else keep NULL (note: if an error is thrown from <code>uniroot</code>,
try a lower upper bound; i.e., 100000 instead of Inf)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_sub">sub</code></td>
<td>
<p>the number of subdivisions to use in the integration to calculate the CDF from <code>fx</code>; if no result, try increasing
sub (requires longer computation time; default = 1000)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_legend.position">legend.position</code></td>
<td>
<p>the position of the legend</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_legend.justification">legend.justification</code></td>
<td>
<p>the justification of the legend</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_legend.text.size">legend.text.size</code></td>
<td>
<p>the size of the legend labels</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_title.text.size">title.text.size</code></td>
<td>
<p>the size of the plot title</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>the size of the axes text (tick labels)</p>
</td></tr>
<tr><td><code id="plot_simtheory_+3A_axis.title.size">axis.title.size</code></td>
<td>
<p>the size of the axes titles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2-package</a></code> object.
</p>


<h3>References</h3>

<p>Carnell R (2017). triangle: Provides the Standard Distribution Functions for the Triangle Distribution. R package version 0.11.
<a href="https://CRAN.R-project.org/package=triangle">https://CRAN.R-project.org/package=triangle</a>.
</p>
<p>Fialkowski AC (2018). SimMultiCorrData: Simulation of Correlated Data with Multiple Variable Types. R package version 0.2.2.
<a href="https://CRAN.R-project.org/package=SimMultiCorrData">https://CRAN.R-project.org/package=SimMultiCorrData</a>.
</p>
<p>Headrick TC, Sheng Y, &amp; Hodis FA (2007). Numerical Computing and Graphics for the Power Method Transformation Using
Mathematica. Journal of Statistical Software, 19(3):1-17. <br /> doi: <a href="http://doi.org/10.18637/jss.v019.i03">10.18637/jss.v019.i03</a>.
</p>
<p>Wickham H. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2009.
</p>
<p>Yee TW (2018). VGAM: Vector Generalized Linear and Additive Models. R package version 1.0-5. <a href="https://CRAN.R-project.org/package=VGAM">https://CRAN.R-project.org/package=VGAM</a>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+calc_theory">calc_theory</a></code>,
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using normal mixture variable from contmixvar1 example
Nmix &lt;- contmixvar1(n = 1000, "Polynomial", means = 0, vars = 1,
  mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2), mix_sigmas = c(1, 1),
  mix_skews = c(0, 0), mix_skurts = c(0, 0), mix_fifths = c(0, 0),
  mix_sixths = c(0, 0))
plot_simtheory(Nmix$Y_mix[, 1], title = "Mixture of Normal Distributions",
  fx = function(x) 0.4 * dnorm(x, -2, 1) + 0.6 * dnorm(x, 2, 1),
  lower = -5, upper = 5)
## Not run: 
# Mixture of Beta(6, 3), Beta(4, 1.5), and Beta(10, 20)
Stcum1 &lt;- calc_theory("Beta", c(6, 3))
Stcum2 &lt;- calc_theory("Beta", c(4, 1.5))
Stcum3 &lt;- calc_theory("Beta", c(10, 20))
mix_pis &lt;- c(0.5, 0.2, 0.3)
mix_mus &lt;- c(Stcum1[1], Stcum2[1], Stcum3[1])
mix_sigmas &lt;- c(Stcum1[2], Stcum2[2], Stcum3[2])
mix_skews &lt;- c(Stcum1[3], Stcum2[3], Stcum3[3])
mix_skurts &lt;- c(Stcum1[4], Stcum2[4], Stcum3[4])
mix_fifths &lt;- c(Stcum1[5], Stcum2[5], Stcum3[5])
mix_sixths &lt;- c(Stcum1[6], Stcum2[6], Stcum3[6])
mix_Six &lt;- list(seq(0.01, 10, 0.01), c(0.01, 0.02, 0.03),
  seq(0.01, 10, 0.01))
Bstcum &lt;- calc_mixmoments(mix_pis, mix_mus, mix_sigmas, mix_skews,
  mix_skurts, mix_fifths, mix_sixths)
Bmix &lt;- contmixvar1(n = 10000, "Polynomial", Bstcum[1], Bstcum[2]^2,
  mix_pis, mix_mus, mix_sigmas, mix_skews, mix_skurts, mix_fifths,
  mix_sixths, mix_Six)
plot_simtheory(Bmix$Y_mix[, 1], title = "Mixture of Beta Distributions",
  fx = function(x) mix_pis[1] * dbeta(x, 6, 3) + mix_pis[2] *
    dbeta(x, 4, 1.5) + mix_pis[3] * dbeta(x, 10, 20), lower = 0, upper = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='rho_M1M2'>Approximate Correlation between Two Continuous Mixture Variables M1 and M2</h2><span id='topic+rho_M1M2'></span>

<h3>Description</h3>

<p>This function approximates the expected correlation between two continuous mixture variables <code class="reqn">M1</code> and <code class="reqn">M2</code> based on
their mixing proportions, component means, component standard deviations, and correlations between components across variables.
The equations can be found in the <strong>Expected Cumulants and Correlations for Continuous Mixture Variables</strong> vignette.  This
function can be used to see what combination of component correlations gives a desired correlation between <code class="reqn">M1</code> and <code class="reqn">M2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_M1M2(mix_pis = list(), mix_mus = list(), mix_sigmas = list(),
  p_M1M2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rho_M1M2_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length 2 with 1st component a vector of mixing probabilities that sum to 1 for component distributions of
<code class="reqn">M1</code> and likewise for 2nd component and <code class="reqn">M2</code></p>
</td></tr>
<tr><td><code id="rho_M1M2_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length 2 with 1st component a vector of means for component distributions of <code class="reqn">M1</code> and likewise for 2nd
component and <code class="reqn">M2</code></p>
</td></tr>
<tr><td><code id="rho_M1M2_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length 2 with 1st component a vector of standard deviations for component distributions of <code class="reqn">M1</code> and
likewise for 2nd component and <code class="reqn">M2</code></p>
</td></tr>
<tr><td><code id="rho_M1M2_+3A_p_m1m2">p_M1M2</code></td>
<td>
<p>a matrix of correlations with rows corresponding to <code class="reqn">M1</code> and columns corresponding to <code class="reqn">M2</code>; i.e.,
<code>p_M1M2[1, 2]</code> is the correlation between the 1st component of <code class="reqn">M1</code> and the 2nd component of <code class="reqn">M2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the expected correlation between M1 and M2
</p>


<h3>References</h3>

<p>Davenport JW, Bezder JC, &amp; Hathaway RJ (1988). Parameter Estimation for Finite Mixture Distributions.
Computers &amp; Mathematics with Applications, 15(10):819-28.
</p>
<p>Pearson RK (2011). Exploring Data in Engineering, the Sciences, and Medicine. In. New York: Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rho_M1Y">rho_M1Y</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># M1 is mixture of N(-2, 1) and N(2, 1);
# M2 is mixture of Logistic(0, 1), Chisq(4), and Beta(4, 1.5)
# pairwise correlation between components across M1 and M2 set to 0.35
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))
rho_M1M2(mix_pis = list(c(0.4, 0.6), c(0.3, 0.2, 0.5)),
  mix_mus = list(c(-2, 2), c(L[1], C[1], B[1])),
  mix_sigmas = list(c(1, 1), c(L[2], C[2], B[2])),
  p_M1M2 = matrix(0.35, 2, 3))

</code></pre>

<hr>
<h2 id='rho_M1Y'>Approximate Correlation between Continuous Mixture Variable M1 and Random Variable Y</h2><span id='topic+rho_M1Y'></span>

<h3>Description</h3>

<p>This function approximates the expected correlation between a continuous mixture variables <code class="reqn">M1</code> and another random
variable <code class="reqn">Y</code> based on the mixing proportions, component means, and component standard deviations of <code class="reqn">M1</code> and correlations
between components of <code class="reqn">M1</code> and <code class="reqn">Y</code>.  The equations can be found in the <strong>Expected Cumulants and Correlations for
Continuous Mixture Variables</strong> vignette.  This function can be used to see what combination of correlations between components
of <code class="reqn">M1</code> and <code class="reqn">Y</code> gives a desired correlation between <code class="reqn">M1</code> and <code class="reqn">Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_M1Y(mix_pis = NULL, mix_mus = NULL, mix_sigmas = NULL, p_M1Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rho_M1Y_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">M1</code></p>
</td></tr>
<tr><td><code id="rho_M1Y_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a vector of means for component distributions of <code class="reqn">M1</code></p>
</td></tr>
<tr><td><code id="rho_M1Y_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a vector of standard deviations for component distributions of <code class="reqn">M1</code></p>
</td></tr>
<tr><td><code id="rho_M1Y_+3A_p_m1y">p_M1Y</code></td>
<td>
<p>a vector of correlations between the components of <code class="reqn">M1</code> and <code class="reqn">Y</code>; i.e.,
<code>p_M1Y[1]</code> is the correlation between the 1st component of <code class="reqn">M1</code> and <code class="reqn">Y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the expected correlation between M1 and Y
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+rho_M1M2">rho_M1M2</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rho_M1Y">rho_M1Y</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># M1 is mixture of N(-2, 1) and N(2, 1); pairwise correlation set to 0.35
rho_M1Y(mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2), mix_sigmas = c(1, 1),
  p_M1Y = c(0.35, 0.35))

</code></pre>

<hr>
<h2 id='summary_var'>Summary of Simulated Variables</h2><span id='topic+summary_var'></span>

<h3>Description</h3>

<p>This function summarizes the results of <code><a href="#topic+contmixvar1">contmixvar1</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, or
<code><a href="#topic+corrvar2">corrvar2</a></code>.  The inputs are either the simulated variables or inputs for those functions.  See their
documentation for more information.  If summarizing result from <code><a href="#topic+contmixvar1">contmixvar1</a></code>, mixture parameters may be
entered as vectors instead of lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_var(Y_cat = NULL, Y_cont = NULL, Y_comp = NULL, Y_mix = NULL,
  Y_pois = NULL, Y_nb = NULL, means = NULL, vars = NULL, skews = NULL,
  skurts = NULL, fifths = NULL, sixths = NULL, mix_pis = list(),
  mix_mus = list(), mix_sigmas = list(), mix_skews = list(),
  mix_skurts = list(), mix_fifths = list(), mix_sixths = list(),
  marginal = list(), lam = NULL, p_zip = 0, size = NULL, prob = NULL,
  mu = NULL, p_zinb = 0, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_var_+3A_y_cat">Y_cat</code></td>
<td>
<p>a matrix of ordinal variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_y_cont">Y_cont</code></td>
<td>
<p>a matrix of continuous non-mixture variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_y_comp">Y_comp</code></td>
<td>
<p>a matrix of components of continuous mixture variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_y_mix">Y_mix</code></td>
<td>
<p>a matrix of continuous mixture variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_y_pois">Y_pois</code></td>
<td>
<p>a matrix of Poisson variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_y_nb">Y_nb</code></td>
<td>
<p>a matrix of Negative Binomial variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_means">means</code></td>
<td>
<p>a vector of means for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="summary_var_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="summary_var_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="summary_var_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose components vary based on the type of simulated variables.
</p>
<p>If <b>ordinal variables</b> are produced:
</p>
<p><code>ord_sum</code> a list, where the i-th element contains a data.frame with target and simulated cumulative probabilities for ordinal variable Y_i
</p>
<p>If <b>continuous variables</b> are produced:
</p>
<p><code>cont_sum</code> a data.frame summarizing <code>Y_cont</code> and <code>Y_comp</code>,
</p>
<p><code>target_sum</code> a data.frame with the target distributions for <code>Y_cont</code> and <code>Y_comp</code>,
</p>
<p><code>mix_sum</code> a data.frame summarizing <code>Y_mix</code>,
</p>
<p><code>target_mix</code> a data.frame with the target distributions for <code>Y_mix</code>,
</p>
<p>If <b>Poisson variables</b> are produced:
</p>
<p><code>pois_sum</code> a data.frame summarizing <code>Y_pois</code>
</p>
<p>If <b>Negative Binomial variables</b> are produced:
</p>
<p><code>nb_sum</code> a data.frame summarizing <code>Y_nb</code>
</p>
<p>Additionally, the following elements:
</p>
<p><code>rho_calc</code> the final correlation matrix for <code>Y_cat</code>, <code>Y_cont</code>, <code>Y_comp</code>, <code>Y_pois</code>, and <code>Y_nb</code>
</p>
<p><code>rho_mix</code> the final correlation matrix for <code>Y_cat</code>, <code>Y_cont</code>, <code>Y_mix</code>, <code>Y_pois</code>, and <code>Y_nb</code>
</p>
<p><code>maxerr</code> the maximum final correlation error of <code>rho_calc</code> from the target <code>rho</code>.
</p>


<h3>References</h3>

<p>See references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contmixvar1">contmixvar1</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using normal mixture variable from contmixvar1 example
Nmix &lt;- contmixvar1(n = 1000, "Polynomial", means = 0, vars = 1,
  mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2), mix_sigmas = c(1, 1),
  mix_skews = c(0, 0), mix_skurts = c(0, 0), mix_fifths = c(0, 0),
  mix_sixths = c(0, 0))
Nsum &lt;- summary_var(Y_comp = Nmix$Y_comp, Y_mix = Nmix$Y_mix,
  means = 0, vars = 1, mix_pis = c(0.4, 0.6), mix_mus = c(-2, 2),
  mix_sigmas = c(1, 1), mix_skews = c(0, 0), mix_skurts = c(0, 0),
  mix_fifths = c(0, 0), mix_sixths = c(0, 0))

## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, rho = Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed)

# simulate without the error loop
Sim1 &lt;- corrvar(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed, epsilon = 0.01)

Summ1 &lt;- summary_var(Sim1$Y_cat, Y_cont = NULL, Sim1$Y_comp, Sim1$Y_mix,
  Sim1$Y_pois, Sim1$Y_nb, means, vars, skews, skurts, fifths, sixths,
  mix_pis, mix_mus, mix_sigmas, mix_skews, mix_skurts, mix_fifths,
  mix_sixths, marginal, lam, p_zip, size, prob, mu = NULL, p_zinb, Rey)

Sim1_error &lt;- abs(Rey - Summ1$rho_calc)
summary(as.numeric(Sim1_error))


## End(Not run)


</code></pre>

<hr>
<h2 id='validcorr'>Determine Correlation Bounds for Ordinal, Continuous, Poisson, and/or Negative Binomial Variables: Correlation Method 1</h2><span id='topic+validcorr'></span>

<h3>Description</h3>

<p>This function calculates the lower and upper correlation bounds for the given distributions and
checks if a given target correlation matrix <code>rho</code> is within the bounds.  It should be used before simulation with
<code><a href="#topic+corrvar">corrvar</a></code>.  However, even if all pairwise correlations fall within the bounds, it is still possible
that the desired correlation matrix is not feasible.  This is particularly true when ordinal variables (<code class="reqn">r \ge 2</code> categories) are
generated or negative correlations are desired.  Therefore, this function should be used as a general check to eliminate pairwise correlations that are obviously
not reproducible.  It will help prevent errors when executing the simulation.  The <em>ordering</em> of the variables in <code>rho</code>
must be 1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixture, 4th regular Poisson, 5th zero-inflated
Poisson, 6th regular NB, and 7th zero-inflated NB.  Note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_mix</code>,
<code>k_pois</code>, and/or <code>k_nb</code> to be 0.  The target correlations are specified with respect to the components of the continuous
mixture variables.  There are no parameter input checks in order to decrease simulation time.  All inputs should be checked prior to simulation with
<code><a href="#topic+validpar">validpar</a></code>.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for the differences between the two correlation methods, and
the <b>Variable Types</b> vignette for a detailed explanation of how the correlation boundaries are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validcorr(n = 10000, k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0,
  k_nb = 0, method = c("Fleishman", "Polynomial"), means = NULL,
  vars = NULL, skews = NULL, skurts = NULL, fifths = NULL,
  sixths = NULL, Six = list(), mix_pis = list(), mix_mus = list(),
  mix_sigmas = list(), mix_skews = list(), mix_skurts = list(),
  mix_fifths = list(), mix_sixths = list(), mix_Six = list(),
  marginal = list(), lam = NULL, p_zip = 0, size = NULL, prob = NULL,
  mu = NULL, p_zinb = 0, rho = NULL, seed = 1234, use.nearPD = TRUE,
  quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validcorr_+3A_n">n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable; default = 10000)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_k_mix">k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_method">method</code></td>
<td>
<p>the method used to generate the k_cont non-mixture and k_mix mixture continuous variables.  &quot;Fleishman&quot; uses
Fleishman's third-order polynomial transformation and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="validcorr_+3A_means">means</code></td>
<td>
<p>a vector of means for the k_cont non-mixture and k_mix mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the k_cont non-mixture and k_mix mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validcorr_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validcorr_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_six">Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br /> ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>;
if no correction is desired for variable <code class="reqn">Y_{cont_i}</code>, set set the i-th list component equal to <code>NULL</code>;
if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_mix_six">mix_Six</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (&gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="validcorr_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="validcorr_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="validcorr_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="validcorr_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>TRUE to convert <code>rho</code> to the nearest positive definite matrix with <code>Matrix::nearPD</code> if necessary</p>
</td></tr>
<tr><td><code id="validcorr_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<p><code>rho</code> the target correlation matrix, which will differ from the supplied matrix (if provided) if it was converted to
the nearest positive-definite matrix
</p>
<p><code>L_rho</code> the lower correlation bound
</p>
<p><code>U_rho</code> the upper correlation bound
</p>
<p>If continuous variables are desired, additional components are:
</p>
<p><code>constants</code> the calculated constants
</p>
<p><code>sixth_correction</code> a vector of the sixth cumulant correction values
</p>
<p><code>valid.pdf</code> a vector with i-th component equal to &quot;TRUE&quot; if variable Y_i has a valid power method PDF, else &quot;FALSE&quot;
</p>
<p>If a target correlation matrix <code>rho</code> is provided, each pairwise correlation is checked to see if it is within the lower and upper
bounds.  If the correlation is outside the bounds, the indices of the variable pair are given.
</p>
<p><code>valid.rho</code> TRUE if all entries of <code>rho</code> are within the bounds, else FALSE
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code><a href="SimMultiCorrData.html#topic+fleish">fleish</a></code> or
<code><a href="SimMultiCorrData.html#topic+poly">poly</a></code> converged when using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If this happens,
the function will stop.  It may help to first use <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> for each continuous variable to
determine if a sixth cumulant correction value is needed.  If the standardized cumulants are obtained from <code>calc_theory</code>,
the user may need to use rounded values as inputs (i.e. <code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew
is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code> to determine the boundary for a given set of cumulants.
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, <code><a href="#topic+validpar">validpar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validcorr(n = 1000, k_cat = 1, k_cont = 1, method = "Polynomial",
  means = 0, vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), rho = matrix(c(1, 0.4, 0.4, 1), 2, 2),
  quiet = TRUE)
## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, rho = Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, Rey, seed)

## End(Not run)
</code></pre>

<hr>
<h2 id='validcorr2'>Determine Correlation Bounds for Ordinal, Continuous, Poisson, and/or Negative Binomial Variables: Correlation Method 2</h2><span id='topic+validcorr2'></span>

<h3>Description</h3>

<p>This function calculates the lower and upper correlation bounds for the given distributions and
checks if a given target correlation matrix <code>rho</code> is within the bounds.  It should be used before simulation with
<code><a href="#topic+corrvar2">corrvar2</a></code>.  However, even if all pairwise correlations fall within the bounds, it is still possible
that the desired correlation matrix is not feasible.  This is particularly true when ordinal variables (<code class="reqn">r \ge 2</code> categories) are
generated or negative correlations are desired.  Therefore, this function should be used as a general check to eliminate pairwise correlations that are obviously
not reproducible.  It will help prevent errors when executing the simulation.  The <em>ordering</em> of the variables in <code>rho</code>
must be 1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixture, 4th regular Poisson, 5th zero-inflated
Poisson, 6th regular NB, and 7th zero-inflated NB.  Note that it is possible for <code>k_cat</code>, <code>k_cont</code>, <code>k_mix</code>,
<code>k_pois</code>, and/or <code>k_nb</code> to be 0.  The target correlations are specified with respect to the components of the continuous
mixture variables.  There are no parameter input checks in order to decrease simulation time.  All inputs should be checked prior to simulation with
<code><a href="#topic+validpar">validpar</a></code>.
</p>
<p>Please see the <b>Comparison of Correlation Methods 1 and 2</b> vignette for the differences between the two correlation methods, and
the <b>Variable Types</b> vignette for a detailed explanation of how the correlation boundaries are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validcorr2(n = 10000, k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0,
  k_nb = 0, method = c("Fleishman", "Polynomial"), means = NULL,
  vars = NULL, skews = NULL, skurts = NULL, fifths = NULL,
  sixths = NULL, Six = list(), mix_pis = list(), mix_mus = list(),
  mix_sigmas = list(), mix_skews = list(), mix_skurts = list(),
  mix_fifths = list(), mix_sixths = list(), mix_Six = list(),
  marginal = list(), lam = NULL, p_zip = 0, size = NULL, prob = NULL,
  mu = NULL, p_zinb = 0, pois_eps = 0.0001, nb_eps = 0.0001,
  rho = NULL, seed = 1234, use.nearPD = TRUE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validcorr2_+3A_n">n</code></td>
<td>
<p>the sample size (i.e. the length of each simulated variable; default = 10000)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_k_mix">k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_method">method</code></td>
<td>
<p>the method used to generate the k_cont non-mixture and k_mix mixture continuous variables.  &quot;Fleishman&quot; uses
Fleishman's third-order polynomial transformation and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_means">means</code></td>
<td>
<p>a vector of means for the k_cont non-mixture and k_mix mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the k_cont non-mixture and k_mix mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_six">Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br /> ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>;
if no correction is desired for variable <code class="reqn">Y_{cont_i}</code>, set set the i-th list component equal to <code>NULL</code>;
if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mix_six">mix_Six</code></td>
<td>
<p>a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1);
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (&gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_pois_eps">pois_eps</code></td>
<td>
<p>a vector of length <code>k_pois</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_nb_eps">nb_eps</code></td>
<td>
<p>a vector of length <code>k_nb</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="validcorr2_+3A_seed">seed</code></td>
<td>
<p>the seed value for random number generation (default = 1234)</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_use.nearpd">use.nearPD</code></td>
<td>
<p>TRUE to convert <code>rho</code> to the nearest positive definite matrix with <code>Matrix::nearPD</code> if necessary</p>
</td></tr>
<tr><td><code id="validcorr2_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<p><code>rho</code> the target correlation matrix, which will differ from the supplied matrix (if provided) if it was converted to
the nearest positive-definite matrix
</p>
<p><code>L_rho</code> the lower correlation bound
</p>
<p><code>U_rho</code> the upper correlation bound
</p>
<p>If continuous variables are desired, additional components are:
</p>
<p><code>constants</code> the calculated constants
</p>
<p><code>sixth_correction</code> a vector of the sixth cumulant correction values
</p>
<p><code>valid.pdf</code> a vector with i-th component equal to &quot;TRUE&quot; if variable Y_i has a valid power method PDF, else &quot;FALSE&quot;
</p>
<p>If a target correlation matrix <code>rho</code> is provided, each pairwise correlation is checked to see if it is within the lower and upper
bounds.  If the correlation is outside the bounds, the indices of the variable pair are given.
</p>
<p><code>valid.rho</code> TRUE if all entries of <code>rho</code> are within the bounds, else FALSE
</p>


<h3>Reasons for Function Errors</h3>

<p>1) The most likely cause for function errors is that no solutions to <code><a href="SimMultiCorrData.html#topic+fleish">fleish</a></code> or
<code><a href="SimMultiCorrData.html#topic+poly">poly</a></code> converged when using <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If this happens,
the function will stop.  It may help to first use <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code> for each continuous variable to
determine if a sixth cumulant correction value is needed.  If the standardized cumulants are obtained from <code>calc_theory</code>,
the user may need to use rounded values as inputs (i.e. <code>skews = round(skews, 8)</code>).  For example, in order to ensure that skew
is exactly 0 for symmetric distributions.
</p>
<p>2) The kurtosis may be outside the region of possible values.  There is an associated lower boundary for kurtosis associated
with a given skew (for Fleishman's method) or skew and fifth and sixth cumulants (for Headrick's method).  Use
<code><a href="SimMultiCorrData.html#topic+calc_lower_skurt">calc_lower_skurt</a></code> to determine the boundary for a given set of cumulants.
</p>


<h3>References</h3>

<p>Please see references for <code><a href="#topic+SimCorrMix">SimCorrMix</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>, <code><a href="#topic+validpar">validpar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validcorr2(n = 1000, k_cat = 1, k_cont = 1, method = "Polynomial",
  means = 0, vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), rho = matrix(c(1, 0.4, 0.4, 1), 2, 2),
  quiet = TRUE)
## Not run: 

# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable
n &lt;- 10000
seed &lt;- 1234

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
pois_eps &lt;- 0.0001
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2
nb_eps &lt;- 0.0001

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# check parameter inputs
validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps, nb_eps, Rey)

# check to make sure Rey is within the feasible correlation boundaries
validcorr2(n, k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal,
  lam, p_zip, size, prob, mu = NULL, p_zinb, pois_eps, nb_eps, Rey, seed)

## End(Not run)
</code></pre>

<hr>
<h2 id='validpar'>Parameter Check for Simulation or Correlation Validation Functions</h2><span id='topic+validpar'></span>

<h3>Description</h3>

<p>This function checks the parameter inputs to the simulation functions <code><a href="#topic+contmixvar1">contmixvar1</a></code>,
<code><a href="#topic+corrvar">corrvar</a></code>, and <code><a href="#topic+corrvar2">corrvar2</a></code> and to the correlation validation functions
<code><a href="#topic+validcorr">validcorr</a></code> and <code><a href="#topic+validcorr2">validcorr2</a></code>.  It should be used prior to execution of these
functions to ensure all inputs are of the correct format.  Those functions do not contain parameter checks in order to decrease
simulation time.  This would be important if the user is running several simulation repetitions so that the inputs only have to
be checked once.  Note that the inputs do not include all of the inputs to the simulation functions.  See the appropriate function
documentation for more details about parameter inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validpar(k_cat = 0, k_cont = 0, k_mix = 0, k_pois = 0, k_nb = 0,
  method = c("Fleishman", "Polynomial"), means = NULL, vars = NULL,
  skews = NULL, skurts = NULL, fifths = NULL, sixths = NULL,
  Six = list(), mix_pis = list(), mix_mus = list(), mix_sigmas = list(),
  mix_skews = list(), mix_skurts = list(), mix_fifths = list(),
  mix_sixths = list(), mix_Six = list(), marginal = list(),
  support = list(), lam = NULL, p_zip = 0, size = NULL, prob = NULL,
  mu = NULL, p_zinb = 0, pois_eps = 0.0001, nb_eps = 0.0001,
  rho = NULL, Sigma = NULL, cstart = list(), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validpar_+3A_k_cat">k_cat</code></td>
<td>
<p>the number of ordinal (r &gt;= 2 categories) variables (default = 0)</p>
</td></tr>
<tr><td><code id="validpar_+3A_k_cont">k_cont</code></td>
<td>
<p>the number of continuous non-mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validpar_+3A_k_mix">k_mix</code></td>
<td>
<p>the number of continuous mixture variables (default = 0)</p>
</td></tr>
<tr><td><code id="validpar_+3A_k_pois">k_pois</code></td>
<td>
<p>the number of regular Poisson and zero-inflated Poisson variables (default = 0)</p>
</td></tr>
<tr><td><code id="validpar_+3A_k_nb">k_nb</code></td>
<td>
<p>the number of regular Negative Binomial and zero-inflated Negative Binomial variables (default = 0)</p>
</td></tr>
<tr><td><code id="validpar_+3A_method">method</code></td>
<td>
<p>the method used to generate the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables.
&quot;Fleishman&quot; uses Fleishman's third-order polynomial transformation and &quot;Polynomial&quot; uses Headrick's fifth-order transformation.</p>
</td></tr>
<tr><td><code id="validpar_+3A_means">means</code></td>
<td>
<p>a vector of means for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(0, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validpar_+3A_vars">vars</code></td>
<td>
<p>a vector of variances for the <code>k_cont</code> non-mixture and <code>k_mix</code> mixture continuous variables
(i.e. <code>rep(1, (k_cont + k_mix))</code>)</p>
</td></tr>
<tr><td><code id="validpar_+3A_skews">skews</code></td>
<td>
<p>a vector of skewness values for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validpar_+3A_skurts">skurts</code></td>
<td>
<p>a vector of standardized kurtoses (kurtosis - 3, so that normal variables have a value of 0)
for the <code>k_cont</code> non-mixture continuous variables</p>
</td></tr>
<tr><td><code id="validpar_+3A_fifths">fifths</code></td>
<td>
<p>a vector of standardized fifth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_sixths">sixths</code></td>
<td>
<p>a vector of standardized sixth cumulants for the <code>k_cont</code> non-mixture continuous variables
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_six">Six</code></td>
<td>
<p>a list of vectors of sixth cumulant correction values for the <code>k_cont</code> non-mixture continuous variables
if no valid PDF constants are found, <br /> ex: <code>Six = list(seq(0.01, 2, 0.01), seq(1, 10, 0.5))</code>;
if no correction is desired for variable <code class="reqn">Y_{cont_i}</code>, set set the i-th list component equal to <code>NULL</code>;
if no correction is desired for any of the <code class="reqn">Y_{cont}</code> keep as <code>Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_pis">mix_pis</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of mixing probabilities that sum to 1 for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_mus">mix_mus</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of means for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_sigmas">mix_sigmas</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of standard deviations for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_skews">mix_skews</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of skew values for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_skurts">mix_skurts</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of standardized kurtoses for component distributions of <code class="reqn">Y_{mix_i}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_fifths">mix_fifths</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of standardized fifth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_sixths">mix_sixths</code></td>
<td>
<p>a vector if using <code><a href="#topic+contmixvar1">contmixvar1</a></code> or a list of length <code>k_mix</code> with i-th component a vector of standardized sixth cumulants for component distributions of <code class="reqn">Y_{mix_i}</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_mix_six">mix_Six</code></td>
<td>
<p>if using <code><a href="#topic+contmixvar1">contmixvar1</a></code>, a list of vectors of sixth cumulant corrections for the components of the
continuous mixture variable; else a list of length <code>k_mix</code> with i-th component a list of vectors of sixth cumulant correction values
for component distributions of <code class="reqn">Y_{mix_i}</code>; use <code>NULL</code> if no correction is desired for a given component or
mixture variable; if no correction is desired for any of the <code class="reqn">Y_{mix}</code> keep as <code>mix_Six = list()</code>
(not necessary for <code>method</code> = &quot;Fleishman&quot;)</p>
</td></tr>
<tr><td><code id="validpar_+3A_marginal">marginal</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector of the cumulative
probabilities defining the marginal distribution of the i-th variable;
if the variable can take r values, the vector will contain r - 1 probabilities (the r-th is assumed to be 1; default = list());
for binary variables, these should be input the same as for ordinal variables with more than 2 categories (i.e. the user-specified
probability is the probability of the 1st category, which has the smaller support value)</p>
</td></tr>
<tr><td><code id="validpar_+3A_support">support</code></td>
<td>
<p>a list of length equal to <code>k_cat</code>; the i-th element is a vector containing the r ordered support values;
if not provided (i.e. <code>support = list()</code>), the default is for the i-th element to be the vector 1, ..., r</p>
</td></tr>
<tr><td><code id="validpar_+3A_lam">lam</code></td>
<td>
<p>a vector of lambda (mean &gt; 0) constants for the Poisson variables (see <code>stats::dpois</code>); the order should be
1st regular Poisson variables, 2nd zero-inflated Poisson variables</p>
</td></tr>
<tr><td><code id="validpar_+3A_p_zip">p_zip</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the Poisson distribution) for the
zero-inflated Poisson variables (see <code>VGAM::dzipois</code>); if <code>p_zip</code> = 0, <code class="reqn">Y_{pois}</code> has a regular Poisson
distribution; if <code>p_zip</code> is in (0, 1), <code class="reqn">Y_{pois}</code> has a zero-inflated Poisson distribution;
if <code>p_zip</code> is in <code>(-(exp(lam) - 1)^(-1), 0)</code>, <code class="reqn">Y_{pois}</code> has a zero-deflated Poisson distribution and <code>p_zip</code>
is not a probability; if <code>p_zip = -(exp(lam) - 1)^(-1)</code>, <code class="reqn">Y_{pois}</code> has a positive-Poisson distribution
(see <code>VGAM::dpospois</code>); if <code>length(p_zip) &lt; length(lam)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validpar_+3A_size">size</code></td>
<td>
<p>a vector of size parameters for the Negative Binomial variables (see <code>stats::dnbinom</code>); the order should be
1st regular NB variables, 2nd zero-inflated NB variables</p>
</td></tr>
<tr><td><code id="validpar_+3A_prob">prob</code></td>
<td>
<p>a vector of success probability parameters for the NB variables; order the same as in <code>size</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_mu">mu</code></td>
<td>
<p>a vector of mean parameters for the NB variables (*Note: either <code>prob</code> or <code>mu</code> should be supplied for all Negative Binomial variables,
not a mixture; default = NULL); order the same as in <code>size</code>; for zero-inflated NB this refers to
the mean of the NB distribution (see <code>VGAM::dzinegbin</code>)</p>
</td></tr>
<tr><td><code id="validpar_+3A_p_zinb">p_zinb</code></td>
<td>
<p>a vector of probabilities of structural zeros (not including zeros from the NB distribution) for the zero-inflated NB variables
(see <code>VGAM::dzinegbin</code>); if <code>p_zinb</code> = 0, <code class="reqn">Y_{nb}</code> has a regular NB distribution;
if <code>p_zinb</code> is in <code>(-prob^size/(1 - prob^size),</code> <code>0)</code>, <code class="reqn">Y_{nb}</code> has a zero-deflated NB distribution and <code>p_zinb</code>
is not a probability; if <code>p_zinb = -prob^size/(1 - prob^size)</code>, <code class="reqn">Y_{nb}</code> has a positive-NB distribution (see
<code>VGAM::dposnegbin</code>); if <code>length(p_zinb) &lt; length(size)</code>, the missing values are set to 0 (and ordered 1st)</p>
</td></tr>
<tr><td><code id="validpar_+3A_pois_eps">pois_eps</code></td>
<td>
<p>a vector of length <code>k_pois</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="validpar_+3A_nb_eps">nb_eps</code></td>
<td>
<p>a vector of length <code>k_nb</code> containing total cumulative probability truncation values; if none are provided,
the default is 0.0001 for each variable</p>
</td></tr>
<tr><td><code id="validpar_+3A_rho">rho</code></td>
<td>
<p>the target correlation matrix which must be ordered
<em>1st ordinal, 2nd continuous non-mixture, 3rd components of continuous mixtures, 4th regular Poisson, 5th zero-inflated Poisson,
6th regular NB, 7th zero-inflated NB</em>; note that <code>rho</code> is specified in terms of the components of <code class="reqn">Y_{mix}</code></p>
</td></tr>
<tr><td><code id="validpar_+3A_sigma">Sigma</code></td>
<td>
<p>an intermediate correlation matrix to use if the user wants to provide one, else it is calculated within by
<code><a href="#topic+intercorr">intercorr</a></code></p>
</td></tr>
<tr><td><code id="validpar_+3A_cstart">cstart</code></td>
<td>
<p>a list of length equal to <code>k_cont</code> + the total number of mixture components containing initial values for root-solving
algorithm used in <code><a href="SimMultiCorrData.html#topic+find_constants">find_constants</a></code>.  If user specified, each list element must be input as a matrix.
For <code>method</code> = &quot;Fleishman&quot;, each should have 3 columns for <code class="reqn">c1, c2, c3</code>;
for <code>method</code> = &quot;Polynomial&quot;, each should have 5 columns for <code class="reqn">c1, c2, c3, c4, c5</code>.  If no starting values are specified for
a given component, that list element should be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="validpar_+3A_quiet">quiet</code></td>
<td>
<p>if FALSE prints messages, if TRUE suppresses message printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all inputs are correct, else it will stop with a correction message
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contmixvar1">contmixvar1</a></code>, <code><a href="#topic+corrvar">corrvar</a></code>, <code><a href="#topic+corrvar2">corrvar2</a></code>,
<code><a href="#topic+validcorr">validcorr</a></code>, <code><a href="#topic+validcorr2">validcorr2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validpar(k_cat = 1, k_cont = 1, method = "Polynomial", means = 0,
  vars = 1, skews = 0, skurts = 0, fifths = 0, sixths = 0,
  marginal = list(c(1/3, 2/3)), rho = matrix(c(1, 0.4, 0.4, 1), 2, 2),
  quiet = TRUE)
## Not run: 
# 2 continuous mixture, 1 binary, 1 zero-inflated Poisson, and
# 1 zero-inflated NB variable

# Mixture variables: Normal mixture with 2 components;
# mixture of Logistic(0, 1), Chisq(4), Beta(4, 1.5)
# Find cumulants of components of 2nd mixture variable
L &lt;- calc_theory("Logistic", c(0, 1))
C &lt;- calc_theory("Chisq", 4)
B &lt;- calc_theory("Beta", c(4, 1.5))

skews &lt;- skurts &lt;- fifths &lt;- sixths &lt;- NULL
Six &lt;- list()
mix_pis &lt;- list(c(0.4, 0.6), c(0.3, 0.2, 0.5))
mix_mus &lt;- list(c(-2, 2), c(L[1], C[1], B[1]))
mix_sigmas &lt;- list(c(1, 1), c(L[2], C[2], B[2]))
mix_skews &lt;- list(rep(0, 2), c(L[3], C[3], B[3]))
mix_skurts &lt;- list(rep(0, 2), c(L[4], C[4], B[4]))
mix_fifths &lt;- list(rep(0, 2), c(L[5], C[5], B[5]))
mix_sixths &lt;- list(rep(0, 2), c(L[6], C[6], B[6]))
mix_Six &lt;- list(list(NULL, NULL), list(1.75, NULL, 0.03))
Nstcum &lt;- calc_mixmoments(mix_pis[[1]], mix_mus[[1]], mix_sigmas[[1]],
  mix_skews[[1]], mix_skurts[[1]], mix_fifths[[1]], mix_sixths[[1]])
Mstcum &lt;- calc_mixmoments(mix_pis[[2]], mix_mus[[2]], mix_sigmas[[2]],
  mix_skews[[2]], mix_skurts[[2]], mix_fifths[[2]], mix_sixths[[2]])
means &lt;- c(Nstcum[1], Mstcum[1])
vars &lt;- c(Nstcum[2]^2, Mstcum[2]^2)

marginal &lt;- list(0.3)
support &lt;- list(c(0, 1))
lam &lt;- 0.5
p_zip &lt;- 0.1
size &lt;- 2
prob &lt;- 0.75
p_zinb &lt;- 0.2

k_cat &lt;- k_pois &lt;- k_nb &lt;- 1
k_cont &lt;- 0
k_mix &lt;- 2
Rey &lt;- matrix(0.39, 8, 8)
diag(Rey) &lt;- 1
rownames(Rey) &lt;- colnames(Rey) &lt;- c("O1", "M1_1", "M1_2", "M2_1", "M2_2",
  "M2_3", "P1", "NB1")

# set correlation between components of the same mixture variable to 0
Rey["M1_1", "M1_2"] &lt;- Rey["M1_2", "M1_1"] &lt;- 0
Rey["M2_1", "M2_2"] &lt;- Rey["M2_2", "M2_1"] &lt;- Rey["M2_1", "M2_3"] &lt;- 0
Rey["M2_3", "M2_1"] &lt;- Rey["M2_2", "M2_3"] &lt;- Rey["M2_3", "M2_2"] &lt;- 0

# use before contmixvar1 with 1st mixture variable:
# change mix_pis to not sum to 1

check1 &lt;- validpar(k_mix = 1, method = "Polynomial", means = Nstcum[1],
  vars = Nstcum[2]^2, mix_pis = C(0.4, 0.5), mix_mus = mix_mus[[1]],
  mix_sigmas = mix_sigmas[[1]], mix_skews = mix_skews[[1]],
  mix_skurts = mix_skurts[[1]], mix_fifths = mix_fifths[[1]],
  mix_sixths = mix_sixths[[1]])

# use before validcorr: should return TRUE

check2 &lt;- validpar(k_cat, k_cont, k_mix, k_pois, k_nb, "Polynomial", means,
  vars, skews, skurts, fifths, sixths, Six, mix_pis, mix_mus, mix_sigmas,
  mix_skews, mix_skurts, mix_fifths, mix_sixths, mix_Six, marginal, support,
  lam, p_zip, size, prob, mu = NULL, p_zinb, rho = Rey)


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
