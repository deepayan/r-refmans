<!DOCTYPE html><html lang="en"><head><title>Help for package stringstatic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringstatic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stringstatic-package'><p>stringstatic: Dependency-Free String Operations</p></a></li>
<li><a href='#fixed'><p>Compare literal bytes in the string</p></a></li>
<li><a href='#regex'><p>Control regex matching behavior</p></a></li>
<li><a href='#str_c'><p>Join multiple strings into a single string</p></a></li>
<li><a href='#str_count'><p>Count the number of matches in a string</p></a></li>
<li><a href='#str_detect'><p>Detect the presence or absence of a pattern in a string</p></a></li>
<li><a href='#str_dup'><p>Duplicate and concatenate strings within a character vector</p></a></li>
<li><a href='#str_ends'><p>Detect the presence or absence of a pattern at the end of a string</p></a></li>
<li><a href='#str_extract'><p>Extract matching patterns from a string</p></a></li>
<li><a href='#str_extract_all'><p>Extract matching patterns from a string</p></a></li>
<li><a href='#str_length'><p>Compute the length of a string</p></a></li>
<li><a href='#str_match'><p>Extract matched groups from a string</p></a></li>
<li><a href='#str_pad'><p>Duplicate and concatenate strings within a character vector</p></a></li>
<li><a href='#str_remove'><p>Remove matched patterns in a string</p></a></li>
<li><a href='#str_remove_all'><p>Remove matched patterns in a string</p></a></li>
<li><a href='#str_replace'><p>Replace matched patterns in a string</p></a></li>
<li><a href='#str_replace_all'><p>Replace matched patterns in a string</p></a></li>
<li><a href='#str_replace_na'><p>Turn NA into &quot;NA&quot;</p></a></li>
<li><a href='#str_split'><p>Split up a string into pieces</p></a></li>
<li><a href='#str_split_fixed'><p>Split up a string into pieces</p></a></li>
<li><a href='#str_squish'><p>Remove whitespace</p></a></li>
<li><a href='#str_starts'><p>Detect the presence or absence of a pattern at the beginning of a string</p></a></li>
<li><a href='#str_subset'><p>Keep strings matching a pattern</p></a></li>
<li><a href='#str_trim'><p>Remove whitespace</p></a></li>
<li><a href='#str_which'><p>Find positions of strings matching a pattern</p></a></li>
<li><a href='#str_width'><p>Compute the width of a string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Dependency-Free String Operations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides drop-in replacements for functions from the
    'stringr' package, with the same user interface. These functions have
    no external dependencies and can be copied directly into your package
    code using the 'staticimports' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rossellhayes/stringstatic">https://github.com/rossellhayes/stringstatic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rossellhayes/stringstatic/issues">https://github.com/rossellhayes/stringstatic/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/Needs/roxygen:</td>
<td>wch/staticimports</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-11 06:09:41 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Rossell Hayes
    <a href="https://orcid.org/0000-0001-9412-0457"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Eli Pousson <a href="https://orcid.org/0000-0001-8280-1706"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (str_pad() and str_split() functions),
  Hadley Wickham [ctb, cph] (stringr package),
  RStudio [cph] (stringr package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Rossell Hayes &lt;alexander@rossellhayes.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-12 22:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='stringstatic-package'>stringstatic: Dependency-Free String Operations</h2><span id='topic+stringstatic'></span><span id='topic+stringstatic-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides drop-in replacements for functions from the 'stringr' package, with the same user interface. These functions have no external dependencies and can be copied directly into your package code using the 'staticimports' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander Rossell Hayes <a href="mailto:alexander@rossellhayes.com">alexander@rossellhayes.com</a> (<a href="https://orcid.org/0000-0001-9412-0457">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Eli Pousson <a href="mailto:eli.pousson@gmail.com">eli.pousson@gmail.com</a> (<a href="https://orcid.org/0000-0001-8280-1706">ORCID</a>) (str_pad() and str_split() functions) [contributor]
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@rstudio.com">hadley@rstudio.com</a> (stringr package) [contributor, copyright holder]
</p>
</li>
<li><p> RStudio (stringr package) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rossellhayes/stringstatic">https://github.com/rossellhayes/stringstatic</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rossellhayes/stringstatic/issues">https://github.com/rossellhayes/stringstatic/issues</a>
</p>
</li></ul>


<hr>
<h2 id='fixed'>Compare literal bytes in the string</h2><span id='topic+fixed'></span>

<h3>Description</h3>

<p>Compare literal bytes in the string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed(pattern, ignore_case = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixed_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to modify behavior.</p>
</td></tr>
<tr><td><code id="fixed_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Should case differences be ignored in the match?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>
<p>Dependency-free drop-in alternative for <code>stringr::fixed()</code>.
This is very fast,
but not usually what you want for non-ASCII character sets.
</p>

<hr>
<h2 id='regex'>Control regex matching behavior</h2><span id='topic+regex'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::regex()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regex(
  pattern,
  ignore_case = FALSE,
  multiline = FALSE,
  comments = FALSE,
  dotall = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regex_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to modify behavior.</p>
</td></tr>
<tr><td><code id="regex_+3A_ignore_case">ignore_case</code></td>
<td>
<p>Should case differences be ignored in the match?</p>
</td></tr>
<tr><td><code id="regex_+3A_multiline">multiline</code></td>
<td>
<p>If <code>TRUE</code>, <code>$</code> and <code>^</code> match the beginning and end of each line.
If <code>FALSE</code>, the default, only match the start and end of the input.</p>
</td></tr>
<tr><td><code id="regex_+3A_comments">comments</code></td>
<td>
<p>If <code>TRUE</code>, white space and comments beginning with <code style="white-space: pre;">&#8288;#&#8288;</code> are ignored.
Escape literal spaces with <code style="white-space: pre;">&#8288;\\&#8288;</code>.</p>
</td></tr>
<tr><td><code id="regex_+3A_dotall">dotall</code></td>
<td>
<p>If <code>TRUE</code>, <code>.</code> will also match line terminators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_c'>Join multiple strings into a single string</h2><span id='topic+str_c'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_c()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_c(..., sep = "", collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_c_+3A_...">...</code></td>
<td>
<p>One or more character vectors.
Zero length arguments are removed.
Short arguments are recycled to the length of the longest.
</p>
<p>Like most other R functions, missing values are &quot;infectious&quot;:
whenever a missing value is combined with another string
the result will always be missing.
Use <code>str_replace_na()</code> to convert <code>NA</code> to &quot;NA&quot;</p>
</td></tr>
<tr><td><code id="str_c_+3A_sep">sep</code></td>
<td>
<p>String to insert between input vectors.</p>
</td></tr>
<tr><td><code id="str_c_+3A_collapse">collapse</code></td>
<td>
<p>Optional string used to combine input vectors into single string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>collapse = NULL</code> (the default) a character vector
with length equal to the longest input string.
If collapse is non-<code>NULL</code>, a character vector of length 1.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_count'>Count the number of matches in a string</h2><span id='topic+str_count'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_count()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_count(string, pattern = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_count_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_count_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_detect'>Detect the presence or absence of a pattern in a string</h2><span id='topic+str_detect'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_detect()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_detect(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_detect_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_detect_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_detect_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_dup'>Duplicate and concatenate strings within a character vector</h2><span id='topic+str_dup'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_dup()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_dup(string, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_dup_+3A_string">string</code></td>
<td>
<p>Input character vector.</p>
</td></tr>
<tr><td><code id="str_dup_+3A_times">times</code></td>
<td>
<p>Number of times to duplicate each string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_ends'>Detect the presence or absence of a pattern at the end of a string</h2><span id='topic+str_ends'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_ends()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_ends(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_ends_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_ends_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_ends_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_extract'>Extract matching patterns from a string</h2><span id='topic+str_extract'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_extract()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_extract_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_extract_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix.
The first column is the complete match,
followed by one column for each capture group.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_extract_all'>Extract matching patterns from a string</h2><span id='topic+str_extract_all'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_extract_all()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_extract_all(string, pattern, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_extract_all_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_extract_all_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_extract_all_+3A_simplify">simplify</code></td>
<td>
<p>If <code>FALSE</code>, the default, returns a list of character vectors.
If <code>TRUE</code> returns a character matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors if <code>simplify = FALSE</code>,
or a character matrix if <code>simplify = TRUE</code>.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_length'>Compute the length of a string</h2><span id='topic+str_length'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_length()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_length(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_length_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as string.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_match'>Extract matched groups from a string</h2><span id='topic+str_match'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_match()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_match(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_match_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_match_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix.
The first column is the complete match,
followed by one column for each capture group.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_pad'>Duplicate and concatenate strings within a character vector</h2><span id='topic+str_pad'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_pad()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_pad(
  string,
  width,
  side = c("left", "right", "both"),
  pad = " ",
  use_width = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_pad_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_pad_+3A_width">width</code></td>
<td>
<p>Minimum width of padded strings.</p>
</td></tr>
<tr><td><code id="str_pad_+3A_side">side</code></td>
<td>
<p>Side on which padding character is added (left, right or both).</p>
</td></tr>
<tr><td><code id="str_pad_+3A_pad">pad</code></td>
<td>
<p>Single padding character (default is a space).</p>
</td></tr>
<tr><td><code id="str_pad_+3A_use_width">use_width</code></td>
<td>
<p>If <code>FALSE</code>,
use the length of the string instead of the width;
see <code><a href="#topic+str_width">str_width()</a></code>/<code><a href="#topic+str_length">str_length()</a></code> for the difference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Eli Pousson <a href="mailto:eli.pousson@gmail.com">eli.pousson@gmail.com</a>
(<a href="https://orcid.org/0000-0001-8280-1706">ORCID</a>)
</p>
<p>Alexander Rossell Hayes <a href="mailto:alexander@rossellhayes.com">alexander@rossellhayes.com</a>
(<a href="https://orcid.org/0000-0001-9412-0457">ORCID</a>)
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_remove'>Remove matched patterns in a string</h2><span id='topic+str_remove'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_remove()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_remove(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_remove_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_remove_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_remove_all'>Remove matched patterns in a string</h2><span id='topic+str_remove_all'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_remove_all()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_remove_all(string, pattern)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_remove_all_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_remove_all_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_replace'>Replace matched patterns in a string</h2><span id='topic+str_replace'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_replace()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace(string, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_replace_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_replace_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_replace_+3A_replacement">replacement</code></td>
<td>
<p>A character vector of replacements.
Should be either length one, or the same length as <code>string</code> or <code>pattern</code>.
References of the form <code style="white-space: pre;">&#8288;\1&#8288;</code>, <code style="white-space: pre;">&#8288;\2&#8288;</code>, etc. will be replaced with the contents
of the respective matched group (created by <code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>To replace the complete string with <code>NA</code>,
use <code>replacement = NA_character_</code>.
</p>
<p>Using a function for <code>replacement</code> is not yet supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_replace_all'>Replace matched patterns in a string</h2><span id='topic+str_replace_all'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_replace_all()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace_all(string, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_replace_all_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_replace_all_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_replace_all_+3A_replacement">replacement</code></td>
<td>
<p>A character vector of replacements.
Should be either length one, or the same length as <code>string</code> or <code>pattern</code>.
References of the form <code style="white-space: pre;">&#8288;\1&#8288;</code>, <code style="white-space: pre;">&#8288;\2&#8288;</code>, etc. will be replaced with the contents
of the respective matched group (created by <code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>To perform multiple replacements in each element of <code>string</code>,
pass a named vector <code>(c(pattern1 = replacement1))</code> to <code>str_replace_all()</code>.
</p>
<p>To replace the complete string with <code>NA</code>,
use <code>replacement = NA_character_</code>.
</p>
<p>Using a function for <code>replacement</code> is not yet supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_replace_na'>Turn NA into &quot;NA&quot;</h2><span id='topic+str_replace_na'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_replace_na()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_replace_na(string, replacement = "NA")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_replace_na_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_replace_na_+3A_replacement">replacement</code></td>
<td>
<p>A single string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='str_split'>Split up a string into pieces</h2><span id='topic+str_split'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_split()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split(string, pattern, n = Inf, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_split_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_split_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_split_+3A_n">n</code></td>
<td>
<p>Maximum number of pieces to return.
Default (<code>Inf</code>) uses all possible split positions.
This determines the maximum length of each element of the output.</p>
</td></tr>
<tr><td><code id="str_split_+3A_simplify">simplify</code></td>
<td>
<p>A boolean.
</p>

<ul>
<li> <p><code>FALSE</code> (the default): returns a list of character vectors.
</p>
</li>
<li> <p><code>TRUE</code>: returns a character matrix.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list the same length as <code>string</code>/<code>pattern</code> containing character vectors,
or if <code>simplify = FALSE</code>, a character matrix with n columns and
the same number of rows as the length of <code>string</code>/<code>pattern</code>.
</p>


<h3>Author(s)</h3>

<p>Eli Pousson <a href="mailto:eli.pousson@gmail.com">eli.pousson@gmail.com</a>
(<a href="https://orcid.org/0000-0001-8280-1706">ORCID</a>)
</p>
<p>Alexander Rossell Hayes <a href="mailto:alexander@rossellhayes.com">alexander@rossellhayes.com</a>
(<a href="https://orcid.org/0000-0001-9412-0457">ORCID</a>)
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_split_fixed'>Split up a string into pieces</h2><span id='topic+str_split_fixed'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_split_fixed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split_fixed(string, pattern, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_split_fixed_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_split_fixed_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_split_fixed_+3A_n">n</code></td>
<td>
<p>Maximum number of pieces to return.
This determines the number of columns in the output;
if an input is too short, the result will be padded with <code>""</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character matrix with <code>n</code> columns and
the same number of rows as the length of <code>string</code>/<code>pattern</code>.
</p>


<h3>Author(s)</h3>

<p>Eli Pousson <a href="mailto:eli.pousson@gmail.com">eli.pousson@gmail.com</a>
(<a href="https://orcid.org/0000-0001-8280-1706">ORCID</a>)
</p>
<p>Alexander Rossell Hayes <a href="mailto:alexander@rossellhayes.com">alexander@rossellhayes.com</a>
(<a href="https://orcid.org/0000-0001-9412-0457">ORCID</a>)
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_squish'>Remove whitespace</h2><span id='topic+str_squish'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_squish()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_squish(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_squish_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_starts'>Detect the presence or absence of a pattern at the beginning of a string</h2><span id='topic+str_starts'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_starts()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_starts(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_starts_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_starts_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_starts_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>

<hr>
<h2 id='str_subset'>Keep strings matching a pattern</h2><span id='topic+str_subset'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_subset()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_subset(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_subset_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_subset_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_subset_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_trim'>Remove whitespace</h2><span id='topic+str_trim'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_trim()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_trim(string, side = c("both", "left", "right"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_trim_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_trim_+3A_side">side</code></td>
<td>
<p>Side on which to remove whitespace:
<code>"left"</code>, <code>"right"</code>, or <code>"both"</code>, the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_which'>Find positions of strings matching a pattern</h2><span id='topic+str_which'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_which()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_which(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_which_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
<tr><td><code id="str_which_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression,
as described in <a href="base.html#topic+regex">base::regex</a>.
Control options with <code><a href="#topic+regex">regex()</a></code>.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using <code><a href="#topic+fixed">fixed()</a></code>.
This is fast, but approximate.</p>
</td></tr>
<tr><td><code id="str_which_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

<hr>
<h2 id='str_width'>Compute the width of a string</h2><span id='topic+str_width'></span>

<h3>Description</h3>

<p>Dependency-free drop-in alternative for <code>stringr::str_width()</code>.
Results for non-ASCII characters may be inaccurate in R &lt; 4.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_width(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_width_+3A_string">string</code></td>
<td>
<p>Input vector.
Either a character vector, or something coercible to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same length as string.
</p>


<h3>Source</h3>

<p>Adapted from the <a href="https://stringr.tidyverse.org/">stringr</a> package.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
