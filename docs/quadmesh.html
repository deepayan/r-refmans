<!DOCTYPE html><html><head><title>Help for package quadmesh</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quadmesh}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quadmesh-package'><p>quadmesh: Quadrangle Mesh</p></a></li>
<li><a href='#bary_index'><p>Barycentric triangle index for interpolation</p></a></li>
<li><a href='#cmip6'><p>CMIP6 sample</p></a></li>
<li><a href='#etopo'><p>World topography map</p></a></li>
<li><a href='#llh2xyz'><p>Angular coordinates to X, Y, Z.</p></a></li>
<li><a href='#mesh_plot'><p>Plot as a mesh</p></a></li>
<li><a href='#qm_as_raster'><p>Quadmesh to raster</p></a></li>
<li><a href='#qsc'><p>Quadrilateralized Spherical Cube (QSC)</p></a></li>
<li><a href='#quadmesh'><p>Create a quad-type mesh for use in rgl.</p></a></li>
<li><a href='#reproj'><p>Coordinate reprojection</p></a></li>
<li><a href='#triangmesh'><p>Create a triangle-type mesh for use in rgl.</p></a></li>
<li><a href='#triangulate_quads'><p>Triangles from quads</p></a></li>
<li><a href='#use_crs'><p>In-use coordinate system</p></a></li>
<li><a href='#worldll'><p>World raster map</p></a></li>
<li><a href='#xymap'><p>World map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quadrangle Mesh</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Create surface forms from matrix or 'raster' data for flexible plotting and
 conversion to other mesh types. The functions 'quadmesh' or 'triangmesh'
 produce a continuous surface as a 'mesh3d' object as used by the 'rgl'
 package. This is used for plotting raster data in 3D (optionally with
 texture), and allows the application of a map projection without data loss and 
 many processing applications that are restricted by inflexible regular grid rasters.
 There are discrete forms of these continuous surfaces available with
 'dquadmesh' and 'dtriangmesh' functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>raster, gridBase, png, sp, geometry, reproj (&ge; 0.4.0),
scales, palr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hypertidy/quadmesh">https://github.com/hypertidy/quadmesh</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hypertidy/quadmesh/issues">https://github.com/hypertidy/quadmesh/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-31 06:20:51 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael D. Sumner [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael D. Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-31 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quadmesh-package'>quadmesh: Quadrangle Mesh</h2><span id='topic+quadmesh-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Create surface forms from matrix or 'raster' data for flexible plotting and conversion to other mesh types. The functions 'quadmesh' or 'triangmesh' produce a continuous surface as a 'mesh3d' object as used by the 'rgl' package. This is used for plotting raster data in 3D (optionally with texture), and allows the application of a map projection without data loss and many processing applications that are restricted by inflexible regular grid rasters. There are discrete forms of these continuous surfaces available with 'dquadmesh' and 'dtriangmesh' functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael D. Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hypertidy/quadmesh">https://github.com/hypertidy/quadmesh</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hypertidy/quadmesh/issues">https://github.com/hypertidy/quadmesh/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bary_index'>Barycentric triangle index for interpolation</h2><span id='topic+bary_index'></span>

<h3>Description</h3>

<p>This function returns the barycentric weight for a grid of coordinates
from a geographic raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bary_index(x, coords = NULL, grid = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bary_index_+3A_x">x</code></td>
<td>
<p>a 'RasterLayer' source</p>
</td></tr>
<tr><td><code id="bary_index_+3A_coords">coords</code></td>
<td>
<p>optional input coordinates</p>
</td></tr>
<tr><td><code id="bary_index_+3A_grid">grid</code></td>
<td>
<p>target 'RasterLayer', a target regular grid</p>
</td></tr>
<tr><td><code id="bary_index_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's not as fast as <code><a href="raster.html#topic+projectRaster">raster::projectRaster()</a></code> (e.g. <code>projectRaster(x, grid)</code>) but it
also accepts a <code>coords</code> argument and so can be used for non-regular raster
reprojection.
</p>
<p>'coords' may be 'NULL' or longitude, latitude in a 2-layer raster brick or stack as with
<code>mesh_plot</code>.
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
p_srs &lt;- "+proj=stere +lat_0=-90 +lat_ts=-71 +datum=WGS84"
polar &lt;- raster(extent(-5e6, 5e6, -5e6, 5e6), crs = p_srs, res = 25000)
etopo &lt;- aggregate(etopo, fact = 4)
index &lt;- bary_index(etopo, grid = polar)
ok &lt;- !is.na(index$idx)
r &lt;- setValues(polar, NA_integer_)
r[ok] &lt;- colSums(matrix(values(etopo)[index$tri[, index$idx[ok]]], nrow = 3) * t(index$p)[, ok])
plot(r)
</code></pre>

<hr>
<h2 id='cmip6'>CMIP6 sample</h2><span id='topic+cmip6'></span>

<h3>Description</h3>

<p>A small extract of model output and native grid ('gn') coordinates from CMIP6. Derived from
'CMIP6/ssp245/intpp/intpp_Omon_MPI-ESM1-2-LR_ssp245_r1i1p1f1_gn_201501-203412.nc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmip6
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RasterBrick</code> of dimension 220 x 256 x 3.
</p>


<h3>Details</h3>

<p>The <a href="#topic+cmip6">cmip6</a> object is a 'RasterBrick', defined by the raster package with three
layers: 'intpp', 'longitude', 'latitude'. The model data is primary organic carbon production 'intpp'.
</p>


<h3>Source</h3>


<ul>
<li><p> A small extract of data and grid coordinates from CMIP 6 produced by the MPI-M.
</p>

<ul>
<li><p> Description: Primary Organic Carbon Production by All Types of Phytoplankton.
</p>
</li>
<li><p> Source: Max Planck Institute for Meteorology, Hamburg 20146, Germany (MPI-M)
</p>
</li>
<li><p> URL: https://data.ccamlr.org/dataset/small-scale-management-units
</p>
</li>
<li><p> Reference: doi:10.1029/2017MS001217
</p>
</li>
<li><p> License: CC BY-SA 4.0
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mesh_plot(cmip6[[1]])
</code></pre>

<hr>
<h2 id='etopo'>World topography map</h2><span id='topic+etopo'></span>

<h3>Description</h3>

<p>A simplified version of 'Etopo2'. The Etopo2 data set was
reduced 20X to create this raster layer of global relief. See code
in 'data-raw/topo.R'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etopo
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RasterLayer</code> of dimension 135 x 540 x 1.
</p>

<hr>
<h2 id='llh2xyz'>Angular coordinates to X, Y, Z.</h2><span id='topic+llh2xyz'></span>

<h3>Description</h3>

<p>Angular coordinates to X, Y, Z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llh2xyz(lonlatheight, rad = 6378137, exag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llh2xyz_+3A_lonlatheight">lonlatheight</code></td>
<td>
<p>matrix or data.frame of lon,lat,height values</p>
</td></tr>
<tr><td><code id="llh2xyz_+3A_rad">rad</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
<tr><td><code id="llh2xyz_+3A_exag">exag</code></td>
<td>
<p>exaggeration to apply to height values (added to radius)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='mesh_plot'>Plot as a mesh</h2><span id='topic+mesh_plot'></span><span id='topic+mesh_plot.BasicRaster'></span><span id='topic+mesh_plot.RasterLayer'></span><span id='topic+mesh_plot.stars'></span><span id='topic+mesh_plot.TRI'></span><span id='topic+mesh_plot.quadmesh'></span><span id='topic+mesh_plot.mesh3d'></span>

<h3>Description</h3>

<p>Convert to a quadmesh and plot in efficient vectorized form using 'grid'.
</p>
<p>Plot mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'BasicRaster'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'RasterLayer'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'stars'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'TRI'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'quadmesh'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL
)

## S3 method for class 'mesh3d'
mesh_plot(
  x,
  crs = NULL,
  col = NULL,
  add = FALSE,
  zlim = NULL,
  ...,
  coords = NULL,
  prefer_quad = TRUE,
  breaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesh_plot_+3A_x">x</code></td>
<td>
<p>object to convert to mesh and plot</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_crs">crs</code></td>
<td>
<p>target map projection</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_col">col</code></td>
<td>
<p>colours to use, defaults to that used by <code><a href="graphics.html#topic+image">graphics::image()</a></code></p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_add">add</code></td>
<td>
<p>add to existing plot or start a new one</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_zlim">zlim</code></td>
<td>
<p>absolute range of data to use for colour scaling (if <code>NULL</code> the data range is used)</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_...">...</code></td>
<td>
<p>passed through to <code>base::plot</code></p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_coords">coords</code></td>
<td>
<p>optional input raster of coordinates of each cell, see details</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_prefer_quad">prefer_quad</code></td>
<td>
<p>set to <code>TRUE</code> by default, if but may be <code>FALSE</code> to assume use of triangle rather than quad primitives -
this covers the case for when a mesh3d object may have quads <em>and</em> triangles in the same mesh</p>
</td></tr>
<tr><td><code id="mesh_plot_+3A_breaks">breaks</code></td>
<td>
<p>argument passed along to <code><a href="palr.html#topic+image_pal">palr::image_pal()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mesh may be reprojected prior to plotting using the 'crs' argument to
define the target map projection in 'PROJ string' format. (There is no
&quot;reproject&quot; function for quadmesh, this is performed directly on the x-y
coordinates of the 'quadmesh' output). The 'col' argument are mapped to the input pplied
object data as in 'image', and applied relative to 'zlim' if su.
</p>
<p>If <code>coords</code> is supplied, it is currently assumed to be a 2-layer <code>RasterBrick</code> with
longitude and latitude as the <em>cell values</em>. These are used to geographically locate
the resulting mesh, and will be transformed to the <code>crs</code> if that is supplied. This is
modelled on the approach to curvilinear grid data used in the <code>angstroms</code> package. There
the function <code>angstroms::romsmap()</code> and 'angstroms::romscoords()&ldquo; are used to separate the complicated
grid geometry from the grid data itself. A small fudge is applied to extend the coordinates
by 1 cell to avoid losing any data due to the half cell outer margin (get in touch if this causes problems!).
</p>
<p>If 'color' is present on the object it is used. This can be overridden by
using the 'col' argument, and controlled with 'zlim' and 'breaks' in the usual
<code><a href="graphics.html#topic+image">graphics::image()</a></code> way.
</p>


<h3>Value</h3>

<p>nothing, used for the side-effect of creating or adding to a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##mesh_plot(worldll)
## crop otherwise out of bounds from PROJ
rr &lt;- raster::crop(worldll, raster::extent(-179, 179, -89, 89))
mesh_plot(rr, crs = "+proj=laea +datum=WGS84")
mesh_plot(worldll, crs = "+proj=moll +datum=WGS84")
prj &lt;- "+proj=lcc +datum=WGS84 +lon_0=147 +lat_0=-40 +lat_1=-55 +lat_2=-20"
mesh_plot(etopo, crs = prj, add = FALSE, col = grey(seq(0, 1, length = 20)))
mesh_plot(rr, crs = prj, add = TRUE)
</code></pre>

<hr>
<h2 id='qm_as_raster'>Quadmesh to raster</h2><span id='topic+qm_as_raster'></span>

<h3>Description</h3>

<p>Approximate re-creation of a raster from a quadmesh.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qm_as_raster(x, index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qm_as_raster_+3A_x">x</code></td>
<td>
<p>'mesh3d' object</p>
</td></tr>
<tr><td><code id="qm_as_raster_+3A_index">index</code></td>
<td>
<p>optional index to specify which z coordinate to use as raster values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raster is populated with the mean of the values at each corner, which is
closest to the interpretation use to create mesh3d from rasters. This can be over ridden
by setting 'index' to 1, 2, 3, or 4.
</p>


<h3>Value</h3>

<p>RasterLayer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qm_as_raster(quadmesh(etopo))
</code></pre>

<hr>
<h2 id='qsc'>Quadrilateralized Spherical Cube (QSC)</h2><span id='topic+qsc'></span>

<h3>Description</h3>

<p>The QSC is a set of six equal area projections for each side of the cube. Here
a raw rendition of the cube is returned as six quad primitives in a <code>mesh3d</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsc()
</code></pre>


<h3>Details</h3>

<p>It's not clear if this is useful.
</p>


<h3>Value</h3>

<p>mesh3d
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(qsc())
</code></pre>

<hr>
<h2 id='quadmesh'>Create a quad-type mesh for use in rgl.</h2><span id='topic+quadmesh'></span><span id='topic+dquadmesh'></span><span id='topic+dquadmesh.default'></span><span id='topic+quadmesh.BasicRaster'></span><span id='topic+quadmesh.matrix'></span>

<h3>Description</h3>

<p>Convert an object to a <code>mesh3d</code> quadrangle mesh,
with methods for <code><a href="raster.html#topic+raster">raster::raster()</a></code> and <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dquadmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

## Default S3 method:
dquadmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

quadmesh(x, z = x, na.rm = FALSE, ..., texture = NULL, texture_filename = NULL)

## S3 method for class 'BasicRaster'
quadmesh(x, z = x, na.rm = FALSE, ..., texture = NULL, texture_filename = NULL)

## S3 method for class 'matrix'
quadmesh(x, z = x, na.rm = FALSE, ..., texture = NULL, texture_filename = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadmesh_+3A_x">x</code></td>
<td>
<p>raster object for mesh structure</p>
</td></tr>
<tr><td><code id="quadmesh_+3A_z">z</code></td>
<td>
<p>raster object for height values</p>
</td></tr>
<tr><td><code id="quadmesh_+3A_na.rm">na.rm</code></td>
<td>
<p>remove quads where missing values?</p>
</td></tr>
<tr><td><code id="quadmesh_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="quadmesh_+3A_texture">texture</code></td>
<td>
<p>optional input RGB raster, 3-layers</p>
</td></tr>
<tr><td><code id="quadmesh_+3A_texture_filename">texture_filename</code></td>
<td>
<p>optional input file path for PNG texture</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>quadmesh()</code> generates the cell-based interpretation of a raster (AREA) but applies a continuous
interpretation of the values of the cells to each quad corner. <code>dquadmesh</code> splits the mesh and
applies a discrete interpretation directly. Loosely, the quadmesh is a continuous surface and the dquadmesh
is free-floating cells, but it's a little more complicated and depends on the options applied. (The interpolation)
applied in the quadmesh case is not entirely consistent.
</p>
<p>The output is described as a mesh because it is a dense representation
of a continuous shape, in this case plane-filling quadrilaterals defined
by index of four of the available vertices.
</p>
<p>The <code>z</code> argument defaults to the input <code>x</code> argument, though may be set to <code>NULL</code>, a constant
numeric value, or another raster. If the coordinate system of <code>z</code> and <code>x</code> don't match the z values
are queried by reprojection.
</p>
<p>Any raster RGB object (3-layers, ranging in 0-255) may be used as
a <em>texture</em> on the resulting mesh3d object. If <code>texture</code> is a palette raster it will be
auto-expanded to RGB.
</p>
<p>It is not possible to provide rgl with an object of data for texture, it must be a PNG file and so
the in-memory <code>texture</code> argument is written out to PNG file (with a message). The location of the file
may be set explicitly with <code>texture_filename</code>.  Currently it's not possible to not use the <code>texture</code> object
in-memory.
</p>


<h3>Value</h3>

<p>mesh3d
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
data(volcano)
r &lt;- setExtent(raster(volcano), extent(0, 100, 0, 200))
qm &lt;- quadmesh(r)
</code></pre>

<hr>
<h2 id='reproj'>Coordinate reprojection</h2><span id='topic+reproj'></span>

<h3>Description</h3>

<p>See <code>reproj::<a href="reproj.html#topic+reproj">reproj</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproj(x, target, ..., source = NULL, four = FALSE)
</code></pre>

<hr>
<h2 id='triangmesh'>Create a triangle-type mesh for use in rgl.</h2><span id='topic+triangmesh'></span><span id='topic+dtriangmesh'></span><span id='topic+triangmesh.matrix'></span><span id='topic+triangmesh.BasicRaster'></span><span id='topic+dtriangmesh.default'></span>

<h3>Description</h3>

<p>Convert an object to a <code>mesh3d</code> (of rgl package) triangle mesh,
with methods for <code><a href="raster.html#topic+raster">raster::raster()</a></code> and <code>matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

## S3 method for class 'matrix'
triangmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

## S3 method for class 'BasicRaster'
triangmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

dtriangmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)

## Default S3 method:
dtriangmesh(
  x,
  z = x,
  na.rm = FALSE,
  ...,
  texture = NULL,
  texture_filename = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangmesh_+3A_x">x</code></td>
<td>
<p>raster object for mesh structure</p>
</td></tr>
<tr><td><code id="triangmesh_+3A_z">z</code></td>
<td>
<p>raster object for height values</p>
</td></tr>
<tr><td><code id="triangmesh_+3A_na.rm">na.rm</code></td>
<td>
<p>remove quads where missing values?</p>
</td></tr>
<tr><td><code id="triangmesh_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="triangmesh_+3A_texture">texture</code></td>
<td>
<p>optional input RGB raster, 3-layers</p>
</td></tr>
<tr><td><code id="triangmesh_+3A_texture_filename">texture_filename</code></td>
<td>
<p>optional input file path for PNG texture</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triangmesh()</code> generates the point-based interpretation of a raster (POINT) with the obvious continuous
interpretation. <code>dtriangmesh</code> splits the mesh so that each primitive is independent.  This is more coherent
than the analogous distinction for quadmesh, though both will appear the same on creation.
</p>
<p>The output is described as a mesh because it is a dense representation
of a continuous shape, in this case plane-filling triangles defined
by index of three of the available vertices.
</p>
<p>The <code>z</code> argument defaults to the input <code>x</code> argument, though may be set to <code>NULL</code>, a constant
numeric value, or another raster. If the coordinate system of <code>z</code> and <code>x</code> don't match the z values
are queried by reprojection.
</p>
<p>Any raster RGB object (3-layers, ranging in 0-255) may be used as
a <em>texture</em> on the resulting mesh3d object.
It is not possible to provide rgl with an object of data for texture, it must be a PNG file and so
the in-memory <code>texture</code> argument is written out to PNG file (with a message). The location of the file
may be set explicitly with <code>texture_filename</code>.  Currently it's not possible to not use the <code>texture</code> object
in-memory.
</p>


<h3>Value</h3>

<p>mesh3d (primitivetype triangle)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
r &lt;- setExtent(raster(volcano), extent(0, nrow(volcano), 0, ncol(volcano)))
tm &lt;- triangmesh(r)

## jitter the mesh just enough to show that they are distinct in the discrete case
a &lt;- dtriangmesh(r)
a$vb[3L, ] &lt;- jitter(a$vb[3L, ], factor = 10)
</code></pre>

<hr>
<h2 id='triangulate_quads'>Triangles from quads</h2><span id='topic+triangulate_quads'></span>

<h3>Description</h3>

<p>Convert quad index to triangles, this converts the 'rgl mesh3d (ib)' quad
index to the complementary triangle index '(it)'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate_quads(quad_index, clockwise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate_quads_+3A_quad_index">quad_index</code></td>
<td>
<p>the 'ib' index of quads from 'quadmesh'</p>
</td></tr>
<tr><td><code id="triangulate_quads_+3A_clockwise">clockwise</code></td>
<td>
<p>if true triangles are wound clockwise, if false
anticlockwise. This affects which faces rendering engines consider to be
the 'front' and 'back' of the triangle. If your mesh appears 'inside out',
try the alternative setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triangle pairs from each quad are interleaved in the result, so that neighbour
triangles from a single quad are together.
</p>


<h3>Value</h3>

<p>matrix of triangle indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>triangulate_quads(cbind(c(1, 2, 4, 3), c(3, 4, 6, 5)))

qm &lt;- quadmesh(raster::crop(etopo, raster::extent(140, 160, -50, -30)))
tri &lt;- triangulate_quads(qm$ib)
plot(t(qm$vb))
tri_avg &lt;- colMeans(matrix(qm$vb[3, tri], nrow = 3), na.rm = TRUE)
scl &lt;- function(x) (x - min(x))/diff(range(x))
tri_col &lt;- grey(seq(0, 1, length = 100))[scl(tri_avg) * 99 + 1]
## tri is qm$ib converted to triangles for the same vertex set
polygon(t(qm$vb)[rbind(tri, NA), ])
polygon(t(qm$vb)[rbind(tri, NA), ], col = tri_col)
</code></pre>

<hr>
<h2 id='use_crs'>In-use coordinate system</h2><span id='topic+use_crs'></span>

<h3>Description</h3>

<p>Set or return the coordinate system currently in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_crs(crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_crs_+3A_crs">crs</code></td>
<td>
<p>provide PROJ string to set the value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>crs</code> is NULL, the function returns the current value (which may be 'NULL&ldquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use_crs()
use_crs("+proj=laea +datum=WGS84")
use_crs()

## End(Not run)
</code></pre>

<hr>
<h2 id='worldll'>World raster map</h2><span id='topic+worldll'></span>

<h3>Description</h3>

<p>A rasterized version of <code>wrld_simpl</code>, created by burning the country
polygon ID number into a one-degree world raster. (This is a very
out of date polygon data set used for example only).See code in
'data-raw/worldll.R'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worldll
</code></pre>


<h3>Format</h3>

<p>An object of class <code>RasterLayer</code> of dimension 180 x 360 x 1.
</p>

<hr>
<h2 id='xymap'>World map</h2><span id='topic+xymap'></span>

<h3>Description</h3>

<p>The world coastline coordinates. A simple matrix of lon, lat, separated by NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xymap
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 82403 rows and 2 columns.
</p>


<h3>Details</h3>

<p>From the maps package, see 'data-raw/xymap.R'.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
