<!DOCTYPE html><html><head><title>Help for package TrueSkillThroughTime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TrueSkillThroughTime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Game'><p>Game</p></a></li>
<li><a href='#Gaussian'><p>Gaussian</p></a></li>
<li><a href='#History-class'><p>History</p></a></li>
<li><a href='#lc_print'><p>Print list of Gaussian using the python and julia syntax</p></a></li>
<li><a href='#Player'><p>Player</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Skill Estimation Based on a Single Bayesian Network</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-26</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gustavo Landfried &lt;gustavolandfried@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Most estimators implemented by the video game industry cannot obtain reliable initial estimates nor guarantee comparability between distant estimates. TrueSkill Through Time solves all these problems by modeling the entire history of activities using a single Bayesian network allowing the information to propagate correctly throughout the system. This algorithm requires only a few iterations to converge, allowing millions of observations to be analyzed using any low-end computer.
    The core ideas implemented in this project were developed by Dangauthier P, Herbrich R, Minka T, Graepel T (2007). "Trueskill through time: Revisiting the history of chess." <a href="https://dl.acm.org/doi/10.5555/2981562.2981605">https://dl.acm.org/doi/10.5555/2981562.2981605</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>hash, methods, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/glandfried/TrueSkillThroughTime.R">https://github.com/glandfried/TrueSkillThroughTime.R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/glandfried/TrueSkillThroughTime.R/issues">https://github.com/glandfried/TrueSkillThroughTime.R/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-26 14:42:58 UTC; landfried</td>
</tr>
<tr>
<td>Author:</td>
<td>Gustavo Landfried [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-26 15:22:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='Game'>Game</h2><span id='topic+Game'></span><span id='topic+posteriors'></span><span id='topic+posteriors+2CGame-method'></span>

<h3>Description</h3>

<p>Game class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Game(teams, result = vector(), p_draw = P_DRAW)

posteriors(g)

## S4 method for signature 'Game'
posteriors(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Game_+3A_teams">teams</code></td>
<td>
<p>A list of <code>Player</code> objects. Each position represents a team,
so it must contain a vector of <code>Player</code> objects.</p>
</td></tr>
<tr><td><code id="Game_+3A_result">result</code></td>
<td>
<p>A vector of numbers, with the score obtained by each team, or
an empty vector. The default value is an empty vector. In this case, the
outcome is defined by the order in which the <code>teams</code> list was initialized:
the teams appearing firstly in the list defeat those appearing later (no ties). If 
the list is not empty, it must have the same length as the <code>teams</code> list. In 
this last case, the team with the highest score is the winner, and the teams with 
the same score are tied.</p>
</td></tr>
<tr><td><code id="Game_+3A_p_draw">p_draw</code></td>
<td>
<p>A number, the probability of a draw. The default value is 
<code>P_DRAW = 0</code>. A rule of thumb states that the probability of a draw must be 
initialized with the observed frequency of draws. If in doubt, it is a candidate 
parameter to be optimized or integrated by the sum rule. It is used to compute 
the prior probability of the observed result, so its value may affect an 
eventual model selection task.</p>
</td></tr>
<tr><td><code id="Game_+3A_g">g</code></td>
<td>
<p>A game object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Game object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 = Player(Gaussian(mu=0, sigma=6), beta=1, gamma=0.03)
a2 = Player(); a3 = Player(); a4 = Player()
team_a = c(a1, a2)
team_b = c(a3, a4)
teams = list(team_a, team_b)

g = Game(teams) 
post = posteriors(g)
lhs = g@likelihoods
post[[1]][[1]] == lhs[[1]][[1]]*a1@prior 
ev = g@evidence
ev == 0.5

ta = c(a1)
tb = c(a2, a3)
tc = c(a4)
teams_3 = list(ta, tb, tc)
result = c(1, 0, 0)
g3 = Game(teams_3, result, p_draw=0.25)

</code></pre>

<hr>
<h2 id='Gaussian'>Gaussian</h2><span id='topic+Gaussian'></span><span id='topic+Pi'></span><span id='topic+Pi+2CGaussian-method'></span><span id='topic+Tau'></span><span id='topic+Tau+2CGaussian-method'></span><span id='topic+forget'></span><span id='topic+forget+2CGaussian+2Cnumeric+2Cnumeric-method'></span><span id='topic+isapprox'></span><span id='topic+isapprox+2CGaussian+2CGaussian+2Cnumeric-method'></span><span id='topic++2B+2CGaussian+2CGaussian-method'></span><span id='topic+-+2CGaussian+2CGaussian-method'></span><span id='topic++2A+2CGaussian+2CGaussian-method'></span><span id='topic++2F+2CGaussian+2CGaussian-method'></span><span id='topic++3D+3D+2CGaussian+2CGaussian-method'></span><span id='topic+performance+2CPlayer-method'></span>

<h3>Description</h3>

<p>Gaussian class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian(mu = 0, sigma = 1)

Pi(N)

## S4 method for signature 'Gaussian'
Pi(N)

Tau(N)

## S4 method for signature 'Gaussian'
Tau(N)

forget(N, gamma, t)

## S4 method for signature 'Gaussian,numeric,numeric'
forget(N, gamma, t)

isapprox(N, M, tol = 1e-04)

## S4 method for signature 'Gaussian,Gaussian,numeric'
isapprox(N, M, tol = 1e-04)

## S4 method for signature 'Gaussian,Gaussian'
e1 + e2

## S4 method for signature 'Gaussian,Gaussian'
e1 - e2

## S4 method for signature 'Gaussian,Gaussian'
e1 * e2

## S4 method for signature 'Gaussian,Gaussian'
e1 / e2

## S4 method for signature 'Gaussian,Gaussian'
e1 == e2

## S4 method for signature 'Player'
performance(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian_+3A_mu">mu</code></td>
<td>
<p>A number, the mean of the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_sigma">sigma</code></td>
<td>
<p>A number, the standar deviation of the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_n">N</code></td>
<td>
<p>A Gaussian object</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_gamma">gamma</code></td>
<td>
<p>The dynamic factor, the dynamic uncertainty</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_t">t</code></td>
<td>
<p>The elapsed time</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_m">M</code></td>
<td>
<p>A Gaussian object</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_tol">tol</code></td>
<td>
<p>The tolerance threshold for comparitions</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_e1">e1</code></td>
<td>
<p>A Gaussian object</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_e2">e2</code></td>
<td>
<p>A Gaussian object</p>
</td></tr>
<tr><td><code id="Gaussian_+3A_a">a</code></td>
<td>
<p>A Gaussian object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gaussian object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N01 = Gaussian(0,1); N12 = Gaussian(mu = 1, sigma = 2)
N06 = Gaussian(); Ninf = Gaussian(0,Inf)
N01 * Ninf == N01
N01 * N12
N01 / N12
N01 + N12
N01 - N12
Pi(N12) == 1/(N12@sigma^2)
Tau(N12) == N12@mu/(N12@sigma^2)
Nnew = forget(N = N01, gamma = 0.01, t = 100)
isapprox(Nnew, Gaussian(N01@mu,sqrt(N01@sigma^2+100*(0.01^2))), tol=1e-6)

</code></pre>

<hr>
<h2 id='History-class'>History</h2><span id='topic+History-class'></span><span id='topic+History'></span>

<h3>Description</h3>

<p>History class
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="History-class_+3A_composition">composition</code></td>
<td>
<p>A list of list of player's names (id). Each position of the 
list is a list that represents the teams of a game, so the latter must contain
vectors of names representing the composition of each team in that game.</p>
</td></tr>
<tr><td><code id="History-class_+3A_results">results</code></td>
<td>
<p>A list of numeric vectors, representing the outcome of each 
game. It must have the same 
length as the <code>composition</code> list or be an empty list. The default value is an empty list.
When the list is empty, the outcomes of the games are inferred by the order of
the teams in the <code>composition</code> list: the teams appearing firstly in the list 
defeat those appearing later (no ties).
When the list is not empty, each vector of the list must represents the score of each team in the game. The team with the highest score is 
the winner, and the teams with the same score are tied.</p>
</td></tr>
<tr><td><code id="History-class_+3A_times">times</code></td>
<td>
<p>A numeric vector, the timestamp of each game. It must have the 
same length as the <code>composition</code> list or be an empty list. The default value 
is an empty list. When the list is empty, all players' games are 
separated by a single timestamp, so a single dynamic uncertainty <code>gamma</code> will be added between games.
When the list is not empty, the amount of dynamic uncertainty will depend on the difference (measured in timestamps) that each player has between games.
In addition, the order of the timestamps determines the reading order of the <code>composition</code> and <code>results</code> lists.
If a player appears more than once in the same timestamp, no dynamic uncertainty will be added between those games.</p>
</td></tr>
<tr><td><code id="History-class_+3A_priors">priors</code></td>
<td>
<p>A hash object, a dictionary of <code>Player</code> objects indexed by the 
players' name (id). Used to create players with special values. The default
value is an empty hash. In this case, one <code>Player</code> object for each unique 
name in the <code>composition</code> list is automatically initialized using the values 
of the parameters <code>mu</code>, <code>sigma</code>, <code>beta</code>, and <code>gamma</code>.
The names that appear in the hash are the only ones that will be initialized 
with special values.</p>
</td></tr>
<tr><td><code id="History-class_+3A_mu">mu</code></td>
<td>
<p>A number, the prior mean. The deafult value is: <code>MU = 0</code>.</p>
</td></tr>
<tr><td><code id="History-class_+3A_sigma">sigma</code></td>
<td>
<p>A number, the prior standar deviation. The deafult value is: 
<code>SIGMA = 6</code>.</p>
</td></tr>
<tr><td><code id="History-class_+3A_beta">beta</code></td>
<td>
<p>A number, the standard deviation of the performance. The default 
value is: <code>BETA = 1</code>. The parameter <code>beta</code> acts as the scale of the 
estimates. A real difference of one <code>beta</code> between two skills is equivalent 
to 76% probability of winning.</p>
</td></tr>
<tr><td><code id="History-class_+3A_gamma">gamma</code></td>
<td>
<p>A number, the amount of uncertainty (standar deviation) added to 
the estimates between events. The default value is: <code>GAMMA = 0.03</code>.</p>
</td></tr>
<tr><td><code id="History-class_+3A_p_draw">p_draw</code></td>
<td>
<p>A number, the probability of a draw. The default value is 
<code>P_DRAW = 0</code>. A rule of thumb states that the probability of a draw must be 
initialized with the observed frequency of draws. If in doubt, it is a candidate 
parameter to be optimized or integrated by the sum rule. It is used to compute 
the prior probability of the observed result, so its value may affect an 
eventual model selection task.</p>
</td></tr>
<tr><td><code id="History-class_+3A_epsilon">epsilon</code></td>
<td>
<p>A number, the convergence threshold. Used to stop the convergence procedure. The default value is <code>EPSILON = 1e-6</code>.</p>
</td></tr>
<tr><td><code id="History-class_+3A_iterations">iterations</code></td>
<td>
<p>A number, the maximum number of iterations for convergence. Used to stop the convergence procedure. The default value is <code>ITERATIONS = 30</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>History object
</p>


<h3>Fields</h3>


<dl>
<dt><code>size</code></dt><dd><p>A number, the amount of games.</p>
</dd>
<dt><code>batches</code></dt><dd><p>A vector of <code>Batch</code> objects. Where the games that occur at the same timestamp live.</p>
</dd>
<dt><code>agents</code></dt><dd><p>A hash, a dictionary indexed by the players' name (id).</p>
</dd>
<dt><code>time</code></dt><dd><p>A boolean, indicating whether the history was initialized with timestamps or not.</p>
</dd>
<dt><code>mu</code></dt><dd><p>A number, the default prior mean in this particular <code>History</code> object</p>
</dd>
<dt><code>sigma</code></dt><dd><p>A number, the default prior standard deviation in this particular <code>History</code> object</p>
</dd>
<dt><code>beta</code></dt><dd><p>A number, the default standar deviation of the performance in this particular <code>History</code> object</p>
</dd>
<dt><code>gamma</code></dt><dd><p>A number, the default dynamic uncertainty in this particular <code>History</code> object</p>
</dd>
<dt><code>p_draw</code></dt><dd><p>A number, the probability of a draw in this particular <code>History</code> object</p>
</dd>
<dt><code>h_epsilon</code></dt><dd><p>A number, the convergence threshold in this particular <code>History</code> object</p>
</dd>
<dt><code>h_iterations</code></dt><dd><p>A number, the maximum number of iterations for convergence in this particular <code>History</code> object</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>convergence(epsilon = NA, iterations = NA, verbose = TRUE)</code></dt><dd></dd>
<dt><code>initialize(
  composition,
  results = list(),
  times = c(),
  priors = hash(),
  mu = MU,
  sigma = SIGMA,
  beta = BETA,
  gamma = GAMMA,
  p_draw = P_DRAW,
  epsilon = EPSILON,
  iterations = ITERATIONS
)</code></dt><dd></dd>
<dt><code>learning_curves()</code></dt><dd></dd>
<dt><code>log_evidence()</code></dt><dd></dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>c1 = list(c("a"),c("b"))
c2 = list(c("b"),c("c"))
c3 = list(c("c"),c("a"))
composition = list(c1,c2,c3)
h = History(composition, gamma=0.0)

trueskill_learning_curves = h$learning_curves()
ts_a = trueskill_learning_curves[["a"]]
ts_a[[1]]$N; ts_a[[2]]$N
ts_a[[1]]$t; ts_a[[2]]$t
h$convergence()
trueskillThrougTime_learning_curves = h$learning_curves()
ttt_a = trueskillThrougTime_learning_curves[["a"]]
ttt_a[[1]]$N; ttt_a[[2]]$N
ttt_a[[1]]$t; ttt_a[[2]]$t

## Not run: 
# Synthetic example
library(hash)
N = 100
skill &lt;- function(experience, middle, maximum, slope){
return(maximum/(1+exp(slope*(-experience+middle)))) }
target = skill(seq(N), N/2, 2, 0.075)
opponents = rnorm(N,target,0.5)
composition = list(); results = list(); times = c(); priors = hash()
for(i in seq(N)){composition[[i]] = list(c("a"), c(toString(i)))}
for(i in
seq(N)){results[[i]]=if(rnorm(1,target[i])&gt;rnorm(1,opponents[i])){c(1,0)}else{c(0,1)}}
for(i in seq(N)){times = c(times,i)}
for(i in seq(N)){priors[[toString(i)]] = Player(Gaussian(opponents[i],0.2))}
h = History(composition, results, times, priors, gamma=0.1)
h$convergence(); lc_a = h$learning_curves()$a; mu = c()
for(tp in lc_a){mu = c(mu,tp[[2]]@mu)}
plot(target)
lines(mu)

# Plotting learning curves

# First solve your own example. Here is a dummy one.
agents &lt;- c("a", "b", "c", "d", "e")
composition &lt;- list()
for (i in 1:500) {
 who = sample(agents, 2)
 composition[[i]] &lt;- list(list(who[1]), list(who[2]))
}
h &lt;- History(composition = composition, gamma = 0.03, sigma = 1.0)
h$convergence(iterations=6)

# Then plot some learning curves
lc &lt;- h$learning_curves()
colors &lt;- c(rgb(0.2,0.2,0.8), rgb(0.2,0.8,0.2), rgb(0.8,0.2,0.2))
colors_alpha &lt;- c(rgb(0.2,0.2,0.8,0.2), rgb(0.2,0.8,0.2,0.2), rgb(0.8,0.2,0.2,0.2))
plot(0,0, xlim = c(0, 500), ylim = c(-1, 1), xlab = "t", ylab = "skill", type = "n")
for (i in 1:3) {
  agent &lt;- agents[i]
  t &lt;- c(); mu &lt;- c(); sigma &lt;- c()
  for(x in lc[[agent]]){
    t &lt;- c(t, x$t )
    mu &lt;- c(mu, x$N@mu)
    sigma &lt;- c(sigma, x$N@sigma)
  }
  lines(t, mu, col = colors[i], lwd = 2, type = "l")
  polygon(c(t, rev(t)), c(mu + sigma, rev(mu - sigma)), col = colors_alpha[i], border = NA)
}
legend("topright", legend = agents[1:3], col = colors, lwd = 2)


## End(Not run)
</code></pre>

<hr>
<h2 id='lc_print'>Print list of Gaussian using the python and julia syntax</h2><span id='topic+lc_print'></span>

<h3>Description</h3>

<p>Print list of Gaussian using the python and julia syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc_print(lc.a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lc_print_+3A_lc.a">lc.a</code></td>
<td>
<p>List of Gaussians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, print lists of Gaussian using the python and julia syntax
</p>

<hr>
<h2 id='Player'>Player</h2><span id='topic+Player'></span><span id='topic+performance'></span>

<h3>Description</h3>

<p>Player class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Player(prior = Nms, beta = BETA, gamma = GAMMA)

performance(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Player_+3A_prior">prior</code></td>
<td>
<p>A Gaussian object, the prior belief distribution of the skills. The 
default value is: <code>Nms = Gaussian(mu = 0, sigma = 6)</code>.</p>
</td></tr>
<tr><td><code id="Player_+3A_beta">beta</code></td>
<td>
<p>A number, the standard deviation of the performance. The default 
value is: <code>BETA = 1</code>. The parameter <code>beta</code> acts as the scale of the 
estimates. A real difference of one <code>beta</code> between two skills is equivalent 
to 76% probability of winning.</p>
</td></tr>
<tr><td><code id="Player_+3A_gamma">gamma</code></td>
<td>
<p>A number, the amount of uncertainty (standar deviation) added to 
the estimates at each time step. The default value is: <code>GAMMA = 0.03</code>.</p>
</td></tr>
<tr><td><code id="Player_+3A_a">a</code></td>
<td>
<p>A Player object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Player object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 = Player(prior = Gaussian(0,6), beta = 1, gamma = 0.03); 
a2 = Player()
a1@gamma == a2@gamma 
N = performance(a1) 
N@mu == a1@prior@mu
N@sigma == sqrt(a1@prior@sigma^2 + a1@beta^2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
