<!DOCTYPE html><html><head><title>Help for package myClim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {myClim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.myClimList'><p>Extract localities with []</p></a></li>
<li><a href='#length.myClimList'><p>Length function for myClim object</p></a></li>
<li><a href='#mc_agg'><p>Aggregate data by function</p></a></li>
<li><a href='#mc_calc_cumsum'><p>Cumulative sum</p></a></li>
<li><a href='#mc_calc_fdd'><p>Freezing Degree Days</p></a></li>
<li><a href='#mc_calc_gdd'><p>Growing Degree Days</p></a></li>
<li><a href='#mc_calc_snow'><p>Snow detection from temperature</p></a></li>
<li><a href='#mc_calc_snow_agg'><p>Summary of TRUE/FALSE snow sensor</p></a></li>
<li><a href='#mc_calc_tomst_dendro'><p>Converting Tomst dendrometer values to micrometers</p></a></li>
<li><a href='#mc_calc_vpd'><p>Calculate vapor pressure deficit (in kPa)</p></a></li>
<li><a href='#mc_calc_vwc'><p>Conversion of raw TMS soil moisture values to volumetric water content (VWC)</p></a></li>
<li><a href='#mc_calib_moisture'><p>Calculates coefficients for TMS moisture conversion to VWC</p></a></li>
<li><a href='#mc_const_CALIB_MOIST_ACOR_T'><p>Default temperature drift for TMS moisture in the air.</p></a></li>
<li><a href='#mc_const_CALIB_MOIST_REF_T'><p>Default ref. temperate for TMS moisture calibration</p></a></li>
<li><a href='#mc_const_CALIB_MOIST_WCOR_T'><p>Default temperature drift for TMS moisture in the water</p></a></li>
<li><a href='#mc_const_SENSOR_count'><p>Count sensor id see <code>mc_agg()</code></p></a></li>
<li><a href='#mc_const_SENSOR_coverage'><p>Coverage sensor id see <code>mc_agg()</code></p></a></li>
<li><a href='#mc_const_SENSOR_dendro_l_um'><p>Radius difference sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_Dendro_raw'><p>Default sensor for TOMST Dendrometer radius difference</p></a></li>
<li><a href='#mc_const_SENSOR_Dendro_T'><p>Default sensor for TOMST Dendrometer temperature</p></a></li>
<li><a href='#mc_const_SENSOR_FDD'><p>Freezing Degree Days sensor id see <code>mc_calc_fdd()</code></p></a></li>
<li><a href='#mc_const_SENSOR_GDD'><p>Growing Degree Days sensor id see <code>mc_calc_gdd()</code></p></a></li>
<li><a href='#mc_const_SENSOR_HOBO_EXTT'><p>Onset HOBO external temperature sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_HOBO_RH'><p>Onset HOBO humidity sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_HOBO_T'><p>Onset HOBO temperature sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_integer'><p>General integer sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_logical'><p>General logical sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_precipitation'><p>Precipitation sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_real'><p>General real sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_RH'><p>Relative humidity sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_snow_bool'><p>Snow existence sensor id see <code>mc_calc_snow()</code></p></a></li>
<li><a href='#mc_const_SENSOR_snow_fresh'><p>Height of newly fallen snow sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_snow_total'><p>Height snow sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_sun_shine'><p>Time of sun shine sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_T_C'><p>Temperature sensor id</p></a></li>
<li><a href='#mc_const_SENSOR_Thermo_T'><p>Default sensor for TOMST Thermologger temperature</p></a></li>
<li><a href='#mc_const_SENSOR_TMS_moist'><p>Default sensor for TOMST TMS raw soil moisture</p></a></li>
<li><a href='#mc_const_SENSOR_TMS_T1'><p>Default sensor for TOMST TMS soil temperature</p></a></li>
<li><a href='#mc_const_SENSOR_TMS_T2'><p>Default sensor for TOMST TMS temperature of soil surface</p></a></li>
<li><a href='#mc_const_SENSOR_TMS_T3'><p>Default sensor for TOMST TMS air temperature</p></a></li>
<li><a href='#mc_const_SENSOR_VPD'><p>Vapor Pressure Deficit sensor id see <code>mc_calc_vpd()</code></p></a></li>
<li><a href='#mc_const_SENSOR_VWC'><p>Volumetric soil moisture sensor id see <code>mc_calc_vwc()</code></p></a></li>
<li><a href='#mc_const_SENSOR_wind_speed'><p>Speed of wind sensor id</p></a></li>
<li><a href='#mc_data_example_agg'><p>Example data in Agg-format.</p></a></li>
<li><a href='#mc_data_example_clean'><p>Example cleaned data in Raw-format.</p></a></li>
<li><a href='#mc_data_example_raw'><p>Example data in Raw-format</p></a></li>
<li><a href='#mc_data_formats'><p>Formats of source data files</p></a></li>
<li><a href='#mc_data_heights'><p>Default heights of sensors</p></a></li>
<li><a href='#mc_data_physical'><p>Physical quantities definition</p></a></li>
<li><a href='#mc_data_sensors'><p>Sensors definition.</p></a></li>
<li><a href='#mc_data_vwc_parameters'><p>Volumetric water content parameters</p></a></li>
<li><a href='#mc_DataFormat-class'><p>Class for Logger File Data Format</p></a></li>
<li><a href='#mc_env_moist'><p>Standardised myClim soil moisture variables</p></a></li>
<li><a href='#mc_env_temp'><p>Standardised myClim temperature variables</p></a></li>
<li><a href='#mc_env_vpd'><p>Standardised myClim vapor pressure deficit variables</p></a></li>
<li><a href='#mc_filter'><p>Filter data from myClim object</p></a></li>
<li><a href='#mc_HOBODataFormat-class'><p>Class for reading HOBO logger files</p></a></li>
<li><a href='#mc_info'><p>Get sensors info table</p></a></li>
<li><a href='#mc_info_clean'><p>Call cleaning log</p></a></li>
<li><a href='#mc_info_count'><p>Count data</p></a></li>
<li><a href='#mc_info_join'><p>Get joining info table</p></a></li>
<li><a href='#mc_info_logger'><p>Get loggers info table</p></a></li>
<li><a href='#mc_info_meta'><p>Get localities metadata table</p></a></li>
<li><a href='#mc_join'><p>Joining time-series from repeated downloads</p></a></li>
<li><a href='#mc_load'><p>Load myClim object</p></a></li>
<li><a href='#mc_LocalityMetadata-class'><p>Class for locality metadata</p></a></li>
<li><a href='#mc_LoggerCleanInfo-class'><p>Class for logger clean info</p></a></li>
<li><a href='#mc_LoggerMetadata-class'><p>Class for logger metadata</p></a></li>
<li><a href='#mc_MainMetadata-class'><p>Class for myClim object metadata</p></a></li>
<li><a href='#mc_MainMetadataAgg-class'><p>Class for myClim object metadata in Agg-format</p></a></li>
<li><a href='#mc_Physical-class'><p>Class for physical</p></a></li>
<li><a href='#mc_plot_image'><p>Plot data - image</p></a></li>
<li><a href='#mc_plot_line'><p>Plot data - ggplot2 geom_line</p></a></li>
<li><a href='#mc_plot_loggers'><p>Plot data from loggers</p></a></li>
<li><a href='#mc_plot_raster'><p>Plot data - ggplot2 geom_raster</p></a></li>
<li><a href='#mc_prep_calib'><p>Sensors calibration</p></a></li>
<li><a href='#mc_prep_calib_load'><p>Load sensor calibration parameters to correct microclimatic records</p></a></li>
<li><a href='#mc_prep_clean'><p>Cleaning datetime series</p></a></li>
<li><a href='#mc_prep_crop'><p>Crop datetime</p></a></li>
<li><a href='#mc_prep_fillNA'><p>Fill NA</p></a></li>
<li><a href='#mc_prep_merge'><p>Merge myClim objects</p></a></li>
<li><a href='#mc_prep_meta_locality'><p>Set metadata of localities</p></a></li>
<li><a href='#mc_prep_meta_sensor'><p>Set metadata of sensors</p></a></li>
<li><a href='#mc_prep_solar_tz'><p>Set solar time offset against UTC time</p></a></li>
<li><a href='#mc_prep_TMSoffsoil'><p>Detection of out-of-soil measurements from TMS logger</p></a></li>
<li><a href='#mc_read_data'><p>Reading files with locality metadata</p></a></li>
<li><a href='#mc_read_files'><p>Reading files or directories</p></a></li>
<li><a href='#mc_read_long'><p>Reading data from long data.frame</p></a></li>
<li><a href='#mc_read_tubedb'><p>Reading data from TubeDB</p></a></li>
<li><a href='#mc_read_wide'><p>Reading data from wide data.frame</p></a></li>
<li><a href='#mc_reshape_long'><p>Export values to long table</p></a></li>
<li><a href='#mc_reshape_wide'><p>Export values to wide table</p></a></li>
<li><a href='#mc_save'><p>Save myClim object</p></a></li>
<li><a href='#mc_Sensor-class'><p>Class for sensor definition</p></a></li>
<li><a href='#mc_SensorMetadata-class'><p>Class for sensor metadata</p></a></li>
<li><a href='#mc_TOMSTDataFormat-class'><p>Class for reading TOMST logger files</p></a></li>
<li><a href='#mc_TOMSTJoinDataFormat-class'><p>Class for reading TMS join files</p></a></li>
<li><a href='#myClim-package'><p>myClim: Microclimatic Data Processing</p></a></li>
<li><a href='#myClimList'><p>Custom list for myClim object</p></a></li>
<li><a href='#print.myClimList'><p>Print function for myClim object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Microclimatic Data Processing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://labgis.ibot.cas.cz/myclim/index.html">http://labgis.ibot.cas.cz/myclim/index.html</a>,
<a href="https://github.com/ibot-geoecology/myClim">https://github.com/ibot-geoecology/myClim</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Handling the microclimatic data in R. The 'myClim' workflow begins
    at the reading data primary from microclimatic dataloggers,
    but can be also reading of meteorological station data from files.
    Cleaning time step, time zone settings and metadata collecting is the next step of the work flow.
    With 'myClim' tools one can crop, join, downscale, and convert microclimatic data formats, sort them into localities,
    request descriptive characteristics and compute microclimatic variables.
    Handy plotting functions are provided with smart defaults.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, lubridate, tibble, dplyr, purrr, tidyr, ggplot2,
ggforce, viridis, data.table, plotly, zoo, methods, vroom,
progress</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://ibot-geoecology.github.io/drat">https://ibot-geoecology.github.io/drat</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, kableExtra, rTubeDB, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-13 15:03:57 UTC; jules</td>
</tr>
<tr>
<td>Author:</td>
<td>Matěj Man [aut],
  Vojtěch Kalčík [aut, cre],
  Martin Macek [aut],
  Josef Brůna [aut],
  Lucia Hederová [aut],
  Jan Wild [aut],
  Martin Kopecký [aut],
  Institute of Botany of the Czech Academy of Sciences [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vojtěch Kalčík &lt;Vojtech.Kalcik@ibot.cas.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-16 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.myClimList'>Extract localities with []</h2><span id='topic++5B.myClimList'></span>

<h3>Description</h3>

<p>Using [] for extract localities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'myClimList'
x[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.myClimList_+3A_x">x</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="+2B5B.myClimList_+3A_...">...</code></td>
<td>
<p>indexes for extract localities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>myClim object with subset of localities see <a href="#topic+myClim-package">myClim-package</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filtered_data &lt;- mc_data_example_raw[1:2]
</code></pre>

<hr>
<h2 id='length.myClimList'>Length function for myClim object</h2><span id='topic+length.myClimList'></span>

<h3>Description</h3>

<p>Function return number of localities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'myClimList'
length(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.myClimList_+3A_x">x</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="length.myClimList_+3A_...">...</code></td>
<td>
<p>other parameters from function length</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>length(mc_data_example_agg)
</code></pre>

<hr>
<h2 id='mc_agg'>Aggregate data by function</h2><span id='topic+mc_agg'></span>

<h3>Description</h3>

<p>mc_agg has two basic uses:
</p>

<ul>
<li><p> aggregate (upscale) time step of microclimatic records with specified function (e. g. 15 min records to daily mean);
</p>
</li>
<li><p> convert myClim object from Raw-format to Agg-format see <a href="#topic+myClim-package">myClim-package</a> without time-series modification,
this behavior appears when <code>fun=NULL</code>, <code>period=NULL</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mc_agg(
  data,
  fun = NULL,
  period = NULL,
  use_utc = TRUE,
  percentiles = NULL,
  min_coverage = 1,
  custom_start = NULL,
  custom_end = NULL,
  custom_functions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_agg_+3A_data">data</code></td>
<td>
<p>cleaned myClim object in Raw-format: output of <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code> or Agg-format as it is allowed to aggregate data multiple times.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_fun">fun</code></td>
<td>
<p>aggregation function; one of (<code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"percentile"</code>, <code>"sum"</code>, <code>"range"</code>, <code>"count"</code>, <code>"coverage"</code>)
and functions defined in <code>custom_functions</code>. See details of custom_functions argument.
Can be single function name, character vector of function names or named list of vector function names.
Named list of functions allows apply different function(s) to different sensors e.g. <code>list(TMS_T1=c("max", "min"), TMS_T2="mean", TMS_T3_GDD="sum")</code>
if NULL records are not aggregated, but myClim object is only converted to Agg-format without modifing time-series. See details.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_period">period</code></td>
<td>
<p>Time period for aggregation - same as breaks in cut.POSIXt, e.g. (<code>"hour"</code>, <code>"day"</code>, <code>"month"</code>); if NULL then no aggregation
</p>
<p>There are special periods <code>"all"</code> and <code>"custom"</code>. Period <code>"all"</code> returning single value for each sensor based
on function applied across all records within the sensor.
Period <code>"custom"</code> aggregates data in yearly cycle. You can aggregate e.g. water year, vegetation season etc. by providing start, end datetime.
See <code>custom_start</code> and <code>custom_end</code> parameters. The output of special periods <code>"all"</code> and <code>"custom"</code>are not allowed to be aggregated
again in <code><a href="#topic+mc_agg">mc_agg()</a></code> function, regardless multiple aggregations are allowed in general.
</p>
<p>Start day of week is Monday.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_use_utc">use_utc</code></td>
<td>
<p>default TRUE using UTC time, if set FALSE, the time is shifted by offset if available in locality metadata.
Shift can be e.g. to solar time <code><a href="#topic+mc_prep_solar_tz">mc_prep_solar_tz()</a></code> or political time with custom offset <code><a href="#topic+mc_prep_meta_locality">mc_prep_meta_locality()</a></code>).
Non-UTC time can by used only for aggregation of the data with period shorter than <code>day</code> (seconds, minutes, hours) into period <code>day</code> and longer.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_percentiles">percentiles</code></td>
<td>
<p>vector of percentile numbers; numbers are from range 0-100; each specified percentile number generate new virtual sensor, see details</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_min_coverage">min_coverage</code></td>
<td>
<p>value from range 0-1 (default 1); the threshold specifying how many missing values can you accept within aggregation period.
e.g. when aggregating from 15 min to monthly mean and set <code>min_coverage=1</code> then a single NA value within the specific month cause monthly mean = NA.
When <code>min_coverage=0.9</code> then you will get your monthly mean in case there are no more than 10 % missing values, if there were more than 10% you will get NA.
Ignored for functions <code>count</code> and <code>coverage</code></p>
</td></tr>
<tr><td><code id="mc_agg_+3A_custom_start">custom_start</code></td>
<td>
<p>date of start, only use for <code>custom</code> period (default NULL); Character in format <code>"mm-dd"</code> or <code>"mm-dd H:MM"</code> recycled in yearly cycle for time-series longer than 1 year.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_custom_end">custom_end</code></td>
<td>
<p>date of end only use for <code>custom</code> period (default NULL); If NULL then calculates in year cycle ending on <code>custom_start</code> next year. (useful e.g. for hydrological year)
When custom_end is provided, then data out of range <code>custom_start</code>-<code>custom_end</code> are ignored.
Character in format <code>"mm-dd"</code> or <code>"mm-dd H:MM"</code>. <code>custom_end</code> row (the last record) is not included. I.e.complete daily data from year 2020 ends in 2021-01-01 <code>custom_end="01-01"</code>.</p>
</td></tr>
<tr><td><code id="mc_agg_+3A_custom_functions">custom_functions</code></td>
<td>
<p>user define one or more functions in format <code>list(function_name=function(values){...})</code>; then you will feed function_name(s)
you defined to the <code>fun</code> parameter. e.g. <code>custom_functions = list(positive_count=function(x){length(x[x&gt;0])})</code>,
<code>fun="positive_count"</code>,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any output of mc_agg is in Agg-format. That means the
hierarchical level of logger is removed (Locality&lt;-Logger&lt;-Sensor&lt;-Record), and all microclimatic records within
the sensors are on the level of locality (Locality&lt;-Sensor&lt;-Record). See <a href="#topic+myClim-package">myClim-package</a>.
</p>
<p>In case <code>mc_agg()</code> is used only for conversion from Raw-format to Agg-format (<code style="white-space: pre;">&#8288;fun=NULL, period=NULL&#8288;</code>) then microclimatic
records are not modified. Equal step in all sensors is required for conversion from Raw-format to Agg-format, otherwise
period must be specified.
</p>
<p>When fun and period are specified, microclimatic records are aggregated based on a selected function into a specified period.
The name of the aggregated variable will contain also the name of the function used for the aggregation (e.g. TMS_T1_mean).
Aggregated time step is named after the first time step of selected period i.e. day = c(2022-12-29 00:00, 2022-12-30 00:00...);
week = c(2022-12-19 00:00, 2022-12-28 00:00...); month = c(2022-11-01 00:00, 2022-12-01 00:00...);
year = c(2021-01-01 00:00, 2022-01-01 00:00...).
When first or last period is incomplete in original data, the incomplete part is extended with NA values to match specified period.
For example, when you want to aggregate time-series to monthly mean, but your time-series starts on January 15 ending December 20,
myClim will extend the time-series to start on January 1 and end on December 31.
If you want to still use the data from the aggregation periods with not complete data coverage, you can adjust the parameter <code>min_coverage</code>.
</p>
<p>Empty sensors with no records are excluded. <code>mc_agg()</code> return NA for empty vector except from <code>fun=count</code> which returns 0.
When aggregation functions are provided as vector or list e.g. c(mean, min, max), than they are all applied to all the sensors
and multiple results are returned from each sensors. When named list (names are the sensor ids) of functions is provided then <code>mc_agg()</code>
apply specific functions to the specific sensors based on the named list <code>list(TMS_T1=c("max", "min"), TMS_T2="mean")</code>.
mc_agg returns new sensors on the localities putting aggregation
function in its name (TMS_T1 -&gt; TMS_T1_max), despite sensor names contains aggregation
function, sensor_id stays the same as before aggregation in sensor metadata (e.g. TMS_T1 -&gt; TMS_T1).
Sensors created with functions <code>min</code>, <code>max</code>, <code>mean</code>, <code>percentile</code>, <code>sum</code>, <code>range</code>
keeps identical sensor_id and value_type as original input sensors.
When function <code>sum</code> is applied on <code>logical</code> sensor (e.g. snow as TRUE, FALSE) the
output is  <code>integer</code> i.e. number of <code>TRUE</code> values.
</p>
<p>Sensors created with functions <code>count</code> has sensor_id <code>count</code> and value_type <code>integer</code>,
function  <code>coverage</code> has sensor_id <code>coverage</code> and value_type <code>real</code>
</p>


<h3>Value</h3>

<p>Returns new myClim object in Agg-format see <a href="#topic+myClim-package">myClim-package</a> When fun=NULL, period=NULL
records are not modified but only converted to Agg-format.
When fun and period are provided then time step is aggregated based on function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hour_data &lt;- mc_agg(mc_data_example_clean, c("min", "max", "percentile"),
                              "hour", percentiles = 50, min_coverage=0.5)
day_data &lt;- mc_agg(mc_data_example_clean, list(TMS_T1=c("max", "min"), TMS_T2="mean"),
                             "day", min_coverage=1)
month_data &lt;- mc_agg(mc_data_example_clean, fun=list(TMS_T3="below5"),period = "month",
                               custom_functions = list(below5=function(x){length(x[x&lt;(-5)])}))
</code></pre>

<hr>
<h2 id='mc_calc_cumsum'>Cumulative sum</h2><span id='topic+mc_calc_cumsum'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on locality within the myClim data object.
The virtual sensor represents the cumulative sum of the values on the input sensor.
Names of new sensors are original sensor name + <code>outpus_suffix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_cumsum(data, sensors, output_suffix = "_cumsum", localities = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_cumsum_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_cumsum_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors on which to calculate cumulative sum</p>
</td></tr>
<tr><td><code id="mc_calc_cumsum_+3A_output_suffix">output_suffix</code></td>
<td>
<p>name suffix for virtual sensor names (default &quot;_cumsum&quot;) e.g. TMS_T3_cumsum</p>
</td></tr>
<tr><td><code id="mc_calc_cumsum_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids for calculation; if NULL then all (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If value type of sensor is logical, then output type is integer. (TRUE, TRUE, FALSE -&gt; 2)
</p>


<h3>Value</h3>

<p>The same myClim object as input but with added cumsum sensors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumsum_data &lt;- mc_calc_cumsum(mc_data_example_agg, c("TMS_T1", "TMS_T2"))
</code></pre>

<hr>
<h2 id='mc_calc_fdd'>Freezing Degree Days</h2><span id='topic+mc_calc_fdd'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on locality within the myClim data object.
The new virtual sensor provides FDD Freezing Degree Days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_fdd(data, sensor, output_prefix = "FDD", t_base = 0, localities = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_fdd_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_fdd_+3A_sensor">sensor</code></td>
<td>
<p>name of temperature sensor used for FDD calculation e.g. TMS_T3 see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_calc_fdd_+3A_output_prefix">output_prefix</code></td>
<td>
<p>name prefix of new FDD sensor (default &quot;FDD&quot;)
</p>
<p>name of output sensor consists of output_prefix and value t_base (FDD0_TMS_T3)</p>
</td></tr>
<tr><td><code id="mc_calc_fdd_+3A_t_base">t_base</code></td>
<td>
<p>threshold temperature for FDD calculation (default 0)</p>
</td></tr>
<tr><td><code id="mc_calc_fdd_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids for calculation; if NULL then all (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The allowed step length for FDD calculation is day and shorter.
Function creates a new virtual sensor with the same time step as input data.
For shorter time steps than the day (which is however not intuitive for FDD)
the FDD value is the contribution of the time step to the freezing degree day.
Be careful while aggregating freezing degree days to longer periods
only meaningful aggregation function is <code>sum</code>, but myClim allows you to apply anything see <code><a href="#topic+mc_agg">mc_agg()</a></code>.
</p>
<p>Note that FDD is always positive number, despite summing freezing events. When you set
<code>t_base=-1</code> you get the sum of degree days below -1 °C but expressed in positive number
if you set <code>t_base=1</code> you get also positive number. Therefore pay attention to
name of output variable which contains <code>t_base</code> value. FDD1_TMS_T3, t_base=1 vs FDDminus1_TMS_T3, t_base=-1
</p>


<h3>Value</h3>

<p>The same myClim object as input but with added virtual FDD sensor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fdd_data &lt;- mc_calc_fdd(mc_data_example_agg, "TMS_T3", localities = c("A2E32", "A6W79"))
fdd_agg &lt;- mc_agg(fdd_data, list(TMS_T3=c("min", "max"), FDD5="sum"), period="day")
</code></pre>

<hr>
<h2 id='mc_calc_gdd'>Growing Degree Days</h2><span id='topic+mc_calc_gdd'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor for each locality within myClim data object. The new virtual sensor
provides values of GDD (Growing Degree Days) in degees Celsius for each time step in the original timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_gdd(data, sensor, output_prefix = "GDD", t_base = 5, localities = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_gdd_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_gdd_+3A_sensor">sensor</code></td>
<td>
<p>name of temperature sensor used for GDD calculation e.g. TMS_T3 see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_calc_gdd_+3A_output_prefix">output_prefix</code></td>
<td>
<p>name prefix of new GDD sensor (default &quot;GDD&quot; -&gt; &quot;GDD5_TMS_T3&quot;)
name of output sensor consists of output_prefix and value t_base e.g. GDD5</p>
</td></tr>
<tr><td><code id="mc_calc_gdd_+3A_t_base">t_base</code></td>
<td>
<p>base temperature for calculation of GDD (default 5°C)</p>
</td></tr>
<tr><td><code id="mc_calc_gdd_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids for calculation; if NULL then all (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function calculates growing degree days as follows:  GDD = max(0;(T - Tbase)) . period(days)
The maximum allowed time step length for GDD calculation is one day.
Function creates a new virtual sensor with the same time step as input data.
For shorter time steps than one day, the GDD value is the contribution
of the interval to the growing degree day, assuming constant temperature over this period.
Be careful while aggregating growing degree days to longer periods, because only meaningful aggregation function here is <code>sum</code>,
but myClim let you apply any aggregation function see <code><a href="#topic+mc_agg">mc_agg()</a></code>.
</p>


<h3>Value</h3>

<p>The same myClim object as input but with added virtual GDD sensor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdd_data &lt;- mc_calc_gdd(mc_data_example_agg, "TMS_T3", localities = c("A2E32", "A6W79"))
gdd_agg &lt;- mc_agg(gdd_data, list(TMS_T3=c("min", "max"), GDD5="sum"), period="day")
</code></pre>

<hr>
<h2 id='mc_calc_snow'>Snow detection from temperature</h2><span id='topic+mc_calc_snow'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on locality within the myClim data object.
Virtual sensor hosts values of snow cover presence/absence detected from temperature time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_snow(
  data,
  sensor,
  output_sensor = "snow",
  localities = NULL,
  range = 1,
  tmax = 1.25,
  days = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_snow_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_sensor">sensor</code></td>
<td>
<p>name of temperature sensor used for snow estimation. (e.g. TMS_T2)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_output_sensor">output_sensor</code></td>
<td>
<p>name of output snow sensor (default &quot;snow&quot;)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids where snow will be calculated; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_range">range</code></td>
<td>
<p>maximum temperature range threshold for snow-covered sensor (default 1°C)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_tmax">tmax</code></td>
<td>
<p>maximum temperature threshold for snow-covered sensor  (default 1.25°C)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_+3A_days">days</code></td>
<td>
<p>number of days to be used for moving-window for snow detection algorithm (default 3 days)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function detects snow cover from temperature time-series. Temperature sensor is considered as covered by snow
when the maximal temperature in the preceding or subsequent time-window (specified by <code>days</code> param)
does not exceed specific <code>tmax</code> threshold value (default 1.25°C) and the temperature range remain below specified
<code>range</code> threshold (default 1°C). This function rely on insulating effect of a of snow layer,
significantly reducing diurnal temperature variation and restricting the maximal temperature near the ground
close to freezing point. Temperature sensor near the ground (<code>TMS_T2</code>) is default choice for snow-cover detection from Tomst TMS loggers.
Snow detection with default values accurately detects snow of depth &gt; 15cm (unpublished data).
For detection of thin snow, range parameter should be set to 3-4 °C.
The function returns vector of snow cover (TRUE/FLASE) with same time-step as input data. To get number of days with snow cover
and more snow summary characteristics use <a href="#topic+mc_calc_snow_agg">mc_calc_snow_agg</a> after snow detection.
</p>


<h3>Value</h3>

<p>myClim object with added virtual sensor 'snow' (logical) indicating snow presence/absence (TRUE/FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_calc_snow(mc_data_example_agg, "TMS_T2", output_sensor="TMS_T2_snow",
                     localities = c("A2E32", "A6W79"))
</code></pre>

<hr>
<h2 id='mc_calc_snow_agg'>Summary of TRUE/FALSE snow sensor</h2><span id='topic+mc_calc_snow_agg'></span>

<h3>Description</h3>

<p>This function works with the virtual snow sensor of TRUE/FALSE
which is the output of <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code>. So, before calling
<code>mc_calc_snow_agg</code> you need to calculate or import <code>mc_read_</code>
TRUE/FALSE snow sensor.
<code>mc_calc_snow_agg</code> returns the summary table of snow sensor
(e.g number of days with snow cover, first and last date of continual
snow cover longer than input period).
The snow summary is returned for whole date range provided. And is returned as
new data.frame in contrast with other mc_calc functions returning virtual sensors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_snow_agg(
  data,
  snow_sensor = "snow",
  localities = NULL,
  period = 3,
  use_utc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_snow_agg_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a> with TRUE/FALSE snow sensor see <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code></p>
</td></tr>
<tr><td><code id="mc_calc_snow_agg_+3A_snow_sensor">snow_sensor</code></td>
<td>
<p>name of snow sensor containing TRUE/FALS snow detection, suitable for virtual sensors created by function <code>mc_calc_snow</code>; (default &quot;snow&quot;)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_agg_+3A_localities">localities</code></td>
<td>
<p>optional subset of localities where to run the function (list of locality_ids); if NULL then return all localities (default NULL)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_agg_+3A_period">period</code></td>
<td>
<p>number of days defining the continual snow cover period of interest (default 3 days)</p>
</td></tr>
<tr><td><code id="mc_calc_snow_agg_+3A_use_utc">use_utc</code></td>
<td>
<p>if set FALSE then time is shifted based on offset provided in locality metadata <code>tz_offset</code>, see e.g. <code><a href="#topic+mc_prep_solar_tz">mc_prep_solar_tz()</a></code>, <code><a href="#topic+mc_prep_meta_locality">mc_prep_meta_locality()</a></code>; (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Primary designed for virtual snow sensor calculated by <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code>,
but accepts any sensor with TRUE/FLAST snow event detection. If <code>snow_sensor</code>
on the locality is missing, then locality is skipped.
</p>


<h3>Value</h3>

<p>Returns data.frame with columns:
</p>

<ul>
<li><p> locality - locality id
</p>
</li>
<li><p> snow_days - number of days with snow cover
</p>
</li>
<li><p> first_day - first day with snow
</p>
</li>
<li><p> last_day - last day with snow
</p>
</li>
<li><p> first_day_period - first day of period with continual snow cover based on <code>period</code> parameter
</p>
</li>
<li><p> last_day_period - last day of period with continual snow cover based on <code>period</code> parameter
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_calc_snow(mc_data_example_agg, "TMS_T2", output_sensor="TMS_T2_snow",
                     localities = c("A2E32", "A6W79"))
mc_calc_snow_agg(data, "TMS_T2_snow")
</code></pre>

<hr>
<h2 id='mc_calc_tomst_dendro'>Converting Tomst dendrometer values to micrometers</h2><span id='topic+mc_calc_tomst_dendro'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on locality within the myClim data object.
The virtual sensor provides the values of the change in stem size converted from raw
Tomst units to micrometers. Note that newer versions of Tomst Lolly
software can directly convert raw Tomst units to micrometers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_tomst_dendro(
  data,
  dendro_sensor = mc_const_SENSOR_Dendro_raw,
  output_sensor = mc_const_SENSOR_dendro_l_um,
  localities = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_tomst_dendro_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_tomst_dendro_+3A_dendro_sensor">dendro_sensor</code></td>
<td>
<p>name of change in stem size sensor to be converted from raw to micrometers (default &quot;Dendro_raw&quot;) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_calc_tomst_dendro_+3A_output_sensor">output_sensor</code></td>
<td>
<p>name of new change in stem size sensor (default &quot;dendro_l_um&quot;)</p>
</td></tr>
<tr><td><code id="mc_calc_tomst_dendro_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids for calculation; if NULL then all (default NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>myClim object same as input but with added dendro_l_um sensor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>agg_data &lt;- mc_calc_tomst_dendro(mc_data_example_agg, localities="A1E05")
</code></pre>

<hr>
<h2 id='mc_calc_vpd'>Calculate vapor pressure deficit (in kPa)</h2><span id='topic+mc_calc_vpd'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on locality within the myClim data object.
The virtual sensor represents the vapor pressure deficit (in kPa) calculated
from temperature and relative air humidity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_vpd(
  data,
  temp_sensor = "HOBO_T",
  rh_sensor = "HOBO_RH",
  output_sensor = "VPD",
  elevation = 0,
  metadata_elevation = TRUE,
  localities = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_vpd_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_temp_sensor">temp_sensor</code></td>
<td>
<p>name of temperature sensor. Temperature sensor must be in T_C physical.</p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_rh_sensor">rh_sensor</code></td>
<td>
<p>name of relative air humidity sensor. Humidity sensor must be in RH physical.</p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_output_sensor">output_sensor</code></td>
<td>
<p>name of new virtual VPD sensor (default &quot;VPD&quot;)</p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_elevation">elevation</code></td>
<td>
<p>value in meters (default 0)</p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_metadata_elevation">metadata_elevation</code></td>
<td>
<p>if TRUE then elevation from metadata of locality is used (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_calc_vpd_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids for calculation; if NULL then all (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equation are from the CR-5 Users Manual 2009–12 from Buck Research. These equations have been modified from Buck (1981)
and adapted by Jones, 2013 (eq. 5.15)
Elevation to pressure conversion function uses eq. 3.7 from Campbell G.S. &amp; Norman J.M. (1998).
</p>


<h3>Value</h3>

<p>myClim object same as input but with added VPD sensor
</p>


<h3>References</h3>

<p>Jones H.G. (2014) Plants and Microclimate, Third Edit. Cambridge University Press, Cambridge
Buck A.L. (1981) New equations for computing vapor pressure and enhancment factor. Journal of Applied Meteorology 20: 1527–1532.
Campbell G.S. &amp; Norman J.M. (1998). An Introduction to Environmental Biophysics, Springer New York, New York, NY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>agg_data &lt;- mc_calc_vpd(mc_data_example_agg, "HOBO_T", "HOBO_RH", localities="A2E32")
</code></pre>

<hr>
<h2 id='mc_calc_vwc'>Conversion of raw TMS soil moisture values to volumetric water content (VWC)</h2><span id='topic+mc_calc_vwc'></span>

<h3>Description</h3>

<p>This function creates a new virtual sensor on the locality within the myClim data object.
Function converts the raw TMS soil moisture (scaled TDT signal)
to volumetric water content (VWC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calc_vwc(
  data,
  moist_sensor = mc_const_SENSOR_TMS_moist,
  temp_sensor = mc_const_SENSOR_TMS_T1,
  output_sensor = "VWC_moisture",
  soiltype = "universal",
  localities = NULL,
  ref_t = mc_const_CALIB_MOIST_REF_T,
  acor_t = mc_const_CALIB_MOIST_ACOR_T,
  wcor_t = mc_const_CALIB_MOIST_WCOR_T,
  frozen2NA = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calc_vwc_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_moist_sensor">moist_sensor</code></td>
<td>
<p>name of soil moisture sensor to be converted from TMS
moisture values to volumetric water content (default &quot;TMS_moist&quot;) see <code>names(mc_data_sensors)</code>.
Soil moisture sensor must be in moisture_raw physical units see <code>names(mc_data_physical)</code>.</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_temp_sensor">temp_sensor</code></td>
<td>
<p>name of soil temperature sensor (default &quot;TMS_T1&quot;)
see <code>names(mc_data_sensors)</code>. Temperature sensor must be in T_C physical units.</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_output_sensor">output_sensor</code></td>
<td>
<p>name of new virtual sensor with VWC values (default &quot;VWC_moisture&quot;)</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_soiltype">soiltype</code></td>
<td>
<p>Either character corresponding to one of <code>soiltype</code> from <a href="#topic+mc_data_vwc_parameters">mc_data_vwc_parameters</a>
(default <code>"universal"</code>), or a list with parameters <code>a</code>, <code>b</code> and <code>c</code> provided
by the user as a <code>list(a=Value_1, b=Value_2, c=Value_3)</code>.</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_localities">localities</code></td>
<td>
<p>list of locality_ids used for calculation; if NULL then all localities are used (default NULL)</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_ref_t">ref_t</code></td>
<td>
<p>(default 24)</p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_acor_t">acor_t</code></td>
<td>
<p>(default 1.91132689118083) correction parameter for temperature drift
in the air, see <code><a href="#topic+mc_calib_moisture">mc_calib_moisture()</a></code></p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_wcor_t">wcor_t</code></td>
<td>
<p>(default 0.64108) correction parameter for temperature drift
in the water, see <code><a href="#topic+mc_calib_moisture">mc_calib_moisture()</a></code></p>
</td></tr>
<tr><td><code id="mc_calc_vwc_+3A_frozen2na">frozen2NA</code></td>
<td>
<p>if TRUE then VWC values are set to NA when the soil temperature is below 0 °C (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is suitable for TOMST TMS loggers measuring soil moisture in raw TMS units.
The raw TMS units represents inverted and numerically rescaled (1-4095) electromagnetic signal from the moisture sensor working
on Time Domain Transmission principle (Wild et al. 2019). For TMS4 logger, the typical raw TMS moisture values range from cca
115 units in dry air to cca 3635 units in distilled water - see <a href="#topic+mc_calib_moisture">mc_calib_moisture</a>.
</p>
<p>Raw TMS moisture values can be converted to the soil volumetric water content with calibration curves. The function provides
several experimentally derived calibration curves which were developped at reference temperature. To account for the difference
between reference and actual temperature, the function uses actual soil temperature values measured by TMS_T1 soil temperature
sensor.
</p>
<p>The default calibration curve is &quot;universal&quot;, which was designed for mineral soils (see Kopecký et al. 2021).
Specific calibration curves were developed for several soil types (see Wild et al. 2019) and the user can choose one of these
or can define its own calibration - see <a href="#topic+mc_data_vwc_parameters">mc_data_vwc_parameters</a>
</p>
<p>Currently available calibration curves are: sand, loamy sand A,
loamy sand B, sandy loam A, sandy loam B, loam, silt loam, peat, water,
universal, sand TMS1, loamy sand TMS1, silt loam TMS1.
For details see <a href="#topic+mc_data_vwc_parameters">mc_data_vwc_parameters</a>.
</p>
<p>It is also possible to define a new calibarion function with custom parameters <code>a</code>, <code>b</code> and <code>c</code>. These can be
derived e.g. from TOMST TMS Calibr utility after entering custom ratio of clay, silt, sand.
</p>
<p><strong>Warning:</strong> TOMST TMS Calibr utility was developed for TMS3 series of TMS loggers, which have
different range of raw soil moisture values than TMS4 series.
</p>
<p>The function by default replace the moisture records in frozen soils with NA (param <em>frozen2NA</em>),
because the TMS soil moisture sensor was not designed to measure in frozen soils and the returned values are thus not comparable
with values from non-frozen soil.
</p>


<h3>Value</h3>

<p>myClim object same as input but with added virtual VWC moisture sensor
</p>


<h3>References</h3>

<p>Wild, J., Kopecký, M., Macek, M., Šanda, M., Jankovec, J., Haase, T. (2019) Climate at ecologically relevant scales:
A new temperature and soil moisture logger for long-term microclimate measurement. Agriculture and Forest Meteorology 268, 40-47.
https://doi.org/10.1016/j.agrformet.2018.12.018
</p>
<p>Kopecký, M., Macek, M., Wild, J. (2021) Topographic Wetness Index calculation guidelines based on measured soil
moisture and plant species composition. Science of the Total Environment 757, 143785. https://doi.org/10.1016/j.scitotenv.2020.143785
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_data_vwc_parameters">mc_data_vwc_parameters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- mc_calc_vwc(mc_data_example_agg, soiltype="sand", localities="A2E32")
data2 &lt;- mc_calc_vwc(mc_data_example_agg, localities="A2E32",
                     soiltype=list(a=-3.00e-09, b=0.000161192, c=-0.109956505))
</code></pre>

<hr>
<h2 id='mc_calib_moisture'>Calculates coefficients for TMS moisture conversion to VWC</h2><span id='topic+mc_calib_moisture'></span>

<h3>Description</h3>

<p>Specialized function for calibration of TOMST TMS moisture sensor.
Function calculate correction parameters for individual logger (slope and intercept)
from TMS moisture measurements in demineralized water and dry air.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_calib_moisture(
  raw_air,
  raw_water,
  t_air = 24,
  t_water = 24,
  ref_air = 114.534,
  ref_water = 3634.723,
  ref_t = mc_const_CALIB_MOIST_REF_T,
  acor_t = mc_const_CALIB_MOIST_ACOR_T,
  wcor_t = mc_const_CALIB_MOIST_WCOR_T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_calib_moisture_+3A_raw_air">raw_air</code></td>
<td>
<p>Raw TMS moisture signal in air</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_raw_water">raw_water</code></td>
<td>
<p>Raw TMS moisture signal in water</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_t_air">t_air</code></td>
<td>
<p>temperature of air (default 24)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_t_water">t_water</code></td>
<td>
<p>temperature of water (default 24)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_ref_air">ref_air</code></td>
<td>
<p>raw air signal of reference logger used to derive soil calibration parameters (default 114.534)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_ref_water">ref_water</code></td>
<td>
<p>raw air signal of reference logger used to derive soil calibration parameters (default 3634.723)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_ref_t">ref_t</code></td>
<td>
<p>reference logger temperature (default 24)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_acor_t">acor_t</code></td>
<td>
<p>temperature drift correction parameter in the air (default 1.911)</p>
</td></tr>
<tr><td><code id="mc_calib_moisture_+3A_wcor_t">wcor_t</code></td>
<td>
<p>temperature drift correction parameter in the water (default 0.641)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculate calibration parameters <code>cor_factor</code> and <code>cor_intercept</code>
accounting for individual differencies in TMS moisture sensor signal in air and in water against reference
loggers which were used for estimation of parameters of soil VWC conversion curves.
These parameters must be loaded into myClim object <code><a href="#topic+mc_prep_calib_load">mc_prep_calib_load()</a></code>
prior to calling <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code>.
Parameters for soils available in my_Clim were derived for TMS3 logger version, with slightly different typical air and water signal.
Correction parameters for TMS4 loggers therefore can be expected in the range of values:
cor_factor = (-150; -450) and cor_slope = (100, 450)
</p>


<h3>Value</h3>

<p>list with correction factor and correction slope
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data
files &lt;- c(system.file("extdata", "data_94184102_0.csv", package = "myClim"))
tomst_data &lt;- mc_read_files(files, "TOMST")

# vwc without calibration
tomst_data &lt;- mc_calc_vwc(tomst_data, soiltype = "universal", output_sensor = "VWC_universal")

# load calibration
my_cor &lt;- mc_calib_moisture(raw_air = 394, raw_water = 3728, t_air = 21, t_water = 20)
my_calib_tb &lt;- data.frame(serial_number = c("94184102"), sensor_id = "TMS_moist",
                          datetime = as.POSIXct("2020-01-01 00:00"),
                          cor_factor = my_cor$cor_factor, cor_slope = my_cor$cor_slope)
tomst_data_cal &lt;- mc_prep_calib_load(tomst_data, my_calib_tb)
# vwc using calibration
tomst_data_cal &lt;- mc_calc_vwc(tomst_data_cal, soiltype = "universal",
                              output_sensor = "VWC_universal_calib")
# plot results
sensors &lt;- mc_info(tomst_data_cal)$sensor_name
(mc_plot_line(tomst_data_cal, sensors = c(sensors[startsWith(sensors,"VWC")]))
     + ggplot2::scale_color_viridis_d(begin = 0.2, end = 0.8))
</code></pre>

<hr>
<h2 id='mc_const_CALIB_MOIST_ACOR_T'>Default temperature drift for TMS moisture in the air.</h2><span id='topic+mc_const_CALIB_MOIST_ACOR_T'></span>

<h3>Description</h3>

<p>1.91132689118083 = default temperature drift correction parameter in the air -
TMS moisture sensor. This constant is used in the function <a href="#topic+mc_calc_vwc">mc_calc_vwc</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_CALIB_MOIST_ACOR_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='mc_const_CALIB_MOIST_REF_T'>Default ref. temperate for TMS moisture calibration</h2><span id='topic+mc_const_CALIB_MOIST_REF_T'></span>

<h3>Description</h3>

<p>24°C = default reference calibration temperate for TMS moisture sensor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_CALIB_MOIST_REF_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='mc_const_CALIB_MOIST_WCOR_T'>Default temperature drift for TMS moisture in the water</h2><span id='topic+mc_const_CALIB_MOIST_WCOR_T'></span>

<h3>Description</h3>

<p>0.64108 = default temperature drift correction parameter in the water -
TMS moisture sensor. This constant is used in the function <a href="#topic+mc_calc_vwc">mc_calc_vwc</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_CALIB_MOIST_WCOR_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_count'>Count sensor id see <code><a href="#topic+mc_agg">mc_agg()</a></code></h2><span id='topic+mc_const_SENSOR_count'></span>

<h3>Description</h3>

<p>Count sensor id see <code><a href="#topic+mc_agg">mc_agg()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_count
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_coverage'>Coverage sensor id see <code><a href="#topic+mc_agg">mc_agg()</a></code></h2><span id='topic+mc_const_SENSOR_coverage'></span>

<h3>Description</h3>

<p>Coverage sensor id see <code><a href="#topic+mc_agg">mc_agg()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_coverage
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_dendro_l_um'>Radius difference sensor id</h2><span id='topic+mc_const_SENSOR_dendro_l_um'></span>

<h3>Description</h3>

<p>Radius difference sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_dendro_l_um
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_Dendro_raw'>Default sensor for TOMST Dendrometer radius difference</h2><span id='topic+mc_const_SENSOR_Dendro_raw'></span>

<h3>Description</h3>

<p>This constant is used in the function <a href="#topic+mc_calc_tomst_dendro">mc_calc_tomst_dendro</a>
as default sensor for converting the change in stem size from raw
TOMST units to micrometers.
mc_const_SENSOR_Dendro_raw = &quot;Dendro_raw&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_Dendro_raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_Dendro_T'>Default sensor for TOMST Dendrometer temperature</h2><span id='topic+mc_const_SENSOR_Dendro_T'></span>

<h3>Description</h3>

<p>Default sensor for TOMST Dendrometer temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_Dendro_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_FDD'>Freezing Degree Days sensor id see <code><a href="#topic+mc_calc_fdd">mc_calc_fdd()</a></code></h2><span id='topic+mc_const_SENSOR_FDD'></span>

<h3>Description</h3>

<p>Freezing Degree Days sensor id see <code><a href="#topic+mc_calc_fdd">mc_calc_fdd()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_FDD
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_GDD'>Growing Degree Days sensor id see <code><a href="#topic+mc_calc_gdd">mc_calc_gdd()</a></code></h2><span id='topic+mc_const_SENSOR_GDD'></span>

<h3>Description</h3>

<p>Growing Degree Days sensor id see <code><a href="#topic+mc_calc_gdd">mc_calc_gdd()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_GDD
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_HOBO_EXTT'>Onset HOBO external temperature sensor id</h2><span id='topic+mc_const_SENSOR_HOBO_EXTT'></span>

<h3>Description</h3>

<p>Onset HOBO external temperature sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_HOBO_EXTT
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_HOBO_RH'>Onset HOBO humidity sensor id</h2><span id='topic+mc_const_SENSOR_HOBO_RH'></span>

<h3>Description</h3>

<p>Onset HOBO humidity sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_HOBO_RH
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_HOBO_T'>Onset HOBO temperature sensor id</h2><span id='topic+mc_const_SENSOR_HOBO_T'></span>

<h3>Description</h3>

<p>Onset HOBO temperature sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_HOBO_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_integer'>General integer sensor id</h2><span id='topic+mc_const_SENSOR_integer'></span>

<h3>Description</h3>

<p>General integer sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_integer
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_logical'>General logical sensor id</h2><span id='topic+mc_const_SENSOR_logical'></span>

<h3>Description</h3>

<p>General logical sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_logical
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_precipitation'>Precipitation sensor id</h2><span id='topic+mc_const_SENSOR_precipitation'></span>

<h3>Description</h3>

<p>Precipitation sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_precipitation
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_real'>General real sensor id</h2><span id='topic+mc_const_SENSOR_real'></span>

<h3>Description</h3>

<p>General real sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_real
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_RH'>Relative humidity sensor id</h2><span id='topic+mc_const_SENSOR_RH'></span>

<h3>Description</h3>

<p>Relative humidity sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_RH
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_snow_bool'>Snow existence sensor id see <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code></h2><span id='topic+mc_const_SENSOR_snow_bool'></span>

<h3>Description</h3>

<p>Snow existence sensor id see <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_snow_bool
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_snow_fresh'>Height of newly fallen snow sensor id</h2><span id='topic+mc_const_SENSOR_snow_fresh'></span>

<h3>Description</h3>

<p>Height of newly fallen snow sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_snow_fresh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_snow_total'>Height snow sensor id</h2><span id='topic+mc_const_SENSOR_snow_total'></span>

<h3>Description</h3>

<p>Height snow sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_snow_total
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_sun_shine'>Time of sun shine sensor id</h2><span id='topic+mc_const_SENSOR_sun_shine'></span>

<h3>Description</h3>

<p>Time of sun shine sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_sun_shine
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_T_C'>Temperature sensor id</h2><span id='topic+mc_const_SENSOR_T_C'></span>

<h3>Description</h3>

<p>Temperature sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_T_C
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_Thermo_T'>Default sensor for TOMST Thermologger temperature</h2><span id='topic+mc_const_SENSOR_Thermo_T'></span>

<h3>Description</h3>

<p>Default sensor for TOMST Thermologger temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_Thermo_T
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_TMS_moist'>Default sensor for TOMST TMS raw soil moisture</h2><span id='topic+mc_const_SENSOR_TMS_moist'></span>

<h3>Description</h3>

<p>This constant is used in the function <a href="#topic+mc_calc_vwc">mc_calc_vwc</a> as default for sensor for
converting the raw TMS soil moisture (scaled TDT signal) to volumetric water content (VWC).
mc_const_SENSOR_TMS_moist = &quot;TMS_moist&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_TMS_moist
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_TMS_T1'>Default sensor for TOMST TMS soil temperature</h2><span id='topic+mc_const_SENSOR_TMS_T1'></span>

<h3>Description</h3>

<p>This constant is used in the function <a href="#topic+mc_calc_vwc">mc_calc_vwc</a> to account for soil temperature effect
while converting the raw TMS soil moisture (scaled TDT signal) to volumetric water content (VWC).
mc_const_SENSOR_TMS_T1 = &quot;TMS_T1&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_TMS_T1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_TMS_T2'>Default sensor for TOMST TMS temperature of soil surface</h2><span id='topic+mc_const_SENSOR_TMS_T2'></span>

<h3>Description</h3>

<p>Default sensor for TOMST TMS temperature of soil surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_TMS_T2
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_TMS_T3'>Default sensor for TOMST TMS air temperature</h2><span id='topic+mc_const_SENSOR_TMS_T3'></span>

<h3>Description</h3>

<p>Default sensor for TOMST TMS air temperature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_TMS_T3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_VPD'>Vapor Pressure Deficit sensor id see <code><a href="#topic+mc_calc_vpd">mc_calc_vpd()</a></code></h2><span id='topic+mc_const_SENSOR_VPD'></span>

<h3>Description</h3>

<p>Vapor Pressure Deficit sensor id see <code><a href="#topic+mc_calc_vpd">mc_calc_vpd()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_VPD
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_VWC'>Volumetric soil moisture sensor id see <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code></h2><span id='topic+mc_const_SENSOR_VWC'></span>

<h3>Description</h3>

<p>Volumetric soil moisture sensor id see <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_VWC
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_const_SENSOR_wind_speed'>Speed of wind sensor id</h2><span id='topic+mc_const_SENSOR_wind_speed'></span>

<h3>Description</h3>

<p>Speed of wind sensor id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_const_SENSOR_wind_speed
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>

<hr>
<h2 id='mc_data_example_agg'>Example data in Agg-format.</h2><span id='topic+mc_data_example_agg'></span>

<h3>Description</h3>

<p>Cleaned data in Agg-format. Three example localities situated in
Saxon Switzerland National Park.
myClim object has metadata and covers time period from 2020-10 to 2021-02.
</p>
<p>Data includes time-series from 4 loggers:
</p>

<ul>
<li><p> Tomst TMS4 with 4 sensors (&quot;TMS_T1&quot;, &quot;TMS_T2&quot;, &quot;TMS_T3&quot;, &quot;TMS_moist&quot;)
</p>
</li>
<li><p> Tomst Thermologger with 1 sensor (&quot;Thermo_T)
</p>
</li>
<li><p> Tomst Point Dendrometer with 2 sensors (&quot;Dendro_T&quot;, &quot;Dendro_raw&quot;)
</p>
</li>
<li><p> HOBO U23 with 2 sensors (&quot;HOBO_T&quot;, &quot;HOBO_RH&quot;)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mc_data_example_agg
</code></pre>


<h3>Format</h3>

<p>An object of class <code>myClimList</code> (inherits from <code>list</code>) of length 2.
</p>

<hr>
<h2 id='mc_data_example_clean'>Example cleaned data in Raw-format.</h2><span id='topic+mc_data_example_clean'></span>

<h3>Description</h3>

<p>Cleaned data. Three example localities situated in Saxon Switzerland National Park.
myClim object has metadata and covers time period from 2020-10 to 2021-02.
</p>
<p>Data includes time-series from 4 loggers:
</p>

<ul>
<li><p> Tomst TMS4 with 4 sensors (&quot;TMS_T1&quot;, &quot;TMS_T2&quot;, &quot;TMS_T3&quot;, &quot;TMS_moist&quot;)
</p>
</li>
<li><p> Tomst Thermologger with 1 sensor (&quot;Thermo_T)
</p>
</li>
<li><p> Tomst Point Dendrometer with 2 sensors (&quot;Dendro_T&quot;, &quot;Dendro_raw&quot;)
</p>
</li>
<li><p> HOBO U23 with 2 sensors (&quot;HOBO_T&quot;, &quot;HOBO_RH&quot;)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mc_data_example_clean
</code></pre>


<h3>Format</h3>

<p>An object of class <code>myClimList</code> (inherits from <code>list</code>) of length 2.
</p>

<hr>
<h2 id='mc_data_example_raw'>Example data in Raw-format</h2><span id='topic+mc_data_example_raw'></span>

<h3>Description</h3>

<p>Raw data, not cleaned. Three example localities situated
in Saxon Switzerland National Park.
myClim object has metadata and covers time period from 2020-10 to 2021-02.
</p>
<p>Data includes time-series from 4 loggers:
</p>

<ul>
<li><p> Tomst TMS4 with 4 sensors (&quot;TMS_T1&quot;, &quot;TMS_T2&quot;, &quot;TMS_T3&quot;, &quot;TMS_moist&quot;)
</p>
</li>
<li><p> Tomst Thermologger with 1 sensor (&quot;Thermo_T)
</p>
</li>
<li><p> Tomst Point Dendrometer with 2 sensors (&quot;Dendro_T&quot;, &quot;Dendro_raw&quot;)
</p>
</li>
<li><p> HOBO U23 with 2 sensors (&quot;HOBO_T&quot;, &quot;HOBO_RH&quot;)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mc_data_example_raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>myClimList</code> (inherits from <code>list</code>) of length 2.
</p>

<hr>
<h2 id='mc_data_formats'>Formats of source data files</h2><span id='topic+mc_data_formats'></span>

<h3>Description</h3>

<p>R object of class environment with the definitions how to
parse specific microclimatic logger files. In case you would like to add
new, unsupported logger, this is the place where the reading key is stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_data_formats
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 3.
</p>


<h3>Details</h3>

<p>Package myClim support formats TOMST, TOMST_join and HOBO.
The environment object is stored in <code>./data/mc_data_formats.rda</code>.
</p>
<p><strong>TOMST</strong>
</p>
<p>TOMST data format has defined structure. Expected name of data file is in format data_\&lt;serial_number\&gt;_\&lt;x\&gt;.csv.
Value serial_number can be automatically detected from file name.
Datetime is in UTC and is stored in col 2. Temperature values are stored in col 3-5. Moisture ()
Supported logger types are TMS (for TMS-3/TMS-4), ThermoDataLogger (for Thermologger), Dendrometer and TMS_L45 (for TMS-4 Long 45cm).
</p>
<p><strong>TOMST_join</strong>
</p>
<p>TOMST_join data format is used by output files from JoinTMS.exe software and from tupomanager.exe (TMS-1).
Datetime in col 4, temperatures in col 5-7, moisture in col 8.
</p>
<p><strong>HOBO</strong>
</p>
<p>HOBO data format is export format from software HOBOware of Onset company for HOBO U23 Pro v2 loggers (Temperature/RH).
Format is very variable and can be adjusted by user in preferences of HOBOware. Strucuture of HOBO files format can be partly
detected automatically from header of data.
Format of date-time (<code>date_format</code>) must be set manually in myClim reading functions (<code><a href="#topic+mc_read_files">mc_read_files()</a></code>, <code><a href="#topic+mc_read_data">mc_read_data()</a></code>).
Date and time separated in more columns is not supported in myClim reading. If time zone is not defined in header of HOBO txt or csv file
and is not UTC, then <code>tz_offset</code> must be filled in while reading. UTF-8 encoding of HOBO file is required for reding to myClim.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>, <a href="#topic+mc_TOMSTDataFormat-class">mc_TOMSTDataFormat</a>, <a href="#topic+mc_TOMSTJoinDataFormat-class">mc_TOMSTJoinDataFormat</a>, <a href="#topic+mc_HOBODataFormat-class">mc_HOBODataFormat</a>
</p>

<hr>
<h2 id='mc_data_heights'>Default heights of sensors</h2><span id='topic+mc_data_heights'></span>

<h3>Description</h3>

<p>This table is used to set the default heights in metadata of sensors based on logger type.
The defaults were set based on the most common uses,
defaults can be overwrite be user. see <a href="#topic+mc_prep_meta_sensor">mc_prep_meta_sensor</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_data_heights
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 15 rows and 4 columns.
</p>


<h3>Details</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> logger_type
</p>
</li>
<li><p> sensor_name
</p>
</li>
<li><p> height - character representation of height
</p>
</li>
<li><p> suffix - suffix for sensor_name. If suffix is NA, then sensor_name is not modified.
</p>
</li></ul>

<p>Default heights are:
</p>
<p>TOMST - Thermo
</p>

<ul>
<li><p> Thermo_T = air 200 cm
</p>
</li></ul>

<p>TOMST - TMS
</p>

<ul>
<li><p> TMS_T1 = soil 8 cm
</p>
</li>
<li><p> TMS_T2 = air 2 cm
</p>
</li>
<li><p> TMS_T3 = air 15 cm
</p>
</li>
<li><p> TMS_moist = soil 0-15 cm
</p>
</li></ul>

<p>TOMST - Dendro
</p>

<ul>
<li><p> Dendro_T = 130 cm
</p>
</li>
<li><p> Dendro_raw = 130 cm
</p>
</li></ul>

<p>TOMST - TMS_L45
</p>

<ul>
<li><p> TMS_T1 = soil 40 cm
</p>
</li>
<li><p> TMS_T2 = soil 30 cm
</p>
</li>
<li><p> TMS_T3 = air 15 cm
</p>
</li>
<li><p> TMS_moist = soil 30-44 cm
</p>
</li></ul>

<p>HOBO - HOBO_U23-001A
</p>

<ul>
<li><p> HOBO_T = air 150 cm
</p>
</li>
<li><p> HOBO_RH = air 150 cm
</p>
</li></ul>

<p>HOBO - HOBO_U23-004
</p>

<ul>
<li><p> HOBO_T = air 2 cm
</p>
</li>
<li><p> HOBO_extT = soil 8 cm
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mc_read_files">mc_read_files()</a></code>, <code><a href="#topic+mc_read_data">mc_read_data()</a></code>
</p>

<hr>
<h2 id='mc_data_physical'>Physical quantities definition</h2><span id='topic+mc_data_physical'></span>

<h3>Description</h3>

<p>R object of class environment with the definitions of physical elements
for recording the microclimate e.g. temperature, speed, depth, volumetric water content...
see <a href="#topic+mc_Physical-class">mc_Physical</a>. Similarly as in case of logger format definitions <a href="#topic+mc_DataFormat-class">mc_DataFormat</a> it is easy
to add new, physical here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_data_physical
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 11.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_Physical-class">mc_Physical</a>
</p>
<p>Currently supported physical elements:
</p>

<ul>
<li><p> l_cm - length in cm
</p>
</li>
<li><p> l_mm - length in mm
</p>
</li>
<li><p> l_um - length in um
</p>
</li>
<li><p> VWC - volumetric moisture in m3/m3
</p>
</li>
<li><p> RH - relative humidity in %
</p>
</li>
<li><p> T_C - temperature in °C
</p>
</li>
<li><p> t_h - time in hours
</p>
</li>
<li><p> moisture_raw - raw TMS moisture sensor values
</p>
</li>
<li><p> radius_raw - radius difference in raw units
</p>
</li>
<li><p> v - speed in m/s
</p>
</li></ul>


<hr>
<h2 id='mc_data_sensors'>Sensors definition.</h2><span id='topic+mc_data_sensors'></span>

<h3>Description</h3>

<p>R object of class environment with the definitions of (micro)climatic sensors.
see <a href="#topic+mc_Sensor-class">mc_Sensor</a>. Similarly as in case of logger format definitions <a href="#topic+mc_DataFormat-class">mc_DataFormat</a> it is easy
to add new, sensor here. There is also universal sensor <code>real</code> where you can store any real values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_data_sensors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 28.
</p>


<h3>Details</h3>

<p>Names of items are sensor_ids.
Currently supported sensors:
</p>

<ul>
<li><p> count - result of <code>count</code> function <code><a href="#topic+mc_agg">mc_agg()</a></code>
</p>
</li>
<li><p> coverage - result of <code>coverage</code> function <code><a href="#topic+mc_agg">mc_agg()</a></code>
</p>
</li>
<li><p> Dendro_T - temperature in Tomst dendrometer (°C)
</p>
</li>
<li><p> Dendro_raw - change in stem size in Tomst dendrometer (raw units) <code><a href="#topic+mc_calc_tomst_dendro">mc_calc_tomst_dendro()</a></code>
</p>
</li>
<li><p> dendro_l_um - change in stem size (um) <code><a href="#topic+mc_calc_tomst_dendro">mc_calc_tomst_dendro()</a></code>
</p>
</li>
<li><p> FDD - result of function <code><a href="#topic+mc_calc_fdd">mc_calc_fdd()</a></code>
</p>
</li>
<li><p> GDD - result of function <code><a href="#topic+mc_calc_gdd">mc_calc_gdd()</a></code>
</p>
</li>
<li><p> HOBO_RH - relative humidity in HOBO U23-001A logger (%)
</p>
</li>
<li><p> HOBO_T - temperature in HOBO U23 logger (°C)
</p>
</li>
<li><p> HOBO_extT - external temperature in HOBO U23-004 logger (°C)
</p>
</li>
<li><p> integer - universal sensor with integer values
</p>
</li>
<li><p> logical - universal sensor with logical values
</p>
</li>
<li><p> VWC - volumetric water content in soil (m3/m3)
</p>
</li>
<li><p> precipitation - (mm)
</p>
</li>
<li><p> real - universal sensor with real values
</p>
</li>
<li><p> RH - relative humidity sensor (%)
</p>
</li>
<li><p> snow_bool - result of function <code><a href="#topic+mc_calc_snow">mc_calc_snow()</a></code>
</p>
</li>
<li><p> snow_fresh - fresh snow height (cm)
</p>
</li>
<li><p> snow_total - total snow height (cm)
</p>
</li>
<li><p> sun_shine - time of sun shine (hours)
</p>
</li>
<li><p> T_C - universal temperature sensor (°C)
</p>
</li>
<li><p> Thermo_T - temperature sensor in Tomst Thermologger (°C)
</p>
</li>
<li><p> TMS_T1 - soil temperature sensor in Tomst TMS (°C)
</p>
</li>
<li><p> TMS_T2 - surface temperature sensor in Tomst TMS (°C)
</p>
</li>
<li><p> TMS_T3 - air temperature sensor in Tomst TMS (°C)
</p>
</li>
<li><p> TMS_moist - soil moisture sensor in Tomst TMS (raw TMS units)
</p>
</li>
<li><p> wind - wind speed (m/s)
</p>
</li></ul>


<hr>
<h2 id='mc_data_vwc_parameters'>Volumetric water content parameters</h2><span id='topic+mc_data_vwc_parameters'></span>

<h3>Description</h3>

<p>Data frame hosting the coefficients for the conversion of TMS raw moisture units to
volumetric warer content. The coefficients come from laboratory calibration for several
soil types. For the best performance you should specify the soil type in case you know it
and in case it could be approximated to the available calibration e.g sand, loam, loamy sand....
See <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_data_vwc_parameters
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 13 rows and 9 columns.
</p>


<h3>Details</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> soiltype
</p>
</li>
<li><p> a
</p>
</li>
<li><p> b
</p>
</li>
<li><p> c
</p>
</li>
<li><p> rho
</p>
</li>
<li><p> clay
</p>
</li>
<li><p> silt
</p>
</li>
<li><p> sand
</p>
</li>
<li><p> ref
</p>
</li></ul>



<h3>References</h3>

<p>Wild, J., Kopecky, M., Macek, M., Sanda, M., Jankovec, J., Haase, T., 2019. Climate at ecologically relevant scales:
A new temperature and soil moisture logger for long-term microclimate measurement. Agric. For. Meteorol. 268, 40-47.
https://doi.org/10.1016/j.agrformet.2018.12.018
</p>
<p>Kopecky, M., Macek, M., Wild, J., 2021. Topographic Wetness Index calculation guidelines based on measured soil
moisture and plant species composition. Sci. Total Environ. 757, 143785. https://doi.org/10.1016/j.scitotenv.2020.143785
</p>

<hr>
<h2 id='mc_DataFormat-class'>Class for Logger File Data Format</h2><span id='topic+mc_DataFormat-class'></span><span id='topic+mc_DataFormat'></span>

<h3>Description</h3>

<p>This class is used for parsing source TXT/CSV files downloaded from microclimatic
loggers.
</p>


<h3>Details</h3>

<p>myClim offers several pre-defined
logger file data formats, such as TOMST TMS or HOBO. Users can also define custom
readings for their own loggers. Pre-defined and custom loggers in myClim each have
their own specific object of class <code style="white-space: pre;">&#8288;mc_{logger}DataFormat&#8288;</code>, which defines the
parameters for handling logger files.
The pre-defined logger definitions are stored in the R environment object
<code>./data/mc_data_formats.rda</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>skip</code></dt><dd><p>The number of rows to skip before the first row containing microclimatic records.
For example, to skip the header (default 0).</p>
</dd>
<dt><code>separator</code></dt><dd><p>The column separator (default is a comma &quot;,&quot;).</p>
</dd>
<dt><code>date_column</code></dt><dd><p>The index of the date column - required (default NA).</p>
</dd>
<dt><code>date_format</code></dt><dd><p>The format of the date (default NA).
</p>
<p>For a description of the date_format parameter, see <code><a href="base.html#topic+strptime">strptime()</a></code>. If the format is in ISO8601
and the function <code><a href="vroom.html#topic+vroom">vroom::vroom()</a></code> automatically detects datetime values,
the date_format parameter can be NA.</p>
</dd>
<dt><code>na_strings</code></dt><dd><p>Strings for representing NA values, e.g., &quot;-100&quot;, &quot;9999&quot; (default &quot;&quot;).</p>
</dd>
<dt><code>error_value</code></dt><dd><p>The value that represents an error of the sensor, e.g., 404, 9999 (default NA).
</p>
<p>The error_value is replaced by NA, and intervals of errors are flagged in <code>sensor$states</code>
(see <a href="#topic+myClim-package">myClim-package</a>).</p>
</dd>
<dt><code>columns</code></dt><dd><p>A list with names and indexes of value columns - required (default list()).
</p>
<p>Names come from names(mc_data_sensors). Names are defined as constants <code style="white-space: pre;">&#8288;mc_const_SENSOR_*&#8288;</code>.
For example, if the third column is temperature, you can define it as <code>columns[[mc_const_SENSOR_T_C]] &lt;- 3</code>.
There are universal sensors for arbitrary value types: <code>mc_const_SENSOR_real</code>, <code>mc_const_SENSOR_integer</code>
and <code>mc_const_SENSOR_logical</code>. Multiple columns with same sensor type can be defined
as <code>columns[[mc_const_SENSOR_real]] &lt;- c(2, 3, 4)</code>. The names in this example will be <code>real1</code>, <code>real2</code> and <code>real3</code>.</p>
</dd>
<dt><code>col_types</code></dt><dd><p>Parameter for <code><a href="vroom.html#topic+vroom">vroom::vroom()</a></code> (default NA).
</p>
<p>To ensure the correct reading of values, you have the possibility to strictly define the types of columns.</p>
</dd>
<dt><code>filename_serial_number_pattern</code></dt><dd><p>A character pattern for detecting the serial number from the file name (default NA).
</p>
<p>The regular expression with brackets around the serial number.
For example, the pattern for old TOMST files is <code>"data_(\\d+)_\\d+\\.csv$"</code>. If the value is NA, the name of the file is used
as the serial number.</p>
</dd>
<dt><code>data_row_pattern</code></dt><dd><p>A character pattern for detecting the correct file format (default NA).
</p>
<p>The regular expression. If data_row_pattern is NA, then the file format is not checked.</p>
</dd>
<dt><code>logger_type</code></dt><dd><p>The type of logger: TMS, TMS_L45, Thermo, Dendro, HOBO, ... (default NA).</p>
</dd>
<dt><code>tz_offset</code></dt><dd><p>The timezone offset in minutes from UTC - required (default NA).
</p>
<p>If the value of the tz_offset parameter is 0, then datetime values are in UTC.
If the time zone offset is defined in the value, e.g., <code>"2020-10-06 09:00:00+0100"</code>,
and <code>date_format</code> is <code>"%Y-%m-%d %H:%M:%S%z"</code>, the value is automatically converted to UTC.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+mc_data_formats">mc_data_formats</a>, <a href="#topic+mc_TOMSTDataFormat-class">mc_TOMSTDataFormat</a>, <a href="#topic+mc_TOMSTJoinDataFormat-class">mc_TOMSTJoinDataFormat</a>, <a href="#topic+mc_HOBODataFormat-class">mc_HOBODataFormat</a>
</p>

<hr>
<h2 id='mc_env_moist'>Standardised myClim soil moisture variables</h2><span id='topic+mc_env_moist'></span>

<h3>Description</h3>

<p>The wrapper function returning 4 standardised and ecologically relevant myClim variables
derived from soil moisture measurements. The mc_env_moist function needs time-series of
volumetric water content (VWC) measurements as input. Therefore, non-VWC soil
moisture measurements must be first converted to VWC.
For TMS loggers see <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_env_moist(
  data,
  period,
  use_utc = TRUE,
  custom_start = NULL,
  custom_end = NULL,
  min_coverage = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_env_moist_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_env_moist_+3A_period">period</code></td>
<td>
<p>output period see <code><a href="#topic+mc_agg">mc_agg()</a></code></p>
</td></tr>
<tr><td><code id="mc_env_moist_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then local time is used for day aggregation see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_env_moist_+3A_custom_start">custom_start</code></td>
<td>
<p>start date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_moist_+3A_custom_end">custom_end</code></td>
<td>
<p>end date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_moist_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the threshold specifying how many missing values can you accept within aggregation period. see <code><a href="#topic+mc_agg">mc_agg()</a></code> value from range 0-1 (default 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed for time-series of step shorter than one
day and will not work with coarser data. In contrast with other myClim functions
returning myClim objects, this wrapper function returns long table.
Variables are named based on sensor name, height, and function e.g.,
(VWC.soil_0_15_cm.5p, VWC.soil_0_15_cm.mean)
</p>
<p>Standardised myClim soil moisture variables:
</p>

<ul>
<li><p> VWC.5p: Minimum soil moisture = 5th percentile of VWC values
</p>
</li>
<li><p> VWC.mean: Mean soil moisture = mean of VWC values
</p>
</li>
<li><p> VWC.95p: Maximum soil moisture = 95th percentile of VWC values
</p>
</li>
<li><p> VWC.sd: Standard deviation of VWC measurements
</p>
</li></ul>



<h3>Value</h3>

<p>table in long format with standardised myClim variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_prep_crop(mc_data_example_agg, lubridate::ymd_h("2020-11-01 00"),
                     lubridate::ymd_h("2021-02-01 00"), end_included = FALSE)
data &lt;- mc_calc_vwc(data, localities=c("A2E32", "A6W79"))
mc_env_moist(data, "month")
</code></pre>

<hr>
<h2 id='mc_env_temp'>Standardised myClim temperature variables</h2><span id='topic+mc_env_temp'></span>

<h3>Description</h3>

<p>The wrapper function returning 7 standardised and ecologically relevant myClim variables
derived from temperature measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_env_temp(
  data,
  period,
  use_utc = TRUE,
  custom_start = NULL,
  custom_end = NULL,
  min_coverage = 1,
  gdd_t_base = 5,
  fdd_t_base = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_env_temp_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_period">period</code></td>
<td>
<p>output period see <code><a href="#topic+mc_agg">mc_agg()</a></code></p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then local time is used for day aggregation see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_custom_start">custom_start</code></td>
<td>
<p>start date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_custom_end">custom_end</code></td>
<td>
<p>end date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the threshold specifying how many missing values can you accept within aggregation period. see <code><a href="#topic+mc_agg">mc_agg()</a></code> value from range 0-1 (default 1)</p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_gdd_t_base">gdd_t_base</code></td>
<td>
<p>base temperature for Growing Degree Days <code><a href="#topic+mc_calc_gdd">mc_calc_gdd()</a></code> (default 5)</p>
</td></tr>
<tr><td><code id="mc_env_temp_+3A_fdd_t_base">fdd_t_base</code></td>
<td>
<p>base temperature for Freezing Degree Days <code><a href="#topic+mc_calc_fdd">mc_calc_fdd()</a></code> (default 0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed for time-series of step shorter than one
day and will not work with coarser data. It automatically use all
available sensors in myClim object and returns all possible variables based
on sensor type and measurement height/depth. In contrast with other myClim functions
returning myClim objects, this wrapper function returns long table.
The mc_env_temp function first aggregates time-series to daily time-step
and then aggregates to the final time-step set in <code>period</code> parameter.
Because freezing and growing degree days are always aggregated with sum function,
these two variables are not first aggregated to the daily time-steps.
Variables are named based on sensor name, height, and function e.g.,
(T.air_15_cm.max95p, T.air_15_cm.drange)
</p>
<p>Standardised myClim temperature variables:
</p>

<ul>
<li><p> min5p: Minimum temperature = 5th percentile of daily minimum temperatures
</p>
</li>
<li><p> mean: Mean temperature = mean of daily mean temperatures
</p>
</li>
<li><p> max95p: Maximum temperature = 95th percentile of daily maximum temperatures
</p>
</li>
<li><p> drange: Temperature range = mean of daily temperature range (i.e., difference between daily minima and maxima)
</p>
</li>
<li><p> GDD5: Growing degree days = sum of growing degree days above defined base temperature (default 5°C) <code>gdd_t_base</code>
</p>
</li>
<li><p> FDD0: Freezing degree days = sum of freezing degree days bellow defined base temperature (default 0°C) <code>fdd_t_base</code>
</p>
</li>
<li><p> frostdays: Frost days = number of days with frost (daily minimum &lt; 0°C) <code>fdd_t_base</code>
</p>
</li></ul>



<h3>Value</h3>

<p>table in long format with standardised myClim variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_prep_crop(mc_data_example_clean, lubridate::ymd_h("2020-11-01 00"),
                     lubridate::ymd_h("2021-02-01 00"), end_included = FALSE)
mc_env_temp(data, "month")
</code></pre>

<hr>
<h2 id='mc_env_vpd'>Standardised myClim vapor pressure deficit variables</h2><span id='topic+mc_env_vpd'></span>

<h3>Description</h3>

<p>The wrapper function returning 2 standardised and ecologically relevant myClim variables
derived from vapor pressure deficit. The mc_env_vpd function needs time-series of
vapor pressure deficit measurements as input. Therefore, VPD must be first calculated
from temperature and air humidity measurements - see <code><a href="#topic+mc_calc_vpd">mc_calc_vpd()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_env_vpd(
  data,
  period,
  use_utc = TRUE,
  custom_start = NULL,
  custom_end = NULL,
  min_coverage = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_env_vpd_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_env_vpd_+3A_period">period</code></td>
<td>
<p>output period see <code><a href="#topic+mc_agg">mc_agg()</a></code></p>
</td></tr>
<tr><td><code id="mc_env_vpd_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then local time is used for day aggregation see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_env_vpd_+3A_custom_start">custom_start</code></td>
<td>
<p>start date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_vpd_+3A_custom_end">custom_end</code></td>
<td>
<p>end date for custom period see <code><a href="#topic+mc_agg">mc_agg()</a></code> (default NULL)</p>
</td></tr>
<tr><td><code id="mc_env_vpd_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the threshold specifying how many missing values can you accept within aggregation period. see <code><a href="#topic+mc_agg">mc_agg()</a></code> value from range 0-1 (default 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was designed for time-series of step shorter than one
day and will not work with coarser data. The mc_env_vpd function
first aggregates time-series to daily time-step
and then aggregates to the final time-step set in <code>period</code> parameter.
In contrast with other myClim functions
returning myClim objects, this wrapper function returns long table.
Variables are named based on sensor name, height, and function e.g.,
(VPD.air_150_cm.mean, VPD.air_150_cm.max95p)
</p>
<p>Standardised myClim vapor pressure deficit variables:
</p>

<ul>
<li><p> VPD.mean: Mean vapor pressure deficit = mean of daily mean VPD
</p>
</li>
<li><p> VPD.max95p: Maximum vapor pressure deficit = 95th percentile of daily maximum VPD
</p>
</li></ul>



<h3>Value</h3>

<p>table in long format with standardised myClim variables
</p>

<hr>
<h2 id='mc_filter'>Filter data from myClim object</h2><span id='topic+mc_filter'></span>

<h3>Description</h3>

<p>This function filter data by localities and sensors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_filter(
  data,
  localities = NULL,
  sensors = NULL,
  reverse = FALSE,
  stop_if_empty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_filter_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_filter_+3A_localities">localities</code></td>
<td>
<p>locality_ids for filtering data; if NULL then do nothing</p>
</td></tr>
<tr><td><code id="mc_filter_+3A_sensors">sensors</code></td>
<td>
<p>sensor_names for filtering data; if NULL then do nothing see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_filter_+3A_reverse">reverse</code></td>
<td>
<p>if TRUE then input localities and/or sensors are excluded (default FALSE)</p>
</td></tr>
<tr><td><code id="mc_filter_+3A_stop_if_empty">stop_if_empty</code></td>
<td>
<p>if TRUE then error for empty output (default TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In default settings it returns the object containing input sensors / localities.
When you provide vector of localities e.g. <code>localities=c("A6W79", "A2E32")</code>
selected localities are filtered with all sensors on those localities.
The same as When you provide vector of sensors <code>sensors=c("TMS_T1", "TMS_T2")</code>,
selected sensors are filtered through all localities.
When you combine localities and sensors, then filtering return
selected sensors on selected localities.
</p>
<p>When <code>reverse = TRUE</code> and using only localities parameter then
the listed localities are removed. Similarly <code>reverse = TRUE</code> with proving only
sensors parameter, then the listed sensors are removed from all localities. When
using <code>reverse = TRUE</code> and combining sensors and localities parameters then
selected sensors are removed from selected localities.
</p>


<h3>Value</h3>

<p>filtered myClim object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## keep only "A6W79", "A2E32" localities with all their sensors
filtered_data &lt;- mc_filter(mc_data_example_raw, localities=c("A6W79", "A2E32"))

## remove "A6W79", "A2E32" localities and keep all others
filtered_data &lt;- mc_filter(mc_data_example_raw, localities=c("A6W79", "A2E32"), reverse=TRUE)

## keep only "TMS_T1", and "TMS_T2" sensors on all localities
filtered_data &lt;- mc_filter(mc_data_example_raw, sensors=c("TMS_T1", "TMS_T2"))

## remove "TMS_T1", and "TMS_T2" sensors from all localities
filtered_data &lt;- mc_filter(mc_data_example_raw, sensors=c("TMS_T1", "TMS_T2"),reverse=TRUE)

## keep only "TMS_T1", and "TMS_T2" sensors on "A6W79", "A2E32" localities
filtered_data &lt;- mc_filter(mc_data_example_raw, localities=c("A6W79", "A2E32"),
                           sensors=c("TMS_T1", "TMS_T2"))

## remove "TMS_T1", and "TMS_T2" sensors from "A6W79", "A2E32" localities
## and keep all other sensors and localities
filtered_data &lt;- mc_filter(mc_data_example_raw, localities=c("A6W79", "A2E32"),
                           sensors=c("TMS_T1", "TMS_T2"), reverse=TRUE)
</code></pre>

<hr>
<h2 id='mc_HOBODataFormat-class'>Class for reading HOBO logger files</h2><span id='topic+mc_HOBODataFormat-class'></span><span id='topic+mc_HOBODataFormat'></span>

<h3>Description</h3>

<p>Provides the key for reading the HOBO source files. In which column is the date,
in what format is the date, in which columns are records of which sensors.
The code defining the class is in section methods ./R/model.R
</p>


<h3>Slots</h3>


<dl>
<dt><code>convert_fahrenheit</code></dt><dd><p>if TRUE temperature values are converted from °F to °C (default FALSE)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>, <a href="#topic+mc_data_formats">mc_data_formats</a>
</p>

<hr>
<h2 id='mc_info'>Get sensors info table</h2><span id='topic+mc_info'></span>

<h3>Description</h3>

<p>This function return data.frame with info about sensors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> locality_id - when provided by user then locality ID, when not provided identical with serial number
</p>
</li>
<li><p> serial_number - serial number of logger when provided or automatically detected from file name or header
</p>
</li>
<li><p> sensor_id - original sensor id (e.g.,&quot;GDD&quot;, &quot;HOBO_T&quot; ,&quot;TMS_T1&quot;, &quot;TMS_T2&quot;)
</p>
</li>
<li><p> sensor_name - original sensor id if not modified, if renamed then new name (e.g.,&quot;GDD5&quot;, &quot;HOBO_T_mean&quot; ,&quot;TMS_T1_max&quot;, &quot;my_sensor01&quot;)
</p>
</li>
<li><p> start_date - the oldest record on the sensor
</p>
</li>
<li><p> end_date - the newest record on the sensor
</p>
</li>
<li><p> step_seconds - time step of records series (seconds)
</p>
</li>
<li><p> period - time step of records series (text)
</p>
</li>
<li><p> min_value - minimal recorded values
</p>
</li>
<li><p> max_value - maximal recorded value
</p>
</li>
<li><p> count_values - number of non NA records
</p>
</li>
<li><p> count_na - number of NA records
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mc_info(mc_data_example_agg)
</code></pre>

<hr>
<h2 id='mc_info_clean'>Call cleaning log</h2><span id='topic+mc_info_clean'></span>

<h3>Description</h3>

<p>This function return data.frame with information from cleaning the loggers time series see <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info_clean(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_clean_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> locality_id - when provided by user then locality ID, when not provided identical with serial number
</p>
</li>
<li><p> serial_number - serial number of logger when provided or automatically detected from file name or header
</p>
</li>
<li><p> start_date - date of the first record on the logger
</p>
</li>
<li><p> end_date  - date of the last record on the logger
</p>
</li>
<li><p> step_seconds - detected time step in seconds of the logger measurements.
</p>
</li>
<li><p> count_duplicities - number of duplicated records (identical time)
</p>
</li>
<li><p> count_missing - number of missing records (logger outage in time when it should record)
</p>
</li>
<li><p> count_disordered - number of records incorrectly ordered in time (newer followed by older)
</p>
</li>
<li><p> rounded - T/F indication whether myClim automatically rounded time series minutes to the closes half (HH:00, HH:30) e.g. 13:07 -&gt; 13:00
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>
</p>

<hr>
<h2 id='mc_info_count'>Count data</h2><span id='topic+mc_info_count'></span>

<h3>Description</h3>

<p>This function return data.frame with the number of localities, loggers and sensors of input myClim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info_count(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_count_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with count of localities, loggers and sensors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_table &lt;- mc_info_count(mc_data_example_raw)
</code></pre>

<hr>
<h2 id='mc_info_join'>Get joining info table</h2><span id='topic+mc_info_join'></span>

<h3>Description</h3>

<p>This function returns a data.frame that contains information about the join operations.
Although this function performs the join process, it only returns an overview table,
not the actual joined data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info_join(data, comp_sensors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_join_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_info_join_+3A_comp_sensors">comp_sensors</code></td>
<td>
<p>parameter for <code><a href="#topic+mc_join">mc_join()</a></code> function (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to work only with
myClim objects in <strong>Raw-format</strong>, where the loggers are organized at localities.
In <strong>Agg-format</strong>, myClim objects do not support loggers; sensors are directly connected to the locality.
See <a href="#topic+myClim-package">myClim-package</a>. <code>mc_info_join</code> does not work in Agg-format.
</p>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li><p> locality_id - The ID of the locality.
</p>
</li>
<li><p> count_loggers - Number of loggers before the join operation.
</p>
</li>
<li><p> count_joined_loggers - Number of loggers after the join operation.
</p>
</li>
<li><p> count_data_conflicts - Number of different values in overlapping sensors.
</p>
</li>
<li><p> count_errors - Number of join-related errors. An error occurs when all sensors of the loggers have different names.
</p>
</li></ul>


<hr>
<h2 id='mc_info_logger'>Get loggers info table</h2><span id='topic+mc_info_logger'></span>

<h3>Description</h3>

<p>This function returns a data.frame with information about loggers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info_logger(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_logger_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to work only with
myClim objects in <strong>Raw-format</strong>, where the loggers are organized at localities.
In <strong>Agg-format</strong>, myClim objects do not support loggers; sensors are directly connected to the locality.
See <a href="#topic+myClim-package">myClim-package</a>. <code>mc_info_logger</code> does not work in Agg-format.
</p>


<h3>Value</h3>

<p>A data.frame with the following columns:
</p>

<ul>
<li><p> locality_id - If provided by the user, it represents the locality ID; if not provided, it is identical to the logger's serial number.
</p>
</li>
<li><p> index - Logger index at the locality.
</p>
</li>
<li><p> serial_number - Serial number of the logger, either provided by the user or automatically detected from the file name or header.
</p>
</li>
<li><p> logger_type - Logger type.
</p>
</li>
<li><p> start_date - The oldest record on the logger.
</p>
</li>
<li><p> end_date - The newest record on the logger.
</p>
</li>
<li><p> step_seconds - Time step of the record series (in seconds).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mc_info_logger(mc_data_example_raw)
</code></pre>

<hr>
<h2 id='mc_info_meta'>Get localities metadata table</h2><span id='topic+mc_info_meta'></span>

<h3>Description</h3>

<p>This function return data.frame with localities metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_info_meta(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_info_meta_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> locality_id
</p>
</li>
<li><p> lon_wgs84
</p>
</li>
<li><p> lat_wgs84
</p>
</li>
<li><p> elevation
</p>
</li>
<li><p> tz_offset
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mc_info_meta(mc_data_example_agg)
</code></pre>

<hr>
<h2 id='mc_join'>Joining time-series from repeated downloads</h2><span id='topic+mc_join'></span>

<h3>Description</h3>

<p>The function is designed to merge time-series data obtained through
repeated downloads in the same location. Within a specific locality,
the function performs the merging based on logger type,
physical element, and sensor height
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_join(data, comp_sensors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_join_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_join_+3A_comp_sensors">comp_sensors</code></td>
<td>
<p>senors for compare and select source logger; If NULL then first is used. (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Joining is restricted to the myClim Raw-format (refer to <a href="#topic+myClim-package">myClim-package</a>).
Loggers need to be organized within localities. The simplest method is to use <a href="#topic+mc_read_data">mc_read_data</a>,
providing both <code>files_table</code> and <code>localities_table</code>. When using <a href="#topic+mc_read_files">mc_read_files</a>
without metadata, a bit more coding is needed. In this case, you can create
multiple myClim objects and specify correct locality names afterwards,
then merge these objects using <a href="#topic+mc_prep_merge">mc_prep_merge</a>, which groups loggers
based on identical locality names.
</p>
<p>The joining function operates seamlessly without user intervention
in two scenarios:
</p>

<ol>
<li><p> when the start of a newer time series aligns with the end of an older one, and
</p>
</li>
<li><p> when the two time-series share identical values during the overlap.
</p>
</li></ol>

<p>However, if values differ during the overlap, the user is prompted to
interactively choose which time-series to retain and which to discard.
myClim provides information about differing time-series in the console,
including locality ID, problematic interval (start-end),
older logger ID and its time series start-end, and newer logger ID and
its time series start-end. Additionally, an interactive graphical
window (plotly) displays conflicting time series, allowing the user to
zoom in and explore values. In case of multiple conflicts, myClim
sequentially asks the user for decisions.
</p>
<p>Users have seven options for handling overlap conflicts, six of which are pre-defined.
The seventh option allows the user to specify the exact time
to trim the older time-series and use the newer one. The options include:
</p>

<ul>
<li><p> 1: using the older logger (to resolve this conflict),
</p>
</li>
<li><p> 2: using the newer logger (to resolve this conflict),
</p>
</li>
<li><p> 3: skip this join (same type loggers in locality aren't joined),
</p>
</li>
<li><p> 4: always using the older logger (to resolve this and all other conflicts),
</p>
</li>
<li><p> 5: always using the newer logger (to resolve this and all other conflicts)
</p>
</li>
<li><p> 6: exit joining process.
</p>
</li></ul>

<p>Users must press the number key, hit Return/Enter,
or write in console the exact date in the format <code style="white-space: pre;">&#8288;YYYY-MM-DD hh:mm&#8288;</code>
to trim the older series and continue with the newer series.
</p>
<p>Loggers with multiple sensors are joined based on one or
more selected sensors (see parameter comp_sensors).
The name of the resulting joined sensor is taken from the logger with
the oldest data. If serial_number is not equal during logger joining,
the resulting serial_number is NA. Clean info is changed to NA except
for the step. When joining a non-calibrated sensor with a calibrated one,
the calibration information must be empty in the non-calibrated sensor.
</p>
<p>For example of joining see <a href="http://labgis.ibot.cas.cz/myclim/articles/myclim-demo.html">myClim vignette</a>.
</p>
<p><strong>WARNING</strong>
</p>
<p><code>mc_join</code> expects a maximum of one logger of a certain type
and height measuring certain elements in one locality.
In other words, if you use multiple logger of identical type
at identical heights in one locality, you cannot use
<code>mc_join</code> directly; you have to split your locality into sub-localities.
</p>


<h3>Value</h3>

<p>myClim object with joined loggers.
</p>

<hr>
<h2 id='mc_load'>Load myClim object</h2><span id='topic+mc_load'></span>

<h3>Description</h3>

<p>This function loads the myClim .rds data object saved with <a href="#topic+mc_save">mc_save</a>.
The <code>mc_save</code> and <code>mc_load</code> functions secure that the myClim object is correctly
loaded across myClim versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_load(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_load_+3A_file">file</code></td>
<td>
<p>path to input .rds file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loaded myClim object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- tempdir()
tmp_file &lt;- tempfile(tmpdir = tmp_dir)
mc_save(mc_data_example_agg, tmp_file)
data &lt;- mc_load(tmp_file)
file.remove(tmp_file)
</code></pre>

<hr>
<h2 id='mc_LocalityMetadata-class'>Class for locality metadata</h2><span id='topic+mc_LocalityMetadata-class'></span><span id='topic+mc_LocalityMetadata'></span>

<h3>Description</h3>

<p>Class for locality metadata
</p>


<h3>Details</h3>

<p>When reading without metadata, then locality is named after file
where the data come from, or after the sensor id where the data come form.
</p>


<h3>Slots</h3>


<dl>
<dt><code>locality_id</code></dt><dd><p>name of locality</p>
</dd>
<dt><code>elevation</code></dt><dd><p>of locality</p>
</dd>
<dt><code>lat_wgs84</code></dt><dd><p>latitude of locality in WGS-84</p>
</dd>
<dt><code>lon_wgs84</code></dt><dd><p>longitude of locality in WGS-84</p>
</dd>
<dt><code>tz_offset</code></dt><dd><p>offset from UTC in minutes</p>
</dd>
<dt><code>tz_type</code></dt><dd><p>type of time zone</p>
</dd>
<dt><code>user_data</code></dt><dd><p>list for user data</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+myClim-package">myClim-package</a>, <a href="#topic+mc_LoggerMetadata">mc_LoggerMetadata</a>, <a href="#topic+mc_SensorMetadata">mc_SensorMetadata</a>
</p>

<hr>
<h2 id='mc_LoggerCleanInfo-class'>Class for logger clean info</h2><span id='topic+mc_LoggerCleanInfo-class'></span><span id='topic+mc_LoggerCleanInfo'></span>

<h3>Description</h3>

<p>Class for logger clean info
</p>


<h3>Slots</h3>


<dl>
<dt><code>step</code></dt><dd><p>Time step of microclimatic data series in seconds</p>
</dd>
<dt><code>count_duplicities</code></dt><dd><p>count of duplicated records - values with same date</p>
</dd>
<dt><code>count_missing</code></dt><dd><p>count of missing records; Period between the records should be the same length. If not, than missing.</p>
</dd>
<dt><code>count_disordered</code></dt><dd><p>count of records incorrectly ordered in time. In table, newer record is followed by the older.</p>
</dd>
<dt><code>rounded</code></dt><dd><p>T/F indication whether myClim automatically rounded time series to the closes half (HH:00, HH:30) e.g. 13:07 -&gt; 13:00</p>
</dd>
</dl>

<hr>
<h2 id='mc_LoggerMetadata-class'>Class for logger metadata</h2><span id='topic+mc_LoggerMetadata-class'></span><span id='topic+mc_LoggerMetadata'></span>

<h3>Description</h3>

<p>Class for logger metadata
</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code></dt><dd><p>of logger (TMS, Thermo, Dendro, HOBO)</p>
</dd>
<dt><code>serial_number</code></dt><dd><p>serial number of the logger</p>
</dd>
<dt><code>step</code></dt><dd><p>time step of microclimatic time-seris in seconds.
When provided by user, is used in <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code> function instead of
automatic step detection</p>
</dd>
</dl>

<hr>
<h2 id='mc_MainMetadata-class'>Class for myClim object metadata</h2><span id='topic+mc_MainMetadata-class'></span><span id='topic+mc_MainMetadata'></span>

<h3>Description</h3>

<p>Class for myClim object metadata
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code></dt><dd><p>the version of the myClim package in which the object was created</p>
</dd>
<dt><code>format_type</code></dt><dd><p>type of format (Raw-format, Agg-format)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+myClim-package">myClim-package</a>
</p>

<hr>
<h2 id='mc_MainMetadataAgg-class'>Class for myClim object metadata in Agg-format</h2><span id='topic+mc_MainMetadataAgg-class'></span><span id='topic+mc_MainMetadataAgg'></span>

<h3>Description</h3>

<p>Class for myClim object metadata in Agg-format
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code></dt><dd><p>the version of the myClim package in which the object was created</p>
</dd>
<dt><code>format_type</code></dt><dd><p>type of format (Raw-format, Agg-format)</p>
</dd>
<dt><code>step</code></dt><dd><p>time step of data in seconds</p>
</dd>
<dt><code>period</code></dt><dd><p>value from <code><a href="#topic+mc_agg">mc_agg()</a></code> (e.g. month, day, all...)</p>
</dd>
<dt><code>intervals_start</code></dt><dd><p>start datetime of data intervals for spacial periods all and custom (see <code><a href="#topic+mc_agg">mc_agg()</a></code>)</p>
</dd>
<dt><code>intervals_end</code></dt><dd><p>end datetime of data intervals for spacial periods all and custom (see <code><a href="#topic+mc_agg">mc_agg()</a></code>)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+mc_MainMetadata">mc_MainMetadata</a> <a href="#topic+myClim-package">myClim-package</a>
</p>

<hr>
<h2 id='mc_Physical-class'>Class for physical</h2><span id='topic+mc_Physical-class'></span><span id='topic+mc_Physical'></span>

<h3>Description</h3>

<p>Class defining the element of the records (temperature, volumetric water content, height...)
</p>


<h3>Details</h3>

<p>See e.g. definition of temperature. Similarly as the definition of new loggers, new
physicals can be added like modules.
</p>
<pre>
Slot "name": "T_C"
Slot "description": "Temperature °C"
Slot "units": "°C"
Slot "viridis_color_map": "C" 
Slot "scale_coeff": 0.03333333
</pre>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>of physical</p>
</dd>
<dt><code>description</code></dt><dd><p>character info</p>
</dd>
<dt><code>units</code></dt><dd><p>measurument (°C, %, m3/m3, raw, mm, ...)</p>
</dd>
<dt><code>viridis_color_map</code></dt><dd><p>viridis color map option</p>
</dd>
<dt><code>scale_coeff</code></dt><dd><p>coefficient for plot; value * scale_coef is in range 0-1</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+mc_data_physical">mc_data_physical</a>
</p>

<hr>
<h2 id='mc_plot_image'>Plot data - image</h2><span id='topic+mc_plot_image'></span>

<h3>Description</h3>

<p>Function plots single sensor form myClim data into PNG file with image() R base function.
This was designed for fast, and easy data visualization especially focusing on missing
values visualization and general data picture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_plot_image(
  data,
  filename,
  title = "",
  localities = NULL,
  sensors = NULL,
  height = 1900,
  left_margin = 12,
  use_utc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_plot_image_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_filename">filename</code></td>
<td>
<p>output file name (file path)</p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_title">title</code></td>
<td>
<p>of plot; default is empty</p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_height">height</code></td>
<td>
<p>of image; default = 1900</p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_left_margin">left_margin</code></td>
<td>
<p>width of space for sensor_labels; default = 12</p>
</td></tr>
<tr><td><code id="mc_plot_image_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then the time shift from <code>tz_offset</code> metadata is used to correct
(shift) the output time-series (default TRUE)
</p>
<p>In the Agg-format myClim object <code>use_utc = FALSE</code> is allowed only for steps shorter than one day. In myClim
the day nd longer time steps are defined by the midnight, but this represent whole day, week, month, year...
shifting daily, weekly, monthly... data (shift midnight) does not make sense in our opinion.
But when user need more flexibility, then myClim Raw-format
can be used, In Raw-format <code>use_utc</code> is not limited, user can shift an data without the restrictions.
See <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful with bigger data. Can take some time.
</p>


<h3>Value</h3>

<p>PNG file created as specified in output file name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- tempdir()
tmp_file &lt;- tempfile(tmpdir = tmp_dir)
mc_plot_image(mc_data_example_clean, tmp_file, "T1 sensor", sensors="TMS_T1")
file.remove(tmp_file)
</code></pre>

<hr>
<h2 id='mc_plot_line'>Plot data - ggplot2 geom_line</h2><span id='topic+mc_plot_line'></span>

<h3>Description</h3>

<p>Function plots data with ggplot2 geom_line. Plot is returned as ggplot faced grid and
is optimized for saving as facet, paginated PDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_plot_line(
  data,
  filename = NULL,
  sensors = NULL,
  scale_coeff = NULL,
  png_width = 1900,
  png_height = 1900,
  start_crop = NULL,
  end_crop = NULL,
  use_utc = TRUE,
  localities = NULL,
  facet = "locality"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_plot_line_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_filename">filename</code></td>
<td>
<p>output file name/path with the extension - supported formats are .pdf and .png (default NULL)
</p>
<p>If NULL then the plot is displayed and can be returned into r environment but is not saved to file.</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_scale_coeff">scale_coeff</code></td>
<td>
<p>scale coefficient for secondary axis (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_png_width">png_width</code></td>
<td>
<p>width for png output (default 1900)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_png_height">png_height</code></td>
<td>
<p>height for png output (default 1900)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_start_crop">start_crop</code></td>
<td>
<p>POSIXct datetime in UTC for crop data (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_end_crop">end_crop</code></td>
<td>
<p>POSIXct datetime in UTC for crop data (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then the time shift from <code>tz_offset</code> metadata is used to correct
(shift) the output time-series (default TRUE)
</p>
<p>In the Agg-format myClim object <code>use_utc = FALSE</code> is allowed only for steps shorter than one day. In myClim
the day nd longer time steps are defined by the midnight, but this represent whole day, week, month, year...
shifting daily, weekly, monthly... data (shift midnight) does not make sense in our opinion.
But when user need more flexibility, then myClim Raw-format
can be used, In Raw-format <code>use_utc</code> is not limited, user can shift an data without the restrictions.
See <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_line_+3A_facet">facet</code></td>
<td>
<p>possible values (<code>NULL</code>, <code>"locality"</code>, <code>"physical"</code>)
</p>

<ul>
<li> <p><code>facet = "locality"</code> each locality is plotted (default)
in separate plot in R and separate row in PDF if filename.pdf is provided.
</p>
</li>
<li> <p><code>facet = "physical"</code> sensors with  identical physical (see <a href="#topic+mc_data_physical">mc_data_physical</a>) are grouped together across localities.
</p>
</li>
<li> <p><code>facet = NULL</code>, all localities and sensors (max 2 physicals, see details) are plotted
in single plot
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Saving as the PDF file is recommended, because the plot is optimized
to be paginate PDF (facet line plot is distributed to pages), each locality can be
represented by separate plot (<code>facet = "locality"</code>) default, which is especially useful
for bigger data. When <code>facet = NULL</code> then single plot is returned showing all localities together.
When <code>facet = physical</code> sensors with identical physical units are grouped together across localities.
Maximal number of physical units (elements) of sensors to be plotted in one
plot is two. First element is related to primary and second to secondary y axis.
In case, there are multiple sensors with identical physical on one locality,
they are plotted together for <code>facet = "locality"</code> e.g., when you have
TMS_T1, TMS_T2, TMS_T3, Thermo_T, and VWC you get plot with 5 lines of different colors and
two y axes. Secondary y axes are scaled with calculation <code>values * scale_coeff</code>.
If scaling coefficient is NULL than function try to detects scale coefficient from
physical unit of sensors see <a href="#topic+mc_Physical-class">mc_Physical</a>. Scaling is useful when
plotting together e.g. temperature and moisture. For native myClim loggers
(TOMST, HOBO U-23) scaling coefficients are pre-defined.
For other cases when plotting two physicals together,
it is better to set scaling coefficients by hand.
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tms.plot &lt;- mc_filter(mc_data_example_agg, localities = "A6W79")
p &lt;- mc_plot_line(tms.plot,sensors = c("TMS_T3","TMS_T1","TMS_moist"))
p &lt;- p+ggplot2::scale_x_datetime(date_breaks = "1 week", date_labels = "%W")
p &lt;- p+ggplot2::xlab("week")
p &lt;- p+ggplot2::scale_color_manual(values=c("hotpink","pink", "darkblue"),name=NULL)
</code></pre>

<hr>
<h2 id='mc_plot_loggers'>Plot data from loggers</h2><span id='topic+mc_plot_loggers'></span>

<h3>Description</h3>

<p>Function save separate files (*.png) per the loggers to the directory.
Only Raw-format supported, Agg-format not supported.
For Agg-format use <code><a href="#topic+mc_plot_line">mc_plot_line()</a></code>. Function was primary designed
for Tomst  TMS loggers for fast, and easy data visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_plot_loggers(
  data,
  directory,
  localities = NULL,
  sensors = NULL,
  crop = c(NA, NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_plot_loggers_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_plot_loggers_+3A_directory">directory</code></td>
<td>
<p>path to output directory</p>
</td></tr>
<tr><td><code id="mc_plot_loggers_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_loggers_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_plot_loggers_+3A_crop">crop</code></td>
<td>
<p>datetime range for plot, not cropping if NA (default c(NA, NA))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PNG files created in the output directory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- file.path(tempdir(), "plot")
mc_plot_loggers(mc_data_example_clean, tmp_dir)
unlink(tmp_dir, recursive=TRUE)
</code></pre>

<hr>
<h2 id='mc_plot_raster'>Plot data - ggplot2 geom_raster</h2><span id='topic+mc_plot_raster'></span>

<h3>Description</h3>

<p>Function plots data with ggplot2 geom_raster. Plot is returned as ggplot faced raster and
is primary designed to be saved as .pdf file (recommended) or .png file.
Plotting into R environment without saving any file is also possible.
See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_plot_raster(
  data,
  filename = NULL,
  sensors = NULL,
  by_hour = TRUE,
  png_width = 1900,
  png_height = 1900,
  viridis_color_map = NULL,
  start_crop = NULL,
  end_crop = NULL,
  use_utc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_plot_raster_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_filename">filename</code></td>
<td>
<p>output with the extension - supported formats are .pdf and .png (default NULL)
If NULL then the plot is shown/returned into R environment as ggplot object, but not saved to file.</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_sensors">sensors</code></td>
<td>
<p>names of sensor; should have same physical unit see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_by_hour">by_hour</code></td>
<td>
<p>if TRUE, then y axis is plotted as an hour, else original time step (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_png_width">png_width</code></td>
<td>
<p>width for png output (default 1900)</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_png_height">png_height</code></td>
<td>
<p>height for png output (default 1900)</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_viridis_color_map">viridis_color_map</code></td>
<td>
<p>viridis color map option; if NULL, then used value from mc_data_physical
</p>

<ul>
<li><p> &quot;A&quot; - magma
</p>
</li>
<li><p> &quot;B&quot; - inferno
</p>
</li>
<li><p> &quot;C&quot; - plasma
</p>
</li>
<li><p> &quot;D&quot; - viridis
</p>
</li>
<li><p> &quot;E&quot; - cividis
</p>
</li>
<li><p> &quot;F&quot; - rocket
</p>
</li>
<li><p> &quot;G&quot; - mako
</p>
</li>
<li><p> &quot;H&quot; - turbo
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_start_crop">start_crop</code></td>
<td>
<p>POSIXct datetime in UTC for crop data (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_end_crop">end_crop</code></td>
<td>
<p>POSIXct datetime in UTC for crop data (default NULL)</p>
</td></tr>
<tr><td><code id="mc_plot_raster_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then the time shift from <code>tz_offset</code> metadata is used to correct
(shift) the output time-series (default TRUE)
</p>
<p>In the Agg-format myClim object <code>use_utc = FALSE</code> is allowed only for steps shorter than one day. In myClim
the day nd longer time steps are defined by the midnight, but this represent whole day, week, month, year...
shifting daily, weekly, monthly... data (shift midnight) does not make sense in our opinion.
But when user need more flexibility, then myClim Raw-format
can be used, In Raw-format <code>use_utc</code> is not limited, user can shift an data without the restrictions.
See <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Saving as the .pdf file is recommended, because the plot is optimized
to be paginate PDF (facet raster plot is distributed to pages), which is especially useful
for bigger data. In case of plotting multiple sensors to PDF, the facet grids are grouped by sensor.
I.e., all localities of sensor_1 followed by all localities of sensor_2 etc.
When plotting only few localities, but multiple sensors,
each sensor has own page. I.e., when plotting data from one locality, and 3 sensors resulting PDF has 3 pages.
In case of plotting PNG, sensors are plotted in separated images (PNG files) by physical.
I.e, when plotting 3 sensors in PNG it will save 3 PNG files named after sensors.
Be careful with bigger data in PNG. Play with <code>png_height</code> and <code>png_width</code>.
When too small height/width, image does not fit and is plotted incorrectly. Plotting into
R environment instead of saving PDF or PNG is possible, but is recommended only for
low number  of localities (e.g. up to 10), because
high number of localities plotted in R environment results in very small picture which is hard/impossible to read.
</p>


<h3>Value</h3>

<p>list of ggplot2 objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- tempdir()
tmp_file &lt;- tempfile(tmpdir = tmp_dir, fileext=".pdf")
mc_plot_raster(mc_data_example_agg, filename=tmp_file, sensors=c("TMS_T3","TM_T"))
file.remove(tmp_file)
</code></pre>

<hr>
<h2 id='mc_prep_calib'>Sensors calibration</h2><span id='topic+mc_prep_calib'></span>

<h3>Description</h3>

<p>This function calibrate values of sensor (microclimatic records) using the
myClim object <code>sensor$calibration</code> parameters provided by <code><a href="#topic+mc_prep_calib_load">mc_prep_calib_load()</a></code>.
Microclimatic records are changed and myClim object parameter <code>sensor$metadata@calibrated</code>
is set to TRUE. It isn't allowed to calibrate sensor multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_calib(data, localities = NULL, sensors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_calib_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format or Agg-format having calibration data in metadata slot <code>sensor$calibration</code></p>
</td></tr>
<tr><td><code id="mc_prep_calib_+3A_localities">localities</code></td>
<td>
<p>vector of locality_ids where to perform calibration, if NULL, then calibrate sensors on all localities (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_calib_+3A_sensors">sensors</code></td>
<td>
<p>vector of sensor names where to perform calibration see <code>names(mc_data_sensors)</code>; if NULL,
then calibrate all sensors having calibration parameters loaded (default NULL)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs calibration itself. It uses the calibration values (cor_factor, cor_slope) stored
in myClim object sensor metadata sensor calibration loaded with <code><a href="#topic+mc_prep_calib_load">mc_prep_calib_load()</a></code>.
As it is possible to have multiple calibration values for one sensor in time (re-calibration after some time)
different calibration values can be applied based on the calibration time. Older microclimatic records
then first calibration <code>datetime</code> available are calibrated anyway (in case sensor was calibrated ex-post)
with the first calibration parameters available.
</p>
<p>This function is not designed for moisture_raw calibration
(conversion to volumetric water content) for this use <code><a href="#topic+mc_calc_vwc">mc_calc_vwc()</a></code>
</p>
<p>Only sensors with real value type can be calibrated. see <code><a href="#topic+mc_data_sensors">mc_data_sensors()</a></code>
</p>


<h3>Value</h3>

<p>same myClim object as input but with calibrated sensor values.
</p>

<hr>
<h2 id='mc_prep_calib_load'>Load sensor calibration parameters to correct microclimatic records</h2><span id='topic+mc_prep_calib_load'></span>

<h3>Description</h3>

<p>This function loads calibration parameters from data.frame <em>logger_calib_table</em>
and stores them in the myClim object metadata. This function
does not calibrate data. For calibration itself run <code><a href="#topic+mc_prep_calib">mc_prep_calib()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_calib_load(data, calib_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_calib_load_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_calib_load_+3A_calib_table">calib_table</code></td>
<td>
<p>data.frame with columns (serial_number, sensor_id, datetime, slope, intercept)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows user to provide correction coefficients <code>cor_factor</code> and <code>cor_slope</code> for linear sensor calibration.
Calibrated data have by default the form of linear function terms:
</p>
<p><code style="white-space: pre;">&#8288;calibrated value = original value * (cor_slope + 1) + cor_factor&#8288;</code>
</p>
<p>In case of one-point calibration, <code>cor_factor</code> can be estimated as:
<code style="white-space: pre;">&#8288;cor_factor = reference value - sensor value&#8288;</code>
and <code>cor_slope</code> should be set to 0.
This function loads sensor-specific
calibration coefficients from <em>calib_table</em> and stores them into myClim Raw-format
object metadata. The <em>calib_table</em> is data.frame with 5 columns:
</p>

<ul>
<li><p> serial_number = serial number of the logger
</p>
</li>
<li><p> sensor_id = name of sensor, e.g. &quot;TMS_T1&quot;
</p>
</li>
<li><p> datetime = the date of the calibration in POSIXct type
</p>
</li>
<li><p> cor_factor = the correction factor
</p>
</li>
<li><p> cor_slope = the slope of calibration curve (in case of one-point calibration, use cor_slope = 0)
</p>
</li></ul>

<p>It is not possible to change calibration parameters for already calibrated sensor.
This prevents repeated calibrations. Once <code><a href="#topic+mc_prep_calib">mc_prep_calib()</a></code> is called then
it is not allowed to provide new calibration data, neither run calibration again.
</p>


<h3>Value</h3>

<p>myClim object with loaded calibration information in metadata.
Microclimatic records are not calibrated, only ready for calibration.
To calibrate records run <code><a href="#topic+mc_prep_calib">mc_prep_calib()</a></code>
</p>

<hr>
<h2 id='mc_prep_clean'>Cleaning datetime series</h2><span id='topic+mc_prep_clean'></span>

<h3>Description</h3>

<p>By default <code>mc_prep_clean</code> runs automatically when <code><a href="#topic+mc_read_files">mc_read_files()</a></code>,
<code><a href="#topic+mc_read_data">mc_read_data()</a></code> are called. <code>mc_prep_clean</code> checks time-series in
myClim object in Raw-format for missing, duplicated, and disordered records
and regularizes microclimatic time-series to constant time-step.
Duplicated records are removed and missing values are filled with NA.
</p>
<p>See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_clean(data, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_clean_+3A_data">data</code></td>
<td>
<p>myClim object in Raw-format. see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_clean_+3A_silent">silent</code></td>
<td>
<p>if true, then cleaning log table and progress bar is not printed in console (default FALSE), see <code><a href="#topic+mc_info_clean">mc_info_clean()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Processing the data with <code>mc_prep_clean</code> is a mandatory step
required for further data handling in <code>myClim</code> library.
</p>
<p>This function guarantee that all time series are in chronological order,
have regular time-step and no duplicated records.
Function <code>mc_prep_clean</code> use time-step provided by user during data import with <code>mc_read</code>
(used time-step is permanently stored in logger metadata <a href="#topic+mc_LoggerMetadata">mc_LoggerMetadata</a>.
If time-step is not provided by the user (NA),than myClim automatically
detects the time-step from input time series based on the last 100 records.
In case of irregular time series, function returns warning and skip the series.
</p>
<p>In case the time-step is regular, but is not nicely rounded, function rounds
the time series to the closest nice time and shifts original data.
E.g., original records in 10 min regular step c(11:58, 12:08, 12:18, 12:28)
are shifted to newly generated nice sequence c(12:00, 12:10, 12:20, 12:30).
Note that microclimatic records are not modified but only shifted.
Maximum allowed shift of time series is 30 minutes. For example, when the time-step
is 2h (e.g. 13:33, 15:33, 17:33), the measurement times are shifted to (13:30, 15:30, 17:30).
When you have 2h time step and wish to round to the whole hour
(13:33 -&gt; 14:00, 15:33 -&gt; 16:00) than use <code>mc_agg(period="2 hours")</code> command after data cleaning.
</p>


<h3>Value</h3>


<ul>
<li><p> cleaned myClim object in Raw-format
</p>
</li>
<li><p> cleaning log is by default printed in console, but can be called also later by <code><a href="#topic+mc_info_clean">mc_info_clean()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>cleaned_data &lt;- mc_prep_clean(mc_data_example_raw)
</code></pre>

<hr>
<h2 id='mc_prep_crop'>Crop datetime</h2><span id='topic+mc_prep_crop'></span>

<h3>Description</h3>

<p>This function crop data by datetime
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_crop(
  data,
  start = NULL,
  end = NULL,
  localities = NULL,
  end_included = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_crop_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_crop_+3A_start">start</code></td>
<td>
<p>optional; POSIXct datetime <strong>in UTC</strong>; single value or vector; start datetime is included (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_crop_+3A_end">end</code></td>
<td>
<p>optional, POSIXct datetime <strong>in UTC</strong>; single value or vector (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_crop_+3A_localities">localities</code></td>
<td>
<p>vector of locality_ids to be cropped; if NULL then all localities are cropped (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_crop_+3A_end_included">end_included</code></td>
<td>
<p>if TRUE then end datetime is included (default TRUE), see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is able to crop data from <code>start</code> to <code>end</code> but works also
with <code>start</code> only and <code>end</code> only. When only <code>start</code> is provided, then function crops only
the beginning of the tim-series and vice versa with end.
</p>
<p>If <code>start</code> or <code>end</code> is a single POSIXct value, it is used for all or selected localities (regular crop).
However, if <code>start</code> and <code>end</code> are vectors of POSIXct values with the same length as the localities vector,
each locality is cropped by its own time window (irregular crop).
</p>
<p>The <code>end_included</code> parameter is used for selecting, whether to return data which contains <code>end</code>
time or not. For example when cropping the data to rounded days, typically users use midnight.
2023-06-15 00:00:00 UTC. But midnight is the last date of ending day and the same
time first date of the next day. Thus, there will be the last day with single record.
This can be confusing in aggregation (e.g. daily mean of single record per day, typically NA) so
sometimes it is better to exclude end and crop on 2023-06-14 23:45:00 UTC (15 minutes records).
</p>


<h3>Value</h3>

<p>cropped data in the same myClim format as input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cropped_data &lt;- mc_prep_crop(mc_data_example_clean, end=as.POSIXct("2020-02-01", tz="UTC"))
</code></pre>

<hr>
<h2 id='mc_prep_fillNA'>Fill NA</h2><span id='topic+mc_prep_fillNA'></span>

<h3>Description</h3>

<p>This function approximate NA (missing) values. It was designed to fill
only small gaps in microclimatic time-series therefore, the default maximum
length of the gap is 5 missing records and longer gaps are not filled
Only linear method is implemented from <a href="zoo.html#topic+na.approx">zoo::na.approx</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_fillNA(
  data,
  localities = NULL,
  sensors = NULL,
  maxgap = 5,
  method = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_fillNA_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_fillNA_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_fillNA_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_prep_fillNA_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum number of consecutively NA values to fill (default 5)</p>
</td></tr>
<tr><td><code id="mc_prep_fillNA_+3A_method">method</code></td>
<td>
<p>used for approximation. It is implemented now only &quot;linear&quot;. (default &quot;linear&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>myClim object with filled NA values
</p>

<hr>
<h2 id='mc_prep_merge'>Merge myClim objects</h2><span id='topic+mc_prep_merge'></span>

<h3>Description</h3>

<p>This function is designed to merge more existing myClim objects into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_merge(data_items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_merge_+3A_data_items">data_items</code></td>
<td>
<p>list of myClim objects see <a href="#topic+myClim-package">myClim-package</a>; Format (Raw/Agg) of merged objects must be same.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works only when the input myClim objects have the same format
(Raw-format, Agg-format) It is not possible to merge Raw wit Agg format.
Identical time-step is required for Agg-format data.
</p>
<p>When the merged myClim objects in Raw-format contains locality with same names (locality_id),
than list of loggers are merged on the locality. Sensors with the same name does not matter here.
Loggers with the same name within the locality are allowed in the Raw-format.
</p>
<p>When the merged myClim objects in Agg-format contains locality with same names (locality_id).
than the sensors are merged on the locality. Sensors with same names are renamed.
</p>


<h3>Value</h3>

<p>merged myClim object in the same format as input objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>merged_data &lt;- mc_prep_merge(list(mc_data_example_raw, mc_data_example_raw))
</code></pre>

<hr>
<h2 id='mc_prep_meta_locality'>Set metadata of localities</h2><span id='topic+mc_prep_meta_locality'></span>

<h3>Description</h3>

<p>This function allows you to add or modify locality metadata including
locality names. See <a href="#topic+mc_LocalityMetadata">mc_LocalityMetadata</a>.
You can import metadata from named list or from data frame. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_meta_locality(data, values, param_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_meta_locality_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_meta_locality_+3A_values">values</code></td>
<td>
<p>for localities can be named list or table
</p>

<ul>
<li><p> named list: <code>metadata &lt;- list(locality_id=value)</code>; <code>param_name</code> must be set
</p>
</li>
<li><p> table with column <code>locality_id</code> and another columns named by metadata parameter name;
to rename locality use <code>new_locality_id</code>. Parameter <code>param_name</code> must be NULL.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_prep_meta_locality_+3A_param_name">param_name</code></td>
<td>
<p>name of locality metadata parameter; Default names are <code>locality_id</code>, <code>elevation</code>, <code>lat_wgs84</code>, <code>lon_wgs84</code>, <code>tz_offset</code>.
Another names are inserted to <code>user_data</code> list. see <a href="#topic+mc_LocalityMetadata">mc_LocalityMetadata</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locality metadata is critical e.g. for correctly handling time zones.
By providing geographic coordinates in locality metadata, the user can later harmonize all data to the local solar time (midday) #' with <code><a href="#topic+mc_prep_solar_tz">mc_prep_solar_tz()</a></code> or calculate temporal offset to the UTC base on local time-zone.
Alternatively, the user can directly provide the offset (in minutes) for individual localities. This can be useful especially
for heterogeneous data sets containing various localities with loggers recording in local time. By providing temporal offset for #' each locality separately, you can unify the whole dataset to UTC.
Note that when tz_offset is set manually, than tz_type is set to <code style="white-space: pre;">&#8288;user defined&#8288;</code>.
</p>
<p>For minor metadata modification it is practical to use named list in combination
with <code>param_name</code> specification. E.g. when you wish to modify only time zone offset,
then set <code>param_name="tz_offset"</code> and provide named list with locality name and
offset value <code>list(A1E05=60)</code>.
Similarly, you can modify other metadata slots <a href="#topic+mc_LocalityMetadata">mc_LocalityMetadata</a>.
</p>
<p>For batch or generally more complex metadata modification you can provide data.frame
with columns specifying <code>locality_id</code> and one of <code style="white-space: pre;">&#8288;new_locality_id, elevation, lat_wgs84, lon_wgs84, tz_offset&#8288;</code>.
Provide locality_id (name) and the value in column of metadata you wish to update.
In case of using data.frame use <code>param_name = NULL</code>
</p>


<h3>Value</h3>

<p>myClim object in the same format as input, with updated metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_prep_meta_locality(mc_data_example_raw, list(A1E05=60), param_name="tz_offset")
</code></pre>

<hr>
<h2 id='mc_prep_meta_sensor'>Set metadata of sensors</h2><span id='topic+mc_prep_meta_sensor'></span>

<h3>Description</h3>

<p>This function allows you to modify sensor metadata including sensor name. See <a href="#topic+mc_SensorMetadata">mc_SensorMetadata</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_meta_sensor(
  data,
  values,
  param_name,
  localities = NULL,
  logger_types = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_meta_sensor_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_meta_sensor_+3A_values">values</code></td>
<td>
<p>named list with metadata values; names of items are sensor_names e.g.
for changing sensor height use <code>list(TMS_T1="soil 8 cm")</code></p>
</td></tr>
<tr><td><code id="mc_prep_meta_sensor_+3A_param_name">param_name</code></td>
<td>
<p>name of the sensor metadata parameter you want to change;
You can change <code>name</code> and <code>height</code> of sensor.</p>
</td></tr>
<tr><td><code id="mc_prep_meta_sensor_+3A_localities">localities</code></td>
<td>
<p>optional filter; vector of <code>locality_id</code>
where to change sensor metadata; if NULL than all localities (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_meta_sensor_+3A_logger_types">logger_types</code></td>
<td>
<p>optional filter; vector of <code>logger_type</code>
where to change metadata; if NULL than all logger types (default NULL);
<code>logger_type</code>is useful only for Raw-format of myClim having the level of logger see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>myClim object in the same format as input, with updated sensor metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_prep_meta_sensor(mc_data_example_raw, list(TMS_T1="my_TMS_T1"), param_name="name")
</code></pre>

<hr>
<h2 id='mc_prep_solar_tz'>Set solar time offset against UTC time</h2><span id='topic+mc_prep_solar_tz'></span>

<h3>Description</h3>

<p>This function calculates the temporal offset between local solar time and UTC time zone.
Calculation is based on geographic coordinates of each locality.
Therefore, the function does not work when longitude coordinate is not provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_solar_tz(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_solar_tz_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>myClim assumes that the data are in UTC. To calculate temporal offset based on local solar time, this function requires
geographic coordinates (at least longitude) to be provided in locality metadata slot <code>lon_wgs84</code> (in decimal degrees).
Geographic coordinates for each locality can be provided already during data reading, see <code><a href="#topic+mc_read_data">mc_read_data()</a></code>, or added
later  with <code><a href="#topic+mc_prep_meta_locality">mc_prep_meta_locality()</a></code> function.
</p>
<p>TZ offset (in minutes) is calculated as <code>longitude / 180 * 12 * 60</code>.
</p>


<h3>Value</h3>

<p>myClim object in the same format as input, with <code>tz_offset</code> filled in locality metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_solar &lt;- mc_prep_solar_tz(mc_data_example_clean)
</code></pre>

<hr>
<h2 id='mc_prep_TMSoffsoil'>Detection of out-of-soil measurements from TMS logger</h2><span id='topic+mc_prep_TMSoffsoil'></span>

<h3>Description</h3>

<p>This function creates new virtual sensor labelling anomalies in TMS logger caused by displacement out of from soil.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_prep_TMSoffsoil(
  data,
  localities = NULL,
  soil_sensor = mc_const_SENSOR_TMS_T1,
  air_sensor = mc_const_SENSOR_TMS_T2,
  moist_sensor = mc_const_SENSOR_TMS_moist,
  output_sensor = "off_soil",
  smooth = FALSE,
  smooth_window = 10,
  smooth_threshold = 0.5,
  sd_threshold = 0.76085,
  minmoist_threshold = 721.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_data">data</code></td>
<td>
<p>cleaned myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_soil_sensor">soil_sensor</code></td>
<td>
<p>character, soil temperature sensor (default <code>mc_const_SENSOR_TMS_T1</code>)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_air_sensor">air_sensor</code></td>
<td>
<p>character, air temperature sensor (default <code>mc_const_SENSOR_TMS_T2</code>)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_moist_sensor">moist_sensor</code></td>
<td>
<p>character, soil moisture sensor (default <code>mc_const_SENSOR_TMS_moist</code>)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_output_sensor">output_sensor</code></td>
<td>
<p>character, name of virtual sensor to store ouptup values (default &quot;off_soil&quot;)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_smooth">smooth</code></td>
<td>
<p>logical, smooth out isolated faulty/correct records using floating window (default FALSE)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_smooth_window">smooth_window</code></td>
<td>
<p>integer, smooth floating window width (in days) (default 10)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_smooth_threshold">smooth_threshold</code></td>
<td>
<p>numeric, floating window threshold for detection of faulty records. (default 0.5)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_sd_threshold">sd_threshold</code></td>
<td>
<p>numeric, threshold value for the criteria on the ratio of standard deviation of the soil sensor
to the above-ground sensor temperatures (default 0.76085)</p>
</td></tr>
<tr><td><code id="mc_prep_TMSoffsoil_+3A_minmoist_threshold">minmoist_threshold</code></td>
<td>
<p>numeric, threshold value for criteria on the minimum soil moisture (default 721.5)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TMS loggers, when correctly installed in the soil, exhibit certain temperature and soil moisture signal characteristics.
Temperature varies the most at the soil interface, and temperature fluctuations in the soil are minimized.
The moisture signal from a sensor that has lost direct contact with the soil is reduced.
The following criteria are used for detecting faulty measurements: the ratio of the standard deviations of the soil
sensor to the above-ground sensor within 24h moving window is greater than the defined threshold (default 0.76085),
and simultaneously, the soil moisture minimum within 24h mowing window is less than 721.5.
Optionally, the prediction results can be smoothed using a floating window to average-out unlikely short periods detected by the algorithm.
Selection and parametrization of criteria was done using a recursive partitioning (rpart::rpart)
on the training set of 7.8M readings in 154 TMS timeseries from different environmental settings (temperate forests, tropical rainforest, cold desert, alpine and subnival zone,
and invalid measurements from loggers stored in the office or displaced from the soil).
Sensitivity of the method (true positive rate) on was 95.1% and specificity (true negative rate) was 99.4% using function default parameters.
Smoothing with 10 day floating window increased sensitivity to 96.8% while retaining specifity at the same level of 99.4%.
Decreasing 'smooth_threshold' below 0.5 will extend periods flagged as faulty measurement.
</p>


<h3>Value</h3>

<p>numeric vector (0 = correct measurement, 1 = faulty measurement) stored as virtual sensor in myClim object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mc_read_files(system.file("extdata", "data_93142760_201904.csv", package = "myClim"),
                      "TOMST")
data &lt;- mc_prep_TMSoffsoil(data)
mc_plot_line(data, sensors = c("off_soil","TMS_T1", "TMS_T2","TMS_T3"))
</code></pre>

<hr>
<h2 id='mc_read_data'>Reading files with locality metadata</h2><span id='topic+mc_read_data'></span>

<h3>Description</h3>

<p>This function has two tables as the parameters.
</p>
<p>(i) <code>files_table</code> with <em>paths</em> pointing to raw
csv logger files, specification of <em>data format</em> (logger type) and <em>locality name</em>.
</p>
<p>(ii) <code>localities_table</code> with <em>locality id</em> and metadata e.g. longitude, latitude, elevation...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_read_data(
  files_table,
  localities_table = NULL,
  clean = TRUE,
  silent = FALSE,
  user_data_formats = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_read_data_+3A_files_table">files_table</code></td>
<td>
<p>path to csv file or data.frame object see example](https://github.com/ibot-geoecology/myClim/blob/main/examples/data/TOMST/files_table.csv)
with 3 required columns and few optional:
required columns:
</p>

<ul>
<li><p> path - path to files
</p>
</li>
<li><p> locality_id - unique locality id
</p>
</li>
<li><p> data_format see <a href="#topic+mc_data_formats">mc_data_formats</a>, <code>names(mc_data_formats)</code>
</p>
</li></ul>

<p>optional columns:
</p>

<ul>
<li><p> serial_number - logger serial number. If is NA, than myClim tries to detect serial number from file name (for TOMST) or header (for HOBO)
</p>
</li>
<li><p> logger_type - type of logger. This defines individual sensors attributes (measurement heights and physical units) of the logger. Important when combining the data from multiple loggers on the locality.
If not provided, myClim tries to detect loger_type from the source data file structure (applicable for HOBO, Dendro, Thermo and TMS), but automatic detection of TMS_L45 is not possible.
Pre-defined logger types are: (&quot;Dendro&quot;, &quot;HOBO&quot;, &quot;Thermo&quot;, &quot;TMS&quot;, &quot;TMS_L45&quot;)
Default heights of sensor based on logger types are defined in table <a href="#topic+mc_data_heights">mc_data_heights</a>
</p>
</li>
<li><p> date_format A character vector specifying the custom date format(s) for the <code><a href="lubridate.html#topic+parse_date_time">lubridate::parse_date_time()</a></code> function
(e.g., &quot;%d.%m.%Y %H:%M:%S&quot;). Multiple formats can be defined. The first matching format will be selected for parsing.
</p>
</li>
<li><p> tz_offset - If source datetimes aren't in UTC, then is possible define offset from UTC in minutes.
Value in this column have the highest priority. If NA then auto detection of timezone in files.
If timezone can't be detected, then UTC is supposed.
Timezone offset in HOBO format can be defined in header. In this case function try detect offset automatically.
Ignored for Tomst TMS data format (they are always in UTC)
</p>
</li>
<li><p> step - Time step of microclimatic time-series in seconds. When provided, then used in <a href="#topic+mc_prep_clean">mc_prep_clean</a>
instead of automatic step detection.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_read_data_+3A_localities_table">localities_table</code></td>
<td>
<p>path to csv file (&quot;c:/user/localities.table.csv&quot;) or R data.frame <a href="https://github.com/ibot-geoecology/myClim/blob/main/examples/data/TOMST/localities_table.csv"> see example</a>.
Localities table is optional (default NULL).
The <code>locality_id</code> is the only required column. Other columns are optional. Column names corresponding
with the myclim pre-defined locality metadata (elevation, lon_wgs84, lat_wgs84, tz_offset)
are associted withthose pre-defined metadata slots, other columns are  written into
<code>metadata@user_data</code> <a href="#topic+myClim-package">myClim-package</a>.
</p>
<p>required columns:
</p>

<ul>
<li><p> locality_id - unique locality id
</p>
</li></ul>

<p>optional columns:
</p>

<ul>
<li><p> elevation - elevation (in m)
</p>
</li>
<li><p> lon_wgs84 - longitude (in decimal degrees)
</p>
</li>
<li><p> lat_wgs84 - latitude (in decimal degrees)
</p>
</li>
<li><p> tz_offset - locality time zone offset from UTC, applicable for converting time-series from UTC to local time.
</p>
</li>
<li><p> ... - any other columns are imported to <code>metadata@user_data</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_read_data_+3A_clean">clean</code></td>
<td>
<p>if TRUE, then <a href="#topic+mc_prep_clean">mc_prep_clean</a> is called automatically while reading (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_data_+3A_silent">silent</code></td>
<td>
<p>if TRUE, then any information is not printed in console (default FALSE)</p>
</td></tr>
<tr><td><code id="mc_read_data_+3A_user_data_formats">user_data_formats</code></td>
<td>
<p>custom data formats; use in case you have your own logger
files not pre-defined in myClim  - list(key=mc_DataFormat) <a href="#topic+mc_DataFormat-class">mc_DataFormat</a> (default NULL)
</p>
<p>If custom data format is defined the key can be used in data_format parameter in <code><a href="#topic+mc_read_files">mc_read_files()</a></code>
and <code><a href="#topic+mc_read_data">mc_read_data()</a></code>. Custom data format must be defined first, and then an be used for reading.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input tables could be R data.frames or csv files. When loading <code>files_table</code>
and <code>localities_table</code> from external CSV they must have header, column separator must be comma &quot;,&quot;.
By default data are cleaned with function <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>. See function description. It detects
holes in time-series, duplicated records or records in wrong order.
</p>


<h3>Value</h3>

<p>myClim object in Raw-format see <a href="#topic+myClim-package">myClim-package</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>files_csv &lt;- system.file("extdata", "files_table.csv", package = "myClim")
localities_csv &lt;- system.file("extdata", "localities_table.csv", package = "myClim")
tomst_data &lt;- mc_read_data(files_csv, localities_csv)
</code></pre>

<hr>
<h2 id='mc_read_files'>Reading files or directories</h2><span id='topic+mc_read_files'></span>

<h3>Description</h3>

<p>This function read one or more CSV/TXT files or directories of identical,
pre-defined logger type (format) see <a href="#topic+mc_DataFormat">mc_DataFormat</a> and <a href="#topic+mc_data_formats">mc_data_formats</a>.
This function does not support loading locality or sensor metadata while reading.
Metadata can be loaded through <code><a href="#topic+mc_read_data">mc_read_data()</a></code> or
can be provided later with function <code><a href="#topic+mc_prep_meta_locality">mc_prep_meta_locality()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_read_files(
  paths,
  dataformat_name,
  logger_type = NA_character_,
  recursive = TRUE,
  date_format = NA_character_,
  tz_offset = NA_integer_,
  step = NA_integer_,
  clean = TRUE,
  silent = FALSE,
  user_data_formats = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_read_files_+3A_paths">paths</code></td>
<td>
<p>vector of paths to files or directories</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_dataformat_name">dataformat_name</code></td>
<td>
<p>data format of logger; one of <code>names(mc_data_formats)</code></p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_logger_type">logger_type</code></td>
<td>
<p>type of logger (default NA), can be one of
pre-defined see <code><a href="#topic+mc_read_data">mc_read_data()</a></code> or any custom string</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_recursive">recursive</code></td>
<td>
<p>recursive search in sub-directories (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_date_format">date_format</code></td>
<td>
<p>format of date in your hobo files e.g. &quot;%d.%m.%y %H:%M:%S&quot; (default NA).
Required for HOBO files. For TMS files ignored, there is known, stable date format. see <a href="#topic+mc_data_formats">mc_data_formats</a></p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_tz_offset">tz_offset</code></td>
<td>
<p>timezone offset in minutes; It is required only for non-UTC data
(custom settings in HOBO). Not used in TMS (default NA)</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_step">step</code></td>
<td>
<p>time step of microclimatic time-series in seconds. When provided, then is used in
<a href="#topic+mc_prep_clean">mc_prep_clean</a> instead of automatic step detection.
If not provided (NA), is automatically detected in <a href="#topic+mc_prep_clean">mc_prep_clean</a>. (default NA)</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_clean">clean</code></td>
<td>
<p>if TRUE, then <a href="#topic+mc_prep_clean">mc_prep_clean</a> is called automatically while reading (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_silent">silent</code></td>
<td>
<p>if TRUE, then any information is not printed in console (default FALSE)</p>
</td></tr>
<tr><td><code id="mc_read_files_+3A_user_data_formats">user_data_formats</code></td>
<td>
<p>custom data formats; use in case you have your own logger
files not pre-defined in myClim  - list(key=mc_DataFormat) <a href="#topic+mc_DataFormat-class">mc_DataFormat</a> (default NULL)
</p>
<p>If custom data format is defined the key can be used in data_format parameter in <code><a href="#topic+mc_read_files">mc_read_files()</a></code>
and <code><a href="#topic+mc_read_data">mc_read_data()</a></code>. Custom data format must be defined first, and then an be used for reading.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If file is not in expected format, then file is skipped and warning printed in console.
CSV/TXT files (loggers raw data) are in resulting myClim object placed to separate
localities with empty metadata. Localities are named after serial_number of logger.
Pre-defined logger types are (&quot;Dendro&quot;,&quot;HOBO&quot;,&quot;Thermo&quot;,&quot;TMS&quot;,&quot;TMS_L45&quot;)
By default data are cleaned with function <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>.
See function description. It detects holes in time-series,
duplicated records or records in wrong order.
</p>


<h3>Value</h3>

<p>myClim object in Raw-format see <a href="#topic+myClim-package">myClim-package</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>, <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>files &lt;- c(system.file("extdata", "data_91184101_0.csv", package = "myClim"),
           system.file("extdata", "data_94184102_0.csv", package = "myClim"))
tomst_data &lt;- mc_read_files(files, "TOMST")
# user_data_formats
files &lt;- system.file("extdata", "TMS94184102.csv", package = "myClim")
user_data_formats &lt;- list(my_logger=new("mc_DataFormat"))
user_data_formats$my_logger@date_column &lt;- 2
user_data_formats$my_logger@date_format &lt;- "%Y-%m-%d %H:%M:%S"
user_data_formats$my_logger@tz_offset &lt;- 0
user_data_formats$my_logger@columns[[mc_const_SENSOR_T_C]] &lt;- c(3, 4, 5)
user_data_formats$my_logger@columns[[mc_const_SENSOR_real]] &lt;- 6
my_data &lt;- mc_read_files(files, "my_logger", silent=TRUE, user_data_formats=user_data_formats)
</code></pre>

<hr>
<h2 id='mc_read_long'>Reading data from long data.frame</h2><span id='topic+mc_read_long'></span>

<h3>Description</h3>

<p>This is universal function designed to read time series and values
from long data.frame to myClim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_read_long(data_table, sensor_ids = list(), clean = TRUE, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_read_long_+3A_data_table">data_table</code></td>
<td>
<p>long data.frame with Columns:
</p>

<ul>
<li><p> locality_id - character; id of locality
</p>
</li>
<li><p> sensor_name - can be any character string, recommended are these: <code>names(mc_data_sensors)</code>
</p>
</li>
<li><p> datetime - POSIXct in UTC timezone is required
</p>
</li>
<li><p> value
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_read_long_+3A_sensor_ids">sensor_ids</code></td>
<td>
<p>list with relations between sensor_names and sensor_ids (default list());
sensor_id is key from <code>names(mc_data_sensors)</code>. E.g.,
<code>sensor_ids &lt;- list(precipitation="real", maxAirT="T_C")</code>
If sensor_name is the same as sensor_id does not have to be provided.</p>
</td></tr>
<tr><td><code id="mc_read_long_+3A_clean">clean</code></td>
<td>
<p>if TRUE, then <a href="#topic+mc_prep_clean">mc_prep_clean</a> is called automatically while reading (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_long_+3A_silent">silent</code></td>
<td>
<p>if TRUE, then any information is not printed in console (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar like <a href="#topic+mc_read_wide">mc_read_wide</a> but is capable to read multiple sensors
from single table. Useful for data not coming from supported microclimatic
loggers. E.g. meteorological station data.
By default data are cleaned with function <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>.
</p>


<h3>Value</h3>

<p>myClim object in Raw-format
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_read_wide">mc_read_wide</a>
</p>

<hr>
<h2 id='mc_read_tubedb'>Reading data from TubeDB</h2><span id='topic+mc_read_tubedb'></span>

<h3>Description</h3>

<p>Function is reading data from TubeDB (https://environmentalinformatics-marburg.github.io/tubedb/) into myClim object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_read_tubedb(
  tubedb,
  region = NULL,
  plot = NULL,
  sensor_ids = NULL,
  clean = TRUE,
  silent = FALSE,
  aggregation = "raw",
  quality = "no",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_read_tubedb_+3A_tubedb">tubedb</code></td>
<td>
<p>object for connection to server see <a href="rTubeDB.html#topic+TubeDB-class">rTubeDB::TubeDB</a></p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_region">region</code></td>
<td>
<p>vector of TubeDB region ids - see <a href="rTubeDB.html#topic+query_regions">rTubeDB::query_regions</a> (default NULL)
</p>
<p>Regions are used mainly for loading metadata from TubeDB localities.</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_plot">plot</code></td>
<td>
<p>vector of localities ids see <a href="rTubeDB.html#topic+query_region_plots">rTubeDB::query_region_plots</a> <a href="rTubeDB.html#topic+query_timeseries">rTubeDB::query_timeseries</a> (default NULL)
</p>
<p>If plot is NULL, then all localities are loaded from whole region.</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_sensor_ids">sensor_ids</code></td>
<td>
<p>list in format <code>list(tubedb_sensor_name=myClim_sensor_name)</code> (default NULL)
If sensor names in TubeDB match the default sensor names in myClim, then the value is detected automatically.</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_clean">clean</code></td>
<td>
<p>if TRUE, then <a href="#topic+mc_prep_clean">mc_prep_clean</a> is called automatically while reading (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_silent">silent</code></td>
<td>
<p>if TRUE, then any information is not printed in console (default FALSE)</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_aggregation">aggregation</code></td>
<td>
<p>parameter used in function <a href="rTubeDB.html#topic+query_timeseries">rTubeDB::query_timeseries</a> (default raw)</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_quality">quality</code></td>
<td>
<p>parameter used in function <a href="rTubeDB.html#topic+query_timeseries">rTubeDB::query_timeseries</a> (default no)</p>
</td></tr>
<tr><td><code id="mc_read_tubedb_+3A_...">...</code></td>
<td>
<p>other parameters from function <a href="rTubeDB.html#topic+query_timeseries">rTubeDB::query_timeseries</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case you store your microclimatic time-series in TubeDB, you can read data
with TubeDB API into myClim object. You need to know database URL, username and password.
</p>


<h3>Value</h3>

<p>myClim object in Raw-format
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run: To retrieve data from TubeDB, a running TubeDB server with a user account
#          and a secret password is required.
## Not run: 
tubedb &lt;- TubeDB(url="server", user="user", password="password")
data &lt;- mc_read_tubedb(tubedb, region="ckras", plot=c("TP_KAR_19", "TP_KODA_61"))

## End(Not run)
</code></pre>

<hr>
<h2 id='mc_read_wide'>Reading data from wide data.frame</h2><span id='topic+mc_read_wide'></span>

<h3>Description</h3>

<p>This is universal function designed to read time-series and values
from wide data.frame to myClim object. Useful for data not coming from
supported microclimatic loggers. E.g. meteorological station data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_read_wide(
  data_table,
  sensor_id = mc_const_SENSOR_real,
  sensor_name = NULL,
  clean = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_read_wide_+3A_data_table">data_table</code></td>
<td>
<p>data.frame with first column of POSIXct time format UTC timezone,
followed by columns with (micro)climatic records. See details.
</p>
<p>Columns:
</p>

<ul>
<li><p> datetime column - POSIXct in UTC timezone is required
</p>
</li>
<li><p> Name of locality[1] - values
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> Name of locality[n] - values
</p>
</li></ul>
</td></tr>
<tr><td><code id="mc_read_wide_+3A_sensor_id">sensor_id</code></td>
<td>
<p>define the sensor type, one of <code>names(mc_data_sensors)</code> (default <code>real</code>)</p>
</td></tr>
<tr><td><code id="mc_read_wide_+3A_sensor_name">sensor_name</code></td>
<td>
<p>custom name of sensor; if NULL (default) than <code>sensor_name == sensor_id</code></p>
</td></tr>
<tr><td><code id="mc_read_wide_+3A_clean">clean</code></td>
<td>
<p>if TRUE, then <a href="#topic+mc_prep_clean">mc_prep_clean</a> is called automatically while reading (default TRUE)</p>
</td></tr>
<tr><td><code id="mc_read_wide_+3A_silent">silent</code></td>
<td>
<p>if TRUE, then any information is printed in console (default FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first column of input data.frame must be datetime column in POSIXct time format UTC timezone.
Following columns represents localities. Column names are the localities names.
All values in wide data.frame represents the same sensor type, e.g. air temperature. If you wish to
read multiple sensors use <a href="#topic+mc_read_long">mc_read_long</a> or use <a href="#topic+mc_read_wide">mc_read_wide</a> multiple times separately
for each sensor type and that merge myClim objects with <a href="#topic+mc_prep_merge">mc_prep_merge</a>
By default data are cleaned with function <code><a href="#topic+mc_prep_clean">mc_prep_clean()</a></code>. See function description. It detects
holes in time-series, duplicated records or records in wrong order.
</p>


<h3>Value</h3>

<p>myClim object in Raw-format
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_read_long">mc_read_long</a>
</p>

<hr>
<h2 id='mc_reshape_long'>Export values to long table</h2><span id='topic+mc_reshape_long'></span>

<h3>Description</h3>

<p>This function converts myClim object to long R data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_reshape_long(data, localities = NULL, sensors = NULL, use_utc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_reshape_long_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_reshape_long_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_reshape_long_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_reshape_long_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then the time shift from <code>tz_offset</code> metadata is used to correct
(shift) the output time-series (default TRUE)
</p>
<p>In the Agg-format myClim object <code>use_utc = FALSE</code> is allowed only for steps shorter than one day. In myClim
the day nd longer time steps are defined by the midnight, but this represent whole day, week, month, year...
shifting daily, weekly, monthly... data (shift midnight) does not make sense in our opinion.
But when user need more flexibility, then myClim Raw-format
can be used, In Raw-format <code>use_utc</code> is not limited, user can shift an data without the restrictions.
See <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>
<p>columns:
</p>

<ul>
<li><p> locality_id
</p>
</li>
<li><p> serial_number
</p>
</li>
<li><p> sensor_name
</p>
</li>
<li><p> height
</p>
</li>
<li><p> datetime
</p>
</li>
<li><p> time_to
</p>
</li>
<li><p> value
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>head(mc_reshape_long(mc_data_example_clean, c("A6W79", "A2E32"), c("TMS_T1", "TMS_T2")), 10)
</code></pre>

<hr>
<h2 id='mc_reshape_wide'>Export values to wide table</h2><span id='topic+mc_reshape_wide'></span>

<h3>Description</h3>

<p>This function converts myClim object to the R data.frame with values of sensor in wide format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_reshape_wide(data, localities = NULL, sensors = NULL, use_utc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_reshape_wide_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_reshape_wide_+3A_localities">localities</code></td>
<td>
<p>names of localities; if NULL then all (default NULL)</p>
</td></tr>
<tr><td><code id="mc_reshape_wide_+3A_sensors">sensors</code></td>
<td>
<p>names of sensors; if NULL then all (default NULL) see <code>names(mc_data_sensors)</code></p>
</td></tr>
<tr><td><code id="mc_reshape_wide_+3A_use_utc">use_utc</code></td>
<td>
<p>if FALSE, then the time shift from <code>tz_offset</code> metadata is used to correct
(shift) the output time-series (default TRUE)
</p>
<p>In the Agg-format myClim object <code>use_utc = FALSE</code> is allowed only for steps shorter than one day. In myClim
the day nd longer time steps are defined by the midnight, but this represent whole day, week, month, year...
shifting daily, weekly, monthly... data (shift midnight) does not make sense in our opinion.
But when user need more flexibility, then myClim Raw-format
can be used, In Raw-format <code>use_utc</code> is not limited, user can shift an data without the restrictions.
See <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>First column of the output data.frame is datetime followed by the
columns for every sensor. Name of the column is in format:
</p>

<ul>
<li><p> localityid_loggerid_serialnumber_sensorname for Raw-format
</p>
</li>
<li><p> localityid_sensorname for Agg-format
</p>
</li></ul>

<p>The less complex wide table is returned when exporting single sensor ascross localities.
</p>


<h3>Value</h3>

<p>data.frame with columns:
</p>

<ul>
<li><p> datetime
</p>
</li>
<li><p> locality1_sensor1
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> localityn_sensorn
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>example_tms_wideformat &lt;- mc_reshape_wide(mc_data_example_raw, c("A6W79", "A2E32"),
                                          c("TMS_T1", "TMS_T2"))
</code></pre>

<hr>
<h2 id='mc_save'>Save myClim object</h2><span id='topic+mc_save'></span>

<h3>Description</h3>

<p>This function was designed for saving the myClim data object to an
.rds file, which can be later correctly loaded by any further version
of myClim package with <a href="#topic+mc_load">mc_load</a>. This is the safest way how to store and
share your myClim data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_save(data, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_save_+3A_data">data</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="mc_save_+3A_file">file</code></td>
<td>
<p>path to output .rds file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RDS file saved at the output path destination
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp_dir &lt;- tempdir()
tmp_file &lt;- tempfile(tmpdir = tmp_dir)
mc_save(mc_data_example_agg, tmp_file)
file.remove(tmp_file)
</code></pre>

<hr>
<h2 id='mc_Sensor-class'>Class for sensor definition</h2><span id='topic+mc_Sensor-class'></span><span id='topic+mc_Sensor'></span>

<h3>Description</h3>

<p>Sensor definitions are stored in <a href="#topic+mc_data_sensors">mc_data_sensors</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sensor_id</code></dt><dd><p>unique identifier of sensor (TMS_T1, TMS_T2, TMS_T3, TMS_moist, ...)</p>
</dd>
<dt><code>logger</code></dt><dd><p>name of logger (TMS, Thermo, ...)</p>
</dd>
<dt><code>physical</code></dt><dd><p>unit of sensor (T_C, moisture_raw, moisture, RH) (default NA)</p>
</dd>
<dt><code>description</code></dt><dd><p>character info</p>
</dd>
<dt><code>value_type</code></dt><dd><p>type of values (real, integer, logical) (default real)</p>
</dd>
<dt><code>min_value</code></dt><dd><p>minimal value (default NA)</p>
</dd>
<dt><code>max_value</code></dt><dd><p>maximal value (default NA)</p>
</dd>
<dt><code>plot_color</code></dt><dd><p>color in pot (default &quot;&quot;)</p>
</dd>
<dt><code>plot_line_width</code></dt><dd><p>width of line in plot (default 1)</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+mc_data_sensors">mc_data_sensors</a>
</p>

<hr>
<h2 id='mc_SensorMetadata-class'>Class for sensor metadata</h2><span id='topic+mc_SensorMetadata-class'></span><span id='topic+mc_SensorMetadata'></span>

<h3>Description</h3>

<p>Class for sensor metadata
</p>


<h3>Details</h3>

<p><code>sensor_id</code> must be one of the defined id in myClim. see <a href="#topic+mc_data_sensors">mc_data_sensors</a>.
It is useful to select on of predefined, because it makes plotting and calculaton easier.
Through <code>sensor_id</code> myClim assign pre-deined physicyl units or plotting colors see <a href="#topic+mc_Sensor">mc_Sensor</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>sensor_id</code></dt><dd><p>unique identifier of sensor (TMS_T1, TMS_T2, TMS_T3, TMS_moist, ...) <a href="#topic+mc_data_sensors">mc_data_sensors</a> e.g. TMS_T1, TMS_moist, snow_fresh...</p>
</dd>
<dt><code>name</code></dt><dd><p>character, could be same as <code>sensor_id</code> but also defined by function or user.</p>
</dd>
<dt><code>height</code></dt><dd><p>character</p>
</dd>
<dt><code>calibrated</code></dt><dd><p>logical - detect if sensor is calibrated</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+myClim-package">myClim-package</a>, <a href="#topic+mc_LoggerMetadata">mc_LoggerMetadata</a>, <a href="#topic+mc_data_sensors">mc_data_sensors</a>
</p>

<hr>
<h2 id='mc_TOMSTDataFormat-class'>Class for reading TOMST logger files</h2><span id='topic+mc_TOMSTDataFormat-class'></span><span id='topic+mc_TOMSTDataFormat'></span>

<h3>Description</h3>

<p>Provides the key for the column in source files. Where is the date,
in what format is the date, in which columns are records of which sensors.
The code defining the class is in section methods ./R/model.R
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>, <a href="#topic+mc_data_formats">mc_data_formats</a>, <a href="#topic+mc_TOMSTJoinDataFormat-class">mc_TOMSTJoinDataFormat</a>
</p>

<hr>
<h2 id='mc_TOMSTJoinDataFormat-class'>Class for reading TMS join files</h2><span id='topic+mc_TOMSTJoinDataFormat-class'></span><span id='topic+mc_TOMSTJoinDataFormat'></span>

<h3>Description</h3>

<p>Provides the key for the column in source files. Where is the date,
in what format is the date, in which columns are records of which sensors.
The code defining the class is in section methods ./R/model.R
</p>


<h3>Details</h3>

<p>TMS join file format is the output of IBOT internal post-processing of TOMST logger files.
</p>


<h3>See Also</h3>

<p><a href="#topic+mc_DataFormat">mc_DataFormat</a>,<a href="#topic+mc_data_formats">mc_data_formats</a>,<a href="#topic+mc_TOMSTDataFormat-class">mc_TOMSTDataFormat</a>, <a href="#topic+mc_TOMSTJoinDataFormat-class">mc_TOMSTJoinDataFormat</a>
</p>

<hr>
<h2 id='myClim-package'>myClim: Microclimatic Data Processing</h2><span id='topic+myClim'></span><span id='topic+myClim-package'></span>

<h3>Description</h3>

<p>Package myClim was designed for microclimate data processing, storing, and analyzing.
The myClim wofrkflow consists of reading logger files, pre-processing the time-series,
time-series aggregation, and microclimatic variables calculation. The microclimatic
data are stored in size-efficient hierarchical structure which respects the
hierarchy of field microclimate measurement (locality&gt;loggers&gt;sensors).
</p>
<p>After data import, myClim can summarize the data and automatically correct
for the most common problems.   The myClim package provides functions to
calculate aggregated microclimate statistics as well as methods for data
calibration, conversion and calculation of derived microclimatic variables
like growing degree days, freezing degree days, snow cover duration,
volumetric water content and vapor pressure deficit.
</p>
<p>Standardized microclimatic variables can be stored efficiently in myClim
data format or easily exported to stadard R long or wide tables for further
analyses and visualization.
</p>
<p><strong>myClim object</strong>
</p>
<p>We implemented two slightly different data formats of myClim objects calling them:
Raw-format and Agg-format.
Raw-format is designed for data preparation. Mainly data cleaning,
metadata gathering, time zones handling and multiple downloads joining.
Outputs of functions <code><a href="#topic+mc_read_files">mc_read_files()</a></code> and <code><a href="#topic+mc_read_data">mc_read_data()</a></code> are a Raw-format.
Raw-format has the levels of: localities, loggers and sensors.
Function <code><a href="#topic+mc_agg">mc_agg()</a></code> converts data from Raw-format to Agg-format.
Agg-format is designed mainly for calculations,analysis and microclimatic variables
derivations on the basis of cleaned microclimatic data.
Agg-format is missing the level of loggers. In Agg-format sensors are organized
directly in localities, without loggers.
</p>
<p>The highest hierarchical level of myClim structure is the <code>locality</code>. It has own metadata e.g.
coordinates and elevation. For detail description of locality metadata see <a href="#topic+mc_LocalityMetadata">mc_LocalityMetadata</a>.
On the locality in Raw-format there are <code>loggers</code>; in Agg-format the <code>sensors</code>.
See below. Loggers represents the files imported with myClim reading functions.
Both <code>loggesr</code> and <code>sensors</code> have own metadata. One logger could host more sensors e.g.
Tomst TMS logger hosing TMS_T1 soil temperature, TMS_T2 surface temperature,
TMS_T3 air temperature , TMS_moist soil moisture.
For detailed description of logger and sensor metadata
see <a href="#topic+mc_LoggerMetadata">mc_LoggerMetadata</a>, <a href="#topic+mc_SensorMetadata">mc_SensorMetadata</a>, <a href="#topic+mc_data_sensors">mc_data_sensors</a>
</p>
<p>In Raw-format Within the logger all sensors share time series. In Agg-format where level of
logger is missing, all sensors within the locality share time series. In Raw-format
the time series between the loggers or between the localities can be of different time
step. E.g. on the locality there can be one logger measuring in time step
15 minutes and another one measuring once a day.  In Agg-format this is not allowed.
Therefore it is necessary to use <code><a href="#topic+mc_agg">mc_agg()</a></code> to switch from Raw-format to the Agg-format.
</p>
<p>myClim time step is defined in seconds (<code>data$metadata@step</code>).
But some steps (especially irregular ones) may not be represented by seconds.
For example step <code>month</code> has variable number of seconds within the year. Therefore, metadata contains also text
representation of the step (<code>data$metadata@period</code>).
</p>
<p>Schema of myClim <strong>Raw-format</strong>
</p>
<pre>
            +-------------------------+
$metadata   | mc_MainMetadata - class |
            +-------------------------+
            | @version                |
            | @format_type            |
            +-------------------------+
            +-------------------------------------------------------------------------------+
$localities | locality[1]                                                                   |
            +-------------------------------------------------------------------------------+
            |           +-----------------------------+                                     |
            | $metadata | mc_LocalityMetadata - class |                                     |
            |           +-----------------------------+                                     |
            |           | @locality_id                |                                     |
            |           | @elevation                  |                                     |
            |           | @lat_wgs84                  |                                     |
            |           | @lon_wgs84                  |                                     |
            |           | @tz_offset                  |                                     |
            |           | @tz_type                    |                                     |
            |           | @user_data                  |                                     |
            |           +-----------------------------+                                     |
            |           +------------------------------------------------------------------+|
            | $loggers  | logger[1]                                                        ||
            |           +------------------------------------------------------------------+|
            |           |             +---------------------------+                        ||
            |           | $metadata   | mc_LoggerMetadata - class |                        ||
            |           |             +---------------------------+                        ||
            |           |             | @type                     |                        ||
            |           |             | @serial_number            |                        ||
            |           |             +---------------------------+                        ||
            |           |             +----------------------------+                       ||
            |           | $clean_info | mc_LoggerCleanInfo - class |                       ||
            |           |             +----------------------------+                       ||
            |           |             | @step                      |                       ||
            |           |             | @count_duplicities         |                       ||
            |           |             | @count_missing             |                       ||
            |           |             | @count_disordered          |                       ||
            |           |             | @rounded                   |                       ||
            |           |             +----------------------------+                       ||
            |           | $datetime   POSIXct vector                                       ||
            |           |             +---------------------------------------------------+||
            |           | $sensors    | sensor[1]                                         |||
            |           |             +---------------------------------------------------+||
            |           |             |              +---------------------------+        |||
            |           |             | $metadata    | mc_SensorMetadata - class |        |||
            |           |             |              +---------------------------+        |||
            |           |             |              | @sensor_id                |        |||
            |           |             |              | @name                     |        |||
            |           |             |              | @height                   |        |||
            |           |             |              | @calibrated               |        |||
            |           |             |              +---------------------------+        |||
            |           |             | $values      numeric/logical vector               |||
            |           |             |              +----------+------------+-----------+|||
            |           |             | $calibration | datetime | cor_factor | cor_slope ||||
            |           |             |              | ...      | ...        | ...       ||||
            |           |             |              +----------+------------+-----------+|||
            |           |             |              +-----+-------+-----+-------+        |||
            |           |             | $states      | tag | start | end | value |        |||
            |           |             |              | ... | ...   | ... | ...   |        |||
            |           |             |              +-----+-------+-----+-------+        |||
            |           |             +---------------------------------------------------+||
            |           |             +---------------------------------------------------+||
            |           |             | sensor[2]                                         |||
            |           |             +---------------------------------------------------+||
            |           |             ...                                                  ||
            |           |             +---------------------------------------------------+||
            |           |             | sensor[n]                                         |||
            |           |             +---------------------------------------------------+||
            |           +------------------------------------------------------------------+|
            |           +------------------------------------------------------------------+|
            |           | logger[2]                                                        ||
            |           +------------------------------------------------------------------+|
            |           ...                                                                 |
            |           +------------------------------------------------------------------+|
            |           | logger[n]                                                        ||
            |           +------------------------------------------------------------------+|
            +-------------------------------------------------------------------------------+
            +-------------------------------------------------------------------------------+
            | locality[2]                                                                   |
            +-------------------------------------------------------------------------------+
            ...
            +-------------------------------------------------------------------------------+
            | locality[n]                                                                   |
            +-------------------------------------------------------------------------------+</pre>
<p>Agg-format is the output of <code><a href="#topic+mc_agg">mc_agg()</a></code> function.
Agg-format is mainly designed for calculations which are faster in Agg and slower in Raw.
</p>
<p>Schema of myClim <strong>Agg-format</strong>
</p>
<pre>
            +----------------------------+
$metadata   | mc_MainMetadataAgg - class |
            +----------------------------+
            | @version                   |
            | @format_type               |
            | @step                      |
            | @period                    |
            | @intervals_start           |
            | @intervals_end             |
            +----------------------------+
            +-----------------------------------------------------------------+
$localities | locality[1]                                                     |
            +-----------------------------------------------------------------+
            |            +-----------------------------+                      |
            | $metadata  | mc_LocalityMetadata - class |                      |
            |            +-----------------------------+                      |
            |            | @locality_id                |                      |
            |            | @elevation                  |                      |
            |            | @lat_wgs84                  |                      |
            |            | @lon_wgs84                  |                      |
            |            | @tz_offset                  |                      |
            |            | @tz_type                    |                      |
            |            | @user_data                  |                      |
            |            +-----------------------------+                      |
            | $datetime  POSIXct vector                                       |
            |            +---------------------------------------------------+|
            | $sensors   | sensor[1]                                         ||
            |            +---------------------------------------------------+|
            |            |              +---------------------------+        ||
            |            | $metadata    | mc_SensorMetadata - class |        ||
            |            |              +---------------------------+        ||
            |            |              | @sensor_id                |        ||
            |            |              | @name                     |        ||
            |            |              | @height                   |        ||
            |            |              | @calibrated               |        ||
            |            |              +---------------------------+        ||
            |            | $values      numeric/logical vector               ||
            |            |              +----------+------------+-----------+||
            |            | $calibration | datetime | cor_factor | cor_slope |||
            |            |              | ...      | ...        | ...       |||
            |            |              +----------+------------+-----------+||
            |            |              +-----+-------+-----+-------+        ||
            |            | $states      | tag | start | end | value |        ||
            |            |              | ... | ...   | ... | ...   |        ||
            |            |              +-----+-------+-----+-------+        ||
            |            +---------------------------------------------------+|
            |            +---------------------------------------------------+|
            |            | sensor[2]                                         ||
            |            +---------------------------------------------------+|
            |            ...                                                  |
            |            +---------------------------------------------------+|
            |            | sensor[n]                                         ||
            |            +---------------------------------------------------+|
            +-----------------------------------------------------------------+
            +-----------------------------------------------------------------+
            | locality[2]                                                     |
            +-----------------------------------------------------------------+
            ...
            +-----------------------------------------------------------------+
            | locality[n]                                                     |
            +-----------------------------------------------------------------+</pre>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Vojtěch Kalčík <a href="mailto:Vojtech.Kalcik@ibot.cas.cz">Vojtech.Kalcik@ibot.cas.cz</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Matěj Man <a href="mailto:Matej.Man@ibot.cas.cz">Matej.Man@ibot.cas.cz</a>
</p>
</li>
<li><p> Martin Macek <a href="mailto:Martin.Macek@ibot.cas.cz">Martin.Macek@ibot.cas.cz</a>
</p>
</li>
<li><p> Josef Brůna <a href="mailto:Josef.Bruna@ibot.cas.cz">Josef.Bruna@ibot.cas.cz</a>
</p>
</li>
<li><p> Lucia Hederová <a href="mailto:Lucia.Hederova@ibot.cas.cz">Lucia.Hederova@ibot.cas.cz</a>
</p>
</li>
<li><p> Jan Wild <a href="mailto:Jan.Wild@ibot.cas.cz">Jan.Wild@ibot.cas.cz</a>
</p>
</li>
<li><p> Martin Kopecký <a href="mailto:Martin.Kopecky@ibot.cas.cz">Martin.Kopecky@ibot.cas.cz</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Institute of Botany of the Czech Academy of Sciences [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://labgis.ibot.cas.cz/myclim/index.html">http://labgis.ibot.cas.cz/myclim/index.html</a>
</p>
</li>
<li> <p><a href="https://github.com/ibot-geoecology/myClim">https://github.com/ibot-geoecology/myClim</a>
</p>
</li></ul>


<hr>
<h2 id='myClimList'>Custom list for myClim object</h2><span id='topic+myClimList'></span>

<h3>Description</h3>

<p>Top level list for store myClim data. (see <a href="#topic+myClim-package">myClim-package</a>) Rather service function used
for checking, whether object is myClimList. The same time can be used to create standard
R list from myClimList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myClimList(metadata = NULL, localities = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myClimList_+3A_metadata">metadata</code></td>
<td>
<p>of data object</p>
</td></tr>
<tr><td><code id="myClimList_+3A_localities">localities</code></td>
<td>
<p>list of licalities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list containing myClim object’s metadata and localities
</p>

<hr>
<h2 id='print.myClimList'>Print function for myClim object</h2><span id='topic+print.myClimList'></span>

<h3>Description</h3>

<p>Function print metadata of myClim object and table from function mc_info().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'myClimList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.myClimList_+3A_x">x</code></td>
<td>
<p>myClim object see <a href="#topic+myClim-package">myClim-package</a></p>
</td></tr>
<tr><td><code id="print.myClimList_+3A_...">...</code></td>
<td>
<p>other parameters from function print for tibble <a href="tibble.html#topic+tibble">tibble::tibble</a></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>print(mc_data_example_agg, n=10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
