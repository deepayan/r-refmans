<!DOCTYPE html><html><head><title>Help for package nicheROVER</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nicheROVER}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ellipse'><p>Point coordinates for a 2-D ellipse.</p></a></li>
<li><a href='#fish'><p>Fish stable isotope dataset.</p></a></li>
<li><a href='#niche.par.plot'><p>Plot for niche parameters.</p></a></li>
<li><a href='#niche.plot'><p>Plot for 2-d projection of niche regions.</p></a></li>
<li><a href='#niche.runif'><p>Uniform sampling from an elliptical niche region.</p></a></li>
<li><a href='#niche.size'><p>Calculate the size of an elliptical niche region.</p></a></li>
<li><a href='#nicheROVER-package'><p>(Niche) (R)egion and Niche (Over)lap Metrics for Multidimensional Ecological Niches.</p></a></li>
<li><a href='#niiw.post'><p>Random draws from the posterior distribution with Normal-Independent-Inverse-Wishart (NIIW) prior.</p></a></li>
<li><a href='#niw.coeffs'><p>Posterior coefficients of the Normal-Inverse-Wishart distribution with its conjugate prior.</p></a></li>
<li><a href='#niw.mom'><p>Mean and variance of the Normal-Inverse-Wishart distribution.</p></a></li>
<li><a href='#niw.post'><p>Random draws from the posterior distribution with Normal-Inverse-Wishart (NIW) prior.</p></a></li>
<li><a href='#overlap'><p>Monte Carlo calculation of niche region overlap metrics.</p></a></li>
<li><a href='#overlap.plot'><p>Plot the overlap metric.</p></a></li>
<li><a href='#overlap.unif'><p>Overlap calculation for uniform niche regions.</p></a></li>
<li><a href='#rniw'><p>Random draws from a Normal-Inverse-Wishart distribution.</p></a></li>
<li><a href='#rwish'><p>Random draws from a Wishart (or Inverse-Wishart) distribution.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Niche Region and Niche Overlap Metrics for Multidimensional
Ecological Niches</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of a probabilistic method to calculate 'nicheROVER' (_niche_ _r_egion and niche _over_lap) metrics using multidimensional niche indicator data (e.g., stable isotopes, environmental variables, etc.). The niche region is defined as the joint probability density function of the multidimensional niche indicators at a user-defined probability alpha (e.g., 95%).  Uncertainty is accounted for in a Bayesian framework, and the method can be extended to three or more indicator dimensions.  It provides directional estimates of niche overlap, accounts for species-specific distributions in multivariate niche space, and produces unique and consistent bivariate projections of the multivariate niche region.  The article by Swanson et al. (2015) &lt;<a href="https://doi.org/10.1890%2F14-0235.1">doi:10.1890/14-0235.1</a>&gt; provides a detailed description of the methodology.  See the package vignette for a worked example using fish stable isotope data.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlysy/nicheROVER">https://github.com/mlysy/nicheROVER</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlysy/nicheROVER/issues">https://github.com/mlysy/nicheROVER/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-13 15:51:22 UTC; mlysy</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Lysy [aut, cre],
  Ashley D. Stasko [aut],
  Heidi K. Swanson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Lysy &lt;mlysy@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-13 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ellipse'>Point coordinates for a 2-D ellipse.</h2><span id='topic+ellipse'></span>

<h3>Description</h3>

<p>Calculates coordinates of points for plotting a 2-dimensional ellipse based on user-defined parameters. Can be used for exploratory data analysis to produce ellipses at a given niche region size (e.g., <code class="reqn">\alpha = 95\%</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(mu, V, alpha = 0.95, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellipse_+3A_mu">mu</code></td>
<td>
<p>Centre of ellipse. A vector of length 2.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_v">V</code></td>
<td>
<p>Scale of ellipse. A 2x2 matrix. See 'Details'.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_alpha">alpha</code></td>
<td>
<p>Niche region size. See 'Details'.</p>
</td></tr>
<tr><td><code id="ellipse_+3A_n">n</code></td>
<td>
<p>Number of points to return for plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the coordinates needed to plot a 2-dimensional ellipse based on user-defined parameters, such that <code>X = c(x,y)</code> satisfies the equation
</p>
<p style="text-align: center;"><code class="reqn">
(X-\mu)' V^{-1} (X-\mu) = C,
</code>
</p>

<p>where <code class="reqn">C=\code{qchisq(alpha, df = 2)}</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of coordinates <code>cbind(x,y)</code> to plot a 2-dimensional ellipse.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niche.plot">niche.plot()</a></code> for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- rnorm(2)
V &lt;- crossprod(matrix(rnorm(4), 2, 2))
ell.pts &lt;- ellipse(mu = mu, V = V, alpha = .9, n = 100)
plot(ell.pts, col = rainbow(110)[1:100], type = "o")
points(mu[1], mu[2], pch = "+")
</code></pre>

<hr>
<h2 id='fish'>Fish stable isotope dataset.</h2><span id='topic+fish'></span>

<h3>Description</h3>

<p>A dataset containing values for three stable isotopes measured in the muscle tissue of four species of arctic fish. For use in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fish
</code></pre>


<h3>Format</h3>

<p>A data frame with 278 rows (observations) and 4 columns (species, <code class="reqn">\delta^{15}N</code>, <code class="reqn">\delta^{13}C</code>, and <code class="reqn">\delta^{34}S</code>).
</p>


<h3>Details</h3>

<p>This dataset contains <code class="reqn">\delta^{15}N</code>, <code class="reqn">\delta^{13}C</code>, and <code class="reqn">delta^{34}S</code> values for the following fish species:
</p>

<ul>
<li><p> ARCS - Arctic Cisco (<em>Coregonus autumnalis</em>), <code class="reqn">n = 69</code>.
</p>
</li>
<li><p> BDWF - Broad Whitefish (<em>Coregonus nasus</em>), <code class="reqn">n = 71</code>.
</p>
</li>
<li><p> LKWF - Lake Whitefish (<em>Coregonus clupeaformis</em>), <code class="reqn">n = 67</code>.
</p>
</li>
<li><p> LSCS - Least Cisco (<em>Coregonus sardinella</em>), <code class="reqn">n = 70</code>
</p>
</li></ul>



<h3>Source</h3>

<p>Fish were collected between 2007 and 2008 from an estuarine area of the Beaufort Sea, North and West of the Mackenzie Delta at Phillips Bay, Yukon Territory, Canada (69.28 N, 138.49 W).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(fish)
aggregate(fish[2:4], fish[1], mean)
</code></pre>

<hr>
<h2 id='niche.par.plot'>Plot for niche parameters.</h2><span id='topic+niche.par.plot'></span>

<h3>Description</h3>

<p>For one or more species, plots some or all of the niche parameters <code class="reqn">\mu</code> and <code class="reqn">\Sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche.par.plot(
  niche.par,
  plot.mu = TRUE,
  plot.Sigma = TRUE,
  plot.index,
  col,
  ndens = 512,
  ylab
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche.par.plot_+3A_niche.par">niche.par</code></td>
<td>
<p>List with <code>nspecies = length(niche.par)</code>, each element of which is a list with parameters <code>mu</code> and <code>Sigma</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_plot.mu">plot.mu</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, plot the distribution of <code class="reqn">\mu</code> for each niche indicator (e.g., stable isotope).  See 'Details'.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_plot.sigma">plot.Sigma</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, plot the distribution of <code class="reqn">\Sigma</code> for each niche indicator.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_plot.index">plot.index</code></td>
<td>
<p>Either a scalar of a numeric vector of length 2.  If <code>plot.index = i</code> then plot the distribution of <code class="reqn">\mu_i</code>.  If <code>plot.index = c(i,j)</code> then plot the distribution of <code class="reqn">\Sigma_{ij}</code>.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_col">col</code></td>
<td>
<p>Vector of colors in which to plot each species.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_ndens">ndens</code></td>
<td>
<p>Number of points at which to evaluate density estimates.</p>
</td></tr>
<tr><td><code id="niche.par.plot_+3A_ylab">ylab</code></td>
<td>
<p>Optional label for <code class="reqn">y</code>-axis.  If missing, defaults to <code class="reqn">p(\mu_i | X)</code> and <code class="reqn">p(\Sigma_{ij} | X)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each element of the list <code>niche.par</code> is a distribution of niche parameters.  That is, <code>names(niche.par[[1]]) = c("mu", "Sigma")</code>, and if <code>niso</code> is the number of niche indicators (e.g., stable isotopes), then <code>dim(niche.par[[1]]$mu) = c(nsamples, niso)</code> and <code>dim(niche.par[[1]]$Sigma) = c(niso, niso, nsamples)</code>.
</p>


<h3>Value</h3>

<p>Returns a plot of the distribution of some or all niche parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niw.post">niw.post()</a></code>, <code><a href="#topic+niiw.post">niiw.post()</a></code> for niche parameter output, <code><a href="stats.html#topic+density">stats::density()</a></code> for density estimation from sample data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fish data
data(fish)

# generate parameter draws from the "default" posteriors of each fish
nsamples &lt;- 1e3
system.time({
  fish.par &lt;- tapply(1:nrow(fish), fish$species,
                     function(ii) niw.post(nsamples = nsamples, X = fish[ii,2:4]))
})

# various parameter plots
clrs &lt;- c("black", "red", "blue", "orange") # colors for each species

# mu1, mu2, and Sigma12
par(mar = c(4, 4, .5, .1)+.1, mfrow = c(1,3))
niche.par.plot(fish.par, col = clrs, plot.index = 1)
niche.par.plot(fish.par, col = clrs, plot.index = 2)
niche.par.plot(fish.par, col = clrs, plot.index = 1:2)
legend("topright", legend = names(fish.par), fill = clrs)

# all mu
niche.par.plot(fish.par, col = clrs, plot.mu = TRUE, plot.Sigma = FALSE)
legend("topright", legend = names(fish.par), fill = clrs)

# all mu and Sigma
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(fish.par, col = clrs, plot.mu = TRUE, plot.Sigma = TRUE)
legend("topright", legend = names(fish.par), fill = clrs)
</code></pre>

<hr>
<h2 id='niche.plot'>Plot for 2-d projection of niche regions.</h2><span id='topic+niche.plot'></span>

<h3>Description</h3>

<p>For one or more species, creates a series of plots: (i) the raw niche indicators (e.g., stable isotope) data, (ii) their density estimates, and (iii) 2-dimensional projections of probabilistic niche regions based on <code class="reqn">n</code>-dimensionsional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche.plot(
  niche.par,
  niche.data,
  alpha = 0.95,
  species.names,
  iso.names,
  lims,
  col,
  ndens = 512,
  pfrac = 0,
  xlab,
  legend = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche.plot_+3A_niche.par">niche.par</code></td>
<td>
<p>A list of length <code>nspecies</code>, each element of which in turn is a list with elements <code>mu</code> and <code>Sigma</code>.  Each of these will correspond to an ellipse being drawn for that species in the corresponding 2-d plane. See 'Example'.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_niche.data">niche.data</code></td>
<td>
<p>A list of length <code>nspecies</code>, each element of which is a matrix with observations along the rows and niche indicators (e.g., stable isotopes) along the columns.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_alpha">alpha</code></td>
<td>
<p>Size of the niche region to plot. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_species.names">species.names</code></td>
<td>
<p>Names of the species. Defaults to <code>names(niche.par)</code>.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_iso.names">iso.names</code></td>
<td>
<p>Names of the niche indicators (or isotopes) to plot. Defaults to <code>colnames(niche.par)</code>.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_lims">lims</code></td>
<td>
<p>Two-row matrix of range limits for each niche indicator.  Defaults to include all ellipses.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_col">col</code></td>
<td>
<p>Vector of colours in which each species will be drawn.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_ndens">ndens</code></td>
<td>
<p>Number of points at which to evaluate kernel density estimates.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_pfrac">pfrac</code></td>
<td>
<p>Fraction of the plot on which to display 1-dimensional raw niche indicator data. <code>pfrac = 0</code> means don't display the raw data in 1-d.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_xlab">xlab</code></td>
<td>
<p>Title of plot, located on the bottom.  Defaults to no title.</p>
</td></tr>
<tr><td><code id="niche.plot_+3A_legend">legend</code></td>
<td>
<p>Whether or not to add a legend.  Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of plots is created for each pairwise combination of niche indicators.  Below the diagonal are scatterplots for each species, above the diagonal are ellipses corresponding to 2-d projections of the probabilistic niche regions.  The diagonal displays density estimates for each indicator, and optionally the raw 1-d data.  See Swanson et al. (2015) for detailed description of the probabilistic niche region.
</p>


<h3>Value</h3>

<p>Returns a series of plots displaying niche indicator data and their probabilistic niche projections.
</p>


<h3>References</h3>

<p>Swanson, H.K., Lysy, M., Stasko, A.D., Power, M., Johnson, J.D., and Reist, J.D. &quot;A new probabilistic method for quantifying n-dimensional ecological niches and niche overlap.&quot; <em>Ecology: Statistical Reports</em> 96:2 (2015): 318-324. <a href="https://doi.org/10.1890/14-0235.1">doi:10.1890/14-0235.1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlap.plot">overlap.plot()</a></code>, <code><a href="#topic+niw.post">niw.post()</a></code>, <code><a href="#topic+niiw.post">niiw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fish) # 4 fish, 3 isotopes

# generate 10 parameter draws from the posteriors
# of each fish with default prior
nsamples &lt;- 10
fish.par &lt;- tapply(1:nrow(fish), fish$species,
                   function(ii) niw.post(nsamples = nsamples, X = fish[ii,2:4]))

# format data for plotting function
fish.data &lt;- tapply(1:nrow(fish), fish$species, function(ii) X = fish[ii,2:4])

clrs &lt;- c("black", "red", "blue", "orange") # colors for each species
niche.plot(niche.par = fish.par, niche.data = fish.data, pfrac = .1,
           iso.names = expression(delta^{15}*N, delta^{13}*C, delta^{34}*S),
           col = clrs, xlab = expression("Isotope Ratio (per mille)"))
</code></pre>

<hr>
<h2 id='niche.runif'>Uniform sampling from an elliptical niche region.</h2><span id='topic+niche.runif'></span>

<h3>Description</h3>

<p>Uniform sampling from an elliptical niche region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche.runif(n, mu, Sigma, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche.runif_+3A_n">n</code></td>
<td>
<p>Number of random draws.</p>
</td></tr>
<tr><td><code id="niche.runif_+3A_mu">mu</code></td>
<td>
<p>Mean vector.</p>
</td></tr>
<tr><td><code id="niche.runif_+3A_sigma">Sigma</code></td>
<td>
<p>Variance matrix.</p>
</td></tr>
<tr><td><code id="niche.runif_+3A_alpha">alpha</code></td>
<td>
<p>Probabilistic niche size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IID draws from a uniform distribution on the elliptical niche region.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ellipse">ellipse()</a></code> and <code><a href="#topic+niche.size">niche.size()</a></code> for the definition of the elliptical niche region.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2d example
d &lt;- 2 # number of dimensions
V &lt;- crossprod(matrix(rnorm(4),d,d))
mu &lt;- rnorm(d)
plot(ellipse(mu, V), type = "l")
points(niche.runif(1e4, mu, V), col = "brown", pch = ".")
</code></pre>

<hr>
<h2 id='niche.size'>Calculate the size of an elliptical niche region.</h2><span id='topic+niche.size'></span>

<h3>Description</h3>

<p>Calculate the size of an elliptical niche region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche.size(Sigma, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche.size_+3A_sigma">Sigma</code></td>
<td>
<p>Variance matrix for normally distributed niche axes.</p>
</td></tr>
<tr><td><code id="niche.size_+3A_alpha">alpha</code></td>
<td>
<p>Probabilistic niche size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given niche region <code class="reqn">N_R</code>, the niche size is defined as the hypervolume of this region: <code class="reqn">N_S = \int_{x \in N_R} d x</code>.
</p>


<h3>Value</h3>

<p>Hypervolume niche size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for each species, size of 95% niche region using sample variance
tapply(1:nrow(fish), fish$species, function(ind) {
  X &lt;- fish[ind,2:4] # all measurements for given species
  Sighat &lt;- var(X) # sample variance
  niche.size(Sigma = Sighat, alpha = .95)
})
</code></pre>

<hr>
<h2 id='nicheROVER-package'>(Niche) (R)egion and Niche (Over)lap Metrics for Multidimensional Ecological Niches.</h2><span id='topic+nicheROVER'></span><span id='topic+nicheROVER-package'></span>

<h3>Description</h3>

<p>This package uses a probabilistic method to calculate niche regions and pairwise niche overlap using multidimensional niche indicator data (e.g., stable isotopes, environmental variables, etc.). The niche region is defined as the joint probability density function of the multidimensional niche indicators at a user-defined probability alpha (e.g., 95%).  Uncertainty is accounted for in a Bayesian framework, and the method can be extended to three or more indicator dimensions.  It provides directional estimates of niche overlap, accounts for species-specific distributions in multivariate niche space, and produces unique and consistent bivariate projections of the multivariate niche region. See Swanson et al. (2014) for a detailed description and worked example below using fish stable isotope data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Lysy <a href="mailto:mlysy@uwaterloo.ca">mlysy@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Ashley D. Stasko
</p>
</li>
<li><p> Heidi K. Swanson
</p>
</li></ul>



<h3>References</h3>

<p>Swanson, H.K., Lysy, M., Stasko, A.D., Power, M., Johnson, J.D., and Reist, J.D. &quot;A new probabilistic method for quantifying n-dimensional ecological niches and niche overlap.&quot; <em>Ecology: Statistical Reports</em> 96:2 (2015): 318-324. <a href="https://doi.org/10.1890/14-0235.1">doi:10.1890/14-0235.1</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlysy/nicheROVER">https://github.com/mlysy/nicheROVER</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlysy/nicheROVER/issues">https://github.com/mlysy/nicheROVER/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># analysis for fish data

data(fish) # 4 fish, 3 isotopes
aggregate(fish[2:4], fish[1], mean) # isotope means per fish

# random draws from posterior distribution with default prior
nsamples &lt;- 500
fish.par &lt;- tapply(1:nrow(fish), fish$species,
                   function(ii) niw.post(nsamples = nsamples, X = fish[ii,2:4]))

# display p(mu | X) and p(Sigma | X) for each fish
clrs &lt;- c("black", "red", "blue", "orange") # colors for each species
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(fish.par, col = clrs)
legend(x = "topright", legend = names(fish.par), fill = clrs)

# 2-d projections of 10 niche regions
nsamples &lt;- 10
fish.par &lt;- tapply(1:nrow(fish), fish$species,
                   function(ii) niw.post(nsamples = nsamples, X = fish[ii,2:4]))

# format data for plotting function
fish.data &lt;- tapply(1:nrow(fish), fish$species, function(ii) X = fish[ii,2:4])

niche.plot(niche.par = fish.par, niche.data = fish.data, pfrac = .05,
           iso.names = expression(delta^{15}*N, delta^{13}*C, delta^{34}*S),
           col = clrs, xlab = expression("Isotope Ratio (per mille)"))

# niche overlap plots for 95% niche region sizes

# overlap calculation.  use nsamples = nprob = 1e4 for higher accuracy.
nsamples &lt;- 500
over.stat &lt;- overlap(fish.par, nreps = nsamples, nprob = nsamples, alpha = .95)

# overlap plot
overlap.plot(over.stat, col = clrs, mean.cred.col = "turquoise",
             equal.axis = TRUE,
             xlab = "Overlap Probability (%) -- Niche Region Size: 95%")
</code></pre>

<hr>
<h2 id='niiw.post'>Random draws from the posterior distribution with Normal-Independent-Inverse-Wishart (NIIW) prior.</h2><span id='topic+niiw.post'></span>

<h3>Description</h3>

<p>Given iid <code class="reqn">d</code>-dimensional niche indicators  <code class="reqn">X = (X_1,\ldots,X_N)</code> with <code class="reqn">X_i \sim N(\mu, \Sigma)</code>, this function generates random draws from <code class="reqn">p(\mu,\Sigma | X)</code> for the Normal-Independent-Inverse-Wishart (NIIW) prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niiw.post(nsamples, X, lambda, Omega, Psi, nu, mu0 = lambda, burn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niiw.post_+3A_nsamples">nsamples</code></td>
<td>
<p>The number of posterior draws.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_x">X</code></td>
<td>
<p>A data matrix with observations along the rows.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_lambda">lambda</code></td>
<td>
<p>Mean of <code class="reqn">\mu</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_omega">Omega</code></td>
<td>
<p>Variance of <code class="reqn">\mu</code>. Defaults to <code>Omega = 0</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix of <code class="reqn">\Sigma</code>. Defaults to <code>Psi = 0</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom of <code class="reqn">\Sigma</code>. Defaults to <code>nu = ncol(X)+1</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_mu0">mu0</code></td>
<td>
<p>Initial value of <code class="reqn">\mu</code> to start the Gibbs sampler.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niiw.post_+3A_burn">burn</code></td>
<td>
<p>Burn-in for the MCMC sampling algorithm.  Either an integer giving the number of initial samples to discard, or a fraction with <code style="white-space: pre;">&#8288;0 &lt; burn &lt; 1&#8288;</code>.  Defaults to <code>burn = floor(nsamples/10)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIIW distribution <code class="reqn">p(\mu, \Sigma | \lambda, \kappa, \Psi, \nu)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma \sim W^{-1}(\Psi, \nu), \quad \mu | \Sigma \sim N(\lambda, \Omega).
</code>
</p>

<p>The default value <code>Omega = 0</code> uses the Lebesque prior on <code class="reqn">\mu</code>: <code class="reqn">p(\mu) \propto 1</code>.  In this case the NIW and NIIW priors produce identical resuls, but <code><a href="#topic+niw.post">niw.post()</a></code> is faster.
</p>
<p>The default value <code>Psi = 0</code> uses the scale-invariant prior on <code class="reqn">\Sigma</code>: <code class="reqn">p(\Sigma) \propto |\Sigma|^{-(\nu+d+1)/2}</code>.
</p>
<p>The default value <code>nu = ncol(X)+1</code> for <code>Omega = 0</code> and <code>Psi = 0</code> makes <code class="reqn">E[\mu|X]=`colMeans(X)`</code> and <code class="reqn">E[\Sigma | X]=`var(X)`</code>.
</p>
<p>Random draws are obtained by a Markov chain Monte Carlo (MCMC) algorithm; specifically, a Gibbs sampler alternates between draws from <code class="reqn">p(\mu | \Sigma, X)</code> and <code class="reqn">p(\Sigma | \mu, X)</code>, which are Normal and Inverse-Wishart distributions respectively.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>mu</code> and <code>Sigma</code> of sizes <code>c(nsamples, length(lambda))</code> and <code>c(dim(Psi), nsamples)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+niw.post">niw.post()</a></code>, <code><a href="#topic+rwish">rwish()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate normal data with mean and variance (mu0, Sigma0)
d &lt;- 4
mu0 &lt;- rnorm(d)
Sigma0 &lt;- matrix(rnorm(d^2), d, d)
Sigma0 &lt;- Sigma0 %*% t(Sigma0)
N &lt;- 1e2
X &lt;- matrix(rnorm(N*d), N, d) # iid N(0,1)
X &lt;- t(t(X %*% chol(Sigma0)) + mu0) # each row is N(mu0, Sigma)

# prior parameters
# flat prior on mu
lambda &lt;- 0
Omega &lt;- 0
# informative prior on Sigma
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d))
nu &lt;- 5

# sample from NIIW posterior
nsamples &lt;- 2e3
system.time({
  siiw &lt;- niiw.post(nsamples, X, lambda, Omega, Psi, nu, burn = 100)
})

# sample from NIW posterior
kappa &lt;- 0
system.time({
  siw &lt;- niw.post(nsamples, X, lambda, kappa, Psi, nu)
})

# check that posteriors are the same

# p(mu | X)
clrs &lt;- c("black", "red")
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(list(siiw, siw), col = clrs, plot.mu = TRUE, plot.Sigma = FALSE)
legend(x = "topright", legend = c("NIIW Prior", "NIW Prior"), fill = clrs)

# p(Sigma | X)
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(list(siiw, siw), col = clrs, plot.mu = FALSE, plot.Sigma = TRUE)
legend(x = "topright", legend = c("NIIW Prior", "NIW Prior"), fill = clrs)
</code></pre>

<hr>
<h2 id='niw.coeffs'>Posterior coefficients of the Normal-Inverse-Wishart distribution with its conjugate prior.</h2><span id='topic+niw.coeffs'></span>

<h3>Description</h3>

<p>Given iid <code class="reqn">d</code>-dimensional niche indicators <code class="reqn">X = (X_1,\ldots,X_N)</code> with <code class="reqn">X_i \sim N(\mu, \Sigma)</code>, this function calculates the coefficients of the Normal-Inverse-Wishart (NIW) posterior <code class="reqn">p(\mu, \Sigma | X)</code> for a conjugate NIW prior.  Together with <code><a href="#topic+niw.mom">niw.mom()</a></code>, this can be used to rapidly compute the point estimates <code class="reqn">E[\mu | X]</code> and <code class="reqn">E[\Sigma | X]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niw.coeffs(X, lambda, kappa, Psi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niw.coeffs_+3A_x">X</code></td>
<td>
<p>A data matrix with observations along the rows.</p>
</td></tr>
<tr><td><code id="niw.coeffs_+3A_lambda">lambda</code></td>
<td>
<p>Location parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.coeffs_+3A_kappa">kappa</code></td>
<td>
<p>Scale parameter. Defaults to <code>kappa = 0</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.coeffs_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix. Defaults to <code>Psi = 0</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.coeffs_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom. Defaults to <code>nu = ncol(X)+1</code>.  See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIW distribution <code class="reqn">p(\mu, \Sigma | \lambda, \kappa, \Psi, \nu)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma \sim W^{-1}(\Psi, \nu), \quad \mu | \Sigma \sim N(\lambda, \Sigma/\kappa).
</code>
</p>

<p>The default value <code>kappa = 0</code> uses the Lebesque prior on <code class="reqn">\mu</code>: <code class="reqn">p(\mu) \propto 1</code>.
</p>
<p>The default value <code>Psi = 0</code> uses the scale-invariant prior on <code class="reqn">\Sigma</code>: <code class="reqn">p(\Sigma) \propto |\Sigma|^{-(\nu+d+1)/2}</code>.
</p>
<p>The default value <code>nu = ncol(X)+1</code> for <code>kappa = 0</code> and <code>Psi = 0</code> makes <code class="reqn">E[\mu|X]=`colMeans(X)`</code> and <code class="reqn">E[\Sigma | X]=`var(X)`</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>lambda</code>, <code>kappa</code>, <code>Psi</code>, <code>nu</code> corresponding to the coefficients of the NIW posterior distribution <code class="reqn">p(\mu, \Sigma | X)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rniw">rniw()</a></code>, <code><a href="#topic+niw.mom">niw.mom()</a></code>, <code><a href="#topic+niw.post">niw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NIW prior coefficients
d &lt;- 3
lambda &lt;- rnorm(d)
kappa &lt;- 5
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d))
nu &lt;- 10

# data
data(fish)
X &lt;- fish[fish$species == "ARCS",2:4]

# NIW posterior coefficients
post.coef &lt;- niw.coeffs(X, lambda, kappa, Psi, nu)

# compare
mu.mean &lt;- niw.mom(post.coef$lambda, post.coef$kappa, post.coef$Psi, post.coef$nu)$mu$mean
mu.est &lt;- rbind(prior = niw.mom(lambda, kappa, Psi, nu)$mu$mean,
                data = colMeans(X),
                post = mu.mean)
round(mu.est, 2)
</code></pre>

<hr>
<h2 id='niw.mom'>Mean and variance of the Normal-Inverse-Wishart distribution.</h2><span id='topic+niw.mom'></span>

<h3>Description</h3>

<p>This function computes the mean and variance of the Normal-Inverse-Wishart (NIW) distribution.  Can be used to very quickly compute Bayesian point estimates for the conjugate NIW prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niw.mom(lambda, kappa, Psi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niw.mom_+3A_lambda">lambda</code></td>
<td>
<p>Location parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.mom_+3A_kappa">kappa</code></td>
<td>
<p>Scale parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.mom_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.mom_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom.  See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIW distribution <code class="reqn">p(\mu, \Sigma | \lambda, \kappa, \Psi, \nu)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma \sim W^{-1}(\Psi, \nu), \quad \mu | \Sigma \sim N(\lambda, \Sigma/\kappa).
</code>
</p>

<p>Note that cov<code class="reqn">(\mu, \Sigma) = 0</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>mu</code> and <code>Sigma</code>, each containing lists with elements <code>mean</code> and <code>var</code>.  For <code>mu</code> these elements are of size <code>length(lambda)</code> and <code>c(length(lambda),length(lambda))</code>.  For <code>Sigma</code> they are of size <code>dim(Psi)</code> and <code>c(dim(Psi), dim(Psi))</code>, such that cov<code class="reqn">(\Sigma_{ij}, \Sigma_{kl})=</code><code>Sigma$var[i,j,k,l]</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rniw">rniw()</a></code>, <code><a href="#topic+niw.coeffs">niw.coeffs()</a></code>, <code><a href="#topic+niw.post">niw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NIW parameters
d &lt;- 3 # number of dimensions
lambda &lt;- rnorm(d)
kappa &lt;- 2
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d))
nu &lt;- 10

# simulate data
niw.sim &lt;- rniw(n = 1e4, lambda, kappa, Psi, nu)

# check moments
niw.mV &lt;- niw.mom(lambda, kappa, Psi, nu)

# mean of mu
ii &lt;- 1
c(true = niw.mV$mu$mean[ii], sim = mean(niw.sim$mu[,ii]))

# variance of Sigma
II &lt;- c(1,2)
JJ &lt;- c(2,3)
c(true = niw.mV$var[II[1],II[2],JJ[1],JJ[2]],
  sim = cov(niw.sim$Sigma[II[1],II[2],], niw.sim$Sigma[JJ[1],JJ[2],]))
</code></pre>

<hr>
<h2 id='niw.post'>Random draws from the posterior distribution with Normal-Inverse-Wishart (NIW) prior.</h2><span id='topic+niw.post'></span>

<h3>Description</h3>

<p>Given iid <code class="reqn">d</code>-dimensional niche indicators  <code class="reqn">X = (X_1,\ldots,X_N)</code> with <code class="reqn">X_i \sim N(\mu, \Sigma)</code>, this function generates random draws from <code class="reqn">p(\mu,\Sigma | X)</code> for the Normal-Inverse-Wishart (NIW) prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niw.post(nsamples, X, lambda, kappa, Psi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niw.post_+3A_nsamples">nsamples</code></td>
<td>
<p>The number of posterior draws.</p>
</td></tr>
<tr><td><code id="niw.post_+3A_x">X</code></td>
<td>
<p>A data matrix with observations along the rows.</p>
</td></tr>
<tr><td><code id="niw.post_+3A_lambda">lambda</code></td>
<td>
<p>Location parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.post_+3A_kappa">kappa</code></td>
<td>
<p>Scale parameter. Defaults to <code>kappa = 0</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="niw.post_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix. Defaults to <code>Psi = 0</code>.  See Details.</p>
</td></tr>
<tr><td><code id="niw.post_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom. Defaults to <code>nu = ncol(X)+1</code>.  See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIW distribution <code class="reqn">p(\mu, \Sigma | \lambda, \kappa, \Psi, \nu)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma \sim W^{-1}(\Psi, \nu), \quad \mu | \Sigma \sim N(\lambda, \Sigma/\kappa).
</code>
</p>

<p>The default value <code>kappa = 0</code> uses the Lebesque prior on <code class="reqn">\mu</code>: <code class="reqn">p(\mu) \propto 1</code>.
</p>
<p>The default value <code>Psi = 0</code> uses the scale-invariant prior on <code class="reqn">\Sigma</code>: <code class="reqn">p(\Sigma) \propto |\Sigma|^{-(\nu+d+1)/2}</code>.
</p>
<p>The default value <code>nu = ncol(X)+1</code> for <code>kappa = 0</code> and <code>Psi = 0</code> makes <code class="reqn">E[\mu|X]=\code{colMeans(X)}</code> and <code class="reqn">E[\Sigma | X]=\code{var(X)}</code>.
</p>


<h3>Value</h3>

<p>Returns a list with elements <code>mu</code> and <code>Sigma</code> of sizes <code>c(nsamples, length(lambda))</code> and <code>c(dim(Psi), nsamples)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rniw">rniw()</a></code>, <code><a href="#topic+niiw.post">niiw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare the default non-informative prior to an arbitrary informative prior
# for simulated data

# simulate normal data with mean and variance (mu0, Sigma0)
d &lt;- 4
mu0 &lt;- rnorm(d)
Sigma0 &lt;- matrix(rnorm(d^2), d, d)
Sigma0 &lt;- Sigma0 %*% t(Sigma0)
N &lt;- 1e2
X &lt;- matrix(rnorm(N*d), N, d) # iid N(0,1)
X &lt;- t(t(X %*% chol(Sigma0)) + mu0) # each row is N(mu0, Sigma)

# informative prior parameters
lambda &lt;- rnorm(d)
kappa &lt;- 20
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d))
nu &lt;- 5

# iid draws from informative prior pi(mu, Sigma)
nsamples &lt;- 2e3
siw0 &lt;- rniw(nsamples, lambda, kappa, Psi, nu)

# iid draws from posterior p(mu, Sigma | X) with informative prior
siw1 &lt;- niw.post(nsamples, X, lambda, kappa, Psi, nu)

# iid draws from posterior p(mu, Sigma | X) with default noninformative prior
siw2 &lt;- niw.post(nsamples, X)

# compare

# prior and posterior densities of mu
clrs &lt;- c("orange", "red", "blue", "black")
ii &lt;- 1
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(list(siw0, siw1, siw2), col = clrs[1:3],
               plot.index = ii, ylab = "Density")
abline(v = mu0[ii], col = clrs[4]) # true value of mu
legend(x = "topright",
       legend = c(parse(text = paste0("pi(mu[", ii, "])")),
                  parse(text = paste0("p(mu[", ii, "]*\" | \"*X)*\", Informative Prior\"")),
                  parse(text = paste0("p(mu[", ii, "]*\" | \"*X)*\", Noninformative Prior\"")),
                  parse(text = paste0("\"True value of \"*mu[", ii, "]"))),
       fill = clrs)

# prior and posterior densities of Sigma
ii &lt;- 1
jj &lt;- 2
par(mar = c(4.2, 4.2, 2, 1)+.1)
niche.par.plot(list(siw0, siw1, siw2), col = clrs[1:3],
               plot.index = c(ii,jj), ylab = "Density")
abline(v = Sigma0[ii,jj], col = clrs[4])
legend(x = "topright",
       legend = c(parse(text = paste0("pi(Sigma[", ii, "*", jj, "])")),
                  parse(text = paste0("p(Sigma[", ii, "*", jj,
                                      "]*\" | \"*X)*\", Informative Prior\"")),
                  parse(text = paste0("p(Sigma[", ii, "*", jj,
                                      "]*\" | \"*X)*\", Noninformative Prior\"")),
                  parse(text = paste0("\"True value of \"*Sigma[", ii, "*", jj, "]"))),
       fill = clrs)

</code></pre>

<hr>
<h2 id='overlap'>Monte Carlo calculation of niche region overlap metrics.</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>Calculates the distribution of a niche region overlap metric for each pairwise species combination and user-specified niche region sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(
  niche.par,
  nreps,
  nprob,
  alpha = 0.95,
  species.names,
  norm.redraw = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_niche.par">niche.par</code></td>
<td>
<p>A list with <code>nspecies = length(niche.par)</code>, each element of which in turn is a list with elements <code>mu</code> and <code>Sigma</code>.  See Details.</p>
</td></tr>
<tr><td><code id="overlap_+3A_nreps">nreps</code></td>
<td>
<p>The number of overlap metric calculations for each species.  Defaults to the smallest number of parameter samples supplied by <code>niche.par</code>.  See 'Details'.</p>
</td></tr>
<tr><td><code id="overlap_+3A_nprob">nprob</code></td>
<td>
<p>The number of normal draws for each Monte Carlo overlap metric calculation.  See 'Details'.</p>
</td></tr>
<tr><td><code id="overlap_+3A_alpha">alpha</code></td>
<td>
<p>Scalar or vector of niche region sizes for calculating the niche overlap metric. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="overlap_+3A_species.names">species.names</code></td>
<td>
<p>Names of the species. Defaults to <code>names(niche.par)</code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_norm.redraw">norm.redraw</code></td>
<td>
<p>Logical. If <code>FALSE</code>, the same <code>nprob*nspecies</code> iid <code class="reqn">N(0,1)</code> draws are used for each calculation of the overlap metric. This increases the Monte Carlo error, but the procedure is about 1.5x faster.  Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overlap metric is the probability that a randomly drawn individual from species <code class="reqn">A</code> will be found within the niche region of species <code class="reqn">B</code> (for a given niche region size, e.g., <code>alpha = .95</code>).  It is a single number which is a function of the parameters for each species, <code class="reqn">\Theta_A = (\mu_A, \Sigma_A)</code> and <code class="reqn">\Theta_B = (\mu_B, \Sigma_B)</code>.  This number is difficult to calculate directly, but easy to approximate stochastically by generating <code>nprob</code> draws from the distribution of species <code class="reqn">A</code> and counting the fraction of them which fall in the niche region of species <code class="reqn">B</code>.
</p>
<p>Typically the true values of <code class="reqn">\Theta_A</code> and <code class="reqn">\Theta_B</code> are unknown and must be estimated from the data. Thus, the overlap metric is calculated for <code>nreps</code> combinations of samples from <code class="reqn">p(\Theta_A | X)</code> and <code class="reqn">p(\Theta_B | X)</code> which are supplied in <code>niche.par</code>.
</p>
<p>See Swanson et al. (2015) for a detailed description of niche overlap and its calculation.
</p>


<h3>Value</h3>

<p>Returns an array of size <code>c(nspecies, nspecies, nreps, nlevels)</code>, where <code>nlevels</code> is the number of alpha levels at which to calculate the overlap metric.  For each of the last two dimensions of the output array, the first two dimensions form an <code>nspecies</code> by <code>nspecies</code> matrix giving each pairwise calculation of overlap metric between two species for given <code class="reqn">\Theta_A</code>, <code class="reqn">\Theta_B</code>, and <code>alpha</code>. In each of these matrices, Species <code class="reqn">A</code> is along the rows of this matrix and Species <code class="reqn">B</code> is along the columns.
</p>


<h3>References</h3>

<p>Swanson, H.K., Lysy, M., Stasko, A.D., Power, M., Johnson, J.D., and Reist, J.D. &quot;A new probabilistic method for quantifying n-dimensional ecological niches and niche overlap.&quot; <em>Ecology: Statistical Reports</em> 96:2 (2015): 318-324. <a href="https://doi.org/10.1890/14-0235.1">doi:10.1890/14-0235.1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlap.plot">overlap.plot()</a></code>, <code><a href="#topic+niw.post">niw.post()</a></code>, <code><a href="#topic+niiw.post">niiw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fish data
data(fish)

# generate parameter draws from the "default" posteriors of each fish
nsamples &lt;- 500
system.time({
  fish.par &lt;- tapply(1:nrow(fish), fish$species,
                     function(ii) niw.post(nsamples = nsamples, X = fish[ii,2:4]))
})

# overlap calculation. use nsamples = nprob = 1e4 for more accurate results.
system.time({
  over &lt;- overlap(fish.par, nreps = nsamples, nprob = nsamples,
                  alpha = c(.95, .99))
})

# posterior expectations of overlap metrics
over.mean &lt;- apply(over*100, c(1:2, 4), mean)
round(over.mean)

# posterior 95% credible intervals of overlap metrics
over.cred &lt;- apply(over*100, c(1:2, 4), quantile,
                   prob = c(.025, .975), na.rm = TRUE)
round(over.cred[,,,1]) # display alpha = .95 niche region
</code></pre>

<hr>
<h2 id='overlap.plot'>Plot the overlap metric.</h2><span id='topic+overlap.plot'></span>

<h3>Description</h3>

<p>Plots the posterior distribution of the niche region overlap metric calculated for each pairwise combination of species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.plot(
  over.stat,
  nbreaks = 50,
  equal.axis = FALSE,
  species.names,
  col,
  mean.cred = TRUE,
  mean.cred.col = "green",
  xlab
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap.plot_+3A_over.stat">over.stat</code></td>
<td>
<p>An array with <code>dim(over.stat) = c(nspecies, nspecies, nreps)</code> containing <code>nreps</code> calculations of the overlap metric for each pair of species. See 'Details'.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_nbreaks">nbreaks</code></td>
<td>
<p>Number of breaks in the histogram. Defaults to 50.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_equal.axis">equal.axis</code></td>
<td>
<p>Logical. If <code>TRUE</code>, all histograms in a given column of the output (corresponding to different Species <code class="reqn">A</code> for the same Species <code class="reqn">B</code>) are plotted on the same range.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_species.names">species.names</code></td>
<td>
<p>A vector of species names. Defaults to <code>dimnames(over.stat)[[1]]</code>.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_col">col</code></td>
<td>
<p>A vector of the colours in which each species will be drawn.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_mean.cred">mean.cred</code></td>
<td>
<p>Logical. If <code>TRUE</code>, vertical lines for mean and 95% credible intervals will be included in the historgram of each overlap metric.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_mean.cred.col">mean.cred.col</code></td>
<td>
<p>Colour of the mean and credible interval lines in the histogram.</p>
</td></tr>
<tr><td><code id="overlap.plot_+3A_xlab">xlab</code></td>
<td>
<p>Optional plot title, located on the bottom.  Default is no title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the overlap metric information in <code>over.stat</code> calculated by <code><a href="#topic+overlap">overlap()</a></code> to create 2-dimensional plots of interspecific niche region overlap.
</p>


<h3>Value</h3>

<p>Returns a series of histograms illustrating the probability of pairwise species overlap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlap">overlap()</a></code>, <code><a href="#topic+niw.post">niw.post()</a></code>, <code><a href="#topic+niiw.post">niiw.post()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fish data
data(fish)

# parameter draws from the "default" posteriors of each fish
nsamples &lt;- 500
system.time({
  fish.par &lt;- tapply(1:nrow(fish), fish$species,
                     function(ii) niw.post(nsamples = nsamples,
                                           X = fish[ii,2:4]))
})

# overlap calculation
system.time({
  over &lt;- overlap(fish.par, nreps = nsamples, nprob = nsamples,
                  alpha = c(.95, .99))
})

# overlap plot
clrs &lt;- c("black", "red", "blue", "orange") # color for each species
ii &lt;- 1 # which niche region alpha level to use
overlap.plot(over[,,,ii], col = clrs, mean.cred.col = "turquoise",
             xlab = paste0("Overlap Probability (%) -- Niche Region Size: ",
                           dimnames(over)[[4]][ii]))
</code></pre>

<hr>
<h2 id='overlap.unif'>Overlap calculation for uniform niche regions.</h2><span id='topic+overlap.unif'></span><span id='topic+overlap.sphere'></span>

<h3>Description</h3>

<p>Overlap calculation for uniform niche regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.unif(muA, SigmaA, muB, SigmaB, alphaA = 0.95, alphaB = 0.95, nprob)

overlap.sphere(muA, sigmaA, muB, sigmaB, alphaA = 0.95, alphaB = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap.unif_+3A_mua">muA</code>, <code id="overlap.unif_+3A_mub">muB</code></td>
<td>
<p>Mean of niche regions.</p>
</td></tr>
<tr><td><code id="overlap.unif_+3A_sigmaa">SigmaA</code>, <code id="overlap.unif_+3A_sigmab">SigmaB</code></td>
<td>
<p>Variance matrix of elliptical niche regions.</p>
</td></tr>
<tr><td><code id="overlap.unif_+3A_alphaa">alphaA</code>, <code id="overlap.unif_+3A_alphab">alphaB</code></td>
<td>
<p>Probabilistic size of niche regions.</p>
</td></tr>
<tr><td><code id="overlap.unif_+3A_nprob">nprob</code></td>
<td>
<p>Number of uniform draws from niche region <code>A</code>.</p>
</td></tr>
<tr><td><code id="overlap.unif_+3A_sigmaa">sigmaA</code>, <code id="overlap.unif_+3A_sigmab">sigmaB</code></td>
<td>
<p>standard deviations (scalars) of spherical niche regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overlap between niche regions <code class="reqn">A</code> and <code class="reqn">B</code> is defined as <code class="reqn">vol(A \cap B)/vol(A \cup B)</code>, where the hypervolume of an <code class="reqn">n</code>-dimensional region <code class="reqn">S</code> is <code class="reqn">vol(S) = \int_S dx</code>.  For elliptical niche regions, there are simple formulas for <code class="reqn">vol(A)</code> and <code class="reqn">vol(B)</code>.  Thus, we need only determine the volume of the intersection <code class="reqn">vol(A \cap B)</code>, as the volume of the union is given by the formula <code class="reqn">vol(A \cup B) = vol(A) + vol(B) - vol(A \cap B)</code>.
</p>
<p>For spherical niche regions, <code class="reqn">vol(A \cap B)</code> has a closed-form expression (see 'References').  For elliptical regions, no such formula exists and a Monte Carlo method is used instead.  That is, <code class="reqn">vol(A \cap B)</code> is calculated by sampling uniformly from <code class="reqn">A</code>, then multiplying <code class="reqn">vol(A)</code> by the fraction of sampled points which fall into <code class="reqn">B</code>.
</p>
<p>While the uniform overlap metric is invariant to permutation of niche regions <code class="reqn">A</code> and <code class="reqn">B</code>, the accuracy of the Monte Carlo calculation of <code class="reqn">vol(A \cap B)</code> is not: higher accuracy is obtained when a higher fraction of sampled points are in the opposite niche region.  <code><a href="#topic+overlap.unif">overlap.unif()</a></code> does not attempt to determine for which region this is the case, though the choice can be informed by plotting the niche regions, e.g., with <code><a href="#topic+niche.plot">niche.plot()</a></code>.
</p>


<h3>Value</h3>

<p>A Monte Carlo estimate of the niche overlap for <code><a href="#topic+overlap.unif">overlap.unif()</a></code>, and an analytic calculation for <code><a href="#topic+overlap.sphere">overlap.sphere()</a></code>.
</p>


<h3>References</h3>

<p>Li, S. &quot;Concise formulas for the area and volume of a hyperspherical cap.&quot; <em>Asian Journal of Mathematics &amp; Statistics</em> 4.1 (2011): 66-70. <a href="https://doi.org/10.3923/ajms.2011.66.70">doi:10.3923/ajms.2011.66.70</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># spherical case: compare Monte Carlo method to analytic formula

d &lt;- 2 # 2D example
mA &lt;- rnorm(d)
mB &lt;- rnorm(d)
sigA &lt;- rexp(1)
SigA &lt;- sigA^2 * diag(d)
sigB &lt;- rexp(1)
SigB &lt;- sigB^2 * diag(d)

# plot circles
ellA &lt;- ellipse(mA, SigA)
ellB &lt;- ellipse(mB, SigB)
plot(0, type = "n",
     xlim = range(ellA[,1], ellB[,1]),
     ylim = range(ellA[,2], ellB[,2]), xlab = "x", ylab = "y")
lines(ellA, col = "red")
lines(ellB, col = "blue")
legend("topright", legend = c("niche A", "niche B"),
       fill = c("red", "blue"), bg = "white")

# compare niche calculations
overlap.sphere(mA, sigA, mB, sigB)
overlap.unif(mA, SigA, mB, SigB, nprob = 1e5)
</code></pre>

<hr>
<h2 id='rniw'>Random draws from a Normal-Inverse-Wishart distribution.</h2><span id='topic+rniw'></span>

<h3>Description</h3>

<p>Generates random draws from a Normal-Inverse-Wishart (NIW) distribution. Can be used to compare prior to posterior parameter distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rniw(n, lambda, kappa, Psi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rniw_+3A_n">n</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="rniw_+3A_lambda">lambda</code></td>
<td>
<p>Location parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="rniw_+3A_kappa">kappa</code></td>
<td>
<p>Scale parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="rniw_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix.  See 'Details'.</p>
</td></tr>
<tr><td><code id="rniw_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom.  See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIW distribution <code class="reqn">p(\mu, \Sigma | \lambda, \kappa, \Psi, \nu)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
\Sigma \sim W^{-1}(\Psi, \nu), \quad \mu | \Sigma \sim N(\lambda, \Sigma/\kappa).
</code>
</p>



<h3>Value</h3>

<p>Returns a list with elements <code>mu</code> and <code>Sigma</code> of sizes <code>c(n,length(lambda))</code> and <code>c(nrow(Psi),ncol(Psi),n)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rwish">rwish()</a></code>, <code><a href="#topic+niw.mom">niw.mom()</a></code>, <code><a href="#topic+niw.coeffs">niw.coeffs()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4 # number of dimensions
nu &lt;- 7 # degrees of freedom
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d)) # scale
lambda &lt;- rnorm(d)
kappa &lt;- 2
n &lt;- 1e4

niw.sim &lt;- rniw(n, lambda, kappa, Psi, nu)

# diagonal elements of Sigma^{-1} are const * chi^2
S &lt;- apply(niw.sim$Sigma, 3, function(M) diag(solve(M)))

ii &lt;- 2
const &lt;- solve(Psi)[ii,ii]
hist(S[ii,], breaks = 100, freq = FALSE,
     main = parse(text = paste0("\"Histogram of \"*(Sigma^{-1})[", ii,ii,"]")),
     xlab = parse(text = paste0("(Sigma^{-1})[", ii,ii,"]")))
curve(dchisq(x/const, df = nu)/const,
      from = min(S[ii,]), to = max(S[ii,]), col = "red", add = TRUE)

# elements of mu have a t-distribution
mu &lt;- niw.sim$mu

ii &lt;- 4
const &lt;- sqrt(Psi[ii,ii]/(kappa*(nu-d+1)))
hist(mu[,ii], breaks = 100, freq = FALSE,
     main = parse(text = paste0("\"Histogram of \"*mu[", ii, "]")),
     xlab = parse(text = paste0("mu[", ii, "]")))
curve(dt((x-lambda[ii])/const, df = nu-d+1)/const, add = TRUE, col = "red")
</code></pre>

<hr>
<h2 id='rwish'>Random draws from a Wishart (or Inverse-Wishart) distribution.</h2><span id='topic+rwish'></span>

<h3>Description</h3>

<p>Generates a random samples from a Wishart distribution defined as <code class="reqn">W(\Psi, \nu)</code>, or an Inverse-Wishart distribution defined as <code class="reqn">W^{-1}(\Psi, \nu)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwish(n, Psi, nu, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwish_+3A_n">n</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="rwish_+3A_psi">Psi</code></td>
<td>
<p>Scale matrix.</p>
</td></tr>
<tr><td><code id="rwish_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code id="rwish_+3A_inv">inv</code></td>
<td>
<p>Logical. Setting <code>inv = TRUE</code> returns random matrices from an Inverse-Wishart distribution. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting <code>inv = TRUE</code> replaces <code class="reqn">\Psi</code> by <code class="reqn">Psi^{-1}</code> and inverts the output random matrices, such that they are being generated from an Inverse-Wishart <code class="reqn">W^{-1}(\Psi, \nu)</code> distribution.
</p>


<h3>Value</h3>

<p>Returns an array of Wishart (or Inverse-Wishart) draws of size <code>c(nrow(Psi),ncol(Psi),n)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rniw">rniw()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 4 # number of dimensions
nu &lt;- 7 # degrees of freedom
Psi &lt;- crossprod(matrix(rnorm(d^2), d, d)) # scale matrix
n &lt;- 1e4

Sigma &lt;- rwish(n, Psi, nu)

# for any vector a, X = (a' Sigma a) has a const * chi^2 distribution
a &lt;- rnorm(d)
X &lt;- apply(Sigma, 3, function(S) crossprod(a, S %*% a))
const &lt;- c(a %*% Psi %*% a)

hist(X, breaks = 100, freq = FALSE,
     main = parse(text = "\"Histogram of \"*X==a*minute*Sigma*a"),
     xlab = parse(text = "X==a*minute*Sigma*a"))
curve(dchisq(x/const, df = nu)/const,
      from = min(X), to = max(X), col = "red", add = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
