<!DOCTYPE html><html lang="en"><head><title>Help for package credsubs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {credsubs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alzheimers'><p>Clinical trial data from 369 Alzheimer's disease patients.</p></a></li>
<li><a href='#build.shiny.calc'><p>Build a credible subset calculator</p></a></li>
<li><a href='#credsubs'><p>Constructs a credible subset pair</p></a></li>
<li><a href='#credsubs.level'><p>Compute the maximum credible levels at which conclusions may be drawn</p></a></li>
<li><a href='#run.shiny.calc'><p>Run a calculator</p></a></li>
<li><a href='#sim.cred.band'><p>Constructs a simultaneous credible band</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Credible Subsets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Schnell,
  Brad Carlin</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Schnell &lt;schnell.31@osu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for constructing simultaneous credible bands and identifying subsets via the "credible subsets" (also called "credible subgroups") method. Package documentation includes the vignette included in this package, and the paper by Schnell, Fiecas, and Carlin (2020, &lt;<a href="https://doi.org/10.18637%2Fjss.v094.i07">doi:10.18637/jss.v094.i07</a>&gt;).</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ff, R.rsp, shiny</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-31 20:21:36 UTC; schnell.31</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-01 11:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='alzheimers'>Clinical trial data from 369 Alzheimer's disease patients.</h2><span id='topic+alzheimers'></span>

<h3>Description</h3>

<p>A dataset containing the treatment assignment, baseline measurements,
and outcomes of 369 patients enrolled in four clinical trials
for treatments of Alzheimer's disease. Patients assigned to the test
treatments are excluded, leaving patients assigned to either a placebo
or the palliative standard of care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alzheimers
</code></pre>


<h3>Format</h3>

<p>A data frame with 369 rows and 6 variables:
</p>

<dl>
<dt>Treatment</dt><dd><p>treatment assignment</p>
</dd>
<dt>Severity</dt><dd><p>baseline severity (ADAS-Cog 11)</p>
</dd>
<dt>Decline</dt><dd><p>decline in score on Mini Mental State Exam (MMSE) divided
by number of years since onset of symptoms</p>
</dd>
<dt>Sex</dt><dd><p>male or female</p>
</dd>
<dt>Carrier</dt><dd><p>carrier status of ApoE4 allele</p>
</dd>
<dt>Improvement</dt><dd><p>baseline severity minus severity at 12 weeks
(positive is good)</p>
</dd>
</dl>



<h3>Source</h3>

<p>AbbVie, Inc.
</p>

<hr>
<h2 id='build.shiny.calc'>Build a credible subset calculator</h2><span id='topic+build.shiny.calc'></span>

<h3>Description</h3>

<p>This function builds a <code>shiny</code> application in the specified directory
that gives the maximum credible level at an entered covariate point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.shiny.calc(
  credsubs.level,
  cov.space,
  name = "calc",
  dir = ".",
  title = "Credible Subsets Calculator",
  instructions = "Select a covariate point."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build.shiny.calc_+3A_credsubs.level">credsubs.level</code></td>
<td>
<p>An object of class <code>credsubs.level</code>.</p>
</td></tr>
<tr><td><code id="build.shiny.calc_+3A_cov.space">cov.space</code></td>
<td>
<p>A data frame whose rows are human-readable
covariate points corresponding to the entries
of <code>credsubs.level$level</code>.</p>
</td></tr>
<tr><td><code id="build.shiny.calc_+3A_name">name</code></td>
<td>
<p>A character string indicating the name of the application.</p>
</td></tr>
<tr><td><code id="build.shiny.calc_+3A_dir">dir</code></td>
<td>
<p>The directory in which to place the application.</p>
</td></tr>
<tr><td><code id="build.shiny.calc_+3A_title">title</code></td>
<td>
<p>A character string to be displayed as the application title.</p>
</td></tr>
<tr><td><code id="build.shiny.calc_+3A_instructions">instructions</code></td>
<td>
<p>A character string to be displayed as instructions.
HTML allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculator creates a subdirectory according to <code>name</code> in
the directory specified by <code>dir</code>, and places in it files
<code>server.R</code>, <code>ui.R</code>, and <code>config.RData</code>. This application
requires the <code>shiny</code> package to run, and can be executed by passing
the directory path to <code>run.shiny.calc()</code>. The produced application
directory may be moved from its original location.
</p>

<hr>
<h2 id='credsubs'>Constructs a credible subset pair</h2><span id='topic+credsubs'></span>

<h3>Description</h3>

<p><code>credsubs</code> returns a credible subset pair over a finite set of
covariate points given either a sample from the posterior of the
regression surface or a function <code>FUN(x, params)</code> and a sample from
the posterior of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credsubs(
  params,
  design = NULL,
  FUN = function(x, params) {     params %*% t(x) },
  cred.level = 0.95,
  threshold = 0,
  method = c("asymptotic", "quantile"),
  step.down = TRUE,
  sides = c("both", "exclusive", "inclusive"),
  est.FUN = mean,
  var.FUN = sd,
  point.estimate = NULL,
  track = numeric(0),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credsubs_+3A_params">params</code></td>
<td>
<p>A numeric matrix whose rows are draws from the posterior
distribution of either the regression surface or the
parameter vector.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_design">design</code></td>
<td>
<p>(Optional) A numeric matrix whose rows are covariate points
over which the band is to be constructed.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_fun">FUN</code></td>
<td>
<p>(Optional) a function of the form <code>function(x, params)</code>
that takes a row of <code>design</code> and the entire <code>params</code>
matrix and returns a vector of the same length of <code>x</code>
representing the regression surface.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_cred.level">cred.level</code></td>
<td>
<p>Numeric; the credible level.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_threshold">threshold</code></td>
<td>
<p>Numeric; the value of <code>FUN</code> above which
a covariate is included in the target subset.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_method">method</code></td>
<td>
<p>Either &quot;asymptotic&quot; (default) or &quot;quantile&quot;; see details.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_step.down">step.down</code></td>
<td>
<p>Logical (default <code>TRUE</code>); should the step-down
procedure be used?</p>
</td></tr>
<tr><td><code id="credsubs_+3A_sides">sides</code></td>
<td>
<p>One of &quot;both&quot; (default), &quot;exclusive&quot;, or &quot;inclusive&quot;.
Which bounds should be constructed?</p>
</td></tr>
<tr><td><code id="credsubs_+3A_est.fun">est.FUN</code></td>
<td>
<p>The function used to produce estimates of the regression
surface. Default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_var.fun">var.FUN</code></td>
<td>
<p>The function used to quantify the variability of the
regression surface posterior. Default is <code>sd</code>.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_point.estimate">point.estimate</code></td>
<td>
<p>If not null, replaces the mean and sets the reference 
around which the standard error is computed.
Useful for bootstrapping methods.
Treated as a row of the <code>params</code> matrix.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_track">track</code></td>
<td>
<p>A numeric vector of indices indicating which rows (default none)
of the design matrix should have the sample of the corresponding
<code>FUN(x, params)</code> returned.</p>
</td></tr>
<tr><td><code id="credsubs_+3A_verbose">verbose</code></td>
<td>
<p>Logical (default <code>FALSE</code>); print progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If design is NULL (default), it is taken to be the identity
matrix of dimension ncol(params), so that the rows of params
are treated as draws from the posterior FUN(x, params).
</p>
<p>The 'asymptotic' method assumes that the marginal posteriors of 
the FUN(x, params) are asymptotically normal and is usually
significantly faster and less memory-intensive than the 'quantile'
method, which makes no such assumption.
</p>


<h3>Value</h3>

<p>An object of class <code>credsubs</code>, which contains:
</p>

<dl>
<dt><code>exclusive</code></dt><dd><p>A logical vector indicating membership in
the exclusive credible subset.</p>
</dd>
<dt><code>inclusive</code></dt><dd><p>A logical vector indicating membership in
the inclusive credible subset.</p>
</dd>
<dt><code>cred.level</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>method</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>step.down</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>sides</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>est</code></dt><dd><p>Posterior estimate of the regression surface.</p>
</dd>
<dt><code>est.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>var</code></dt><dd><p>Summary of posterior variability of the regression
surface.</p>
</dd>
<dt><code>var.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>W</code></dt><dd><p>An estimate of the extremal errors.</p>
</dd>
<dt><code>W.crit</code></dt><dd><p>The critical quantile of W.</p>
</dd>
<dt><code>trace</code></dt><dd><p>The posterior samples of the regression surface
indicated by the <code>track</code> argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>### Sample from regression surface posterior
reg.surf.sample &lt;- matrix(rnorm(1000, mean=1:10), ncol=2, byrow=TRUE)
credsubs(reg.surf.sample, cred.level=0.80)

### Parametric case
design &lt;- cbind(1, 1:10)
params &lt;- matrix(rnorm(200, mean=1:2), ncol=2, byrow=TRUE)
credsubs(params, design)

### With custom function
params.sd &lt;- cbind(1 / rgamma(100, 1), params)
FUN.sd &lt;- function(x, params) { params[, -1] %*% t(x) / params[, 1] }
credsubs(params.sd, design, FUN.sd, threshold=1)

</code></pre>

<hr>
<h2 id='credsubs.level'>Compute the maximum credible levels at which conclusions may be drawn</h2><span id='topic+credsubs.level'></span>

<h3>Description</h3>

<p>For each covariate point, <code>credsubs.level</code> computes the maximum
credible level at which a conclusion may be drawn at each point, and
what that conclusion is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credsubs.level(
  params,
  design = NULL,
  FUN = function(x, params) {     params %*% t(x) },
  threshold = 0,
  method = c("asymptotic", "quantile"),
  step.down = TRUE,
  sides = c("both", "exclusive", "inclusive"),
  est.FUN = mean,
  var.FUN = sd,
  point.estimate = NULL,
  track = numeric(0),
  verbose = FALSE,
  z.store = c("ram", "recompute", "disk")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credsubs.level_+3A_params">params</code></td>
<td>
<p>A numeric matrix whose rows are draws from the posterior
distribution of either the regression surface or the
parameter vector.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_design">design</code></td>
<td>
<p>(Optional) A numeric matrix whose rows are covariate points
over which the band is to be constructed.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_fun">FUN</code></td>
<td>
<p>(Optional) a function of the form <code>function(x, params)</code>
that takes a row of <code>design</code> and the entire <code>params</code>
matrix and returns a vector of the same length of <code>x</code>
representing the regression surface.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_threshold">threshold</code></td>
<td>
<p>Numeric; the value of <code>FUN</code> above which
a covariate is included in the target subset.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_method">method</code></td>
<td>
<p>Either &quot;asymptotic&quot; (default) or &quot;quantile&quot;; see details.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_step.down">step.down</code></td>
<td>
<p>Logical (default <code>TRUE</code>); should the step-down
procedure be used?</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_sides">sides</code></td>
<td>
<p>One of &quot;both&quot; (default), &quot;exclusive&quot;, or &quot;inclusive&quot;.
Which bounds should be constructed?</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_est.fun">est.FUN</code></td>
<td>
<p>The function used to produce estimates of the regression
surface. Default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_var.fun">var.FUN</code></td>
<td>
<p>The function used to quantify the variability of the
regression surface posterior. Default is <code>sd</code>.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_point.estimate">point.estimate</code></td>
<td>
<p>If not null, replaces the mean and sets the reference 
around which the standard error is computed.
Useful for bootstrapping methods.
Treated as a row of the <code>params</code> matrix.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_track">track</code></td>
<td>
<p>A numeric vector of indices indicating which rows (default none)
of the design matrix should have the sample of the corresponding
<code>FUN(x, params)</code> returned.</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_verbose">verbose</code></td>
<td>
<p>Logical (default <code>FALSE</code>); print progress?</p>
</td></tr>
<tr><td><code id="credsubs.level_+3A_z.store">z.store</code></td>
<td>
<p>How should certain intermediate computations be handled?
See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If design is NULL (default), it is taken to be the identity
matrix of dimension ncol(params), so that the rows of params
are treated as draws from the posterior FUN(x, params).
</p>
<p>The 'asymptotic' method assumes that the marginal posteriors of 
the FUN(x, params) are asymptotically normal and is usually
significantly faster and less memory-intensive than the 'quantile'
method, which makes no such assumption.
</p>
<p>By default (<code>z.store = "ram"</code>), the maximum credible level computation
stores a potentially very large amount of intermediate computation results
in memory. If not enough memory is available, <code>z.store = "disk"</code>
uses the <code>ff</code> package to store the intermediate results on disk,
which can still be fairly quick if the storage is fast (e.g. a local SSD).
Alternatively, <code>z.store = "recompute"</code> discards the intermediate
results and recomputes whenever needed. This uses minimal memory, but
is usually the slowest option.
</p>


<h3>Value</h3>

<p>An object of class <code>credsubs.level</code>, which contains:
</p>

<dl>
<dt><code>level</code></dt><dd><p>A numeric vector indicating the maximum credible
level at which a conclusion may be drawn at each
covariate point.</p>
</dd>
<dt><code>sign</code></dt><dd><p>A numeric vector indicating the which credible subsets
of which each covariate point is a member at the
credible level indicated by <code>level</code>. Exclusive
and inclusive: 1, inclusive only: 0, neither: -1.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>method</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>step.down</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>sides</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>est</code></dt><dd><p>Posterior estimate of the regression surface.</p>
</dd>
<dt><code>est.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>var</code></dt><dd><p>Summary of posterior variability of the regression
surface.</p>
</dd>
<dt><code>var.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>trace</code></dt><dd><p>The posterior samples of the regression surface
indicated by the <code>track</code> argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>### Sample from regression surface posterior
reg.surf.sample &lt;- matrix(rnorm(1000, mean=1:10), ncol=2, byrow=TRUE)
credsubs.level(reg.surf.sample)

### Parametric case
design &lt;- cbind(1, 1:10)
params &lt;- matrix(rnorm(200, mean=1:2), ncol=2, byrow=TRUE)
credsubs(params, design)

### With custom function
params.sd &lt;- cbind(1 / rgamma(100, 1), params)
FUN.sd &lt;- function(x, params) { params[, -1] %*% t(x) / params[, 1] }
credsubs(params.sd, design, FUN.sd, threshold=1)

</code></pre>

<hr>
<h2 id='run.shiny.calc'>Run a calculator</h2><span id='topic+run.shiny.calc'></span>

<h3>Description</h3>

<p>Runs the specified calculator using the <code>shiny</code> package.
Calculators must be built using <code>build.shiny.calc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.shiny.calc(
  app.dir = system.file("shiny", "alzheimers", package = "credsubs")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.shiny.calc_+3A_app.dir">app.dir</code></td>
<td>
<p>A character string pointing to the application directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>app.dir</code> argument need not exactly match the value recommended
by <code>build.shiny.calc()</code>, as long as it points to the correct directory.
For example, <code>"./calc/"</code>, <code>"calc/"</code>, and <code>"calc"</code> are
all equivalent. If no value is supplied, an example is run.
</p>

<hr>
<h2 id='sim.cred.band'>Constructs a simultaneous credible band</h2><span id='topic+sim.cred.band'></span>

<h3>Description</h3>

<p><code>sim.cred.band</code> returns a simultaneous band over a finite set of
covariate points given either a sample from the posterior of the
regression surface or a function <code>FUN(x, params)</code> and a sample from
the posterior of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cred.band(
  params,
  design = NULL,
  FUN = function(x, params) {     params %*% t(x) },
  cred.level = 0.95,
  method = c("asymptotic", "quantile"),
  sides = c("both", "upper", "lower"),
  est.FUN = mean,
  var.FUN = sd,
  point.estimate = NULL,
  track = numeric(0),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cred.band_+3A_params">params</code></td>
<td>
<p>A numeric matrix whose rows are draws from the posterior
distribution of either the regression surface or the parameter vector.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_design">design</code></td>
<td>
<p>(Optional) A numeric matrix whose rows are covariate points
over which the band is to be constructed.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_fun">FUN</code></td>
<td>
<p>(Optional) a function of the form <code>function(x, params)</code>
that takes a row of <code>design</code> and the entire <code>params</code> matrix and
returns a vector of the same length of <code>x</code> representing the regression
surface.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_cred.level">cred.level</code></td>
<td>
<p>Numeric; the credible level.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_method">method</code></td>
<td>
<p>Either &quot;asymptotic&quot; (default) or &quot;quantile&quot;; see details.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_sides">sides</code></td>
<td>
<p>One of &quot;both&quot; (default), &quot;upper&quot;, or &quot;lower&quot;.
Which bounds should be constructed?</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_est.fun">est.FUN</code></td>
<td>
<p>The function used to produce estimates of the regression
surface. Default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_var.fun">var.FUN</code></td>
<td>
<p>The function used to quantify the variability of the
regression surface posterior. Default is <code>sd</code>.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_point.estimate">point.estimate</code></td>
<td>
<p>If not null, replaces the mean and sets the reference 
around which the standard error is computed.
Useful for bootstrapping methods.
Treated as a row of the <code>params</code> matrix.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_track">track</code></td>
<td>
<p>A numeric vector of indices indicating which rows (default none)
of the design matrix should have the sample of the corresponding
<code>FUN(x, params)</code> returned.</p>
</td></tr>
<tr><td><code id="sim.cred.band_+3A_verbose">verbose</code></td>
<td>
<p>Logical (default <code>FALSE</code>); print progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>design</code> is <code>NULL</code> (default), it is taken to be the identity
matrix of dimension <code>ncol(params)</code>, so that the rows of params
are treated as draws from the posterior <code>FUN(x, params)</code>.
</p>
<p>The 'asymptotic' method assumes that the marginal posteriors of 
the <code>FUN(x, params)</code> are asymptotically normal and is usually
significantly faster and less memory-intensive than the 'quantile'
method, which makes no such assumption.
</p>


<h3>Value</h3>

<p>An object of class <code>sim.cred.band</code>, which contains:
</p>

<dl>
<dt><code>upper</code></dt><dd><p>A numeric vector of upper bounds.</p>
</dd>
<dt><code>lower</code></dt><dd><p>A numeric vector of lower bounds.</p>
</dd>
<dt><code>cred.level</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>method</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>sides</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>est</code></dt><dd><p>Posterior estimate of the regression surface.</p>
</dd>
<dt><code>est.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>var</code></dt><dd><p>Summary of posterior variability of the regression
surface.</p>
</dd>
<dt><code>var.FUN</code></dt><dd><p>As provided.</p>
</dd>
<dt><code>W</code></dt><dd><p>An estimate of the extremal errors.</p>
</dd>
<dt><code>W.crit</code></dt><dd><p>The critical quantile of W.</p>
</dd>
<dt><code>trace</code></dt><dd><p>The posterior samples of the regression surface
indicated by the <code>track</code> argument.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>### Sample from regression surface posterior
reg.surf.sample &lt;- matrix(rnorm(1000, mean=1:10), ncol=2, byrow=TRUE)
sim.cred.band(reg.surf.sample, cred.level=0.80)

### Parametric case
design &lt;- cbind(1, 1:10)
params &lt;- matrix(rnorm(200, mean=1:2), ncol=2, byrow=TRUE)
sim.cred.band(params, design)

### With custom function
params.sd &lt;- cbind(1 / rgamma(100, 1), params)
FUN.sd &lt;- function(x, params) { params[, -1] %*% t(x) / params[, 1] }
sim.cred.band(params.sd, design, FUN.sd)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
