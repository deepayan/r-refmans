<!DOCTYPE html><html><head><title>Help for package CircSpaceTime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CircSpaceTime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CircSpaceTime'><p>CircSpaceTime: implementation of Bayesian models,</p>
for spatial and spatio-temporal interpolation of circular data.</a></li>
<li><a href='#APEcirc'><p>Average Prediction Error for circular Variables.</p></a></li>
<li><a href='#april'><p>April waves.</p></a></li>
<li><a href='#ConvCheck'><p>Testing Convergence of mcmc using package coda</p></a></li>
<li><a href='#CRPScirc'><p>The Continuous Ranked Probability Score for Circular Variables.</p></a></li>
<li><a href='#may'><p>May waves.</p></a></li>
<li><a href='#ProjKrigSp'><p>Kriging using projected normal model.</p></a></li>
<li><a href='#ProjKrigSpTi'><p>#' Spatio temporal interpolation using projected spatial temporal normal model.</p></a></li>
<li><a href='#ProjSp'><p>Samples from the Projected Normal spatial model</p></a></li>
<li><a href='#ProjSpTi'><p>Samples from the posterior distribution of the Projected Normal spatial model</p></a></li>
<li><a href='#rose_diag'><p>Rose diagram in ggplot2 inspired from rose.diag in package circular.</p></a></li>
<li><a href='#WrapKrigSp'><p>Spatial interpolation using wrapped normal model.</p></a></li>
<li><a href='#WrapKrigSpTi'><p>Prediction using wrapped normal spatio-temporal model.</p></a></li>
<li><a href='#WrapSp'><p>Samples from the Wrapped Normal spatial model</p></a></li>
<li><a href='#WrapSpTi'><p>Samples from the posterior distribution of the Wrapped Normal spatial temporal model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Spatio-Temporal Bayesian Model for Circular Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/santoroma/CircSpaceTime">https://github.com/santoroma/CircSpaceTime</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Bayesian models for spatial and spatio-temporal
             interpolation of circular data using Gaussian Wrapped and Gaussian Projected distributions.
             We developed the methods described in Jona Lasinio G. et al. (2012) &lt;<a href="https://doi.org/10.1214%2F12-aoas576">doi:10.1214/12-aoas576</a>&gt;, 
             Wang F. et al. (2014) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.934454">doi:10.1080/01621459.2014.934454</a>&gt; and 
             Mastrantonio G. et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs11749-015-0458-y">doi:10.1007/s11749-015-0458-y</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/santoroma/CircSpaceTime">https://github.com/santoroma/CircSpaceTime</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach, iterators, parallel, doParallel, gridExtra</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RInside</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.14), circular, RInside, coda, ggplot2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-06-06 09:07:05 UTC; harlok</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanna Jona Lasinio
    <a href="https://orcid.org/0000-0001-8912-5018"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gianluca Mastrantonio
    <a href="https://orcid.org/0000-0002-2963-6729"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mario Santoro <a href="https://orcid.org/0000-0001-6626-9430"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mario Santoro &lt;santoro.ma@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-06-06 15:12:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='CircSpaceTime'>CircSpaceTime: implementation of Bayesian models,
for spatial and spatio-temporal interpolation of circular data.</h2><span id='topic+CircSpaceTime'></span><span id='topic+CircSpaceTime-package'></span>

<h3>Description</h3>

<p>The CircSpaceTime package provides two categories of important functions:
Sampling Functions and Posterior (Kriging) Estimation Functions.
</p>


<h3>CircSpaceTime main functions</h3>

<p><code><a href="#topic+WrapSp">WrapSp</a></code> and <code><a href="#topic+ProjSp">ProjSp</a></code>, for sampling
from a spatial Normal Wrapped and Projected, respectively.
<code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> and <code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code>, for posterior
estimation on spatial Normal Wrapped and Projected, respectively.
</p>
<p><code><a href="#topic+WrapSpTi">WrapSpTi</a></code> and <code><a href="#topic+ProjSpTi">ProjSpTi</a></code>, for sampling
from a spatio-temporal Normal Wrapped and Projected, respectively.
<code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> and <code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code>, for posterior
estimation on spatio-temporal Normal Wrapped and Projected, respectively.
</p>

<hr>
<h2 id='APEcirc'>Average Prediction Error for circular Variables.</h2><span id='topic+APEcirc'></span>

<h3>Description</h3>

<p><code>APEcirc</code>  computes the average prediction error (APE),
defined as the average circular distance across pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>APEcirc(real, sim, bycol = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="APEcirc_+3A_real">real</code></td>
<td>
<p>a vector of the  values of the process at the test locations</p>
</td></tr>
<tr><td><code id="APEcirc_+3A_sim">sim</code></td>
<td>
<p>a matrix with <code>nrow =</code> the test locations and <code>ncol =</code> the number
of posterior samples from the posterior distributions  by
<code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code>, <code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code>,
<code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code></p>
</td></tr>
<tr><td><code id="APEcirc_+3A_bycol">bycol</code></td>
<td>
<p>logical. It is TRUE if the columns of sim represent the observations and
the rows the posterior samples, the default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements
</p>

<dl>
<dt><code>ApePoints</code></dt><dd><p> a vector of APE, one element for each test point</p>
</dd>
<dt><code>Ape</code></dt><dd><p> the  overall mean</p>
</dd>
</dl>



<h3>References</h3>

<p>G. Jona Lasinio, A. Gelfand, M. Jona-Lasinio,
&quot;Spatial analysis of wave direction data using wrapped Gaussian processes&quot;,
The Annals of Applied Statistics 6 (2013), 1478-1498
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> and <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for posterior spatial
estimations,
<code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> and <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for posterior spatio-temporal
estimations
</p>
<p>Other model performance indices: <code><a href="#topic+CRPScirc">CRPScirc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CircSpaceTime)
## functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

######################################
## Simulation                       ##
######################################
set.seed(1)
n &lt;- 20
### simulate coordinates from a unifrom distribution
coords  &lt;- cbind(runif(n,0,100), runif(n,0,100)) #spatial coordinates
coordsT &lt;- sort(runif(n,0,100)) #time coordinates (ordered)
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho     &lt;- 0.05 #spatial decay
rhoT    &lt;- 0.01 #temporal decay
sep_par &lt;- 0.5 #separability parameter
sigma2  &lt;- 0.3 # variance of the process
alpha   &lt;- c(0.5)
#Gneiting covariance
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist/(rhoT * DistT^2 + 1)^(sep_par/2))

Y &lt;- rmnorm(1,rep(alpha, times = n), SIGMA) #generate the linear variable
theta &lt;- c()
## wrapping step
for(i in 1:n) {
  theta[i] &lt;- Y[i] %% (2*pi)
}
### Add plots of the simulated data

rose_diag(theta)
## use this values as references for the definition of initial values and priors
rho_sp.min &lt;- 3/max(Dist)
rho_sp.max &lt;- rho_sp.min+0.5
rho_t.min  &lt;- 3/max(DistT)
rho_t.max  &lt;- rho_t.min+0.5
val &lt;- sample(1:n,round(n*0.2)) #validation set
set.seed(100)
mod &lt;- WrapSpTi(
  x       = theta[-val],
  coords    = coords[-val,],
  times    = coordsT[-val],
  start   = list("alpha"      = c(.79, .74),
                 "rho_sp"     = c(.33,.52),
                 "rho_t"     = c(.19, .43),
                 "sigma2"    = c(.49, .37),
                 "sep_par"  = c(.47, .56),
                 "k"       = sample(0,length(theta[-val]), replace = TRUE)),
  priors   = list("rho_sp"      = c(0.01,3/4), ### uniform prior on this interval
                  "rho_t"      = c(0.01,3/4), ### uniform prior on this interval
                  "sep_par"  = c(1,1), ### beta prior
                  "sigma2"    = c(5,5),## inverse gamma prior with mode=5/6
                  "alpha" =  c(0,20) ## wrapped gaussian with large variance
  )  ,
  sd_prop   = list( "sigma2" = 0.1,  "rho_sp" = 0.1,  "rho_t" = 0.1,"sep_par"= 0.1),
  iter    = 7000,
  BurninThin    = c(burnin = 3000, thin = 10),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  n_chains = 2 ,
  parallel = FALSE,
  n_cores = 1
)
check &lt;- ConvCheck(mod,startit = 1 ,thin = 1)
check$Rhat ## convergence has been reached
## when plotting chains remember that alpha is a circular variable
par(mfrow = c(3,2))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))


############## Prediction on the validation set
Krig &lt;- WrapKrigSpTi(
  WrapSpTi_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  times_obs =  coordsT[-val],
  times_nobs =  coordsT[val],
  x_obs = theta[-val]
)
### checking the prediction
Wrap_Ape &lt;- APEcirc(theta[val], Krig$Prev_out)
</code></pre>

<hr>
<h2 id='april'>April waves.</h2><span id='topic+april'></span>

<h3>Description</h3>

<p>Four days of waves data on the Adriatic sea in the month of April 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>april
</code></pre>


<h3>Format</h3>


<dl>
<dt>Date</dt><dd><p>Date, format: yyyy-mm-dd</p>
</dd>
<dt>hour</dt><dd><p>Factor w/ 24 levels corresponding to the 24h, format: 00:00</p>
</dd>
<dt>Lon, Lat</dt><dd><p>decimal longitude and latitude</p>
</dd>
<dt>Hm0</dt><dd><p>Significant wave heights in meters</p>
</dd>
<dt>Dm</dt><dd><p>Direction of waves in degrees (North=0)</p>
</dd>
<dt>state</dt><dd><p>Factor w/ 3 levels &quot;calm&quot;,&quot;transition&quot;, &quot;storm&quot;</p>
</dd>
</dl>


<h3>Details</h3>

<p>Wave directions and heights are obtained as outputs from a deterministic computer model implemented by Istituto Superiore per la Protezione e la Ricerca Ambientale (ISPRA).
The computer model starts from a wind forecast model predicting
the surface wind over the entire Mediterranean.
The hourly evolution of sea wave spectra is obtained by solving energy transport
equations using the wind forecast as input.
Wave spectra are locally modified using a source function
describing the wind energy, the energy redistribution due to nonlinear
wave interactions, and energy dissipation
due to wave fracture.
The model produces estimates every hour
on a grid with 10 x 10 km cells (Inghilesi et al. 2016).
The ISPRA dataset has forecasts for a total of 4941 grid points
over the Italian Mediterranean.
Over the Adriatic Sea area, there are 1494 points.
</p>
<p>A list containing 4 data frames each of 35856 rows and 7 columns.
</p>


<h3>Source</h3>

<p>R. Inghilesi, A. Orasi &amp; F. Catini (2016) The ISPRA Mediterranean Coastal Wave Forecasting system: evaluation and perspectives  Journal of Operational Oceanography Vol. 9 , Iss. sup1 <a href="http://www.tandfonline.com/doi/full/10.1080/1755876X.2015.1115635">http://www.tandfonline.com/doi/full/10.1080/1755876X.2015.1115635</a>
</p>

<hr>
<h2 id='ConvCheck'>Testing Convergence of mcmc using package coda</h2><span id='topic+ConvCheck'></span>

<h3>Description</h3>

<p><code>ConvCheck</code> returns an mcmc.list (mcmc) to be used with the <code>coda</code> package
and the Potential scale reduction factors (Rhat) of the model parameters
computed using the <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code> function in the <code>coda</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvCheck(mod, startit = 15000, thin = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvCheck_+3A_mod">mod</code></td>
<td>
<p>is a list with <code class="reqn">m\ge 1</code> elements, one for each chain generated using
<code><a href="#topic+WrapSp">WrapSp</a></code>, <code><a href="#topic+ProjSp">ProjSp</a></code>, <code><a href="#topic+WrapSpTi">WrapSpTi</a></code> or <code><a href="#topic+ProjSpTi">ProjSpTi</a></code></p>
</td></tr>
<tr><td><code id="ConvCheck_+3A_startit">startit</code></td>
<td>
<p>is an integer, the iteration at which the chains start
(required to build the mcmc.list)</p>
</td></tr>
<tr><td><code id="ConvCheck_+3A_thin">thin</code></td>
<td>
<p>is an integer, the thinning applied to chains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements
</p>

<dl>
<dt><code>mcmc</code></dt><dd><p>an <code>mcmc.list</code> (mcmc) to be used with the <code>coda</code> package</p>
</dd>
<dt><code>Rhat</code></dt><dd><p>the Potential scale reduction factors  of the model parameters
computed using the <code><a href="coda.html#topic+gelman.diag">gelman.diag</a></code> function in the <code>coda</code> package</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> and <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for posterior
spatial estimations,
and
<code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> and <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for posterior
spatio-temporal estimations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
</code></pre>

<hr>
<h2 id='CRPScirc'>The Continuous Ranked Probability Score for Circular Variables.</h2><span id='topic+CRPScirc'></span>

<h3>Description</h3>

<p><code>CRPScirc</code> function computes the The Continuous Ranked Probability Score for Circular Variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRPScirc(obs, sim, bycol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CRPScirc_+3A_obs">obs</code></td>
<td>
<p>a vector of the  values of the process at the test locations</p>
</td></tr>
<tr><td><code id="CRPScirc_+3A_sim">sim</code></td>
<td>
<p>a matrix with nrow the test locations and ncol the number of posterior samples
from the posterior distributions</p>
</td></tr>
<tr><td><code id="CRPScirc_+3A_bycol">bycol</code></td>
<td>
<p>logical. It is TRUE if the columns of sim represent the observations
and the rows the posterior samples, the default value is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements
</p>

<dl>
<dt><code>CRPSvec</code></dt><dd><p> a vector of CRPS, one element for each test point</p>
</dd>
<dt><code>CRPS</code></dt><dd><p> the  overall mean</p>
</dd>
</dl>



<h3>References</h3>

<p>Grimit, Eric P., Tilmann Gneiting, Veronica J. Berrocal,
Nicholas Alexander Johnson.
&quot;The Continuous Ranked Probability Score for Circular Variables
and its Application to Mesoscale Forecast Ensemble Verification&quot;,  Q.J.R. Meteorol. Soc. 132 (2005), 2925-2942.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> and <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for posterior spatial interpolation, and
<code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> and <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for posterior spatio-temporal interpolation
</p>
<p>Other model performance indices: <code><a href="#topic+APEcirc">APEcirc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
## graphical check
par(mfrow = c(3,1))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))
##### We move to the spatial interpolation

Krig &lt;- WrapKrigSp(
  WrapSp_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  x_obs = theta[-val]
)

#### check the quality of the prediction using APE and CRPS
ApeCheck &lt;- APEcirc(theta[val],Krig$Prev_out)
CrpsCheck &lt;- CRPScirc(theta[val],Krig$Prev_out)
</code></pre>

<hr>
<h2 id='may'>May waves.</h2><span id='topic+may'></span>

<h3>Description</h3>

<p>Four time slices of waves data on the Adriatic sea in the month of May 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>may
</code></pre>


<h3>Format</h3>


<dl>
<dt>object</dt><dd><p>each element of the list is one hour of data on the entire area</p>
</dd>
<dt>Date</dt><dd><p>Date, format: yyyy-mm-dd</p>
</dd>
<dt>hour</dt><dd><p>Factor w/ 24 levels corresponding to the 24h, format: 00:00</p>
</dd>
<dt>Lon, Lat</dt><dd><p>decimal longitude and latitude</p>
</dd>
<dt>Hm0</dt><dd><p>Significant wave heights in meters</p>
</dd>
<dt>Dm</dt><dd><p>Direction of waves in degrees (North=0)</p>
</dd>
<dt>state</dt><dd><p>Factor w/ 3 levels &quot;calm&quot;,&quot;transition&quot;, &quot;storm&quot;</p>
</dd>
</dl>


<h3>Details</h3>

<p>Wave directions and heights are obtained as outputs from a deterministic
computer model implemented by Istituto Superiore per la Protezione e
la Ricerca Ambientale (ISPRA).
The computer model starts from a wind forecast model predicting
the surface wind over the entire Mediterranean.
The hourly evolution of sea wave spectra is obtained by
solving energy transport equations using the wind forecast as input.
Wave spectra are locally modified using a source function describing the wind
energy, the energy redistribution due to nonlinear wave interactions,
and energy dissipation due to wave fracture.
The model produces estimates every hour
on a grid with 10 x 10 km cells (Inghilesi et al. 2016).
The ISPRA dataset has forecasts for a total of 4941 grid points
over the Italian Mediterranean.
Over the Adriatic Sea area, there are 1494 points.
</p>
<p>A list containing 4 data frames each of 1494 rows and 7 columns.
</p>


<h3>Source</h3>

<p>R. Inghilesi, A. Orasi &amp; F. Catini (2016) The ISPRA Mediterranean Coastal Wave Forecasting system: evaluation and perspectives  Journal of Operational Oceanography Vol. 9 , Iss. sup1 <a href="http://www.tandfonline.com/doi/full/10.1080/1755876X.2015.1115635">http://www.tandfonline.com/doi/full/10.1080/1755876X.2015.1115635</a>
</p>

<hr>
<h2 id='ProjKrigSp'>Kriging using projected normal model.</h2><span id='topic+ProjKrigSp'></span>

<h3>Description</h3>

<p><code>ProjKrigSp</code> function computes the spatial prediction
for circular spatial data using samples from the posterior distribution
of the spatial projected normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjKrigSp(ProjSp_out, coords_obs, coords_nobs, x_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjKrigSp_+3A_projsp_out">ProjSp_out</code></td>
<td>
<p>the function takes the output of <code><a href="#topic+ProjSp">ProjSp</a></code> function</p>
</td></tr>
<tr><td><code id="ProjKrigSp_+3A_coords_obs">coords_obs</code></td>
<td>
<p>coordinates of observed locations (in UTM)</p>
</td></tr>
<tr><td><code id="ProjKrigSp_+3A_coords_nobs">coords_nobs</code></td>
<td>
<p>coordinates of unobserved locations (in UTM)</p>
</td></tr>
<tr><td><code id="ProjKrigSp_+3A_x_obs">x_obs</code></td>
<td>
<p>observed values in <code class="reqn">[0,2\pi)</code>.
If they are not in <code class="reqn">[0,2\pi)</code>, the function will transform
the data in the right interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements
</p>

<dl>
<dt><code>M_out</code></dt><dd><p>the mean of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp</p>
</dd>
<dt><code>V_out</code></dt><dd><p>the variance of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSp</p>
</dd>
<dt><code>Prev_out</code></dt><dd><p>the posterior predicted  values at the unobserved locations.</p>
</dd>
</dl>



<h3>References</h3>

<p>F. Wang, A. E.   Gelfand,
&quot;Modeling space and space-time directional data using projected Gaussian processes&quot;,
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>
<p>G. Mastrantonio, G. Jona Lasinio, A. E. Gelfand,
&quot;Spatio-temporal circular models with non-separable covariance structure&quot;,
TEST 25 (2016), 331-350 https://doi.org/10.1007/s11749-015-0458-y
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjSp">ProjSp</a></code> for spatial sampling from
Projected Normal ,
<code><a href="#topic+WrapSp">WrapSp</a></code> for spatial sampling from
Wrapped Normal and <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for
spatial interpolation under the wrapped model
</p>
<p>Other spatial interpolations: <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
## auxiliary function
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
 d &lt;- if (is.matrix(varcov))
   ncol(varcov)
 else 1
 z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
 y &lt;- t(mean + t(z))
 return(y)
}

####
# Simulation using exponential  spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
tau     &lt;- 0.2
sigma2  &lt;- 1
alpha   &lt;- c(0.5,0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n),
           kronecker(SIGMA, matrix(c( sigma2,sqrt(sigma2)*tau,sqrt(sigma2)*tau,1 ) ,nrow=2 )))
theta &lt;- c()
for(i in 1:n) {
 theta[i] &lt;- atan2(Y[(i-1)*2+2],Y[(i-1)*2+1])
}
theta &lt;- theta %% (2*pi) #to be sure to have values in (0,2pi)

hist(theta)
rose_diag(theta)

val &lt;- sample(1:n,round(n*0.1))

################some useful quantities
rho.min &lt;- 3/max(Dist)
rho.max &lt;- rho.min+0.5

set.seed(100)

mod &lt;- ProjSp(
 x       = theta[-val],
 coords    = coords[-val,],
 start   = list("alpha"      = c(0.92, 0.18, 0.56, -0.35),
                "rho"     = c(0.51,0.15),
                "tau"     = c(0.46, 0.66),
                "sigma2"    = c(0.27, 0.3),
                "r"       = abs(rnorm(  length(theta))  )),
 priors   = list("rho"      = c(rho.min,rho.max),
                 "tau"      = c(-1,1),
                 "sigma2"    = c(10,3),
                 "alpha_mu" = c(0, 0),
                 "alpha_sigma" = diag(10,2)
 )  ,
 sd_prop   = list("sigma2" = 0.1, "tau" = 0.1, "rho" = 0.1,
                  "sdr" = sample(.05,length(theta), replace = TRUE)),
 iter    = 10000,
 BurninThin    = c(burnin = 7000, thin = 10),
 accept_ratio = 0.234,
 adapt_param = c(start = 130000, end = 120000, exp = 0.5),#no adaptation
 corr_fun = "exponential",
 kappa_matern = .5,
 n_chains = 2 ,
 parallel = TRUE ,
 n_cores = 2
)
# If you don't want to install/use DoParallel
# please set parallel = FALSE. Keep in mind that it can be substantially slower
# How much it takes?

check &lt;-  ConvCheck(mod)
check$Rhat #close to 1 we have convergence

#### graphical check
par(mfrow=c(3,2))
coda::traceplot(check$mcmc)

par(mfrow=c(1,1))

# move to prediction once convergence is achieved
Krig &lt;- ProjKrigSp(
 ProjSp_out = mod,
 coords_obs =  coords[-val,],
 coords_nobs =  coords[val,],
 x_obs = theta[-val]
)

# The quality of prediction can be checked using APEcirc and CRPScirc
ape  &lt;- APEcirc(theta[val],Krig$Prev_out)
crps &lt;- CRPScirc(theta[val],Krig$Prev_out)
</code></pre>

<hr>
<h2 id='ProjKrigSpTi'>#' Spatio temporal interpolation using projected spatial temporal normal model.</h2><span id='topic+ProjKrigSpTi'></span>

<h3>Description</h3>

<p><code>ProjKrigSpTi</code> function computes the spatio-temporal
prediction for circular space-time data using samples
from the posterior distribution of the space-time projected normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjKrigSpTi(ProjSpTi_out, coords_obs, coords_nobs, times_obs, times_nobs,
  x_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjKrigSpTi_+3A_projspti_out">ProjSpTi_out</code></td>
<td>
<p>the functions takes the output of <code><a href="#topic+ProjSpTi">ProjSpTi</a></code> function</p>
</td></tr>
<tr><td><code id="ProjKrigSpTi_+3A_coords_obs">coords_obs</code></td>
<td>
<p>coordinates of observed locations (in UTM)</p>
</td></tr>
<tr><td><code id="ProjKrigSpTi_+3A_coords_nobs">coords_nobs</code></td>
<td>
<p>coordinates of unobserved locations (in UTM)</p>
</td></tr>
<tr><td><code id="ProjKrigSpTi_+3A_times_obs">times_obs</code></td>
<td>
<p>numeric vector of observed time coordinates</p>
</td></tr>
<tr><td><code id="ProjKrigSpTi_+3A_times_nobs">times_nobs</code></td>
<td>
<p>numeric vector of unobserved time coordinates</p>
</td></tr>
<tr><td><code id="ProjKrigSpTi_+3A_x_obs">x_obs</code></td>
<td>
<p>observed values in <code class="reqn">[0,2\pi)</code>
If they are not in <code class="reqn">[0,2\pi)</code>, the function will tranform
the data in the right interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements
</p>

<dl>
<dt><code>M_out</code></dt><dd><p>the mean of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSpTi</p>
</dd>
<dt><code>V_out</code></dt><dd><p>the variance of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by ProjSpTi</p>
</dd>
<dt><code>Prev_out</code></dt><dd><p>are the posterior predicted  values at the unobserved locations.</p>
</dd>
</dl>



<h3>References</h3>

<p>G. Mastrantonio, G.Jona Lasinio,
A. E. Gelfand, &quot;Spatio-temporal circular models with
non-separable covariance structure&quot;, TEST 25 (2016), 331–350.
</p>
<p>F. Wang, A. E.   Gelfand,
&quot;Modeling space and space-time directional data using projected Gaussian processes&quot;,
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>
<p>T. Gneiting,  &quot;Nonseparable, Stationary Covariance Functions for Space-Time
Data&quot;, JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjSpTi">ProjSpTi</a></code> to sample the posterior distribution of the spatio-temporal
Projected Normal model,
<code><a href="#topic+WrapSpTi">WrapSpTi</a></code> to sample the posterior distribution of the spatio-temporal
Wrapped Normal model and <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for
spatio-temporal interpolation under the same model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
#### simulated example
## auxiliary functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov) {
  d &lt;- if (is.matrix(varcov)) {
    ncol(varcov)
  } else {
    1
  }
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}
####
# Simulation using a gneiting covariance function
####
set.seed(1)
n &lt;- 20

coords &lt;- cbind(runif(n, 0, 100), runif(n, 0, 100))
coordsT &lt;- cbind(runif(n, 0, 100))
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho &lt;- 0.05
rhoT &lt;- 0.01
sep_par &lt;- 0.1
sigma2 &lt;- 1
alpha &lt;- c(0.5)
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist / (rhoT * DistT^2 + 1)^(sep_par / 2))
tau &lt;- 0.2

Y &lt;- rmnorm(
  1, rep(alpha, times = n),
  kronecker(SIGMA, matrix(c(sigma2, sqrt(sigma2) * tau, sqrt(sigma2) * tau, 1), nrow = 2))
)
theta &lt;- c()
for (i in 1:n) {
  theta[i] &lt;- atan2(Y[(i - 1) * 2 + 2], Y[(i - 1) * 2 + 1])
}
theta &lt;- theta %% (2 * pi) ## to be sure we have values in (0,2pi)
rose_diag(theta)
################ some useful quantities
rho_sp.min &lt;- 3 / max(Dist)
rho_sp.max &lt;- rho_sp.min + 0.5
rho_t.min &lt;- 3 / max(DistT)
rho_t.max &lt;- rho_t.min + 0.5
### validation set 20% of the data
val &lt;- sample(1:n, round(n * 0.2))

set.seed(200)

mod &lt;- ProjSpTi(
  x = theta[-val],
  coords = coords[-val, ],
  times = coordsT[-val],
  start = list(
    "alpha" = c(0.66, 0.38, 0.27, 0.13),
    "rho_sp" = c(0.29, 0.33),
    "rho_t" = c(0.25, 0.13),
    "sep_par" = c(0.56, 0.31),
    "tau" = c(0.71, 0.65),
    "sigma2" = c(0.47, 0.53),
    "r" = abs(rnorm(length(theta[-val])))
  ),
  priors = list(
    "rho_sp" = c(rho_sp.min, rho_sp.max), # Uniform prior in this interval
    "rho_t" = c(rho_t.min, rho_t.max), # Uniform prior in this interval
    "sep_par" = c(1, 1), # Beta distribution
    "tau" = c(-1, 1), ## Uniform prior in this interval
    "sigma2" = c(10, 3), # inverse gamma
    "alpha_mu" = c(0, 0), ## a vector of 2 elements,
    ## the means of the bivariate Gaussian distribution
    "alpha_sigma" = diag(10, 2) # a 2x2 matrix, the covariance matrix of the
    # bivariate Gaussian distribution,
  ),
  sd_prop = list(
    "sep_par" = 0.1, "sigma2" = 0.1, "tau" = 0.1, "rho_sp" = 0.1, "rho_t" = 0.1,
    "sdr" = sample(.05, length(theta), replace = TRUE)
  ),
  iter = 4000,
  BurninThin = c(burnin = 2000, thin = 2),
  accept_ratio = 0.234,
  adapt_param = c(start = 155000, end = 156000, exp = 0.5),
  n_chains = 2,
  parallel = TRUE,
)
check &lt;- ConvCheck(mod)
check$Rhat ### convergence has been reached when the values are close to 1
#### graphical checking
#### recall that it is made of as many lists as the number of chains and it has elements named
#### as the model's parameters
par(mfrow = c(3, 3))
coda::traceplot(check$mcmc)
par(mfrow = c(1, 1))
# once convergence is reached we run the interpolation on the validation set
Krig &lt;- ProjKrigSpTi(
  ProjSpTi_out = mod,
  coords_obs = coords[-val, ],
  coords_nobs = coords[val, ],
  times_obs = coordsT[-val],
  times_nobs = coordsT[val],
  x_obs = theta[-val]
)

#### checking the prediction

Proj_ape &lt;- APEcirc(theta[val], Krig$Prev_out)
Proj_crps &lt;- CRPScirc(theta[val],Krig$Prev_out)

</code></pre>

<hr>
<h2 id='ProjSp'>Samples from the Projected Normal spatial model</h2><span id='topic+ProjSp'></span>

<h3>Description</h3>

<p><code>ProjSp</code>  produces samples from the posterior distribtion
of the spatial projected normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjSp(x = x, coords = coords, start = list(alpha = c(1, 1, 0.5,
  0.5), tau = c(0.1, 0.5), rho = c(0.1, 0.5), sigma2 = c(0.1, 0.5), r =
  rep(1, times = length(x))), priors = list(tau = c(8, 14), rho = c(8,
  14), sigma2 = c(), alpha_mu = c(1, 1), alpha_sigma = c()),
  sd_prop = list(sigma2 = 0.5, tau = 0.5, rho = 0.5, sdr = sample(0.05,
  length(x), replace = TRUE)), iter = 1000, BurninThin = c(burnin = 20,
  thin = 10), accept_ratio = 0.234, adapt_param = c(start = 1, end =
  1e+07, exp = 0.9, sdr_update_iter = 50), corr_fun = "exponential",
  kappa_matern = 0.5, n_chains = 2, parallel = FALSE, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjSp_+3A_x">x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>.
If they are not in <code class="reqn">[0,2\pi)</code>, the function will transform
the data in the right interval</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_coords">coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_start">start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a vector with <code>n_chains</code> elements
</p>

<ul>
<li><p>     alpha the 2-d vector of the means of the Gaussian bi-variate distribution,
</p>
</li>
<li><p>  tau the correlation of the two components of the linear representation,
</p>
</li>
<li><p>  rho the spatial decay parameter,
</p>
</li>
<li><p> sigma2 the process variance,
</p>
</li>
<li><p> r the vector of <code>length(x)</code>,  latent variable
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProjSp_+3A_priors">priors</code></td>
<td>
<p>a list of 4 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha_mu</dt><dd><p>a vector of 2 elements, the means of  the bivariate Gaussian distribution,</p>
</dd>
<dt>alpha_sigma</dt><dd><p>a 2x2 matrix, the covariance matrix of the bivariate Gaussian distribution,</p>
</dd>
<dt>rho</dt><dd><p> vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>tau</dt><dd><p> vector of 2 elements defining the minimum and maximum of a uniform distribution, with the constraints min(tau) &gt;= -1 and max(tau) &lt;= 1</p>
</dd>
<dt> sigma2</dt><dd><p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ProjSp_+3A_sd_prop">sd_prop</code></td>
<td>
<p>list of 4 elements. To run the MCMC for the rho, tau and sigma2 parameters and r vector we use an adaptive metropolis and in sd_prop we build a list of initial guesses for these three parameters and the r vector</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_iter">iter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_burninthin">BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_accept_ratio">accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_adapt_param">adapt_param</code></td>
<td>
<p>a vector of 4 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes. The last element (sdr_update_iter) must be a positive integer defining every how many iterations there is the update of the sd  (vector) of  (vector) r.</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_corr_fun">corr_fun</code></td>
<td>
<p>characters, the name of the correlation function;
currently implemented functions are c(&quot;exponential&quot;, &quot;matern&quot;,&quot;gaussian&quot;)</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_kappa_matern">kappa_matern</code></td>
<td>
<p>numeric, the smoothness parameter of the Matern
correlation function, default is <code>kappa_matern = 0.5</code> (the exponential function)</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_n_chains">n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_parallel">parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td></tr>
<tr><td><code id="ProjSp_+3A_n_cores">n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it returns a list of <code>n_chains</code> lists each with elements
</p>

<dl>
<dt><code>rho</code>,<code>tau</code>, <code>sigma2</code></dt><dd><p>vectors with the thinned chains</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a matrix with <code>nrow=2</code> and <code>ncol=</code> the length of thinned chains,</p>
</dd>
<dt><code>r</code></dt><dd><p>a matrix with <code>nrow=length(x)</code> and <code>ncol=</code> the length of thinned chains</p>
</dd>
<dt><code>corr_fun</code> </dt><dd><p>characters with the type of spatial correlation chosen</p>
</dd>
<dt><code>distribution</code></dt><dd><p>characters, always &quot;ProjSp&quot;</p>
</dd>
</dl>



<h3>References</h3>

<p>G. Mastrantonio , G. Jona Lasinio,   A. E. Gelfand,
&quot;Spatio-temporal circular models with non-separable covariance structure&quot;,
TEST 25 (2016), 331–350.
</p>
<p>F. Wang, A. E.   Gelfand,
&quot;Modeling space and space-time directional data using projected Gaussian processes&quot;,
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> for spatial interpolation under the projected normal model,
<code><a href="#topic+WrapSp">WrapSp</a></code> for spatial sampling from
Wrapped Normal and <code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for
Kriging estimation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CircSpaceTime)
## auxiliary function
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
 d &lt;- if (is.matrix(varcov))
   ncol(varcov)
 else 1
 z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
 y &lt;- t(mean + t(z))
 return(y)
}

####
# Simulation using exponential  spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
tau     &lt;- 0.2
sigma2  &lt;- 1
alpha   &lt;- c(0.5,0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n),
           kronecker(SIGMA, matrix(c( sigma2,sqrt(sigma2)*tau,sqrt(sigma2)*tau,1 ) ,nrow=2 )))
theta &lt;- c()
for(i in 1:n) {
 theta[i] &lt;- atan2(Y[(i-1)*2+2],Y[(i-1)*2+1])
}
theta &lt;- theta %% (2*pi) #to be sure to have values in (0,2pi)

hist(theta)
rose_diag(theta)

val &lt;- sample(1:n,round(n*0.1))

################some useful quantities
rho.min &lt;- 3/max(Dist)
rho.max &lt;- rho.min+0.5

set.seed(100)

mod &lt;- ProjSp(
 x       = theta[-val],
 coords    = coords[-val,],
 start   = list("alpha"      = c(0.92, 0.18, 0.56, -0.35),
                "rho"     = c(0.51,0.15),
                "tau"     = c(0.46, 0.66),
                "sigma2"    = c(0.27, 0.3),
                "r"       = abs(rnorm(  length(theta))  )),
 priors   = list("rho"      = c(rho.min,rho.max),
                 "tau"      = c(-1,1),
                 "sigma2"    = c(10,3),
                 "alpha_mu" = c(0, 0),
                 "alpha_sigma" = diag(10,2)
 )  ,
 sd_prop   = list("sigma2" = 0.1, "tau" = 0.1, "rho" = 0.1,
                  "sdr" = sample(.05,length(theta), replace = TRUE)),
 iter    = 10000,
 BurninThin    = c(burnin = 7000, thin = 10),
 accept_ratio = 0.234,
 adapt_param = c(start = 130000, end = 120000, exp = 0.5),#no adaptation
 corr_fun = "exponential",
 kappa_matern = .5,
 n_chains = 2 ,
 parallel = TRUE ,
 n_cores = 2
)
# If you don't want to install/use DoParallel
# please set parallel = FALSE. Keep in mind that it can be substantially slower
# How much it takes?

check &lt;-  ConvCheck(mod)
check$Rhat #close to 1 we have convergence

#### graphical check
par(mfrow=c(3,2))
coda::traceplot(check$mcmc)

par(mfrow=c(1,1))
# once convergence is achieved move to prediction using ProjKrigSp

</code></pre>

<hr>
<h2 id='ProjSpTi'>Samples from the posterior distribution of the Projected Normal spatial model</h2><span id='topic+ProjSpTi'></span>

<h3>Description</h3>

<p><code>ProjSpTi</code> produces samples from the posterior distribution of the spatial
projected normal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProjSpTi(x = x, coords = coords, times = c(), start = list(alpha =
  c(1, 1, 0.5, 0.5), tau = c(0.1, 0.5), rho_sp = c(0.1, 0.5), rho_t =
  c(0.1, 0.5), sep_par = c(0.1, 0.5), sigma2 = c(0.1, 0.5), r = sample(1,
  length(x), replace = T)), priors = list(tau = c(8, 14), rho_sp = c(8,
  14), rho_t = c(8, 14), sep_par = c(8, 14), sigma2 = c(), alpha_mu = c(1,
  1), alpha_sigma = c()), sd_prop = list(sigma2 = 0.5, tau = 0.5, rho_sp
  = 0.5, rho_t = 0.5, sep_par = 0.5, sdr = sample(0.05, length(x), replace
  = T)), iter = 1000, BurninThin = c(burnin = 20, thin = 10),
  accept_ratio = 0.234, adapt_param = c(start = 1, end = 1e+07, exp =
  0.9, sdr_update_iter = 50), n_chains = 2, parallel = FALSE,
  n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProjSpTi_+3A_x">x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>
If they are not in <code class="reqn">[0,2\pi)</code>, the function will tranform
the data in the right interval</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_coords">coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_times">times</code></td>
<td>
<p>an n vector with the times of ....</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_start">start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a vector with <code>n_chains</code> elements
</p>

<ul>
<li><p>     alpha the 2-d vector of the means of the Gaussian bi-variate distribution,
</p>
</li>
<li><p>  tau the correlation of the two components of the linear representation,
</p>
</li>
<li><p>  rho_sp the spatial decay parameter,
</p>
</li>
<li><p>  rho_t the temporal decay parameter,
</p>
</li>
<li><p>  sigma2 the process variance,
</p>
</li>
<li><p>  sep_par the separation parameter,
</p>
</li>
<li><p>  r the vector of <code>length(x)</code>,  latent variable
</p>
</li></ul>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_priors">priors</code></td>
<td>
<p>a list of 7 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha_mu</dt><dd><p>a vector of 2 elements, the means of  the bivariate Gaussian distribution,</p>
</dd>
<dt>alpha_sigma</dt><dd><p>a 2x2 matrix, the covariance matrix of the bivariate Gaussian distribution,</p>
</dd>
<dt>rho_sp</dt><dd><p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>rho_t</dt><dd><p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>tau</dt><dd><p> vector of 2 elements defining the minimum and maximum of a uniform distribution with the constraints min(tau) &gt;= -1 and max(tau) &lt;= 1,</p>
</dd>
<dt>sep_par</dt><dd><p>a vector of 2 elements defining the two parameters of a beta distribution,</p>
</dd>
<dt>sigma2</dt><dd><p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_sd_prop">sd_prop</code></td>
<td>
<p>=list of 4 elements. To run the MCMC for the rho_sp, tau and sigma2 parameters and r vector we use an adaptive metropolis and in sd_prop we build a list of initial guesses for these three parameters and the r vector</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_iter">iter</code></td>
<td>
<p>iter number of iterations</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_burninthin">BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_accept_ratio">accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_adapt_param">adapt_param</code></td>
<td>
<p>a vector of 4 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes. The last element (sdr_update_iter) must be a positive integer defining every how many iterations there is the update of the sd  (vector) of  (vector) r.</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_n_chains">n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_parallel">parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td></tr>
<tr><td><code id="ProjSpTi_+3A_n_cores">n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it returns a list of <code>n_chains</code> lists each with elements
</p>

<dl>
<dt><code>tau</code>, <code>rho_sp</code>, <code>rho_t</code>, <code>sigma2</code></dt><dd><p>vectors with the thinned chains</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a matrix with <code>nrow=2</code> and <code>ncol=</code> the length of thinned chains</p>
</dd>
<dt><code>r</code></dt><dd><p>a matrix with <code>nrow=length(x)</code> and <code>ncol=</code> the length of thinned chains</p>
</dd>
</dl>



<h3>References</h3>

<p>G. Mastrantonio, G.Jona Lasinio,
A. E. Gelfand, &quot;Spatio-temporal circular models with
non-separable covariance structure&quot;, TEST 25 (2016), 331–350.
</p>
<p>F. Wang, A. E.   Gelfand,
&quot;Modeling space and space-time directional data using projected Gaussian processes&quot;,
Journal of the American Statistical Association,109 (2014), 1565-1580
</p>
<p>T. Gneiting,  &quot;Nonseparable, Stationary Covariance Functions for Space-Time
Data&quot;, JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> for spatio-temporal prediction under the spatio-temporal projected  normal model,
<code><a href="#topic+WrapSpTi">WrapSpTi</a></code> to sample from the posterior distribution of the  spatio-temporal
Wrapped Normal model and <code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for spatio-temporal prediction under the
same model
</p>
<p>Other spatio-temporal models: <code><a href="#topic+WrapSpTi">WrapSpTi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
#### simulated example
## auxiliary functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov) {
  d &lt;- if (is.matrix(varcov)) {
    ncol(varcov)
  } else {
    1
  }
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}
####
# Simulation using a gneiting covariance function
####
set.seed(1)
n &lt;- 20

coords &lt;- cbind(runif(n, 0, 100), runif(n, 0, 100))
coordsT &lt;- cbind(runif(n, 0, 100))
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho &lt;- 0.05
rhoT &lt;- 0.01
sep_par &lt;- 0.1
sigma2 &lt;- 1
alpha &lt;- c(0.5)
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist / (rhoT * DistT^2 + 1)^(sep_par / 2))
tau &lt;- 0.2

Y &lt;- rmnorm(
  1, rep(alpha, times = n),
  kronecker(SIGMA, matrix(c(sigma2, sqrt(sigma2) * tau, sqrt(sigma2) * tau, 1), nrow = 2))
)
theta &lt;- c()
for (i in 1:n) {
  theta[i] &lt;- atan2(Y[(i - 1) * 2 + 2], Y[(i - 1) * 2 + 1])
}
theta &lt;- theta %% (2 * pi) ## to be sure we have values in (0,2pi)
rose_diag(theta)
################ some useful quantities
rho_sp.min &lt;- 3 / max(Dist)
rho_sp.max &lt;- rho_sp.min + 0.5
rho_t.min &lt;- 3 / max(DistT)
rho_t.max &lt;- rho_t.min + 0.5
### validation set 20% of the data
val &lt;- sample(1:n, round(n * 0.2))

set.seed(200)

mod &lt;- ProjSpTi(
  x = theta[-val],
  coords = coords[-val, ],
  times = coordsT[-val],
  start = list(
    "alpha" = c(0.66, 0.38, 0.27, 0.13),
    "rho_sp" = c(0.29, 0.33),
    "rho_t" = c(0.25, 0.13),
    "sep_par" = c(0.56, 0.31),
    "tau" = c(0.71, 0.65),
    "sigma2" = c(0.47, 0.53),
    "r" = abs(rnorm(length(theta[-val])))
  ),
  priors = list(
    "rho_sp" = c(rho_sp.min, rho_sp.max), # Uniform prior in this interval
    "rho_t" = c(rho_t.min, rho_t.max), # Uniform prior in this interval
    "sep_par" = c(1, 1), # Beta distribution
    "tau" = c(-1, 1), ## Uniform prior in this interval
    "sigma2" = c(10, 3), # inverse gamma
    "alpha_mu" = c(0, 0), ## a vector of 2 elements,
    ## the means of the bivariate Gaussian distribution
    "alpha_sigma" = diag(10, 2) # a 2x2 matrix, the covariance matrix of the
    # bivariate Gaussian distribution,
  ),
  sd_prop = list(
    "sep_par" = 0.1, "sigma2" = 0.1, "tau" = 0.1, "rho_sp" = 0.1, "rho_t" = 0.1,
    "sdr" = sample(.05, length(theta), replace = TRUE)
  ),
  iter = 4000,
  BurninThin = c(burnin = 2000, thin = 2),
  accept_ratio = 0.234,
  adapt_param = c(start = 155000, end = 156000, exp = 0.5),
  n_chains = 2,
  parallel = TRUE,
)
check &lt;- ConvCheck(mod)
check$Rhat ### convergence has been reached when the values are close to 1
#### graphical checking
#### recall that it is made of as many lists as the number of chains and it has elements named
#### as the model's parameters
par(mfrow = c(3, 3))
coda::traceplot(check$mcmc)
par(mfrow = c(1, 1))
# move to prediction once convergence is achieved using ProjKrigSpTi
</code></pre>

<hr>
<h2 id='rose_diag'>Rose diagram in ggplot2 inspired from rose.diag in package circular.</h2><span id='topic+rose_diag'></span>

<h3>Description</h3>

<p>Rose diagram in ggplot2 inspired from rose.diag in package circular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose_diag(x, bins = 15, color = "red", alpha = 1, start = 0,
  add = FALSE, template = "rad", direction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_diag_+3A_x">x</code></td>
<td>
<p>a vector of circular coordinates in radiants <code class="reqn">[0,2 \pi)</code>.</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_bins">bins</code></td>
<td>
<p>number of bins</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_color">color</code></td>
<td>
<p>color of the line and of the fill</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_alpha">alpha</code></td>
<td>
<p>transparency</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_start">start</code></td>
<td>
<p>the starting angle of the 0 (the North)</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_add">add</code></td>
<td>
<p>add the rose_diag to an existing ggplot2 plot</p>
</td></tr>
<tr><td><code id="rose_diag_+3A_template">template</code></td>
<td>
<p>radiants or wind rose. the values are <code>c("rad","wind_rose")</code>..
default is <code>"rad"</code></p>
</td></tr>
<tr><td><code id="rose_diag_+3A_direction">direction</code></td>
<td>
<p>1, clockwise; -1, anticlockwise. For template = &quot;rad&quot; direction is -1 while
for template = &quot;wind_rose&quot; direction is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot in ggplot2 format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(CircSpaceTime)
x &lt;- circular::rwrappedstable(200, index = 1.5, skewness = .5)
x1 &lt;- circular::rwrappedstable(200, index = 2, skewness = .5)
x2 &lt;- circular::rwrappedstable(200, index = 0.5, skewness = 1)
rose_diag(x, bins = 15, color = "green")
rose_diag(x1, bins = 15, color = "blue", alpha = .5, add = TRUE)
rose_diag(x2, bins = 15, color = "red", alpha = .5, add = TRUE)

</code></pre>

<hr>
<h2 id='WrapKrigSp'>Spatial interpolation using wrapped normal model.</h2><span id='topic+WrapKrigSp'></span>

<h3>Description</h3>

<p><code>WrapKrigSp</code> function computes the spatial prediction
for circular spatial data using samples from the posterior distribution
of the spatial wrapped normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapKrigSp(WrapSp_out, coords_obs, coords_nobs, x_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WrapKrigSp_+3A_wrapsp_out">WrapSp_out</code></td>
<td>
<p>the functions takes the output of <code><a href="#topic+WrapSp">WrapSp</a></code> function</p>
</td></tr>
<tr><td><code id="WrapKrigSp_+3A_coords_obs">coords_obs</code></td>
<td>
<p>coordinates of observed locations (in UTM)</p>
</td></tr>
<tr><td><code id="WrapKrigSp_+3A_coords_nobs">coords_nobs</code></td>
<td>
<p>coordinates of unobserved locations (in UTM)</p>
</td></tr>
<tr><td><code id="WrapKrigSp_+3A_x_obs">x_obs</code></td>
<td>
<p>observed values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements
</p>

<dl>
<dt><code>M_out</code></dt><dd><p> the mean of the associated linear process
on the prediction locations  coords_nobs (rows) over
all the posterior samples (columns) returned by WrapSp</p>
</dd>
<dt><code>V_out</code></dt><dd><p> the variance of the associated linear process
on the prediction locations  coords_nobs (rows) over
all the posterior samples (columns) returned by WrapSp</p>
</dd>
<dt><code>Prev_out</code></dt><dd><p> the posterior predicted  values
at the unobserved locations.</p>
</dd>
</dl>



<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around pi,
and the posterior samples of x and posterior mean are changed back
to the original scale
</p>


<h3>References</h3>

<p>G. Jona-Lasinio, A .E. Gelfand, M. Jona-Lasinio,
&quot;Spatial analysis of wave direction data using wrapped Gaussian processes&quot;,
The Annals of Applied Statistics, 6 (2012), 1478-1498
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapSp">WrapSp</a></code> for spatial sampling from
Wrapped Normal ,
<code><a href="#topic+ProjSp">ProjSp</a></code> for spatial sampling from
Projected Normal and <code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> for
Kriging estimation
</p>
<p>Other spatial interpolations: <code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
## graphical check
par(mfrow = c(3,1))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))
##### We move to the spatial interpolation

Krig &lt;- WrapKrigSp(
  WrapSp_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  x_obs = theta[-val]
)

#### check the quality of the prediction using APE and CRPS
ApeCheck &lt;- APEcirc(theta[val],Krig$Prev_out)
CrpsCheck &lt;- CRPScirc(theta[val],Krig$Prev_out)

</code></pre>

<hr>
<h2 id='WrapKrigSpTi'>Prediction using wrapped normal spatio-temporal model.</h2><span id='topic+WrapKrigSpTi'></span>

<h3>Description</h3>

<p><code>WrapKrigSpTi</code>  function computes the spatio-temporal prediction
for circular space-time data using samples from the posterior distribution
of the space-time wrapped normal model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapKrigSpTi(WrapSpTi_out, coords_obs, coords_nobs, times_obs, times_nobs,
  x_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WrapKrigSpTi_+3A_wrapspti_out">WrapSpTi_out</code></td>
<td>
<p>the functions takes the output of <code><a href="#topic+WrapSpTi">WrapSpTi</a></code> function</p>
</td></tr>
<tr><td><code id="WrapKrigSpTi_+3A_coords_obs">coords_obs</code></td>
<td>
<p>coordinates of observed locations (in UTM)</p>
</td></tr>
<tr><td><code id="WrapKrigSpTi_+3A_coords_nobs">coords_nobs</code></td>
<td>
<p>coordinates of unobserved locations (in UTM)</p>
</td></tr>
<tr><td><code id="WrapKrigSpTi_+3A_times_obs">times_obs</code></td>
<td>
<p>numeric vector of observed time coordinates</p>
</td></tr>
<tr><td><code id="WrapKrigSpTi_+3A_times_nobs">times_nobs</code></td>
<td>
<p>numeric vector of unobserved time coordinates</p>
</td></tr>
<tr><td><code id="WrapKrigSpTi_+3A_x_obs">x_obs</code></td>
<td>
<p>observed values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 elements
</p>

<dl>
<dt><code>M_out</code></dt><dd><p> the mean of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by <code><a href="#topic+WrapSpTi">WrapSpTi</a></code></p>
</dd>
<dt><code>V_out</code></dt><dd><p> the variance of the associated linear process on the prediction locations  coords_nobs (rows) over all the posterior samples (columns) returned by <code><a href="#topic+WrapSpTi">WrapSpTi</a></code></p>
</dd>
<dt><code>Prev_out</code></dt><dd><p> the posterior predicted  values at the unobserved locations</p>
</dd>
</dl>



<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around <code class="reqn">\pi</code>.
Posterior samples of x at the predictive locations and posterior mean are changed back
to the original scale
</p>


<h3>References</h3>

<p>G. Mastrantonio, G. Jona Lasinio, A. E. Gelfand, &quot;Spatio-temporal circular models with
non-separable covariance structure&quot;, TEST 25 (2016), 331–350
</p>
<p>T. Gneiting,  &quot;Nonseparable, Stationary Covariance Functions for Space-Time
Data&quot;, JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapSpTi">WrapSpTi</a></code> spatio-temporal sampling from
Wrapped Normal,
<code><a href="#topic+ProjSpTi">ProjSpTi</a></code> for spatio-temporal sampling from
Projected Normal and <code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> for
Kriging estimation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
## functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

######################################
## Simulation                       ##
######################################
set.seed(1)
n &lt;- 20
### simulate coordinates from a unifrom distribution
coords  &lt;- cbind(runif(n,0,100), runif(n,0,100)) #spatial coordinates
coordsT &lt;- sort(runif(n,0,100)) #time coordinates (ordered)
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho     &lt;- 0.05 #spatial decay
rhoT    &lt;- 0.01 #temporal decay
sep_par &lt;- 0.5 #separability parameter
sigma2  &lt;- 0.3 # variance of the process
alpha   &lt;- c(0.5)
#Gneiting covariance
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist/(rhoT * DistT^2 + 1)^(sep_par/2))

Y &lt;- rmnorm(1,rep(alpha, times = n), SIGMA) #generate the linear variable
theta &lt;- c()
## wrapping step
for(i in 1:n) {
  theta[i] &lt;- Y[i] %% (2*pi)
}
### Add plots of the simulated data

rose_diag(theta)
## use this values as references for the definition of initial values and priors
rho_sp.min &lt;- 3/max(Dist)
rho_sp.max &lt;- rho_sp.min+0.5
rho_t.min  &lt;- 3/max(DistT)
rho_t.max  &lt;- rho_t.min+0.5
val &lt;- sample(1:n,round(n*0.2)) #validation set
set.seed(100)
mod &lt;- WrapSpTi(
  x       = theta[-val],
  coords    = coords[-val,],
  times    = coordsT[-val],
  start   = list("alpha"      = c(.79, .74),
                 "rho_sp"     = c(.33,.52),
                 "rho_t"     = c(.19, .43),
                 "sigma2"    = c(.49, .37),
                 "sep_par"  = c(.47, .56),
                 "k"       = sample(0,length(theta[-val]), replace = TRUE)),
  priors   = list("rho_sp"      = c(0.01,3/4), ### uniform prior on this interval
                  "rho_t"      = c(0.01,3/4), ### uniform prior on this interval
                  "sep_par"  = c(1,1), ### beta prior
                  "sigma2"    = c(5,5),## inverse gamma prior with mode=5/6
                  "alpha" =  c(0,20) ## wrapped gaussian with large variance
  )  ,
  sd_prop   = list( "sigma2" = 0.1,  "rho_sp" = 0.1,  "rho_t" = 0.1,"sep_par"= 0.1),
  iter    = 7000,
  BurninThin    = c(burnin = 3000, thin = 10),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  n_chains = 2 ,
  parallel = FALSE,
  n_cores = 1
)
check &lt;- ConvCheck(mod,startit = 1 ,thin = 1)
check$Rhat ## convergence has been reached
## when plotting chains remember that alpha is a circular variable
par(mfrow = c(3,2))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))


############## Prediction on the validation set
Krig &lt;- WrapKrigSpTi(
  WrapSpTi_out = mod,
  coords_obs =  coords[-val,],
  coords_nobs =  coords[val,],
  times_obs =  coordsT[-val],
  times_nobs =  coordsT[val],
  x_obs = theta[-val]
)
### checking the prediction
Wrap_Ape &lt;- APEcirc(theta[val], Krig$Prev_out)
Wrap_Crps &lt;- CRPScirc(theta[val], Krig$Prev_out)
</code></pre>

<hr>
<h2 id='WrapSp'>Samples from the Wrapped Normal spatial model</h2><span id='topic+WrapSp'></span>

<h3>Description</h3>

<p>The function <code>WrapSp</code> produces samples from the posterior
distribution of the wrapped normal spatial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapSp(x = x, coords = coords, start = list(alpha = c(2, 1), rho =
  c(0.1, 0.5), sigma2 = c(0.1, 0.5), k = sample(0, length(x), replace =
  T)), priors = list(alpha = c(pi, 1, -10, 10), rho = c(8, 14), sigma2 =
  c()), sd_prop = list(sigma2 = 0.5, rho = 0.5), iter = 1000,
  BurninThin = c(burnin = 20, thin = 10), accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1e+07, exp = 0.9),
  corr_fun = "exponential", kappa_matern = 0.5, n_chains = 1,
  parallel = FALSE, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WrapSp_+3A_x">x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>
If they are not in <code class="reqn">[0,2\pi)</code>, the function will tranform
the data in the right interval</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_coords">coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_start">start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a numeric vector with <code>n_chains</code> elements
</p>

<ul>
<li><p>  alpha the mean which value is in <code class="reqn">[0,2\pi)</code>.
</p>
</li>
<li><p>  rho the spatial decay parameter
</p>
</li>
<li><p> sigma2 the process variance
</p>
</li>
<li><p> k the vector of <code>length(x)</code> winding numbers
</p>
</li></ul>
</td></tr>
<tr><td><code id="WrapSp_+3A_priors">priors</code></td>
<td>
<p>a list of 3 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha</dt><dd><p>a vector of 2 elements the mean and the variance of  a Wrapped Gaussian distribution, default is mean <code class="reqn">\pi</code> and variance 1,</p>
</dd>
<dt>rho</dt><dd><p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>sigma2</dt><dd><p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="WrapSp_+3A_sd_prop">sd_prop</code></td>
<td>
<p>list of 3 elements. To run the MCMC for the rho and sigma2 parameters we use an adaptive metropolis and in sd.prop we build a list of initial guesses for these two parameters and the beta parameter</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_iter">iter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_burninthin">BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_accept_ratio">accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_adapt_param">adapt_param</code></td>
<td>
<p>a vector of 3 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) and it is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes.</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_corr_fun">corr_fun</code></td>
<td>
<p>characters, the name of the correlation function;
currently implemented functions are c(&quot;exponential&quot;, &quot;matern&quot;,&quot;gaussian&quot;)</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_kappa_matern">kappa_matern</code></td>
<td>
<p>numeric, the smoothness parameter of the Matern
correlation function, default is <code>kappa_matern = 0.5</code> (the exponential function)</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_n_chains">n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_parallel">parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td></tr>
<tr><td><code id="WrapSp_+3A_n_cores">n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a list of <code>n_chains</code> lists each with elements
</p>

<ul>
<li> <p><code>alpha</code>, <code>rho</code>,<code>sigma2</code> vectors with the thinned chains,
</p>
</li>
<li> <p><code>k</code> a matrix with <code>nrow = length(x)</code> and <code>ncol = </code> the length of thinned chains
</p>
</li>
<li> <p><code>corr_fun</code> characters with the type of spatial correlation chosen.
</p>
</li>
<li> <p><code>distribution</code> characters, always &quot;WrapSp&quot;
</p>
</li></ul>



<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around pi,
and the prior and starting value of alpha are changed accordingly.
After the estimations, posterior samples of alpha are changed
back to the original scale
</p>


<h3>References</h3>

<p>G. Jona Lasinio, A. Gelfand, M. Jona-Lasinio,
&quot;Spatial analysis of wave direction data using wrapped Gaussian processes&quot;,
The Annals of Applied Statistics 6 (2013), 1478-1498
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapKrigSp">WrapKrigSp</a></code> for spatial interpolation,
<code><a href="#topic+ProjSp">ProjSp</a></code> for posterior  sampling from the
Projected Normal model and <code><a href="#topic+ProjKrigSp">ProjKrigSp</a></code> for
spatial interpolation under the same model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(CircSpaceTime)
## auxiliary function
rmnorm&lt;-function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

####
# Simulation with exponential spatial covariance function
####
set.seed(1)
n &lt;- 20
coords &lt;- cbind(runif(n,0,100), runif(n,0,100))
Dist &lt;- as.matrix(dist(coords))

rho     &lt;- 0.05
sigma2  &lt;- 0.3
alpha   &lt;- c(0.5)
SIGMA   &lt;- sigma2*exp(-rho*Dist)

Y &lt;- rmnorm(1,rep(alpha,times=n), SIGMA)
theta &lt;- c()
for(i in 1:n) {
  theta[i] &lt;- Y[i]%%(2*pi)
}
rose_diag(theta)

#validation set
val &lt;- sample(1:n,round(n*0.1))

set.seed(12345)
mod &lt;- WrapSp(
  x       = theta[-val],
  coords    = coords[-val,],
  start   = list("alpha"      = c(.36,0.38),
                 "rho"     = c(0.041,0.052),
                 "sigma2"    = c(0.24,0.32),
                 "k"       = rep(0,(n - length(val)))),
  priors   = list("rho"      = c(0.04,0.08), #few observations require to be more informative
                  "sigma2"    = c(2,1),
                  "alpha" =  c(0,10)
  ),
  sd_prop   = list( "sigma2" = 0.1,  "rho" = 0.1),
  iter    = 1000,
  BurninThin    = c(burnin = 500, thin = 5),
  accept_ratio = 0.234,
  adapt_param = c(start = 40000, end = 45000, exp = 0.5),
  corr_fun = "exponential",
  kappa_matern = .5,
  parallel = FALSE,
  #With doParallel, bigger iter (normally around 1e6) and n_cores&gt;=2 it is a lot faster
  n_chains = 2 ,
  n_cores = 1
)
check &lt;- ConvCheck(mod)
check$Rhat ## close to 1 means convergence has been reached
## graphical check
par(mfrow = c(3,1))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))
##### We move to the spatial interpolation see WrapKrigSp
</code></pre>

<hr>
<h2 id='WrapSpTi'>Samples from the posterior distribution of the Wrapped Normal spatial temporal model</h2><span id='topic+WrapSpTi'></span>

<h3>Description</h3>

<p>The <code>WrapSpTi</code> function returns samples from the posterior distribution of the spatio-temporal Wrapped Gaussian Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WrapSpTi(x = x, coords = coords, times, start = list(alpha = c(2, 1),
  rho_sp = c(0.1, 0.5), rho_t = c(0.1, 1), sep_par = c(0.01, 0.1), k =
  sample(0, length(x), replace = T)), priors = list(alpha = c(pi, 1, -10,
  10), rho_sp = c(8, 14), rho_t = c(1, 2), sep_par = c(0.001, 1), sigma2 =
  c()), sd_prop = list(rho_sp = 0.5, rho_t = 0.5, sep_par = 0.5, sigma2 =
  0.5), iter = 1000, BurninThin = c(burnin = 20, thin = 10),
  accept_ratio = 0.234, adapt_param = c(start = 1, end = 1e+07, exp =
  0.9), n_chains = 1, parallel = FALSE, n_cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WrapSpTi_+3A_x">x</code></td>
<td>
<p>a vector of n circular data in <code class="reqn">[0,2\pi)</code>.
If they are not in <code class="reqn">[0,2\pi)</code>, the function will transform
the data into the right interval</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_coords">coords</code></td>
<td>
<p>an nx2 matrix with the sites coordinates</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_times">times</code></td>
<td>
<p>an n vector with the times of the observations x</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_start">start</code></td>
<td>
<p>a list of 4 elements giving initial values for the model parameters. Each elements is a vector with <code>n_chains</code> elements
</p>

<ul>
<li><p>     alpha the mean which value is in <code class="reqn">[0,2\pi)</code>
</p>
</li>
<li><p>  rho_sp the spatial decay parameter,
</p>
</li>
<li><p>  rho_t the temporal decay parameter,
</p>
</li>
<li><p>  sigma2 the process variance,
</p>
</li>
<li><p>  sep_par the separation parameter,
</p>
</li>
<li><p>  k the vector of <code>length(x)</code>  winding numbers
</p>
</li></ul>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_priors">priors</code></td>
<td>
<p>a list of 5 elements to define priors  for the model parameters:
</p>

<dl>
<dt>alpha</dt><dd><p>a vector of 2 elements the mean and the variance of  a Gaussian distribution, default is  mean <code class="reqn">\pi</code> and variance 1,</p>
</dd>
<dt>rho_sp</dt><dd><p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>rho_t</dt><dd><p>a vector of 2 elements defining the minimum and maximum of a uniform distribution,</p>
</dd>
<dt>sep_par</dt><dd><p>a vector of 2 elements defining the two parameters of a beta distribution,</p>
</dd>
<dt>sigma2</dt><dd><p>a vector of 2 elements defining the shape and rate of an inverse-gamma distribution,</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_sd_prop">sd_prop</code></td>
<td>
<p>list of 3 elements. To run the MCMC for the rho_sp and sigma2 parameters we use an adaptive metropolis and in sd_prop we build a list of initial guesses for these two parameters and the beta parameter</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_iter">iter</code></td>
<td>
<p>iter number of iterations</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_burninthin">BurninThin</code></td>
<td>
<p>a vector of 2 elements with  the burnin and the chain thinning</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_accept_ratio">accept_ratio</code></td>
<td>
<p>it is the desired acceptance ratio in the adaptive metropolis</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_adapt_param">adapt_param</code></td>
<td>
<p>a vector of 3 elements giving the iteration number at which the adaptation must start  and end. The third element (exp)  must be a number in (0,1) and it is a parameter ruling the speed of changes in the adaptation algorithm, it is recommended to set it close to 1, if it is too small  non positive definite matrices may be generated and the program crashes.</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_n_chains">n_chains</code></td>
<td>
<p>integer, the number of chains to be launched (default is 1, but we recommend to use at least 2 for model diagnostic)</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_parallel">parallel</code></td>
<td>
<p>logical, if the multiple chains  must be lunched in parallel
(you should install doParallel package). Default is FALSE</p>
</td></tr>
<tr><td><code id="WrapSpTi_+3A_n_cores">n_cores</code></td>
<td>
<p>integer, required if parallel=TRUE, the number of cores
to be used in the implementation. Default value is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it returns a list of <code>n_chains</code> lists each with elements
</p>

<dl>
<dt><code>alpha</code>, <code>rho_sp</code>, <code>rho_t</code>, <code>sep_par</code>, <code>sigma2</code></dt><dd><p>vectors with the thinned chains</p>
</dd>
<dt><code>k</code></dt><dd><p>a matrix with <code>nrow = length(x)</code> and <code>ncol = </code> the length of thinned chains</p>
</dd>
<dt><code>distribution</code></dt><dd><p>characters, always &quot;WrapSpTi&quot; </p>
</dd>
</dl>



<h3>Implementation Tips</h3>

<p>To facilitate the estimations, the observations x
are centered around pi,
and the prior and starting value of alpha are changed accordingly.
After the estimations, posterior samples of alpha are changed
back to the original scale
</p>


<h3>References</h3>

<p>G. Mastrantonio, G. Jona Lasinio,
A. E. Gelfand, &quot;Spatio-temporal circular models with
non-separable covariance structure&quot;, TEST 25 (2016), 331–350.
</p>
<p>T. Gneiting,  &quot;Nonseparable, Stationary Covariance Functions for Space-Time
Data&quot;, JASA 97 (2002), 590-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WrapKrigSpTi">WrapKrigSpTi</a></code> for spatio-temporal prediction,
<code><a href="#topic+ProjSpTi">ProjSpTi</a></code> to sample from the posterior distribution of the spatio-temporal
Projected Normal model and <code><a href="#topic+ProjKrigSpTi">ProjKrigSpTi</a></code> for spatio-temporal prediction under the same model
</p>
<p>Other spatio-temporal models: <code><a href="#topic+ProjSpTi">ProjSpTi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CircSpaceTime)
## functions
rmnorm &lt;- function(n = 1, mean = rep(0, d), varcov){
  d &lt;- if (is.matrix(varcov))
    ncol(varcov)
  else 1
  z &lt;- matrix(rnorm(n * d), n, d) %*% chol(varcov)
  y &lt;- t(mean + t(z))
  return(y)
}

######################################
## Simulation                       ##
######################################
set.seed(1)
n &lt;- 20
### simulate coordinates from a unifrom distribution
coords  &lt;- cbind(runif(n,0,100), runif(n,0,100)) #spatial coordinates
coordsT &lt;- sort(runif(n,0,100)) #time coordinates (ordered)
Dist &lt;- as.matrix(dist(coords))
DistT &lt;- as.matrix(dist(coordsT))

rho     &lt;- 0.05 #spatial decay
rhoT    &lt;- 0.01 #temporal decay
sep_par &lt;- 0.5 #separability parameter
sigma2  &lt;- 0.3 # variance of the process
alpha   &lt;- c(0.5)
#Gneiting covariance
SIGMA &lt;- sigma2 * (rhoT * DistT^2 + 1)^(-1) * exp(-rho * Dist/(rhoT * DistT^2 + 1)^(sep_par/2))

Y &lt;- rmnorm(1,rep(alpha, times = n), SIGMA) #generate the linear variable
theta &lt;- c()
## wrapping step
for(i in 1:n) {
  theta[i] &lt;- Y[i] %% (2*pi)
}
### Add plots of the simulated data

rose_diag(theta)
## use this values as references for the definition of initial values and priors
rho_sp.min &lt;- 3/max(Dist)
rho_sp.max &lt;- rho_sp.min+0.5
rho_t.min  &lt;- 3/max(DistT)
rho_t.max  &lt;- rho_t.min+0.5
val &lt;- sample(1:n,round(n*0.2)) #validation set
set.seed(100)
mod &lt;- WrapSpTi(
  x       = theta[-val],
  coords    = coords[-val,],
  times    = coordsT[-val],
  start   = list("alpha"      = c(.79, .74),
                 "rho_sp"     = c(.33,.52),
                 "rho_t"     = c(.19, .43),
                 "sigma2"    = c(.49, .37),
                 "sep_par"  = c(.47, .56),
                 "k"       = sample(0,length(theta[-val]), replace = TRUE)),
  priors   = list("rho_sp"      = c(0.01,3/4), ### uniform prior on this interval
                  "rho_t"      = c(0.01,3/4), ### uniform prior on this interval
                  "sep_par"  = c(1,1), ### beta prior
                  "sigma2"    = c(5,5),## inverse gamma prior with mode=5/6
                  "alpha" =  c(0,20) ## wrapped gaussian with large variance
  )  ,
  sd_prop   = list( "sigma2" = 0.1,  "rho_sp" = 0.1,  "rho_t" = 0.1,"sep_par"= 0.1),
  iter    = 7000,
  BurninThin    = c(burnin = 3000, thin = 10),
  accept_ratio = 0.234,
  adapt_param = c(start = 1, end = 1000, exp = 0.5),
  n_chains = 2 ,
  parallel = FALSE,
  n_cores = 1
)
check &lt;- ConvCheck(mod,startit = 1 ,thin = 1)
check$Rhat ## convergence has been reached
## when plotting chains remember that alpha is a circular variable
par(mfrow = c(3,2))
coda::traceplot(check$mcmc)
par(mfrow = c(1,1))

#### move to the prediction step with WrapKrigSpTi
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
