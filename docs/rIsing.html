<!DOCTYPE html><html><head><title>Help for package rIsing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rIsing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rIsing'><p>rIsing: High-Dimensional Ising Model Selection.</p></a></li>
<li><a href='#ising'><p>High-Dimensional Ising Model Selection</p></a></li>
<li><a href='#logreg'><p>L1 Regularized Logistic Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Ising Model Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits an Ising model to a binary dataset using L1 regularized
    logistic regression and extended BIC. Also includes a fast lasso logistic
    regression function for high-dimensional problems. Uses the 'libLBFGS'
    optimization library by Naoaki Okazaki.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8), data.table (&ge; 1.9.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, IsingSampler</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.2.9)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-11-24 15:30:45 UTC; prati</td>
</tr>
<tr>
<td>Author:</td>
<td>Pratik Ramprasad [aut, cre],
  Jorge Nocedal [ctb, cph],
  Naoaki Okazaki [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pratik Ramprasad &lt;pratik.ramprasad@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-11-25 08:43:07</td>
</tr>
</table>
<hr>
<h2 id='rIsing'>rIsing: High-Dimensional Ising Model Selection.</h2><span id='topic+rIsing'></span><span id='topic+rIsing-package'></span>

<h3>Description</h3>

<p>Fits an Ising model to a binary dataset using L1-regularized logistic regression and BIC.
Also includes a fast lasso logistic regression function for high-dimensional problems. Uses the
'libLBFGS' optimization library by Naoki Okazaki.
</p>


<h3>rIsing functions</h3>


<ul>
<li> <p><code>logreg</code>: L1-regularized logistic regression using OWL-QN L-BFGS-B optimization.
</p>
</li>
<li> <p><code>Ising</code>: Ising Model selection using L1-regularized logistic regression and extended BIC.
</p>
</li></ul>


<hr>
<h2 id='ising'>High-Dimensional Ising Model Selection</h2><span id='topic+ising'></span>

<h3>Description</h3>

<p>Ising Model selection using L1-regularized logistic regression and extended BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ising(X, gamma = 0.5, min_sd = 0, nlambda = 50,
  lambda.min.ratio = 0.001, symmetrize = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ising_+3A_x">X</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code id="ising_+3A_gamma">gamma</code></td>
<td>
<p>(non-negative double) Parameter for the extended BIC (default 0.5). Higher gamma encourages sparsity. See references for more details.</p>
</td></tr>
<tr><td><code id="ising_+3A_min_sd">min_sd</code></td>
<td>
<p>(non-negative double) Columns of <code>X</code> with standard deviation less than this value will be excluded from the graph.</p>
</td></tr>
<tr><td><code id="ising_+3A_nlambda">nlambda</code></td>
<td>
<p>(positive integer) The number of parameters in the regularization path (default 50). A longer regularization path will likely yield more accurate results, but will take more time to run.</p>
</td></tr>
<tr><td><code id="ising_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>(non-negative double) The ratio <code>min(lambda) / max(lambda)</code> (default <code>1e-3</code>).</p>
</td></tr>
<tr><td><code id="ising_+3A_symmetrize">symmetrize</code></td>
<td>
<p>The method used to symmetrize the output adjacency matrix. Must be one of &quot;min&quot;, &quot;max&quot;, &quot;mean&quot; (default), or FALSE. &quot;min&quot; and &quot;max&quot; correspond to the Wainwright min/max, respectively
(see reference 1). &quot;mean&quot; corresponds to the coefficient-wise mean of the output adjacency matrix and its transpose. If FALSE, the output matrix is not symmetrized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated adjacency matrix (<code>Theta</code>) and the optimal regularization parameter for each node (<code>lambda</code>), as selected by extended BIC.
</p>


<h3>References</h3>


<ol>
<li><p> Ravikumar, P., Wainwright, M. J. and Lafferty, J. D. (2010). High-dimensional Ising model selection using L1-regularized logistic regression. https://arxiv.org/pdf/1010.0311v1
</p>
</li>
<li><p> Barber, R.F., Drton, M. (2015). High-dimensional Ising model selection with Bayesian information criteria. https://arxiv.org/pdf/1403.3374v2
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# simulate a dataset using IsingSampler
library(IsingSampler)
n = 1e3
p = 10
Theta &lt;- matrix(sample(c(-0.5,0,0.5), replace = TRUE, size = p*p), nrow = p, ncol = p)
Theta &lt;- Theta + t(Theta) # adjacency matrix must be symmetric
diag(Theta) &lt;- 0
X &lt;- unname(as.matrix(IsingSampler(n, graph = Theta, thresholds = 0, method = "direct") ))
m1 &lt;- ising(X, symmetrize = "mean", gamma = 0.5, nlambda = 50)

# Visualize output using igraph
library(igraph)
ig &lt;- graph_from_adjacency_matrix(m1$Theta, "undirected", weighted = TRUE, diag = FALSE)
plot.igraph(ig, vertex.color = "skyblue")

## End(Not run)
</code></pre>

<hr>
<h2 id='logreg'>L1 Regularized Logistic Regression</h2><span id='topic+logreg'></span>

<h3>Description</h3>

<p>L1 Regularized logistic regression using OWL-QN L-BFGS-B optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logreg(X, y, nlambda = 50, lambda.min.ratio = 0.001, lambda = NULL,
  scale = TRUE, type = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logreg_+3A_x">X</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code id="logreg_+3A_y">y</code></td>
<td>
<p>Vector of binary observations of length equal to <code>nrow(X)</code>.</p>
</td></tr>
<tr><td><code id="logreg_+3A_nlambda">nlambda</code></td>
<td>
<p>(positive integer) The number of parameters in the regularization path (default 50).</p>
</td></tr>
<tr><td><code id="logreg_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>(non-negative double) The ratio of <code>max(lambda) / min(lambda)</code> (default <code>1e-3</code>).</p>
</td></tr>
<tr><td><code id="logreg_+3A_lambda">lambda</code></td>
<td>
<p>A user-supplied vector of regularization parameters. Under the default option (<code>NULL</code>), the function computes a regularization path using the input data.</p>
</td></tr>
<tr><td><code id="logreg_+3A_scale">scale</code></td>
<td>
<p>(boolean) Whether to scale <code>X</code> before running the regression. The output parameters will always be rescaled. Use <code>FALSE</code> if <code>X</code> is already scaled.</p>
</td></tr>
<tr><td><code id="logreg_+3A_type">type</code></td>
<td>
<p>(integer 1 or 2) Type 1 aggregates the input data based on repeated rows in <code>X</code>. Type 2 (default) uses the data as is, and is generally faster. Use Type 1 if the data contains several repeated rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the matrix of fitted weights (<code>wmat</code>), the vector of regularization parameters, sorted in decreasing order (<code>lambda</code>), and the vector of log-likelihoods corresponding to <code>lambda</code> (<code>logliks</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate some linear regression data
n &lt;- 1e3
p &lt;- 100
X &lt;- matrix(rnorm(n*p),n,p)
wt &lt;- sample(seq(0,9),p+1,replace = TRUE) / 10
z &lt;- cbind(1,X) %*% wt + rnorm(n)
probs &lt;- 1 / (1 + exp(-z))
y &lt;- sapply(probs, function(p) rbinom(1,1,p))

m1 &lt;- logreg(X, y)
m2 &lt;- logreg(X, y, nlambda = 100, lambda.min.ratio = 1e-4, type = 1)

## Not run: 
# Performance comparison
library(glmnet)
library(microbenchmark)
nlambda = 50; lambda.min.ratio = 1e-3
microbenchmark(
  logreg_type1 = logreg(X, y, nlambda = nlambda,
                         lambda.min.ratio = lambda.min.ratio, type = 1),
  logreg_type2 = logreg(X, y, nlambda = nlambda,
                         lambda.min.ratio = lambda.min.ratio, type = 2),
  glmnet       = glmnet(X, y, family = "binomial",
                         nlambda = nlambda, lambda.min.ratio = lambda.min.ratio),
  times = 20L
)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
