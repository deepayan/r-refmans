<!DOCTYPE html><html><head><title>Help for package ergm.ego</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergm.ego}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2A.svystat'><p>A scalar multiplication method for <code>svystat</code></p></a></li>
<li><a href='#as.egor.egodata'><p>Convert (deprecated) <code>egodata</code> Objects to</p>
<code>egor</code> Objects</a></li>
<li><a href='#as.egor.network'><p>Construct an Egocentric View of a <code>network</code> Object</p></a></li>
<li><a href='#control.ergm.ego'><p>Control parameters for <code>ergm.ego</code>.</p></a></li>
<li><a href='#control.simulate.ergm.ego'><p>Control parameters for <code>simulate.ergm.ego</code>.</p></a></li>
<li><a href='#degreedist.egor'><p>Plotting the degree distribution of an egocentric dataset</p></a></li>
<li><a href='#EgoStat-internal'><p>Helper functions of EgoStats. Some may be documented and exported in the future.</p></a></li>
<li><a href='#ergm.ego'><p>Inference for Exponential-Family Random Graph Models based on Egocentrically</p>
Sampled Data</a></li>
<li><a href='#ergm.ego-terms'><p><code>ergm</code> Terms Implemented for</p>
<code>egor</code></a></li>
<li><a href='#fmhfit'><p>Fitted ergm.ego model object</p></a></li>
<li><a href='#gof.ergm.ego'><p>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph</p>
Model fit to Egocentrically Sampled Data</a></li>
<li><a href='#mixingmatrix.egor'><p>Summarizing the mixing among groups in an egocentric dataset</p></a></li>
<li><a href='#nodal_attributes-API'><p>Helper functions for specifying nodal attribute levels</p></a></li>
<li><a href='#predict.ergm.ego'><p>ERGM-based predicted tie probabilities for the pseudo-population network</p></a></li>
<li><a href='#sample'><p>Draw random egocentric subsamples</p></a></li>
<li><a href='#simulate.ergm.ego'><p>Simulate from a <code>ergm.ego</code> fit.</p></a></li>
<li><a href='#snctrl'><p>Statnet Control</p></a></li>
<li><a href='#summary_formula.egor'><p>Calculation of ERGM-style summary statistics for <code>egor</code></p>
objects.</a></li>
<li><a href='#template_network'><p>Construct an Empty &ldquo;Template&rdquo; Network Consistent with an Egocentric Sample</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit, Simulate and Diagnose Exponential-Family Random Graph
Models to Egocentrically Sampled Network Data</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), ergm (&ge; 4.5.0), egor, network (&ge; 1.17.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ergm</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common (&ge; 4.5.0), RColorBrewer (&ge; 1.1.2), purrr (&ge;
0.3.2), tibble (&ge; 2.1.1), dplyr, survey, stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.1), covr (&ge; 3.2.1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities for managing egocentrically sampled network data and a wrapper around the 'ergm' package to facilitate ERGM inference and simulation from such data. See Krivitsky and Morris (2017) &lt;<a href="https://doi.org/10.1214%2F16-AOAS1010">doi:10.1214/16-AOAS1010</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/ergm.ego/issues">https://github.com/statnet/ergm.ego/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-30 13:32:13 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Steven M. Goodreau [ctb],
  Martina Morris [ctb],
  Kirk Li [ctb],
  Emily N. Beylerian [ctb],
  Micha≈Ç Bojanowski <a href="https://orcid.org/0000-0001-7503-852X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Chad Klumb [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-30 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A.svystat'>A scalar multiplication method for <code>svystat</code></h2><span id='topic++2A.svystat'></span>

<h3>Description</h3>

<p>Multiply the values of survey statistics by a specified vector elementwise, adjusting the variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svystat'
x * y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.svystat_+3A_x">x</code></td>
<td>
<p>an object of class <code style="white-space: pre;">&#8288;[svystat][survey::svymean]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="+2B2A.svystat_+3A_y">y</code></td>
<td>
<p>a numeric vector equal in length to <code>x</code>; shorter vectors will be recycled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code style="white-space: pre;">&#8288;[svystat][survey::svymean]&#8288;</code> object with the updated statistics and variance-covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)
# From example(svymean):
dclus1&lt;-svydesign(id=~dnum, weights=~pw, data=apiclus1, fpc=~fpc)

(m1 &lt;- svymean(~api99, dclus1))
(v1 &lt;- vcov(m1))

# Scale the suvery stat object by a factor of two:
(m2 &lt;- m1 * 2)
(v2 &lt;- vcov(m2))


</code></pre>

<hr>
<h2 id='as.egor.egodata'>Convert (deprecated) <code><a href="#topic+egodata">egodata</a></code> Objects to
<code><a href="egor.html#topic+egor">egor</a></code> Objects</h2><span id='topic+as.egor.egodata'></span><span id='topic+egodata'></span><span id='topic+as_egor.egodata'></span>

<h3>Description</h3>

<p>Convert (deprecated) <code><a href="#topic+egodata">egodata</a></code> Objects to
<code><a href="egor.html#topic+egor">egor</a></code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egodata'
as.egor(x, ...)

as_egor.egodata(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.egor.egodata_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+egodata">egodata</a></code> object</p>
</td></tr>
<tr><td><code id="as.egor.egodata_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="egor.html#topic+egor">egor</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>

<hr>
<h2 id='as.egor.network'>Construct an Egocentric View of a <code><a href="network.html#topic+network">network</a></code> Object</h2><span id='topic+as.egor.network'></span>

<h3>Description</h3>

<p>Given a <code><a href="network.html#topic+network">network</a></code> object, construct an
<code><a href="egor.html#topic+egor">egor</a></code> object representing a census of all the actors in the
network. Used mainly for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
as.egor(x, special.cols = c("na"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.egor.network_+3A_x">x</code></td>
<td>
<p>A <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="as.egor.network_+3A_special.cols">special.cols</code></td>
<td>
<p>Vertex attributes that should not be copied to the
<code>egos</code> and <code>alters</code> tables. Defaults to attributes special to the
<code><a href="network.html#topic+network">network</a></code> objects.</p>
</td></tr>
<tr><td><code id="as.egor.network_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="egor.html#topic+egor">egor</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+template_network">template_network</a></code>, which performs the inverse
operation (though drops the ties).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See example(ergm.ego) and example(template_network).
</code></pre>

<hr>
<h2 id='control.ergm.ego'>Control parameters for <code><a href="#topic+ergm.ego">ergm.ego</a></code>.</h2><span id='topic+control.ergm.ego'></span>

<h3>Description</h3>

<p>Constructs and checks the list of control parameters for estimation by
<code><a href="#topic+ergm.ego">ergm.ego</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.ergm.ego(
  ppopsize = c("auto", "samp", "pop"),
  ppopsize.mul = 1,
  ppop.wt = c("round", "sample"),
  stats.wt = c("data", "ppop"),
  stats.est = c("survey", "asymptotic", "bootstrap", "jackknife", "naive"),
  boot.R = 10000,
  ignore.max.alters = TRUE,
  ergm = control.ergm(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.ergm.ego_+3A_ppopsize">ppopsize</code>, <code id="control.ergm.ego_+3A_ppopsize.mul">ppopsize.mul</code></td>
<td>
<p>Parameters to determine the size
<code class="reqn">|N'|</code> of the pseudopopulation network. <code>ppopsize</code> can be
</p>

<dl>
<dt>&quot;auto&quot;</dt><dd><p>If the <code>popsize</code> (<code class="reqn">|N|</code>) argument is
specified and is different from 1, as if <code>"pop"</code>; otherwise,
as <code>"samp"</code>.</p>
</dd>
<dt>&quot;samp&quot;</dt><dd><p>set <code class="reqn">|N'|</code> based on the sample size:
<code class="reqn">|N'|=|S| \times \code{popsize.mul}</code></p>
</dd>
<dt>&quot;pop&quot;</dt><dd><p>set <code class="reqn">|N'|</code> based on the population size:
<code class="reqn">|N'|=|N| \times \code{popsize.mul}</code></p>
</dd>
<dt>a number</dt><dd><p>set <code class="reqn">|N'|</code> directly (<code>popsize.mul</code>
ignored)</p>
</dd>
<dt>a <code><a href="network.html#topic+network">network</a></code> object</dt><dd><p>use the specified network as the
pseudo-population network directly; use at your own risk</p>
</dd>
<dt>a data frame</dt><dd><p>use the specified data frame as the
pseudo-population; use at your own risk</p>
</dd></dl>

<p>The default is to use the same pseudopopulation size as the sample size,
but, particularly if there are sampling weights in the data, it should be
bigger.
</p>
<p>Note that depending on <code>ppop.wt</code>, this may only be an approximate
target specification, with the actual constructed pseudopopulation network
being slightly bigger or smaller.</p>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_ppop.wt">ppop.wt</code></td>
<td>
<p>Because each ego must be represented in the pseuodopopulation
network an integral number of times, if the sample is weighted (or the
target <code class="reqn">|N'|</code> calculated from <code>ppopsize</code> and <code>ppopsize.mul</code> is
not a multiple of the sample size), it may not be possible, for a finite
<code class="reqn">|N'|</code> to represent each ego exactly according to its relative weight,
and <code>ppop.wt</code> controls how the fractional egos are allocated:
</p>
 <dl>
<dt>&quot;round&quot;</dt><dd><p>(default) Rather than treating <code>ppopsize</code> as
a hard setting, calculate <code class="reqn">|N'| w_i / w_\cdot</code> for each ego <code class="reqn">i</code> and
round it to the nearest integer. Then, the <code class="reqn">|N'|</code> actually used will be
the sum of these rounded freqencies.</p>
</dd>
<dt>&quot;sample&quot;</dt><dd><p>Resample in proportion to <code class="reqn">w_i</code>.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_stats.wt">stats.wt</code></td>
<td>
<p>Weight assigned to each ego's contribution to the ERGM's
sufficient statistic: </p>
 <dl>
<dt>&quot;data&quot;</dt><dd><p>(default) Use weights
<code class="reqn">|N'| w_i / w_\cdot</code> for each ego <code class="reqn">i</code> as in the data.</p>
</dd> <dt>&quot;ppop&quot;</dt><dd><p>Use weights ultimately used in the
pseudopopulation network.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_stats.est">stats.est</code>, <code id="control.ergm.ego_+3A_boot.r">boot.R</code></td>
<td>
<p>Method to be used to estimate the ERGM's sufficient
statistics and their variance: </p>

<dl>
<dt>&quot;survey&quot;</dt><dd><p>Variance estimator returned by <code><a href="survey.html#topic+surveysummary">survey::svymean()</a></code>, appropriate to the design of the dataset.</p>
</dd>
<dt>&quot;asymptotic&quot;</dt><dd><p>Delta method, as derived by Krivitsky and
Morris (2017), assuming the ego weights are sampled alongside the
egos.</p>
</dd><dt> (default)</dt><dd><p>Delta method, as derived by Krivitsky and Morris
(2017), assuming the ego weights are sampled alongside the egos.</p>
</dd>
<dt>&quot;bootstrap&quot;</dt><dd><p>Nonparametric bootstrap with bias correction,
resampling egos, using <code>R</code> replications.</p>
</dd>
<dt>&quot;jackknife&quot;</dt><dd><p>Jackknife with bias correction.</p>
</dd>
<dt>&quot;naive&quot;</dt><dd><p>&quot;Naive&quot; estimator, assuming that weights are
fixed.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_ignore.max.alters">ignore.max.alters</code></td>
<td>
<p>if <code>TRUE</code>, ignores any constraints on the
number of nominations. Used to be <code>FALSE</code>, now <code>TRUE</code> in light of
the findings of Krivitsky et. al (2020).</p>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_ergm">ergm</code></td>
<td>
<p>Control parameters for the <code><a href="ergm.html#topic+ergm">ergm</a>()</code> call
to fit the model, constructed by <code><a href="ergm.html#topic+control.ergm">control.ergm</a>()</code>.</p>
</td></tr>
<tr><td><code id="control.ergm.ego_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>

<p>Pavel N. Krivitsky and Martina Morris (2017). &quot;Inference for social network models from egocentrically sampled data, with application to understanding persistent racial disparities in HIV prevalence in the US.&quot; <em>Annals of Applied Statistics</em>, 11(1): 427‚Äì455. <a href="https://doi.org/10.1214/16-AOAS1010">doi:10.1214/16-AOAS1010</a>
</p>
<p>Pavel N. Krivitsky, Martina Morris, and Micha≈Ç Bojanowski (2019). &quot;Inference for Exponential-Family Random Graph Models from Egocentrically-Sampled Data with Alter‚ÄìAlter Relations.&quot; NIASRA Working Paper 08-19. <a href="https://www.uow.edu.au/niasra/publications/">https://www.uow.edu.au/niasra/publications/</a>
</p>
<p>Pavel N. Krivitsky, Micha≈Ç Bojanowski, and Martina Morris (2020). &quot;Impact of survey design on estimation of exponential-family random graph models from egocentrically-sampled data.&quot; <em>Social Networks</em>, to appear. <a href="https://doi.org/10.1016/j.socnet.2020.10.001">doi:10.1016/j.socnet.2020.10.001</a>
</p>
<p>Pavel N. Krivitsky, Mark S. Handcock, and Martina Morris (2011). &quot;Adjusting for
Network Size and Composition Effects in Exponential-Family Random Graph
Models.&quot; <em>Statistical Methodology</em>, 8(4): 319‚Äì339. <a href="https://doi.org/10.1016/j.stamet.2011.01.005">doi:10.1016/j.stamet.2011.01.005</a>
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+control.ergm">control.ergm</a>()</code>
</p>

<hr>
<h2 id='control.simulate.ergm.ego'>Control parameters for <code><a href="#topic+simulate.ergm.ego">simulate.ergm.ego</a></code>.</h2><span id='topic+control.simulate.ergm.ego'></span>

<h3>Description</h3>

<p>Constructs and checks the list of control parameters for simulation by
<code><a href="#topic+simulate.ergm.ego">simulate.ergm.ego</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.simulate.ergm.ego(
  ppop.wt = c("round", "sample"),
  SAN = control.san(),
  simulate = control.simulate(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.simulate.ergm.ego_+3A_ppop.wt">ppop.wt</code></td>
<td>
<p>Because each ego must be represented in the pseuodopopulation
network an integral number of times, if the sample is weighted (or the
target <code class="reqn">|N'|</code> calculated from <code>ppopsize</code> and <code>ppopsize.mul</code> is
not a multiple of the sample size), it may not be possible, for a finite
<code class="reqn">|N'|</code> to represent each ego exactly according to its relative weight,
and <code>ppop.wt</code> controls how the fractional egos are allocated:
</p>
 <dl>
<dt>&quot;round&quot;</dt><dd><p>(default) Rather than treating <code>ppopsize</code> as
a hard setting, calculate <code class="reqn">|N'| w_i / w_\cdot</code> for each ego <code class="reqn">i</code> and
round it to the nearest integer. Then, the <code class="reqn">|N'|</code> actually used will be
the sum of these rounded freqencies.</p>
</dd>
<dt>&quot;sample&quot;</dt><dd><p>Resample in proportion to <code class="reqn">w_i</code>.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="control.simulate.ergm.ego_+3A_san">SAN</code></td>
<td>
<p>A list of control parameters for <code><a href="ergm.html#topic+san">san</a></code>
constructed by <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code>, called to construct a
pseudopopulation network consistent with the data.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm.ego_+3A_simulate">simulate</code></td>
<td>
<p>A list of control parameters for
<code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code> constructed by
<code><a href="ergm.html#topic+control.simulate">control.simulate</a></code>, called to simulate from the model fit.</p>
</td></tr>
<tr><td><code id="control.simulate.ergm.ego_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p>control.simulate, control.san
</p>

<hr>
<h2 id='degreedist.egor'>Plotting the degree distribution of an egocentric dataset</h2><span id='topic+degreedist.egor'></span><span id='topic+degreedist'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+degreedist">degreedist()</a></code> method for <code><a href="#topic+egodata">egodata</a></code> objects: plot a histogram
of the degree distribution of actors in the egocentric dataset,
optionally broken down by group and/or compared with a Bernoulli
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egor'
degreedist(
  object,
  freq = FALSE,
  prob = !freq,
  by = NULL,
  brgmod = FALSE,
  main = NULL,
  plot = brgmod,
  weight = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreedist.egor_+3A_object">object</code></td>
<td>
<p>A <code><a href="egor.html#topic+egor">egor</a></code> object.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_freq">freq</code>, <code id="degreedist.egor_+3A_prob">prob</code></td>
<td>
<p>Whether to plot the raw frequencies or the conditional
proportions of the degree values. Defaults to the latter.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_by">by</code></td>
<td>
<p>A character vector giving the name of a vertex attribute; if
given, plots the frequences broken down by that attribute.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_brgmod">brgmod</code></td>
<td>
<p>Plot the range of predicted frequencies/probabilities
according to a Bernoulli graph having the same expected density as the
observed.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_plot">plot</code></td>
<td>
<p>Whether to plot the histogram; defaults to the same
value as<code>brgmod</code>, i.e., <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_weight">weight</code></td>
<td>
<p>Whether sampling weights should be incorporated into
the calculation (<code>TRUE</code>, the default) or ignored (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="degreedist.egor_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+simulate.ergm.ego">simulate.ergm.ego()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a vector of degree frequencies/proportions
if <code>by=NULL</code> or a matrix with a row for each category if not. If
<code>plot==TRUE</code> returns invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degreedist">degreedist</a></code>,
<code><a href="ergm.html#topic+summary_formula">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)

degreedist(fmh.ego,by="Grade",brgmod=TRUE)
# Compare:
degreedist(faux.mesa.high)

</code></pre>

<hr>
<h2 id='EgoStat-internal'>Helper functions of EgoStats. Some may be documented and exported in the future.</h2><span id='topic+EgoStat-internal'></span><span id='topic+.attrErr'></span><span id='topic+.unfactor'></span><span id='topic+.degreeseq'></span><span id='topic+.alterEgos'></span><span id='topic+.exsum'></span><span id='topic+.extabulate'></span><span id='topic+.matchNA'></span><span id='topic+.pasteNA'></span><span id='topic+.sapply_col'></span><span id='topic+.mapply_col'></span><span id='topic+split_egos_by_ego'></span><span id='topic+split_alters_by_ego'></span><span id='topic+split_aaties_by_ego'></span><span id='topic+.checkNA'></span>

<h3>Description</h3>

<p>Helper functions of EgoStats. Some may be documented and exported in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.attrErr(term, attrname, req = c("one", "both"))

.unfactor(x)

.degreeseq(egor)

.alterEgos(egor)

.exsum(x)

.extabulate(bin, nbins = max(1, bin, na.rm = TRUE))

.matchNA(x, table, nomatch = NA_integer_, incomparables = NULL)

.pasteNA(..., sep = " ", collapse = NULL)

.sapply_col(..., simplify = TRUE)

.mapply_col(..., SIMPLIFY = TRUE)

split_egos_by_ego(x, egor)

split_alters_by_ego(x, egor)

split_aaties_by_ego(x, egor)

.checkNA(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EgoStat-internal_+3A_x">x</code>, <code id="EgoStat-internal_+3A_bin">bin</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="EgoStat-internal_+3A_egor">egor</code></td>
<td>
<p>an <code><a href="egor.html#topic+egor">egor()</a></code> object.</p>
</td></tr>
<tr><td><code id="EgoStat-internal_+3A_...">...</code></td>
<td>
<p>Additional arguments to subroutines.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>.attrErr()</code>: Construct and throw an error message about ego or alter attributes being missing.
</p>
</li>
<li> <p><code>.unfactor()</code>: Convert a factor to its &quot;ordinary&quot; vector representation.
</p>
</li>
<li> <p><code>.degreeseq()</code>: Degree sequence of the egos.
</p>
</li>
<li> <p><code>.alterEgos()</code>: Ego index (i.e., row) associated with each alter.
</p>
</li>
<li> <p><code>.exsum()</code>: As <code><a href="base.html#topic+sum">sum()</a></code>, but &quot;extrapolating&quot; the <code>NA</code>s.
</p>
</li>
<li> <p><code>.extabulate()</code>: As <code><a href="base.html#topic+tabulate">tabulate()</a></code>, but &quot;extrapolating&quot; the <code>NA</code>s.
</p>
</li>
<li> <p><code>.matchNA()</code>: As <code><a href="base.html#topic+match">base::match()</a></code>, but <code>NA</code>s are passed through.
</p>
</li>
<li> <p><code>.pasteNA()</code>: As <code><a href="base.html#topic+paste">paste()</a></code>, but <code>NA</code>s are passed through rather than typeset.
</p>
</li>
<li> <p><code>.sapply_col()</code>: As <code><a href="base.html#topic+sapply">sapply()</a></code>, but if the function returns a vector, return those
vectors in rows, and if it returns a scalar, return a column
vector.
</p>
</li>
<li> <p><code>.mapply_col()</code>: As <code><a href="base.html#topic+mapply">mapply()</a></code>, but if the function returns a vector, return those
vectors in rows, and if it returns a scalar, return a column
vector.
</p>
</li>
<li> <p><code>split_egos_by_ego()</code>: Split an arbitrary vector or matrix by egos.
</p>
</li>
<li> <p><code>split_alters_by_ego()</code>: Split an arbitrary vector or matrix by egos.
</p>
</li>
<li> <p><code>split_aaties_by_ego()</code>: Split an arbitrary vector or matrix by egos.
</p>
</li>
<li> <p><code>.checkNA()</code>: Pass through the input if it does not contain mising values; otherwise stop with given error. Arguments after the first are passed through to <code><a href="base.html#topic+stop">stop()</a></code>.
</p>
</li></ul>

<hr>
<h2 id='ergm.ego'>Inference for Exponential-Family Random Graph Models based on Egocentrically
Sampled Data</h2><span id='topic+ergm.ego'></span>

<h3>Description</h3>

<p>A wrapper around the <code><a href="ergm.html#topic+ergm">ergm</a></code> to fit an ERGM to an
<code><a href="egor.html#topic+egor">egor</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.ego(
  formula,
  popsize = 1,
  offset.coef = NULL,
  constraints = ~.,
  ...,
  basis = eval_lhs.formula(formula),
  control = control.ergm.ego(),
  na.action = na.fail,
  na.rm = FALSE,
  do.fit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm.ego_+3A_formula">formula</code></td>
<td>
<p>An <code><a href="stats.html#topic+formula">formula</a></code> object, of the form <code>e
  ~ &lt;model terms&gt;</code>, where <code>e</code> is a <code><a href="egor.html#topic+egor">egor</a></code>
object. See <code><a href="ergm.html#topic+ergm">ergm</a></code> for details and examples.
</p>
<p>For a list of currently implemented egocentric terms for the RHS, see
<code><a href="#topic+ergm.ego-terms">ergm.ego-terms</a></code>.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_popsize">popsize</code></td>
<td>
<p>The size <code class="reqn">|N|</code> of the finite population network
from which the egocentric sample was taken; only affects the
shift in the coefficients of the terms modeling the overall
propensity to have ties.  Setting it to 1 (the default)
essentially uses the <code class="reqn">-\log |N'|</code> offset on the edges
term. Passing 0 disables network size adjustment and uses the
egocentric sample size; passing <code><a href="base.html#topic+I">I(N)</a></code> uses the specified
size <code>N</code> (though can be overridden by the <code>ppop</code>
<code><a href="#topic+control.ergm.ego">control.ergm.ego()</a></code> option) and disables network size
adjustment.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_offset.coef">offset.coef</code></td>
<td>
<p>A vector of coefficients for the offset terms.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_constraints">constraints</code></td>
<td>
<p>A one-sided formula <code><a href="stats.html#topic+formula">formula</a></code> giving
the sample space constraints. See <code><a href="ergm.html#topic+ergm">ergm</a></code> for
details and examples.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_basis">basis</code></td>
<td>
<p>a value (usually an <code><a href="egor.html#topic+egor">egor</a></code>) to override the LHS of the formula.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_control">control</code></td>
<td>
<p>A <code><a href="#topic+control.ergm.ego">control.ergm.ego</a></code> control list.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_na.action">na.action</code></td>
<td>
<p>How to handle missing actor attributes in egos or alters,
when the terms need them for  models that scale.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_na.rm">na.rm</code></td>
<td>
<p>How to handle missing actor attributes in egos or alters,
when the terms need them for models that do not scale.</p>
</td></tr>
<tr><td><code id="ergm.ego_+3A_do.fit">do.fit</code></td>
<td>
<p>Whether to actually call <code><a href="ergm.html#topic+ergm">ergm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ergm.ego</code> inheriting from
<code><a href="ergm.html#topic+ergm">ergm</a></code>, with the following additional or overridden
elements:
</p>
<table>
<tr><td><code>"v"</code></td>
<td>
<p>Variance-covariance matrix of the estimate of the
sufficient statistics</p>
</td></tr>
<tr><td><code>"m"</code></td>
<td>
<p>Estimate of the sufficient
statistics</p>
</td></tr>
<tr><td><code>"egor"</code></td>
<td>
<p>The <code><a href="egor.html#topic+egor">egor</a></code> object passed</p>
</td></tr>
<tr><td><code>"popsize"</code></td>
<td>
<p>Population network size used</p>
</td></tr>
<tr><td><code>"ppopsize"</code></td>
<td>
<p>Pseudopopulation size used, see <code><a href="#topic+control.ergm.ego">control.ergm.ego</a></code></p>
</td></tr>
<tr><td><code>"coef"</code></td>
<td>
<p>The
coefficients, along with the network size adjustment <code>netsize.adj</code>
coefficient.</p>
</td></tr>
<tr><td><code>"covar"</code></td>
<td>
<p>Pseudo-MLE estimate of the
variance-covariance matrix of the parameter estimates under repeated
egocentric sampling</p>
</td></tr>
<tr><td><code>"ergm.covar"</code></td>
<td>
<p> The variance-covariance matrix of
parameter estimates under the ERGM superpopulation process (without
incorporating sampling).  </p>
</td></tr>
<tr><td><code>"DtDe"</code></td>
<td>
<p>Estimated Jacobian of the expectation of the sufficient
statistics with respect to the model parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>

<p>Pavel N. Krivitsky and Martina Morris (2017). &quot;Inference for social network models from egocentrically sampled data, with application to understanding persistent racial disparities in HIV prevalence in the US.&quot; <em>Annals of Applied Statistics</em>, 11(1): 427‚Äì455. <a href="https://doi.org/10.1214/16-AOAS1010">doi:10.1214/16-AOAS1010</a>
</p>
<p>Pavel N. Krivitsky, Martina Morris, and Micha≈Ç Bojanowski (2019). &quot;Inference for Exponential-Family Random Graph Models from Egocentrically-Sampled Data with Alter‚ÄìAlter Relations.&quot; NIASRA Working Paper 08-19. <a href="https://www.uow.edu.au/niasra/publications/">https://www.uow.edu.au/niasra/publications/</a>
</p>
<p>Pavel N. Krivitsky, Micha≈Ç Bojanowski, and Martina Morris (2020). &quot;Impact of survey design on estimation of exponential-family random graph models from egocentrically-sampled data.&quot; <em>Social Networks</em>, to appear. <a href="https://doi.org/10.1016/j.socnet.2020.10.001">doi:10.1016/j.socnet.2020.10.001</a>
</p>
<p>Pavel N. Krivitsky, Mark S. Handcock, and Martina Morris (2011). &quot;Adjusting for
Network Size and Composition Effects in Exponential-Family Random Graph
Models.&quot; <em>Statistical Methodology</em>, 8(4): 319‚Äì339. <a href="https://doi.org/10.1016/j.stamet.2011.01.005">doi:10.1016/j.stamet.2011.01.005</a>
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergm">ergm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)

head(fmh.ego)

egofit &lt;- ergm.ego(fmh.ego~edges+degree(0:3)+nodefactor("Race")+nodematch("Race")
                         +nodefactor("Sex")+nodematch("Sex")+absdiff("Grade")+gwesp(0,fix=TRUE), 
                          popsize=network.size(faux.mesa.high))

# Run convergence diagnostics
mcmc.diagnostics(egofit)

# Estimates and standard errors
summary(egofit)


</code></pre>

<hr>
<h2 id='ergm.ego-terms'><code><a href="ergm.html#topic+ergm">ergm</a></code> Terms Implemented for
<code><a href="egor.html#topic+egor">egor</a></code></h2><span id='topic+ergm.ego-terms'></span><span id='topic+terms-ergm.ego'></span><span id='topic+ergm.ego.terms'></span><span id='topic+terms.ergm.ego'></span><span id='topic+ergm-terms'></span><span id='topic+ergm.terms'></span><span id='topic+terms-ergm'></span><span id='topic+terms.ergm'></span><span id='topic+EgoStat'></span>

<h3>Description</h3>

<p>This page describes the <code><a href="ergm.html#topic+ergm">ergm</a></code> terms (and hence network
statistics) for which inference based on egocentrically sampled data is
implemented in <code>ergm.ego</code> package. Other packages may add their own
terms. These functions should not be called by the end-user.
</p>


<h3>Details</h3>

<p>The current recommendation for any package implementing additional
egocentric calculator terms is to create a help file with a name or alias
<code>ergm.ego-terms</code>, so that <code>help("ergm.ego-terms")</code> will
list egocentric ERGM terms available from all loaded packages.
</p>


<h3>Currently implemented egocentric statistics</h3>

<p>For each of these,
please see their respective package's <code>ergm-terms</code> help for meaning and
parameters. The simplest way to do this is usually via <code>? TERM</code>.
</p>
 <dl>
<dt>Special-purpose terms:</dt><dd> 
<dl>
<dt>netsize.adj(edges=+1, mutual=0, transitiveties=0,
cyclicalties=0)</dt><dd><p>A special-purpose term equivalent to a linear
combination of <code><a href="ergm.html#topic+edges-ergmTerm">edges-ergmTerm</a></code>,
<code><a href="ergm.html#topic+mutual-ergmTerm">mutual-ergmTerm</a></code>, <code><a href="ergm.html#topic+transitiveties-ergmTerm">transitiveties-ergmTerm</a></code>, and
<code><a href="ergm.html#topic+cyclicalties-ergmTerm">cyclicalties-ergmTerm</a></code>, to house the network-size
adjustment offset. This term is added to the model automatically
and should not be used in the model formula directly.  </p>
</dd> </dl>
 </dd>
<dt>ergm:</dt><dd>

<ul>
<li> <p><code>offset</code>
</p>
</li>
<li> <p><code>edges</code>
</p>
</li>
<li> <p><code>nodecov</code>
</p>
</li>
<li> <p><code>nodefactor</code>
</p>
</li>
<li> <p><code>nodematch</code>
</p>
</li>
<li> <p><code>nodemix</code>
</p>
</li>
<li> <p><code>absdiff</code>
</p>
</li>
<li> <p><code>degree</code>
</p>
</li>
<li> <p><code>degrange</code>
</p>
</li>
<li> <p><code>concurrent</code>
</p>
</li>
<li> <p><code>concurrentties</code>
</p>
</li>
<li> <p><code>degree1.5</code>
</p>
</li>
<li> <p><code>transitiveties</code>
</p>
</li>
<li> <p><code>cyclicalties</code>
</p>
</li>
<li> <p><code>esp</code>
</p>
</li>
<li> <p><code>gwesp</code>
</p>
</li>
<li> <p><code>gwdegree</code>
</p>
</li>
<li> <p><code>mm</code>
</p>
</li>
<li> <p><code>meandeg</code>*
</p>
</li></ul>

</dd>
<dt>tergm:</dt><dd>

<ul>
<li> <p><code>mean.age</code>*
</p>
</li></ul>

</dd>
</dl>

<p>Starred terms are <em>nonscaling</em>, in that while they can be
evaluated, some inferential results and standard error calculation
methods may not be applicable.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code>
</p>

<hr>
<h2 id='fmhfit'>Fitted ergm.ego model object</h2><span id='topic+fmhfit'></span>

<h3>Description</h3>

<p>This is an object with a fitted model to <code>faux.mesa.high</code> data using the code
shown below in the Examples section.
</p>


<h3>Format</h3>

<p>An object of class <code>ergm.ego</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(faux.mesa.high)
fmh.ego &lt;- egor::as.egor(faux.mesa.high)
fmhfit &lt;- ergm.ego(
  fmh.ego ~ edges + degree(0:3) + 
    nodefactor("Race") + nodematch("Race")
  + nodefactor("Sex")+nodematch("Sex")
  + absdiff("Grade") + gwesp(0, fix=TRUE), 
  popsize = network.size(faux.mesa.high),
  control = control.ergm.ego(
    ergm = control.ergm(parallel=2)
  )
)

## End(Not run)
</code></pre>

<hr>
<h2 id='gof.ergm.ego'>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph
Model fit to Egocentrically Sampled Data</h2><span id='topic+gof.ergm.ego'></span><span id='topic+plot.gof.ergm.ego'></span>

<h3>Description</h3>

<p><code><a href="#topic+gof.ergm.ego">gof.ergm.ego</a></code> implements the <code><a href="ergm.html#topic+gof">gof</a></code> method for
<code><a href="#topic+ergm.ego">ergm.ego</a></code> fit objects.
</p>
<p>An enhanced plotting method is also provided, giving uncertainty bars for the observed statistics as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm.ego'
gof(
  object,
  ...,
  GOF = c("model", "degree", "espartners"),
  control = control.gof.ergm(),
  verbose = FALSE
)

## S3 method for class 'gof.ergm.ego'
plot(x, ..., ego.conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.ergm.ego_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm.ego">ergm.ego</a></code> fit.</p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_...">...</code></td>
<td>
<p>Additional arguments. Unused by <code><a href="#topic+gof.ergm.ego">gof.ergm.ego()</a></code>, passed to
<code><a href="ergm.html#topic+gof">ergm::plot.gof()</a></code> by <code><a href="#topic+plot.gof.ergm.ego">plot.gof.ergm.ego()</a></code></p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_gof">GOF</code></td>
<td>
<p>A string specifying the statistics whose goodness of fit is to be
evaluated. Currently, only &ldquo;degree&rdquo;, &ldquo;espartners&rdquo; and &ldquo;model&rdquo; are
implemented; see <code><a href="ergm.html#topic+gof">gof</a></code> documentation for details.</p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_control">control</code></td>
<td>
<p>A list to control parameters, constructed using
<code><a href="ergm.html#topic+control.gof.formula">control.gof.formula</a></code> or <code><a href="ergm.html#topic+control.gof.ergm">control.gof.ergm</a></code> (which
have different defaults).</p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_verbose">verbose</code></td>
<td>
<p>Provide verbose information on the progress of the
simulation.</p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_x">x</code></td>
<td>
<p>an object returned by <code><a href="#topic+gof.ergm.ego">gof.ergm.ego()</a></code>.</p>
</td></tr>
<tr><td><code id="gof.ergm.ego_+3A_ego.conf.level">ego.conf.level</code></td>
<td>
<p>confidence level for the observed statistic estimates as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+gof.ergm.ego">gof.ergm.ego</a></code>, inheriting from <code><a href="ergm.html#topic+gof.ergm">gof.ergm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>


<ul>
<li><p> David R. Hunter, Steven M. Goodreau, and Mark S. Handcock (2008). &quot;Goodness of Fit of Social Network Models.&quot; <em>Journal of the American Statistical Association</em>, 103:481: 248‚Äì258. <a href="https://doi.org/10.1198/016214507000000446">doi:10.1198/016214507000000446</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>For examples, see <code><a href="#topic+ergm.ego">ergm.ego</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)

head(fmh.ego)

egofit &lt;- ergm.ego(fmh.ego~edges+degree(0:3)+nodefactor("Race")+nodematch("Race")
                         +nodefactor("Sex")+nodematch("Sex")+absdiff("Grade"), 
                          popsize=network.size(faux.mesa.high))

# Check whether the model "converged":
(modelgof &lt;- gof(egofit, GOF="model"))
plot(modelgof)

# Check whether the model reconstructs the degree distribution:
(deggof &lt;- gof(egofit, GOF="degree"))
plot(deggof)

</code></pre>

<hr>
<h2 id='mixingmatrix.egor'>Summarizing the mixing among groups in an egocentric dataset</h2><span id='topic+mixingmatrix.egor'></span><span id='topic+mixingmatrix'></span>

<h3>Description</h3>

<p>A <code><a href="network.html#topic+mixingmatrix">mixingmatrix</a></code> method for
<code><a href="egor.html#topic+egor">egor</a></code> objects, to return counts of how often a ego
of each group nominates an alter of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egor'
mixingmatrix(object, attrname, rowprob = FALSE, weight = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixingmatrix.egor_+3A_object">object</code></td>
<td>
<p>A <code><a href="egor.html#topic+egor">egor</a></code> object.</p>
</td></tr>
<tr><td><code id="mixingmatrix.egor_+3A_attrname">attrname</code></td>
<td>
<p>A character vector containing the name of the network
attribute whose mixing matrix is wanted.</p>
</td></tr>
<tr><td><code id="mixingmatrix.egor_+3A_rowprob">rowprob</code></td>
<td>
<p>Whether the counts should be normalized by row sums. That is,
whether they should be proportions conditional on the ego's group.</p>
</td></tr>
<tr><td><code id="mixingmatrix.egor_+3A_weight">weight</code></td>
<td>
<p>Whether sampling weights should be incorporated into
the calculation (<code>TRUE</code>, the default) or ignored (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mixingmatrix.egor_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with a row and a column for each level of <code>attrname</code>.
</p>
<p>Note that, unlike <code><a href="network.html#topic+mixingmatrix">mixingmatrix</a></code>, what is counted are
<em>nominations</em>, not ties. This means that under an egocentric census,
the diagonal of <code>mixingmatrix.egor</code> will be twice that returned by
<code><a href="network.html#topic+mixingmatrix">mixingmatrix</a></code> for the original undirected network.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+mixingmatrix">mixingmatrix</a></code>, <code><a href="ergm.html#topic+nodemix-ergmTerm">nodemix-ergmTerm</a></code>,
<code><a href="#topic+summary">summary</a></code> method for egocentric data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)

(mm &lt;- mixingmatrix(faux.mesa.high,"Grade"))
(mm.ego &lt;- mixingmatrix(fmh.ego,"Grade"))

</code></pre>

<hr>
<h2 id='nodal_attributes-API'>Helper functions for specifying nodal attribute levels</h2><span id='topic+nodal_attributes-API'></span><span id='topic+ergm.ego_get_vattr'></span><span id='topic+ergm.ego_get_vattr.character'></span><span id='topic+ergm.ego_get_vattr.function'></span><span id='topic+ergm.ego_get_vattr.formula'></span><span id='topic+ergm.ego_attr_levels'></span><span id='topic+ergm.ego_attr_levels.numeric'></span><span id='topic+ergm.ego_attr_levels.logical'></span><span id='topic+ergm.ego_attr_levels.AsIs'></span><span id='topic+ergm.ego_attr_levels.character'></span><span id='topic+ergm.ego_attr_levels.NULL'></span><span id='topic+ergm.ego_attr_levels.matrix'></span><span id='topic+ergm.ego_attr_levels.function'></span><span id='topic+ergm.ego_attr_levels.formula'></span><span id='topic+COLLAPSE_SMALLEST'></span>

<h3>Description</h3>

<p>These functions are meant to be used in <code>EgoStat</code> and other
implementations to provide the user with a way to extract nodal attributes
and select their levels in standardized and flexible ways. They are
intended to parallel <a href="ergm.html#topic+nodal_attributes-API">ergm::nodal_attributes-API</a> of <code>ergm</code> package.
</p>
<p><code>ergm.ego_get_vattr</code> extracts and processes the specified
nodal attribute vector. It is strongly recommended that
<code><a href="ergm.html#topic+check.ErgmTerm">check.ErgmTerm()</a></code>'s corresponding
<code>vartype="function,formula,character"</code> (using the
<code>ERGM_VATTR_SPEC</code> constant).
</p>
<p><code>ergm.ego_attr_levels</code> filters the levels of the
attribute.  It is strongly recommended that <code><a href="ergm.html#topic+check.ErgmTerm">check.ErgmTerm()</a></code>'s
corresponding
<code>vartype="function,formula,character,numeric,logical,AsIs,NULL"</code> (using the
<code>ERGM_LEVELS_SPEC</code> constant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm.ego_get_vattr(
  object,
  df,
  accept = "character",
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class 'character'
ergm.ego_get_vattr(
  object,
  df,
  accept = "character",
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class ''function''
ergm.ego_get_vattr(
  object,
  df,
  accept = "character",
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

## S3 method for class 'formula'
ergm.ego_get_vattr(
  object,
  df,
  accept = "character",
  multiple = if (accept == "character") "paste" else "stop",
  ...
)

ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'numeric'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'logical'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'AsIs'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'character'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class ''NULL''
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'matrix'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class ''function''
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

## S3 method for class 'formula'
ergm.ego_attr_levels(object, attr, egor, levels = sort(unique(attr)), ...)

COLLAPSE_SMALLEST(object, n, into)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodal_attributes-API_+3A_object">object</code></td>
<td>
<p>An argument specifying the nodal attribute to select
or which levels to include.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_df">df</code></td>
<td>
<p>Table of egos or of alters.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_accept">accept</code></td>
<td>
<p>A character vector listing permitted data types for
the output. See the Details section for the specification.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_multiple">multiple</code></td>
<td>
<p>Handling of multiple attributes or matrix or data
frame output. See the Details section for the specification.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_...">...</code></td>
<td>
<p>Additional argument to the functions of network or to
the formula's environment.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_attr">attr</code></td>
<td>
<p>A vector of length equal to the number of nodes,
specifying the attribute vector.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_egor">egor</code></td>
<td>
<p>An <code><a href="egor.html#topic+egor">egor</a></code> object.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_levels">levels</code></td>
<td>
<p>Starting set of levels to use; defaults to the sorted
list of unique attributes.</p>
</td></tr>
<tr><td><code id="nodal_attributes-API_+3A_n">n</code>, <code id="nodal_attributes-API_+3A_into">into</code></td>
<td>
<p>see <code><a href="ergm.html#topic+nodal_attributes">ergm::COLLAPSE_SMALLEST()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>accept</code> argument is meant to allow the user to
quickly check whether the output is of an <em>acceptable</em> class or
mode. Typically, if a term accepts a character (i.e.,
categorical) attribute, it will also accept a numeric one,
treating each number as a category label. For this reason, the
following outputs are defined:
</p>

<dl>
<dt><code>"character"</code></dt><dd><p>Accept any mode or class (since it can
beconverted to character).</p>
</dd>
<dt><code>"numeric"</code></dt><dd><p>Accept real, integer, or logical.</p>
</dd>
<dt><code>"logical"</code></dt><dd><p>Accept logical.</p>
</dd>
<dt><code>"integer"</code></dt><dd><p>Accept integer or logical.</p>
</dd>
<dt><code>"natural"</code></dt><dd><p>Accept a strictly positive integer.</p>
</dd>
<dt><code>"0natural"</code></dt><dd><p>Accept a nonnegative integer or logical.</p>
</dd>
<dt><code>"nonnegative"</code></dt><dd><p>Accept a nonnegative number or logical.</p>
</dd>
<dt><code>"positive"</code></dt><dd><p>Accept a strictly positive number or logical.</p>
</dd>
</dl>


<dl>
<dt><code>"paste"</code></dt><dd><p>Paste together with dot as the separator.</p>
</dd>
<dt><code>"stop"</code></dt><dd><p>Fail with an error message.</p>
</dd>
<dt><code>"matrix"</code></dt><dd><p>Construct and/or return a matrix whose rows correspond to vertices.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>ergm.ego_get_vattr</code> returns a vector of length equal to the number of nodes giving the
selected attribute function. It may also have an attribute
<code>"name"</code>, which controls the suggested name of the attribute
combination.
</p>
<p><code>ergm.ego_attr_levels</code> returns a vector of levels to use and their order.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>COLLAPSE_SMALLEST()</code>: A version of <code><a href="ergm.html#topic+nodal_attributes">ergm::COLLAPSE_SMALLEST()</a></code> that can handle both <code><a href="network.html#topic+network">network</a></code> and <code><a href="#topic+egodata">egodata</a></code> objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(florentine)
flomego &lt;- as.egor(flomarriage)
ergm.ego_get_vattr("priorates", flomego)
ergm.ego_get_vattr(~priorates, flomego)
ergm.ego_get_vattr(c("wealth","priorates"), flomego)
ergm.ego_get_vattr(~priorates&gt;30, flomego)
(a &lt;- ergm.ego_get_vattr(~cut(priorates,c(-Inf,0,20,40,60,Inf),label=FALSE)-1, flomego))
ergm.ego_attr_levels(NULL, a, flomego)
ergm.ego_attr_levels(-1, a, flomego)
ergm.ego_attr_levels(1:2, a, flomego)
ergm.ego_attr_levels(I(1:2), a, flomego)
</code></pre>

<hr>
<h2 id='predict.ergm.ego'>ERGM-based predicted tie probabilities for the pseudo-population network</h2><span id='topic+predict.ergm.ego'></span>

<h3>Description</h3>

<p>ERGM-based predicted tie probabilities for the pseudo-population network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm.ego'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ergm.ego_+3A_object">object</code></td>
<td>
<p>model fit as returned by <code><a href="#topic+ergm.ego">ergm.ego()</a></code></p>
</td></tr>
<tr><td><code id="predict.ergm.ego_+3A_...">...</code></td>
<td>
<p>other arguments passed to/from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="ergm.html#topic+predict.formula">ergm::predict.ergm()</a></code>
</p>

<hr>
<h2 id='sample'>Draw random egocentric subsamples</h2><span id='topic+sample'></span><span id='topic+sample.default'></span><span id='topic+sample.egor'></span>

<h3>Description</h3>

<p>Implementations of the <code><a href="base.html#topic+sample">base::sample()</a></code> function for <code><a href="egor.html#topic+egor">egor::egor()</a></code> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample(x, size, replace = FALSE, prob = NULL, ...)

## Default S3 method:
sample(x, ...)

## S3 method for class 'egor'
sample(x, size, replace = FALSE, prob = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_+3A_x">x</code>, <code id="sample_+3A_size">size</code>, <code id="sample_+3A_replace">replace</code>, <code id="sample_+3A_prob">prob</code></td>
<td>
<p>see <code><a href="base.html#topic+sample">base::sample()</a></code>.</p>
</td></tr>
<tr><td><code id="sample_+3A_...">...</code></td>
<td>
<p>extra arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="egor.html#topic+egor">egor::egor()</a></code> object whose egos have been resampled in
accordance with the arguments. Note that its <code><a href="egor.html#topic+ego_design">egor::ego_design()</a></code>
information is overwritten in favor of the selection
probabilities used in the sampling.
</p>


<h3>Note</h3>

<p>A reimplementation of sample as a generic was necessary
because <code><a href="base.html#topic+sample">base::sample()</a></code> is not a generic and cannot take
data-frame-alikes as arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)

# Create a tiny weighted sample:
(s3 &lt;- sample(fmh.ego, 3, replace=TRUE, prob=1:nrow(fmh.ego$ego)))
# Resampling with prob=weights(egor) creates a self-weighted
# sample:
(sample(s3, 3, replace=TRUE, prob=weights(s3)))

# Create a large weighted sample, oversampling 12th-graders:
p &lt;- ifelse(as_tibble(fmh.ego$ego)$Grade==12, 2, 1)
s2000 &lt;- sample(fmh.ego, 2000, replace=TRUE, prob=p)

# Summary function adjusts for weights:
(summ.net &lt;- summary(faux.mesa.high ~ edges + nodematch("Grade") +
                     nodefactor("Race") + gwesp(0,fix=TRUE)))
(summ.ego &lt;- summary(s2000 ~ edges + nodematch("Grade") + 
                     nodefactor("Race") + gwesp(0,fix=TRUE),
                     scaleto=network.size(faux.mesa.high)))



</code></pre>

<hr>
<h2 id='simulate.ergm.ego'>Simulate from a <code><a href="#topic+ergm.ego">ergm.ego</a></code> fit.</h2><span id='topic+simulate.ergm.ego'></span>

<h3>Description</h3>

<p>A wrapper around <code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code> to simulate networks
from an ERGM fit using <code><a href="#topic+ergm.ego">ergm.ego</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm.ego'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  constraints = object$constraints,
  popsize = if (object$popsize == 1 || object$popsize == 0 || is(object$popsize, "AsIs"))
    object$ppopsize else object$popsize,
  control = control.simulate.ergm.ego(),
  output = c("network", "stats", "edgelist", "pending_update_network", "ergm_state"),
  ...,
  basis = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ergm.ego_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergm.ego">ergm.ego</a></code> fit.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_nsim">nsim</code></td>
<td>
<p>Number of realizations to simulate.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_constraints">constraints</code>, <code id="simulate.ergm.ego_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ergm.html#topic+san">san</a></code> and
<code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_popsize">popsize</code>, <code id="simulate.ergm.ego_+3A_basis">basis</code></td>
<td>
<p>A network size to which to scale the model for
simulation; a <code><a href="base.html#topic+data.frame">data.frame</a></code> with at least those ego attributes
used to estimate the model to simulate over a specific set of
actors; or a <code><a href="network.html#topic+network">network</a></code> object to use as is. <code>basis</code> is provided
for consistency with <code><a href="ergm.html#topic+ergm">ergm()</a></code>, <code><a href="#topic+ergm.ego">ergm.ego()</a></code>, <code><a href="ergm.html#topic+simulate.ergm">simulate.ergm()</a></code>,
and others. If both are specified, <code>popsize</code> overrules.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_control">control</code></td>
<td>
<p>A <code><a href="#topic+control.simulate.ergm.ego">control.simulate.ergm.ego</a></code> control list.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_output">output</code></td>
<td>
<p>one of <code>"network"</code>, <code>"stats"</code>, <code>"edgelist"</code>,
<code>"pending_update_network"</code>, or, for future compatibility,
<code>"ergm_state"</code>. See help for <code><a href="ergm.html#topic+simulate.ergm">simulate.ergm()</a></code> for explanation.</p>
</td></tr>
<tr><td><code id="simulate.ergm.ego_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ouput has the same format (with the same options) as
<code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code>. If <code>output="stats"</code> is passed, an
additional attribute, <code>"ppopsize"</code> is set, giving the actual size of
the network reconstructed, when the <code>pop.wt</code> control parameter is set
to <code>"round"</code> and <code>"popsize"</code> is not a multiple of the egocentric
sample size or the sampling weights.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>


<ul>
<li><p> Pavel N. Krivitsky and Martina Morris (2017). &quot;Inference for social network models from egocentrically sampled data, with application to understanding persistent racial disparities in HIV prevalence in the US.&quot; <em>Annals of Applied Statistics</em>, 11(1): 427‚Äì455. <a href="https://doi.org/10.1214/16-AOAS1010">doi:10.1214/16-AOAS1010</a>
</p>
</li>
<li><p> Pavel N. Krivitsky, Martina Morris, and Micha≈Ç Bojanowski (2019). &quot;Inference for Exponential-Family Random Graph Models from Egocentrically-Sampled Data with Alter‚ÄìAlter Relations.&quot; NIASRA Working Paper 08-19. <a href="https://www.uow.edu.au/niasra/publications/">https://www.uow.edu.au/niasra/publications/</a>
</p>
</li>
<li><p> Pavel N. Krivitsky, Mark S. Handcock, and Martina Morris (2011). &quot;Adjusting for
Network Size and Composition Effects in Exponential-Family Random Graph
Models.&quot; <em>Statistical Methodology</em>, 8(4): 319‚Äì339. <a href="https://doi.org/10.1016/j.stamet.2011.01.005">doi:10.1016/j.stamet.2011.01.005</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code>,
<code><a href="ergm.html#topic+simulate.ergm">simulate.ergm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
data(fmhfit)
colMeans(egosim &lt;- simulate(fmhfit, popsize=300,nsim=50,
                       output="stats", control=control.simulate.ergm.ego(
                       simulate=control.simulate.formula(MCMC.burnin=2e6))))
colMeans(egosim)/attr(egosim,"ppopsize")*network.size(faux.mesa.high)
summary(faux.mesa.high~edges+degree(0:3)+nodefactor("Race")+nodematch("Race")
           +nodefactor("Sex")+nodematch("Sex")+absdiff("Grade"))

</code></pre>

<hr>
<h2 id='snctrl'>Statnet Control</h2><span id='topic+snctrl'></span>

<h3>Description</h3>

<p>A utility to facilitate argument completion of control lists, reexported from <code>statnet.common</code>.
</p>


<h3>Currently recognised control parameters</h3>

<p>This list is updated as packages are loaded and unloaded.
</p>



<h3>See Also</h3>

<p><code><a href="statnet.common.html#topic+snctrl">statnet.common::snctrl()</a></code>
</p>

<hr>
<h2 id='summary_formula.egor'>Calculation of ERGM-style summary statistics for <code><a href="egor.html#topic+egor">egor</a></code>
objects.</h2><span id='topic+summary_formula.egor'></span><span id='topic+summary_formula.egodata'></span><span id='topic+summary'></span><span id='topic+summary_formula'></span><span id='topic++2A.ergm.ego_svystat'></span>

<h3>Description</h3>

<p>Used to calculate the specified network statistics inferred from a
<code><a href="egor.html#topic+egor">egor</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'egor'
summary_formula(object, ..., basis = NULL, individual = FALSE, scaleto = NULL)

## S3 method for class 'ergm.ego_svystat'
x * y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_formula.egor_+3A_object">object</code></td>
<td>
<p>An <code><a href="ergm.html#topic+ergm">ergm</a></code>-style formula with a
<code><a href="egor.html#topic+egor">egor</a></code> object as the LHS.
</p>
<p>For a list of currently implemented egocentric terms for the RHS, see
<code><a href="#topic+ergm.ego-terms">ergm.ego-terms</a></code>.</p>
</td></tr>
<tr><td><code id="summary_formula.egor_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
<tr><td><code id="summary_formula.egor_+3A_basis">basis</code></td>
<td>
<p>An optional <code><a href="egor.html#topic+egor">egor</a></code> object relative to which the
statistics should be calculated.</p>
</td></tr>
<tr><td><code id="summary_formula.egor_+3A_individual">individual</code></td>
<td>
<p>If <code>FALSE</code> (the default), calculate the estimated
per-capita statistics, weighted according to the ego weights, then scale
them up to a network of size <code>scaleto</code>.
</p>
<p>If <code>TRUE</code>, calculate each ego's individual contribution to the
specified network statistics.</p>
</td></tr>
<tr><td><code id="summary_formula.egor_+3A_scaleto">scaleto</code></td>
<td>
<p>Size of a hypothetical network to which to scale the
statistics. Defaults to the number of egos in the dataset.</p>
</td></tr>
<tr><td><code id="summary_formula.egor_+3A_x">x</code>, <code id="summary_formula.egor_+3A_y">y</code></td>
<td>
<p>see <code><a href="#topic++2A.svystat">*.svystat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>individual==FALSE</code>, an <code>ergm.ego_svystat</code> object, which is a subclass of <a href="survey.html#topic+surveysummary">svystat</a>&mdash;effectively a named vector of statistics. If
<code>individual==TRUE</code>, a matrix with a row for each ego, giving that ego's
contribution to the network statistic.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code> * </code>: A multiplication method that takes into account which statistics are scalable.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>References</h3>


<ul>
<li><p> Pavel N. Krivitsky and Martina Morris (2017). &quot;Inference for social network models from egocentrically sampled data, with application to understanding persistent racial disparities in HIV prevalence in the US.&quot; <em>Annals of Applied Statistics</em>, 11(1): 427‚Äì455. <a href="https://doi.org/10.1214/16-AOAS1010">doi:10.1214/16-AOAS1010</a>
</p>
</li>
<li><p> Pavel N. Krivitsky, Mark S. Handcock, and Martina Morris (2011). &quot;Adjusting for
Network Size and Composition Effects in Exponential-Family Random Graph
Models.&quot; <em>Statistical Methodology</em>, 8(4): 319‚Äì339. <a href="https://doi.org/10.1016/j.stamet.2011.01.005">doi:10.1016/j.stamet.2011.01.005</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+summary_formula">summary_formula</a></code>,
<code><a href="ergm.html#topic+summary_formula.ergm">summary_formula.ergm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faux.mesa.high)
fmh.ego &lt;- as.egor(faux.mesa.high)
(nw.summ &lt;- summary(faux.mesa.high~edges+degree(0:3)+nodematch("Race")+
                    nodematch("Sex")+absdiff("Grade")+nodemix("Grade")))

(ego.summ &lt;- summary(fmh.ego~edges+degree(0:3)+nodematch("Race")+nodematch("Sex")+
                     absdiff("Grade")+nodemix("Grade"),
                     scaleto=network.size(faux.mesa.high)))

stopifnot(isTRUE(all.equal(as.vector(nw.summ),as.vector(ego.summ))))


(ego.summ2 &lt;- summary(fmh.ego ~ edges + meandeg + degree(0:2)))
vcov(ego.summ2)

ego.summ2 * 2 # edges and degrees scales, meandeg doesn't
vcov(ego.summ2 * 2)

</code></pre>

<hr>
<h2 id='template_network'>Construct an Empty &ldquo;Template&rdquo; Network Consistent with an Egocentric Sample</h2><span id='topic+template_network'></span><span id='topic+template_network.data.frame'></span><span id='topic+template_network.egor'></span>

<h3>Description</h3>

<p>Taking an object with ego information, constructs a
<code><a href="network.html#topic+network">network</a></code> object with no edges whose vertices have the
attributes of the egos in the dataset, replicating the egos as needed, and
taking into accounts their sampling weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_network(x, ...)

## S3 method for class 'data.frame'
template_network(x, ...)

## S3 method for class 'egor'
template_network(x, N, scaling = c("round", "sample"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_network_+3A_x">x</code></td>
<td>
<p>A <code><a href="egor.html#topic+egor">egor</a></code> object.</p>
</td></tr>
<tr><td><code id="template_network_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
<tr><td><code id="template_network_+3A_n">N</code></td>
<td>
<p>The target number of vertices the output network should have.</p>
</td></tr>
<tr><td><code id="template_network_+3A_scaling">scaling</code></td>
<td>
<p>If <code><a href="egor.html#topic+egor">egor</a></code> contains weights or <code>N</code> is not
a multiple of number of egos in the sample, it may not be possible, for a
finite <code>N</code> to represent each ego exactly according to its relative
weight, and <code>scaling</code> controls how the fractional egos are allocated:
</p>
 <dl>
<dt>&quot;round&quot;</dt><dd><p>(the default) Rather than treating <code>N</code> as a hard
setting, calculate <code class="reqn">N w_i / w_\cdot</code> for each ego <code class="reqn">i</code> and round it
to the nearest integer. Then, the <code>N</code> actually used will be the sum of
these rounded freqencies.</p>
</dd> <dt>&quot;sample&quot;</dt><dd><p>Resample in
proportion to <code class="reqn">w_i</code>.</p>
</dd> </dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="network.html#topic+network">network</a></code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>template_network(data.frame)</code>: method for <code><a href="base.html#topic+data.frame">data.frame</a></code>s and <code><a href="tibble.html#topic+tibble">tibble</a></code>s, specifying ego composition directly.
</p>
</li>
<li> <p><code>template_network(egor)</code>: method for <code><a href="egor.html#topic+egor">egor</a></code> objects; weights, if any, are obtained from the <code>egor</code>'s design information.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.egor.network">as.egor.network</a></code>, which performs the inverse
operation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(faux.mesa.high)
summary(faux.mesa.high, print.adj = FALSE)

fmh.ego &lt;- as.egor(faux.mesa.high)

# Same actor attributes
fmh.template &lt;- template_network(fmh.ego, N=network.size(faux.mesa.high))
summary(fmh.template, print.adj = FALSE)

# Twice the actors, same distribution
fmh2.template &lt;- template_network(fmh.ego, N=2*network.size(faux.mesa.high))
summary(fmh2.template, print.adj = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
