<!DOCTYPE html><html><head><title>Help for package vtreat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vtreat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vtreat-package'><p>vtreat: A Statistically Sound 'data.frame' Processor/Conditioner</p></a></li>
<li><a href='#.wmean'><p>Compute weighted mean</p></a></li>
<li><a href='#apply_transform'><p>Transform second argument by first.</p></a></li>
<li><a href='#as_rquery_plan'><p>Convert vtreatment plans into a sequence of rquery operations.</p></a></li>
<li><a href='#BinomialOutcomeTreatment'><p>Stateful object for designing and applying binomial outcome treatments.</p></a></li>
<li><a href='#buildEvalSets'><p>Build set carve-up for out-of sample evaluation.</p></a></li>
<li><a href='#center_scale'><p>Center and scale a set of variables.</p></a></li>
<li><a href='#classification_parameters'><p>vtreat classification parameters.</p></a></li>
<li><a href='#design_missingness_treatment'><p>Design a simple treatment plan to indicate missingingness and perform simple imputation.</p></a></li>
<li><a href='#designTreatmentsC'><p>Build all treatments for a data frame to predict a categorical outcome.</p></a></li>
<li><a href='#designTreatmentsN'><p>build all treatments for a data frame to predict a numeric outcome</p></a></li>
<li><a href='#designTreatmentsZ'><p>Design variable treatments with no outcome variable.</p></a></li>
<li><a href='#fit'><p>Fit first arguemnt to data in second argument.</p></a></li>
<li><a href='#fit_prepare'><p>Fit and prepare in a cross-validated manner.</p></a></li>
<li><a href='#fit_transform'><p>Fit and transform in a cross-validated manner.</p></a></li>
<li><a href='#flatten_fn_list'><p>Flatten a list of functions onto d.</p></a></li>
<li><a href='#format.vtreatment'><p>Display treatment plan.</p></a></li>
<li><a href='#get_feature_names'><p>Return feasible feature names.</p></a></li>
<li><a href='#get_score_frame'><p>Return score frame from vps.</p></a></li>
<li><a href='#get_transform'><p>Return underlying transform from vps.</p></a></li>
<li><a href='#getSplitPlanAppLabels'><p>read application labels off a split plan.</p></a></li>
<li><a href='#kWayCrossValidation'><p>k-fold cross validation, a splitFunction in the sense of vtreat::buildEvalSets</p></a></li>
<li><a href='#kWayStratifiedY'><p>k-fold cross validation stratified on y, a splitFunction in the sense of vtreat::buildEvalSets</p></a></li>
<li><a href='#kWayStratifiedYReplace'><p>k-fold cross validation stratified with replacement on y, a splitFunction in the sense of vtreat::buildEvalSets .</p></a></li>
<li><a href='#makeCustomCoderCat'><p>Make a categorical input custom coder.</p></a></li>
<li><a href='#makeCustomCoderNum'><p>Make a numeric input custom coder.</p></a></li>
<li><a href='#makekWayCrossValidationGroupedByColumn'><p>Build a k-fold cross validation splitter, respecting (never splitting) groupingColumn.</p></a></li>
<li><a href='#mkCrossFrameCExperiment'><p>Run categorical cross-frame experiment.</p></a></li>
<li><a href='#mkCrossFrameMExperiment'><p>Function to build multi-outcome vtreat cross frame and treatment plan.</p></a></li>
<li><a href='#mkCrossFrameNExperiment'><p>Run a numeric cross frame experiment.</p></a></li>
<li><a href='#multinomial_parameters'><p>vtreat multinomial parameters.</p></a></li>
<li><a href='#MultinomialOutcomeTreatment'><p>Stateful object for designing and applying multinomial outcome treatments.</p></a></li>
<li><a href='#novel_value_summary'><p>Report new/novel appearances of character values.</p></a></li>
<li><a href='#NumericOutcomeTreatment'><p>Stateful object for designing and applying numeric outcome treatments.</p></a></li>
<li><a href='#oneWayHoldout'><p>One way holdout, a splitFunction in the sense of vtreat::buildEvalSets.</p></a></li>
<li><a href='#patch_columns_into_frame'><p>Patch columns into data.frame.</p></a></li>
<li><a href='#pre_comp_xval'><p>Pre-computed cross-plan (so same split happens each time).</p></a></li>
<li><a href='#prepare'><p>Apply treatments and restrict to useful variables.</p></a></li>
<li><a href='#prepare.multinomial_plan'><p>Function to apply mkCrossFrameMExperiment treatemnts.</p></a></li>
<li><a href='#prepare.simple_plan'><p>Prepare a simple treatment.</p></a></li>
<li><a href='#prepare.treatmentplan'><p>Apply treatments and restrict to useful variables.</p></a></li>
<li><a href='#print.multinomial_plan'><p>Print treatmentplan.</p></a></li>
<li><a href='#print.simple_plan'><p>Print treatmentplan.</p></a></li>
<li><a href='#print.treatmentplan'><p>Print treatmentplan.</p></a></li>
<li><a href='#print.vtreatment'><p>Print treatmentplan.</p></a></li>
<li><a href='#problemAppPlan'><p>check if appPlan is a good carve-up of 1:nRows into nSplits groups</p></a></li>
<li><a href='#regression_parameters'><p>vtreat regression parameters.</p></a></li>
<li><a href='#rqdatatable_prepare'><p>Apply a treatment plan using rqdatatable.</p></a></li>
<li><a href='#rquery_prepare'><p>Materialize a treated data frame remotely.</p></a></li>
<li><a href='#solve_piecewise'><p>Solve as piecewise linear problem, numeric target.</p></a></li>
<li><a href='#solve_piecewisec'><p>Solve as piecewise logit problem, categorical target.</p></a></li>
<li><a href='#spline_variable'><p>Spline variable numeric target.</p></a></li>
<li><a href='#spline_variablec'><p>Spline variable categorical target.</p></a></li>
<li><a href='#square_window'><p>Build a square windows variable, numeric target.</p></a></li>
<li><a href='#square_windowc'><p>Build a square windows variable, categorical target.</p></a></li>
<li><a href='#track_values'><p>Track unique character values for variables.</p></a></li>
<li><a href='#unsupervised_parameters'><p>vtreat unsupervised parameters.</p></a></li>
<li><a href='#UnsupervisedTreatment'><p>Stateful object for designing and applying unsupervised treatments.</p></a></li>
<li><a href='#value_variables_C'><p>Value variables for prediction a categorical outcome.</p></a></li>
<li><a href='#value_variables_N'><p>Value variables for prediction a numeric outcome.</p></a></li>
<li><a href='#variable_values'><p>Return variable evaluations.</p></a></li>
<li><a href='#vnames'><p>New treated variable names from a treatmentplan$treatment item.</p></a></li>
<li><a href='#vorig'><p>Original variable name from a treatmentplan$treatment item.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Statistically Sound 'data.frame' Processor/Conditioner</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-12</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/vtreat/">https://github.com/WinVector/vtreat/</a>,
<a href="https://winvector.github.io/vtreat/">https://winvector.github.io/vtreat/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/vtreat/issues">https://github.com/WinVector/vtreat/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'data.frame' processor/conditioner that prepares real-world data for predictive modeling in a statistically sound manner.
    'vtreat' prepares variables so that data has fewer exceptional cases, making
    it easier to safely use models in production. Common problems 'vtreat' defends
    against: 'Inf', 'NA', too many categorical levels, rare categorical levels, and new
    categorical levels (levels seen during application, but not during training). Reference: 
    "'vtreat': a data.frame Processor for Predictive Modeling", Zumel, Mount, 2016, &lt;<a href="https://doi.org/10.5281%2Fzenodo.1173313">doi:10.5281/zenodo.1173313</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), wrapr (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rquery (&ge; 1.4.99), rqdatatable (&ge; 1.3.3), data.table (&ge;
1.12.2), knitr, rmarkdown, parallel, DBI, RSQLite, datasets,
R.rsp, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-12 15:51:36 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Nina Zumel [aut],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-12 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vtreat-package'>vtreat: A Statistically Sound 'data.frame' Processor/Conditioner</h2><span id='topic+vtreat'></span><span id='topic+vtreat-package'></span>

<h3>Description</h3>

<p>A 'data.frame' processor/conditioner that prepares real-world data for predictive modeling in a statistically sound manner.
'vtreat' prepares variables so that data has fewer exceptional cases, making
it easier to safely use models in production. Common problems 'vtreat' defends
against: 'Inf', 'NA', too many categorical levels, rare categorical levels, and new
categorical levels (levels seen during application, but not during training).
'vtreat::prepare' should be used as you would use 'model.matrix'.
</p>


<h3>Details</h3>

<p>For more information:
</p>

<ul>
<li> <p><code>vignette('vtreat', package='vtreat')</code>
</p>
</li>
<li> <p><code>vignette(package='vtreat')</code>
</p>
</li>
<li><p> Website: <a href="https://github.com/WinVector/vtreat">https://github.com/WinVector/vtreat</a> </p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Nina Zumel <a href="mailto:nzumel@win-vector.com">nzumel@win-vector.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/vtreat/">https://github.com/WinVector/vtreat/</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/vtreat/">https://winvector.github.io/vtreat/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/vtreat/issues">https://github.com/WinVector/vtreat/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.wmean'>Compute weighted mean</h2><span id='topic+.wmean'></span>

<h3>Description</h3>

<p>Compute the weighted mean of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.wmean(x, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".wmean_+3A_x">x</code></td>
<td>
<p>numeric vector without NA to compute mean of</p>
</td></tr>
<tr><td><code id=".wmean_+3A_weights">weights</code></td>
<td>
<p>weights vector (or NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>weighted mean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.wmean(c(1, 2, 3))

</code></pre>

<hr>
<h2 id='apply_transform'>Transform second argument by first.</h2><span id='topic+apply_transform'></span>

<h3>Description</h3>

<p>Apply first argument to second as a transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_transform(vps, dframe, ..., parallelCluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_transform_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, object defining transform.</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_dframe">dframe</code></td>
<td>
<p>data.frame, data to transform</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="apply_transform_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>optional, parallel cluster to run on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed dframe
</p>

<hr>
<h2 id='as_rquery_plan'>Convert vtreatment plans into a sequence of rquery operations.</h2><span id='topic+as_rquery_plan'></span>

<h3>Description</h3>

<p>Convert vtreatment plans into a sequence of rquery operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rquery_plan(treatmentplans, ..., var_restriction = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rquery_plan_+3A_treatmentplans">treatmentplans</code></td>
<td>
<p>vtreat treatment plan or list of vtreat treatment plan sharing same outcome and outcome type.</p>
</td></tr>
<tr><td><code id="as_rquery_plan_+3A_...">...</code></td>
<td>
<p>not used, force any later arguments to bind to names.</p>
</td></tr>
<tr><td><code id="as_rquery_plan_+3A_var_restriction">var_restriction</code></td>
<td>
<p>character, if not null restrict to producing these variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(optree_generator (ordered list of functions), temp_tables (named list of tables))
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rquery_prepare">rquery_prepare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("rquery", quietly = TRUE)) {
   dTrainC &lt;- data.frame(x= c('a', 'a', 'a', 'b' ,NA , 'b'),
                         z= c(1, 2, NA, 4, 5, 6),
                         y= c(FALSE, FALSE, TRUE, FALSE, TRUE, TRUE),
                         stringsAsFactors = FALSE)
   dTrainC$id &lt;- seq_len(nrow(dTrainC))
   treatmentsC &lt;- designTreatmentsC(dTrainC, c("x", "z"), 'y', TRUE)
   print(prepare(treatmentsC, dTrainC))
   rqplan &lt;- as_rquery_plan(list(treatmentsC))
   ops &lt;- flatten_fn_list(rquery::local_td(dTrainC), rqplan$optree_generators)
   cat(format(ops))
   if(requireNamespace("rqdatatable", quietly = TRUE)) {
      treated &lt;- rqdatatable::ex_data_table(ops, tables = rqplan$tables)
      print(treated[])
   }
   if(requireNamespace("DBI", quietly = TRUE) &amp;&amp;
      requireNamespace("RSQLite", quietly = TRUE)) {
      db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
      source_data &lt;- rquery::rq_copy_to(db, "dTrainC", dTrainC,
                               overwrite = TRUE, temporary = TRUE)

      rest &lt;- rquery_prepare(db, rqplan, source_data, "dTreatedC", 
                                  extracols = "id")
      resd &lt;- DBI::dbReadTable(db, rest$table_name)
      print(resd)

      rquery::rq_remove_table(db, source_data$table_name)
      rquery::rq_remove_table(db, rest$table_name)
      DBI::dbDisconnect(db)
   }
}

</code></pre>

<hr>
<h2 id='BinomialOutcomeTreatment'>Stateful object for designing and applying binomial outcome treatments.</h2><span id='topic+BinomialOutcomeTreatment'></span>

<h3>Description</h3>

<p>Hold settings and results for binomial classification data preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinomialOutcomeTreatment(
  ...,
  var_list,
  outcome_name,
  outcome_target = TRUE,
  cols_to_copy = NULL,
  params = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinomialOutcomeTreatment_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_var_list">var_list</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_outcome_name">outcome_name</code></td>
<td>
<p>Name of column holding outcome variable. <code>dframe[[outcomename]]</code> must be only finite and non-missing values.</p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_outcome_target">outcome_target</code></td>
<td>
<p>Value/level of outcome to be considered &quot;success&quot;,  and there must be a cut such that <code>dframe[[outcomename]]==outcometarget</code> at least twice and dframe[[outcomename]]!=outcometarget at least twice.</p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_cols_to_copy">cols_to_copy</code></td>
<td>
<p>list of extra columns to copy.</p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_params">params</code></td>
<td>
<p>parameters list from <code>classification_parameters</code></p>
</td></tr>
<tr><td><code id="BinomialOutcomeTreatment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>, 
<code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, and
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>

<hr>
<h2 id='buildEvalSets'>Build set carve-up for out-of sample evaluation.</h2><span id='topic+buildEvalSets'></span>

<h3>Description</h3>

<p>Return a carve-up of seq_len(nRows).  Very useful for any sort of
nested model situation (such as data prep, stacking, or super-learning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildEvalSets(
  nRows,
  ...,
  dframe = NULL,
  y = NULL,
  splitFunction = NULL,
  nSplits = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildEvalSets_+3A_nrows">nRows</code></td>
<td>
<p>scalar, &gt;=1 number of rows to sample from.</p>
</td></tr>
<tr><td><code id="buildEvalSets_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments.</p>
</td></tr>
<tr><td><code id="buildEvalSets_+3A_dframe">dframe</code></td>
<td>
<p>(optional) original data.frame, passed to user splitFunction.</p>
</td></tr>
<tr><td><code id="buildEvalSets_+3A_y">y</code></td>
<td>
<p>(optional) numeric vector, outcome variable (possibly to stratify on), passed to user splitFunction.</p>
</td></tr>
<tr><td><code id="buildEvalSets_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) function taking arguments nSplits,nRows,dframe, and y; returning a user desired split.</p>
</td></tr>
<tr><td><code id="buildEvalSets_+3A_nsplits">nSplits</code></td>
<td>
<p>integer, target number of splits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also sets attribute &quot;splitmethod&quot; on return value that describes how the split was performed.
attr(returnValue,'splitmethod') is one of: 'notsplit' (data was not split; corner cases
like single row data sets), 'oneway' (leave one out holdout), 'kwaycross' (a simple
partition), 'userfunction' (user supplied function was actually used), or a user specified attribute.
Any user
desired properties (such as stratification on y, or preservation of groups designated by 
original data row numbers) may not apply unless you see that 'userfunction' has been
used.
</p>
<p>The intent is the user splitFunction only needs to handle &quot;easy cases&quot; 
and maintain user invariants. If the user splitFunction returns NULL,
throws, or returns an unacceptable carve-up then vtreat::buildEvalSets
returns its own eval set plan.  The signature of splitFunction should
be splitFunction(nRows,nSplits,dframe,y) where nSplits is the number of 
pieces we want in the carve-up, nRows is the number of rows to split,
dframe is the original dataframe (useful for any group control variables),
and y is a numeric vector representing outcome (useful for outcome stratification).
</p>
<p>Note that buildEvalSets may not always return a partition (such
as one row dataframes), or if the user split function chooses to make rows eligible for
application a different number of times.
</p>


<h3>Value</h3>

<p>list of lists where the app portion of the sub-lists is a disjoint carve-up of seq_len(nRows) and each list as a train portion disjoint from app.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kWayCrossValidation">kWayCrossValidation</a></code>, <code><a href="#topic+kWayStratifiedY">kWayStratifiedY</a></code>, and <code><a href="#topic+makekWayCrossValidationGroupedByColumn">makekWayCrossValidationGroupedByColumn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# use
buildEvalSets(200)

# longer example
# helper fns
# fit models using experiment plan to estimate out of sample behavior
fitModelAndApply &lt;- function(trainData,applicaitonData) {
   model &lt;- lm(y~x,data=trainData)
   predict(model,newdata=applicaitonData)
}
simulateOutOfSampleTrainEval &lt;- function(d,fitApplyFn) {
   eSets &lt;- buildEvalSets(nrow(d))
   evals &lt;- lapply(eSets, 
      function(ei) { fitApplyFn(d[ei$train,],d[ei$app,]) })
   pred &lt;- numeric(nrow(d))
   for(eii in seq_len(length(eSets))) {
     pred[eSets[[eii]]$app] &lt;- evals[[eii]]
   }
   pred
}

# run the experiment
set.seed(2352356)
# example data
d &lt;- data.frame(x=rnorm(5),y=rnorm(5),
        outOfSampleEst=NA,inSampleEst=NA)
        
# fit model on all data
d$inSampleEst &lt;- fitModelAndApply(d,d)
# compute in-sample R^2 (above zero, falsely shows a 
#   relation until we adjust for degrees of freedom)
1-sum((d$y-d$inSampleEst)^2)/sum((d$y-mean(d$y))^2)

d$outOfSampleEst &lt;- simulateOutOfSampleTrainEval(d,fitModelAndApply)
# compute out-sample R^2 (not positive, 
#  evidence of no relation)
1-sum((d$y-d$outOfSampleEst)^2)/sum((d$y-mean(d$y))^2)

</code></pre>

<hr>
<h2 id='center_scale'>Center and scale a set of variables.</h2><span id='topic+center_scale'></span>

<h3>Description</h3>

<p>Center and scale a set of variables. Other columns are passed through.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_scale(d, center, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_scale_+3A_d">d</code></td>
<td>
<p>data.frame to work with</p>
</td></tr>
<tr><td><code id="center_scale_+3A_center">center</code></td>
<td>
<p>named vector of variables to center</p>
</td></tr>
<tr><td><code id="center_scale_+3A_scale">scale</code></td>
<td>
<p>named vector of variables to scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>d with centered and scaled columns altered
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = 1:5, 
                y = c('a', 'a', 'b', 'b', 'b'))
vars_to_transform = "x"
t &lt;- base::scale(as.matrix(d[, vars_to_transform, drop = FALSE]), 
                 center = TRUE, scale = TRUE)
t

centering &lt;- attr(t, "scaled:center")
scaling &lt;- attr(t, "scaled:scale")
center_scale(d, center = centering, scale = scaling)

</code></pre>

<hr>
<h2 id='classification_parameters'>vtreat classification parameters.</h2><span id='topic+classification_parameters'></span>

<h3>Description</h3>

<p>A list of settings and values for vtreat binomial classification fitting. 
Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>, 
<code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, and
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classification_parameters(user_params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classification_parameters_+3A_user_params">user_params</code></td>
<td>
<p>list of user overrides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filled out parameter list
</p>

<hr>
<h2 id='design_missingness_treatment'>Design a simple treatment plan to indicate missingingness and perform simple imputation.</h2><span id='topic+design_missingness_treatment'></span>

<h3>Description</h3>

<p>Design a simple treatment plan to indicate missingingness and perform simple imputation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_missingness_treatment(
  dframe,
  ...,
  varlist = colnames(dframe),
  invalid_mark = "_invalid_",
  drop_constant_columns = FALSE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_missingness_treatment_+3A_dframe">dframe</code></td>
<td>
<p>data.frame to drive design.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_varlist">varlist</code></td>
<td>
<p>character, names of columns to process.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_invalid_mark">invalid_mark</code></td>
<td>
<p>character, name to use for NA levels and novel levels.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_drop_constant_columns">drop_constant_columns</code></td>
<td>
<p>logical, if TRUE drop columns that do not vary from the treatment plan.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="design_missingness_treatment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>simple treatment plan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.simple_plan">prepare.simple_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "x1", "x2", "x3" |
  1   , 4   , "A"  |
  NA  , 5   , "B"  |
  3   , 6   , NA   )

plan &lt;- design_missingness_treatment(d)
prepare(plan, d)

prepare(plan, data.frame(x1=NA, x2=NA, x3="E"))

</code></pre>

<hr>
<h2 id='designTreatmentsC'>Build all treatments for a data frame to predict a categorical outcome.</h2><span id='topic+designTreatmentsC'></span>

<h3>Description</h3>

<p>Function to design variable treatments for binary prediction of a
categorical outcome.  Data frame is assumed to have only atomic columns
except for dates (which are converted to numeric). Note: re-encoding high cardinality
categorical variables can introduce undesirable nested model bias, for such data consider
using <code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designTreatmentsC(
  dframe,
  varlist,
  outcomename,
  outcometarget = TRUE,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = NULL,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  catScaling = TRUE,
  verbose = TRUE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designTreatmentsC_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_outcometarget">outcometarget</code></td>
<td>
<p>Value/level of outcome to be considered &quot;success&quot;,  and there must be a cut such that dframe[[outcomename]]==outcometarget at least twice and dframe[[outcomename]]!=outcometarget at least twice.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar &gt;=2 number of cross validation splits use in rescoring complex variables.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods (when parallel cluster is set).</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="designTreatmentsC_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main fields are mostly vectors with names (all with the same names in the same order):
</p>
<p>- vars : (character array without names) names of variables (in same order as names on the other diagnostic vectors)
- varMoves : logical TRUE if the variable varied during hold out scoring, only variables that move will be in the treated frame
- #' - sig : an estimate significance of effect
</p>
<p>See the vtreat vignette for a bit more detail and a worked example.
</p>
<p>Columns that do not vary are not passed through.
</p>
<p>Note: re-encoding high cardinality on training data can introduce nested model bias, consider using <code>mkCrossFrameCExperiment</code> instead.
</p>


<h3>Value</h3>

<p>treatment plan (for use with prepare)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, <code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dTrainC &lt;- data.frame(x=c('a','a','a','b','b','b'),
   z=c(1,2,3,4,5,6),
   y=c(FALSE,FALSE,TRUE,FALSE,TRUE,TRUE))
dTestC &lt;- data.frame(x=c('a','b','c',NA),
   z=c(10,20,30,NA))
treatmentsC &lt;- designTreatmentsC(dTrainC,colnames(dTrainC),'y',TRUE)
dTestCTreated &lt;- prepare(treatmentsC,dTestC,pruneSig=0.99)

</code></pre>

<hr>
<h2 id='designTreatmentsN'>build all treatments for a data frame to predict a numeric outcome</h2><span id='topic+designTreatmentsN'></span>

<h3>Description</h3>

<p>Function to design variable treatments for binary prediction of a
numeric outcome.  Data frame is assumed to have only atomic columns
except for dates (which are converted to numeric).
Note: each column is processed independently of all others. 
Note: re-encoding high cardinality on training data
categorical variables can introduce undesirable nested model bias, for such data consider
using <code><a href="#topic+mkCrossFrameNExperiment">mkCrossFrameNExperiment</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designTreatmentsN(
  dframe,
  varlist,
  outcomename,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = NULL,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  verbose = TRUE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designTreatmentsN_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values and there must be a cut such that dframe[[outcomename]] is both above the cut at least twice and below the cut at least twice.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar &gt;=2 number of cross validation splits use in rescoring complex variables.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods (when parallel cluster is set).</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="designTreatmentsN_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main fields are mostly vectors with names (all with the same names in the same order):
</p>
<p>- vars : (character array without names) names of variables (in same order as names on the other diagnostic vectors)
- varMoves : logical TRUE if the variable varied during hold out scoring, only variables that move will be in the treated frame
- sig : an estimate significance of effect
</p>
<p>See the vtreat vignette for a bit more detail and a worked example.
</p>
<p>Columns that do not vary are not passed through.
</p>


<h3>Value</h3>

<p>treatment plan (for use with prepare)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, <code><a href="#topic+mkCrossFrameNExperiment">mkCrossFrameNExperiment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dTrainN &lt;- data.frame(x=c('a','a','a','a','b','b','b'),
    z=c(1,2,3,4,5,6,7),y=c(0,0,0,1,0,1,1))
dTestN &lt;- data.frame(x=c('a','b','c',NA),
    z=c(10,20,30,NA))
treatmentsN = designTreatmentsN(dTrainN,colnames(dTrainN),'y')
dTestNTreated &lt;- prepare(treatmentsN,dTestN,pruneSig=0.99)

</code></pre>

<hr>
<h2 id='designTreatmentsZ'>Design variable treatments with no outcome variable.</h2><span id='topic+designTreatmentsZ'></span>

<h3>Description</h3>

<p>Data frame is assumed to have only atomic columns
except for dates (which are converted to numeric).
Note: each column is processed independently of all others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designTreatmentsZ(
  dframe,
  varlist,
  ...,
  minFraction = 0,
  weights = c(),
  rareCount = 0,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  verbose = TRUE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designTreatmentsZ_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods (if parallel cluster is set).</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="designTreatmentsZ_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main fields are mostly vectors with names (all with the same names in the same order):
</p>
<p>- vars : (character array without names) names of variables (in same order as names on the other diagnostic vectors)
- varMoves : logical TRUE if the variable varied during hold out scoring, only variables that move will be in the treated frame
</p>
<p>See the vtreat vignette for a bit more detail and a worked example.
</p>
<p>Columns that do not vary are not passed through.
</p>


<h3>Value</h3>

<p>treatment plan (for use with prepare)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dTrainZ &lt;- data.frame(x=c('a','a','a','a','b','b',NA,'e','e'),
    z=c(1,2,3,4,5,6,7,NA,9))
dTestZ &lt;- data.frame(x=c('a','x','c',NA),
    z=c(10,20,30,NA))
treatmentsZ = designTreatmentsZ(dTrainZ, colnames(dTrainZ),
  rareCount=0)
dTrainZTreated &lt;- prepare(treatmentsZ, dTrainZ)
dTestZTreated &lt;- prepare(treatmentsZ, dTestZ)

</code></pre>

<hr>
<h2 id='fit'>Fit first arguemnt to data in second argument.</h2><span id='topic+fit'></span>

<h3>Description</h3>

<p>Update the state of first argument to have learned or fit from second argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(vps, dframe, ..., weights = NULL, parallelCluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, object specifying fit</p>
</td></tr>
<tr><td><code id="fit_+3A_dframe">dframe</code></td>
<td>
<p>data.frame, data to fit from.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="fit_+3A_weights">weights</code></td>
<td>
<p>optional, per-dframe data weights.</p>
</td></tr>
<tr><td><code id="fit_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>optional, parallel cluster to run on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: input vps is not altered, fit is in returned value.
</p>


<h3>Value</h3>

<p>new fit object
</p>

<hr>
<h2 id='fit_prepare'>Fit and prepare in a cross-validated manner.</h2><span id='topic+fit_prepare'></span>

<h3>Description</h3>

<p>Update the state of first argument to have learned or fit from second argument, and compute a cross
validated example of such a transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_prepare(vps, dframe, ..., weights = NULL, parallelCluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_prepare_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, object specifying fit.</p>
</td></tr>
<tr><td><code id="fit_prepare_+3A_dframe">dframe</code></td>
<td>
<p>data.frame, data to fit from.</p>
</td></tr>
<tr><td><code id="fit_prepare_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="fit_prepare_+3A_weights">weights</code></td>
<td>
<p>optional, per-dframe data weights.</p>
</td></tr>
<tr><td><code id="fit_prepare_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>optional, parallel cluster to run on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: input vps is not altered, fit is in returned list.
</p>


<h3>Value</h3>

<p>@return named list containing: treatments and cross_frame
</p>

<hr>
<h2 id='fit_transform'>Fit and transform in a cross-validated manner.</h2><span id='topic+fit_transform'></span>

<h3>Description</h3>

<p>Update the state of first argument to have learned or fit from second argument, and compute a cross
validated example of such a transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_transform(vps, dframe, ..., weights = NULL, parallelCluster = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_transform_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, object specifying fit.</p>
</td></tr>
<tr><td><code id="fit_transform_+3A_dframe">dframe</code></td>
<td>
<p>data.frame, data to fit from.</p>
</td></tr>
<tr><td><code id="fit_transform_+3A_...">...</code></td>
<td>
<p>not used, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="fit_transform_+3A_weights">weights</code></td>
<td>
<p>optional, per-dframe data weights.</p>
</td></tr>
<tr><td><code id="fit_transform_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>optional, parallel cluster to run on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: input vps is not altered, fit is in returned list.
</p>


<h3>Value</h3>

<p>@return named list containing: treatments and cross_frame
</p>

<hr>
<h2 id='flatten_fn_list'>Flatten a list of functions onto d.</h2><span id='topic+flatten_fn_list'></span>

<h3>Description</h3>

<p>Flatten a list of functions onto d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_fn_list(d, fnlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_fn_list_+3A_d">d</code></td>
<td>
<p>object (usually a data souce)</p>
</td></tr>
<tr><td><code id="flatten_fn_list_+3A_fnlist">fnlist</code></td>
<td>
<p>a list of functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fnlist[[length(fnlist)]](flatten_fn_list(d, fnlist[[-length(fnlist)]]) (or d if length(fnlist)&lt;1)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rquery_plan">as_rquery_plan</a></code>
</p>

<hr>
<h2 id='format.vtreatment'>Display treatment plan.</h2><span id='topic+format.vtreatment'></span>

<h3>Description</h3>

<p>Display treatment plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vtreatment'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.vtreatment_+3A_x">x</code></td>
<td>
<p>treatment plan</p>
</td></tr>
<tr><td><code id="format.vtreatment_+3A_...">...</code></td>
<td>
<p>additional args (to match general signature).</p>
</td></tr>
</table>

<hr>
<h2 id='get_feature_names'>Return feasible feature names.</h2><span id='topic+get_feature_names'></span>

<h3>Description</h3>

<p>Return previously fit feature names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_feature_names(vps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_feature_names_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, mutable object to read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>feature names
</p>

<hr>
<h2 id='get_score_frame'>Return score frame from vps.</h2><span id='topic+get_score_frame'></span>

<h3>Description</h3>

<p>Return previously fit score frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_score_frame(vps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_score_frame_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, mutable object to read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>score frame
</p>

<hr>
<h2 id='get_transform'>Return underlying transform from vps.</h2><span id='topic+get_transform'></span>

<h3>Description</h3>

<p>Return previously fit transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transform(vps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_transform_+3A_vps">vps</code></td>
<td>
<p>vtreat pipe step, mutable object to read from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transform
</p>

<hr>
<h2 id='getSplitPlanAppLabels'>read application labels off a split plan.</h2><span id='topic+getSplitPlanAppLabels'></span>

<h3>Description</h3>

<p>read application labels off a split plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSplitPlanAppLabels(nRow, plan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSplitPlanAppLabels_+3A_nrow">nRow</code></td>
<td>
<p>number of rows in original data.frame.</p>
</td></tr>
<tr><td><code id="getSplitPlanAppLabels_+3A_plan">plan</code></td>
<td>
<p>split plan</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of labels
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kWayCrossValidation">kWayCrossValidation</a></code>, <code><a href="#topic+kWayStratifiedY">kWayStratifiedY</a></code>, and <code><a href="#topic+makekWayCrossValidationGroupedByColumn">makekWayCrossValidationGroupedByColumn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plan &lt;- kWayStratifiedY(3,2,NULL,NULL)
getSplitPlanAppLabels(3,plan)

</code></pre>

<hr>
<h2 id='kWayCrossValidation'>k-fold cross validation, a splitFunction in the sense of vtreat::buildEvalSets</h2><span id='topic+kWayCrossValidation'></span>

<h3>Description</h3>

<p>k-fold cross validation, a splitFunction in the sense of vtreat::buildEvalSets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kWayCrossValidation(nRows, nSplits, dframe, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kWayCrossValidation_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to split (&gt;1).</p>
</td></tr>
<tr><td><code id="kWayCrossValidation_+3A_nsplits">nSplits</code></td>
<td>
<p>number of groups to split into (&gt;1,&lt;=nRows).</p>
</td></tr>
<tr><td><code id="kWayCrossValidation_+3A_dframe">dframe</code></td>
<td>
<p>original data frame (ignored).</p>
</td></tr>
<tr><td><code id="kWayCrossValidation_+3A_y">y</code></td>
<td>
<p>numeric outcome variable (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>split plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kWayCrossValidation(7,2,NULL,NULL)

</code></pre>

<hr>
<h2 id='kWayStratifiedY'>k-fold cross validation stratified on y, a splitFunction in the sense of vtreat::buildEvalSets</h2><span id='topic+kWayStratifiedY'></span>

<h3>Description</h3>

<p>k-fold cross validation stratified on y, a splitFunction in the sense of vtreat::buildEvalSets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kWayStratifiedY(nRows, nSplits, dframe, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kWayStratifiedY_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to split (&gt;1)</p>
</td></tr>
<tr><td><code id="kWayStratifiedY_+3A_nsplits">nSplits</code></td>
<td>
<p>number of groups to split into (&lt;nRows,&gt;1).</p>
</td></tr>
<tr><td><code id="kWayStratifiedY_+3A_dframe">dframe</code></td>
<td>
<p>original data frame (ignored).</p>
</td></tr>
<tr><td><code id="kWayStratifiedY_+3A_y">y</code></td>
<td>
<p>numeric outcome variable try to have equidistributed in each split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>split plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23255)
d &lt;- data.frame(y=sin(1:100))
pStrat &lt;- kWayStratifiedY(nrow(d),5,d,d$y)
problemAppPlan(nrow(d),5,pStrat,TRUE)
d$stratGroup &lt;- vtreat::getSplitPlanAppLabels(nrow(d),pStrat)
pSimple &lt;- kWayCrossValidation(nrow(d),5,d,d$y)
problemAppPlan(nrow(d),5,pSimple,TRUE)
d$simpleGroup &lt;- vtreat::getSplitPlanAppLabels(nrow(d),pSimple)
summary(tapply(d$y,d$simpleGroup,mean))
summary(tapply(d$y,d$stratGroup,mean))



</code></pre>

<hr>
<h2 id='kWayStratifiedYReplace'>k-fold cross validation stratified with replacement on y, a splitFunction in the sense of vtreat::buildEvalSets .</h2><span id='topic+kWayStratifiedYReplace'></span>

<h3>Description</h3>

<p>Build a k-fold cross validation sample where training sets are the same size as the original data,
and built by sampling disjoint from test/application sets (sampled with replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kWayStratifiedYReplace(nRows, nSplits, dframe, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kWayStratifiedYReplace_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to split (&gt;1)</p>
</td></tr>
<tr><td><code id="kWayStratifiedYReplace_+3A_nsplits">nSplits</code></td>
<td>
<p>number of groups to split into (&lt;nRows,&gt;1).</p>
</td></tr>
<tr><td><code id="kWayStratifiedYReplace_+3A_dframe">dframe</code></td>
<td>
<p>original data frame (ignored).</p>
</td></tr>
<tr><td><code id="kWayStratifiedYReplace_+3A_y">y</code></td>
<td>
<p>numeric outcome variable try to have equidistributed in each split.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>split plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23255)
d &lt;- data.frame(y=sin(1:100))
pStrat &lt;- kWayStratifiedYReplace(nrow(d),5,d,d$y)

</code></pre>

<hr>
<h2 id='makeCustomCoderCat'>Make a categorical input custom coder.</h2><span id='topic+makeCustomCoderCat'></span>

<h3>Description</h3>

<p>Make a categorical input custom coder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCustomCoderCat(
  ...,
  customCode,
  coder,
  codeSeq,
  v,
  vcolin,
  zoY,
  zC,
  zTarget,
  weights = NULL,
  catScaling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCustomCoderCat_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be set by name</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_customcode">customCode</code></td>
<td>
<p>code name</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_coder">coder</code></td>
<td>
<p>user supplied variable re-coder (see vignette for type signature)</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_codeseq">codeSeq</code></td>
<td>
<p>argments to custom coder</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_v">v</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_vcolin">vcolin</code></td>
<td>
<p>data column, character</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_zoy">zoY</code></td>
<td>
<p>outcome column as numeric</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_zc">zC</code></td>
<td>
<p>if classification outcome column as character</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_ztarget">zTarget</code></td>
<td>
<p>if classification target class</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_weights">weights</code></td>
<td>
<p>per-row weights</p>
</td></tr>
<tr><td><code id="makeCustomCoderCat_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wrapped custom coder
</p>

<hr>
<h2 id='makeCustomCoderNum'>Make a numeric input custom coder.</h2><span id='topic+makeCustomCoderNum'></span>

<h3>Description</h3>

<p>Make a numeric input custom coder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCustomCoderNum(
  ...,
  customCode,
  coder,
  codeSeq,
  v,
  vcolin,
  zoY,
  zC,
  zTarget,
  weights = NULL,
  catScaling = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCustomCoderNum_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be set by name</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_customcode">customCode</code></td>
<td>
<p>code name</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_coder">coder</code></td>
<td>
<p>user supplied variable re-coder (see vignette for type signature)</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_codeseq">codeSeq</code></td>
<td>
<p>argments to custom coder</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_v">v</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_vcolin">vcolin</code></td>
<td>
<p>data column, numeric</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_zoy">zoY</code></td>
<td>
<p>outcome column as numeric</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_zc">zC</code></td>
<td>
<p>if classification outcome column as character</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_ztarget">zTarget</code></td>
<td>
<p>if classification target class</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_weights">weights</code></td>
<td>
<p>per-row weights</p>
</td></tr>
<tr><td><code id="makeCustomCoderNum_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wrapped custom coder
</p>

<hr>
<h2 id='makekWayCrossValidationGroupedByColumn'>Build a k-fold cross validation splitter, respecting (never splitting) groupingColumn.</h2><span id='topic+makekWayCrossValidationGroupedByColumn'></span>

<h3>Description</h3>

<p>Build a k-fold cross validation splitter, respecting (never splitting) groupingColumn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makekWayCrossValidationGroupedByColumn(groupingColumnName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makekWayCrossValidationGroupedByColumn_+3A_groupingcolumnname">groupingColumnName</code></td>
<td>
<p>name of column to group by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splitting function in the sense of vtreat::buildEvalSets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(y=sin(1:100))
d$group &lt;- floor(seq_len(nrow(d))/5)
splitter &lt;- makekWayCrossValidationGroupedByColumn('group')
split &lt;- splitter(nrow(d),5,d,d$y)
d$splitLabel &lt;- vtreat::getSplitPlanAppLabels(nrow(d),split)
rowSums(table(d$group,d$splitLabel)&gt;0)

</code></pre>

<hr>
<h2 id='mkCrossFrameCExperiment'>Run categorical cross-frame experiment.</h2><span id='topic+mkCrossFrameCExperiment'></span>

<h3>Description</h3>

<p>Builds a <code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code> treatment plan and a data frame prepared 
from <code>dframe</code> that is &quot;cross&quot; in the sense each row is treated using a treatment
plan built from a subset of dframe disjoint from the given row.
The goal is to try to and supply a method of breaking nested model bias other than splitting
into calibration, training, test sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkCrossFrameCExperiment(
  dframe,
  varlist,
  outcomename,
  outcometarget,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = 1,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  scale = FALSE,
  doCollar = FALSE,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  catScaling = TRUE,
  verbose = TRUE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkCrossFrameCExperiment_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_outcometarget">outcometarget</code></td>
<td>
<p>Value/level of outcome to be considered &quot;success&quot;,  and there must be a cut such that dframe[[outcomename]]==outcometarget at least twice and dframe[[outcomename]]!=outcometarget at least twice.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with regression (&quot;move to outcome-scale&quot;).</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar&gt;=2 number of cross-validation rounds to design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="mkCrossFrameCExperiment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list containing: treatments, crossFrame, crossWeights, method, and evalSets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# categorical example
set.seed(23525)

# we set up our raw training and application data
dTrainC &lt;- data.frame(
  x = c('a', 'a', 'a', 'b', 'b', NA, NA),
  z = c(1, 2, 3, 4, NA, 6, NA),
  y = c(FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE))

dTestC &lt;- data.frame(
  x = c('a', 'b', 'c', NA), 
  z = c(10, 20, 30, NA))

# we perform a vtreat cross frame experiment
# and unpack the results into treatmentsC
# and dTrainCTreated
unpack[
  treatmentsC = treatments,
  dTrainCTreated = crossFrame
  ] &lt;- mkCrossFrameCExperiment(
    dframe = dTrainC,
    varlist = setdiff(colnames(dTrainC), 'y'),
    outcomename = 'y',
    outcometarget = TRUE,
    verbose = FALSE)

# the treatments include a score frame relating new
# derived variables to original columns
treatmentsC$scoreFrame[, c('origName', 'varName', 'code', 'rsq', 'sig', 'extraModelDegrees')] %.&gt;%
  print(.)

# the treated frame is a "cross frame" which
# is a transform of the training data built 
# as if the treatment were learned on a different
# disjoint training set to avoid nested model
# bias and over-fit.
dTrainCTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

# Any future application data is prepared with
# the prepare method.
dTestCTreated &lt;- prepare(treatmentsC, dTestC, pruneSig=NULL)

dTestCTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

</code></pre>

<hr>
<h2 id='mkCrossFrameMExperiment'>Function to build multi-outcome vtreat cross frame and treatment plan.</h2><span id='topic+mkCrossFrameMExperiment'></span>

<h3>Description</h3>

<p>Please see <code>vignette("MultiClassVtreat", package = "vtreat")</code> <a href="https://winvector.github.io/vtreat/articles/MultiClassVtreat.html">https://winvector.github.io/vtreat/articles/MultiClassVtreat.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkCrossFrameMExperiment(
  dframe,
  varlist,
  outcomename,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = 1,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  scale = FALSE,
  doCollar = FALSE,
  splitFunction = vtreat::kWayCrossValidation,
  ncross = 3,
  forceSplit = FALSE,
  catScaling = FALSE,
  y_dependent_treatments = c("catB"),
  verbose = FALSE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkCrossFrameMExperiment_+3A_dframe">dframe</code></td>
<td>
<p>data to learn from</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_varlist">varlist</code></td>
<td>
<p>character, vector of indpendent variable column names.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_outcomename">outcomename</code></td>
<td>
<p>character, name of outcome column.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_...">...</code></td>
<td>
<p>not used, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.multinomial_plan">prepare.multinomial_plan</a></code>.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with regression (&quot;move to outcome-scale&quot;).</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar&gt;=2 number of cross-validation rounds to design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_y_dependent_treatments">y_dependent_treatments</code></td>
<td>
<p>character what treatment types to build per-outcome level.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="mkCrossFrameMExperiment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a names list containing cross_frame, treat_m, score_frame, and fit_obj_id
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.multinomial_plan">prepare.multinomial_plan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# numeric example
set.seed(23525)

# we set up our raw training and application data
dTrainM &lt;- data.frame(
  x = c('a', 'a', 'a', 'a', 'b', 'b', NA, NA),
  z = c(1, 2, 3, 4, 5, NA, 7, NA), 
  y = c(0, 0, 0, 1, 0, 1, 2, 1))

dTestM &lt;- data.frame(
  x = c('a', 'b', 'c', NA), 
  z = c(10, 20, 30, NA))

# we perform a vtreat cross frame experiment
# and unpack the results into treatmentsM,
# dTrainMTreated, and score_frame
unpack[
  treatmentsM = treat_m,
  dTrainMTreated = cross_frame,
  score_frame = score_frame
  ] &lt;- mkCrossFrameMExperiment(
    dframe = dTrainM,
    varlist = setdiff(colnames(dTrainM), 'y'),
    outcomename = 'y',
    verbose = FALSE)

# the score_frame relates new
# derived variables to original columns
score_frame[, c('origName', 'varName', 'code', 'rsq', 'sig', 'outcome_level')] %.&gt;%
  print(.)

# the treated frame is a "cross frame" which
# is a transform of the training data built 
# as if the treatment were learned on a different
# disjoint training set to avoid nested model
# bias and over-fit.
dTrainMTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

# Any future application data is prepared with
# the prepare method.
dTestMTreated &lt;- prepare(treatmentsM, dTestM, pruneSig=NULL)

dTestMTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

</code></pre>

<hr>
<h2 id='mkCrossFrameNExperiment'>Run a numeric cross frame experiment.</h2><span id='topic+mkCrossFrameNExperiment'></span>

<h3>Description</h3>

<p>Builds a <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code> treatment plan and a data frame prepared 
from <code>dframe</code> that is &quot;cross&quot; in the sense each row is treated using a treatment
plan built from a subset of dframe disjoint from the given row.
The goal is to try to and supply a method of breaking nested model bias other than splitting
into calibration, training, test sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkCrossFrameNExperiment(
  dframe,
  varlist,
  outcomename,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = 1,
  collarProb = 0,
  codeRestriction = NULL,
  customCoders = NULL,
  scale = FALSE,
  doCollar = FALSE,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  verbose = TRUE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkCrossFrameNExperiment_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values and there must be a cut such that dframe[[outcomename]] is both above the cut at least twice and below the cut at least twice.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>what types of variables to produce (character array of level codes, NULL means no restriction).</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_customcoders">customCoders</code></td>
<td>
<p>map from code names to custom categorical variable encoding functions (please see <a href="https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md">https://github.com/WinVector/vtreat/blob/main/extras/CustomLevelCoders.md</a>).</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with regression (&quot;move to outcome-scale&quot;).</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar&gt;=2 number of cross-validation rounds to design.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="mkCrossFrameNExperiment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list containing: treatments, crossFrame, crossWeights, method, and evalSets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# numeric example
set.seed(23525)

# we set up our raw training and application data
dTrainN &lt;- data.frame(
  x = c('a', 'a', 'a', 'a', 'b', 'b', NA, NA),
  z = c(1, 2, 3, 4, 5, NA, 7, NA), 
  y = c(0, 0, 0, 1, 0, 1, 1, 1))

dTestN &lt;- data.frame(
  x = c('a', 'b', 'c', NA), 
  z = c(10, 20, 30, NA))

# we perform a vtreat cross frame experiment
# and unpack the results into treatmentsN
# and dTrainNTreated
unpack[
  treatmentsN = treatments,
  dTrainNTreated = crossFrame
  ] &lt;- mkCrossFrameNExperiment(
    dframe = dTrainN,
    varlist = setdiff(colnames(dTrainN), 'y'),
    outcomename = 'y',
    verbose = FALSE)

# the treatments include a score frame relating new
# derived variables to original columns
treatmentsN$scoreFrame[, c('origName', 'varName', 'code', 'rsq', 'sig', 'extraModelDegrees')] %.&gt;%
  print(.)

# the treated frame is a "cross frame" which
# is a transform of the training data built 
# as if the treatment were learned on a different
# disjoint training set to avoid nested model
# bias and over-fit.
dTrainNTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

# Any future application data is prepared with
# the prepare method.
dTestNTreated &lt;- prepare(treatmentsN, dTestN, pruneSig=NULL)

dTestNTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

</code></pre>

<hr>
<h2 id='multinomial_parameters'>vtreat multinomial parameters.</h2><span id='topic+multinomial_parameters'></span>

<h3>Description</h3>

<p>A list of settings and values for vtreat multinomial classification fitting. 
Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameMExperiment">mkCrossFrameMExperiment</a></code> and
<code><a href="#topic+prepare.multinomial_plan">prepare.multinomial_plan</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial_parameters(user_params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomial_parameters_+3A_user_params">user_params</code></td>
<td>
<p>list of user overrides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filled out parameter list
</p>

<hr>
<h2 id='MultinomialOutcomeTreatment'>Stateful object for designing and applying multinomial outcome treatments.</h2><span id='topic+MultinomialOutcomeTreatment'></span>

<h3>Description</h3>

<p>Hold settings and results for multinomial classification data preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultinomialOutcomeTreatment(
  ...,
  var_list,
  outcome_name,
  cols_to_copy = NULL,
  params = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_var_list">var_list</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_outcome_name">outcome_name</code></td>
<td>
<p>Name of column holding outcome variable. <code>dframe[[outcomename]]</code> must be only finite non-missing values.</p>
</td></tr>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_cols_to_copy">cols_to_copy</code></td>
<td>
<p>list of extra columns to copy.</p>
</td></tr>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_params">params</code></td>
<td>
<p>parameters list from <code>multinomial_parameters</code></p>
</td></tr>
<tr><td><code id="MultinomialOutcomeTreatment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameMExperiment">mkCrossFrameMExperiment</a></code> and
<code><a href="#topic+prepare.multinomial_plan">prepare.multinomial_plan</a></code> for details.
</p>
<p>Note: there currently is no <code>designTreatmentsM</code>, 
so <code>MultinomialOutcomeTreatment$fit()</code> is implemented in terms
of <code>MultinomialOutcomeTreatment$fit_transform()</code>
</p>

<hr>
<h2 id='novel_value_summary'>Report new/novel appearances of character values.</h2><span id='topic+novel_value_summary'></span>

<h3>Description</h3>

<p>Report new/novel appearances of character values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>novel_value_summary(dframe, trackedValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="novel_value_summary_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to inspect.</p>
</td></tr>
<tr><td><code id="novel_value_summary_+3A_trackedvalues">trackedValues</code></td>
<td>
<p>optional named list mapping variables to know values, allows warnings upon novel level appearances (see <code><a href="#topic+track_values">track_values</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>frame of novel occurrences
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+track_values">track_values</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23525)
zip &lt;- c(NA, paste('z', 1:10, sep = "_"))
N &lt;- 10
d &lt;- data.frame(zip = sample(zip, N, replace=TRUE),
                zip2 = sample(zip, N, replace=TRUE),
                y = runif(N))
dSample &lt;- d[1:5, , drop = FALSE]
trackedValues &lt;- track_values(dSample, c("zip", "zip2"))
novel_value_summary(d, trackedValues)

</code></pre>

<hr>
<h2 id='NumericOutcomeTreatment'>Stateful object for designing and applying numeric outcome treatments.</h2><span id='topic+NumericOutcomeTreatment'></span>

<h3>Description</h3>

<p>Hold settings and results for regression data preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumericOutcomeTreatment(
  ...,
  var_list,
  outcome_name,
  cols_to_copy = NULL,
  params = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NumericOutcomeTreatment_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="NumericOutcomeTreatment_+3A_var_list">var_list</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="NumericOutcomeTreatment_+3A_outcome_name">outcome_name</code></td>
<td>
<p>Name of column holding outcome variable. <code>dframe[[outcomename]]</code> must be only finite non-missing values.</p>
</td></tr>
<tr><td><code id="NumericOutcomeTreatment_+3A_cols_to_copy">cols_to_copy</code></td>
<td>
<p>list of extra columns to copy.</p>
</td></tr>
<tr><td><code id="NumericOutcomeTreatment_+3A_params">params</code></td>
<td>
<p>parameters list from <code>regression_parameters</code></p>
</td></tr>
<tr><td><code id="NumericOutcomeTreatment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameNExperiment">mkCrossFrameNExperiment</a></code>, 
<code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, and
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>

<hr>
<h2 id='oneWayHoldout'>One way holdout, a splitFunction in the sense of vtreat::buildEvalSets.</h2><span id='topic+oneWayHoldout'></span>

<h3>Description</h3>

<p>Note one way holdout can leak target expected values, so it should not
be preferred in nested modeling situations.
Also, doesn't respect nSplits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneWayHoldout(nRows, nSplits, dframe, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneWayHoldout_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to split (integer &gt;1).</p>
</td></tr>
<tr><td><code id="oneWayHoldout_+3A_nsplits">nSplits</code></td>
<td>
<p>number of groups to split into (ignored).</p>
</td></tr>
<tr><td><code id="oneWayHoldout_+3A_dframe">dframe</code></td>
<td>
<p>original data frame (ignored).</p>
</td></tr>
<tr><td><code id="oneWayHoldout_+3A_y">y</code></td>
<td>
<p>numeric outcome variable (ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>split plan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
oneWayHoldout(3,NULL,NULL,NULL)

</code></pre>

<hr>
<h2 id='patch_columns_into_frame'>Patch columns into data.frame.</h2><span id='topic+patch_columns_into_frame'></span>

<h3>Description</h3>

<p>Add columns from new_frame into old_frame, replacing any
columns with matching names in orig_frame with values from
new_frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_columns_into_frame(orig_frame, new_frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patch_columns_into_frame_+3A_orig_frame">orig_frame</code></td>
<td>
<p>data.frame to patch into.</p>
</td></tr>
<tr><td><code id="patch_columns_into_frame_+3A_new_frame">new_frame</code></td>
<td>
<p>data.frame to take replacement columns from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>patched data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
orig_frame &lt;- data.frame(x = 1, y = 2)
new_frame &lt;- data.frame(y = 3, z = 4)
patch_columns_into_frame(orig_frame, new_frame)

</code></pre>

<hr>
<h2 id='pre_comp_xval'>Pre-computed cross-plan (so same split happens each time).</h2><span id='topic+pre_comp_xval'></span>

<h3>Description</h3>

<p>Pre-computed cross-plan (so same split happens each time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_comp_xval(nRows, nSplits, splitplan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_comp_xval_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to split (integer &gt;1).</p>
</td></tr>
<tr><td><code id="pre_comp_xval_+3A_nsplits">nSplits</code></td>
<td>
<p>number of groups to split into (ignored).</p>
</td></tr>
<tr><td><code id="pre_comp_xval_+3A_splitplan">splitplan</code></td>
<td>
<p>split plan to actually use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splitplan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- oneWayHoldout(3,NULL,NULL,NULL)
p2 &lt;- pre_comp_xval(3, 3, p1)
p2(3, 3)

</code></pre>

<hr>
<h2 id='prepare'>Apply treatments and restrict to useful variables.</h2><span id='topic+prepare'></span>

<h3>Description</h3>

<p>Apply treatments and restrict to useful variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare(treatmentplan, dframe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_+3A_treatmentplan">treatmentplan</code></td>
<td>
<p>Plan built by designTreantmentsC() or designTreatmentsN()</p>
</td></tr>
<tr><td><code id="prepare_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to be treated</p>
</td></tr>
<tr><td><code id="prepare_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+prepare.simple_plan">prepare.simple_plan</a></code>, <code><a href="#topic+prepare.multinomial_plan">prepare.multinomial_plan</a></code>
</p>

<hr>
<h2 id='prepare.multinomial_plan'>Function to apply mkCrossFrameMExperiment treatemnts.</h2><span id='topic+prepare.multinomial_plan'></span>

<h3>Description</h3>

<p>Please see <code>vignette("MultiClassVtreat", package = "vtreat")</code> <a href="https://winvector.github.io/vtreat/articles/MultiClassVtreat.html">https://winvector.github.io/vtreat/articles/MultiClassVtreat.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multinomial_plan'
prepare(
  treatmentplan,
  dframe,
  ...,
  pruneSig = NULL,
  scale = FALSE,
  doCollar = FALSE,
  varRestriction = NULL,
  codeRestriction = NULL,
  trackedValues = NULL,
  extracols = NULL,
  parallelCluster = NULL,
  use_parallel = TRUE,
  check_for_duplicate_frames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.multinomial_plan_+3A_treatmentplan">treatmentplan</code></td>
<td>
<p>multinomial_plan from mkCrossFrameMExperiment.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_dframe">dframe</code></td>
<td>
<p>new data to process.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_...">...</code></td>
<td>
<p>not used, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_prunesig">pruneSig</code></td>
<td>
<p>suppress variables with significance above this level</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with single variable model regressions (&quot;move to outcome-scale&quot;).  These have mean zero and (for variables with significant less than 1) slope 1 when regressed  (lm for regression problems/glm for classification problems) against outcome.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_varrestriction">varRestriction</code></td>
<td>
<p>optional list of treated variable names to restrict to</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>optional list of treated variable codes to restrict to</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_trackedvalues">trackedValues</code></td>
<td>
<p>optional named list mapping variables to know values, allows warnings upon novel level appearances (see <code><a href="#topic+track_values">track_values</a></code>)</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_extracols">extracols</code></td>
<td>
<p>extra columns to copy.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="prepare.multinomial_plan_+3A_check_for_duplicate_frames">check_for_duplicate_frames</code></td>
<td>
<p>logical, if TRUE check if we called prepare on same data.frame as design step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prepared data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkCrossFrameMExperiment">mkCrossFrameMExperiment</a></code>, <code><a href="#topic+prepare">prepare</a></code>
</p>

<hr>
<h2 id='prepare.simple_plan'>Prepare a simple treatment.</h2><span id='topic+prepare.simple_plan'></span>

<h3>Description</h3>

<p>Prepare a simple treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simple_plan'
prepare(treatmentplan, dframe, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.simple_plan_+3A_treatmentplan">treatmentplan</code></td>
<td>
<p>A simple treatment plan.</p>
</td></tr>
<tr><td><code id="prepare.simple_plan_+3A_dframe">dframe</code></td>
<td>
<p>data.frame to be treated.</p>
</td></tr>
<tr><td><code id="prepare.simple_plan_+3A_...">...</code></td>
<td>
<p>not used, present for S3 signature consistency.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+design_missingness_treatment">design_missingness_treatment</a></code>, <code><a href="#topic+prepare">prepare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "x1", "x2", "x3" |
  1   , 4   , "A"  |
  NA  , 5   , "B"  |
  3   , 6   , NA   )

plan &lt;- design_missingness_treatment(d)
prepare(plan, d)

prepare(plan, data.frame(x1=NA, x2=NA, x3="E"))

</code></pre>

<hr>
<h2 id='prepare.treatmentplan'>Apply treatments and restrict to useful variables.</h2><span id='topic+prepare.treatmentplan'></span>

<h3>Description</h3>

<p>Use a treatment plan to prepare a data frame for analysis.  The
resulting frame will have new effective variables that are numeric
and free of NaN/NA.  If the outcome column is present it will be copied over.
The intent is that these frames are compatible with more machine learning
techniques, and avoid a lot of corner cases (NA,NaN, novel levels, too many levels).
Note: each column is processed independently of all others.  Also copies over outcome if present.
Note: treatmentplan's are not meant for long-term storage, a warning is issued if the version of
vtreat that produced the plan differs from the version running <code>prepare()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treatmentplan'
prepare(
  treatmentplan,
  dframe,
  ...,
  pruneSig = NULL,
  scale = FALSE,
  doCollar = FALSE,
  varRestriction = NULL,
  codeRestriction = NULL,
  trackedValues = NULL,
  extracols = NULL,
  parallelCluster = NULL,
  use_parallel = TRUE,
  check_for_duplicate_frames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.treatmentplan_+3A_treatmentplan">treatmentplan</code></td>
<td>
<p>Plan built by designTreantmentsC() or designTreatmentsN()</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to be treated</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_prunesig">pruneSig</code></td>
<td>
<p>suppress variables with significance above this level</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with single variable model regressions (&quot;move to outcome-scale&quot;).  These have mean zero and (for variables with significant less than 1) slope 1 when regressed  (lm for regression problems/glm for classification problems) against outcome.</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_varrestriction">varRestriction</code></td>
<td>
<p>optional list of treated variable names to restrict to</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>optional list of treated variable codes to restrict to</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_trackedvalues">trackedValues</code></td>
<td>
<p>optional named list mapping variables to know values, allows warnings upon novel level appearances (see <code><a href="#topic+track_values">track_values</a></code>)</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_extracols">extracols</code></td>
<td>
<p>extra columns to copy.</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="prepare.treatmentplan_+3A_check_for_duplicate_frames">check_for_duplicate_frames</code></td>
<td>
<p>logical, if TRUE check if we called prepare on same data.frame as design step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>treated data frame (all columns numeric- without NA, NaN)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>, <code><a href="#topic+mkCrossFrameNExperiment">mkCrossFrameNExperiment</a></code>, <code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code> <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code> <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, <code><a href="#topic+prepare">prepare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# categorical example
set.seed(23525)

# we set up our raw training and application data
dTrainC &lt;- data.frame(
  x = c('a', 'a', 'a', 'b', 'b', NA, NA),
  z = c(1, 2, 3, 4, NA, 6, NA),
  y = c(FALSE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE))

dTestC &lt;- data.frame(
  x = c('a', 'b', 'c', NA), 
  z = c(10, 20, 30, NA))

# we perform a vtreat cross frame experiment
# and unpack the results into treatmentsC
# and dTrainCTreated
unpack[
  treatmentsC = treatments,
  dTrainCTreated = crossFrame
  ] &lt;- mkCrossFrameCExperiment(
    dframe = dTrainC,
    varlist = setdiff(colnames(dTrainC), 'y'),
    outcomename = 'y',
    outcometarget = TRUE,
    verbose = FALSE)

# the treatments include a score frame relating new
# derived variables to original columns
treatmentsC$scoreFrame[, c('origName', 'varName', 'code', 'rsq', 'sig', 'extraModelDegrees')] %.&gt;%
  print(.)

# the treated frame is a "cross frame" which
# is a transform of the training data built 
# as if the treatment were learned on a different
# disjoint training set to avoid nested model
# bias and over-fit.
dTrainCTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

# Any future application data is prepared with
# the prepare method.
dTestCTreated &lt;- prepare(treatmentsC, dTestC, pruneSig=NULL)

dTestCTreated %.&gt;%
  head(.) %.&gt;%
  print(.)

</code></pre>

<hr>
<h2 id='print.multinomial_plan'>Print treatmentplan.</h2><span id='topic+print.multinomial_plan'></span>

<h3>Description</h3>

<p>Print treatmentplan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multinomial_plan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.multinomial_plan_+3A_x">x</code></td>
<td>
<p>treatmentplan</p>
</td></tr>
<tr><td><code id="print.multinomial_plan_+3A_...">...</code></td>
<td>
<p>additional args (to match general signature).</p>
</td></tr>
</table>

<hr>
<h2 id='print.simple_plan'>Print treatmentplan.</h2><span id='topic+print.simple_plan'></span>

<h3>Description</h3>

<p>Print treatmentplan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simple_plan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.simple_plan_+3A_x">x</code></td>
<td>
<p>treatmentplan</p>
</td></tr>
<tr><td><code id="print.simple_plan_+3A_...">...</code></td>
<td>
<p>additional args (to match general signature).</p>
</td></tr>
</table>

<hr>
<h2 id='print.treatmentplan'>Print treatmentplan.</h2><span id='topic+print.treatmentplan'></span>

<h3>Description</h3>

<p>Print treatmentplan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treatmentplan'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.treatmentplan_+3A_x">x</code></td>
<td>
<p>treatmentplan</p>
</td></tr>
<tr><td><code id="print.treatmentplan_+3A_...">...</code></td>
<td>
<p>additional args (to match general signature).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>
</p>

<hr>
<h2 id='print.vtreatment'>Print treatmentplan.</h2><span id='topic+print.vtreatment'></span>

<h3>Description</h3>

<p>Print treatmentplan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vtreatment'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.vtreatment_+3A_x">x</code></td>
<td>
<p>treatmentplan</p>
</td></tr>
<tr><td><code id="print.vtreatment_+3A_...">...</code></td>
<td>
<p>additional args (to match general signature).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>, <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>
</p>

<hr>
<h2 id='problemAppPlan'>check if appPlan is a good carve-up of 1:nRows into nSplits groups</h2><span id='topic+problemAppPlan'></span>

<h3>Description</h3>

<p>check if appPlan is a good carve-up of 1:nRows into nSplits groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problemAppPlan(nRows, nSplits, appPlan, strictCheck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problemAppPlan_+3A_nrows">nRows</code></td>
<td>
<p>number of rows to carve-up</p>
</td></tr>
<tr><td><code id="problemAppPlan_+3A_nsplits">nSplits</code></td>
<td>
<p>number of sets to carve-up into</p>
</td></tr>
<tr><td><code id="problemAppPlan_+3A_appplan">appPlan</code></td>
<td>
<p>carve-up to critique</p>
</td></tr>
<tr><td><code id="problemAppPlan_+3A_strictcheck">strictCheck</code></td>
<td>
<p>logical, if true expect application data to be a carve-up and training data to be a maximal partition and to match nSplits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>problem with carve-up (null if good)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kWayCrossValidation">kWayCrossValidation</a></code>, <code><a href="#topic+kWayStratifiedY">kWayStratifiedY</a></code>, and <code><a href="#topic+makekWayCrossValidationGroupedByColumn">makekWayCrossValidationGroupedByColumn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plan &lt;- kWayStratifiedY(3,2,NULL,NULL)
problemAppPlan(3,3,plan,TRUE)

</code></pre>

<hr>
<h2 id='regression_parameters'>vtreat regression parameters.</h2><span id='topic+regression_parameters'></span>

<h3>Description</h3>

<p>A list of settings and values for vtreat regression fitting. 
Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+mkCrossFrameCExperiment">mkCrossFrameCExperiment</a></code>, 
<code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code>, and
<code><a href="#topic+mkCrossFrameNExperiment">mkCrossFrameNExperiment</a></code>, 
<code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code>,
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regression_parameters(user_params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression_parameters_+3A_user_params">user_params</code></td>
<td>
<p>list of user overrides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filled out parameter list
</p>

<hr>
<h2 id='rqdatatable_prepare'>Apply a treatment plan using rqdatatable.</h2><span id='topic+rqdatatable_prepare'></span>

<h3>Description</h3>

<p>Note: does not treat map NaN or +-Infinity.  
This function is only for timings and demonstration, not for production use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqdatatable_prepare(
  rqplan,
  data_source,
  ...,
  partition_column = NULL,
  parallelCluster = NULL,
  use_parallel = use_parallel,
  extracols = NULL,
  non_join_mapping = FALSE,
  print_rquery = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rqdatatable_prepare_+3A_rqplan">rqplan</code></td>
<td>
<p>an query plan produced by as_rquery_plan().</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_data_source">data_source</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_partition_column">partition_column</code></td>
<td>
<p>character name of column to partition work by.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>a cluster object, created by package parallel or by package snow. If NULL, use the registered default cluster.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel cluster (when available).</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_extracols">extracols</code></td>
<td>
<p>extra columns to copy.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_non_join_mapping">non_join_mapping</code></td>
<td>
<p>logical, if TRUE use non-join based column mapping.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_print_rquery">print_rquery</code></td>
<td>
<p>logical, if TRUE print the rquery ops.</p>
</td></tr>
<tr><td><code id="rqdatatable_prepare_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>treated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_rquery_plan">as_rquery_plan</a></code>, <code><a href="#topic+rquery_prepare">rquery_prepare</a></code>
</p>

<hr>
<h2 id='rquery_prepare'>Materialize a treated data frame remotely.</h2><span id='topic+rquery_prepare'></span><span id='topic+materialize_treated'></span>

<h3>Description</h3>

<p>Materialize a treated data frame remotely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rquery_prepare(
  db,
  rqplan,
  data_source,
  result_table_name,
  ...,
  extracols = NULL,
  temporary = FALSE,
  overwrite = TRUE,
  attempt_nan_inf_mapping = FALSE,
  col_sample = NULL,
  return_ops = FALSE
)

materialize_treated(
  db,
  rqplan,
  data_source,
  result_table_name,
  ...,
  extracols = NULL,
  temporary = FALSE,
  overwrite = TRUE,
  attempt_nan_inf_mapping = FALSE,
  col_sample = NULL,
  return_ops = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rquery_prepare_+3A_db">db</code></td>
<td>
<p>a db handle.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_rqplan">rqplan</code></td>
<td>
<p>an query plan produced by as_rquery_plan().</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_data_source">data_source</code></td>
<td>
<p>relop, data source (usually a relop_table_source).</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_result_table_name">result_table_name</code></td>
<td>
<p>character, table name to land result in</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_extracols">extracols</code></td>
<td>
<p>extra columns to copy.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE try to make result temporary.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_overwrite">overwrite</code></td>
<td>
<p>logical, if TRUE try to overwrite result.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_attempt_nan_inf_mapping">attempt_nan_inf_mapping</code></td>
<td>
<p>logical, if TRUE attempt to map NaN and Infnity to NA/NULL (goot on PostgreSQL, not on Spark).</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_col_sample">col_sample</code></td>
<td>
<p>sample of data to determine column types.</p>
</td></tr>
<tr><td><code id="rquery_prepare_+3A_return_ops">return_ops</code></td>
<td>
<p>logical, if TRUE return operator tree instead of materializing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description of treated table.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>materialize_treated()</code>: old name for rquery_prepare function
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+as_rquery_plan">as_rquery_plan</a></code>, <code><a href="#topic+rqdatatable_prepare">rqdatatable_prepare</a></code>
</p>

<hr>
<h2 id='solve_piecewise'>Solve as piecewise linear problem, numeric target.</h2><span id='topic+solve_piecewise'></span>

<h3>Description</h3>

<p>Return a vector of length y that is a piecewise function of x.
This vector is picked as close to
y (by square-distance) as possible for a set of x-only determined
cut-points.  Cross-validates for a good number of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_piecewise(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_piecewise_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="solve_piecewise_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="solve_piecewise_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="solve_piecewise_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>segmented y prediction
</p>

<hr>
<h2 id='solve_piecewisec'>Solve as piecewise logit problem, categorical target.</h2><span id='topic+solve_piecewisec'></span>

<h3>Description</h3>

<p>Return a vector of length y that is a piecewise function of x.
This vector is picked as close to
y (by square-distance) as possible for a set of x-only determined
cut-points.  Cross-validates for a good number of segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_piecewisec(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_piecewisec_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="solve_piecewisec_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="solve_piecewisec_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="solve_piecewisec_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>segmented y prediction
</p>

<hr>
<h2 id='spline_variable'>Spline variable numeric target.</h2><span id='topic+spline_variable'></span>

<h3>Description</h3>

<p>Return a spline approximation of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_variable(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_variable_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="spline_variable_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="spline_variable_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="spline_variable_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spline y prediction
</p>

<hr>
<h2 id='spline_variablec'>Spline variable categorical target.</h2><span id='topic+spline_variablec'></span>

<h3>Description</h3>

<p>Return a spline approximation of the change in log odds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_variablec(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_variablec_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="spline_variablec_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="spline_variablec_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="spline_variablec_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spline y prediction
</p>

<hr>
<h2 id='square_window'>Build a square windows variable, numeric target.</h2><span id='topic+square_window'></span>

<h3>Description</h3>

<p>Build a square moving average window (KNN in 1d).  This is a high-frequency feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>square_window(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square_window_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="square_window_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="square_window_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="square_window_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL) IGNORED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>segmented y prediction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = c(NA, 1:6), y = c(0, 0, 0, 1, 1, 0, 0))
square_window("v", d$x, d$y)


</code></pre>

<hr>
<h2 id='square_windowc'>Build a square windows variable, categorical target.</h2><span id='topic+square_windowc'></span>

<h3>Description</h3>

<p>Build a square moving average window (KNN in 1d).  This is a high-frequency feature.
Approximation of the change in log odds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>square_windowc(varName, x, y, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="square_windowc_+3A_varname">varName</code></td>
<td>
<p>character, name of variable</p>
</td></tr>
<tr><td><code id="square_windowc_+3A_x">x</code></td>
<td>
<p>numeric input (not empty, no NAs).</p>
</td></tr>
<tr><td><code id="square_windowc_+3A_y">y</code></td>
<td>
<p>numeric or castable to such (same length as x no NAs), output to match</p>
</td></tr>
<tr><td><code id="square_windowc_+3A_w">w</code></td>
<td>
<p>numeric positive, same length as x (weights, can be NULL) IGNORED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>segmented y prediction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = c(NA, 1:6), y = c(0, 0, 0, 1, 1, 0, 0))
square_window("v", d$x, d$y)


</code></pre>

<hr>
<h2 id='track_values'>Track unique character values for variables.</h2><span id='topic+track_values'></span>

<h3>Description</h3>

<p>Builds lists of observed unique character values of varlist variables from the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_values(dframe, varlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_values_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="track_values_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of values seen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>, <code><a href="#topic+novel_value_summary">novel_value_summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(23525)
zip &lt;- c(NA, paste('z', 1:100, sep = "_"))
N &lt;- 500
d &lt;- data.frame(zip = sample(zip, N, replace=TRUE),
                zip2 = sample(zip, N, replace=TRUE),
                y = runif(N))
dSample &lt;- d[1:300, , drop = FALSE]
tplan &lt;- designTreatmentsN(dSample, 
                           c("zip", "zip2"), "y", 
                           verbose = FALSE)
trackedValues &lt;- track_values(dSample, c("zip", "zip2"))
# don't normally want to catch warnings,
# doing it here as this is an example 
# and must not have unhandled warnings.
tryCatch(
  prepare(tplan, d, trackedValues = trackedValues),
  warning = function(w) { cat(paste(w, collapse = "\n")) })

</code></pre>

<hr>
<h2 id='unsupervised_parameters'>vtreat unsupervised parameters.</h2><span id='topic+unsupervised_parameters'></span>

<h3>Description</h3>

<p>A list of settings and values for vtreat unsupervised fitting. 
Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>, and
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsupervised_parameters(user_params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsupervised_parameters_+3A_user_params">user_params</code></td>
<td>
<p>list of user overrides.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filled out parameter list
</p>

<hr>
<h2 id='UnsupervisedTreatment'>Stateful object for designing and applying unsupervised treatments.</h2><span id='topic+UnsupervisedTreatment'></span>

<h3>Description</h3>

<p>Hold settings and results for unsupervised data preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnsupervisedTreatment(
  ...,
  var_list,
  cols_to_copy = NULL,
  params = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnsupervisedTreatment_+3A_...">...</code></td>
<td>
<p>not used, force arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="UnsupervisedTreatment_+3A_var_list">var_list</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="UnsupervisedTreatment_+3A_cols_to_copy">cols_to_copy</code></td>
<td>
<p>list of extra columns to copy.</p>
</td></tr>
<tr><td><code id="UnsupervisedTreatment_+3A_params">params</code></td>
<td>
<p>parameters list from <code>unsupervised_parameters</code></p>
</td></tr>
<tr><td><code id="UnsupervisedTreatment_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see
<a href="https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md">https://github.com/WinVector/vtreat/blob/main/Examples/fit_transform/fit_transform_api.md</a>,
<code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code> and
<code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code> for details.
</p>
<p>Note: for <code>UnsupervisedTreatment</code> <code>fit_transform(d)</code> is implemented
as <code>fit(d)$transform(d)</code>.
</p>

<hr>
<h2 id='value_variables_C'>Value variables for prediction a categorical outcome.</h2><span id='topic+value_variables_C'></span>

<h3>Description</h3>

<p>Value variables for prediction a categorical outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_variables_C(
  dframe,
  varlist,
  outcomename,
  outcometarget,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = 1,
  collarProb = 0,
  scale = FALSE,
  doCollar = FALSE,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  catScaling = TRUE,
  verbose = FALSE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  customCoders = list(c.PiecewiseV.num = vtreat::solve_piecewisec, n.PiecewiseV.num =
    vtreat::solve_piecewise, c.knearest.num = vtreat::square_windowc, n.knearest.num =
    vtreat::square_window),
  codeRestriction = c("PiecewiseV", "knearest", "clean", "isBAD", "catB", "catP"),
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_variables_C_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_outcometarget">outcometarget</code></td>
<td>
<p>Value/level of outcome to be considered &quot;success&quot;,  and there must be a cut such that dframe[[outcomename]]==outcometarget at least twice and dframe[[outcomename]]!=outcometarget at least twice.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with regression (&quot;move to outcome-scale&quot;).</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar&gt;=2 number of cross-validation rounds to design.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_catscaling">catScaling</code></td>
<td>
<p>optional, if TRUE use glm() linkspace, if FALSE use lm() for scaling.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_customcoders">customCoders</code></td>
<td>
<p>additional coders to use for variable importance estimate.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>codes to restrict to for variable importance estimate.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="value_variables_C_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table of variable valuations
</p>

<hr>
<h2 id='value_variables_N'>Value variables for prediction a numeric outcome.</h2><span id='topic+value_variables_N'></span>

<h3>Description</h3>

<p>Value variables for prediction a numeric outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value_variables_N(
  dframe,
  varlist,
  outcomename,
  ...,
  weights = c(),
  minFraction = 0.02,
  smFactor = 0,
  rareCount = 0,
  rareSig = 1,
  collarProb = 0,
  scale = FALSE,
  doCollar = FALSE,
  splitFunction = NULL,
  ncross = 3,
  forceSplit = FALSE,
  verbose = FALSE,
  parallelCluster = NULL,
  use_parallel = TRUE,
  customCoders = list(c.PiecewiseV.num = vtreat::solve_piecewisec, n.PiecewiseV.num =
    vtreat::solve_piecewise, c.knearest.num = vtreat::square_windowc, n.knearest.num =
    vtreat::square_window),
  codeRestriction = c("PiecewiseV", "knearest", "clean", "isBAD", "catB", "catP"),
  missingness_imputation = NULL,
  imputation_map = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_variables_N_+3A_dframe">dframe</code></td>
<td>
<p>Data frame to learn treatments from (training data), must have at least 1 row.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_varlist">varlist</code></td>
<td>
<p>Names of columns to treat (effective variables).</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_outcomename">outcomename</code></td>
<td>
<p>Name of column holding outcome variable. dframe[[outcomename]] must be only finite non-missing values and there must be a cut such that dframe[[outcomename]] is both above the cut at least twice and below the cut at least twice.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_...">...</code></td>
<td>
<p>no additional arguments, declared to forced named binding of later arguments</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_weights">weights</code></td>
<td>
<p>optional training weights for each row</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_minfraction">minFraction</code></td>
<td>
<p>optional minimum frequency a categorical level must have to be converted to an indicator column.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_smfactor">smFactor</code></td>
<td>
<p>optional smoothing factor for impact coding models.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_rarecount">rareCount</code></td>
<td>
<p>optional integer, allow levels with this count or below to be pooled into a shared rare-level.  Defaults to 0 or off.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_raresig">rareSig</code></td>
<td>
<p>optional numeric, suppress levels from pooling at this significance value greater.  Defaults to NULL or off.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_collarprob">collarProb</code></td>
<td>
<p>what fraction of the data (pseudo-probability) to collar data at if doCollar is set during <code><a href="#topic+prepare.treatmentplan">prepare.treatmentplan</a></code>.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_scale">scale</code></td>
<td>
<p>optional if TRUE replace numeric variables with regression (&quot;move to outcome-scale&quot;).</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_docollar">doCollar</code></td>
<td>
<p>optional if TRUE collar numeric variables by cutting off after a tail-probability specified by collarProb during treatment design.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_splitfunction">splitFunction</code></td>
<td>
<p>(optional) see vtreat::buildEvalSets .</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_ncross">ncross</code></td>
<td>
<p>optional scalar&gt;=2 number of cross-validation rounds to design.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_forcesplit">forceSplit</code></td>
<td>
<p>logical, if TRUE force cross-validated significance calculations on all variables.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print progress.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_parallelcluster">parallelCluster</code></td>
<td>
<p>(optional) a cluster object created by package parallel or package snow.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_use_parallel">use_parallel</code></td>
<td>
<p>logical, if TRUE use parallel methods.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_customcoders">customCoders</code></td>
<td>
<p>additional coders to use for variable importance estimate.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_coderestriction">codeRestriction</code></td>
<td>
<p>codes to restrict to for variable importance estimate.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_missingness_imputation">missingness_imputation</code></td>
<td>
<p>function of signature f(values: numeric, weights: numeric), simple missing value imputer.</p>
</td></tr>
<tr><td><code id="value_variables_N_+3A_imputation_map">imputation_map</code></td>
<td>
<p>map from column names to functions of signature f(values: numeric, weights: numeric), simple missing value imputers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table of variable valuations
</p>

<hr>
<h2 id='variable_values'>Return variable evaluations.</h2><span id='topic+variable_values'></span>

<h3>Description</h3>

<p>Return variable evaluations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_values(sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_values_+3A_sf">sf</code></td>
<td>
<p>scoreFrame from from vtreat treatments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>per-original varaible evaluations
</p>

<hr>
<h2 id='vnames'>New treated variable names from a treatmentplan$treatment item.</h2><span id='topic+vnames'></span>

<h3>Description</h3>

<p>New treated variable names from a treatmentplan$treatment item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vnames_+3A_x">x</code></td>
<td>
<p>vtreatment item</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code> <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code> <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>
</p>

<hr>
<h2 id='vorig'>Original variable name from a treatmentplan$treatment item.</h2><span id='topic+vorig'></span>

<h3>Description</h3>

<p>Original variable name from a treatmentplan$treatment item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorig(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorig_+3A_x">x</code></td>
<td>
<p>vtreatment item.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+designTreatmentsC">designTreatmentsC</a></code> <code><a href="#topic+designTreatmentsN">designTreatmentsN</a></code> <code><a href="#topic+designTreatmentsZ">designTreatmentsZ</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
