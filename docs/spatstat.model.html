<!DOCTYPE html><html><head><title>Help for package spatstat.model</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.model}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addvar'>
<p>Added Variable Plot for Point Process Model</p></a></li>
<li><a href='#anova.mppm'><p>ANOVA for Fitted Point Process Models for Replicated Patterns</p></a></li>
<li><a href='#anova.ppm'><p>ANOVA for Fitted Point Process Models</p></a></li>
<li><a href='#anova.slrm'>
<p>Analysis of Deviance for Spatial Logistic Regression Models</p></a></li>
<li><a href='#AreaInter'><p>The Area Interaction Point Process Model</p></a></li>
<li><a href='#as.function.leverage.ppm'>
<p>Convert Leverage Object to Function of Coordinates</p></a></li>
<li><a href='#as.fv.kppm'><p>Convert Fitted Model To Class fv</p></a></li>
<li><a href='#as.interact'><p>Extract Interaction Structure</p></a></li>
<li><a href='#as.layered.msr'><p>Convert Measure To Layered Object</p></a></li>
<li><a href='#as.owin.ppm'><p>Convert Data To Class owin</p></a></li>
<li><a href='#as.ppm'><p>Extract Fitted Point Process Model</p></a></li>
<li><a href='#auc.ppm'>
<p>Area Under ROC Curve</p></a></li>
<li><a href='#BadGey'><p>Hybrid Geyer Point Process Model</p></a></li>
<li><a href='#bc.ppm'>
<p>Bias Correction for Fitted Model</p></a></li>
<li><a href='#berman.test.ppm'><p>Berman's Tests for Point Process Model</p></a></li>
<li><a href='#cauchy.estK'><p>Fit the Neyman-Scott cluster process with Cauchy kernel</p></a></li>
<li><a href='#cauchy.estpcf'><p>Fit the Neyman-Scott cluster process with Cauchy kernel</p></a></li>
<li><a href='#cdf.test.mppm'><p>Spatial Distribution Test for Multiple Point Process Model</p></a></li>
<li><a href='#cdf.test.ppm'><p>Spatial Distribution Test for Point Pattern or Point Process Model</p></a></li>
<li><a href='#closepaircounts'>
<p>Count Close Pairs of Points</p></a></li>
<li><a href='#clusterfield.kppm'><p>Field of clusters</p></a></li>
<li><a href='#clusterfit'><p>Fit Cluster or Cox Point Process Model via Minimum Contrast</p></a></li>
<li><a href='#clusterkernel.kppm'>
<p>Extract Cluster Offspring Kernel</p></a></li>
<li><a href='#clusterradius.kppm'>
<p>Compute or Extract Effective Range of Cluster Kernel</p></a></li>
<li><a href='#coef.mppm'>
<p>Coefficients of Point Process Model Fitted to Multiple Point Patterns</p></a></li>
<li><a href='#coef.ppm'>
<p>Coefficients of Fitted Point Process Model</p></a></li>
<li><a href='#coef.slrm'>
<p>Coefficients of Fitted Spatial Logistic Regression Model</p></a></li>
<li><a href='#compareFit'>
<p>Residual Diagnostics for Multiple Fitted Models</p></a></li>
<li><a href='#Concom'><p>The Connected Component Process Model</p></a></li>
<li><a href='#data.ppm'><p>Extract Original Data from a Fitted Point Process Model</p></a></li>
<li><a href='#detpointprocfamilyfun'><p>Construct a New Determinantal Point Process Model Family Function</p></a></li>
<li><a href='#dfbetas.ppm'>
<p>Parameter Influence Measure</p></a></li>
<li><a href='#dffit.ppm'>
<p>Case Deletion Effect Measure of Fitted Model</p></a></li>
<li><a href='#diagnose.ppm'>
<p>Diagnostic Plots for Fitted Point Process Model</p></a></li>
<li><a href='#DiggleGatesStibbard'><p>Diggle-Gates-Stibbard Point Process Model</p></a></li>
<li><a href='#DiggleGratton'><p>Diggle-Gratton model</p></a></li>
<li><a href='#dim.detpointprocfamily'><p>Dimension of Determinantal Point Process Model</p></a></li>
<li><a href='#domain.ppm'>
<p>Extract the Domain of any Spatial Object</p></a></li>
<li><a href='#dppapproxkernel'><p>Approximate Determinantal Point Process Kernel</p></a></li>
<li><a href='#dppapproxpcf'><p>Approximate Pair Correlation Function of Determinantal Point Process Model</p></a></li>
<li><a href='#dppBessel'><p>Bessel Type Determinantal Point Process Model</p></a></li>
<li><a href='#dppCauchy'><p>Generalized Cauchy Determinantal Point Process Model</p></a></li>
<li><a href='#dppeigen'><p>Internal function calculating eig and index</p></a></li>
<li><a href='#dppGauss'><p>Gaussian Determinantal Point Process Model</p></a></li>
<li><a href='#dppkernel'><p>Extract Kernel from Determinantal Point Process Model Object</p></a></li>
<li><a href='#dppm'><p>Fit Determinantal Point Process Model</p></a></li>
<li><a href='#dppMatern'><p>Whittle-Matern Determinantal Point Process Model</p></a></li>
<li><a href='#dppparbounds'><p>Parameter Bound for a Determinantal Point Process Model</p></a></li>
<li><a href='#dppPowerExp'><p>Power Exponential Spectral Determinantal Point Process Model</p></a></li>
<li><a href='#dppspecden'><p>Extract Spectral Density from Determinantal Point Process Model Object</p></a></li>
<li><a href='#dppspecdenrange'><p>Range of Spectral Density of a Determinantal Point Process Model</p></a></li>
<li><a href='#dummify'>
<p>Convert Data to Numeric Values by Constructing Dummy Variables</p></a></li>
<li><a href='#dummy.ppm'><p>Extract Dummy Points Used to Fit a Point Process Model</p></a></li>
<li><a href='#eem'>
<p>Exponential Energy Marks</p></a></li>
<li><a href='#effectfun'><p>Compute Fitted Effect of a Spatial Covariate in a Point Process Model</p></a></li>
<li><a href='#emend'>
<p>Force Model to be Valid</p></a></li>
<li><a href='#emend.ppm'>
<p>Force Point Process Model to be Valid</p></a></li>
<li><a href='#emend.slrm'>
<p>Force Spatial Logistic Regression Model to be Valid</p></a></li>
<li><a href='#envelope.ppm'><p>Simulation Envelopes of Summary Function</p></a></li>
<li><a href='#exactMPLEstrauss'>
<p>Exact Maximum Pseudolikelihood Estimate for Stationary Strauss Process</p></a></li>
<li><a href='#Extract.influence.ppm'><p>Extract Subset of Influence Object</p></a></li>
<li><a href='#Extract.leverage.ppm'><p>Extract Subset of Leverage Object</p></a></li>
<li><a href='#Extract.msr'><p>Extract Subset of Signed or Vector Measure</p></a></li>
<li><a href='#Fiksel'><p>The Fiksel Interaction</p></a></li>
<li><a href='#fitin.ppm'><p>Extract the Interaction from a Fitted Point Process Model</p></a></li>
<li><a href='#fitted.mppm'><p>Fitted Conditional Intensity for Multiple Point Process Model</p></a></li>
<li><a href='#fitted.ppm'>
<p>Fitted Conditional Intensity for Point Process Model</p></a></li>
<li><a href='#fitted.slrm'>
<p>Fitted Probabilities for Spatial Logistic Regression</p></a></li>
<li><a href='#fixef.mppm'>
<p>Extract Fixed Effects from Point Process Model</p></a></li>
<li><a href='#formula.ppm'>
<p>Model Formulae for Gibbs Point Process Models</p></a></li>
<li><a href='#Gcom'>
<p>Model Compensator of Nearest Neighbour Function</p></a></li>
<li><a href='#Geyer'><p>Geyer's Saturation Point Process Model</p></a></li>
<li><a href='#Gres'>
<p>Residual G Function</p></a></li>
<li><a href='#Hardcore'><p>The Hard Core Point Process Model</p></a></li>
<li><a href='#hardcoredist'>
<p>Extract the Hard Core Distance of a Point Process Model</p></a></li>
<li><a href='#harmonic'><p>Basis for Harmonic Functions</p></a></li>
<li><a href='#harmonise.msr'><p>Make Measures Compatible</p></a></li>
<li><a href='#HierHard'><p>The Hierarchical  Hard Core Point Process Model</p></a></li>
<li><a href='#hierpair.family'><p>Hierarchical Pairwise Interaction Process Family</p></a></li>
<li><a href='#HierStrauss'><p>The Hierarchical Strauss Point Process Model</p></a></li>
<li><a href='#HierStraussHard'><p>The Hierarchical Strauss Hard Core Point Process Model</p></a></li>
<li><a href='#Hybrid'>
<p>Hybrid Interaction Point Process Model</p></a></li>
<li><a href='#hybrid.family'>
<p>Hybrid Interaction Family</p></a></li>
<li><a href='#ic.kppm'><p>Model selection criteria for the intensity function of a point process</p></a></li>
<li><a href='#improve.kppm'><p>Improve Intensity Estimate of Fitted Cluster Point Process Model</p></a></li>
<li><a href='#influence.ppm'>
<p>Influence Measure for Spatial Point Process Model</p></a></li>
<li><a href='#inforder.family'><p>Infinite Order Interaction Family</p></a></li>
<li><a href='#integral.msr'>
<p>Integral of a Measure</p></a></li>
<li><a href='#intensity.dppm'><p>Intensity of Determinantal Point Process Model</p></a></li>
<li><a href='#intensity.ppm'>
<p>Intensity of Fitted Point Process Model</p></a></li>
<li><a href='#intensity.slrm'>
<p>Intensity of Fitted Spatial Logistic Regression Model</p></a></li>
<li><a href='#interactionorder'>
<p>Determine the Order of Interpoint Interaction in a Model</p></a></li>
<li><a href='#ippm'>
<p>Fit Point Process Model Involving Irregular Trend Parameters</p></a></li>
<li><a href='#is.dppm'><p>Recognise Fitted Determinantal Point Process Models</p></a></li>
<li><a href='#is.hybrid'>
<p>Test Whether Object is a Hybrid</p></a></li>
<li><a href='#is.marked.ppm'><p>Test Whether A Point Process Model is Marked</p></a></li>
<li><a href='#is.multitype.ppm'><p>Test Whether A Point Process Model is Multitype</p></a></li>
<li><a href='#is.poissonclusterprocess'>
<p>Recognise Poisson Cluster Process Models</p></a></li>
<li><a href='#is.ppm'><p>Test Whether An Object Is A Fitted Point Process Model</p></a></li>
<li><a href='#is.stationary.ppm'>
<p>Recognise Stationary and Poisson Point Process Models</p></a></li>
<li><a href='#isf.object'><p>Interaction Structure Family Objects</p></a></li>
<li><a href='#Kcom'>
<p>Model Compensator of K Function</p></a></li>
<li><a href='#Kmodel'><p>K Function or Pair Correlation Function of a Point Process Model</p></a></li>
<li><a href='#Kmodel.dppm'>
<p>K-function or Pair Correlation Function of a</p>
Determinantal Point Process Model</a></li>
<li><a href='#Kmodel.kppm'><p>K Function or Pair Correlation Function of Cluster Model or Cox model</p></a></li>
<li><a href='#Kmodel.ppm'><p>K Function or Pair Correlation Function of Gibbs Point Process model</p></a></li>
<li><a href='#kppm'><p>Fit Cluster or Cox Point Process Model</p></a></li>
<li><a href='#Kres'>
<p>Residual K Function</p></a></li>
<li><a href='#LambertW'>
<p>Lambert's W Function</p></a></li>
<li><a href='#LennardJones'><p>The Lennard-Jones Potential</p></a></li>
<li><a href='#leverage.ppm'>
<p>Leverage Measure for Spatial Point Process Model</p></a></li>
<li><a href='#leverage.slrm'>
<p>Leverage and Influence Diagnostics for Spatial Logistic Regression</p></a></li>
<li><a href='#lgcp.estK'><p>Fit a Log-Gaussian Cox Point Process by Minimum Contrast</p></a></li>
<li><a href='#lgcp.estpcf'><p>Fit a Log-Gaussian Cox Point Process by Minimum Contrast</p></a></li>
<li><a href='#logLik.dppm'><p>Log Likelihood and AIC for Fitted Determinantal Point Process Model</p></a></li>
<li><a href='#logLik.kppm'><p>Log Likelihood and AIC for Fitted Cox or Cluster Point Process Model</p></a></li>
<li><a href='#logLik.mppm'><p>Log Likelihood and AIC for Multiple Point Process Model</p></a></li>
<li><a href='#logLik.ppm'><p>Log Likelihood and AIC for Point Process Model</p></a></li>
<li><a href='#logLik.slrm'>
<p>Loglikelihood of Spatial Logistic Regression</p></a></li>
<li><a href='#lurking'><p>Lurking Variable Plot</p></a></li>
<li><a href='#lurking.mppm'>
<p>Lurking Variable Plot for Multiple Point Patterns</p></a></li>
<li><a href='#matclust.estK'><p>Fit the Matern Cluster Point Process by Minimum Contrast</p></a></li>
<li><a href='#matclust.estpcf'><p>Fit the Matern Cluster Point Process by Minimum Contrast Using Pair Correlation</p></a></li>
<li><a href='#measureContinuous'>
<p>Discrete and Continuous Components of a Measure</p></a></li>
<li><a href='#measureVariation'>
<p>Positive and Negative Parts, and Variation, of a Measure</p></a></li>
<li><a href='#measureWeighted'>
<p>Weighted Version of a Measure</p></a></li>
<li><a href='#methods.dppm'>
<p>Methods for Determinantal Point Process Models</p></a></li>
<li><a href='#methods.fii'>
<p>Methods for Fitted Interactions</p></a></li>
<li><a href='#methods.influence.ppm'><p>Methods for Influence Objects</p></a></li>
<li><a href='#methods.kppm'>
<p>Methods for Cluster Point Process Models</p></a></li>
<li><a href='#methods.leverage.ppm'><p>Methods for Leverage Objects</p></a></li>
<li><a href='#methods.objsurf'>
<p>Methods for Objective Function Surfaces</p></a></li>
<li><a href='#methods.slrm'>
<p>Methods for Spatial Logistic Regression Models</p></a></li>
<li><a href='#methods.traj'>
<p>Methods for Trajectories of Function Evaluations</p></a></li>
<li><a href='#methods.zclustermodel'>
<p>Methods for Cluster Models</p></a></li>
<li><a href='#methods.zgibbsmodel'>
<p>Methods for Gibbs Models</p></a></li>
<li><a href='#mincontrast'><p>Method of Minimum Contrast</p></a></li>
<li><a href='#model.depends'>
<p>Identify Covariates Involved in each Model Term</p></a></li>
<li><a href='#model.frame.ppm'>
<p>Extract the Variables in a Point Process Model</p></a></li>
<li><a href='#model.images'><p>Compute Images of Constructed Covariates</p></a></li>
<li><a href='#model.matrix.mppm'><p>Extract Design Matrix of Point Process Model for Several Point Patterns</p></a></li>
<li><a href='#model.matrix.ppm'><p>Extract Design Matrix from Point Process Model</p></a></li>
<li><a href='#model.matrix.slrm'><p>Extract Design Matrix from Spatial Logistic Regression Model</p></a></li>
<li><a href='#mppm'><p>Fit Point Process Model to Several Point Patterns</p></a></li>
<li><a href='#msr'>
<p>Signed or Vector-Valued Measure</p></a></li>
<li><a href='#MultiHard'><p>The Multitype Hard Core Point Process Model</p></a></li>
<li><a href='#MultiStrauss'><p>The Multitype Strauss Point Process Model</p></a></li>
<li><a href='#MultiStraussHard'><p>The Multitype/Hard Core Strauss Point Process Model</p></a></li>
<li><a href='#npfun'>
<p>Dummy Function Returns Number of Points</p></a></li>
<li><a href='#objsurf'>
<p>Objective Function Surface</p></a></li>
<li><a href='#Ops.msr'><p>Arithmetic Operations on Measures</p></a></li>
<li><a href='#Ord'><p>Generic Ord Interaction model</p></a></li>
<li><a href='#ord.family'><p>Ord Interaction Process Family</p></a></li>
<li><a href='#OrdThresh'><p>Ord's Interaction model</p></a></li>
<li><a href='#PairPiece'><p>The Piecewise Constant Pairwise Interaction Point Process Model</p></a></li>
<li><a href='#pairsat.family'><p>Saturated Pairwise Interaction Point Process Family</p></a></li>
<li><a href='#Pairwise'><p>Generic Pairwise Interaction model</p></a></li>
<li><a href='#pairwise.family'><p>Pairwise Interaction Process Family</p></a></li>
<li><a href='#palmdiagnose'>
<p>Diagnostic based on Palm Intensity</p></a></li>
<li><a href='#panel.contour'>
<p>Panel Plots using Colour Image or Contour Lines</p></a></li>
<li><a href='#panysib'>
<p>Probability that a Point Has Any Siblings</p></a></li>
<li><a href='#parameters'>
<p>Extract Model Parameters in Understandable Form</p></a></li>
<li><a href='#parres'>
<p>Partial Residuals for Point Process Model</p></a></li>
<li><a href='#Penttinen'><p>Penttinen Interaction</p></a></li>
<li><a href='#plot.dppm'><p>Plot a fitted determinantal point process</p></a></li>
<li><a href='#plot.influence.ppm'>
<p>Plot Influence Measure</p></a></li>
<li><a href='#plot.kppm'><p>Plot a fitted cluster point process</p></a></li>
<li><a href='#plot.leverage.ppm'>
<p>Plot Leverage Function</p></a></li>
<li><a href='#plot.mppm'><p>plot a Fitted Multiple Point Process Model</p></a></li>
<li><a href='#plot.msr'><p>Plot a Signed or Vector-Valued Measure</p></a></li>
<li><a href='#plot.palmdiag'>
<p>Plot the Palm Intensity Diagnostic</p></a></li>
<li><a href='#plot.plotppm'><p>Plot a plotppm Object Created by plot.ppm</p></a></li>
<li><a href='#plot.ppm'><p>plot a Fitted Point Process Model</p></a></li>
<li><a href='#plot.profilepl'>
<p>Plot Profile Likelihood</p></a></li>
<li><a href='#plot.rppm'>
<p>Plot a Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#plot.slrm'>
<p>Plot a Fitted Spatial Logistic Regression</p></a></li>
<li><a href='#Poisson'><p>Poisson Point Process Model</p></a></li>
<li><a href='#polynom'>
<p>Polynomial in One or Two Variables</p></a></li>
<li><a href='#ppm'>
<p>Fit Point Process Model to Data</p></a></li>
<li><a href='#ppm.object'><p>Class of Fitted Point Process Models</p></a></li>
<li><a href='#ppm.ppp'>
<p>Fit Point Process Model to Point Pattern Data</p></a></li>
<li><a href='#ppmInfluence'>
<p>Leverage and Influence Measures for Spatial Point Process Model</p></a></li>
<li><a href='#predict.dppm'><p>Prediction from a Fitted Determinantal Point Process Model</p></a></li>
<li><a href='#predict.kppm'><p>Prediction from a Fitted Cluster Point Process Model</p></a></li>
<li><a href='#predict.mppm'><p>Prediction for Fitted Multiple Point Process Model</p></a></li>
<li><a href='#predict.ppm'><p>Prediction from a Fitted Point Process Model</p></a></li>
<li><a href='#predict.rppm'>
<p>Make Predictions From a Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#predict.slrm'>
<p>Predicted or Fitted Values from Spatial Logistic Regression</p></a></li>
<li><a href='#print.ppm'><p>Print a Fitted Point Process Model</p></a></li>
<li><a href='#profilepl'><p>Fit Models by Profile Maximum Pseudolikelihood or AIC</p></a></li>
<li><a href='#prune.rppm'>
<p>Prune a Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#pseudoR2'>
<p>Calculate Pseudo-R-Squared for Point Process Model</p></a></li>
<li><a href='#psib'>
<p>Sibling Probability of Cluster Point Process</p></a></li>
<li><a href='#psst'>
<p>Pseudoscore Diagnostic For Fitted Model against General Alternative</p></a></li>
<li><a href='#psstA'>
<p>Pseudoscore Diagnostic For Fitted Model against Area-Interaction Alternative</p></a></li>
<li><a href='#psstG'>
<p>Pseudoscore Diagnostic For Fitted Model against Saturation Alternative</p></a></li>
<li><a href='#qqplot.ppm'>
<p>Q-Q Plot of Residuals from Fitted Point Process Model</p></a></li>
<li><a href='#quad.ppm'><p>Extract Quadrature Scheme Used to Fit a Point Process Model</p></a></li>
<li><a href='#quadrat.test.mppm'><p>Chi-Squared Test for Multiple Point Process Model Based on</p>
Quadrat Counts</a></li>
<li><a href='#quadrat.test.ppm'><p>Dispersion Test for Spatial Point Pattern Based on</p>
Quadrat Counts</a></li>
<li><a href='#ranef.mppm'>
<p>Extract Random Effects from Point Process Model</p></a></li>
<li><a href='#rdpp'><p>Simulation of a Determinantal Point Process</p></a></li>
<li><a href='#reach'><p>Interaction Distance of a Point Process Model</p></a></li>
<li><a href='#reach.dppm'><p>Range of Interaction for a Determinantal Point Process Model</p></a></li>
<li><a href='#reach.kppm'><p>Range of Interaction for a Cox or Cluster Point Process Model</p></a></li>
<li><a href='#relrisk.ppm'>
<p>Parametric Estimate of Spatially-Varying Relative Risk</p></a></li>
<li><a href='#repul.dppm'>
<p>Repulsiveness Index of a Determinantal Point Process Model</p></a></li>
<li><a href='#residualMeasure'>
<p>Residual Measure for an Observed Point Pattern and a Fitted Intensity</p></a></li>
<li><a href='#residuals.dppm'>
<p>Residuals for Fitted Determinantal Point Process Model</p></a></li>
<li><a href='#residuals.kppm'>
<p>Residuals for Fitted Cox or Cluster Point Process Model</p></a></li>
<li><a href='#residuals.mppm'><p>Residuals for Point Process Model Fitted to Multiple Point Patterns</p></a></li>
<li><a href='#residuals.ppm'>
<p>Residuals for Fitted Point Process Model</p></a></li>
<li><a href='#residuals.rppm'>
<p>Residuals for Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#residuals.slrm'>
<p>Residuals for Fitted Spatial Logistic Regression Model</p></a></li>
<li><a href='#response'>
<p>Extract the Values of the Response from a Fitted Model</p></a></li>
<li><a href='#rex'>
<p>Richardson Extrapolation</p></a></li>
<li><a href='#rhohat.ppm'>
<p>Nonparametric Estimate of Intensity as Function of a Covariate</p></a></li>
<li><a href='#rmh.ppm'><p>Simulate from a Fitted Point Process Model</p></a></li>
<li><a href='#rmhmodel.ppm'><p>Interpret Fitted Model for Metropolis-Hastings Simulation.</p></a></li>
<li><a href='#roc.ppm'>
<p>Receiver Operating Characteristic</p></a></li>
<li><a href='#rppm'>
<p>Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#SatPiece'><p>Piecewise Constant Saturated Pairwise Interaction Point Process Model</p></a></li>
<li><a href='#Saturated'><p>Saturated Pairwise Interaction model</p></a></li>
<li><a href='#simulate.dppm'><p>Simulation of Determinantal Point Process Model</p></a></li>
<li><a href='#simulate.kppm'><p>Simulate a Fitted Cluster Point Process Model</p></a></li>
<li><a href='#simulate.mppm'><p>Simulate a Point Process Model Fitted to Several Point Patterns</p></a></li>
<li><a href='#simulate.ppm'><p>Simulate a Fitted Gibbs Point Process Model</p></a></li>
<li><a href='#simulate.slrm'><p>Simulate a Fitted Spatial Logistic Regression Model</p></a></li>
<li><a href='#slrm'><p>Spatial Logistic Regression</p></a></li>
<li><a href='#Smooth.msr'>
<p>Smooth a Signed or Vector-Valued Measure</p></a></li>
<li><a href='#Softcore'><p>The Soft Core Point Process Model</p></a></li>
<li><a href='#spatstat.model-internal'><p>Internal spatstat.model functions</p></a></li>
<li><a href='#spatstat.model-package'><p>The spatstat.model Package</p></a></li>
<li><a href='#split.msr'>
<p>Divide a Measure into Parts</p></a></li>
<li><a href='#Strauss'><p>The Strauss Point Process Model</p></a></li>
<li><a href='#StraussHard'><p>The Strauss / Hard Core Point Process Model</p></a></li>
<li><a href='#subfits'><p>Extract List of Individual Point Process Models</p></a></li>
<li><a href='#suffstat'><p>Sufficient Statistic of Point Process Model</p></a></li>
<li><a href='#summary.dppm'><p>Summarizing a Fitted Determinantal Point Process Model</p></a></li>
<li><a href='#summary.kppm'><p>Summarizing a Fitted Cox or Cluster Point Process Model</p></a></li>
<li><a href='#summary.ppm'><p>Summarizing a Fitted Point Process Model</p></a></li>
<li><a href='#thomas.estK'><p>Fit the Thomas Point Process by Minimum Contrast</p></a></li>
<li><a href='#thomas.estpcf'><p>Fit the Thomas Point Process by Minimum Contrast</p></a></li>
<li><a href='#traj'>
<p>Extract trajectory of function evaluations</p></a></li>
<li><a href='#triplet.family'><p>Triplet Interaction Family</p></a></li>
<li><a href='#Triplets'><p>The Triplet Point Process Model</p></a></li>
<li><a href='#unitname'><p>Name for Unit of Length</p></a></li>
<li><a href='#unstack.msr'>
<p>Separate a Vector Measure into its Scalar Components</p></a></li>
<li><a href='#update.detpointprocfamily'><p>Set Parameter Values in a Determinantal Point Process Model</p></a></li>
<li><a href='#update.dppm'><p>Update a Fitted Determinantal Point Process Model</p></a></li>
<li><a href='#update.interact'>
<p>Update an Interpoint Interaction</p></a></li>
<li><a href='#update.kppm'><p>Update a Fitted Cluster Point Process Model</p></a></li>
<li><a href='#update.ppm'><p>Update a Fitted Point Process Model</p></a></li>
<li><a href='#update.rppm'><p>Update a Recursively Partitioned Point Process Model</p></a></li>
<li><a href='#valid'>
<p>Check Whether Point Process Model is Valid</p></a></li>
<li><a href='#valid.detpointprocfamily'><p>Check Validity of a Determinantal Point Process Model</p></a></li>
<li><a href='#valid.ppm'>
<p>Check Whether Point Process Model is Valid</p></a></li>
<li><a href='#valid.slrm'>
<p>Check Whether Spatial Logistic Regression Model is Valid</p></a></li>
<li><a href='#varcount'>
<p>Predicted Variance of the Number of Points</p></a></li>
<li><a href='#vargamma.estK'><p>Fit the Neyman-Scott Cluster Point Process with Variance Gamma kernel</p></a></li>
<li><a href='#vargamma.estpcf'><p>Fit the Neyman-Scott Cluster Point Process with Variance Gamma kernel</p></a></li>
<li><a href='#vcov.kppm'><p>Variance-Covariance Matrix for a Fitted Cluster Point Process Model</p></a></li>
<li><a href='#vcov.mppm'><p>Calculate Variance-Covariance Matrix for Fitted Multiple Point</p>
Process Model</a></li>
<li><a href='#vcov.ppm'><p>Variance-Covariance Matrix for a Fitted Point Process Model</p></a></li>
<li><a href='#vcov.slrm'><p>Variance-Covariance Matrix for a Fitted Spatial Logistic Regression</p></a></li>
<li><a href='#Window.ppm'><p>Extract Window of Spatial Object</p></a></li>
<li><a href='#with.msr'><p>Evaluate Expression Involving Components of a Measure</p></a></li>
<li><a href='#zclustermodel'>
<p>Cluster Point Process Model</p></a></li>
<li><a href='#zgibbsmodel'>
<p>Gibbs Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.2-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Parametric Statistical Modelling and Inference for the
'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0-4), spatstat.geom (&ge;
3.2-9), spatstat.random (&ge; 3.2-3), spatstat.explore (&ge;
3.2-7), stats, graphics, grDevices, utils, methods, nlme, rpart</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-4), spatstat.sparse (&ge; 3.0-3), mgcv,
Matrix, abind, tensor, goftest (&ge; 1.2-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sm, gsl, locfit, spatial, fftwtools (&ge; 0.9-8), nleqslv,
glmnet, spatstat.linnet (&ge; 3.1-4), spatstat (&ge; 3.0-7)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functionality for parametric statistical modelling and inference for spatial data,
	     mainly spatial point patterns, in the 'spatstat' family of packages.
	     (Excludes analysis of spatial data on a linear network,
	     which is covered by the separate package 'spatstat.linnet'.)
	     Supports parametric modelling, formal statistical inference, and model validation.
	     Parametric models include Poisson point processes, Cox point processes, Neyman-Scott cluster processes, Gibbs point processes and determinantal point processes. Models can be fitted to data using maximum likelihood, maximum pseudolikelihood, maximum composite likelihood and the method of minimum contrast. Fitted models can be simulated and predicted. Formal inference includes hypothesis tests (quadrat counting tests, Cressie-Read tests, Clark-Evans test, Berman test, Diggle-Cressie-Loosmore-Ford test, scan test, studentised permutation test, segregation test, ANOVA tests of fitted models, adjusted composite likelihood ratio test, envelope tests, Dao-Genton test, balanced independent two-stage test), confidence intervals for parameters, and prediction intervals for point counts. Model validation techniques include leverage, influence, partial residuals, added variable plots, diagnostic plots, pseudoscore residual plots, model compensators and Q-Q plots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.model/issues">https://github.com/spatstat/spatstat.model/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-22 07:57:14 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Kasper Klitgaard Berthelsen [ctb],
  Achmad Choiruddin [ctb, cph],
  Jean-Francois Coeurjolly [ctb],
  Ottmar Cronie [ctb],
  Tilman Davies [ctb],
  Julian Gilbey [ctb],
  Yongtao Guan [ctb],
  Ute Hahn [ctb],
  Martin Hazelton [ctb],
  Kassel Hingee [ctb],
  Abdollah Jalilian [ctb],
  Frederic Lavancier [ctb],
  Marie-Colette van Lieshout [ctb],
  Bethany Macdonald [ctb],
  Greg McSwiggan [ctb],
  Tuomas Rajala [ctb],
  Suman Rakshit [ctb, cph],
  Dominic Schuhmacher [ctb],
  Rasmus Plenge Waagepetersen [ctb],
  Hangsheng Wang [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addvar'>
Added Variable Plot for Point Process Model
</h2><span id='topic+addvar'></span>

<h3>Description</h3>

<p>Computes the coordinates for an Added Variable Plot
for a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addvar(model, covariate, ...,
                   subregion=NULL,
                   bw="nrd0", adjust=1,
                   from=NULL, to=NULL, n=512,
                   bw.input = c("points", "quad"),
                   bw.restrict = FALSE,
                   covname, crosscheck=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addvar_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="addvar_+3A_covariate">covariate</code></td>
<td>

<p>The covariate to be added to the model. Either a
pixel image, a <code>function(x,y)</code>, or a character string
giving the name of a covariate that was supplied when
the model was fitted.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_subregion">subregion</code></td>
<td>

<p>Optional.  A window (object of class <code>"owin"</code>)
specifying a subset of the spatial domain of the data.
The calculation will be confined to the data in this subregion.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth or bandwidth rule
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="addvar_+3A_adjust">adjust</code></td>
<td>

<p>Smoothing bandwidth adjustment factor
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="addvar_+3A_n">n</code>, <code id="addvar_+3A_from">from</code>, <code id="addvar_+3A_to">to</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code> to
control the number and range of values at which the function
will be estimated.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_bw.input">bw.input</code></td>
<td>

<p>Character string specifying the input data used for automatic
bandwidth selection. 
</p>
</td></tr>
<tr><td><code id="addvar_+3A_bw.restrict">bw.restrict</code></td>
<td>

<p>Logical value, specifying whether bandwidth selection is performed using
data from the entire spatial domain or from the <code>subregion</code>.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_covname">covname</code></td>
<td>

<p>Optional. Character string to use as the name of the covariate.
</p>
</td></tr>
<tr><td><code id="addvar_+3A_crosscheck">crosscheck</code></td>
<td>

<p>For developers only.
Logical value indicating whether to perform
cross-checks on the validity of the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command generates the plot coordinates for an Added Variable Plot
for a spatial point process model.
</p>
<p>Added Variable Plots (Cox, 1958, sec 4.5; Wang, 1985)
are commonly used in linear models and generalized linear
models, to decide whether a model with response <code class="reqn">y</code> and predictors <code class="reqn">x</code>
would be improved by including another predictor <code class="reqn">z</code>.
</p>
<p>In a (generalised) linear model 
with response <code class="reqn">y</code> and predictors <code class="reqn">x</code>,
the Added Variable Plot for a new covariate <code class="reqn">z</code> 
is a plot of the smoothed Pearson residuals from the original model
against the scaled residuals from a weighted linear
regression of <code class="reqn">z</code> on <code class="reqn">x</code>.
If this plot has nonzero slope, then the new covariate <code class="reqn">z</code> is
needed. For general advice see Cook and Weisberg(1999); Harrell (2001).
</p>
<p>Essentially the same technique can be used for a spatial point process
model (Baddeley et al, 2012).
</p>
<p>The argument <code>model</code> should be a fitted spatial point process
model (object of class <code>"ppm"</code>). 
</p>
<p>The argument <code>covariate</code>
identifies the covariate that is to be considered for addition to
the model. It should be either a pixel image (object of class
<code>"im"</code>) or a <code>function(x,y)</code> giving the values of the
covariate at any spatial location. Alternatively <code>covariate</code>
may be a character string, giving the name of a covariate that was
supplied (in the <code>covariates</code> argument to <code><a href="#topic+ppm">ppm</a></code>)
when the model was fitted, but was not used in the model.
</p>
<p>The result of <code>addvar(model, covariate)</code> is an object belonging
to the classes <code>"addvar"</code> and <code>"fv"</code>. Plot this object to
generate the added variable plot. 
</p>
<p>Note that the plot method shows the pointwise significance bands
for a test of the <em>null</em> model, i.e. the null hypothesis
that the new covariate has no effect.
</p>
<p>The smoothing bandwidth is controlled by the arguments
<code>bw</code>, <code>adjust</code>, <code>bw.input</code> and <code>bw.restrict</code>.
If <code>bw</code> is a numeric value, then
the bandwidth is taken to be <code>adjust * bw</code>.
If <code>bw</code> is a string representing a bandwidth selection rule
(recognised by <code><a href="stats.html#topic+density.default">density.default</a></code>)
then the bandwidth is selected by this rule.
</p>
<p>The data used for automatic bandwidth selection are
specified by <code>bw.input</code> and <code>bw.restrict</code>.
If <code>bw.input="points"</code>  (the default) then bandwidth selection is
based on the covariate values at the points of the original point
pattern dataset to which the model was fitted.
If <code>bw.input="quad"</code> then bandwidth selection is
based on the covariate values at every quadrature point used to
fit the model.
If <code>bw.restrict=TRUE</code> then the bandwidth selection is performed
using only data from inside the <code>subregion</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"addvar"</code> containing the coordinates
for the added variable plot. There is a <code>plot</code> method.
</p>


<h3>Slow computation</h3>

<p>In a large dataset, computation can be very slow if the default
settings are used, because the smoothing bandwidth is selected
automatically. To avoid this, specify a numerical value
for the bandwidth <code>bw</code>. One strategy is to use a coarser
subset of the data to select <code>bw</code> automatically.
The selected bandwidth can be read off the print output for
<code>addvar</code>.  
</p>


<h3>Internal data</h3>

<p>The return value has an attribute <code>"spatial"</code> which contains
the internal data: the computed values of the residuals,
and of all relevant covariates,
at each quadrature point of the model. It is an object of class
<code>"ppp"</code> with a data frame of marks.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
Ya-Mei Chang and Yong Song.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2013)
Residual diagnostics for covariate effects in
spatial point process models.
<em>Journal of Computational and Graphical Statistics</em>,
<b>22</b>, 886&ndash;905.
</p>
<p>Cook, R.D. and Weisberg, S. (1999)
<em>Applied regression, including computing and graphics</em>.
New York: Wiley.
</p>
<p>Cox, D.R. (1958) <em>Planning of Experiments</em>. New York: Wiley.
</p>
<p>Harrell, F. (2001) <em>Regression Modeling Strategies</em>. New York: Springer.
</p>
<p>Wang, P. (1985) Adding a variable in generalized linear models.
<em>Technometrics</em> <b>27</b>, 273&ndash;276.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parres">parres</a></code>,
<code><a href="spatstat.explore.html#topic+rhohat">rhohat</a></code>,
<code><a href="spatstat.explore.html#topic+rho2hat">rho2hat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;-  rpoispp(function(x,y){exp(3+3*x)})
  model &lt;- ppm(X, ~y)
  adv &lt;- addvar(model, "x")
  plot(adv)
  adv &lt;- addvar(model, "x", subregion=square(0.5))
</code></pre>

<hr>
<h2 id='anova.mppm'>ANOVA for Fitted Point Process Models for Replicated Patterns</h2><span id='topic+anova.mppm'></span>

<h3>Description</h3>

<p>Performs analysis of deviance for one or more
point process models fitted to replicated point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mppm'
anova(object, ...,
                  test=NULL, adjust=TRUE,
                  fine=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.mppm_+3A_object">object</code></td>
<td>

<p>Object of class <code>"mppm"</code> representing a
point process model that was fitted to replicated point patterns.
</p>
</td></tr>
<tr><td><code id="anova.mppm_+3A_...">...</code></td>
<td>

<p>Optional. Additional objects of class <code>"mppm"</code>.
</p>
</td></tr>
<tr><td><code id="anova.mppm_+3A_test">test</code></td>
<td>

<p>Type of hypothesis test to perform. 
A character string, partially matching one of
<code>"Chisq"</code>, <code>"LRT"</code>,
<code>"Rao"</code>, <code>"score"</code>, <code>"F"</code> or <code>"Cp"</code>,
or <code>NULL</code> indicating that no test should be performed.
</p>
</td></tr>
<tr><td><code id="anova.mppm_+3A_adjust">adjust</code></td>
<td>

<p>Logical value indicating whether to correct the
pseudolikelihood ratio when some of the models are not Poisson
processes.
</p>
</td></tr>
<tr><td><code id="anova.mppm_+3A_fine">fine</code></td>
<td>

<p>Logical value passed to <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>
indicating whether to use a quick estimate 
(<code>fine=FALSE</code>, the default) or a slower, more accurate
estimate (<code>fine=TRUE</code>) of the variance of the fitted
coefficients of each model. 
Relevant only when some of the models are not Poisson
and <code>adjust=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="anova.mppm_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue warnings
if problems arise.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+anova">anova</a></code> for comparing several
fitted point process models of class <code>"mppm"</code>,
usually generated by the model-fitting function <code><a href="#topic+mppm">mppm</a></code>).
</p>
<p>If the fitted models are all Poisson point processes,
then this function performs an Analysis of Deviance of
the fitted models. The output shows the deviance differences
(i.e. 2 times log likelihood ratio),
the difference in degrees of freedom, and (if <code>test="Chi"</code>)
the two-sided p-values for the chi-squared tests. Their interpretation
is very similar to that in <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>.
</p>
<p>If some of the fitted models are <em>not</em> Poisson point processes,
the &lsquo;deviance&rsquo; differences in this table are
'pseudo-deviances' equal to 2 times the differences
in the maximised values of the log pseudolikelihood (see
<code><a href="#topic+ppm">ppm</a></code>). It is not valid to compare these
values to the chi-squared distribution. In this case,
if <code>adjust=TRUE</code> (the default), the
pseudo-deviances will be adjusted using the method of Pace et al
(2011) and Baddeley, Turner and Rubak (2015)
so that the chi-squared test is valid.
It is strongly advisable to perform this adjustment.
</p>
<p>The argument <code>test</code> determines which hypothesis test, if any, will
be performed to compare the models. The argument <code>test</code>
should be a character string, partially matching one of
<code>"Chisq"</code>, <code>"F"</code> or <code>"Cp"</code>,
or <code>NULL</code>. The first option <code>"Chisq"</code> gives
the likelihood ratio test based on the asymptotic chi-squared
distribution of the deviance difference.
The meaning of the other options is explained in
<code><a href="stats.html#topic+anova.glm">anova.glm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code>, or <code>NULL</code>.
</p>


<h3>Random effects models are currently not supported</h3>

<p>For models with random effects
(i.e. where the call to <code><a href="#topic+mppm">mppm</a></code>
included the argument <code>random</code>),


analysis of deviance is currently not supported,
due to changes in the <span class="pkg">nlme</span> package.
We will try to find a solution.
</p>


<h3>Error messages</h3>

<p>An error message that reports
<em>system is computationally singular</em> indicates that the
determinant of the Fisher information matrix of one of the models
was either too large or too small for reliable numerical calculation.
See <code><a href="#topic+vcov.ppm">vcov.ppm</a></code> for suggestions on how to handle this.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Baddeley, A., Turner, R. and Rubak, E. (2015)
Adjusted composite likelihood ratio test for Gibbs point processes.
<em>Journal of Statistical Computation and Simulation</em>
<b>86</b> (5) 922&ndash;941.
DOI: 10.1080/00949655.2015.1044530.
</p>
<p>Pace, L., Salvan, A. and Sartori, N. (2011)
Adjusting composite likelihood ratio statistics.
<em>Statistica Sinica</em> <b>21</b>, 129&ndash;148.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> H &lt;- hyperframe(X=waterstriders)
 #' test for loglinear trend in x coordinate
 mod0 &lt;- mppm(X~1, data=H, Poisson())
 modx &lt;- mppm(X~x, data=H, Poisson())
 anova(mod0, modx, test="Chi")
 # not significant
 anova(modx, test="Chi")
 # not significant

 #' test for inhibition
 mod0S &lt;- mppm(X~1, data=H, Strauss(2))
 anova(mod0, mod0S, test="Chi")
 # significant! 

 #' test for trend after accounting for inhibition
 modxS &lt;- mppm(X~x, data=H, Strauss(2))
 anova(mod0S, modxS, test="Chi")
 # not significant
</code></pre>

<hr>
<h2 id='anova.ppm'>ANOVA for Fitted Point Process Models</h2><span id='topic+anova.ppm'></span>

<h3>Description</h3>

<p>Performs analysis of deviance for one or more fitted point process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
anova(object, ..., test=NULL,
                      adjust=TRUE, warn=TRUE, fine=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.ppm_+3A_object">object</code></td>
<td>

<p>A fitted point process model
(object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="anova.ppm_+3A_...">...</code></td>
<td>

<p>Optional. Additional objects of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="anova.ppm_+3A_test">test</code></td>
<td>

<p>Character string, partially matching one of
<code>"Chisq"</code>, <code>"LRT"</code>,
<code>"Rao"</code>, <code>"score"</code>, <code>"F"</code> or <code>"Cp"</code>,
or <code>NULL</code> indicating that no test should be performed.
</p>
</td></tr>
<tr><td><code id="anova.ppm_+3A_adjust">adjust</code></td>
<td>

<p>Logical value indicating whether to correct the
pseudolikelihood ratio when some of the models are not Poisson
processes.
</p>
</td></tr>
<tr><td><code id="anova.ppm_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue warnings
if problems arise.
</p>
</td></tr>
<tr><td><code id="anova.ppm_+3A_fine">fine</code></td>
<td>

<p>Logical value, passed to <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>,
indicating whether to use a quick estimate 
(<code>fine=FALSE</code>, the default) or a slower, more accurate
estimate (<code>fine=TRUE</code>) of variance terms.
Relevant only when some of the models are not Poisson
and <code>adjust=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+anova">anova</a></code> for 
fitted point process models (objects of class <code>"ppm"</code>,
usually generated by the model-fitting function <code><a href="#topic+ppm">ppm</a></code>).
</p>
<p>If the fitted models are all Poisson point processes,
then by default, this function performs an Analysis of Deviance of
the fitted models. The output shows the deviance differences
(i.e. 2 times log likelihood ratio),
the difference in degrees of freedom, and (if <code>test="Chi"</code>
or <code>test="LRT"</code>)
the two-sided p-values for the chi-squared tests. Their interpretation
is very similar to that in <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>.
If <code>test="Rao"</code> or <code>test="score"</code>,
the <em>score test</em> (Rao, 1948) is performed instead.
</p>
<p>If some of the fitted models are <em>not</em> Poisson point processes,
the &lsquo;deviance&rsquo; differences in this table are
'pseudo-deviances' equal to 2 times the differences
in the maximised values of the log pseudolikelihood (see
<code><a href="#topic+ppm">ppm</a></code>). It is not valid to compare these
values to the chi-squared distribution. In this case,
if <code>adjust=TRUE</code> (the default), the
pseudo-deviances will be adjusted using the method of Pace et al
(2011) and Baddeley et al (2015) so that the chi-squared test is valid.
It is strongly advisable to perform this adjustment.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code>, or <code>NULL</code>.
</p>


<h3>Errors and warnings</h3>


<dl>
<dt>models not nested:</dt><dd>
<p>There may be an error message that the models are not &ldquo;nested&rdquo;.
For an Analysis of Deviance the models must be nested, i.e. one model
must be a special case of the other. For example the point process
model with formula <code>~x</code> is a special case of the model with
formula <code>~x+y</code>, so these models are nested. However
the two point process
models with formulae <code>~x</code> and <code>~y</code> are not nested.
</p>
<p>If you get this error message and you believe that the models should
be nested, the problem may be the inability of <span class="rlang"><b>R</b></span> to recognise that
the two formulae are nested. Try modifying the formulae to make
their relationship more obvious.
</p>
</dd>
<dt>different sizes of dataset:</dt><dd>
<p>There may be an error message from <code>anova.glmlist</code> that
&ldquo;models were not all fitted to the same size of dataset&rdquo;.
This implies that the models were fitted using different
quadrature schemes (see <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>) and/or
with different edge corrections or different values of the
border edge correction distance <code>rbord</code>.
</p>
<p>To ensure that models are comparable, check the following:
</p>

<ul>
<li><p> the models must all have been fitted to the same
point pattern dataset, in the same window.
</p>
</li>
<li><p> all models must have been fitted by the same
fitting method as specified by the argument <code>method</code> in
<code><a href="#topic+ppm">ppm</a></code>. 
</p>
</li>
<li><p> If some of the models depend on covariates, then
they should all have been fitted using the same list of
covariates, and using <code>allcovar=TRUE</code> to ensure that the
same quadrature scheme is used.
</p>
</li>
<li><p> all models must have been fitted using the same edge
correction as specified by the arguments <code>correction</code>
and <code>rbord</code>. If you did not specify the value of
<code>rbord</code>, then it may have
taken a different value for different models. The default value of
<code>rbord</code> is equal to zero for a Poisson model,
and otherwise equals the reach (interaction distance) of the
interaction term (see <code><a href="spatstat.random.html#topic+reach">reach</a></code>).
To ensure that the models are comparable, set <code>rbord</code> to
equal the maximum reach of the interactions that you
are fitting.
</p>
</li></ul>

</dd>
</dl>



<h3>Error messages</h3>

<p>An error message that reports
<em>system is computationally singular</em> indicates that the
determinant of the Fisher information matrix of one of the models
was either too large or too small for reliable numerical calculation.
See <code><a href="#topic+vcov.ppm">vcov.ppm</a></code> for suggestions on how to handle this.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R. and Rubak, E. (2015)
Adjusted composite likelihood ratio test for Gibbs point processes.
<em>Journal of Statistical Computation and Simulation</em>
<b>86</b> (5) 922&ndash;941.
DOI: 10.1080/00949655.2015.1044530.
</p>
<p>Pace, L., Salvan, A. and Sartori, N. (2011)
Adjusting composite likelihood ratio statistics.
<em>Statistica Sinica</em> <b>21</b>, 129&ndash;148.
</p>
<p>Rao, C.R. (1948) 
Large sample tests of statistical hypotheses concerning
several parameters with applications to problems of
estimation. <em>Proceedings of the Cambridge Philosophical Society</em>
<b>44</b>, 50&ndash;57.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+vcov.ppm">vcov.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mod0 &lt;- ppm(swedishpines ~1)
 modx &lt;- ppm(swedishpines ~x)
 # Likelihood ratio test
 anova(mod0, modx, test="Chi")
 # Score test
 anova(mod0, modx, test="Rao")

 # Single argument
 modxy &lt;- ppm(swedishpines ~x + y)
 anova(modxy, test="Chi")

 # Adjusted composite likelihood ratio test
 modP &lt;- ppm(swedishpines ~1, rbord=9)
 modS &lt;- ppm(swedishpines ~1, Strauss(9))
 anova(modP, modS, test="Chi")
</code></pre>

<hr>
<h2 id='anova.slrm'>
Analysis of Deviance for Spatial Logistic Regression Models
</h2><span id='topic+anova.slrm'></span>

<h3>Description</h3>

<p>Performs Analysis of Deviance for two or more fitted Spatial Logistic
Regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
anova(object, ..., test = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.slrm_+3A_object">object</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="anova.slrm_+3A_...">...</code></td>
<td>

<p>additional objects of the same type (optional).
</p>
</td></tr>
<tr><td><code id="anova.slrm_+3A_test">test</code></td>
<td>

<p>a character string, (partially) matching one of
<code>"Chisq"</code>, <code>"F"</code> or <code>"Cp"</code>, indicating the
reference distribution that should be used to compute
<code class="reqn">p</code>-values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+anova">anova</a></code> for fitted spatial logistic
regression models (objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>).
</p>
<p>The output shows the deviance differences (i.e. 2 times log
likelihood ratio), the difference in degrees of freedom, and (if
<code>test="Chi"</code>) the two-sided <code class="reqn">p</code>-values for the chi-squared tests.
Their interpretation is very similar to that
in <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code>, inheriting from
class <code>"data.frame"</code>, representing the analysis of deviance table.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit0 &lt;- slrm(X ~ 1)
  fit1 &lt;- slrm(X ~ x+y)
  anova(fit0, fit1, test="Chi")
</code></pre>

<hr>
<h2 id='AreaInter'>The Area Interaction Point Process Model</h2><span id='topic+AreaInter'></span>

<h3>Description</h3>

<p>Creates an instance of the Area Interaction point process model
(Widom-Rowlinson penetrable spheres model) 
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  AreaInter(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AreaInter_+3A_r">r</code></td>
<td>
<p>The radius of the discs in the area interaction process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines the interpoint interaction structure of a point
process called the Widom-Rowlinson penetrable sphere model
or area-interaction process. It can be used to fit this model to
point pattern data.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the area interaction structure is
yielded by the function <code>AreaInter()</code>. See the examples below.
</p>
<p>In <b>standard form</b>, the area-interaction process
(Widom and Rowlinson, 1970;
Baddeley and Van Lieshout, 1995) with disc radius <code class="reqn">r</code>,
intensity parameter <code class="reqn">\kappa</code> and interaction parameter
<code class="reqn">\gamma</code> is a point process with probability density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \kappa^{n(x)} \gamma^{-A(x)}
  </code>
</p>

<p>for a point pattern <code class="reqn">x</code>, where 
<code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, and <code class="reqn">A(x)</code> is the area of the region formed by
the union of discs of radius <code class="reqn">r</code> centred at the points
<code class="reqn">x_1,\ldots,x_n</code>.
Here <code class="reqn">\alpha</code> is a normalising constant.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> can be any positive number.
If <code class="reqn">\gamma = 1</code> then the model reduces to a Poisson
process with intensity <code class="reqn">\kappa</code>.
If <code class="reqn">\gamma &lt; 1</code> then the process is regular,
while if <code class="reqn">\gamma &gt; 1</code> the process is clustered.
Thus, an area interaction process can be used to model either
clustered or regular point patterns. Two points interact if the
distance between them is less than <code class="reqn">2r</code>.
</p>
<p>The standard form of the model, shown above, is a little
complicated to interpret in practical applications.
For example, each isolated point of the pattern <code class="reqn">x</code> contributes a factor
<code class="reqn">\kappa \gamma^{-\pi r^2}</code>
to the probability density. 
</p>
<p>In <span class="pkg">spatstat</span>, the model is parametrised in a different form,
which is easier to interpret.
In <b>canonical scale-free form</b>, the probability density is rewritten as
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \eta^{-C(x)}
  </code>
</p>

<p>where <code class="reqn">\beta</code> is the new intensity parameter,
<code class="reqn">\eta</code> is the new interaction parameter, and
<code class="reqn">C(x) = B(x) - n(x)</code> is the interaction potential. Here
</p>
<p style="text-align: center;"><code class="reqn">
    B(x) = \frac{A(x)}{\pi r^2}
  </code>
</p>

<p>is the normalised area (so that the discs have unit area).
In this formulation, each isolated point of the pattern contributes a
factor <code class="reqn">\beta</code> to the probability density (so the
first order trend is <code class="reqn">\beta</code>). The quantity 
<code class="reqn">C(x)</code> is a true interaction potential, in the sense that
<code class="reqn">C(x) = 0</code> if the point pattern <code class="reqn">x</code> does not contain any
points that lie close together (closer than <code class="reqn">2r</code> units
apart).
</p>
<p>When a new point <code class="reqn">u</code> is added to an existing point pattern
<code class="reqn">x</code>, the rescaled potential <code class="reqn">-C(x)</code> increases by
a value between 0 and 1. 
The increase is zero if <code class="reqn">u</code> is not close to any point of <code class="reqn">x</code>.
The increase is 1 if the disc of radius <code class="reqn">r</code> centred at <code class="reqn">u</code>
is completely contained in the union of discs of radius <code class="reqn">r</code>
centred at the data points <code class="reqn">x_i</code>. Thus, the increase in
potential is a measure of how close the new point <code class="reqn">u</code> is to the
existing pattern <code class="reqn">x</code>. Addition of the point
<code class="reqn">u</code> contributes a factor <code class="reqn">\beta \eta^\delta</code>
to the probability density, where <code class="reqn">\delta</code> is the
increase in potential. 
</p>
<p>The old parameters <code class="reqn">\kappa,\gamma</code> of the
standard form are related to
the new parameters <code class="reqn">\beta,\eta</code> of the canonical
scale-free form, by
</p>
<p style="text-align: center;"><code class="reqn">
    \beta = \kappa \gamma^{-\pi r^2} = \kappa /\eta
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    \eta = \gamma^{\pi r^2}
  </code>
</p>

<p>provided <code class="reqn">\gamma</code> and <code class="reqn">\kappa</code> are positive and finite.
</p>
<p>In the canonical scale-free form, the parameter <code class="reqn">\eta</code>
can take any nonnegative value. The value <code class="reqn">\eta = 1</code>
again corresponds to a Poisson process, with intensity <code class="reqn">\beta</code>.
If <code class="reqn">\eta &lt; 1</code> then the process is regular,
while if <code class="reqn">\eta &gt; 1</code> the process is clustered.
The value <code class="reqn">\eta = 0</code> corresponds to a hard core process
with hard core radius <code class="reqn">r</code> (interaction distance <code class="reqn">2r</code>).
</p>
<p>The <em>nonstationary</em> area interaction process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location, rather than a constant beta. 
</p>
<p>Note the only argument of <code>AreaInter()</code> is the disc radius <code>r</code>.
When <code>r</code> is fixed, the model becomes an exponential family.
The canonical parameters <code class="reqn">\log(\beta)</code>
and <code class="reqn">\log(\eta)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>AreaInter()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the area-interaction process with disc radius <code class="reqn">r</code>.
</p>


<h3>Warnings</h3>

<p>The interaction distance of this process is equal to
<code>2 * r</code>. Two discs of radius <code>r</code> overlap if their centres
are closer than <code>2 * r</code> units apart.
</p>
<p>The estimate of the interaction parameter <code class="reqn">\eta</code>
is unreliable if the interaction radius <code>r</code> is too small
or too large. In these situations the model is approximately Poisson
so that <code class="reqn">\eta</code> is unidentifiable.
As a rule of thumb, one can inspect the empty space function
of the data, computed by <code><a href="spatstat.explore.html#topic+Fest">Fest</a></code>. The value <code class="reqn">F(r)</code>
of the empty space function at the interaction radius <code>r</code> should
be between 0.2 and 0.8. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Van Lieshout, M.N.M. (1995).
Area-interaction point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>47</b> (1995) 601&ndash;619.
</p>
<p>Widom, B. and Rowlinson, J.S. (1970).
New model for the study of liquid-vapor phase transitions.
<em>The Journal of Chemical Physics</em>
<b>52</b> (1970) 1670&ndash;1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>
<p><code><a href="spatstat.random.html#topic+ragsAreaInter">ragsAreaInter</a></code> and <code><a href="spatstat.random.html#topic+rmh">rmh</a></code> for simulation
of area-interaction models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   

   # prints a sensible description of itself
   AreaInter(r=0.1)

   # Note the reach is twice the radius
   reach(AreaInter(r=1))

   # Fit the stationary area interaction process to Swedish Pines data
   ppm(swedishpines ~1, AreaInter(r=7))

   # Fit the stationary area interaction process to `cells'
   ppm(cells ~1, AreaInter(r=0.06))
   # eta=0 indicates hard core process.

   # Fit a nonstationary area interaction with log-cubic polynomial trend
   
     ppm(swedishpines ~polynom(x/10,y/10,3), AreaInter(r=7))
   

   
</code></pre>

<hr>
<h2 id='as.function.leverage.ppm'>
Convert Leverage Object to Function of Coordinates
</h2><span id='topic+as.function.leverage.ppm'></span>

<h3>Description</h3>

<p>Converts an object of class <code>"leverage.ppm"</code> to a function of the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'leverage.ppm'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.leverage.ppm_+3A_x">x</code></td>
<td>

<p>Object of class <code>"leverage.ppm"</code>
produced by <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="as.function.leverage.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"leverage.ppm"</code> represents the leverage
function of a fitted point process model. This command converts the object
to a <code>function(x,y)</code>
where the arguments <code>x</code> and <code>y</code> are (vectors of) spatial
coordinates. This function returns the leverage values at the
specified locations (calculated by referring to the nearest location
where the leverage has been computed).
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, also belonging to the
class <code>"funxy"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.im.leverage.ppm">as.im.leverage.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
  fit &lt;- ppm(X ~x+y)
  lev &lt;- leverage(fit)
  f &lt;- as.function(lev)
  
  f(0.2, 0.3)  # evaluate at (x,y) coordinates
  y &lt;- f(X)    # evaluate at a point pattern
</code></pre>

<hr>
<h2 id='as.fv.kppm'>Convert Fitted Model To Class fv</h2><span id='topic+as.fv.kppm'></span><span id='topic+as.fv.dppm'></span><span id='topic+as.fv.minconfit'></span>

<h3>Description</h3>

<p>Converts fitted model into a function table (an object of class <code>"fv"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
as.fv(x)

  ## S3 method for class 'dppm'
as.fv(x)

  ## S3 method for class 'minconfit'
as.fv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.fv.kppm_+3A_x">x</code></td>
<td>
<p>A fitted model which will be converted into a function table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic command <code>as.fv</code> converts data <code>x</code>, that
could be interpreted as the values of a function,
into a function value table (object of the class <code>"fv"</code>
as described in <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>). This object can then
be plotted easily using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>.
</p>
<p>Objects of class <code>"kppm"</code> (and related classes) represent
a model that has been fitted to a dataset 
by computing a summary function of the dataset and
matching it to the corresponding summary function of the model.
The methods for <code>as.fv</code> for classes <code>"kppm"</code>,
<code>"dppm"</code> and <code>"minconfit"</code> extract this information:
the result is a function table containing the
observed summary function and the best fit summary function.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.fv(kppm(redwood))
</code></pre>

<hr>
<h2 id='as.interact'>Extract Interaction Structure</h2><span id='topic+as.interact'></span><span id='topic+as.interact.fii'></span><span id='topic+as.interact.interact'></span><span id='topic+as.interact.ppm'></span>

<h3>Description</h3>

<p>Extracts the interpoint interaction structure from
a point pattern model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.interact(object)
## S3 method for class 'fii'
as.interact(object)
## S3 method for class 'interact'
as.interact(object)
## S3 method for class 'ppm'
as.interact(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.interact_+3A_object">object</code></td>
<td>
<p>A fitted point process model (object of class
<code>"ppm"</code>) or an interpoint interaction structure
(object of class <code>"interact"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.interact</code> extracts 
the interpoint interaction structure from a suitable object.
</p>
<p>An object of class <code>"interact"</code> describes an interpoint
interaction structure, before it has been fitted to point pattern
data. The irregular parameters of the interaction (such as the
interaction range) are fixed, but the regular parameters
(such as interaction strength) are undetermined.
Objects of this class are created by the functions
<code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Strauss">Strauss</a></code> and so on.
The main use of such objects is in a call to <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The function <code>as.interact</code> is generic, with methods for the classes
<code>"ppm"</code>, <code>"fii"</code> and <code>"interact"</code>. 
The result is an object of class <code>"interact"</code> which can be printed.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code> representing the 
interpoint interaction. This object can be printed and plotted.
</p>


<h3>Note on parameters</h3>

<p>This function does <b>not</b> extract the fitted coefficients
of the interaction. To extract the fitted interaction including
the fitted coefficients, use <code><a href="#topic+fitin">fitin</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitin">fitin</a></code>,
<code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   model &lt;- ppm(cells ~1, Strauss(0.07))
   f &lt;- as.interact(model)
   f
</code></pre>

<hr>
<h2 id='as.layered.msr'>Convert Measure To Layered Object</h2><span id='topic+as.layered.msr'></span>

<h3>Description</h3>

<p>Converts a measure into a layered object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'msr'
as.layered(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.layered.msr_+3A_x">X</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the object <code>X</code>
into an object of class <code>"layered"</code>.
</p>
<p>It is a method for the generic <code><a href="spatstat.geom.html#topic+as.layered">as.layered</a></code>
for the class of measures.
</p>
<p>If <code>X</code> is a vector-valued measure,
then <code>as.layered(X)</code> consists of several layers,
each containing a scalar-valued measure.
</p>


<h3>Value</h3>

<p>An object of class <code>"layered"</code> (see <code><a href="spatstat.geom.html#topic+layered">layered</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.layered">as.layered</a></code>,
<code><a href="#topic+msr">msr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   P &lt;- rpoispp(100)
   fit &lt;- ppm(P ~ x+y)
   rs &lt;- residuals(fit, type="score")
   as.layered(rs)
</code></pre>

<hr>
<h2 id='as.owin.ppm'>Convert Data To Class owin</h2><span id='topic+as.owin.ppm'></span><span id='topic+as.owin.kppm'></span><span id='topic+as.owin.dppm'></span><span id='topic+as.owin.slrm'></span><span id='topic+as.owin.msr'></span>

<h3>Description</h3>

<p>Converts data specifying an observation window
in any of several formats, into an object of class <code>"owin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppm'
as.owin(W, ..., from=c("points", "covariates"), fatal=TRUE)

 ## S3 method for class 'kppm'
as.owin(W, ..., from=c("points", "covariates"), fatal=TRUE)

 ## S3 method for class 'dppm'
as.owin(W, ..., from=c("points", "covariates"), fatal=TRUE)

 ## S3 method for class 'slrm'
as.owin(W, ..., from=c("points", "covariates"))

 ## S3 method for class 'msr'
as.owin(W, ..., fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin.ppm_+3A_w">W</code></td>
<td>

<p>Data specifying an observation window, in any of several formats
described under <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="as.owin.ppm_+3A_fatal">fatal</code></td>
<td>

<p>Logical value determining what to do
if the data cannot be converted to an observation window.
See Details.
</p>
</td></tr>
<tr><td><code id="as.owin.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.owin.ppm_+3A_from">from</code></td>
<td>
<p>Character string. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"owin"</code> is a way of specifying the observation window
for a point pattern. See <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code> for an overview.
</p>
<p>The generic function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
converts data in any of several formats 
into an object of class <code>"owin"</code> for use by the <span class="pkg">spatstat</span>
package. The function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
is generic, with methods
for different classes of objects, and a default method.
</p>
<p>The argument <code>W</code> may be
</p>

<ul>
<li>
<p>an object of class <code>"owin"</code>
</p>
</li>
<li>
<p>a structure with entries <code>xrange</code>, <code>yrange</code> specifying the 
<code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xmin</code>, <code>xmax</code>, <code>ymin</code>,
<code>ymax</code> (in any order) 
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle.
This will accept objects of class <code>bbox</code> in the <code>sf</code> package.
</p>
</li>
<li>
<p>a numeric vector of length 4
(interpreted as <code>(xmin, xmax, ymin, ymax)</code> in that order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
</p>
</li>
<li>
<p>a structure with entries named <code>xl</code>, <code>xu</code>, <code>yl</code>, <code>yu</code>
(in any order)
specifying the <code class="reqn">x</code> and <code class="reqn">y</code> dimensions of a rectangle
as <code>(xmin, xmax) = (xl, xu)</code> and 
<code>(ymin, ymax) = (yl, yu)</code>. This will accept objects of
class <code>spp</code> used in the Venables and Ripley <span class="pkg">spatial</span>
package.
</p>
</li>
<li>
<p>an object of class <code>"ppp"</code> representing a point pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"psp"</code> representing a line segment pattern.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"tess"</code> representing a tessellation.
In this case, the object's <code>window</code> structure will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"quad"</code> representing a quadrature scheme.
In this case, the window of the <code>data</code> component will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"im"</code> representing a pixel image.
In this case, a window of type <code>"mask"</code> will be returned,
with the same pixel raster coordinates as the image.
An image pixel value of <code>NA</code>, signifying that the pixel
lies outside the window, is transformed into the logical value
<code>FALSE</code>, which is the corresponding convention for window masks.
</p>
</li>
<li>
<p>an object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"dppm"</code>
representing a fitted point process
model. In this case, if <code>from="data"</code> (the default),
<code>as.owin</code> extracts the  original point
pattern data to which the model was fitted, and returns the
observation window of this point pattern. If
<code>from="covariates"</code> then <code>as.owin</code> extracts the
covariate images to which the model was fitted,
and returns a binary mask window that specifies the pixel locations.
</p>
</li>
<li>
<p>an object of class <code>"lpp"</code>
representing a point pattern on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>an object of class <code>"lppm"</code>
representing a fitted point process model on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly three columns. Each row of the
data frame corresponds to one pixel. Each row contains the
<code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel, and a logical value
indicating whether the pixel lies inside the window.   
</p>
</li>
<li>
<p>A <code>data.frame</code> with exactly two columns. Each row of the
data frame contains the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates of a pixel
that lies inside the window.
</p>
</li>
<li>
<p>an object of class <code>"distfun"</code>, <code>"nnfun"</code>
or <code>"funxy"</code> representing a function of spatial location,
defined on a spatial domain. The spatial domain of the function will be
extracted.
</p>
</li>
<li>
<p>an object of class <code>"rmhmodel"</code> representing a
point process model that can be simulated using <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
The window (spatial domain) of the model will be extracted.
The window may be <code>NULL</code> in some circumstances (indicating that the
simulation window has not yet been determined). This is not treated
as an error, because the argument <code>fatal</code> defaults to
<code>FALSE</code> for this method.
</p>
</li>
<li>
<p>an object of class <code>"layered"</code> representing a
list of spatial objects. See <code><a href="spatstat.geom.html#topic+layered">layered</a></code>.
In this case, <code>as.owin</code> will be applied to each
of the objects in the list, and the union of these windows
will be returned.
</p>
</li>
<li>
<p>an object of some other suitable class from another package.
For full details, see <code>vignette('shapefiles')</code>.
</p>
</li></ul>

<p>If the argument <code>W</code> is not in one of these formats
and cannot be converted to a window, then an error will
be generated (if <code>fatal=TRUE</code>) or a value of <code>NULL</code>
will be returned (if <code>fatal=FALSE</code>).
</p>
<p>When <code>W</code> is a data frame, the argument <code>step</code>
can be used to specify the pixel grid spacing; otherwise, the spacing
will be guessed from the data.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.random.html#topic+as.owin.rmhmodel">as.owin.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+as.owin.lpp">as.owin.lpp</a></code>.
</p>
<p><code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>,
<code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>
<p>Additional methods for <code>as.owin</code> may be provided
by other packages outside the <span class="pkg">spatstat</span> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ 1)
  as.owin(fit)
</code></pre>

<hr>
<h2 id='as.ppm'>Extract Fitted Point Process Model</h2><span id='topic+as.ppm'></span><span id='topic+as.ppm.ppm'></span><span id='topic+as.ppm.profilepl'></span><span id='topic+as.ppm.kppm'></span><span id='topic+as.ppm.dppm'></span><span id='topic+as.ppm.rppm'></span>

<h3>Description</h3>

<p>Extracts the fitted point process model from
some kind of fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ppm(object)

## S3 method for class 'ppm'
as.ppm(object)

## S3 method for class 'profilepl'
as.ppm(object)

## S3 method for class 'kppm'
as.ppm(object)

## S3 method for class 'dppm'
as.ppm(object)

## S3 method for class 'rppm'
as.ppm(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ppm_+3A_object">object</code></td>
<td>
<p>An object that includes a
fitted Poisson or Gibbs point process model.
An object of class <code>"ppm"</code>, <code>"profilepl"</code>, <code>"kppm"</code>,
<code>"dppm"</code> or <code>"rppm"</code>,
or possibly other classes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.ppm</code> extracts 
the fitted point process model (of class <code>"ppm"</code>)
from a suitable object.
</p>
<p>The function <code>as.ppm</code> is generic, with methods for the classes
<code>"ppm"</code>, <code>"profilepl"</code>, <code>"kppm"</code>, <code>"dppm"</code>
and <code>"rppm"</code>, and possibly for other classes.
</p>
<p>For the class <code>"profilepl"</code> of models fitted by maximum profile
pseudolikelihood, the method <code>as.ppm.profilepl</code> extracts the
fitted point process model (with the optimal values of the
irregular parameters).
</p>
<p>For the class <code>"kppm"</code> of models fitted by minimum contrast (or Palm or composite likelihood)
using Waagepetersen's two-step estimation procedure
(see <code><a href="#topic+kppm">kppm</a></code>), the method <code>as.ppm.kppm</code>
extracts the Poisson point process model that is fitted in the
first stage of the procedure.
</p>
<p>The behaviour for the class <code>"dppm"</code> is analogous to the
<code>"kppm"</code> case above.
</p>
<p>For the class <code>"rppm"</code> of models fitted by recursive partitioning
(regression trees), the method <code>as.ppm.rppm</code> extracts the
corresponding loglinear model that is fitted in the first stage of the
procedure (whose purpose is merely to identify and evaluate the 
explanatory variables).  
</p>


<h3>Value</h3>

<p>An object of class <code>"ppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+profilepl">profilepl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # fit a model by profile maximum pseudolikelihood
   rvals &lt;- data.frame(r=(1:10)/100)
   pfit &lt;- profilepl(rvals, Strauss, cells, ~1)
   # extract the fitted model
   fit &lt;- as.ppm(pfit)
</code></pre>

<hr>
<h2 id='auc.ppm'>
Area Under ROC Curve
</h2><span id='topic+auc.ppm'></span><span id='topic+auc.kppm'></span><span id='topic+auc.slrm'></span>

<h3>Description</h3>

<p>Compute the AUC (area under the Receiver Operating Characteristic
curve) for
a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
auc(X, ...)

## S3 method for class 'kppm'
auc(X, ...)

## S3 method for class 'slrm'
auc(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc.ppm_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>)
or fitted point process model (object of class <code>"ppm"</code>,
<code>"kppm"</code>, <code>"slrm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="auc.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the AUC, the area under the Receiver Operating
Characteristic curve. The ROC itself is computed by <code><a href="spatstat.explore.html#topic+roc">roc</a></code>.
</p>
<p>For a fitted point process model <code>X</code>,
the AUC measures the ability of the
fitted model intensity to separate the spatial domain
into areas of high and low density of points.
Suppose <code class="reqn">\lambda(u)</code> is the intensity function of the model.
The AUC is the probability that
<code class="reqn">\lambda(x_i) &gt; \lambda(U)</code>.
That is, AUC is the probability that a randomly-selected data point
has higher predicted intensity than does a randomly-selected spatial
location.
The AUC is <b>not</b> a measure of the goodness-of-fit of the model
(Lobo et al, 2007).
</p>
<p>(For spatial logistic regression models (class <code>"slrm"</code>)
replace &ldquo;intensity&rdquo; by &ldquo;probability of presence&rdquo;
in the text above.)
</p>


<h3>Value</h3>

<p>Numeric.
For <code>auc.ppm</code>, <code>auc.kppm</code> and <code>auc.lppm</code>, the result is a 
numeric vector of length 2 giving the AUC value 
and the theoretically expected AUC value for this model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+roc">roc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(swedishpines ~ x+y)
  auc(fit)
</code></pre>

<hr>
<h2 id='BadGey'>Hybrid Geyer Point Process Model</h2><span id='topic+BadGey'></span>

<h3>Description</h3>

<p>Creates an instance of the Baddeley-Geyer point process model, defined
as a hybrid of several Geyer interactions. The model
can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BadGey(r, sat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BadGey_+3A_r">r</code></td>
<td>
<p>vector of interaction radii</p>
</td></tr>
<tr><td><code id="BadGey_+3A_sat">sat</code></td>
<td>

<p>vector of saturation parameters,
or a single common value of saturation parameter
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is Baddeley's generalisation of the
Geyer saturation point process model,
described in <code><a href="#topic+Geyer">Geyer</a></code>, to a process with multiple interaction
distances. 
</p>
<p>The BadGey point process with interaction radii
<code class="reqn">r_1,\ldots,r_k</code>,
saturation thresholds <code class="reqn">s_1,\ldots,s_k</code>,
intensity parameter <code class="reqn">\beta</code> and
interaction parameters
<code class="reqn">\gamma_1,\ldots,gamma_k</code>,
is the point process
in which each point
<code class="reqn">x_i</code> in the pattern <code class="reqn">X</code>
contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">
    \beta \gamma_1^{v_1(x_i, X)} \ldots gamma_k^{v_k(x_i,X)}
  </code>
</p>

<p>to the probability density of the point pattern,
where
</p>
<p style="text-align: center;"><code class="reqn">
    v_j(x_i, X) = \min( s_j, t_j(x_i,X) )
  </code>
</p>

<p>where <code class="reqn">t_j(x_i, X)</code> denotes the
number of points in the pattern <code class="reqn">X</code> which lie
within a distance <code class="reqn">r_j</code>
from the point <code class="reqn">x_i</code>. 
</p>
<p><code>BadGey</code> is used to fit this model to data.
The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the piecewise constant Saturated pairwise
interaction is yielded by the function <code>BadGey()</code>.
See the examples below.
</p>
<p>The argument <code>r</code> specifies the vector of interaction distances.
The entries of <code>r</code> must be strictly increasing, positive numbers.
</p>
<p>The argument <code>sat</code> specifies the vector of saturation parameters
that are applied to the point counts <code class="reqn">t_j(x_i, X)</code>.
It should be a vector of the same length as <code>r</code>, and its entries
should be nonnegative numbers. Thus <code>sat[1]</code> is applied to the
count of points within a distance <code>r[1]</code>, and <code>sat[2]</code> to the
count of points within a distance <code>r[2]</code>, etc.
Alternatively <code>sat</code> may be a single number, and this saturation
value will be applied to every count.
</p>
<p>Infinite values of the
saturation parameters are also permitted; in this case
<code class="reqn">v_j(x_i,X) = t_j(x_i,X)</code>
and there is effectively no &lsquo;saturation&rsquo; for the distance range in
question. If all the saturation parameters are set to <code>Inf</code> then
the model is effectively a pairwise interaction process, equivalent to
<code><a href="#topic+PairPiece">PairPiece</a></code> (however the interaction parameters
<code class="reqn">\gamma</code> obtained from <code><a href="#topic+BadGey">BadGey</a></code>
have a complicated relationship to the interaction
parameters <code class="reqn">\gamma</code> obtained from <code><a href="#topic+PairPiece">PairPiece</a></code>).
</p>
<p>If <code>r</code> is a single number, this model is virtually equivalent to the 
Geyer process, see <code><a href="#topic+Geyer">Geyer</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Hybrids</h3>

<p>A &lsquo;hybrid&rsquo; interaction is one which is built by combining
several different interactions (Baddeley et al, 2013).
The <code>BadGey</code> interaction can be described as a 
hybrid of several <code><a href="#topic+Geyer">Geyer</a></code> interactions.
</p>
<p>The <code><a href="#topic+Hybrid">Hybrid</a></code> command can be used to build
hybrids of any interactions. If the <code><a href="#topic+Hybrid">Hybrid</a></code> operator
is applied to several <code><a href="#topic+Geyer">Geyer</a></code> models, the result is
equivalent to a <code>BadGey</code> model.
This can be useful for incremental model selection.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
in collaboration with Hao Wang and Jeff Picka
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 1&ndash;43.
<code>DOI: 10.18637/jss.v055.i11</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+SatPiece">SatPiece</a></code>,
<code><a href="#topic+Hybrid">Hybrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   BadGey(c(0.1,0.2), c(1,1))
   # prints a sensible description of itself
   BadGey(c(0.1,0.2), 1)

   # fit a stationary Baddeley-Geyer model
   ppm(cells ~1, BadGey(c(0.07, 0.1, 0.13), 2))

   # nonstationary process with log-cubic polynomial trend
   
     ppm(cells ~polynom(x,y,3), BadGey(c(0.07, 0.1, 0.13), 2))
   
</code></pre>

<hr>
<h2 id='bc.ppm'>
Bias Correction for Fitted Model
</h2><span id='topic+bc'></span><span id='topic+bc.ppm'></span>

<h3>Description</h3>

<p>Applies a first-order bias correction to a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bc(fit, ...)

  ## S3 method for class 'ppm'
bc(fit, ..., nfine = 256)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc.ppm_+3A_fit">fit</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code>)
or a model of some other class.
</p>
</td></tr>
<tr><td><code id="bc.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments are currently ignored.
</p>
</td></tr>
<tr><td><code id="bc.ppm_+3A_nfine">nfine</code></td>
<td>

<p>Grid dimensions for fine grid of locations.
An integer, or a pair of integers. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command applies the first order Newton-Raphson bias correction method of
Baddeley and Turner (2014, sec 4.2) to a fitted model.
The function <code>bc</code> is generic, with a method for fitted point
process models of class <code>"ppm"</code>.
</p>
<p>A fine grid of locations, of dimensions <code>nfine * nfine</code> or
<code>nfine[2] * nfine[1]</code>, is created over the original window of the
data, and the intensity or conditional intensity of the fitted model is
calculated on this grid. The result is used to update the fitted
model parameters once by a Newton-Raphson update.
</p>
<p>This is only useful if the quadrature points used to fit the original
model <code>fit</code> are coarser than the grid of points specified by
<code>nfine</code>. 
</p>


<h3>Value</h3>

<p>A numeric vector, of the same length as <code>coef(fit)</code>, giving updated
values for the fitted model coefficients.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2014)
Bias correction for parameter estimates of spatial point process models.
<em>Journal of Statistical Computation and Simulation</em>
<b>84</b>, 1621&ndash;1643.
DOI: 10.1080/00949655.2012.755976
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rex">rex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ x, Strauss(0.07))
  coef(fit)
  if(!interactive()) {
    bc(fit, nfine=64)
  } else {
    bc(fit)
  }
</code></pre>

<hr>
<h2 id='berman.test.ppm'>Berman's Tests for Point Process Model</h2><span id='topic+berman.test.ppm'></span>

<h3>Description</h3>

<p>Tests the goodness-of-fit of a Poisson point process model
using methods of Berman (1986).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
berman.test(model, covariate,
                         which = c("Z1", "Z2"),
               alternative = c("two.sided", "less", "greater"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="berman.test.ppm_+3A_model">model</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code> or
<code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="berman.test.ppm_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
An image (object of class <code>"im"</code>)
or a function.
</p>
</td></tr>
<tr><td><code id="berman.test.ppm_+3A_which">which</code></td>
<td>

<p>Character string specifying the choice of test.
</p>
</td></tr>
<tr><td><code id="berman.test.ppm_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="berman.test.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the pixel resolution
(arguments <code>dimyx</code>, <code>eps</code> and <code>rule.eps</code>
passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>)
or other undocumented features.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson point
process model fitted to point pattern data. The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using either of two test statistics
<code class="reqn">Z_1</code> and <code class="reqn">Z_2</code> proposed by Berman (1986).
The <code class="reqn">Z_1</code> test is also known as the
Lawson-Waller test.
</p>
<p>The function <code>berman.test</code> is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>)
and point process models (<code>"ppm"</code> or <code>"lppm"</code>).
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern dataset (object of class
<code>"ppp"</code> or <code>"lpp"</code>), then
<code>berman.test(X, ...)</code> performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model
(object of class <code>"ppm"</code> or <code>"lppm"</code>)
then <code>berman.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. In this case,
<code>model</code> should be a Poisson point process.
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model.
Thus, you must nominate a spatial covariate for this test.
</p>
<p>The argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> containing the values
of a spatial function.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.  
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected.
</p>
<p>Next the values of the <code>covariate</code> at all locations in the
observation window are evaluated. The point process intensity
of the fitted model is also evaluated at all locations in the window.
</p>

<ul>
<li><p> If <code>which="Z1"</code>,
the test statistic <code class="reqn">Z_1</code> is computed as follows.
The sum <code class="reqn">S</code> of the covariate values at all data
points is evaluated. The predicted mean <code class="reqn">\mu</code> and variance
<code class="reqn">\sigma^2</code> of <code class="reqn">S</code> are computed
from the values of the covariate at all locations in the window.
Then we compute <code class="reqn">Z_1 = (S-\mu)/\sigma</code>.
Closely-related tests were proposed independently 
by Waller et al (1993) and Lawson (1993)
so this test is often termed the 
Lawson-Waller test in epidemiological literature.
</p>
</li>
<li><p> If <code>which="Z2"</code>,
the test statistic <code class="reqn">Z_2</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window, weighted by the point process intensity,
are compiled into a cumulative distribution function <code class="reqn">F</code>.
The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers.
The standardised sample mean of these numbers is the
statistic <code class="reqn">Z_2</code>. 
</p>
</li></ul>

<p>In both cases the null distribution of the test statistic
is the standard normal distribution, approximately.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> (hypothesis test)
and also of class <code>"bermantest"</code>,
containing the results of the test. The return value can be
plotted (by <code><a href="spatstat.explore.html#topic+plot.bermantest">plot.bermantest</a></code>) or printed
to give an informative summary of the test.
</p>


<h3>Warning</h3>

<p>The meaning of a one-sided test must be carefully scrutinised: see
the printed output.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>
<p>Lawson, A.B. (1993)
On the analysis of mortality events around a
prespecified fixed point.
<em>Journal of the Royal Statistical Society, Series A</em>
<b>156</b> (3) 363&ndash;377.
</p>
<p>Waller, L., Turnbull, B., Clark, L.C. and Nasca, P. (1992)
Chronic Disease Surveillance and testing of
clustering of disease and exposure: Application to
leukaemia incidence and TCE-contaminated dumpsites
in upstate New York.
<em>Environmetrics</em> <b>3</b>, 281&ndash;300.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Berman's data
   X &lt;- copper$SouthPoints
   L &lt;- copper$SouthLines
   D &lt;- distmap(L, eps=1)
   # test of fitted model
   fit &lt;- ppm(X ~ x+y)
   berman.test(fit, D)
</code></pre>

<hr>
<h2 id='cauchy.estK'>Fit the Neyman-Scott cluster process with Cauchy kernel</h2><span id='topic+cauchy.estK'></span>

<h3>Description</h3>

<p>Fits the Neyman-Scott Cluster point process with Cauchy kernel
to a point pattern dataset by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cauchy.estK(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cauchy.estK_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="cauchy.estK_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the model.
</p>
</td></tr>
<tr><td><code id="cauchy.estK_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="cauchy.estK_+3A_q">q</code>, <code id="cauchy.estK_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="cauchy.estK_+3A_rmin">rmin</code>, <code id="cauchy.estK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="cauchy.estK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Neyman-Scott cluster point process model
with Cauchy kernel to a point pattern dataset
by the Method of Minimum Contrast, using the <code class="reqn">K</code> function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The <code class="reqn">K</code> function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the <code class="reqn">K</code> function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Neyman-Scott cluster point process
with Cauchy kernel to <code>X</code>,
by finding the parameters of the Matern Cluster model
which give the closest match between the
theoretical <code class="reqn">K</code> function of the Matern Cluster process
and the observed <code class="reqn">K</code> function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The model is described in Jalilian et al (2013).
It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
follow a common distribution described in Jalilian et al (2013).
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of the point process intensity <code class="reqn">\lambda</code>.
Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The corresponding model can be simulated using <code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>.
</p>
<p>For computational reasons, the optimisation procedure uses the parameter 
<code>eta2</code>, which is equivalent to <code>4 * scale^2</code>
where <code>scale</code> is the scale parameter for the model
as used in <code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>.
</p>
<p>Homogeneous or inhomogeneous Neyman-Scott/Cauchy models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code> and the fitted models
can be simulated using <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ghorbani, M. (2013) Cauchy cluster process.
<em>Metrika</em> <b>76</b>, 697&ndash;706.
</p>
<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+cauchy.estpcf">cauchy.estpcf</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
<code><a href="#topic+vargamma.estK">vargamma.estK</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kmodel">Kmodel</a></code>.
</p>
<p><code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code> to simulate the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- cauchy.estK(redwood)
    u
    plot(u)
</code></pre>

<hr>
<h2 id='cauchy.estpcf'>Fit the Neyman-Scott cluster process with Cauchy kernel</h2><span id='topic+cauchy.estpcf'></span>

<h3>Description</h3>

<p>Fits the Neyman-Scott Cluster point process with Cauchy kernel
to a point pattern dataset by the Method of Minimum Contrast,
using the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cauchy.estpcf(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...,
            pcfargs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cauchy.estpcf_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the model.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_q">q</code>, <code id="cauchy.estpcf_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_rmin">rmin</code>, <code id="cauchy.estpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="cauchy.estpcf_+3A_pcfargs">pcfargs</code></td>
<td>

<p>Optional list containing arguments passed to <code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
to control the smoothing in the estimation of the
pair correlation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Neyman-Scott cluster point process model
with Cauchy kernel to a point pattern dataset
by the Method of Minimum Contrast, using the pair correlation function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The pair correlation function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the pair correlation function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Neyman-Scott cluster point process
with Cauchy kernel to <code>X</code>,
by finding the parameters of the Matern Cluster model
which give the closest match between the
theoretical pair correlation function of the Matern Cluster process
and the observed pair correlation function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The model is described in Jalilian et al (2013).
It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
follow a common distribution described in Jalilian et al (2013).
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of the point process intensity <code class="reqn">\lambda</code>.
Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The corresponding model can be simulated using <code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>.
</p>
<p>For computational reasons, the optimisation procedure internally uses
the parameter <code>eta2</code>, which is equivalent to <code>4 * scale^2</code>
where <code>scale</code> is the scale parameter for the model as used in
<code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>.
</p>
<p>Homogeneous or inhomogeneous Neyman-Scott/Cauchy models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code> and the fitted models
can be simulated using <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ghorbani, M. (2013) Cauchy cluster process.
<em>Metrika</em> <b>76</b>, 697&ndash;706.
</p>
<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+cauchy.estK">cauchy.estK</a></code>,
<code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code>,
<code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code>,
<code><a href="#topic+vargamma.estpcf">vargamma.estpcf</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="#topic+pcfmodel">pcfmodel</a></code>.
</p>
<p><code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code> to simulate the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- cauchy.estpcf(redwood)
    u
    plot(u, legendpos="topright")
</code></pre>

<hr>
<h2 id='cdf.test.mppm'>Spatial Distribution Test for Multiple Point Process Model</h2><span id='topic+cdf.test.mppm'></span>

<h3>Description</h3>

<p>Performs a spatial distribution test
of a point process model fitted to multiple spatial point
patterns.  The test compares the observed
and predicted distributions of the values of a spatial covariate,
using either the Kolmogorov-Smirnov,
Cramer-von Mises 
or Anderson-Darling test of goodness-of-fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppm'
cdf.test(model, covariate, test=c("ks", "cvm", "ad"), ...,
            nsim=19, verbose=TRUE, interpolate=FALSE, fast=TRUE, jitter=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.test.mppm_+3A_model">model</code></td>
<td>

<p>An object of class <code>"mppm"</code> representing a point process model
fitted to multiple spatial point patterns.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
A function, a pixel image, a list of functions, a list of pixel
images, a hyperframe, a character string containing the name
of one of the covariates in <code>model</code>, or one of the strings
<code>"x"</code> or <code>"y"</code>.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_test">test</code></td>
<td>

<p>Character string identifying the test to be performed:
<code>"ks"</code> for Kolmogorov-Smirnov test,
<code>"cvm"</code> for Cramer-von Mises test
or <code>"ad"</code> for Anderson-Darling test.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>
to control the test.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations which should be generated,
if a Monte Carlo test is required.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag indicating whether to print
progress reports.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical flag indicating whether to interpolate between
pixel values when <code>covariate</code> is a pixel image.
See <em>Details</em>.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_fast">fast</code></td>
<td>

<p>Logical flag. If <code>TRUE</code>, values of the covariate
are only sampled at the original quadrature points used to
fit the model. If <code>FALSE</code>, values of the covariate
are sampled at all pixels, which can be slower by three orders of
magnitude.
</p>
</td></tr>
<tr><td><code id="cdf.test.mppm_+3A_jitter">jitter</code></td>
<td>

<p>Logical flag. If <code>TRUE</code>, observed values of the covariate
are perturbed by adding small random values, to avoid
tied observations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code> for the class <code>mppm</code>.
</p>
<p>This function performs a goodness-of-fit test of
a point process model that has been fitted to multiple point patterns.
The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using the Kolmogorov-Smirnov,
Cramer-von Mises 
or Anderson-Darling test of goodness-of-fit.
These are exact tests if the model is Poisson;
otherwise, for a Gibbs model, a Monte Carlo p-value is computed by
generating simulated realisations of the model and applying the
selected goodness-of-fit test to each simulation.
</p>
<p>The argument <code>model</code> should be a fitted point process model
fitted to multiple point patterns
(object of class <code>"mppm"</code>). 
</p>
<p>The argument <code>covariate</code> contains the values of a spatial
function. It can be
</p>

<ul>
<li><p> a <code>function(x,y)</code>
</p>
</li>
<li><p> a pixel image (object of class <code>"im"</code>
</p>
</li>
<li><p> a list of <code>function(x,y)</code>, one for each point pattern
</p>
</li>
<li><p> a list of pixel images, one for each point pattern
</p>
</li>
<li><p> a hyperframe (see <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>)
of which the first
column will be taken as containing the covariate
</p>
</li>
<li><p> a character string giving the name of one of the covariates
in <code>model</code>
</p>
</li>
<li><p> one of the character strings <code>"x"</code> or <code>"y"</code>,
indicating the spatial coordinates.
</p>
</li></ul>

<p>If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.  
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected. 
</p>
<p>The predicted distribution of the values of the <code>covariate</code>
under the fitted <code>model</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window are evaluated,
weighted according to the point process intensity of the fitted model,
and compiled into a cumulative distribution function <code class="reqn">F</code> using
<code><a href="spatstat.geom.html#topic+ewcdf">ewcdf</a></code>.
</p>
<p>The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers. 
A goodness-of-fit test of the uniform distribution is applied
to these numbers using <code><a href="stats.html#topic+ks.test">ks.test</a></code>,
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code> or <code><a href="goftest.html#topic+ad.test">ad.test</a></code>.
</p>
<p>The argument <code>interpolate</code> determines 
how pixel values will be handled when <code>covariate</code> is a pixel image.
The value of the covariate at a data point is obtained
by looking up the value of the nearest pixel if
<code>interpolate=FALSE</code>, or by linearly interpolating
between the values of the four nearest pixels 
if <code>interpolate=TRUE</code>. Linear interpolation is slower,
but is sometimes necessary to avoid tied values of the covariate
arising when the pixel grid is coarse.
</p>
<p>If <code>model</code> is a Poisson point process, then the 
Kolmogorov-Smirnov,
Cramer-von Mises 
and Anderson-Darling tests are theoretically exact.
This test was apparently first described (in the context of
spatial data, and for Kolmogorov-Smirnov) by Berman (1986).
See also Baddeley et al (2005).
</p>
<p>If <code>model</code> is not a Poisson point process, then the
Kolmogorov-Smirnov,
Cramer-von Mises 
and Anderson-Darling tests are biased.
Instead they are used as the basis of a Monte Carlo test.
First <code>nsim</code> simulated realisations of the model will be generated.
Each simulated realisation consists of a list of simulated point
patterns, one for each of the original data patterns. This
can take a very long time. The model is then re-fitted to each
simulation, and the refitted model is subjected to the goodness-of-fit
test described above. A Monte Carlo p-value is then computed by
comparing the p-value of the original test with the
p-values obtained from the simulations.
</p>


<h3>Value</h3>

<p>An object of class <code>"cdftest"</code> and <code>"htest"</code>
containing the results of the
test. See <code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="#topic+mppm">mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # three i.i.d. realisations of nonuniform Poisson process
   lambda &lt;- as.im(function(x,y) { 200 * exp(x) }, square(1))
   dat &lt;- hyperframe(X=list(rpoispp(lambda), rpoispp(lambda), rpoispp(lambda)))

   # fit uniform Poisson process
   fit0 &lt;- mppm(X~1, dat)
   # fit correct nonuniform Poisson process
   fit1 &lt;- mppm(X~x, dat)

   # test wrong model
   cdf.test(fit0, "x")
   # test right model
   cdf.test(fit1, "x")

   # Gibbs model
   fitGibbs &lt;- update(fit0, interaction=Strauss(0.05))
   ns &lt;- if(interactive()) 19 else 2
   cdf.test(fitGibbs, "x", nsim=ns)
</code></pre>

<hr>
<h2 id='cdf.test.ppm'>Spatial Distribution Test for Point Pattern or Point Process Model</h2><span id='topic+cdf.test.ppm'></span><span id='topic+cdf.test.slrm'></span>

<h3>Description</h3>

<p>Performs a test of goodness-of-fit of a point process model.
The observed and predicted distributions
of the values of a spatial covariate are compared using either the
Kolmogorov-Smirnov test,
Cramer-von Mises test
or Anderson-Darling test.
For non-Poisson models, a Monte Carlo test is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
cdf.test(model, covariate,  test=c("ks", "cvm", "ad"), ...,
          interpolate=TRUE, jitter=TRUE, nsim=99, verbose=TRUE)

## S3 method for class 'slrm'
cdf.test(model, covariate,  test=c("ks", "cvm", "ad"), ...,
          modelname=NULL, covname=NULL)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.test.ppm_+3A_model">model</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code> or <code>"lppm"</code>)
or fitted spatial logistic regression (object of class <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
A function, a pixel image (object of class <code>"im"</code>),
a list of pixel images, or one of the characters
<code>"x"</code> or <code>"y"</code> indicating the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_test">test</code></td>
<td>

<p>Character string identifying the test to be performed:
<code>"ks"</code> for Kolmogorov-Smirnov test,
<code>"cvm"</code> for Cramer-von Mises test
or <code>"ad"</code> for Anderson-Darling test.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+ks.test">ks.test</a></code>
(from the <span class="pkg">stats</span> package) or 
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code><a href="goftest.html#topic+ad.test">ad.test</a></code> (from the <span class="pkg">goftest</span> package)
to control the test;
and arguments passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>
to control the pixel resolution.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical flag indicating whether to interpolate pixel images.
If <code>interpolate=TRUE</code>, the value of the covariate
at each point of <code>X</code> will be approximated by interpolating
the nearby pixel values.
If <code>interpolate=FALSE</code>, the nearest pixel value will be used.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_jitter">jitter</code></td>
<td>

<p>Logical flag. If <code>jitter=TRUE</code>, values of the covariate
will be slightly perturbed at random, to avoid tied values in the test.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_modelname">modelname</code>, <code id="cdf.test.ppm_+3A_covname">covname</code></td>
<td>

<p>Character strings giving alternative names for <code>model</code>
and <code>covariate</code> to be used in labelling plot axes.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations from the <code>model</code> to be used
for the Monte Carlo test, when <code>model</code> is not a Poisson process.
</p>
</td></tr>
<tr><td><code id="cdf.test.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports when
performing a Monte Carlo test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson or Gibbs point
process model fitted to point pattern data. The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using the Kolmogorov-Smirnov test,
the Cramer-von Mises test
or the Anderson-Darling test. For Gibbs models, a Monte Carlo test is
performed using these test statistics.
</p>
<p>The function <code>cdf.test</code> is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>),
point process models (<code>"ppm"</code> or <code>"lppm"</code>)
and spatial logistic regression models (<code>"slrm"</code>).
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern dataset (object of class
<code>"ppp"</code>), then <code>cdf.test(X, ...)</code>
performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
For a multitype point pattern, the uniform intensity
is assumed to depend on the type of point (sometimes called
Complete Spatial Randomness and Independence, CSRI).
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model
(object of class <code>"ppm"</code> or <code>"lppm"</code>)
then <code>cdf.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. 
</p>
</li>
<li>
<p>If <code>model</code> is a fitted spatial logistic regression
(object of class <code>"slrm"</code>) then <code>cdf.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. 
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model,
using a classical goodness-of-fit test.
Thus, you must nominate
a spatial covariate for this test.
</p>
<p>If <code>X</code> is a point pattern that does not have marks,
the argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> containing the values
of a spatial function, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.
</p>
<p>If <code>X</code> is a multitype point pattern, the argument <code>covariate</code>
can be either a <code>function(x,y,marks)</code>,
or a pixel image, or a list of pixel images corresponding to
each possible mark value, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates. 
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected. 
</p>
<p>The predicted distribution of the values of the <code>covariate</code>
under the fitted <code>model</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window are evaluated,
weighted according to the point process intensity of the fitted model,
and compiled into a cumulative distribution function <code class="reqn">F</code> using
<code><a href="spatstat.geom.html#topic+ewcdf">ewcdf</a></code>.
</p>
<p>The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers. The
A goodness-of-fit test of the uniform distribution is applied
to these numbers using <code>stats::<a href="stats.html#topic+ks.test">ks.test</a></code>,
<code>goftest::<a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code>goftest::<a href="goftest.html#topic+ad.test">ad.test</a></code>.
</p>
<p>This test was apparently first described (in the context of
spatial data, and using Kolmogorov-Smirnov) by Berman (1986).
See also Baddeley et al (2005).
</p>
<p>If <code>model</code> is not a Poisson process, then
a Monte Carlo test is performed, by generating <code>nsim</code>
point patterns which are simulated realisations of the <code>model</code>,
re-fitting the model to each simulated point pattern, 
and calculating the test statistic for each fitted model.
The Monte Carlo <code class="reqn">p</code> value is determined by comparing
the simulated values of the test statistic 
with the value for the original data.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>
<p>The return value also belongs to the class <code>"cdftest"</code>
for which there is a plot method <code><a href="spatstat.explore.html#topic+plot.cdftest">plot.cdftest</a></code>.
The plot method displays the empirical cumulative distribution
function of the covariate at the data points, and the predicted
cumulative distribution function of the covariate under the model,
plotted against the value of the covariate.
</p>
<p>The argument <code>jitter</code> controls whether covariate values are
randomly perturbed, in order to avoid ties.
If the original data contains any ties in the covariate (i.e. points
with equal values of the covariate), and if <code>jitter=FALSE</code>, then 
the Kolmogorov-Smirnov test implemented in <code><a href="stats.html#topic+ks.test">ks.test</a></code>
will issue a warning that it cannot calculate the exact <code class="reqn">p</code>-value.
To avoid this, if <code>jitter=TRUE</code> each value of the covariate will
be perturbed by adding a small random value. The perturbations are
normally distributed with standard deviation equal to one hundredth of
the range of values of the covariate. This prevents ties, 
and the <code class="reqn">p</code>-value is still correct. There is
a very slight loss of power.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> containing the results of the
test. See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for details. The return value can be
printed to give an informative summary of the test.
</p>
<p>The value also belongs to the class <code>"cdftest"</code> for which there is
a plot method.
</p>


<h3>Warning</h3>

<p>The outcome of the test involves a small amount of random variability,
because (by default) the coordinates are randomly perturbed to
avoid tied values. Hence, if <code>cdf.test</code> is executed twice, the
<code class="reqn">p</code>-values will not be exactly the same. To avoid this behaviour,
set <code>jitter=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R.,
Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+plot.cdftest">plot.cdftest</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="spatstat.explore.html#topic+berman.test">berman.test</a></code>,
<code><a href="stats.html#topic+ks.test">ks.test</a></code>,
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code>,
<code><a href="goftest.html#topic+ad.test">ad.test</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   op &lt;- options(useFancyQuotes=FALSE)


   # fit inhomogeneous Poisson model and test
   model &lt;- ppm(nztrees ~x)
   cdf.test(model, "x")

   if(interactive()) {
     # synthetic data: nonuniform Poisson process
     X &lt;- rpoispp(function(x,y) { 100 * exp(x) }, win=square(1))

     # fit uniform Poisson process
     fit0 &lt;- ppm(X ~1)
     # fit correct nonuniform Poisson process
     fit1 &lt;- ppm(X ~x)

     # test wrong model
     cdf.test(fit0, "x")
     # test right model
     cdf.test(fit1, "x")
   }

   # multitype point pattern
   yimage &lt;- as.im(function(x,y){y}, W=Window(amacrine))
   cdf.test(ppm(amacrine ~marks+y), yimage)

   options(op)
</code></pre>

<hr>
<h2 id='closepaircounts'>
Count Close Pairs of Points
</h2><span id='topic+closepaircounts'></span><span id='topic+crosspaircounts'></span>

<h3>Description</h3>

<p>Low-level functions to count the number of close pairs of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closepaircounts(X, r)

crosspaircounts(X, Y, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closepaircounts_+3A_x">X</code>, <code id="closepaircounts_+3A_y">Y</code></td>
<td>

<p>Point patterns (objects of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="closepaircounts_+3A_r">r</code></td>
<td>

<p>Maximum distance between pairs of points to be counted as close pairs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the efficient low-level functions used by <span class="pkg">spatstat</span>
to count close pairs of points in a point pattern
or between two point patterns. 
</p>
<p><code>closepaircounts(X,r)</code> counts the number of neighbours for
each point in the pattern <code>X</code>. That is, for each point
<code>X[i]</code>, it counts the number of other points <code>X[j]</code>
with <code>j != i</code> such that <code>d(X[i],X[j]) &lt;= r</code> where
<code>d</code> denotes Euclidean distance. The result is an integer vector
<code>v</code> such that <code>v[i]</code> is the number of neighbours of
<code>X[i]</code>.
</p>
<p><code>crosspaircounts(X,Y,r)</code> counts, for each point 
in the pattern <code>X</code>, the number of neighbours in the pattern
<code>Y</code>. That is, for each point
<code>X[i]</code>, it counts the number of points <code>Y[j]</code>
such that <code>d(X[i],X[j]) &lt;= r</code>. The result is an integer vector
<code>v</code> such that <code>v[i]</code> is the number of neighbours of
<code>X[i]</code> in the pattern <code>Y</code>.
</p>


<h3>Value</h3>

<p>An integer vector of length equal to the number of points in <code>X</code>.
</p>


<h3>Warning about accuracy</h3>

<p>The results of these functions may not agree exactly with
the correct answer (as calculated by a human) and may not
be consistent between different computers and different installations
of <span class="rlang"><b>R</b></span>. The discrepancies arise in marginal cases where the interpoint
distance is equal to, or very close to, the threshold <code>rmax</code>.
</p>
<p>Floating-point numbers in a computer
are not mathematical Real Numbers: they are approximations using
finite-precision binary arithmetic.
The approximation is accurate to a tolerance of about
<code>.Machine$double.eps</code>.
</p>
<p>If the true interpoint distance <code class="reqn">d</code> and the threshold <code>rmax</code>
are equal, or if their difference is no more than <code>.Machine$double.eps</code>,
the result may be incorrect.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+closepairs">closepairs</a></code> to identify all close pairs of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   a &lt;- closepaircounts(cells, 0.1)
   sum(a)
   Y &lt;- split(amacrine)
   b &lt;- crosspaircounts(Y$on, Y$off, 0.1)
</code></pre>

<hr>
<h2 id='clusterfield.kppm'>Field of clusters</h2><span id='topic+clusterfield.kppm'></span>

<h3>Description</h3>

<p>Calculate the superposition of cluster kernels at the location of a
point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
clusterfield(model, locations = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterfield.kppm_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster model (object of class
<code>"kppm"</code>), a character string specifying the type of cluster
model, or a function defining the cluster kernel. See Details.
</p>
</td></tr>
<tr><td><code id="clusterfield.kppm_+3A_locations">locations</code></td>
<td>

<p>A point pattern giving the locations of the kernels. Defaults to the
centroid of the observation window for the <code>"kppm"</code> method and
to the center of a unit square otherwise.
</p>
</td></tr>
<tr><td><code id="clusterfield.kppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> or the
cluster kernel. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>clusterfield</code> is generic,
with a method for <code>"kppm"</code> (described here)
and methods for <code>"character"</code> and <code>"function"</code>.
</p>
<p>The method <code>clusterfield.kppm</code> extracts the relevant information
from the fitted model and calls <code><a href="spatstat.random.html#topic+clusterfield.function">clusterfield.function</a></code>.
</p>
<p>The calculations are performed by <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> and
<code>...</code> arguments are passed thereto for control over the pixel
resolution etc.
(These arguments are then passed on to <code><a href="spatstat.geom.html#topic+pixellate.ppp">pixellate.ppp</a></code>
and <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.)
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
</p>
<p><code><a href="spatstat.random.html#topic+clusterfield">clusterfield</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood~1, "Thomas")
  Z &lt;- clusterfield(fit, eps = 0.01)
</code></pre>

<hr>
<h2 id='clusterfit'>Fit Cluster or Cox Point Process Model via Minimum Contrast</h2><span id='topic+clusterfit'></span>

<h3>Description</h3>

<p>Fit a homogeneous or inhomogeneous cluster process or
Cox point process model to a point pattern by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterfit(X, clusters, lambda = NULL, startpar = NULL, ...,
           q = 1/4, p = 2, rmin = NULL, rmax = NULL,
           ctrl=list(q=q, p=p, rmin=rmin, rmax=rmax),
           statistic = NULL, statargs = NULL, algorithm="Nelder-Mead",
           verbose=FALSE, pspace=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterfit_+3A_x">X</code></td>
<td>

<p>Data to which the cluster or Cox model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_clusters">clusters</code></td>
<td>

<p>Character string determining the cluster or Cox model.
Partially matched.
Options are <code>"Thomas"</code>, <code>"MatClust"</code>,
<code>"Cauchy"</code>, <code>"VarGamma"</code> and <code>"LGCP"</code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
Either a single numeric specifying a constant intensity,
a pixel image (object of class <code>"im"</code>) giving the
intensity values at all locations, a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>)
or a <code>function(x,y)</code> which
can be evaluated to give the intensity value at any location.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_startpar">startpar</code></td>
<td>

<p>Vector of initial values of the parameters of the
point process mode. If <code>X</code> is a point pattern sensible defaults
are used. Otherwise rather arbitrary values are used.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_q">q</code>, <code id="clusterfit_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
See <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_rmin">rmin</code>, <code id="clusterfit_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
See <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_ctrl">ctrl</code></td>
<td>

<p>Optional. Named list containing values of the parameters
<code>q,p,rmin,rmax</code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+mincontrast">mincontrast</a>.</code>
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_statistic">statistic</code></td>
<td>

<p>Optional. Name of the summary statistic to be used
for minimum contrast estimation: either <code>"K"</code> or <code>"pcf"</code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_statargs">statargs</code></td>
<td>

<p>Optional list of arguments to be used when calculating
the <code>statistic</code>. See Details.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_algorithm">algorithm</code></td>
<td>

<p>Character string determining the mathematical optimisation algorithm
to be used by <code><a href="stats.html#topic+optim">optim</a></code>. See
the argument <code>method</code> of <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print detailed progress reports
for debugging purposes.
</p>
</td></tr>
<tr><td><code id="clusterfit_+3A_pspace">pspace</code></td>
<td>
<p>For internal use by package code only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the clustering parameters of a cluster or Cox point
process model by the Method of Minimum Contrast, that is, by
matching the theoretical <code class="reqn">K</code>-function of the model to the
empirical <code class="reqn">K</code>-function of the data, as explained in
<code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>If <code>statistic="pcf"</code> (or <code>X</code> appears to be an
estimated pair correlation function) then instead of using the
<code class="reqn">K</code>-function, the algorithm will use the pair correlation
function.
</p>
<p>If <code>X</code> is a point pattern of class <code>"ppp"</code> an estimate of
the summary statistic specfied by <code>statistic</code> (defaults to
<code>"K"</code>) is first computed before minimum contrast estimation is
carried out as described above. In this case the argument
<code>statargs</code> can be used for controlling the summary statistic
estimation. The precise algorithm for computing the summary statistic
depends on whether the intensity specification (<code>lambda</code>) is:
</p>

<dl>
<dt>homogeneous:</dt><dd>
<p>If <code>lambda</code> is <code>NUll</code> or a single numeric the pattern is
considered homogeneous and either <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> is invoked. In this case <code>lambda</code> is
<b>not</b> used for anything when estimating the summary statistic.
</p>
</dd>
<dt>inhomogeneous:</dt><dd>
<p>If <code>lambda</code> is a pixel image (object of class <code>"im"</code>),
a fitted point process model (object of class <code>"ppm"</code> or
<code>"kppm"</code>) or a <code>function(x,y)</code> the pattern is considered
inhomogeneous. In this case either <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code> or
<code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code> is invoked with <code>lambda</code> as an
argument.
</p>
</dd>
</dl>

<p>After the clustering parameters of the model have been estimated by
minimum contrast <code>lambda</code> (if non-null) is used to compute the
additional model parameter <code class="reqn">\mu</code>.
</p>
<p>The algorithm parameters <code>q,p,rmax,rmin</code> are described in the
help for <code><a href="#topic+mincontrast">mincontrast</a></code>. They may be provided either
as individually-named arguments, or as entries in the list
<code>ctrl</code>. The individually-named arguments <code>q,p,rmax,rmin</code>
override the entries in the list <code>ctrl</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. See <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Waagepetersen, R. (2007).
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b> (2007) 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- clusterfit(redwood, "Thomas")
  fit
  if(interactive()){
    plot(fit)
  }
  K &lt;- Kest(redwood)
  fit2 &lt;- clusterfit(K, "MatClust")
</code></pre>

<hr>
<h2 id='clusterkernel.kppm'>
Extract Cluster Offspring Kernel
</h2><span id='topic+clusterkernel.kppm'></span>

<h3>Description</h3>

<p>Given a fitted cluster point process model, this command
returns the probability density of the cluster offspring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kppm'
clusterkernel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterkernel.kppm_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster or Cox model
(object of class <code>"kppm"</code>), or a character string
specifying the type of cluster model.
</p>
</td></tr>
<tr><td><code id="clusterkernel.kppm_+3A_...">...</code></td>
<td>

<p>Parameter values for the model,
when <code>model</code> is a character string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a cluster point process model, this command
returns a <code>function(x,y)</code> giving the two-dimensional
probability density of the cluster offspring points assuming a cluster parent
located at the origin.
</p>
<p>The function <code>clusterkernel</code> is generic,
with methods for class <code>"kppm"</code> (described here)
and <code>"character"</code>
(described in <code><a href="spatstat.random.html#topic+clusterkernel.character">clusterkernel.character</a></code>).
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language with arguments <code>x,y,...</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+clusterkernel.character">clusterkernel.character</a></code>,
<code><a href="spatstat.random.html#topic+clusterfield">clusterfield</a></code>, <code><a href="#topic+kppm">kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ x, "MatClust")
  f &lt;- clusterkernel(fit)
  f(0.05, 0.02)
</code></pre>

<hr>
<h2 id='clusterradius.kppm'>
Compute or Extract Effective Range of Cluster Kernel
</h2><span id='topic+clusterradius.kppm'></span>

<h3>Description</h3>

<p>Given a cluster point process model, this command
returns a value beyond which the the probability density of the
cluster offspring is neglible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kppm'
clusterradius(model, ..., thresh = NULL, precision = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterradius.kppm_+3A_model">model</code></td>
<td>

<p>Cluster model. Either a fitted cluster or Cox model
(object of class <code>"kppm"</code>), or a character string
specifying the type of cluster model.
</p>
</td></tr>
<tr><td><code id="clusterradius.kppm_+3A_...">...</code></td>
<td>

<p>Parameter values for the model,
when <code>model</code> is a character string.
</p>
</td></tr>
<tr><td><code id="clusterradius.kppm_+3A_thresh">thresh</code></td>
<td>

<p>Numerical threshold relative to the cluster kernel value at the
origin (parent location) determining when the cluster kernel
will be considered neglible. A sensible default is provided.
</p>
</td></tr>
<tr><td><code id="clusterradius.kppm_+3A_precision">precision</code></td>
<td>

<p>Logical. If <code>precision=TRUE</code> the precision of the calculated
range is returned as an attribute to the range. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a cluster model this function by default returns the effective
range of the model with the given parameters as used in spatstat. For
the Matern cluster model (see e.g. <code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>) this is
simply the finite radius of the offsring density given by the paramter
<code>scale</code> irrespective of other options given to this function. The
remaining models in spatstat have infinite theoretical range, and an
effective finite value is given as follows: For the Thomas model (see
e.g. <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> the default is <code>4*scale</code> where scale
is the scale or standard deviation parameter of the model. If
<code>thresh</code> is given the value is instead found as described for the
other models below.
</p>
<p>For the Cauchy model (see e.g. <code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>) and the Variance
Gamma (Bessel) model (see e.g. <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>) the value of
<code>thresh</code> defaults to 0.001, and then this is used to compute the
range numerically as follows. If <code class="reqn">k(x,y)=k_0(r)</code>
with <code class="reqn">r=\sqrt(x^2+y^2)</code>
denotes the isotropic cluster kernel then <code class="reqn">f(r) = 2 \pi r
  k_0(r)</code> is the
density function of the offspring distance from the parent. The range
is determined as the value of <code class="reqn">r</code> where <code class="reqn">f(r)</code> falls below
<code>thresh</code> times <code class="reqn">k_0(r)</code>.
</p>
<p>If <code>precision=TRUE</code> the precision related to the chosen range is
returned as an attribute. Here the precision is defined as the polar
integral of the kernel from distance 0 to the calculated
range. Ideally this should be close to the value 1 which would be
obtained for the true theretical infinite range.
</p>


<h3>Value</h3>

<p>A positive numeric.
</p>
<p>Additionally, the precision related to this range value is returned as
an attribute <code>"prec"</code>, if <code>precision=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+clusterkernel">clusterkernel</a></code>, <code><a href="#topic+kppm">kppm</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>, <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>,
<code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>,
<code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>, <code><a href="spatstat.random.html#topic+rNeymanScott">rNeymanScott</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ x, "MatClust")
  clusterradius(fit)
</code></pre>

<hr>
<h2 id='coef.mppm'>
Coefficients of Point Process Model Fitted to Multiple Point Patterns
</h2><span id='topic+coef.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a list of point patterns,
extract the coefficients of the fitted model.
A method for <code>coef</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mppm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"mppm"</code>)
</p>
</td></tr>
<tr><td><code id="coef.mppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code><a href="stats.html#topic+coef">coef</a></code>.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"mppm"</code>) produced by the 
fitting algorithm <code><a href="#topic+mppm">mppm</a></code>). This represents a
point process model that has been fitted
to a list of several point pattern datasets. See <code><a href="#topic+mppm">mppm</a></code>
for information.
</p>
<p>This function extracts the vector of coefficients of the fitted model.
This is the estimate of the parameter vector
<code class="reqn">\theta</code> such that the conditional intensity of the model
is of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u,x) = \exp(\theta S(u,x))
  </code>
</p>

<p>where <code class="reqn">S(u,x)</code> is a (vector-valued) statistic.
</p>
<p>For example, if the model <code>object</code> is the uniform Poisson process,
then <code>coef(object)</code> will yield a single value
(named <code>"(Intercept)"</code>) which is the logarithm of the
fitted intensity of the Poisson process.
</p>
<p>If the fitted model includes random effects (i.e. if the argument
<code>random</code> was specified in the call to <code><a href="#topic+mppm">mppm</a></code>),
then the fitted coefficients are different for each point pattern
in the original data, so <code>coef(object)</code> is a data frame
with one row for each point pattern, and one column for each
parameter. Use <code><a href="#topic+fixef.mppm">fixef.mppm</a></code> to extract the vector of fixed effect
coefficients, and <code><a href="#topic+ranef.mppm">ranef.mppm</a></code> to extract the random
effect coefficients at each level.
</p>
<p>Use <code><a href="#topic+print.mppm">print.mppm</a></code> to print a more useful
description of the fitted model.
</p>


<h3>Value</h3>

<p>Either a vector containing the fitted coefficients,
or a data frame containing the fitted coefficients for each point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented in <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.mppm">fixef.mppm</a></code> and <code><a href="#topic+ranef.mppm">ranef.mppm</a></code>
for the fixed and random effect coefficients in a model that includes
random effects.
</p>
<p><code><a href="#topic+print.mppm">print.mppm</a></code>,
<code><a href="#topic+mppm">mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    H &lt;- hyperframe(X=waterstriders)

    fit.Poisson &lt;- mppm(X ~ 1, H)
    coef(fit.Poisson)

    # The single entry "(Intercept)" 
    # is the log of the fitted intensity of the Poisson process

    fit.Strauss &lt;- mppm(X~1, H, Strauss(7))
    coef(fit.Strauss)

    # The two entries "(Intercept)" and "Interaction"
    # are respectively log(beta) and log(gamma)
    # in the usual notation for Strauss(beta, gamma, r)

    # Tweak data to exaggerate differences
    H$X[[1]] &lt;- rthin(H$X[[1]], 0.3)
    # Model with random effects
    fitran &lt;- mppm(X ~ 1, H, random=~1|id)
    coef(fitran)
</code></pre>

<hr>
<h2 id='coef.ppm'>
Coefficients of Fitted Point Process Model
</h2><span id='topic+coef.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
extract the coefficients of the fitted model.
A method for <code>coef</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
</p>
</td></tr>
<tr><td><code id="coef.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function <code><a href="stats.html#topic+coef">coef</a></code>.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code>). Such objects are produced by the maximum
pseudolikelihood fitting algorithm <code><a href="#topic+ppm">ppm</a></code>).
</p>
<p>This function extracts the vector of coefficients of the fitted model.
This is the estimate of the parameter vector
<code class="reqn">\theta</code> such that the conditional intensity of the model
is of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u,x) = \exp(\theta S(u,x))
  </code>
</p>

<p>where <code class="reqn">S(u,x)</code> is a (vector-valued) statistic.
</p>
<p>For example, if the model <code>object</code> is the uniform Poisson process,
then <code>coef(object)</code> will yield a single value
(named <code>"(Intercept)"</code>) which is the logarithm of the
fitted intensity of the Poisson process.
</p>
<p>Use <code><a href="#topic+print.ppm">print.ppm</a></code> to print a more useful
description of the fitted model.
</p>


<h3>Value</h3>

<p>A vector containing the fitted coefficients.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ppm">print.ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    poi &lt;- ppm(cells, ~1, Poisson())
    coef(poi)
    # This is the log of the fitted intensity of the Poisson process

    stra &lt;- ppm(cells, ~1, Strauss(r=0.07))
    coef(stra)

    # The two entries "(Intercept)" and "Interaction"
    # are respectively log(beta) and log(gamma)
    # in the usual notation for Strauss(beta, gamma, r)
</code></pre>

<hr>
<h2 id='coef.slrm'>
Coefficients of Fitted Spatial Logistic Regression Model 
</h2><span id='topic+coef.slrm'></span>

<h3>Description</h3>

<p>Extracts the coefficients (parameters) from a fitted
Spatial Logistic Regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.slrm_+3A_object">object</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="coef.slrm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+coef">coef</a></code> for fitted spatial logistic
regression models (objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>).
</p>
<p>It extracts the fitted canonical parameters, i.e.\ the coefficients in the
linear predictor of the spatial logistic regression.
</p>


<h3>Value</h3>

<p>Numeric vector of coefficients.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- slrm(X ~ x+y)
  coef(fit)
</code></pre>

<hr>
<h2 id='compareFit'>
Residual Diagnostics for Multiple Fitted Models
</h2><span id='topic+compareFit'></span>

<h3>Description</h3>

<p>Compares several fitted point process models using the
same residual diagnostic. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareFit(object, Fun, r = NULL, breaks = NULL, ...,
         trend = ~1, interaction = Poisson(), rbord = NULL,
         modelnames = NULL, same = NULL, different = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareFit_+3A_object">object</code></td>
<td>

<p>Object or objects to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>),
a point pattern (object of class <code>"ppp"</code>),
or a list of these objects.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_fun">Fun</code></td>
<td>

<p>Diagnostic function to be computed for each model.
One of the functions <code>Kcom</code>, <code>Kres</code>, <code>Gcom</code>,
<code>Gres</code>, <code>psst</code>, <code>psstA</code> or <code>psstG</code>
or a string containing one of these names.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
diagnostic should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_breaks">breaks</code></td>
<td>

<p>Optional alternative to <code>r</code> for advanced use. 
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>Fun</code>.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_trend">trend</code>, <code id="compareFit_+3A_interaction">interaction</code>, <code id="compareFit_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern or list of point patterns.
See <code><a href="#topic+ppm">ppm</a></code> for details.
Each of these arguments can be a list, specifying different
<code>trend</code>, <code>interaction</code> and/or <code>rbord</code>
values to be used to generate different fitted models.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_modelnames">modelnames</code></td>
<td>

<p>Character vector. Short descriptive names for the different models.
</p>
</td></tr>
<tr><td><code id="compareFit_+3A_same">same</code>, <code id="compareFit_+3A_different">different</code></td>
<td>

<p>Character strings or character vectors passed to
<code><a href="spatstat.explore.html#topic+collapse.fv">collapse.fv</a></code> to
determine the format of the output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenient way to collect diagnostic information
for several different point process models fitted to the same
point pattern dataset, or for point process models of the same form fitted to
several different datasets, etc.
</p>
<p>The first argument, <code>object</code>, is usually a list of
fitted point process models
(objects of class <code>"ppm"</code>), obtained from the
model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>For convenience, <code>object</code> can also be a list of point patterns
(objects of class <code>"ppp"</code>).
In that case, point process models will be fitted to
each of the point pattern datasets,
by calling <code><a href="#topic+ppm">ppm</a></code> using the arguments
<code>trend</code> (for the first order trend),
<code>interaction</code> (for the interpoint interaction)
and <code>rbord</code> (for the erosion distance in the border correction
for the pseudolikelihood). See <code><a href="#topic+ppm">ppm</a></code> for details
of these arguments.
</p>
<p>Alternatively <code>object</code> can be a single point pattern
(object of class <code>"ppp"</code>) and one or more of the arguments
<code>trend</code>, <code>interaction</code> or <code>rbord</code>
can be a list. In this case, point process models will be fitted to
the same point pattern dataset, using each of the model specifications
listed.
</p>
<p>The diagnostic function <code>Fun</code> will be applied to each of the
point process models. The results will be collected into a single
function value table. The <code>modelnames</code> are used to label the
results from each fitted model.
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>, 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Jesper Moller.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+Kcom">Kcom</a></code>,
<code><a href="#topic+Kres">Kres</a></code>,
<code><a href="#topic+Gcom">Gcom</a></code>,
<code><a href="#topic+Gres">Gres</a></code>,
<code><a href="#topic+psst">psst</a></code>,
<code><a href="#topic+psstA">psstA</a></code>,
<code><a href="#topic+psstG">psstG</a></code>,
<code><a href="spatstat.explore.html#topic+collapse.fv">collapse.fv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nd &lt;- 40
   
   ilist &lt;- list(Poisson(), Geyer(7, 2), Strauss(7))
   iname &lt;- c("Poisson", "Geyer", "Strauss")
   
   K &lt;- compareFit(swedishpines, Kcom, interaction=ilist, rbord=9,
            correction="translate",
            same="trans", different="tcom", modelnames=iname, nd=nd)
   K
</code></pre>

<hr>
<h2 id='Concom'>The Connected Component Process Model</h2><span id='topic+Concom'></span>

<h3>Description</h3>

<p>Creates an instance of the Connected Component point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Concom(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Concom_+3A_r">r</code></td>
<td>
<p>Threshold distance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines the interpoint interaction structure of a point
process called the connected component process.
It can be used to fit this model to point pattern data.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the connected component interaction is
yielded by the function <code>Concom()</code>. See the examples below.
</p>
<p>In <b>standard form</b>, the connected component process
(Baddeley and Moller, 1989) with disc radius <code class="reqn">r</code>,
intensity parameter <code class="reqn">\kappa</code> and interaction parameter
<code class="reqn">\gamma</code> is a point process with probability density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \kappa^{n(x)} \gamma^{-C(x)}
  </code>
</p>

<p>for a point pattern <code class="reqn">x</code>, where 
<code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, and <code class="reqn">C(x)</code> is defined below.
Here <code class="reqn">\alpha</code> is a normalising constant.
</p>
<p>To define the term <code>C(x)</code>, suppose that we construct a planar
graph by drawing an edge between 
each pair of points <code class="reqn">x_i,x_j</code> which are less than
<code class="reqn">r</code> units apart. Two points belong to the same connected component
of this graph if they are joined by a path in the graph.
Then <code class="reqn">C(x)</code> is the number of connected components of the graph.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> can be any positive number.
If <code class="reqn">\gamma = 1</code> then the model reduces to a Poisson
process with intensity <code class="reqn">\kappa</code>.
If <code class="reqn">\gamma &lt; 1</code> then the process is regular,
while if <code class="reqn">\gamma &gt; 1</code> the process is clustered.
Thus, a connected-component interaction process can be used to model either
clustered or regular point patterns.
</p>
<p>In <span class="pkg">spatstat</span>, the model is parametrised in a different form,
which is easier to interpret.
In <b>canonical form</b>, the probability density is rewritten as
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \gamma^{-U(x)}
  </code>
</p>

<p>where <code class="reqn">\beta</code> is the new intensity parameter and
<code class="reqn">U(x) = C(x) - n(x)</code> is the interaction potential. 
In this formulation, each isolated point of the pattern contributes a
factor <code class="reqn">\beta</code> to the probability density (so the
first order trend is <code class="reqn">\beta</code>). The quantity 
<code class="reqn">U(x)</code> is a true interaction potential, in the sense that
<code class="reqn">U(x) = 0</code> if the point pattern <code class="reqn">x</code> does not contain any
points that lie close together.
</p>
<p>When a new point <code class="reqn">u</code> is added to an existing point pattern
<code class="reqn">x</code>, the rescaled potential <code class="reqn">-U(x)</code> increases by
zero or a positive integer.
The increase is zero if <code class="reqn">u</code> is not close to any point of <code class="reqn">x</code>.
The increase is a positive integer <code class="reqn">k</code> if there are
<code class="reqn">k</code> different connected components of <code class="reqn">x</code> that lie close to <code class="reqn">u</code>.
Addition of the point
<code class="reqn">u</code> contributes a factor <code class="reqn">\beta \eta^\delta</code>
to the probability density, where <code class="reqn">\delta</code> is the
increase in potential.
</p>
<p>If desired, the original parameter <code class="reqn">\kappa</code> can be recovered from
the canonical parameter by <code class="reqn">\kappa = \beta\gamma</code>.
</p>
<p>The <em>nonstationary</em> connected component process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location, rather than a constant beta. 
</p>
<p>Note the only argument of <code>Concom()</code> is the threshold distance <code>r</code>.
When <code>r</code> is fixed, the model becomes an exponential family.
The canonical parameters <code class="reqn">\log(\beta)</code>
and <code class="reqn">\log(\gamma)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>Concom()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the connected component process with disc radius <code class="reqn">r</code>.
</p>


<h3>Edge correction</h3>

<p>The interaction distance of this process is infinite.
There are no well-established procedures for edge correction
for fitting such models, and accordingly the model-fitting function
<code><a href="#topic+ppm">ppm</a></code> will give an error message saying that the user must
specify an edge correction. A reasonable solution is
to use the border correction at the same distance <code>r</code>, as shown in the
Examples.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Moller, J. (1989)
Nearest-neighbour Markov point processes and random sets.
<em>International Statistical Review</em> <b>57</b>, 89&ndash;121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # prints a sensible description of itself
   Concom(r=0.1)

   # Fit the stationary connected component process to redwood data
   ppm(redwood ~1, Concom(r=0.07), rbord=0.07)

   # Fit the stationary connected component process to `cells' data
   ppm(cells ~1, Concom(r=0.06), rbord=0.06)
   # eta=0 indicates hard core process.

   # Fit a nonstationary connected component model
   # with log-cubic polynomial trend
   
     ppm(swedishpines ~polynom(x/10,y/10,3), Concom(r=7), rbord=7)
   
</code></pre>

<hr>
<h2 id='data.ppm'>Extract Original Data from a Fitted Point Process Model</h2><span id='topic+data.ppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model,
this function extracts the original point pattern dataset
to which the model was fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data.ppm(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.ppm_+3A_object">object</code></td>
<td>

<p>fitted point process model (an object of class <code>"ppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppm"</code> represents a point process model
that has been fitted to data. It is typically produced by
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>.
The object contains complete information about the original data
point pattern to which the model was fitted.
This function extracts the original data pattern.
</p>
<p>See <code><a href="#topic+ppm.object">ppm.object</a></code> for a list of all operations that can be
performed on objects of class <code>"ppm"</code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- ppm(cells, ~1, Strauss(r=0.1))
 X &lt;- data.ppm(fit)
 # 'X' is identical to 'cells'
</code></pre>

<hr>
<h2 id='detpointprocfamilyfun'>Construct a New Determinantal Point Process Model Family Function</h2><span id='topic+detpointprocfamilyfun'></span>

<h3>Description</h3>

<p>Function to ease the implementation of a new determinantal
point process model family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detpointprocfamilyfun(kernel = NULL,
    specden = NULL, basis = "fourierbasis", 
    convkernel = NULL, Kfun = NULL, valid = NULL, intensity = NULL, 
    dim = 2, name = "User-defined", isotropic = TRUE, range = NULL, 
    parbounds = NULL, specdenrange = NULL, startpar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detpointprocfamilyfun_+3A_kernel">kernel</code></td>
<td>

<p>function specifying the kernel.
May be set to <code>NULL</code>. See Details.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_specden">specden</code></td>
<td>

<p>function specifying the spectral density.
May be set to <code>NULL</code>. See Details.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_basis">basis</code></td>
<td>

<p>character string giving the name of the basis.
Defaults to the Fourier basis. See Details.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_convkernel">convkernel</code></td>
<td>

<p>function specifying the k-fold auto-convolution of the kernel.
May be set to <code>NULL</code>. See Details.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_kfun">Kfun</code></td>
<td>

<p>function specifying the K-function.
May be set to <code>NULL</code>. See Details.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_valid">valid</code></td>
<td>

<p>function determining whether a given set of parameter values
yields a valid model. May be set to <code>NULL</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_intensity">intensity</code></td>
<td>

<p>character string specifying which parameter is the intensity in the
model family. Should be <code>NULL</code> if the model family has no intensity
parameter.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_dim">dim</code></td>
<td>

<p>character strig specifying which parameter is the dimension of the
state space in this model family (if any).
Alternatively a positive integer specifying the dimension.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_name">name</code></td>
<td>

<p>character string giving the name of the model family used for
printing.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_isotropic">isotropic</code></td>
<td>

<p>logical value indicating whether or not the model is isotropic.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_range">range</code></td>
<td>

<p>function determining the interaction range of the model. May be
set to <code>NULL</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_parbounds">parbounds</code></td>
<td>

<p>function determining the bounds for each model parameter when all
other parameters are fixed. May be set to <code>NULL</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_specdenrange">specdenrange</code></td>
<td>

<p>function specifying the the range of the spectral density if it
is finite (only the case for very few models). May be set to
<code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_startpar">startpar</code></td>
<td>

<p>function determining starting values for parameters in any estimation
algorithm. May be set to <code>NULL</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="detpointprocfamilyfun_+3A_...">...</code></td>
<td>

<p>Additional arguments for inclusion in the returned model object. These
are not checked in any way.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A determinantal point process family is specified either
in terms of a kernel (a positive semi-definite function, i.e. a
covariance function) or a spectral density, or preferably both. 
One of these can be <code>NULL</code> if it is unknown, but not both.
When both are supplied they must have the same arguments.
The first argument gives
the values at which the function should be evaluated. In general
the function should accept an  <code class="reqn">n</code> by <code class="reqn">d</code> matrix or
<code>data.frame</code> specifying <code class="reqn">n (&gt;=0)</code>
points in dimension <code class="reqn">d</code>. If the model is isotropic it only needs to
accept a non-negative valued numeric of length <code class="reqn">n</code>. (In fact
there is currently almost no support for non-isotropic models, so
it is recommended not to specify such a model.) The name
of this argument could be chosen freely, but <code class="reqn">x</code> is
recommended. The remaining arguments are the parameters of the
model. If one of these is an intensity parameter the name should
be mentioned in the argument <code>intensity</code>. If one of these
specifies the dimension of the model it should be mentioned in the
argument <code>dim</code>.
</p>
<p>The kernel and spectral density is with respect to a
specific set of basis functions, which is typically the Fourier
basis. However this can be changed to any user-supplied basis in
the argument <code>basis</code>. If such an alternative is supplied it
must be the name of a function expecting the same arguments as
<code><a href="spatstat.geom.html#topic+fourierbasis">fourierbasis</a></code> and returning the results in the same
form as <code><a href="spatstat.geom.html#topic+fourierbasis">fourierbasis</a></code>.
</p>
<p>If supplied, the arguments of convkernel must obey the
following: first argument should be like the first argument of
kernel and/or specden (see above). The second argument (preferably
called <code>k</code>) should be the positive integer specifying how many times
the auto-convolution is done (i.e. the <code class="reqn">k</code> in <code class="reqn">k</code>-fold
auto-convolution). The remaining arguments must agree with the
arguments of <code>kernel</code> and/or <code>specden</code> (see above).
</p>
<p>If supplied, the arguments of <code>Kfun</code> should be like the
arguments of <code>kernel</code> and <code>specden</code> (see above).
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, belonging to the class
<code>"detpointprocfamilyfun"</code>. The function has formal arguments
<code>...</code> and returns a determinantal point process family
(object of class <code>"detpointprocfamily"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Example of how to define the Gauss family
exGauss &lt;- detpointprocfamilyfun(
    name="Gaussian",
    kernel=function(x, lambda, alpha, d){
        lambda*exp(-(x/alpha)^2)
    },
    specden=function(x, lambda, alpha, d){
        lambda * (sqrt(pi)*alpha)^d * exp(-(x*alpha*pi)^2)
    },
    convkernel=function(x, k, lambda, alpha, d){
        logres &lt;- k*log(lambda*pi*alpha^2) - log(pi*k*alpha^2) - x^2/(k*alpha^2)
        return(exp(logres))
    },
    Kfun = function(x, lambda, alpha, d){
        pi*x^2 - pi*alpha^2/2*(1-exp(-2*x^2/alpha^2))
    },
    valid=function(lambda, alpha, d){
        lambda&gt;0 &amp;&amp; alpha&gt;0 &amp;&amp; d&gt;=1 &amp;&amp; lambda &lt;= (sqrt(pi)*alpha)^(-d)
    },
    isotropic=TRUE,
    intensity="lambda",
    dim="d",
    range=function(alpha, bound = .99){
        if(missing(alpha))
            stop("The parameter alpha is missing.")
        if(!(is.numeric(bound)&amp;&amp;bound&gt;0&amp;&amp;bound&lt;1))
            stop("Argument bound must be a numeric between 0 and 1.")
        return(alpha*sqrt(-log(sqrt(1-bound))))
    },
    parbounds=function(name, lambda, alpha, d){
        switch(name,
               lambda = c(0, (sqrt(pi)*alpha)^(-d)),
               alpha = c(0, lambda^(-1/d)/sqrt(pi)),
               stop("Parameter name misspecified")
               )
    },
    startpar=function(model, X){
        rslt &lt;- NULL
        if("lambda" %in% model$freepar){
            lambda &lt;- intensity(X)
            rslt &lt;- c(rslt, "lambda" = lambda)
            model &lt;- update(model, lambda=lambda)
        }
        if("alpha" %in% model$freepar){
            alpha &lt;- .8*dppparbounds(model, "alpha")[2]
            rslt &lt;- c(rslt, "alpha" = alpha)
        }
        return(rslt)
    }
    )
  exGauss
  m &lt;- exGauss(lambda=100, alpha=.05, d=2)
  m
</code></pre>

<hr>
<h2 id='dfbetas.ppm'>
Parameter Influence Measure
</h2><span id='topic+dfbetas.ppm'></span>

<h3>Description</h3>

<p>Computes the deletion influence measure for each parameter
in a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
dfbetas(model, ...,
       drop = FALSE, iScore=NULL, iHessian=NULL, iArgs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfbetas.ppm_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="dfbetas.ppm_+3A_...">...</code></td>
<td>

<p>Ignored, except for the arguments <code>dimyx</code> and <code>eps</code>
which are passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to control the spatial resolution of the image of the density
component.    
</p>
</td></tr>
<tr><td><code id="dfbetas.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical. Whether to include (<code>drop=FALSE</code>) or
exclude (<code>drop=TRUE</code>) contributions from quadrature
points that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="dfbetas.ppm_+3A_iscore">iScore</code>, <code id="dfbetas.ppm_+3A_ihessian">iHessian</code></td>
<td>

<p>Components of the score vector and Hessian matrix for
the irregular parameters, if required. See Details.
</p>
</td></tr>
<tr><td><code id="dfbetas.ppm_+3A_iargs">iArgs</code></td>
<td>

<p>List of extra arguments for the functions <code>iScore</code>,
<code>iHessian</code> if required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a fitted spatial point process <code>model</code>,
this function computes the influence measure for each parameter,
as described in Baddeley, Chang and Song (2013)
and Baddeley, Rubak and Turner (2019).
</p>
<p>This is a method for the generic function <code><a href="stats.html#topic+dfbetas">dfbetas</a></code>.
</p>
<p>The influence measure for each parameter <code class="reqn">\theta</code> is a
signed measure in two-dimensional space. It consists of a discrete
mass on each data point (i.e. each point in the point pattern to which
the <code>model</code> was originally fitted) and a continuous density at
all locations. The mass at a data point represents the change in the 
fitted value of the parameter <code class="reqn">\theta</code> that would occur
if this data point were to be deleted.
The density at other non-data locations represents the
effect (on the fitted value of <code class="reqn">\theta</code>)
of deleting these locations (and their associated covariate values)
from the input to the fitting procedure.
</p>
<p>If the point process model trend has irregular parameters that were
fitted (using <code><a href="#topic+ippm">ippm</a></code>)
then the influence calculation requires the first and second
derivatives of the log trend with respect to the irregular parameters. 
The argument <code>iScore</code> should be a list,
with one entry for each irregular parameter,  of <span class="rlang"><b>R</b></span> functions that compute the
partial derivatives of the log trend (i.e. log intensity or
log conditional intensity) with respect to each irregular
parameter. The argument <code>iHessian</code> should be a list,
with <code class="reqn">p^2</code> entries where <code class="reqn">p</code> is the number of irregular
parameters, of <span class="rlang"><b>R</b></span> functions that compute the second order
partial derivatives of the
log trend with respect to each pair of irregular parameters.  
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code> representing a signed or vector-valued
measure. This object can be printed and plotted. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2019)
Leverage and influence diagnostics for Gibbs spatial point processes.
<em>Spatial Statistics</em> <b>29</b>, 15&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>,
<code><a href="#topic+influence.ppm">influence.ppm</a></code>,
<code><a href="#topic+ppmInfluence">ppmInfluence</a></code>.
</p>
<p>See <code><a href="#topic+msr">msr</a></code> for information on how to use a measure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   
   plot(dfbetas(fit))
   plot(Smooth(dfbetas(fit)))
   
</code></pre>

<hr>
<h2 id='dffit.ppm'>
Case Deletion Effect Measure of Fitted Model
</h2><span id='topic+dffit'></span><span id='topic+dffit.ppm'></span>

<h3>Description</h3>

<p>Computes the case deletion effect measure <code>DFFIT</code>
for a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dffit(object, ...)

## S3 method for class 'ppm'
dffit(object, ..., collapse = FALSE, dfb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dffit.ppm_+3A_object">object</code></td>
<td>

<p>A fitted model, such as a point process model
(object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="dffit.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="dffit.ppm_+3A_collapse">collapse</code></td>
<td>

<p>Logical value specifying whether to collapse the vector-valued
measure to a scalar-valued measure by adding all the components.
</p>
</td></tr>
<tr><td><code id="dffit.ppm_+3A_dfb">dfb</code></td>
<td>

<p>Optional. The result of <code>dfbetas(object)</code>,
if it has already been computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The case deletion effect measure <code>DFFIT</code> is a model diagnostic
traditionally used for regression models. In that context,
<code>DFFIT[i,j]</code> is the negative change, in the value of the
<code>j</code>th term in the linear predictor, that would occur if the <code>i</code>th
data value was deleted. It is closely related to the
diagnostic <code>DFBETA</code>.
</p>
<p>For a spatial point process model, <code>dffit</code> computes
the analogous spatial case deletion diagnostic, described in
Baddeley, Rubak and Turner (2019).
</p>


<h3>Value</h3>

<p>A measure (object of class <code>"msr"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2019)
Leverage and influence diagnostics for Gibbs spatial point processes.
<em>Spatial Statistics</em> <b>29</b>, 15&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   
   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   
   plot(dffit(fit))
   plot(dffit(fit, collapse=TRUE))
   
   
</code></pre>

<hr>
<h2 id='diagnose.ppm'>
Diagnostic Plots for Fitted Point Process Model
</h2><span id='topic+diagnose.ppm'></span><span id='topic+plot.diagppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
produce diagnostic plots based on residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  diagnose.ppm(object, ..., type="raw", which="all", sigma=NULL, 
               rbord=reach(object), cumulative=TRUE,
               plot.it=TRUE, rv = NULL,
               compute.sd=is.poisson(object), compute.cts=TRUE,
               envelope=FALSE, nsim=39, nrank=1,
               typename, check=TRUE, repair=TRUE,
               oldstyle=FALSE, splineargs=list(spar=0.5))

  ## S3 method for class 'diagppm'
plot(x, ..., which, 
               plot.neg=c("image", "discrete", "contour", "imagecontour"),
               plot.smooth=c("imagecontour", "image", "contour", "persp"),
               plot.sd, spacing=0.1, outer=3,
               srange=NULL, monochrome=FALSE, main=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose.ppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which diagnostics should be produced. This object
is usually obtained from <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_type">type</code></td>
<td>

<p>String indicating the type of residuals or weights to be used.
Current options are <code>"eem"</code>
for the Stoyan-Grabarnik exponential energy weights,
<code>"raw"</code> for the raw residuals,
<code>"inverse"</code> for the inverse-lambda residuals,
and <code>"pearson"</code> for the Pearson residuals.
A partial match is adequate.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_which">which</code></td>
<td>

<p>Character string or vector indicating the choice(s) of
plots to be generated. Options are
<code>"all"</code>, <code>"marks"</code>, <code>"smooth"</code>,
<code>"x"</code>, <code>"y"</code> and <code>"sum"</code>.
Multiple choices may be given but must be matched exactly.
See Details.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth for kernel smoother in <code>"smooth"</code> option.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_rbord">rbord</code></td>
<td>

<p>Width of border to avoid edge effects.
The diagnostic calculations
will be confined to those points of the data pattern which are
at least <code>rbord</code> units away from the edge of the window.
(An infinite value of <code>rbord</code> will be ignored.)
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_cumulative">cumulative</code></td>
<td>

<p>Logical flag indicating whether the lurking variable plots
for the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates will be the plots of
cumulative sums of marks (<code>cumulative=TRUE</code>) or the
plots of marginal integrals of the smoothed residual field
(<code>cumulative=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_plot.it">plot.it</code></td>
<td>

<p>Logical value indicating whether 
plots should be shown. If <code>plot.it=FALSE</code>, 
the computed diagnostic quantities are returned without plotting them.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_plot.neg">plot.neg</code></td>
<td>

<p>String indicating how the density part
of the residual measure should be plotted.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_plot.smooth">plot.smooth</code></td>
<td>

<p>String indicating how the smoothed residual field should be plotted.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_compute.sd">compute.sd</code>, <code id="diagnose.ppm_+3A_plot.sd">plot.sd</code></td>
<td>

<p>Logical values indicating whether 
error bounds should be computed and added to the <code>"x"</code> and <code>"y"</code>
plots. The default is <code>TRUE</code> for Poisson models and
<code>FALSE</code> for non-Poisson models. See Details.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_envelope">envelope</code>, <code id="diagnose.ppm_+3A_nsim">nsim</code>, <code id="diagnose.ppm_+3A_nrank">nrank</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+lurking">lurking</a></code>
in order to plot simulation envelopes for the lurking variable plots.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_rv">rv</code></td>
<td>

<p>Usually absent. Advanced use only.
If this argument is present, the values of the residuals will not be
calculated from the fitted model <code>object</code> but will instead
be taken directly from <code>rv</code>.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_spacing">spacing</code></td>
<td>

<p>The spacing between plot panels (when a four-panel plot
is generated) expressed as a fraction of the width of the
window of the point pattern.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_outer">outer</code></td>
<td>

<p>The distance from the outermost line of text to the nearest plot
panel, expressed as a multiple of the spacing between plot panels.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_srange">srange</code></td>
<td>

<p>Vector of length 2 that will be taken as giving the range of values
of the smoothed residual field, when generating an image plot of this
field. This is useful if you want to generate diagnostic plots
for two different fitted models using the same colour map. 
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_monochrome">monochrome</code></td>
<td>

<p>Flag indicating whether images should be displayed in
greyscale (suitable for publication) or in colour (suitable
for the screen). The default is to display in colour.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>object</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_repair">repair</code></td>
<td>

<p>Logical value indicating whether to repair the internal format
of <code>object</code>, if it is found to be damaged. 
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_oldstyle">oldstyle</code></td>
<td>

<p>Logical flag indicating whether error bounds should be plotted
using the approximation given in the original paper
(<code>oldstyle=TRUE</code>),
or using the correct asymptotic formula (<code>oldstyle=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_splineargs">splineargs</code></td>
<td>

<p>Argument passed to <code><a href="#topic+lurking">lurking</a></code> 
to control the smoothing in the lurking variable plot.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_x">x</code></td>
<td>
<p>The value returned from a previous call to 
<code>diagnose.ppm</code>. An object of class <code>"diagppm"</code>.
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_typename">typename</code></td>
<td>
<p>String to be used as the name of the residuals.</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_main">main</code></td>
<td>
<p>Main title for the plot.</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_...">...</code></td>
<td>

<p>Extra arguments, controlling either the resolution of the smoothed image
(passed from <code>diagnose.ppm</code> to <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>) 
or the appearance of the plots
(passed from <code>diagnose.ppm</code> to <code>plot.diagppm</code> and from 
<code>plot.diagppm</code> to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>).
</p>
</td></tr>
<tr><td><code id="diagnose.ppm_+3A_compute.cts">compute.cts</code></td>
<td>
<p>Advanced use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>diagnose.ppm</code> generates several diagnostic plots for a
fitted point process model.
The plots display the residuals from the fitted model
(Baddeley et al, 2005)
or alternatively the &lsquo;exponential energy marks&rsquo; (Stoyan and Grabarnik, 1991).
These plots can be used to
assess goodness-of-fit, to identify outliers in the data,
and to reveal departures from the fitted model.
See also the companion function <code><a href="#topic+qqplot.ppm">qqplot.ppm</a></code>.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code>) typically produced by the maximum
pseudolikelihood fitting algorithm <code><a href="#topic+ppm">ppm</a></code>).
</p>
<p>The argument <code>type</code> selects the type of residual or weight
that will be computed. Current options are:
</p>

<dl>
<dt><code>"eem"</code>:</dt><dd>
<p>exponential energy marks (Stoyan and Grabarnik, 1991) 
computed by <code><a href="#topic+eem">eem</a></code>.
These are positive weights attached to the data points
(i.e. the points of the point pattern dataset
to which the model was fitted).
If the fitted model is correct, then the sum of these weights
for all data points in a spatial region <code class="reqn">B</code>
has expected value equal to the
area of <code class="reqn">B</code>. See <code><a href="#topic+eem">eem</a></code> for further explanation.
</p>
</dd>
<dt><code>"raw"</code>, <code>"inverse"</code> or <code>"pearson"</code>:</dt><dd>
<p>point process residuals (Baddeley et al, 2005)
computed by the function <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>.
These are residuals attached both to the data points and to some
other points in the window of observation (namely, to the dummy
points of the quadrature scheme used to fit the model).
If the fitted model is correct, then the sum of the
residuals in a spatial region <code class="reqn">B</code> has mean zero.
The options are
</p>

<ul>
<li>
<p><code>"raw"</code>: the raw residuals;
</p>
</li>
<li>
<p><code>"inverse"</code>: the &lsquo;inverse-lambda&rsquo; residuals,
a counterpart of the exponential energy weights;
</p>
</li>
<li>
<p><code>"pearson"</code>: the Pearson residuals.
</p>
</li></ul>

<p>See <code><a href="#topic+residuals.ppm">residuals.ppm</a></code> for further explanation.
</p>
</dd>
</dl>

<p>The argument <code>which</code> selects the type of plot that is
produced. Options are:
</p>

<dl>
<dt><code>"marks"</code>:</dt><dd>
<p>plot the residual measure.
For the exponential energy weights (<code>type="eem"</code>)
this displays circles centred at the points of the data pattern,
with radii proportional to the exponential energy weights.
For the residuals (<code>type="raw"</code>, <code>type="inverse"</code>
or <code>type="pearson"</code>) this again displays circles centred at
the points of the data pattern with radii proportional to the
(positive) residuals, while the plotting of the negative residuals
depends on the argument <code>plot.neg</code>. If
<code>plot.neg="image"</code> then the negative part of the residual
measure, which is a density, is plotted as a colour image.
If <code>plot.neg="discrete"</code> then the discretised negative
residuals (obtained by approximately integrating the negative
density using the quadrature scheme of the fitted model)
are plotted as squares centred at the dummy points
with side lengths proportional to the (negative) residuals.
[To control the size of the circles and squares, use the argument
<code>maxsize</code>.]
</p>
</dd>
<dt><code>"smooth"</code>:</dt><dd>
<p>plot a kernel-smoothed version of the residual measure.
Each data or dummy point is taken to have a &lsquo;mass&rsquo; equal to its
residual or exponential energy weight.
(Note that residuals can be negative).
This point mass is then replaced by
a bivariate isotropic Gaussian density
with standard deviation <code>sigma</code>.
The value of the smoothed residual field at
any point in the window is the sum of these weighted densities.
If the fitted model is correct, this smoothed field
should be flat, and its height should be close to 0
(for the residuals) or 1 (for the exponential energy weights).
The field is plotted either as an image, contour plot or
perspective view of a surface, according to the
argument <code>plot.smooth</code>.
The range of values of the smoothed field is printed
if the option <code>which="sum"</code> is also selected.
</p>
</dd>
<dt><code>"x"</code>:</dt><dd>
<p>produce a &lsquo;lurking variable&rsquo; plot for the <code class="reqn">x</code> coordinate.
This is a plot of <code class="reqn">h(x)</code> against <code class="reqn">x</code> (solid lines)
and of <code class="reqn">E(h(x))</code> against <code class="reqn">x</code> (dashed lines),
where <code class="reqn">h(x)</code> is defined below, and <code class="reqn">E(h(x))</code> denotes the
expectation of <code class="reqn">h(x)</code> assuming the fitted model is true.
</p>

<ul>
<li>
<p>if <code>cumulative=TRUE</code> then <code class="reqn">h(x)</code> is the cumulative sum of
the weights or residuals for all points
which have <code class="reqn">X</code> coordinate less than or equal to <code class="reqn">x</code>.
For the residuals <code class="reqn">E(h(x)) = 0</code>,
and for the exponential energy weights
<code class="reqn">E(h(x)) = </code> area of the subset of the window to the left of
the line <code class="reqn">X=x</code>.
</p>
</li>
<li>
<p>if <code>cumulative=FALSE</code> then 
<code class="reqn">h(x)</code> is the marginal integral of 
the smoothed residual field (see the case <code>which="smooth"</code>
described above) on the <code class="reqn">x</code> axis. 
This is approximately the derivative
of the plot for <code>cumulative=TRUE</code>.
The value of <code class="reqn">h(x)</code> is computed by summing the values of
the smoothed residual field over all pixels with
the given <code class="reqn">x</code> coordinate. 
For the residuals <code class="reqn">E(h(x)) = 0</code>,
and for the exponential energy weights
<code class="reqn">E(h(x)) = </code> length of the intersection between the
observation window and the line <code class="reqn">X=x</code>.
</p>
</li></ul>

<p>If <code>plot.sd = TRUE</code>, then superimposed on the lurking variable
plot are the pointwise
two-standard-deviation error limits for <code class="reqn">h(x)</code> calculated for the
inhomogeneous Poisson process. The default is <code>plot.sd = TRUE</code>
for Poisson models and <code>plot.sd = FALSE</code> for non-Poisson
models.
</p>
</dd>
<dt><code>"y"</code>:</dt><dd>
<p>produce a similar lurking variable plot for the <code class="reqn">y</code> coordinate.
</p>
</dd>
<dt><code>"sum"</code>:</dt><dd>
<p>print the sum of the weights or residuals for all points
in the window (clipped by a margin <code>rbord</code> if required)
and the area of the same window. If the fitted model is correct
the sum of the exponential energy weights should equal the area of
the window, while the sum of the residuals should equal zero.
Also print the range of values of the smoothed field
displayed in the <code>"smooth"</code> case.
</p>
</dd>
<dt><code>"all"</code>:</dt><dd>
<p>All four of the diagnostic plots listed above are plotted together
in a two-by-two display. Top left panel is <code>"marks"</code> plot.
Bottom right panel is <code>"smooth"</code> plot. Bottom left panel is
<code>"x"</code> plot. Top right panel is <code>"y"</code> plot, rotated 90 degrees.
</p>
</dd>
</dl>

<p>The argument <code>rbord</code> ensures there are no edge
effects in the computation of the residuals. The diagnostic calculations
will be confined to those points of the data pattern which are
at least <code>rbord</code> units away from the edge of the window.
The value of <code>rbord</code> should be greater than or equal to
the range of interaction permitted in the model.
</p>
<p>By default, the two-standard-deviation limits are calculated
from the exact formula for the asymptotic variance
of the residuals under the asymptotic normal approximation,
equation (37) of Baddeley et al (2006).
However, for compatibility with the original paper
of Baddeley et al (2005), if <code>oldstyle=TRUE</code>,
the two-standard-deviation limits are calculated
using the innovation variance, an over-estimate of the true
variance of the residuals. (However, see the section about
Replicated Data).
</p>
<p>The argument <code>rv</code> would normally be used only by experts.
It enables the user to substitute arbitrary values for the
residuals or marks, overriding the usual calculations.
If <code>rv</code> is present, then instead of calculating the residuals from
the fitted model, the algorithm takes the residuals from the object
<code>rv</code>, and plots them in the manner appropriate to the type of residual
or mark selected by <code>type</code>. If <code>type ="eem"</code> then
<code>rv</code> should be similar to the return value of <code><a href="#topic+eem">eem</a></code>,
namely, a numeric vector of length equal to
the number of points in the original data point pattern.
Otherwise, <code>rv</code> should be similar to the return value of
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>, that is, it should be an object of
class <code>"msr"</code> (see <code><a href="#topic+msr">msr</a></code>) representing a signed
measure.
</p>
<p>The return value of <code>diagnose.ppm</code>
is an object of class <code>"diagppm"</code>.
The <code>plot</code> method for this class is documented here.
There is also a <code>print</code> method. See the Examples.
</p>
<p>In <code>plot.diagppm</code>,
if a four-panel diagnostic plot is produced (the default), then
the extra arguments <code>xlab</code>, <code>ylab</code>, <code>rlab</code> determine the
text labels for the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
and the residuals, respectively.
The undocumented arguments <code>col.neg</code> and <code>col.smooth</code>
control the colour maps used in the top left and bottom right
panels respectively.
</p>
<p>See also the companion functions <code><a href="#topic+qqplot.ppm">qqplot.ppm</a></code>, which produces a
Q-Q plot of the residuals, and <code><a href="#topic+lurking">lurking</a></code>, which produces
lurking variable plots for any spatial covariate.
</p>


<h3>Value</h3>

<p>An object of class <code>"diagppm"</code> which contains
the coordinates needed to reproduce the selected plots.
This object can be plotted using <code>plot.diagppm</code>
and printed using <code>print.diagppm</code>.
</p>


<h3>Replicated Data</h3>

<p>Note that if <code>object</code> is a model that was obtained by
first fitting a model to replicated point pattern data using
<code><a href="#topic+mppm">mppm</a></code> and then using <code><a href="#topic+subfits">subfits</a></code> to extract
a model for one of the individual point patterns, then the
variance calculations are only implemented for the
innovation variance (<code>oldstyle=TRUE</code>) and this is the default
in such cases.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>
<p>Stoyan, D. and Grabarnik, P. (1991)
Second-order characteristics for stochastic structures connected with
Gibbs point processes.
<em>Mathematische Nachrichten</em>, 151:95&ndash;100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+eem">eem</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+qqplot.ppm">qqplot.ppm</a></code>,
<code><a href="#topic+lurking">lurking</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit &lt;- ppm(cells ~x, Strauss(r=0.15))
    diagnose.ppm(fit)
    
    diagnose.ppm(fit, type="pearson")
    

    diagnose.ppm(fit, which="marks")

    diagnose.ppm(fit, type="raw", plot.neg="discrete")

    diagnose.ppm(fit, type="pearson", which="smooth")

    # save the diagnostics and plot them later
    u &lt;- diagnose.ppm(fit, rbord=0.15, plot.it=FALSE)
    if(interactive()) {
    plot(u)
    plot(u, which="marks")
    }
</code></pre>

<hr>
<h2 id='DiggleGatesStibbard'>Diggle-Gates-Stibbard Point Process Model</h2><span id='topic+DiggleGatesStibbard'></span>

<h3>Description</h3>

<p>Creates an instance of the Diggle-Gates-Stibbard point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DiggleGatesStibbard(rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiggleGatesStibbard_+3A_rho">rho</code></td>
<td>
<p>Interaction range</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diggle, Gates and Stibbard (1987) proposed a pairwise interaction
point process in which each pair of points separated by
a distance <code class="reqn">d</code> contributes a factor <code class="reqn">e(d)</code> to the
probability density, where
</p>
<p style="text-align: center;"><code class="reqn">
    e(d) = \sin^2\left(\frac{\pi d}{2\rho}\right)
  </code>
</p>

<p>for <code class="reqn">d &lt; \rho</code>, and <code class="reqn">e(d)</code> is equal to 1
for <code class="reqn">d \ge \rho</code>.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Diggle-Gates-Stibbard 
pairwise interaction is 
yielded by the function <code>DiggleGatesStibbard()</code>.
See the examples below.
</p>
<p>Note that this model does not have any regular parameters
(as explained in the section on Interaction Parameters
in the help file for <code><a href="#topic+ppm">ppm</a></code>).
The parameter <code class="reqn">\rho</code> is not estimated by <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the Diggle-Gates-Stibbard
process with interaction range <code>rho</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>
<p>Diggle, P.J., Gates, D.J., and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
Biometrika <b>74</b>, 763 &ndash; 770.
<em>Scandinavian Journal of Statistics</em> <b>21</b>, 359&ndash;373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="spatstat.random.html#topic+rDGS">rDGS</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   DiggleGatesStibbard(0.02)
   # prints a sensible description of itself

   ppm(cells ~1, DiggleGatesStibbard(0.05))
   # fit the stationary D-G-S process to `cells'

   
     ppm(cells ~ polynom(x,y,3), DiggleGatesStibbard(0.05))
     # fit a nonstationary D-G-S process
     # with log-cubic polynomial trend
   
</code></pre>

<hr>
<h2 id='DiggleGratton'>Diggle-Gratton model</h2><span id='topic+DiggleGratton'></span>

<h3>Description</h3>

<p>Creates an instance of the Diggle-Gratton pairwise interaction
point process model, which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  DiggleGratton(delta=NA, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiggleGratton_+3A_delta">delta</code></td>
<td>
<p>lower threshold <code class="reqn">\delta</code></p>
</td></tr>
<tr><td><code id="DiggleGratton_+3A_rho">rho</code></td>
<td>
<p>upper threshold <code class="reqn">\rho</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diggle and Gratton (1984, pages 208-210)
introduced the pairwise interaction point
process with pair potential <code class="reqn">h(t)</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">
    h(t) = \left( \frac{t-\delta}{\rho-\delta} \right)^\kappa
    \quad\quad \mbox{  if  } \delta \le t \le \rho
  </code>
</p>

<p>with <code class="reqn">h(t) = 0</code> for <code class="reqn">t &lt; \delta</code>
and  <code class="reqn">h(t) = 1</code> for <code class="reqn">t &gt; \rho</code>.
Here <code class="reqn">\delta</code>, <code class="reqn">\rho</code> and <code class="reqn">\kappa</code>
are parameters.
</p>
<p>Note that we use the symbol <code class="reqn">\kappa</code>
where Diggle and Gratton (1984) and Diggle, Gates and Stibbard (1987)
use <code class="reqn">\beta</code>, since in <span class="pkg">spatstat</span> we reserve the symbol
<code class="reqn">\beta</code> for an intensity parameter.
</p>
<p>The parameters must all be nonnegative,
and must satisfy <code class="reqn">\delta \le \rho</code>.
</p>
<p>The potential is inhibitory, i.e.\ this model is only appropriate for
regular point patterns. The strength of inhibition increases with
<code class="reqn">\kappa</code>. For <code class="reqn">\kappa=0</code> the model is
a hard core process with hard core radius <code class="reqn">\delta</code>.
For <code class="reqn">\kappa=\infty</code> the model is a hard core
process with hard core radius <code class="reqn">\rho</code>.
</p>
<p>The irregular parameters 
<code class="reqn">\delta, \rho</code> must be given in the call to
<code>DiggleGratton</code>, while the
regular parameter <code class="reqn">\kappa</code> will be estimated.
</p>
<p>If the lower threshold <code>delta</code> is missing or <code>NA</code>,
it will be estimated from the data when <code><a href="#topic+ppm">ppm</a></code> is called.
The estimated value of <code>delta</code> is the minimum nearest neighbour distance
multiplied by <code class="reqn">n/(n+1)</code>, where <code class="reqn">n</code> is the
number of data points.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Gates, D.J. and Stibbard, A. (1987)
A nonparametric estimator for pairwise-interaction point processes.
<em>Biometrika</em> <b>74</b>, 763 &ndash; 770.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+Pairwise">Pairwise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ppm(cells ~1, DiggleGratton(0.05, 0.1))
</code></pre>

<hr>
<h2 id='dim.detpointprocfamily'>Dimension of Determinantal Point Process Model</h2><span id='topic+dim.detpointprocfamily'></span>

<h3>Description</h3>

<p>Extracts the dimension of a determinantal point process model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'detpointprocfamily'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.detpointprocfamily_+3A_x">x</code></td>
<td>
<p>object of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric (or NULL if the dimension of the model is unspecified).</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>

<hr>
<h2 id='domain.ppm'>
Extract the Domain of any Spatial Object
</h2><span id='topic+domain.ppm'></span><span id='topic+domain.kppm'></span><span id='topic+domain.dppm'></span><span id='topic+domain.slrm'></span><span id='topic+domain.msr'></span>

<h3>Description</h3>

<p>Given a spatial object such as a point pattern, in any number of dimensions,
this function extracts the spatial domain in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
 ## S3 method for class 'ppm'
domain(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'kppm'
domain(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'dppm'
domain(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'slrm'
domain(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'msr'
domain(X, ...)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain.ppm_+3A_x">X</code></td>
<td>

<p>A spatial object such as a point pattern (in any number
of dimensions), line segment pattern or pixel image.
</p>
</td></tr>
<tr><td><code id="domain.ppm_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
<tr><td><code id="domain.ppm_+3A_from">from</code></td>
<td>
<p>Character string. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+domain">domain</a></code> is generic.
</p>
<p>For a spatial object <code>X</code> in any number of dimensions, 
<code>domain(X)</code> extracts the spatial domain in which <code>X</code> is
defined.
</p>
<p>For a two-dimensional object <code>X</code>, typically <code>domain(X)</code>
is the same as <code>Window(X)</code>.
</p>
<p>Exceptions occur for methods related to linear networks.
</p>
<p>The argument <code>from</code> applies when <code>X</code> is a fitted 
point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
If <code>from="data"</code> (the default),
<code>domain</code> extracts the window of the original point
pattern data to which the model was fitted.
If <code>from="covariates"</code> then <code>domain</code> returns the
window in which the spatial covariates of the model were provided.
</p>


<h3>Value</h3>

<p>A spatial object representing the domain of <code>X</code>.
Typically a window (object of class <code>"owin"</code>),
a three-dimensional box (<code>"box3"</code>), a multidimensional
box (<code>"boxx"</code>) or a linear network (<code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+domain">domain</a></code>,
<code><a href="spatstat.geom.html#topic+domain.quadratcount">domain.quadratcount</a></code>,
<code><a href="spatstat.explore.html#topic+domain.quadrattest">domain.quadrattest</a></code>,
<code><a href="spatstat.random.html#topic+domain.rmhmodel">domain.rmhmodel</a></code>,
<code><a href="spatstat.linnet.html#topic+domain.lpp">domain.lpp</a></code>.
<code><a href="spatstat.geom.html#topic+Window">Window</a></code>,
<code><a href="spatstat.geom.html#topic+Frame">Frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  domain(ppm(redwood ~ 1))
</code></pre>

<hr>
<h2 id='dppapproxkernel'>Approximate Determinantal Point Process Kernel</h2><span id='topic+dppapproxkernel'></span>

<h3>Description</h3>

<p>Returns an approximation to the kernel of a determinantal
point process, as a function of one argument <code class="reqn">x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppapproxkernel(model, trunc = 0.99, W = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppapproxkernel_+3A_model">model</code></td>
<td>
<p>Object of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="dppapproxkernel_+3A_trunc">trunc</code></td>
<td>
<p>Numeric specifying how the model truncation is
performed. See Details section of <code><a href="#topic+simulate.detpointprocfamily">simulate.detpointprocfamily</a></code>.
</p>
</td></tr>
<tr><td><code id="dppapproxkernel_+3A_w">W</code></td>
<td>
<p>Optional window &ndash; undocumented at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>

<hr>
<h2 id='dppapproxpcf'>Approximate Pair Correlation Function of Determinantal Point Process Model</h2><span id='topic+dppapproxpcf'></span>

<h3>Description</h3>

<p>Returns an approximation to the
theoretical pair correlation function of a
determinantal point process model, as a
function of one argument <code class="reqn">x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppapproxpcf(model, trunc = 0.99, W = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppapproxpcf_+3A_model">model</code></td>
<td>
<p>Object of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="dppapproxpcf_+3A_trunc">trunc</code></td>
<td>
<p>Numeric value specifying how the model truncation is
performed.
See Details section of <code><a href="#topic+simulate.detpointprocfamily">simulate.detpointprocfamily</a></code>.</p>
</td></tr>
<tr><td><code id="dppapproxpcf_+3A_w">W</code></td>
<td>
<p>Optional window &ndash; undocumented at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is usually NOT needed for anything. It
only exists for investigative purposes.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, with one numeric argument <code>x</code>,
that returns the value of the approximate pair correlation
at distances <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- dppapproxpcf(dppMatern(lambda = 100, alpha=.028, nu=1, d=2))
plot(f, xlim = c(0,0.1))
</code></pre>

<hr>
<h2 id='dppBessel'>Bessel Type Determinantal Point Process Model</h2><span id='topic+dppBessel'></span>

<h3>Description</h3>

<p>Function generating an instance of the Bessel-type
determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppBessel(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppBessel_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>tag=value</code>
specifying the model parameters. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible parameters are:
</p>

<ul>
<li><p> the intensity <code>lambda</code> as a positive numeric
</p>
</li>
<li><p> the scale parameter <code>alpha</code> as a positive numeric
</p>
</li>
<li><p> the shape parameter <code>sigma</code> as a non-negative numeric
</p>
</li>
<li><p> the dimension <code>d</code> as a positive integer
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"detpointprocfamily"</code>.</p>


<h3>Author(s)</h3>

<p>Frederic Lavancier and Christophe Biscio.
Modified by Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> ,
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and 
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppCauchy">dppCauchy</a></code>,
<code><a href="#topic+dppGauss">dppGauss</a></code>,
<code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppPowerExp">dppPowerExp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppBessel(lambda=100, alpha=.05, sigma=0, d=2)
</code></pre>

<hr>
<h2 id='dppCauchy'>Generalized Cauchy Determinantal Point Process Model</h2><span id='topic+dppCauchy'></span>

<h3>Description</h3>

<p>Function generating an instance of the (generalized) Cauchy
determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppCauchy(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppCauchy_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>tag=value</code> specifying the
parameters. See Details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The (generalized) Cauchy DPP is defined in (Lavancier, Moller and Rubak, 2015)
The possible parameters are:
</p>

<ul>
<li><p> the intensity <code>lambda</code> as a positive numeric
</p>
</li>
<li><p> the scale parameter <code>alpha</code> as a positive numeric
</p>
</li>
<li><p> the shape parameter <code>nu</code> as a positive numeric
(artificially required to be less than 20 in the code for numerical
stability)
</p>
</li>
<li><p> the dimension <code>d</code> as a positive integer
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"detpointprocfamily"</code>.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Lavancier, F. Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppBessel">dppBessel</a></code>,
<code><a href="#topic+dppGauss">dppGauss</a></code>,
<code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppPowerExp">dppPowerExp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppCauchy(lambda=100, alpha=.05, nu=1, d=2)
</code></pre>

<hr>
<h2 id='dppeigen'>Internal function calculating eig and index</h2><span id='topic+dppeigen'></span>

<h3>Description</h3>

<p>This function is mainly for internal package use and is usually
not called by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppeigen(model, trunc, Wscale, stationary = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppeigen_+3A_model">model</code></td>
<td>
<p>object of class <code>"detpointprocfamily"</code> </p>
</td></tr>
<tr><td><code id="dppeigen_+3A_trunc">trunc</code></td>
<td>
<p>numeric giving the truncation</p>
</td></tr>
<tr><td><code id="dppeigen_+3A_wscale">Wscale</code></td>
<td>
<p>numeric giving the scale of the window relative to a unit box</p>
</td></tr>
<tr><td><code id="dppeigen_+3A_stationary">stationary</code></td>
<td>
<p>logical indicating whether the stationarity of the model should be used (only works in dimension 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>

<hr>
<h2 id='dppGauss'>Gaussian Determinantal Point Process Model</h2><span id='topic+dppGauss'></span>

<h3>Description</h3>

<p>Function generating an instance
of the Gaussian determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppGauss(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppGauss_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>tag=value</code> specifying the
parameters. See Details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The Gaussian DPP is defined in (Lavancier, Moller and Rubak, 2015)
The possible parameters are:
</p>

<ul>
<li><p> the intensity <code>lambda</code> as a positive numeric
</p>
</li>
<li><p> the scale parameter <code>alpha</code> as a positive numeric
</p>
</li>
<li><p> the dimension <code>d</code> as a positive integer
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"detpointprocfamily"</code>.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Lavancier, F. Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppBessel">dppBessel</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>,
<code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppPowerExp">dppPowerExp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppGauss(lambda=100, alpha=.05, d=2)
</code></pre>

<hr>
<h2 id='dppkernel'>Extract Kernel from Determinantal Point Process Model Object</h2><span id='topic+dppkernel'></span>

<h3>Description</h3>

<p>Returns the kernel of a determinantal point process model as a
function of one argument <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppkernel(model, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppkernel_+3A_model">model</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="dppkernel_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+dppapproxkernel">dppapproxkernel</a></code> if the exact kernel is unknown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kernelMatern &lt;- dppkernel(dppMatern(lambda = 100, alpha=.01, nu=1, d=2))
plot(kernelMatern, xlim = c(0,0.1))
</code></pre>

<hr>
<h2 id='dppm'>Fit Determinantal Point Process Model</h2><span id='topic+dppm'></span>

<h3>Description</h3>

<p>Fit a determinantal point process model to a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dppm(formula, family, data=NULL,
       ...,
       startpar = NULL,
       method = c("mincon", "clik2", "palm", "adapcl"),
       weightfun = NULL,
       control =  list(),
       algorithm,
       statistic = "K",
       statargs = list(),
       rmax = NULL,
       epsilon = 0.01,
       covfunargs = NULL,
       use.gam = FALSE,
       nd = NULL, eps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppm_+3A_formula">formula</code></td>
<td>

<p>A <code>formula</code> in the <span class="rlang"><b>R</b></span> language
specifying the data (on the left side) and the
form of the model to be fitted (on the right side).
For a stationary model it suffices to provide a point pattern
without a formula. See Details.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_family">family</code></td>
<td>

<p>Information specifying the family of point processes
to be used in the model.
Typically one of the family functions
<code><a href="#topic+dppGauss">dppGauss</a></code>, <code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>, <code><a href="#topic+dppBessel">dppBessel</a></code>
or <code><a href="#topic+dppPowerExp">dppPowerExp</a></code>.
Alternatively a character string giving the name
of a family function, or the result of calling one of the
family functions. See Details.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_data">data</code></td>
<td>

<p>The values of spatial covariates (other than the Cartesian
coordinates) required by the model.
A named list of pixel images, functions, windows,
tessellations or numeric constants.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_...">...</code></td>
<td>

<p>Additional arguments. See Details.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_startpar">startpar</code></td>
<td>

<p>Named vector of starting parameter values for the optimization.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_method">method</code></td>
<td>

<p>The fitting method. Either
<code>"mincon"</code> for minimum contrast,
<code>"clik2"</code> for second order composite likelihood,
<code>"adapcl"</code> for adaptive second order composite likelihood,
or <code>"palm"</code> for Palm likelihood.
Partially matched.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_weightfun">weightfun</code></td>
<td>

<p>Optional weighting function <code class="reqn">w</code>
in the composite likelihoods or Palm likelihood.
A <code>function</code> in the <span class="rlang"><b>R</b></span> language.
See Details.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_control">control</code></td>
<td>

<p>List of control parameters passed to the optimization function
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_algorithm">algorithm</code></td>
<td>

<p>Character string determining the mathematical algorithm
to be used to solve the fitting problem.
If <code>method="mincon", "clik2"</code> or <code>"palm"</code> this argument
is passed to the generic optimization function
<code><a href="stats.html#topic+optim">optim</a></code> (renamed as the argument <code>method</code>)
with default <code>"Nelder-Mead"</code>.
If <code>method="adapcl"</code>) the argument is passed to the
equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>,
with default <code>"Bryden"</code>.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_statistic">statistic</code></td>
<td>

<p>Name of the summary statistic to be used
for minimum contrast estimation: either <code>"K"</code> or <code>"pcf"</code>.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_statargs">statargs</code></td>
<td>

<p>Optional list of arguments to be used when calculating
the <code>statistic</code>. See Details.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_rmax">rmax</code></td>
<td>

<p>Maximum value of interpoint distance
to use in the composite likelihood.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_epsilon">epsilon</code></td>
<td>

<p>Tuning parameter for the adaptive composite likelihood.
</p>
</td></tr>
<tr><td><code id="dppm_+3A_covfunargs">covfunargs</code>, <code id="dppm_+3A_use.gam">use.gam</code>, <code id="dppm_+3A_nd">nd</code>, <code id="dppm_+3A_eps">eps</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+ppm">ppm</a></code> when fitting the intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a determinantal point process model to a
point pattern dataset as described in Lavancier et al. (2015).
</p>
<p>The model to be fitted is specified by the arguments
<code>formula</code> and <code>family</code>.
</p>
<p>The argument <code>formula</code> should normally be a <code>formula</code> in the
<span class="rlang"><b>R</b></span> language. The left hand side of the formula
specifies the point pattern dataset to which the model should be fitted.
This should be a single argument which may be a point pattern
(object of class <code>"ppp"</code>) or a quadrature scheme
(object of class <code>"quad"</code>). The right hand side of the formula is called
the <code>trend</code> and specifies the form of the
<em>logarithm of the intensity</em> of the process.
Alternatively the argument <code>formula</code> may be a point pattern or quadrature
scheme, and the trend formula is taken to be <code>~1</code>.
</p>
<p>The argument <code>family</code> specifies the family of point processes
to be used in the model.
It is typically one of the family functions
<code><a href="#topic+dppGauss">dppGauss</a></code>, <code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>, <code><a href="#topic+dppBessel">dppBessel</a></code>
or <code><a href="#topic+dppPowerExp">dppPowerExp</a></code>. 
Alternatively it may be a character string giving the name
of a family function, or the result of calling one of the
family functions. A family function belongs to class
<code>"detpointprocfamilyfun"</code>. The result of calling a family
function is a point process family, which belongs to class
<code>"detpointprocfamily"</code>.   
</p>
<p>The algorithm first estimates the intensity function
of the point process using <code><a href="#topic+ppm">ppm</a></code>.
If the trend formula is <code>~1</code>
(the default if a point pattern or quadrature
scheme is given rather than a <code>"formula"</code>)
then the model is <em>homogeneous</em>. The algorithm begins by
estimating the intensity as the number of points divided by
the area of the window.
Otherwise, the model is <em>inhomogeneous</em>.
The algorithm begins by fitting a Poisson process with log intensity
of the form specified by the formula <code>trend</code>.
(See <code><a href="#topic+ppm">ppm</a></code> for further explanation).
</p>
<p>The interaction parameters of the model are then fitted
either by minimum contrast estimation,
or by a composite likelihood method (maximum
composite likelihood, maximum Palm likelihood, or by solving the adaptive 
composite likelihood estimating equation).
</p>

<dl>
<dt>Minimum contrast:</dt><dd>
<p>If <code>method = "mincon"</code> (the default) interaction parameters of
the model will be fitted
by minimum contrast estimation, that is, by matching the theoretical
<code class="reqn">K</code>-function of the model to the empirical <code class="reqn">K</code>-function
of the data, as explained in <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>For a homogeneous model (<code> trend = ~1 </code>)
the empirical <code class="reqn">K</code>-function of the data is computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
and the interaction parameters of the model are estimated by
the method of minimum contrast.
</p>
<p>For an inhomogeneous model,
the inhomogeneous <code class="reqn">K</code> function is estimated
by <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code> using the fitted intensity.
Then the interaction parameters of the model
are estimated by the method of minimum contrast using the
inhomogeneous <code class="reqn">K</code> function. This two-step estimation
procedure is heavily inspired by Waagepetersen (2007).
</p>
<p>If <code>statistic="pcf"</code> then instead of using the
<code class="reqn">K</code>-function, the algorithm will use
the pair correlation function <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> for homogeneous
models and the inhomogeneous pair correlation function
<code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code> for inhomogeneous models.
In this case, the smoothing parameters of the pair correlation
can be controlled using the argument <code>statargs</code>,
as shown in the Examples.
</p>
<p>Additional arguments <code>...</code> will be passed to
<code><a href="#topic+clusterfit">clusterfit</a></code> to control the minimum contrast fitting
algorithm.
</p>
</dd>
<dt>Composite likelihood:</dt><dd>
<p>If <code>method = "clik2"</code> the interaction parameters of the
model will be fitted by maximising the second-order composite likelihood
(Guan, 2006). The log composite likelihood is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(d_{ij}) \log\rho(d_{ij}; \theta)
	- \left( \sum_{i,j} w(d_{ij}) \right)
	\log \int_D \int_D w(\|u-v\|) \rho(\|u-v\|; \theta)\, du\, dv
      </code>
</p>

<p>where the sums are taken over all pairs of data points
<code class="reqn">x_i, x_j</code> separated by a distance
<code class="reqn">d_{ij} = \| x_i - x_j\|</code>
less than <code>rmax</code>,
and the double integral is taken over all pairs of locations
<code class="reqn">u,v</code> in the spatial window of the data.
Here <code class="reqn">\rho(d;\theta)</code> is the
pair correlation function of the model with
interaction parameters <code class="reqn">\theta</code>.
</p>
<p>The function <code class="reqn">w</code> in the composite likelihood
is a weighting function and may be chosen arbitrarily.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
a threshold weight function,
<code class="reqn">w(d) = 1(d \le R)</code>, where <code class="reqn">R</code> is <code>rmax/2</code>.
</p>
</dd>
<dt>Palm likelihood:</dt><dd>
<p>If <code>method = "palm"</code> the interaction parameters of the
model will be fitted by maximising the Palm loglikelihood
(Tanaka et al, 2008)
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(x_i, x_j) \log \lambda_P(x_j \mid x_i; \theta)
	- \int_D w(x_i, u) \lambda_P(u \mid x_i; \theta) {\rm d} u
      </code>
</p>

<p>with the same notation as above. Here
<code class="reqn">\lambda_P(u|v;\theta</code> is the Palm intensity of
the model at location <code class="reqn">u</code> given there is a point at <code class="reqn">v</code>.
</p>
</dd>
<dt>Adaptive Composite likelihood:</dt><dd>
<p>If <code>method = "cladap"</code> the clustering parameters of the
model will be fitted by solving the adaptive second order 
composite likelihood estimating equation (Lavancier et al, 2021).
The estimating function is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{u, v} w(\epsilon \frac{|g(0; \theta) - 1|}{g(\|u-v\|; \theta)-1}) 
	\frac{\nabla_\theta g(\|u-v\|;\theta)}{g(\|u-v\|;\theta)} - 
	\int_D \int_D w(\epsilon \frac{M(u,v; \theta)} \nabla_\theta g(\|u-v\|; \theta) 
	\rho(u) \rho(v)\, du\, dv
      </code>
</p>

<p>where the sum is taken over all distinct pairs of points.
Here <code class="reqn">g(d;\theta)</code> is the
pair correlation function  with
parameters <code class="reqn">\theta</code>.
The partial derivative with respect to <code class="reqn">\theta</code> 
is <code class="reqn">g'(d; \theta)</code>, and <code class="reqn">\rho(u)</code> denotes
the fitted intensity function of the model.
</p>
<p>The tuning parameter <code class="reqn">\epsilon</code> is 
independent of the data. It can be specified by the
argument <code>epsilon</code> and has default value <code class="reqn">0.01</code>.
</p>
<p>The function <code class="reqn">w</code> in the estimating function
is a weighting function of bounded support <code class="reqn">[-1,1]</code>.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
<code class="reqn">
	w(d) = 1(\|d\| \le 1) \exp(1/(r^2-1))</code>.
The estimating equation is solved using the
nonlinear equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
from the package <span class="pkg">nleqslv</span>. The package <span class="pkg">nleqslv</span>
must be installed in order to use this option.
</p>
</dd>
</dl>

<p>It is also possible to fix any parameters desired before the
optimisation by specifying them as <code>name=value</code>
in the call to the family function. See Examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"dppm"</code> representing the fitted model.
There are methods for printing, plotting, predicting and simulating
objects of this class.
</p>


<h3>Optimization algorithm</h3>

<p>The following details allow greater control over the fitting
procedure.
</p>
<p>For the first three fitting methods
(<code>method="mincon", "clik2"</code> and <code>"palm"</code>), 
the optimisation is performed by the generic
optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
The behaviour of this algorithm can be modified using the
arguments <code>control</code> and <code>algorithm</code>.
Useful control arguments include
<code>trace</code>, <code>maxit</code> and <code>abstol</code>
(documented in the help for <code><a href="stats.html#topic+optim">optim</a></code>).
</p>
<p>For <code>method="adapcl"</code>, the estimating equation is solved
using the nonlinear equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
from the package <span class="pkg">nleqslv</span>. 
Arguments available for controlling the solver are
documented in the help for   
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>; they include <code>control</code>, 
<code>globStrat</code>, <code>startparm</code> for the initial estimates and 
<code>algorithm</code> for the method. 
The package <span class="pkg">nleqslv</span> must be installed in order to use this option.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
Adaptive composite likelihood method contributed by Chiara Fend
and modified by Adrian Baddeley.
</p>


<h3>References</h3>

<p>Guan, Y. (2006)
A composite likelihood approach in fitting spatial point process
models.
<em>Journal of the American Statistical Association</em>
<b>101</b>, 1502&ndash;1512.
</p>
<p>Lavancier, F., Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>
<p>Lavancier, F., Poinas, A., and Waagepetersen, R. (2021)
Adaptive estimating function inference for nonstationary
determinantal point processes.
<em>Scandinavian Journal of Statistics</em>, <b>48</b> (1), 87&ndash;107.
</p>
<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for
Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43&ndash;57.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p>methods for <code>dppm</code> objects:
<code><a href="#topic+plot.dppm">plot.dppm</a></code>,
<code><a href="#topic+fitted.dppm">fitted.dppm</a></code>,
<code><a href="#topic+predict.dppm">predict.dppm</a></code>,
<code><a href="#topic+simulate.dppm">simulate.dppm</a></code>,
<code><a href="#topic+methods.dppm">methods.dppm</a></code>,
<code><a href="#topic+as.ppm.dppm">as.ppm.dppm</a></code>,
<code><a href="#topic+Kmodel.dppm">Kmodel.dppm</a></code>,
<code><a href="#topic+pcfmodel.dppm">pcfmodel.dppm</a></code>.
</p>
<p>Minimum contrast fitting algorithm:
higher level interface <code><a href="#topic+clusterfit">clusterfit</a></code>;
low-level algorithm <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>Deterimantal point process models:
<code><a href="#topic+dppGauss">dppGauss</a></code>,
<code><a href="#topic+dppMatern">dppMatern</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>,
<code><a href="#topic+dppBessel">dppBessel</a></code>,
<code><a href="#topic+dppPowerExp">dppPowerExp</a></code>,
</p>
<p>Summary statistics:
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code>.
</p>
<p>See also <code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  jpines &lt;- residualspaper$Fig1
  

  dppm(jpines ~ 1, dppGauss)

  dppm(jpines ~ 1, dppGauss, method="c")
  dppm(jpines ~ 1, dppGauss, method="p")
  dppm(jpines ~ 1, dppGauss, method="a")

  if(interactive()) {
     # Fixing the intensity at lambda=2 rather than the Poisson MLE 2.04:
     dppm(jpines ~ 1, dppGauss(lambda=2))

     # The following is quite slow (using K-function)
     dppm(jpines ~ x, dppMatern)
  }

   # much faster using pair correlation function
  dppm(jpines ~ x, dppMatern, statistic="pcf", statargs=list(stoyan=0.2))

  # Fixing the Matern shape parameter at nu=2 rather than estimating it:
  dppm(jpines ~ x, dppMatern(nu=2))
</code></pre>

<hr>
<h2 id='dppMatern'>Whittle-Matern Determinantal Point Process Model</h2><span id='topic+dppMatern'></span>

<h3>Description</h3>

<p>Function generating an instance of the Whittle-Matern determinantal
point process model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppMatern(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppMatern_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>tag=value</code> specifying the
parameters. See Details.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The Whittle-Matern DPP is defined in (Lavancier, Moller and Rubak, 2015)
The possible parameters are:
</p>

<ul>
<li><p> the intensity <code>lambda</code> as a positive numeric
</p>
</li>
<li><p> the scale parameter <code>alpha</code> as a positive numeric
</p>
</li>
<li><p> the shape parameter <code>nu</code> as a positive numeric
(artificially required to be less than 20 in the code for numerical
stability)
</p>
</li>
<li><p> the dimension <code>d</code> as a positive integer
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"detpointprocfamily"</code>.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Lavancier, F. Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppBessel">dppBessel</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>,
<code><a href="#topic+dppGauss">dppGauss</a></code>,
<code><a href="#topic+dppPowerExp">dppPowerExp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppMatern(lambda=100, alpha=.02, nu=1, d=2)
</code></pre>

<hr>
<h2 id='dppparbounds'>Parameter Bound for a Determinantal Point Process Model</h2><span id='topic+dppparbounds'></span>

<h3>Description</h3>

<p>Returns the lower and upper bound for a specific parameter of a
determinantal point process model when all other parameters are
fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppparbounds(model, name, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppparbounds_+3A_model">model</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="dppparbounds_+3A_name">name</code></td>
<td>
<p>name of the parameter for which the bound should be computed.</p>
</td></tr>
<tr><td><code id="dppparbounds_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the <code>parbounds</code> function of the given
model
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing lower and upper bounds.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
dppparbounds(model, "lambda")
</code></pre>

<hr>
<h2 id='dppPowerExp'>Power Exponential Spectral Determinantal Point Process Model</h2><span id='topic+dppPowerExp'></span>

<h3>Description</h3>

<p>Function generating an instance of the Power Exponential
Spectral determinantal point process model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppPowerExp(...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppPowerExp_+3A_...">...</code></td>
<td>
<p>arguments of the form <code>tag=value</code> specifying the
parameters. See Details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The Power Exponential Spectral DPP is defined in (Lavancier, Moller and Rubak, 2015)
The possible parameters are:
</p>

<ul>
<li><p> the intensity <code>lambda</code> as a positive numeric
</p>
</li>
<li><p> the scale parameter <code>alpha</code> as a positive numeric
</p>
</li>
<li><p> the shape parameter <code>nu</code> as a positive numeric
(artificially required to be less than 20 in the code for numerical
stability)
</p>
</li>
<li><p> the dimension <code>d</code> as a positive integer
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"detpointprocfamily"</code>.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Lavancier, F. Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppBessel">dppBessel</a></code>,
<code><a href="#topic+dppCauchy">dppCauchy</a></code>,
<code><a href="#topic+dppGauss">dppGauss</a></code>,
<code><a href="#topic+dppMatern">dppMatern</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppPowerExp(lambda=100, alpha=.01, nu=1, d=2)
</code></pre>

<hr>
<h2 id='dppspecden'>Extract Spectral Density from Determinantal Point Process Model Object</h2><span id='topic+dppspecden'></span>

<h3>Description</h3>

<p>Returns the spectral density of a determinantal point process
model as a function of one argument <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppspecden(model)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppspecden_+3A_model">model</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppspecdenrange">dppspecdenrange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- dppMatern(lambda = 100, alpha=.01, nu=1, d=2)
dppspecden(model)
</code></pre>

<hr>
<h2 id='dppspecdenrange'>Range of Spectral Density of a Determinantal Point Process Model</h2><span id='topic+dppspecdenrange'></span>

<h3>Description</h3>

<p>Computes the range of the spectral density of a
determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dppspecdenrange(model)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dppspecdenrange_+3A_model">model</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value (possibly <code>Inf</code>).</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppspecden">dppspecden</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- dppBessel(lambda=100, alpha=0.05, sigma=1, d=2)
dppspecdenrange(m)
</code></pre>

<hr>
<h2 id='dummify'>
Convert Data to Numeric Values by Constructing Dummy Variables
</h2><span id='topic+dummify'></span>

<h3>Description</h3>

<p>Converts data of any kind to numeric values.
A factor is expanded to a set of dummy variables. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummify(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummify_+3A_x">x</code></td>
<td>

<p>Vector, factor, matrix or data frame to be converted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts data (such as a factor) to numeric values
in order that the user may calculate, for example, 
the mean, variance, covariance and correlation of the data.
</p>
<p>If <code>x</code> is a numeric vector or integer vector, it is returned
unchanged.
</p>
<p>If <code>x</code> is a logical vector, it is converted to a 0-1 matrix with
2 columns. The first column contains a 1 if the logical value is
<code>FALSE</code>, and the second column contains a 1 if the logical
value is <code>TRUE</code>.
</p>
<p>If <code>x</code> is a complex vector, it is converted to a matrix with 2
columns, containing the real and imaginary parts.
</p>
<p>If <code>x</code> is a factor, the result is a matrix of 0-1 dummy
variables. The matrix has one column for each possible level of the
factor. The <code>(i,j)</code> entry is 
equal to 1 when the <code>i</code>th factor value equals the
<code>j</code>th level, and is equal to 0 otherwise.
</p>
<p>If <code>x</code> is a matrix or data frame, the appropriate conversion is
applied to each column of <code>x</code>.
</p>
<p>Note that, unlike <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, this command converts a
factor into a full set of dummy variables (one column for each level of
the factor).
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   chara &lt;- sample(letters[1:3], 8, replace=TRUE)
   logi &lt;- (runif(8) &lt; 0.3)
   comp &lt;- round(4*runif(8) + 3*runif(8) * 1i, 1)
   nume &lt;- 8:1 + 0.1
   df &lt;- data.frame(nume, chara, logi, comp)
   df
   dummify(df)
</code></pre>

<hr>
<h2 id='dummy.ppm'>Extract Dummy Points Used to Fit a Point Process Model</h2><span id='topic+dummy.ppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model,
this function extracts the &lsquo;dummy points&rsquo; of the
quadrature scheme used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dummy.ppm(object, drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy.ppm_+3A_object">object</code></td>
<td>

<p>fitted point process model (an object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="dummy.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical value determining whether to delete dummy points
that were not used to fit the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppm"</code> represents a point process model
that has been fitted to data. It is typically produced by
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The maximum pseudolikelihood algorithm in <code><a href="#topic+ppm">ppm</a></code>
approximates the pseudolikelihood
integral by a sum over a finite set of quadrature points,
which is constructed by augmenting
the original data point pattern by a set of &ldquo;dummy&rdquo; points.
The fitted model object returned by <code><a href="#topic+ppm">ppm</a></code>
contains complete information about this quadrature scheme.
See <code><a href="#topic+ppm">ppm</a></code> or <code><a href="#topic+ppm.object">ppm.object</a></code> for further
information.
</p>
<p>This function <code>dummy.ppm</code>
extracts the dummy points of the quadrature scheme.
A typical use of this function would be to count the number of dummy
points, to gauge the accuracy of the approximation to the
exact pseudolikelihood. 
</p>
<p>It may happen that some dummy points are not actually used in
fitting the model (typically because the value of a covariate is <code>NA</code>
at these points). The argument <code>drop</code> specifies whether these
unused dummy points shall be deleted (<code>drop=TRUE</code>) or
retained (<code>drop=FALSE</code>) in the return value.
</p>
<p>See <code><a href="#topic+ppm.object">ppm.object</a></code> for a list of all operations that can be
performed on objects of class <code>"ppm"</code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- ppm(cells, ~1, Strauss(r=0.1))
 X &lt;- dummy.ppm(fit)
 npoints(X)
 # this is the number of dummy points in the quadrature scheme
</code></pre>

<hr>
<h2 id='eem'>
Exponential Energy Marks
</h2><span id='topic+eem'></span><span id='topic+eem.ppm'></span><span id='topic+eem.slrm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
compute the Stoyan-Grabarnik diagnostic &ldquo;exponential energy marks&rdquo;
for the data points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eem(fit, ...)

  ## S3 method for class 'ppm'
eem(fit, check=TRUE, ...)

  ## S3 method for class 'slrm'
eem(fit, check=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eem_+3A_fit">fit</code></td>
<td>

<p>The fitted point process model. An object of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="eem_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>fit</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="eem_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stoyan and Grabarnik (1991) proposed a diagnostic
tool for point process models fitted to spatial point pattern data.
Each point <code class="reqn">x_i</code> of the data pattern <code class="reqn">X</code>
is given a &lsquo;mark&rsquo; or &lsquo;weight&rsquo;
</p>
<p style="text-align: center;"><code class="reqn">m_i = \frac 1 {\hat\lambda(x_i,X)}</code>
</p>

<p>where <code class="reqn">\hat\lambda(x_i,X)</code>
is the conditional intensity of the fitted model.
If the fitted model is correct, then the sum of these marks
for all points in a region <code class="reqn">B</code> has expected value equal to the
area of <code class="reqn">B</code>.
</p>
<p>The argument <code>fit</code> must be a fitted point process model
(object of class <code>"ppm"</code> or <code>"slrm"</code>).
Such objects are produced by the fitting algorithms <code><a href="#topic+ppm">ppm</a></code>)
and <code><a href="#topic+slrm">slrm</a></code>.
This fitted model object contains complete
information about the original data pattern and the model that was
fitted to it.
</p>
<p>The value returned by <code>eem</code> is the vector
of weights <code class="reqn">m[i]</code> associated with the points <code class="reqn">x[i]</code>
of the original data pattern. The original data pattern
(in corresponding order) can be
extracted from <code>fit</code> using <code><a href="#topic+response">response</a></code>.
</p>
<p>The function <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>
produces a set of sensible diagnostic plots based on these weights.
</p>


<h3>Value</h3>

<p>A vector containing the values of the exponential energy mark
for each point in the pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Stoyan, D. and Grabarnik, P. (1991)
Second-order characteristics for stochastic structures connected with
Gibbs point processes.
<em>Mathematische Nachrichten</em>, 151:95&ndash;100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+data.ppm">data.ppm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit &lt;- ppm(cells ~x, Strauss(r=0.15))
    ee &lt;- eem(fit)
    sum(ee)/area(Window(cells)) # should be about 1 if model is correct
    Y &lt;- setmarks(cells, ee)
    plot(Y, main="Cells data\n Exponential energy marks")
</code></pre>

<hr>
<h2 id='effectfun'>Compute Fitted Effect of a Spatial Covariate in a Point Process Model</h2><span id='topic+effectfun'></span>

<h3>Description</h3>

<p>Compute the trend or intensity of a fitted point process model
as a function of one of its covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  effectfun(model, covname, ..., se.fit=FALSE, nvalues=256)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectfun_+3A_model">model</code></td>
<td>

<p>A fitted point process model (object of class
<code>"ppm"</code>, <code>"kppm"</code>, <code>"lppm"</code>, <code>"dppm"</code>, <code>"rppm"</code>
or <code>"profilepl"</code>).
</p>
</td></tr>
<tr><td><code id="effectfun_+3A_covname">covname</code></td>
<td>

<p>The name of the covariate. A character string.
(Needed only if the model has more than one covariate.)
</p>
</td></tr>
<tr><td><code id="effectfun_+3A_...">...</code></td>
<td>

<p>The fixed values of other covariates (in the form
<code>name=value</code>) if required.
</p>
</td></tr>
<tr><td><code id="effectfun_+3A_se.fit">se.fit</code></td>
<td>

<p>Logical. If <code>TRUE</code>, asymptotic standard errors of the estimates
will be computed, together with a 95% confidence interval.
</p>
</td></tr>
<tr><td><code id="effectfun_+3A_nvalues">nvalues</code></td>
<td>

<p>Integer. The number of values of the covariate (if it is numeric)
for which the effect function should be evaluated.
We recommend at least 256.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>model</code> should be an object of class
<code>"ppm"</code>, <code>"kppm"</code>, <code>"lppm"</code>, <code>"dppm"</code>, <code>"rppm"</code>
or <code>"profilepl"</code>
representing a point process model fitted to point pattern data.
</p>
<p>The model's trend formula should involve a spatial covariate
named <code>covname</code>. This could be <code>"x"</code> or <code>"y"</code>
representing one of the Cartesian coordinates.
More commonly the covariate
is another, external variable that was supplied when fitting the model.
</p>
<p>The command <code>effectfun</code> computes the fitted trend 
of the point process <code>model</code> as a function of the covariate
named <code>covname</code>. 
The return value can be plotted immediately, giving a
plot of the fitted trend against the value of the covariate.
</p>
<p>If the model also involves covariates other than <code>covname</code>,
then these covariates will be held fixed. Values for
these other covariates must be provided as arguments
to <code>effectfun</code> in the form <code>name=value</code>. 
</p>
<p>If <code>se.fit=TRUE</code>, the algorithm also calculates
the asymptotic standard error of the fitted trend,
and a (pointwise) asymptotic 95% confidence interval for the
true trend.
</p>
<p>This command is just a wrapper for the prediction method
<code><a href="#topic+predict.ppm">predict.ppm</a></code>. For more complicated computations
about the fitted intensity, use <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>


<h3>Value</h3>

<p>A data frame containing a column of values of the covariate and a column
of values of the fitted trend.
If <code>se.fit=TRUE</code>, there are 3 additional columns containing the
standard error and the upper and lower limits of a confidence interval.
</p>
<p>If the covariate named <code>covname</code> is numeric (rather than a factor
or logical variable), the return value is
also of class <code>"fv"</code> so that it can be plotted immediately.
</p>


<h3>Trend and intensity</h3>

<p>For a Poisson point process model, the trend is the same as the
intensity of the point process. For a more general Gibbs model, the trend
is the first order potential in the model (the first order term in the
Gibbs representation). In Poisson or Gibbs models fitted by
<code><a href="#topic+ppm">ppm</a></code>, the trend is the only part of the model that
depends on the covariates.
</p>


<h3>Determinantal point process models with fixed intensity</h3>

<p>The function <code><a href="#topic+dppm">dppm</a></code> which fits 
a determinantal point process model allows the user to specify the
intensity <code>lambda</code>. In such cases the effect function is
undefined, and <code>effectfun</code> stops with an error message.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- copper$SouthPoints
  D &lt;- distfun(copper$SouthLines)
  fit &lt;- ppm(X ~ polynom(D, 5))
  effectfun(fit)
  plot(effectfun(fit, se.fit=TRUE))

  fitx &lt;- ppm(X ~ x + polynom(D, 5))
  plot(effectfun(fitx, "D", x=20))
</code></pre>

<hr>
<h2 id='emend'>
Force Model to be Valid
</h2><span id='topic+emend'></span>

<h3>Description</h3>

<p>Check whether a model is valid, and if not,
find the nearest model which is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emend(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emend_+3A_object">object</code></td>
<td>

<p>A statistical model, belonging to some class.
</p>
</td></tr>
<tr><td><code id="emend_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>emend</code> is generic,
and has methods for several classes of statistical models
in the <span class="pkg">spatstat</span> package (mostly point process models).
Its purpose is to check whether a given model is valid
(for example, that none of the model parameters are <code>NA</code>)
and, if not, to find the nearest model which is valid.
</p>
<p>See the methods for more information.
</p>


<h3>Value</h3>

<p>Another model of the same kind.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emend.ppm">emend.ppm</a></code>,
<code><a href="#topic+valid">valid</a></code>.
</p>

<hr>
<h2 id='emend.ppm'>
Force Point Process Model to be Valid
</h2><span id='topic+emend.ppm'></span><span id='topic+project.ppm'></span>

<h3>Description</h3>

<p>Ensures that a fitted point process model 
satisfies the integrability conditions for existence of the point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.ppm(object, ..., fatal=FALSE, trace=FALSE)

## S3 method for class 'ppm'
emend(object, ..., fatal=FALSE, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emend.ppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="emend.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="emend.ppm_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether to generate an error
if the model cannot be projected to a valid model.
</p>
</td></tr>
<tr><td><code id="emend.ppm_+3A_trace">trace</code></td>
<td>

<p>Logical value indicating whether to print a trace
of the decision process. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>emend.ppm</code> and <code>project.ppm</code> are identical:
<code>emend.ppm</code> is a method for the generic <code><a href="#topic+emend">emend</a></code>,
while <code>project.ppm</code> is an older name for the same function.
</p>
<p>The purpose of the function is to ensure that a fitted model
is valid.
</p>
<p>The model-fitting function <code><a href="#topic+ppm">ppm</a></code>
fits Gibbs point process models to point pattern data.
By default, the fitted model returned by <code><a href="#topic+ppm">ppm</a></code> may not
actually exist as a point process. 
</p>
<p>First, some of the fitted coefficients of the model
may be <code>NA</code> or infinite values. 
This usually occurs when the data are insufficient to estimate
all the parameters. The model is said to be
<em>unidentifiable</em> or <em>confounded</em>.
</p>
<p>Second, unlike a regression model, which is well-defined for any finite values
of the fitted regression coefficients, a Gibbs point process model
is only well-defined if the fitted interaction parameters 
satisfy some constraints. 
A famous example is the Strauss process (see <code><a href="#topic+Strauss">Strauss</a></code>)
which exists only when the interaction parameter <code class="reqn">\gamma</code>
is less than or equal to 1. For values <code class="reqn">\gamma &gt; 1</code>,
the probability density is not integrable and the process does not
exist (and cannot be simulated).
</p>
<p>By default, <code><a href="#topic+ppm">ppm</a></code> does not enforce the constraint that
a fitted Strauss process (for example) must satisfy
<code class="reqn">\gamma \le 1</code>.
This is because a fitted parameter value of <code class="reqn">\gamma &gt; 1</code> 
could be useful information for data analysis, as it indicates that
the Strauss model is not appropriate, and suggests a clustered model should be
fitted.
</p>
<p>The function <code>emend.ppm</code> or <code>project.ppm</code>
modifies the model <code>object</code>
so that the model is valid. It 
identifies the terms in the model <code>object</code>
that are associated with illegal parameter values (i.e. parameter
values which are either <code>NA</code>, infinite, or outside their permitted
range). It considers all possible sub-models of <code>object</code>
obtained by deleting one or more
of these terms. It identifies which of these submodels are valid,
and chooses the valid submodel with the largest pseudolikelihood. The result
of <code>emend.ppm</code> or <code>project.ppm</code> is the
true maximum pseudolikelihood fit to the data.
</p>
<p>For large datasets or complex models, the algorithm used in
<code>emend.ppm</code> or 
<code>project.ppm</code> may be time-consuming, because it takes time to
compute all the sub-models. A faster, approximate
algorithm can be applied by setting
<code>spatstat.options(project.fast=TRUE)</code>. This produces a
valid submodel, which may not be the maximum pseudolikelihood submodel.
</p>
<p>Use the function <code><a href="#topic+valid.ppm">valid.ppm</a></code> to check whether a fitted model
object specifies a well-defined point process.
</p>
<p>Use the expression <code>all(is.finite(coef(object)))</code> to determine
whether all parameters are identifiable.
</p>


<h3>Value</h3>

<p>Another point process model (object of class <code>"ppm"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+valid.ppm">valid.ppm</a></code>,
<code><a href="#topic+emend">emend</a></code>,
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(redwood ~1, Strauss(0.1))
   coef(fit)
   fit2 &lt;- emend(fit)
   coef(fit2)
</code></pre>

<hr>
<h2 id='emend.slrm'>
Force Spatial Logistic Regression Model to be Valid
</h2><span id='topic+emend.slrm'></span>

<h3>Description</h3>

<p>Ensures that a fitted spatial logistic regression
specifies a well-defined model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slrm'
emend(object, ..., fatal=FALSE, trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emend.slrm_+3A_object">object</code></td>
<td>

<p>Fitted point process model (object of class <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="emend.slrm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="emend.slrm_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether to generate an error
if the model cannot be projected to a valid model.
</p>
</td></tr>
<tr><td><code id="emend.slrm_+3A_trace">trace</code></td>
<td>

<p>Logical value indicating whether to print a trace
of the decision process. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>emend.slrm</code> is a method for the generic <code><a href="#topic+emend">emend</a></code>,
</p>
<p>The purpose of the function is to ensure that a fitted model
is valid.
</p>
<p>The model-fitting function <code><a href="#topic+slrm">slrm</a></code>
fits spatial logistic regression models to point pattern data.
</p>
<p>In some circumstances, the fitted model returned by <code><a href="#topic+slrm">slrm</a></code> may not
specify a well-defined model, because
some of the fitted coefficients of the model
may be <code>NA</code> or infinite values. 
This usually occurs when the data are insufficient to estimate
all the parameters. The model is said to be
<em>unidentifiable</em> or <em>confounded</em>.
</p>
<p>The function <code>emend.slrm</code> modifies the model <code>object</code>
so that the model is valid. It 
identifies the terms in the model <code>object</code>
that are associated with illegal parameter values (i.e. parameter
values which are either <code>NA</code>, infinite, or outside their permitted
range). It considers all possible sub-models of <code>object</code>
obtained by deleting one or more
of these terms. It identifies which of these submodels are valid,
and chooses the valid submodel with the largest pseudolikelihood. The result
of <code>emend.slrm</code> or <code>project.slrm</code> is the
true maximum pseudolikelihood fit to the data.
</p>
<p>For large datasets or complex models, the algorithm used in
<code>emend.slrm</code> may be time-consuming, because it takes time to
compute all the sub-models. A faster, approximate
algorithm can be applied by setting
<code>spatstat.options(project.fast=TRUE)</code>. This produces a
valid submodel, which may not be the maximum likelihood submodel.
</p>
<p>Use the function <code><a href="#topic+valid.slrm">valid.slrm</a></code> to check whether a fitted model
object specifies a well-defined model.
</p>


<h3>Value</h3>

<p>Another point process model (object of class <code>"slrm"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>,
<code><a href="#topic+valid.slrm">valid.slrm</a></code>,
<code><a href="#topic+emend">emend</a></code>,
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- slrm(redwood ~ x + I(x))
   coef(fit)
   fit2 &lt;- emend(fit)
   coef(fit2)
</code></pre>

<hr>
<h2 id='envelope.ppm'>Simulation Envelopes of Summary Function</h2><span id='topic+envelope.ppm'></span><span id='topic+envelope.kppm'></span><span id='topic+envelope.slrm'></span>

<h3>Description</h3>

<p>Computes simulation envelopes of a summary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

  ## S3 method for class 'ppm'
envelope(Y, fun=Kest, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs,
  simulate=NULL, fix.n=FALSE, fix.marks=FALSE,
  verbose=TRUE, clipdata=TRUE,
  start=NULL, control=update(default.rmhcontrol(Y), nrep=nrep), nrep=1e5,
  transform=NULL, global=FALSE, ginterval=NULL, use.theory=NULL, 
  alternative=c("two.sided", "less", "greater"), 
  scale=NULL, clamp=FALSE, 
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL, 
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)

  ## S3 method for class 'kppm'
envelope(Y, fun=Kest, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs,
  simulate=NULL,
  verbose=TRUE, clipdata=TRUE,
  transform=NULL, global=FALSE, ginterval=NULL, use.theory=NULL, 
  alternative=c("two.sided", "less", "greater"), 
  scale=NULL, clamp=FALSE, 
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL, 
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)

  ## S3 method for class 'slrm'
envelope(Y, fun=Kest, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs,
  simulate=NULL,
  verbose=TRUE, clipdata=TRUE,
  transform=NULL, global=FALSE, ginterval=NULL, use.theory=NULL, 
  alternative=c("two.sided", "less", "greater"), 
  scale=NULL, clamp=FALSE, 
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL, 
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope.ppm_+3A_y">Y</code></td>
<td>

<p>Object containing point pattern data.
A point pattern (object of class
<code>"ppp"</code>) or a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_fun">fun</code></td>
<td>

<p>Function that computes the desired summary statistic
for a point pattern. 
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns to be generated
when computing the envelopes.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_funargs">funargs</code></td>
<td>

<p>A list, containing extra arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_funyargs">funYargs</code></td>
<td>

<p>Optional. A list, containing extra arguments to be passed to
<code>fun</code> when applied to the original data <code>Y</code> only.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_simulate">simulate</code></td>
<td>

<p>Optional. Specifies how to generate the simulated point patterns.
If <code>simulate</code> is an expression in the R language, then this
expression will be evaluated <code>nsim</code> times,
to obtain <code>nsim</code> point patterns which are taken as the
simulated patterns from which the envelopes are computed.
If <code>simulate</code> is a function, then this function will be
repeatedly applied to the data pattern <code>Y</code> to obtain
<code>nsim</code> simulated patterns.
If <code>simulate</code> is a list of point patterns, then the entries
in this list will be treated as the simulated patterns from which
the envelopes are computed.
Alternatively <code>simulate</code> may be an object produced by the
<code>envelope</code> command: see Details.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_fix.n">fix.n</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points as the original data pattern.
This option is currently not available for <code>envelope.kppm</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_fix.marks">fix.marks</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points <em>and</em> the same marks as the
original data pattern. In a multitype point pattern this means that
the simulated patterns will have the same number of points
<em>of each type</em> as the original data.
This option is currently not available for <code>envelope.kppm</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
during the simulations.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_clipdata">clipdata</code></td>
<td>

<p>Logical flag indicating whether the data point pattern should be
clipped to the same window as the simulated patterns,
before the summary function for the data is computed.
This should usually be <code>TRUE</code> to ensure that the
data and simulations are properly comparable.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_start">start</code>, <code id="envelope.ppm_+3A_control">control</code></td>
<td>

<p>Optional. These specify the arguments <code>start</code> and <code>control</code>
of <code>rmh</code>, giving complete control over the simulation
algorithm. Applicable only when <code>Y</code> is a fitted model
of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_nrep">nrep</code></td>
<td>

<p>Number of iterations in the Metropolis-Hastings simulation
algorithm. Applicable only when <code>Y</code> is a fitted model
of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_transform">transform</code></td>
<td>

<p>Optional. A transformation to be applied to the
function values, before the envelopes are computed.
An expression object (see Details).
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_global">global</code></td>
<td>

<p>Logical flag indicating whether envelopes should be pointwise
(<code>global=FALSE</code>) or simultaneous (<code>global=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_ginterval">ginterval</code></td>
<td>

<p>Optional.
A vector of length 2 specifying
the interval of <code class="reqn">r</code> values for the simultaneous critical
envelopes. Only relevant if <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_use.theory">use.theory</code></td>
<td>

<p>Logical value indicating whether to use the theoretical value,
computed by <code>fun</code>, as the reference value for simultaneous
envelopes. Applicable only when <code>global=TRUE</code>.
Default is <code>use.theory=TRUE</code> if <code>Y</code> is a point pattern,
or a point process model equivalent to Complete Spatial Randomness,
and <code>use.theory=FALSE</code> otherwise.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>side="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>side="less"</code>) or a one-sided test
with an upper critical boundary (<code>side="greater"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_scale">scale</code></td>
<td>

<p>Optional. Scaling function for global envelopes.
A function in the <span class="rlang"><b>R</b></span> language which determines the
relative scale of deviations, as a function of
distance <code class="reqn">r</code>, when computing the global envelopes.
Applicable only when <code>global=TRUE</code>.
Summary function values for distance <code>r</code>
will be <em>divided</em> by <code>scale(r)</code> before the
maximum deviation is computed. The resulting global envelopes
will have width proportional to <code>scale(r)</code>. 
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_clamp">clamp</code></td>
<td>

<p>Logical value indicating how to compute envelopes when
<code>alternative="less"</code> or <code>alternative="greater"</code>.
Deviations of the observed
summary function from the theoretical summary function are initially
evaluated as signed real numbers, with large positive values indicating
consistency with the alternative hypothesis.
If <code>clamp=FALSE</code> (the default), these values are not changed.
If <code>clamp=TRUE</code>, any negative values are replaced by zero.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
function values.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
point patterns.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_nsim2">nsim2</code></td>
<td>

<p>Number of extra simulated point patterns to be generated
if it is necessary to use simulation to estimate the theoretical
mean of the summary function. Only relevant when <code>global=TRUE</code>
and the simulations are not based on CSR.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_variance">VARIANCE</code></td>
<td>

<p>Logical. If <code>TRUE</code>, critical envelopes will be calculated
as sample mean plus or minus <code>nSD</code> times sample standard
deviation.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_nsd">nSD</code></td>
<td>

<p>Number of estimated standard deviations used to determine
the critical envelopes, if <code>VARIANCE=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_yname">Yname</code></td>
<td>

<p>Character string that should be used as the name of the 
data point pattern <code>Y</code> when printing or plotting the results.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_maxnerr">maxnerr</code></td>
<td>

<p>Maximum number of rejected patterns.
If <code>fun</code> yields a fatal error when applied to a simulated point
pattern (for example, because the pattern is empty and <code>fun</code>
requires at least one point), the pattern will be rejected
and a new random point pattern will be generated. If this happens
more than <code>maxnerr</code> times, the algorithm will give up.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_rejectna">rejectNA</code></td>
<td>

<p>Logical value specifying whether to reject a simulated pattern
if the resulting values of <code>fun</code> are all equal to <code>NA</code>,
<code>NaN</code> or infinite. If <code>FALSE</code> (the default), then
simulated patterns are only rejected when <code>fun</code> gives a
fatal error. 
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_silent">silent</code></td>
<td>

<p>Logical value specifying whether to print a report each time
a simulated pattern is rejected.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_do.pwrong">do.pwrong</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the algorithm will also estimate
the true significance level of the &ldquo;wrong&rdquo; test (the test that
declares the summary function for the data to be significant
if it lies outside the <em>pointwise</em> critical boundary at any
point). This estimate is printed when the result is printed.
</p>
</td></tr>
<tr><td><code id="envelope.ppm_+3A_envir.simul">envir.simul</code></td>
<td>

<p>Environment in which to evaluate the expression <code>simulate</code>,
if not the current environment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>envelope</code> command performs simulations and
computes envelopes of a summary statistic based on the simulations.
The result is an object that can be plotted to display the envelopes.
The envelopes can be used to assess the goodness-of-fit of
a point process model to point pattern data.
</p>
<p>For the most basic use, if you have a point pattern <code>X</code> and
you want to test Complete Spatial Randomness (CSR), type
<code>plot(envelope(X, Kest,nsim=39))</code> to see the <code class="reqn">K</code> function
for <code>X</code> plotted together with the envelopes of the
<code class="reqn">K</code> function for 39 simulations of CSR. 
</p>
<p>The <code>envelope</code> function is generic, with methods for
the classes <code>"ppp"</code>, <code>"ppm"</code>, <code>"kppm"</code> and <code>"slrm"</code>
described here. There are also methods for the classes <code>"pp3"</code>,
<code>"lpp"</code> and <code>"lppm"</code> which are described separately
under <code><a href="spatstat.explore.html#topic+envelope.pp3">envelope.pp3</a></code>
and <code>envelope.lpp</code>.
Envelopes can also be computed from other envelopes, using
<code><a href="spatstat.explore.html#topic+envelope.envelope">envelope.envelope</a></code>.
</p>
<p>To create simulation envelopes, the command <code>envelope(Y, ...)</code> 
first generates <code>nsim</code> random point patterns
in one of the following ways. 
</p>

<ul>
<li> 
<p>If <code>Y</code> is a point pattern (an object of class <code>"ppp"</code>)
and <code>simulate=NULL</code>,
then we generate <code>nsim</code> simulations of
Complete Spatial Randomness (i.e. <code>nsim</code> simulated point patterns
each being a realisation of the uniform Poisson point process)
with the same intensity as the pattern <code>Y</code>.
(If <code>Y</code> is a multitype point pattern, then the simulated patterns
are also given independent random marks; the probability
distribution of the random marks is determined by the
relative frequencies of marks in <code>Y</code>.)
</p>
</li>
<li>
<p>If <code>Y</code> is a fitted point process model (an object of class
<code>"ppm"</code> or <code>"kppm"</code> or <code>"slrm"</code>) and <code>simulate=NULL</code>,
then this routine generates <code>nsim</code> simulated
realisations of that model.
</p>
</li>
<li>
<p>If <code>simulate</code> is supplied, then it determines how the
simulated point patterns are generated. It may be either
</p>

<ul>
<li>
<p>an expression in the R language, typically containing a call
to a random generator. This expression will be evaluated
<code>nsim</code> times to yield <code>nsim</code> point patterns. For example
if <code>simulate=expression(runifpoint(100))</code> then each simulated
pattern consists of exactly 100 independent uniform random points.
</p>
</li>
<li>
<p>a function in the R language, typically containing a call to a
random generator. This function will be applied repeatedly
to the original data pattern <code>Y</code> to yield <code>nsim</code> point
patterns. For example if <code>simulate=<a href="spatstat.random.html#topic+rlabel">rlabel</a></code> then each
simulated pattern was generated by evaluating <code><a href="spatstat.random.html#topic+rlabel">rlabel</a>(Y)</code>
and consists of a randomly-relabelled version of <code>Y</code>.
</p>
</li>
<li>
<p>a list of point patterns.
The entries in this list will be taken as the simulated patterns.
</p>
</li>
<li>
<p>an object of class <code>"envelope"</code>. This should have been
produced by calling <code>envelope</code> with the
argument <code>savepatterns=TRUE</code>.
The simulated point patterns that were saved in this object
will be extracted and used as the simulated patterns for the
new envelope computation. This makes it possible to plot envelopes
for two different summary functions based on exactly the same set of
simulated point patterns.
</p>
</li></ul>

</li></ul>

<p>The summary statistic <code>fun</code> is applied to each of these simulated
patterns. Typically <code>fun</code> is one of the functions
<code>Kest</code>, <code>Gest</code>, <code>Fest</code>, <code>Jest</code>, <code>pcf</code>,
<code>Kcross</code>, <code>Kdot</code>, <code>Gcross</code>, <code>Gdot</code>,
<code>Jcross</code>, <code>Jdot</code>, <code>Kmulti</code>, <code>Gmulti</code>,
<code>Jmulti</code> or <code>Kinhom</code>. It may also be a character string
containing the name of one of these functions.
</p>
<p>The statistic <code>fun</code> can also be a user-supplied function;
if so, then it must have arguments <code>X</code> and <code>r</code>
like those in the functions listed above, and it must return an object
of class <code>"fv"</code>.
</p>
<p>Upper and lower critical envelopes are computed in one of the following ways:
</p>

<dl>
<dt>pointwise:</dt><dd><p>by default, envelopes are calculated pointwise
(i.e. for each value of the distance argument <code class="reqn">r</code>), by sorting the
<code>nsim</code> simulated values, and taking the <code>m</code>-th lowest
and <code>m</code>-th highest values, where <code>m = nrank</code>.
For example if <code>nrank=1</code>, the upper and lower envelopes
are the pointwise maximum and minimum of the simulated values.
</p>
<p>The pointwise envelopes are <b>not</b> &ldquo;confidence bands&rdquo;
for the true value of the function! Rather,
they specify the critical points for a Monte Carlo test
(Ripley, 1981). The test is constructed by choosing a
<em>fixed</em> value of <code class="reqn">r</code>, and rejecting the null hypothesis if the
observed function value
lies outside the envelope <em>at this value of</em> <code class="reqn">r</code>.
This test has exact significance level
<code>alpha = 2 * nrank/(1 + nsim)</code>.
</p>
</dd>
<dt>simultaneous:</dt><dd><p>if <code>global=TRUE</code>, then the envelopes are
determined as follows. First we calculate the theoretical mean value of
the summary statistic (if we are testing CSR, the theoretical
value is supplied by <code>fun</code>; otherwise we perform a separate
set of <code>nsim2</code> simulations, compute the
average of all these simulated values, and take this average
as an estimate of the theoretical mean value). Then, for each simulation,
we compare the simulated curve to the theoretical curve, and compute the
maximum absolute difference between them (over the interval
of <code class="reqn">r</code> values specified by <code>ginterval</code>). This gives a
deviation value <code class="reqn">d_i</code> for each of the <code>nsim</code>
simulations. Finally we take the <code>m</code>-th largest of the
deviation values, where <code>m=nrank</code>, and call this
<code>dcrit</code>. Then the simultaneous envelopes are of the form
<code>lo = expected - dcrit</code> and <code>hi = expected + dcrit</code> where
<code>expected</code> is either the theoretical mean value <code>theo</code>
(if we are testing CSR) or the estimated theoretical value
<code>mmean</code> (if we are testing another model). The simultaneous critical
envelopes have constant width <code>2 * dcrit</code>.
</p>
<p>The simultaneous critical envelopes allow us to perform a different
Monte Carlo test (Ripley, 1981). The test rejects the null
hypothesis if the graph of the observed function
lies outside the envelope <b>at any value of</b> <code class="reqn">r</code>.
This test has exact significance level
<code>alpha = nrank/(1 + nsim)</code>.
</p>
<p>This test can also be performed using <code><a href="spatstat.explore.html#topic+mad.test">mad.test</a></code>.
</p>
</dd>
<dt>based on sample moments:</dt><dd><p>if <code>VARIANCE=TRUE</code>,
the algorithm calculates the
(pointwise) sample mean and sample variance of
the simulated functions. Then the envelopes are computed
as mean plus or minus <code>nSD</code> standard deviations.
These envelopes do not have an exact significance interpretation.
They are a naive approximation to
the critical points of the Neyman-Pearson test
assuming the summary statistic is approximately Normally
distributed.
</p>
</dd>
</dl>

<p>The return value is an object of class <code>"fv"</code> containing
the summary function for the data point pattern,
the upper and lower simulation envelopes, and 
the theoretical expected value (exact or estimated) of the summary function 
for the model being tested. It can be plotted
using <code><a href="spatstat.explore.html#topic+plot.envelope">plot.envelope</a></code>.
</p>
<p>If <code>VARIANCE=TRUE</code> then the return value also includes the
sample mean, sample variance and other quantities.
</p>
<p>Arguments can be passed to the function <code>fun</code> through
<code>...</code>. This means that you simply specify these arguments in the call to
<code>envelope</code>, and they will be passed to <code>fun</code>.
In particular, the argument <code>correction</code>
determines the edge correction to be used to calculate the summary
statistic. See the section on Edge Corrections, and the Examples.
</p>
<p>Arguments can also be passed to the function <code>fun</code>
through the list <code>funargs</code>. This mechanism is typically used if
an argument of <code>fun</code> has the same name as an argument of
<code>envelope</code>. The list <code>funargs</code> should contain
entries of the form <code>name=value</code>, where each <code>name</code> is the name
of an argument of <code>fun</code>.
</p>
<p>There is also an option, rarely used, in which different function
arguments are used when computing the summary function
for the data <code>Y</code> and for the simulated patterns.
If <code>funYargs</code> is given, it will be used
when the summary function for the data <code>Y</code> is computed,
while <code>funargs</code> will be used when computing the summary function
for the simulated patterns.
This option is only needed in rare cases: usually the basic principle
requires that the data and simulated patterns must be treated
equally, so that <code>funargs</code> and <code>funYargs</code> should be identical.
</p>
<p>If <code>Y</code> is a fitted cluster point process model (object of
class <code>"kppm"</code>), and <code>simulate=NULL</code>,
then the model is simulated directly
using <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>If <code>Y</code> is a fitted Gibbs point process model (object of
class <code>"ppm"</code>), and <code>simulate=NULL</code>,
then the model is simulated
by running the Metropolis-Hastings algorithm <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
Complete control over this algorithm is provided by the 
arguments <code>start</code> and <code>control</code> which are passed
to <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
</p>
<p>For simultaneous critical envelopes (<code>global=TRUE</code>)
the following options are also useful:
</p>

<dl>
<dt><code>ginterval</code></dt><dd><p>determines the interval of <code class="reqn">r</code> values
over which the deviation between curves is calculated.
It should be a numeric vector of length 2.
There is a sensible default (namely, the recommended plotting
interval for <code>fun(X)</code>, or the range of <code>r</code> values if
<code>r</code> is explicitly specified).
</p>
</dd>
<dt><code>transform</code></dt><dd><p>specifies a transformation of the
summary function <code>fun</code> that will be carried out before the
deviations are computed.
Such transforms are useful if <code>global=TRUE</code> or
<code>VARIANCE=TRUE</code>.
The <code>transform</code> must be an expression object
using the symbol <code>.</code> to represent the function value
(and possibly other symbols recognised by <code><a href="spatstat.explore.html#topic+with.fv">with.fv</a></code>).
For example, 
the conventional way to normalise the <code class="reqn">K</code> function
(Ripley, 1981) is to transform it to the <code class="reqn">L</code> function
<code class="reqn">L(r) = \sqrt{K(r)/\pi}</code>
and this is implemented by setting
<code>transform=expression(sqrt(./pi))</code>.
</p>
</dd>
</dl>

<p>It is also possible to extract the summary functions for each of the
individual simulated point patterns, by setting <code>savefuns=TRUE</code>.
Then the return value also 
has an attribute <code>"simfuns"</code> containing all the 
summary functions for the individual simulated patterns.
It is an <code>"fv"</code> object containing
functions named <code>sim1, sim2, ...</code> representing the <code>nsim</code>
summary functions.
</p>
<p>It is also possible to save the simulated point patterns themselves,
by setting <code>savepatterns=TRUE</code>. Then the return value also has
an attribute <code>"simpatterns"</code> which is a list of length
<code>nsim</code> containing all the simulated point patterns.
</p>
<p>See <code><a href="spatstat.explore.html#topic+plot.envelope">plot.envelope</a></code> and <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>
for information about how to plot the envelopes.
</p>
<p>Different envelopes can be recomputed from the same data
using <code><a href="spatstat.explore.html#topic+envelope.envelope">envelope.envelope</a></code>.
Envelopes can be combined using <code><a href="spatstat.explore.html#topic+pool.envelope">pool.envelope</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"envelope"</code>
and <code>"fv"</code>, see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>,
which can be printed and plotted directly.
</p>
<p>Essentially a data frame containing columns
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>the vector of values of the argument <code class="reqn">r</code> 
at which the summary function <code>fun</code> has been  estimated
</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>

<p>values of the summary function for the data point pattern
</p>
</td></tr>
<tr><td><code>lo</code></td>
<td>

<p>lower envelope of simulations
</p>
</td></tr>
<tr><td><code>hi</code></td>
<td>

<p>upper envelope of simulations
</p>
</td></tr>
</table>
<p>and <em>either</em>
</p>
<table>
<tr><td><code>theo</code></td>
<td>

<p>theoretical value of the summary function under CSR
(Complete Spatial Randomness, a uniform Poisson point process)
if the simulations were generated according to CSR
</p>
</td></tr>
<tr><td><code>mmean</code></td>
<td>

<p>estimated theoretical value of the summary function,
computed by averaging simulated values, 
if the simulations were not generated according to CSR.
</p>
</td></tr>
</table>
<p>Additionally, if <code>savepatterns=TRUE</code>, the return value has an attribute
<code>"simpatterns"</code> which is a list containing the <code>nsim</code>
simulated patterns. If <code>savefuns=TRUE</code>, the return value
has an attribute <code>"simfuns"</code> which is an object of class
<code>"fv"</code> containing the summary functions
computed for each of the <code>nsim</code> simulated patterns.
</p>


<h3>Errors and warnings</h3>

<p>An error may be generated if one of the simulations produces a
point pattern that is empty, or is otherwise unacceptable to the
function <code>fun</code>.
</p>
<p>The upper envelope may be <code>NA</code> (plotted as plus or minus
infinity) if some of the function values
computed for the simulated point patterns are <code>NA</code>.
Whether this occurs will depend on the function <code>fun</code>,
but it usually happens when the simulated point pattern does not contain
enough points to compute a meaningful value.
</p>


<h3>Confidence intervals</h3>

<p>Simulation envelopes do <b>not</b> compute confidence intervals;
they generate significance bands. 
If you really need a confidence interval for the true summary function
of the point process, use <code><a href="spatstat.explore.html#topic+lohboot">lohboot</a></code>.
See also <code><a href="spatstat.explore.html#topic+varblock">varblock</a></code>.
</p>


<h3>Edge corrections</h3>

<p>It is common to apply a correction for edge effects when
calculating a summary function such as the <code class="reqn">K</code> function.
Typically the user has a choice between several possible edge
corrections.
In a call to <code>envelope</code>, the user can specify the edge correction
to be applied in <code>fun</code>, using the argument <code>correction</code>.
See the Examples below.
</p>

<dl>
<dt>Summary functions in <span class="pkg">spatstat</span></dt><dd>
<p>Summary functions that are available in <span class="pkg">spatstat</span>, such as
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, <code><a href="spatstat.explore.html#topic+Gest">Gest</a></code> and <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
have a standard argument called <code>correction</code> which specifies
the name of one or more edge corrections.
</p>
<p>The list of available edge
corrections is different for each summary function,
and may also depend on the kind of window in which the point pattern is
recorded.
In the
case of <code>Kest</code> (the default and most frequently used value of
<code>fun</code>) the best edge correction is Ripley's isotropic
correction if the window is rectangular or polygonal, 
and the translation correction if the window is a binary mask.
See the help files for the individual
functions for more information.
</p>
<p>All the summary functions in <span class="pkg">spatstat</span>
recognise the option <code>correction="best"</code>
which gives the &ldquo;best&rdquo; (most accurate) available edge correction
for that function. 
</p>
<p>In a call to <code>envelope</code>, if <code>fun</code> is one of the
summary functions provided in <span class="pkg">spatstat</span>, then the default
is <code>correction="best"</code>. This means that
<em>by default, the envelope will be computed
using the &ldquo;best&rdquo; available edge correction</em>.
</p>
<p>The user can override this default by specifying the argument
<code>correction</code>. For example the computation can be accelerated
by choosing another edge correction which is less accurate
than the &ldquo;best&rdquo; one, but faster to compute.
</p>
</dd>
<dt>User-written summary functions</dt><dd>
<p>If <code>fun</code> is a function written by the user,
then <code>envelope</code> has to guess what to do.
</p>
<p>If <code>fun</code> has an argument
called <code>correction</code>, or has <code>...</code> arguments,
then <code>envelope</code> assumes that the function 
can handle a correction argument. To compute the envelope,
<code>fun</code> will be called with a <code>correction</code> argument.
The default is <code>correction="best"</code>, unless
overridden in the call to <code>envelope</code>.
</p>
<p>Otherwise, if <code>fun</code> does not have an argument
called <code>correction</code> and does not have <code>...</code> arguments,
then <code>envelope</code> assumes that the function 
<em>cannot</em> handle a correction argument. To compute the
envelope, <code>fun</code> is called without a correction argument.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Diggle, P.J., Hardegen, A., Lawrence, T., Milne,
R.K. and Nair, G. (2014) On tests of spatial pattern based on
simulation envelopes. <em>Ecological Monographs</em> <b>84</b> (3) 477&ndash;489.
</p>
<p>Cressie, N.A.C. <em>Statistics for spatial data</em>.
John Wiley and Sons, 1991.
</p>
<p>Diggle, P.J. <em>Statistical analysis of spatial point patterns</em>.
Arnold, 2003.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>
<p>Ripley, B.D. <em>Statistical inference for spatial processes</em>.
Cambridge University Press, 1988.
</p>
<p>Stoyan, D. and Stoyan, H. (1994)
Fractals, random shapes and point fields:
methods of geometrical statistics.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+dclf.test">dclf.test</a></code>,
<code><a href="spatstat.explore.html#topic+mad.test">mad.test</a></code>
for envelope-based tests.
</p>
<p><code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>,
<code><a href="spatstat.explore.html#topic+plot.envelope">plot.envelope</a></code>,
<code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>,
<code><a href="spatstat.explore.html#topic+envelope.envelope">envelope.envelope</a></code>,
<code><a href="spatstat.explore.html#topic+pool.envelope">pool.envelope</a></code>
for handling envelopes.
There are also methods for <code>print</code> and <code>summary</code>.
</p>
<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>,
<code><a href="spatstat.explore.html#topic+Fest">Fest</a></code>,
<code><a href="spatstat.explore.html#topic+Jest">Jest</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="spatstat.random.html#topic+default.expand">default.expand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- simdat
 online &lt;- interactive()
 Nsim &lt;- if(online) 19 else 3


 # Envelope of K function for simulations from Gibbs model 
 if(online) {
   fit &lt;- ppm(cells ~1, Strauss(0.05))
   plot(envelope(fit))
   plot(envelope(fit, global=TRUE))
 } else {
  fit &lt;- ppm(cells ~1, Strauss(0.05), nd=20)
  E &lt;- envelope(fit, nsim=Nsim, correction="border", nrep=100)
  E &lt;- envelope(fit, nsim=Nsim, correction="border", global=TRUE, nrep=100)
 }

 # Envelope of K function for simulations from cluster model 
 fit &lt;- kppm(redwood ~1, "Thomas")
 if(online) {
   plot(envelope(fit, Gest))
   plot(envelope(fit, Gest, global=TRUE))
 } else {
  E &lt;- envelope(fit, Gest, correction="rs", nsim=Nsim, global=TRUE, nrep=100)
 }


 # Envelope of INHOMOGENEOUS K-function with fitted trend

 # The following is valid.
 # Setting lambda=fit means that the fitted model is re-fitted to
 # each simulated pattern to obtain the intensity estimates for Kinhom.
 # (lambda=NULL would also be valid)

 fit &lt;- kppm(redwood ~1, clusters="MatClust")
 if(online) {
    plot(envelope(fit, Kinhom, lambda=fit, nsim=19))
 } else {
    envelope(fit, Kinhom, lambda=fit, nsim=Nsim)
 }

</code></pre>

<hr>
<h2 id='exactMPLEstrauss'>
Exact Maximum Pseudolikelihood Estimate for Stationary Strauss Process
</h2><span id='topic+exactMPLEstrauss'></span>

<h3>Description</h3>

<p>Computes, to very high accuracy, the Maximum Pseudolikelihood Estimates
of the parameters of a stationary Strauss point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  exactMPLEstrauss(X, R, ngrid = 2048, plotit = FALSE, project=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactMPLEstrauss_+3A_x">X</code></td>
<td>

<p>Data to which the Strauss process will be fitted.
A point pattern dataset (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="exactMPLEstrauss_+3A_r">R</code></td>
<td>

<p>Interaction radius of the Strauss process.
A non-negative number.
</p>
</td></tr>
<tr><td><code id="exactMPLEstrauss_+3A_ngrid">ngrid</code></td>
<td>

<p>Grid size for calculation of integrals. An integer, giving the
number of grid points in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
</p>
</td></tr>
<tr><td><code id="exactMPLEstrauss_+3A_plotit">plotit</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the log pseudolikelihood is plotted
on the current device. 
</p>
</td></tr>
<tr><td><code id="exactMPLEstrauss_+3A_project">project</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the parameter
<code class="reqn">\gamma</code> is constrained to lie in the interval
<code class="reqn">[0,1]</code>. If <code>FALSE</code>, this constraint is not applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended mainly for technical investigation
of algorithm performance. Its practical use is quite limited.
</p>
<p>It fits the stationary Strauss point process model
to the point pattern dataset <code>X</code> by maximum pseudolikelihood
(with the border edge correction) using an algorithm with very high accuracy.
This algorithm is more accurate than the
<em>default</em> behaviour of the model-fitting function
<code><a href="#topic+ppm">ppm</a></code> because the discretisation is much finer.
</p>
<p>Ripley (1988) and Baddeley and Turner (2000) derived the
log pseudolikelihood for the stationary Strauss
process, and eliminated the parameter <code class="reqn">\beta</code>,
obtaining an exact formula for the partial log pseudolikelihood
as a function of the interaction parameter <code class="reqn">\gamma</code> only.
The algorithm evaluates this expression to a high degree of accuracy,
using numerical integration on a <code>ngrid * ngrid</code> lattice,
uses <code><a href="stats.html#topic+optim">optim</a></code> to maximise the log pseudolikelihood
with respect to <code class="reqn">\gamma</code>, and finally recovers
<code class="reqn">\beta</code>.
</p>
<p>The result is a vector of length 2, containing the fitted coefficients
<code class="reqn">\log\beta</code> and <code class="reqn">\log\gamma</code>.
These values correspond to the entries that would be obtained with
<code>coef(ppm(X, ~1, Strauss(R)))</code>.
The fitted coefficients are typically accurate to
within <code class="reqn">10^{-6}</code> as shown in Baddeley and Turner (2013).
</p>
<p>Note however that (by default) <code>exactMPLEstrauss</code> 
constrains the parameter <code class="reqn">\gamma</code> to lie in the
interval <code class="reqn">[0,1]</code> in which the point process is well defined
(Kelly and Ripley, 1976)
whereas <code><a href="#topic+ppm">ppm</a></code> does not constrain
the value of <code class="reqn">\gamma</code> (by default). This behaviour is controlled by
the argument <code>project</code> to <code><a href="#topic+ppm">ppm</a></code> and
<code>exactMPLEstrauss</code>. The default for <code><a href="#topic+ppm">ppm</a></code>
is <code>project=FALSE</code>, while the default for <code>exactMPLEstrauss</code>
is <code>project=TRUE</code>.
</p>


<h3>Value</h3>

<p>Vector of length 2.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Baddeley, A. and Turner, R. (2013)
Bias correction for parameter estimates of spatial point process models.
<em>Journal of Statistical Computation and Simulation</em>
<b>2012</b>. <code>DOI: 10.1080/00949655.2012.755976</code>
</p>
<p>Kelly, F.P. and Ripley, B.D. (1976)
On Strauss's model for clustering.
<em>Biometrika</em> <b>63</b>, 357&ndash;360.
</p>
<p>Ripley, B.D. (1988)
<em>Statistical inference for spatial processes</em>.
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if(interactive()) {
   rc &lt;- 0.09
   exactMPLEstrauss(cells, rc, plotit=TRUE)
   coef(ppm(cells ~1, Strauss(rc)))
   coef(ppm(cells ~1, Strauss(rc), nd=128))
   rr &lt;- 0.04
   exactMPLEstrauss(redwood, rr)
   exactMPLEstrauss(redwood, rr, project=FALSE)
   coef(ppm(redwood ~1, Strauss(rr)))
 } else {
   rc &lt;- 0.09
   exactMPLEstrauss(cells, rc, ngrid=64, plotit=TRUE)
   exactMPLEstrauss(cells, rc, ngrid=64, project=FALSE)
 }
</code></pre>

<hr>
<h2 id='Extract.influence.ppm'>Extract Subset of Influence Object</h2><span id='topic++5B.influence.ppm'></span>

<h3>Description</h3>

<p>Extract a subset of an influence object, 
or extract the influence values at specified locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'influence.ppm'
x[i, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.influence.ppm_+3A_x">x</code></td>
<td>

<p>A influence object (of class <code>"influence.ppm"</code>)
computed by <code><a href="#topic+influence.ppm">influence.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="Extract.influence.ppm_+3A_i">i</code></td>
<td>

<p>Subset index (passed to <code><a href="spatstat.geom.html#topic++5B.ppp">[.ppp</a></code>).
Either a spatial window (object of class <code>"owin"</code>)
or an integer index.
</p>
</td></tr>
<tr><td><code id="Extract.influence.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"influence.ppm"</code> contains the values of the
likelihood influence for a point process model, computed by
<code><a href="#topic+influence.ppm">influence.ppm</a></code>. This is effectively a marked point
pattern obtained by marking each of the original data points
with its likelihood influence.
</p>
<p>This function extracts a designated subset of the influence values,
either as another influence object, or as a vector of numeric values.
</p>
<p>The function <code>[.influence.ppm</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"influence.ppm"</code>. The argument <code>i</code> should be
an index applicable to a point pattern. It may be either
a spatial window (object of class <code>"owin"</code>)
or a sequence index.
The result will be another influence object
(of class <code>influence.ppm</code>).
</p>
<p>To extract the influence values as a numeric vector,
use <code>marks(as.ppp(x))</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"influence.ppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence.ppm">influence.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells, ~x)
   infl &lt;- influence(fit)
   b &lt;- owin(c(0.1, 0.3), c(0.2, 0.4))
   infl[b]
   infl[1:5]
   marks(as.ppp(infl))[1:3]
</code></pre>

<hr>
<h2 id='Extract.leverage.ppm'>Extract Subset of Leverage Object</h2><span id='topic++5B.leverage.ppm'></span>

<h3>Description</h3>

<p>Extract a subset of a leverage map, 
or extract the leverage values at specified locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'leverage.ppm'
x[i, ..., update=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.leverage.ppm_+3A_x">x</code></td>
<td>

<p>A leverage object (of class <code>"leverage.ppm"</code>)
computed by <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="Extract.leverage.ppm_+3A_i">i</code></td>
<td>

<p>Subset index (passed to <code><a href="spatstat.geom.html#topic++5B.im">[.im</a></code>).
Either a spatial window (object of class <code>"owin"</code>)
or a spatial point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.leverage.ppm_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="spatstat.geom.html#topic++5B.im">[.im</a></code>,
especially the argument <code>drop</code>.
</p>
</td></tr>
<tr><td><code id="Extract.leverage.ppm_+3A_update">update</code></td>
<td>

<p>Logical value indicating whether to update the internally-stored value
of the mean leverage, by averaging over the specified subset.
</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>An object of class <code>"leverage.ppm"</code> contains the values of the
leverage function for a point process model, computed by
<code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>
<p>This function extracts a designated subset of the leverage values,
either as another leverage object, or as a vector of numeric values.
</p>
<p>The function <code>[.leverage.ppm</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"leverage.ppm"</code>. The argument <code>i</code> should be either
</p>

<ul>
<li> 
<p>a spatial window (object of class <code>"owin"</code>)
determining a region where the leverage map is required.
The result will typically be another leverage map
(object of class <code>leverage.ppm</code>).
</p>
</li>
<li> 
<p>a spatial point pattern (object of class <code>"ppp"</code>)
specifying locations at which the leverage values are required.
The result will be a numeric vector.
</p>
</li></ul>

<p>The subset operator for images, <code><a href="spatstat.geom.html#topic++5B.im">[.im</a></code>, is applied to
the leverage map. If this yields a pixel image, then the result of
<code><a href="#topic++5B.leverage.ppm">[.leverage.ppm</a></code> is another leverage object. Otherwise,
a vector containing the numeric values of leverage is returned.
</p>


<h3>Value</h3>

<p>Another object of class <code>"leverage.ppm"</code>,
or a vector of numeric values of leverage.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~x)
   lev &lt;- leverage(fit)
   b &lt;- owin(c(0.1, 0.3), c(0.2, 0.4))
   lev[b]
   lev[cells]
</code></pre>

<hr>
<h2 id='Extract.msr'>Extract Subset of Signed or Vector Measure</h2><span id='topic++5B.msr'></span>

<h3>Description</h3>

<p>Extract a subset of a signed measure or vector-valued measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msr'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.msr_+3A_x">x</code></td>
<td>

<p>A signed or vector measure.
An object of class <code>"msr"</code> (see <code><a href="#topic+msr">msr</a></code>).
</p>
</td></tr>
<tr><td><code id="Extract.msr_+3A_i">i</code></td>
<td>

<p>Object defining the subregion or subset to be extracted.
Either a spatial window (an object of class <code>"owin"</code>),
or a pixel image with logical values,
or any type of index that applies to a matrix.
</p>
</td></tr>
<tr><td><code id="Extract.msr_+3A_j">j</code></td>
<td>

<p>Subset index selecting the vector coordinates to be extracted,
if <code>x</code> is a vector-valued measure.
</p>
</td></tr>
<tr><td><code id="Extract.msr_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operator extracts a subset of
the data which determines the signed measure
or vector-valued measure <code>x</code>. The result is another measure.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   rp &lt;- residuals(fit, type="pearson")
   rs &lt;- residuals(fit, type="score")

   rp[square(0.5)]
   rs[ , 2:3]
</code></pre>

<hr>
<h2 id='Fiksel'>The Fiksel Interaction</h2><span id='topic+Fiksel'></span>

<h3>Description</h3>

<p>Creates an instance of Fiksel's double exponential
pairwise interaction point process model,
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Fiksel(r, hc=NA, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fiksel_+3A_r">r</code></td>
<td>
<p>The interaction radius of the Fiksel model</p>
</td></tr>
<tr><td><code id="Fiksel_+3A_hc">hc</code></td>
<td>
<p>The hard core distance</p>
</td></tr>
<tr><td><code id="Fiksel_+3A_kappa">kappa</code></td>
<td>
<p>The rate parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fiksel (1984) introduced a pairwise interaction point process
with the following interaction function <code class="reqn">c</code>.
For two points <code class="reqn">u</code> and <code class="reqn">v</code> separated by a distance
<code class="reqn">d=||u-v||</code>, the interaction
<code class="reqn">c(u,v)</code> is equal to <code class="reqn">0</code> if <code class="reqn">d &lt; h</code>,
equal to <code class="reqn">1</code> if <code class="reqn">d &gt; r</code>, and
equal to
</p>
<p style="text-align: center;"><code class="reqn"> \exp(a \exp(-\kappa d))</code>
</p>

<p>if <code class="reqn">h \le d \le r</code>, where
<code class="reqn">h,r,\kappa,a</code> are parameters.
</p>
<p>A graph of this interaction function is shown in the Examples.
The interpretation of the parameters is as follows.
</p>

<ul>
<li> <p><code class="reqn">h</code> is the hard core distance: distinct points are
not permitted to come closer than a distance <code class="reqn">h</code> apart.
</p>
</li>
<li> <p><code class="reqn">r</code> is the interaction range: points further than
this distance do not interact.
</p>
</li>
<li> <p><code class="reqn">\kappa</code> is the rate or slope parameter,
controlling the decay of the interaction as distance increases.
</p>
</li>
<li> <p><code class="reqn">a</code> is the interaction strength parameter,
controlling the strength and type of interaction.
If <code class="reqn">a</code> is zero, the process is Poisson. If <code>a</code> is positive,
the process is clustered. If <code>a</code> is negative, the process is
inhibited (regular).
</p>
</li></ul>

<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Fiksel
pairwise interaction is
yielded by the function <code>Fiksel()</code>. See the examples below.
</p>
<p>The parameters <code class="reqn">h</code>, <code class="reqn">r</code> and <code class="reqn">\kappa</code> must be
fixed and given in the call to <code>Fiksel</code>, while the canonical
parameter <code class="reqn">a</code> is estimated by <code><a href="#topic+ppm">ppm</a>()</code>.
</p>
<p>To estimate <code class="reqn">h</code>, <code class="reqn">r</code> and<code class="reqn">\kappa</code>
it is possible to use <code><a href="#topic+profilepl">profilepl</a></code>. The maximum likelihood
estimator of<code class="reqn">h</code> is the minimum interpoint distance.
</p>
<p>If the hard core distance argument <code>hc</code> is missing or <code>NA</code>,
it will be estimated from the data when <code><a href="#topic+ppm">ppm</a></code> is called.
The estimated value of <code>hc</code> is the minimum nearest neighbour distance
multiplied by <code class="reqn">n/(n+1)</code>, where <code class="reqn">n</code> is the
number of data points.
</p>
<p>See also Stoyan, Kendall and Mecke (1987) page 161.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the Fiksel
process with interaction radius <code class="reqn">r</code>,
hard core distance <code>hc</code> and
rate parameter <code>kappa</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Fiksel, T. (1984)
Estimation of parameterized pair potentials
of marked and non-marked Gibbsian point processes.
<em>Electronische Informationsverabeitung und Kybernetika</em>
<b>20</b>, 270&ndash;278.
</p>
<p>Stoyan, D, Kendall, W.S. and Mecke, J. (1987)
<em>Stochastic geometry and its applications</em>.  Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Fiksel(r=1,hc=0.02, kappa=2)
   # prints a sensible description of itself

   X &lt;- unmark(spruces)

   fit &lt;- ppm(X ~ 1, Fiksel(r=3.5, kappa=1))
   plot(fitin(fit))
</code></pre>

<hr>
<h2 id='fitin.ppm'>Extract the Interaction from a Fitted Point Process Model</h2><span id='topic+fitin'></span><span id='topic+fitin.ppm'></span><span id='topic+fitin.profilepl'></span>

<h3>Description</h3>

<p>Given a point process model that has been fitted to point pattern
data, this function extracts the interpoint interaction part of the
model as a separate object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitin(object)

## S3 method for class 'ppm'
fitin(object)

## S3 method for class 'profilepl'
fitin(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitin.ppm_+3A_object">object</code></td>
<td>
<p>A fitted point process model (object of class
<code>"ppm"</code> or <code>"profilepl"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppm"</code> describes a fitted point process
model. It contains information about the original data to which the
model was fitted, the spatial trend that was fitted, the
interpoint interaction that was fitted, and other data.
See <code><a href="#topic+ppm.object">ppm.object</a></code>) for details of this class.
</p>
<p>The function <code>fitin</code> extracts from this model the information about the
fitted interpoint interaction only.
The information is organised as an object of class <code>"fii"</code>
(fitted interpoint interaction).
This object can be printed or plotted.
</p>
<p>Users may find this a convenient way to plot the
fitted interpoint interaction term, as shown in the Examples.
</p>
<p>For a pairwise interaction, the plot of the fitted interaction
shows the pair interaction function (the contribution to the
probability density from a pair of points as a function of the
distance between them). For a higher-order interaction, the plot shows
the strongest interaction (the value most different from 1)
that could ever arise at the given distance. 
</p>
<p>The fitted interaction coefficients can also be extracted
from this object using <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fii"</code> representing the fitted
interpoint interaction. This object can be printed and plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Methods for handling fitted interactions: 
<code><a href="#topic+methods.fii">methods.fii</a></code>, <code><a href="#topic+reach.fii">reach.fii</a></code>,
<code><a href="#topic+as.interact.fii">as.interact.fii</a></code>.
</p>
<p>Background:
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # unmarked 
   model &lt;- ppm(swedishpines ~1, PairPiece(seq(3,19,by=4)))
   f &lt;- fitin(model)
   f
   plot(f)

# extract fitted interaction coefficients
   coef(f)

   # multitype
   # fit the stationary multitype Strauss process to `amacrine'
   r &lt;- 0.02 * matrix(c(1,2,2,1), nrow=2,ncol=2)
   model &lt;- ppm(amacrine ~1, MultiStrauss(r))
   f &lt;- fitin(model)
   f
   plot(f)
</code></pre>

<hr>
<h2 id='fitted.mppm'>Fitted Conditional Intensity for Multiple Point Process Model</h2><span id='topic+fitted.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to multiple point patterns, compute the
fitted conditional intensity of the model at the points of each data
pattern, or at the points of the quadrature schemes used to fit the
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'mppm'
fitted(object, ..., type = "lambda", dataonly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.mppm_+3A_object">object</code></td>
<td>

<p>The fitted model. An object of class <code>"mppm"</code>
obtained from <code><a href="#topic+mppm">mppm</a></code>.
</p>
</td></tr>
<tr><td><code id="fitted.mppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="fitted.mppm_+3A_type">type</code></td>
<td>

<p>Type of fitted values: either <code>"trend"</code> for the spatial trend,
or <code>"lambda"</code> or <code>"cif"</code> for the conditional intensity.
</p>
</td></tr>
<tr><td><code id="fitted.mppm_+3A_dataonly">dataonly</code></td>
<td>

<p>If <code>TRUE</code>, fitted values are computed only for the points
of the data point patterns. If <code>FALSE</code>, fitted values are
computed for the points of the quadrature schemes used to fit the
model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the conditional intensity
<code class="reqn">\hat\lambda(u,x)</code>
or spatial trend <code class="reqn">\hat{b(u)}</code>
of the fitted point process model for
certain locations <code class="reqn">u</code>, for each of the original point patterns <code class="reqn">x</code>
to which the model was fitted.
</p>
<p>The locations <code class="reqn">u</code> at which the fitted conditional intensity/trend is
evaluated, are the points of the quadrature schemes used to fit the
model in <code><a href="#topic+mppm">mppm</a></code>. They include the data points (the points of the
original point pattern datasets) and other &ldquo;dummy&rdquo; points  in
the window of observation.
</p>
<p>Use <code><a href="#topic+predict.mppm">predict.mppm</a></code> to compute the fitted conditional intensity at
other locations or with other values of the explanatory variables.
</p>


<h3>Value</h3>

<p>A list of vectors (one for each row of the original hyperframe,
i.e. one vector for each of the original point patterns)
containing the values of the fitted conditional intensity
or (if <code>type="trend"</code>) the fitted spatial trend.
</p>
<p>Entries in these vector correspond to the quadrature points (data
or dummy points) used to fit the model. The quadrature points can
be extracted from <code>object</code> by <code><a href="#topic+quad.mppm">quad.mppm</a>(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="#topic+predict.mppm">predict.mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   model &lt;- mppm(Bugs ~ x, data=hyperframe(Bugs=waterstriders),
                           interaction=Strauss(7))
   cifs &lt;- fitted(model)
</code></pre>

<hr>
<h2 id='fitted.ppm'>
Fitted Conditional Intensity for Point Process Model
</h2><span id='topic+fitted.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
compute the fitted conditional intensity or fitted trend of the model
at the points of the pattern,
or at the points of the quadrature scheme used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
fitted(object, ..., type="lambda",
                       dataonly=FALSE, new.coef=NULL, leaveoneout=FALSE,
		       drop=FALSE, check=TRUE, repair=TRUE,
		       ignore.hardcore=FALSE, dropcoef=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.ppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_type">type</code></td>
<td>

<p>String (partially matched) indicating whether the fitted value is the
conditional intensity (<code>"lambda"</code> or <code>"cif"</code>) or
the first order trend (<code>"trend"</code>)
or the logarithm of conditional intensity (<code>"link"</code>).
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_dataonly">dataonly</code></td>
<td>

<p>Logical. If <code>TRUE</code>, then values will only be computed
at the points of the data point pattern. If <code>FALSE</code>, then
values will be computed at all the points of the quadrature scheme
used to fit the model, including the points of the data point pattern.
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>Numeric vector of parameter values to replace the 
fitted model parameters <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical. If <code>TRUE</code> the fitted value at each data
point will be computed using a leave-one-out method. See Details.
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical value determining whether to delete quadrature points
that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>object</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_repair">repair</code></td>
<td>

<p>Logical value indicating whether to repair the internal format
of <code>object</code>, if it is found to be damaged. 
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_ignore.hardcore">ignore.hardcore</code></td>
<td>

<p>Advanced use only.
Logical value specifying whether to compute only the
finite part of the interaction potential (effectively removing
any hard core interaction terms).
</p>
</td></tr>
<tr><td><code id="fitted.ppm_+3A_dropcoef">dropcoef</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code>). Such objects are produced by the 
model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>).
</p>
<p>This function evaluates the conditional intensity
<code class="reqn">\hat\lambda(u, x)</code>
or spatial trend <code class="reqn">\hat b(u)</code> of the fitted point process
model for certain locations <code class="reqn">u</code>,
where <code>x</code> is the original point pattern dataset to which
the model was fitted.
</p>
<p>The locations <code class="reqn">u</code> at which the fitted conditional intensity/trend
is evaluated, are the points of the
quadrature scheme used to fit the model in <code><a href="#topic+ppm">ppm</a></code>.
They include the data points (the points of the original point pattern
dataset <code>x</code>) and other &ldquo;dummy&rdquo; points 
in the window of observation.
</p>
<p>If <code>leaveoneout=TRUE</code>, fitted values will be computed
for the data points only, using a &lsquo;leave-one-out&rsquo; rule: 
the fitted value at <code>X[i]</code> is effectively computed by
deleting this point from the data and re-fitting the model to the
reduced pattern <code>X[-i]</code>, then predicting the value at
<code>X[i]</code>. (Instead of literally performing this calculation,
we apply a Taylor approximation using the influence function
computed in <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>. 
</p>
<p>The argument <code>drop</code> is explained in <code><a href="#topic+quad.ppm">quad.ppm</a></code>.
</p>
<p>Use <code><a href="#topic+predict.ppm">predict.ppm</a></code> to compute the fitted conditional
intensity at other locations or with other values of the
explanatory variables.
</p>


<h3>Value</h3>

<p>A vector containing the values of the fitted conditional intensity,
fitted spatial trend, or logarithm of the fitted conditional intensity.
</p>
<p>Entries in this vector correspond to the quadrature points (data or
dummy points) used to fit the model. The quadrature points can be
extracted from <code>object</code> by <code>union.quad(quad.ppm(object))</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005).
Residual analysis for spatial point processes (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    str &lt;- ppm(cells ~x, Strauss(r=0.1))
    lambda &lt;- fitted(str)

    # extract quadrature points in corresponding order
    quadpoints &lt;- union.quad(quad.ppm(str))

    # plot conditional intensity values
    # as circles centred on the quadrature points 
    quadmarked &lt;- setmarks(quadpoints, lambda)
    plot(quadmarked)

    if(!interactive()) str &lt;- ppm(cells ~ x)

    lambdaX &lt;- fitted(str, leaveoneout=TRUE)
</code></pre>

<hr>
<h2 id='fitted.slrm'>
Fitted Probabilities for Spatial Logistic Regression
</h2><span id='topic+fitted.slrm'></span>

<h3>Description</h3>

<p>Given a fitted Spatial Logistic Regression model,
this function computes the fitted probabilities for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.slrm_+3A_object">object</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="fitted.slrm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="stats.html#topic+fitted.values">fitted</a></code>
for spatial logistic regression models
(objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>).
</p>
<p>The algorithm computes
the fitted probabilities of the presence of a random point in each pixel.
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) containing the
fitted probability for each pixel.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>,
<code><a href="stats.html#topic+fitted.values">fitted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- slrm(X ~ x+y)
  plot(fitted(fit))
</code></pre>

<hr>
<h2 id='fixef.mppm'>
Extract Fixed Effects from Point Process Model
</h2><span id='topic+fixef.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a list of point patterns,
extract the fixed effects of the model.
A method for <code>fixef</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'mppm'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.mppm_+3A_object">object</code></td>
<td>

<p>A fitted point process model (an object of class <code>"mppm"</code>).
</p>
</td></tr>
<tr><td><code id="fixef.mppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="nlme.html#topic+fixef">fixef</a></code>.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"mppm"</code>) produced by the 
fitting algorithm <code><a href="#topic+mppm">mppm</a></code>). This represents a
point process model that has been fitted
to a list of several point pattern datasets. See <code><a href="#topic+mppm">mppm</a></code>
for information.
</p>
<p>This function extracts the coefficients of the fixed effects
of the model.
</p>


<h3>Value</h3>

<p>A numeric vector of coefficients.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented in <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.mppm">coef.mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> H &lt;- hyperframe(Y = waterstriders)
 # Tweak data to exaggerate differences
 H$Y[[1]] &lt;- rthin(H$Y[[1]], 0.3)
 m1 &lt;- mppm(Y ~ id,  data=H, Strauss(7))
 fixef(m1)
 m2 &lt;- mppm(Y ~ 1,  random=~1|id, data=H, Strauss(7))
 fixef(m2)
</code></pre>

<hr>
<h2 id='formula.ppm'>
Model Formulae for Gibbs Point Process Models
</h2><span id='topic+formula.ppm'></span><span id='topic+terms.ppm'></span>

<h3>Description</h3>

<p>Extract the trend formula, or the terms in the trend formula,
in a fitted Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
formula(x, ...)
## S3 method for class 'ppm'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.ppm_+3A_x">x</code></td>
<td>

<p>An object of class <code>"ppm"</code>,
representing a fitted point process model.
</p>
</td></tr>
<tr><td><code id="formula.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+formula">formula</a></code> and 
<code><a href="stats.html#topic+terms">terms</a></code> 
for the class <code>"ppm"</code>.
</p>
<p>An object of class <code>"ppm"</code> represents a fitted
Poisson or Gibbs point process model.
It is obtained from the model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The method <code>formula.ppm</code> extracts the trend formula from the
fitted model <code>x</code> (the formula originally specified as the
argument <code>trend</code> to <code><a href="#topic+ppm">ppm</a></code>).
The method <code>terms.ppm</code> extracts the individual
terms in the trend formula.
</p>


<h3>Value</h3>

<p>See the help files for the corresponding generic functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,  
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+coef.ppm">coef.ppm</a></code>,
<code><a href="#topic+extractAIC.ppm">extractAIC.ppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="#topic+logLik.ppm">logLik.ppm</a></code>,
<code><a href="#topic+model.frame.ppm">model.frame.ppm</a></code>,
<code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="#topic+summary.ppm">summary.ppm</a></code>,
<code><a href="#topic+update.ppm">update.ppm</a></code>,
<code><a href="#topic+vcov.ppm">vcov.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells, ~x)
  formula(fit)
  terms(fit)  
</code></pre>

<hr>
<h2 id='Gcom'>
Model Compensator of Nearest Neighbour Function
</h2><span id='topic+Gcom'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the <em>compensator</em> 
of the nearest neighbour distance distribution function <code class="reqn">G</code>
based on the fitted model 
(as well as the usual nonparametric estimates
of <code class="reqn">G</code> based on the data alone).
Comparison between the nonparametric and model-compensated <code class="reqn">G</code>
functions serves as a diagnostic for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gcom(object, r = NULL, breaks = NULL, ...,
     correction = c("border", "Hanisch"),
     conditional = !is.poisson(object),
     restrict=FALSE,
     model=NULL,
     trend = ~1, interaction = Poisson(),
     rbord = reach(interaction),
     ppmcorrection="border",
     truecoef = NULL, hi.res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gcom_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>)
or a point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
function <code class="reqn">G(r)</code> should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_correction">correction</code></td>
<td>

<p>Edge correction(s) to be employed in calculating the compensator.
Options are <code>"border"</code>, <code>"Hanisch"</code> and <code>"best"</code>.
Alternatively <code>correction="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_conditional">conditional</code></td>
<td>

<p>Optional. Logical value indicating whether to 
compute the estimates for the conditional case. See Details.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_restrict">restrict</code></td>
<td>

<p>Logical value indicating whether to compute
the restriction estimator (<code>restrict=TRUE</code>) or
the reweighting estimator (<code>restrict=FALSE</code>, the default).
Applies only if <code>conditional=TRUE</code>.  See Details.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_model">model</code></td>
<td>

<p>Optional. A fitted point process model (object of
class <code>"ppm"</code>) to be re-fitted to the data
using <code><a href="#topic+update.ppm">update.ppm</a></code>, if <code>object</code> is a point pattern.
Overrides the arguments <code>trend,interaction,rbord,ppmcorrection</code>.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_trend">trend</code>, <code id="Gcom_+3A_interaction">interaction</code>, <code id="Gcom_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern.
See <code><a href="#topic+ppm">ppm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_ppmcorrection">ppmcorrection</code></td>
<td>

<p>The <code>correction</code> argument to <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_truecoef">truecoef</code></td>
<td>

<p>Optional. Numeric vector. If present, this will be treated as 
if it were the true coefficient vector of the point process model,
in calculating the diagnostic. Incompatible with <code>hi.res</code>.
</p>
</td></tr>
<tr><td><code id="Gcom_+3A_hi.res">hi.res</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
If this argument is present, the model will be
re-fitted at high resolution as specified by these parameters.
The coefficients
of the resulting fitted model will be taken as the true coefficients.
Then the diagnostic will be computed for the default
quadrature scheme, but using the high resolution coefficients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command provides a diagnostic for the goodness-of-fit of
a point process model fitted to a point pattern dataset.
It computes different estimates of the nearest neighbour distance
distribution function <code class="reqn">G</code> of the
dataset, which should be approximately equal if the model is a good
fit to the data.
</p>
<p>The first argument, <code>object</code>, is usually a fitted point process model
(object of class <code>"ppm"</code>), obtained from the
model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>For convenience, <code>object</code> can also be a point pattern
(object of class <code>"ppp"</code>).
In that case, a point process
model will be fitted to it,
by calling <code><a href="#topic+ppm">ppm</a></code> using the arguments
<code>trend</code> (for the first order trend),
<code>interaction</code> (for the interpoint interaction)
and <code>rbord</code> (for the erosion distance in the border correction
for the pseudolikelihood). See <code><a href="#topic+ppm">ppm</a></code> for details
of these arguments.
</p>
<p>The algorithm first extracts the original point pattern dataset
(to which the model was fitted) and computes the 
standard nonparametric estimates of the <code class="reqn">G</code> function.
It then also computes the <em>model-compensated</em> 
<code class="reqn">G</code> function. The different functions are returned
as columns in a data frame (of class <code>"fv"</code>).
The interpretation of the columns is as follows
(ignoring edge corrections):
</p>

<dl>
<dt><code>bord</code>:</dt><dd> 
<p>the nonparametric border-correction estimate of <code class="reqn">G(r)</code>,
</p>
<p style="text-align: center;"><code class="reqn">
	\hat G(r) = \frac{\sum_i I\{ d_i \le r\} I\{ b_i &gt; r \}}{\sum_i I\{
	  b_i &gt; r\}}
      </code>
</p>

<p>where <code class="reqn">d_i</code> is the distance from the <code class="reqn">i</code>-th data point
to its nearest neighbour, and <code class="reqn">b_i</code> is the distance from the
<code class="reqn">i</code>-th data point to the boundary of the window <code class="reqn">W</code>.
</p>
</dd>
<dt><code>bcom</code>:</dt><dd>
<p>the model compensator of the border-correction estimate
</p>
<p style="text-align: center;"><code class="reqn">
	{\bf C}\,  \hat G(r) = \frac{\int \lambda(u,x) I\{ b(u) &gt; r\} I\{ d(u,x)
	  \le r\}}{ 1 + \sum_i I\{ b_i &gt; r\} }
      </code>
</p>

<p>where 
<code class="reqn">\lambda(u,x)</code> denotes the conditional intensity
of the model at the location <code class="reqn">u</code>, and <code class="reqn">d(u,x)</code> denotes the
distance from <code class="reqn">u</code> to the nearest point in <code class="reqn">x</code>, while
<code class="reqn">b(u)</code> denotes the distance from <code class="reqn">u</code> to the boundary of the
window<code class="reqn">W</code>.
</p>
</dd>
<dt><code>han</code>:</dt><dd>
<p>the nonparametric Hanisch estimate of <code class="reqn">G(r)</code>
</p>
<p style="text-align: center;"><code class="reqn">
	\hat G(r) = \frac{D(r)}{D(\infty)}
      </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
	D(r) = \sum_i 
	\frac{ I\{x_i \in W_{\ominus d_i}\} I\{d_i \le r\}
	}{
	  \mbox{area}(W_{\ominus d_i})
	}
      </code>
</p>

<p>in which <code class="reqn">W_{\ominus r}</code> denotes the erosion of the window
<code class="reqn">W</code> by a distance <code class="reqn">r</code>.
</p>
</dd>
<dt><code>hcom</code>:</dt><dd>
<p>the corresponding model-compensated function 
</p>
<p style="text-align: center;"><code class="reqn">
	{\bf C} \, G(r) = \int_W 
	\frac{
	  \lambda(u,x) I(u \in W_{\ominus d(u)}) I(d(u) \le r)
	}{ 
	  \hat D(\infty) \mbox{area}(W_{\ominus d(u)}) + 1
	}
      </code>
</p>

<p>where <code class="reqn">d(u) = d(u, x)</code> is the (&lsquo;empty space&rsquo;) 
distance from location <code class="reqn">u</code> to the nearest point of <code class="reqn">x</code>.
</p>
</dd>
</dl>

<p>If the fitted model is a Poisson point process, then the formulae above
are exactly what is computed. If the fitted model is not Poisson, the 
formulae above are modified slightly to handle edge effects.
</p>
<p>The modification is determined by the arguments
<code>conditional</code> and <code>restrict</code>.
The value of <code>conditional</code> defaults to <code>FALSE</code> for Poisson models
and <code>TRUE</code> for non-Poisson models.
If <code>conditional=FALSE</code> then the formulae above are not modified.
If <code>conditional=TRUE</code>, then the algorithm calculates
the <em>restriction estimator</em> if <code>restrict=TRUE</code>,
and calculates the <em>reweighting estimator</em> if <code>restrict=FALSE</code>.
See Appendix E of Baddeley, Rubak and Moller (2011).
See also <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a>('eroded.intensity')</code>.
Thus, by default, the reweighting estimator is computed
for non-Poisson models.
</p>
<p>The border-corrected and Hanisch-corrected estimates of <code class="reqn">G(r)</code> are
approximately unbiased estimates of the <code class="reqn">G</code>-function,
assuming the point process is
stationary. The model-compensated functions are unbiased estimates
<em>of the mean value of the corresponding nonparametric estimate</em>,
assuming the model is true. Thus, if the model is a good fit, the mean value
of the difference between the nonparametric and model-compensated
estimates is approximately zero.
</p>
<p>To compute the difference between the nonparametric and model-compensated
functions, use <code><a href="#topic+Gres">Gres</a></code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Related functions:
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>,
<code><a href="#topic+Gres">Gres</a></code>.
</p>
<p>Alternative functions:
<code><a href="#topic+Kcom">Kcom</a></code>, 
<code><a href="#topic+psstA">psstA</a></code>, 
<code><a href="#topic+psstG">psstG</a></code>, 
<code><a href="#topic+psst">psst</a></code>.
</p>
<p>Model fitting: <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit0 &lt;- ppm(cells, ~1) # uniform Poisson
    G0 &lt;- Gcom(fit0)
    G0
    plot(G0)
# uniform Poisson is clearly not correct

# Hanisch estimates only
    plot(Gcom(fit0), cbind(han, hcom) ~ r)

    fit1 &lt;- ppm(cells, ~1, Strauss(0.08))
    plot(Gcom(fit1), cbind(han, hcom) ~ r)

# Try adjusting interaction distance

    fit2 &lt;- update(fit1, Strauss(0.10))
    plot(Gcom(fit2), cbind(han, hcom) ~ r)

    G3 &lt;- Gcom(cells, interaction=Strauss(0.12))
    plot(G3, cbind(han, hcom) ~ r)
</code></pre>

<hr>
<h2 id='Geyer'>Geyer's Saturation Point Process Model</h2><span id='topic+Geyer'></span>

<h3>Description</h3>

<p>Creates an instance of Geyer's saturation point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Geyer(r,sat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Geyer_+3A_r">r</code></td>
<td>
<p>Interaction radius. A positive real number.</p>
</td></tr>
<tr><td><code id="Geyer_+3A_sat">sat</code></td>
<td>
<p>Saturation threshold. A non-negative real number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geyer (1999) introduced the &ldquo;saturation process&rdquo;,
a modification of the Strauss process (see <code><a href="#topic+Strauss">Strauss</a></code>)
in which the total contribution
to the potential  from each point (from its pairwise interaction with all 
other points) is trimmed to a maximum value <code class="reqn">s</code>. 
The interaction structure of this
model is implemented in the function <code><a href="#topic+Geyer">Geyer</a>()</code>.
</p>
<p>The saturation point process with interaction radius <code class="reqn">r</code>,
saturation threshold <code class="reqn">s</code>, and 
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
is the point process
in which each point
<code class="reqn">x_i</code> in the pattern <code class="reqn">X</code>
contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">
    \beta \gamma^{\min(s, t(x_i, X))}
  </code>
</p>

<p>to the probability density of the point pattern,
where <code class="reqn">t(x_i, X)</code> denotes the
number of &lsquo;close neighbours&rsquo; of <code class="reqn">x_i</code> in the pattern
<code class="reqn">X</code>. A close neighbour of <code class="reqn">x_i</code> is a point
<code class="reqn">x_j</code> with <code class="reqn">j \neq i</code>
such that the distance between 
<code class="reqn">x_i</code> and <code class="reqn">x_j</code> is less than or equal to <code class="reqn">r</code>.
</p>
<p>If the saturation threshold <code class="reqn">s</code> is set to infinity,
this model reduces to the Strauss process (see <code><a href="#topic+Strauss">Strauss</a></code>)
with interaction parameter <code class="reqn">\gamma^2</code>.
If <code class="reqn">s = 0</code>, the model reduces to the Poisson point process.
If <code class="reqn">s</code> is a finite positive number, then the interaction parameter
<code class="reqn">\gamma</code> may take any positive value (unlike the case
of the Strauss process), with
values <code class="reqn">\gamma &lt; 1</code>
describing an &lsquo;ordered&rsquo; or &lsquo;inhibitive&rsquo; pattern,
and 
values <code class="reqn">\gamma &gt; 1</code>
describing a &lsquo;clustered&rsquo; or &lsquo;attractive&rsquo; pattern.
</p>
<p>The nonstationary saturation process is similar except that 
the value <code class="reqn">\beta</code> 
is replaced by a function <code class="reqn">\beta(x_i)</code>
of location.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the saturation process interaction is
yielded by <code>Geyer(r, sat)</code> where the
arguments <code>r</code> and <code>sat</code> specify
the Strauss interaction radius <code class="reqn">r</code> and the saturation threshold
<code class="reqn">s</code>, respectively. See the examples below.
</p>
<p>Note the only arguments are the interaction radius <code>r</code>
and the saturation threshold <code>sat</code>.
When <code>r</code> and <code>sat</code> are fixed,
the model becomes an exponential family.
The canonical parameters <code class="reqn">\log(\beta)</code>
and <code class="reqn">\log(\gamma)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>Geyer()</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of Geyer's saturation point process
with interaction radius <code class="reqn">r</code> and saturation threshold <code>sat</code>.
</p>


<h3>Zero saturation</h3>

<p>The value <code>sat=0</code> is permitted by <code>Geyer</code>,
but this is not very useful.
For technical reasons, when <code><a href="#topic+ppm">ppm</a></code> fits a
Geyer model with <code>sat=0</code>, the default behaviour is to return
an &ldquo;invalid&rdquo; fitted model in which the estimate of
<code class="reqn">\gamma</code> is <code>NA</code>.  In order to get a Poisson
process model returned when <code>sat=0</code>,
you would need to set <code>emend=TRUE</code> in
the call to <code><a href="#topic+ppm">ppm</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point Processes.
Chapter 3 in 
O.E. Barndorff-Nielsen, W.S. Kendall and M.N.M. Van Lieshout (eds)
<em>Stochastic Geometry: Likelihood and Computation</em>,
Chapman and Hall / CRC, 
Monographs on Statistics and Applied Probability, number 80.
Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>.
</p>
<p>To make an interaction object like <code><a href="#topic+Geyer">Geyer</a></code> but having
multiple interaction radii, see <code><a href="#topic+BadGey">BadGey</a></code> or <code><a href="#topic+Hybrid">Hybrid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ppm(cells, ~1, Geyer(r=0.07, sat=2))
   # fit the stationary saturation process to `cells'
</code></pre>

<hr>
<h2 id='Gres'>
Residual G Function
</h2><span id='topic+Gres'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the residual <code class="reqn">G</code> function,
which serves as a diagnostic for goodness-of-fit of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Gres(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gres_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>),
a point pattern (object of class <code>"ppp"</code>),
a quadrature scheme (object of class <code>"quad"</code>),
or the value returned by a previous call to <code><a href="#topic+Gcom">Gcom</a></code>.
</p>
</td></tr>
<tr><td><code id="Gres_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+Gcom">Gcom</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command provides a diagnostic for the goodness-of-fit of
a point process model fitted to a point pattern dataset.
It computes a residual version of the <code class="reqn">G</code> function of the
dataset, which should be approximately zero if the model is a good
fit to the data.
</p>
<p>In normal use, <code>object</code> is a fitted point process model
or a point pattern. Then <code>Gres</code> first calls <code><a href="#topic+Gcom">Gcom</a></code>
to compute both the nonparametric estimate of the <code class="reqn">G</code> function
and its model compensator. Then <code>Gres</code> computes the
difference between them, which is the residual <code class="reqn">G</code>-function.
</p>
<p>Alternatively, <code>object</code> may be a function value table
(object of class <code>"fv"</code>) that was returned by
a previous call to <code><a href="#topic+Gcom">Gcom</a></code>. Then <code>Gres</code> computes the
residual from this object. 
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Related functions:
<code><a href="#topic+Gcom">Gcom</a></code>, 
<code><a href="spatstat.explore.html#topic+Gest">Gest</a></code>.
</p>
<p>Alternative functions:
<code><a href="#topic+Kres">Kres</a></code>, 
<code><a href="#topic+psstA">psstA</a></code>, 
<code><a href="#topic+psstG">psstG</a></code>, 
<code><a href="#topic+psst">psst</a></code>.
</p>
<p>Model-fitting:
<code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit0 &lt;- ppm(cells, ~1) # uniform Poisson
    G0 &lt;- Gres(fit0)
    plot(G0)
# Hanisch correction estimate
    plot(G0, hres ~ r)
# uniform Poisson is clearly not correct

    fit1 &lt;- ppm(cells, ~1, Strauss(0.08))
    plot(Gres(fit1), hres ~ r)
# fit looks approximately OK; try adjusting interaction distance

    plot(Gres(cells, interaction=Strauss(0.12)))

# How to make envelopes
    if(interactive()) {
      E &lt;- envelope(fit1, Gres, model=fit1, nsim=39)
      plot(E)
    }
# For computational efficiency
    Gc &lt;- Gcom(fit1)
    G1 &lt;- Gres(Gc)
</code></pre>

<hr>
<h2 id='Hardcore'>The Hard Core Point Process Model</h2><span id='topic+Hardcore'></span>

<h3>Description</h3>

<p>Creates an instance of the hard core point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Hardcore(hc=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hardcore_+3A_hc">hc</code></td>
<td>
<p>The hard core distance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A hard core process with 
hard core distance <code class="reqn">h</code> and abundance
parameter <code class="reqn">\beta</code> 
is a pairwise interaction point process
in which distinct points are not allowed to come closer
than a distance <code class="reqn">h</code> apart.
</p>
<p>The probability density is zero if any pair of points
is closer than <code class="reqn">h</code> units apart, and otherwise equals
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} 
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, and <code class="reqn">\alpha</code> is the normalising constant.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the hard core process
pairwise interaction is 
yielded by the function <code>Hardcore()</code>. See the examples below.
</p>
<p>If the hard core distance argument <code>hc</code> is missing or <code>NA</code>,
it will be estimated from the data when <code><a href="#topic+ppm">ppm</a></code> is called.
The estimated value of <code>hc</code> is the minimum nearest neighbour distance
multiplied by <code class="reqn">n/(n+1)</code>, where <code class="reqn">n</code> is the
number of data points.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the hard core
process with hard core distance <code>hc</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>,
<code><a href="#topic+MultiHard">MultiHard</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Hardcore(0.02)
   # prints a sensible description of itself

   ppm(cells ~1, Hardcore(0.05))
   # fit the stationary hard core process to `cells'

   # estimate hard core radius from data
   ppm(cells ~1, Hardcore())
   
     # equivalent:
     ppm(cells ~1, Hardcore)
   

   
     # fit a nonstationary hard core process
     # with log-cubic polynomial trend
     ppm(cells ~ polynom(x,y,3), Hardcore(0.05))
   
</code></pre>

<hr>
<h2 id='hardcoredist'>
Extract the Hard Core Distance of a Point Process Model
</h2><span id='topic+hardcoredist'></span><span id='topic+hardcoredist.fii'></span><span id='topic+hardcoredist.ppm'></span>

<h3>Description</h3>

<p>Extract or compute the hard core distance of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hardcoredist(x, ...)

## S3 method for class 'fii'
hardcoredist(x, ..., epsilon = 0)

## S3 method for class 'ppm'
hardcoredist(x, ..., epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hardcoredist_+3A_x">x</code></td>
<td>

<p>An object representing a point process model
(class <code>"ppm"</code>)
or the interaction structure of a point process
(class <code>"fii"</code>) or similar.
</p>
</td></tr>
<tr><td><code id="hardcoredist_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="hardcoredist_+3A_epsilon">epsilon</code></td>
<td>

<p>Tolerance for defining the hard core.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A point process model has a hard core distance <code>h</code>
if it is impossible for two random points to lie closer than the
distance <code>h</code> apart.
</p>
<p>The function <code>hardcoredist</code> is generic, with methods for
objects of class <code>"ppm"</code> (point process models)
and <code>"fii"</code> (fitted point process interactions).
It extracts or computes the hard core distance.
</p>
<p>If <code>epsilon</code> is specified, then the code calculates the
largest distance at which the interaction factor is smaller than
<code>epsilon</code>, implying that points are unlikely to occur closer
than this distance.
</p>
<p>The result is zero if the model does not have a hard core distance.
</p>


<h3>Value</h3>

<p>A single numeric value, or for multitype point processes, a numeric matrix giving the
hard core distances for each pair of types of points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- ppm(cells~1, Hardcore())
  hardcoredist(m)
</code></pre>

<hr>
<h2 id='harmonic'>Basis for Harmonic Functions</h2><span id='topic+harmonic'></span>

<h3>Description</h3>

<p>Evaluates a basis for the harmonic polynomials in <code class="reqn">x</code> and <code class="reqn">y</code>
of degree less than or equal to <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   harmonic(x, y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_+3A_x">x</code></td>
<td>

<p>Vector of <code class="reqn">x</code> coordinates
</p>
</td></tr>
<tr><td><code id="harmonic_+3A_y">y</code></td>
<td>

<p>Vector of <code class="reqn">y</code> coordinates
</p>
</td></tr>
<tr><td><code id="harmonic_+3A_n">n</code></td>
<td>

<p>Maximum degree of polynomial
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a basis for the harmonic polynomials
in two variables <code class="reqn">x</code> and <code class="reqn">y</code> up to a given degree <code class="reqn">n</code>
and evaluates them at given <code class="reqn">x,y</code> locations.
It can be used in model formulas (for example in
the model-fitting functions
<code><a href="stats.html#topic+lm">lm</a>,<a href="stats.html#topic+glm">glm</a>,<a href="mgcv.html#topic+gam">gam</a></code> and 
<code><a href="#topic+ppm">ppm</a></code>) to specify a
linear predictor which is a harmonic function.
</p>
<p>A function <code class="reqn">f(x,y)</code> is harmonic if
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial^2}{\partial x^2} f
    + \frac{\partial^2}{\partial y^2}f = 0.</code>
</p>

<p>The harmonic polynomials of degree less than or equal to
<code class="reqn">n</code> have a basis consisting of <code class="reqn">2 n</code> functions.
</p>
<p>This function was implemented on a suggestion of P. McCullagh
for fitting nonstationary spatial trend to point process models.
</p>


<h3>Value</h3>

<p>A data frame with <code>2 * n</code> columns giving the values of the
basis functions at the coordinates. Each column is labelled by an
algebraic expression for the corresponding basis function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+polynom">polynom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # inhomogeneous point pattern
   X &lt;- unmark(longleaf)
   

   # fit Poisson point process with log-cubic intensity
   fit.3 &lt;- ppm(X ~ polynom(x,y,3), Poisson())

   # fit Poisson process with log-cubic-harmonic intensity
   fit.h &lt;- ppm(X ~ harmonic(x,y,3), Poisson())

   # Likelihood ratio test
   lrts &lt;- 2 * (logLik(fit.3) - logLik(fit.h))
   df &lt;- with(coords(X),
              ncol(polynom(x,y,3)) - ncol(harmonic(x,y,3)))
   pval &lt;- 1 - pchisq(lrts, df=df)
</code></pre>

<hr>
<h2 id='harmonise.msr'>Make Measures Compatible</h2><span id='topic+harmonise.msr'></span>

<h3>Description</h3>

<p>Convert several measures to a common quadrature scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msr'
harmonise(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonise.msr_+3A_...">...</code></td>
<td>

<p>Any number of measures (objects of class <code>"msr"</code>).
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function makes any number of measures compatible,
by converting them all to a common quadrature scheme.
</p>
<p>The command <code><a href="spatstat.geom.html#topic+harmonise">harmonise</a></code> is generic. This is the
method for objects of class <code>"msr"</code>.
</p>


<h3>Value</h3>

<p>A list, of length equal to the number of arguments <code>...</code>,
whose entries are measures.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+harmonise">harmonise</a></code>,
<code><a href="#topic+msr">msr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit1 &lt;- ppm(cells ~ x)
  fit2 &lt;- ppm(rpoispp(ex=cells) ~ x)
  m1 &lt;- residuals(fit1)
  m2 &lt;- residuals(fit2)
  harmonise(m1, m2)
  s1 &lt;- residuals(fit1, type="score")
  s2 &lt;- residuals(fit2, type="score")
  harmonise(s1, s2)
</code></pre>

<hr>
<h2 id='HierHard'>The Hierarchical  Hard Core Point Process Model</h2><span id='topic+HierHard'></span>

<h3>Description</h3>

<p>Creates an instance of the hierarchical hard core point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  HierHard(hradii=NULL, types=NULL, archy=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierHard_+3A_hradii">hradii</code></td>
<td>
<p>Optional matrix of hard core distances</p>
</td></tr>
<tr><td><code id="HierHard_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
<tr><td><code id="HierHard_+3A_archy">archy</code></td>
<td>
<p>Optional: the hierarchical order. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a hierarchical point process model
for a multitype point pattern
(Hogmander and 
Sarkka, 1999;
Grabarnik and Sarkka, 2009).
It is appropriate for analysing multitype point pattern data
in which the types are ordered so that
the points of type <code class="reqn">j</code> depend on the points of type
<code class="reqn">1,2,\ldots,j-1</code>.
</p>
<p>The hierarchical version of the (stationary) 
hard core process with <code class="reqn">m</code> types, with
hard core distances <code class="reqn">h_{ij}</code> and 
parameters <code class="reqn">\beta_j</code>, is a point process
in which each point of type <code class="reqn">j</code>
contributes a factor <code class="reqn">\beta_j</code> to the 
probability density of the point pattern.
If any pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code> lies closer than <code class="reqn">h_{ij}</code>
units apart, the configuration of points is impossible (probability
density zero).
</p>
<p>The nonstationary hierarchical  hard core
process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location and type, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>,
which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the hierarchical
hard core process pairwise interaction is
yielded by the function <code>HierHard()</code>. See the examples below.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the HierHard interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrix <code>radii</code>.
</p>
<p>The argument <code>archy</code> can be used to specify a hierarchical
ordering of the types. It can be either a vector of integers
or a character vector matching the possible types.
The default is the sequence
<code class="reqn">1,2, \ldots, m</code> meaning that type <code class="reqn">j</code>
depends on types <code class="reqn">1,2, \ldots, j-1</code>.
</p>
<p>The matrix <code>iradii</code> must be square, with entries
which are either positive numbers, or zero or <code>NA</code>. 
A value of zero or <code>NA</code> indicates that no hard core interaction term
should be included for this combination of types.
</p>
<p>Note that only the hard core distances are
specified in <code>HierHard</code>.  The canonical
parameters <code class="reqn">\log(\beta_j)</code> 
are estimated by
<code><a href="#topic+ppm">ppm</a>()</code>, not fixed in <code>HierHard()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the hierarchical hard core process with
hard core distances <code class="reqn">hradii[i,j]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Grabarnik, P. and Sarkka, A. (2009)
Modelling the spatial structure of forest stands by
multivariate point processes with hierarchical interactions.
<em>Ecological Modelling</em> <b>220</b>, 1232&ndash;1240.
</p>
<p>Hogmander, H. and 
Sarkka, A. (1999)
Multitype spatial point patterns with hierarchical interactions.
<em>Biometrics</em> <b>55</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiHard">MultiHard</a></code> for the corresponding
symmetrical interaction.
</p>
<p><code><a href="#topic+HierStrauss">HierStrauss</a></code>,
<code><a href="#topic+HierStraussHard">HierStraussHard</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   h &lt;- matrix(c(4, NA, 10, 15), 2, 2)
   HierHard(h)
   # prints a sensible description of itself
   ppm(ants ~1, HierHard(h))
   # fit the stationary hierarchical hard core process to ants data
</code></pre>

<hr>
<h2 id='hierpair.family'>Hierarchical Pairwise Interaction Process Family</h2><span id='topic+hierpair.family'></span>

<h3>Description</h3>

<p>An object describing the family of all hierarchical pairwise interaction Gibbs
point processes.
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes 
the hierarchical pairwise interaction family of point process models.
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Other families: 
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>,
<code><a href="#topic+inforder.family">inforder.family</a></code>.
</p>
<p>Hierarchical Strauss interaction:
<code><a href="#topic+HierStrauss">HierStrauss</a></code>.
</p>

<hr>
<h2 id='HierStrauss'>The Hierarchical Strauss Point Process Model</h2><span id='topic+HierStrauss'></span>

<h3>Description</h3>

<p>Creates an instance of the hierarchical Strauss point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  HierStrauss(radii, types=NULL, archy=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierStrauss_+3A_radii">radii</code></td>
<td>
<p>Matrix of interaction radii</p>
</td></tr>
<tr><td><code id="HierStrauss_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
<tr><td><code id="HierStrauss_+3A_archy">archy</code></td>
<td>
<p>Optional: the hierarchical order. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a hierarchical point process model
for a multitype point pattern
(Hogmander and 
Sarkka, 1999;
Grabarnik and Sarkka, 2009).
It is appropriate for analysing multitype point pattern data
in which the types are ordered so that
the points of type <code class="reqn">j</code> depend on the points of type
<code class="reqn">1,2,\ldots,j-1</code>.
</p>
<p>The hierarchical version of the (stationary) 
Strauss process with <code class="reqn">m</code> types, with interaction radii
<code class="reqn">r_{ij}</code> and 
parameters <code class="reqn">\beta_j</code> and <code class="reqn">\gamma_{ij}</code>
is a point process
in which each point of type <code class="reqn">j</code>
contributes a factor <code class="reqn">\beta_j</code> to the 
probability density of the point pattern, and a pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code> closer than <code class="reqn">r_{ij}</code>
units apart contributes a factor
<code class="reqn">\gamma_{ij}</code> to the density
<b>provided</b> <code class="reqn">i \le j</code>. 
</p>
<p>The nonstationary hierarchical Strauss process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location and type, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>,
which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the hierarchical
Strauss process pairwise interaction is
yielded by the function <code>HierStrauss()</code>. See the examples below.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the HierStrauss interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrix <code>radii</code>.
</p>
<p>The argument <code>archy</code> can be used to specify a hierarchical
ordering of the types. It can be either a vector of integers
or a character vector matching the possible types.
The default is the sequence
<code class="reqn">1,2, \ldots, m</code> meaning that type <code class="reqn">j</code>
depends on types <code class="reqn">1,2, \ldots, j-1</code>.
</p>
<p>The matrix <code>radii</code> must be symmetric, with entries
which are either positive numbers or <code>NA</code>. 
A value of <code>NA</code> indicates that no interaction term should be included
for this combination of types.
</p>
<p>Note that only the interaction radii are
specified in <code>HierStrauss</code>.  The canonical
parameters <code class="reqn">\log(\beta_j)</code> and
<code class="reqn">\log(\gamma_{ij})</code> are estimated by
<code><a href="#topic+ppm">ppm</a>()</code>, not fixed in <code>HierStrauss()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the hierarchical Strauss process with
interaction radii <code class="reqn">radii[i,j]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Grabarnik, P. and Sarkka, A. (2009)
Modelling the spatial structure of forest stands by
multivariate point processes with hierarchical interactions.
<em>Ecological Modelling</em> <b>220</b>, 1232&ndash;1240.
</p>
<p>Hogmander, H. and 
Sarkka, A. (1999)
Multitype spatial point patterns with hierarchical interactions.
<em>Biometrics</em> <b>55</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiStrauss">MultiStrauss</a></code> for the corresponding
symmetrical interaction.
</p>
<p><code><a href="#topic+HierHard">HierHard</a></code>,
<code><a href="#topic+HierStraussHard">HierStraussHard</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   r &lt;- matrix(10 * c(3,4,4,3), nrow=2,ncol=2)
   HierStrauss(r)
   # prints a sensible description of itself
   ppm(ants ~1, HierStrauss(r, , c("Messor", "Cataglyphis")))
   # fit the stationary hierarchical Strauss process to ants data
</code></pre>

<hr>
<h2 id='HierStraussHard'>The Hierarchical Strauss Hard Core Point Process Model</h2><span id='topic+HierStraussHard'></span>

<h3>Description</h3>

<p>Creates an instance of the hierarchical Strauss-hard core point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  HierStraussHard(iradii, hradii=NULL, types=NULL, archy=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierStraussHard_+3A_iradii">iradii</code></td>
<td>
<p>Matrix of interaction radii</p>
</td></tr>
<tr><td><code id="HierStraussHard_+3A_hradii">hradii</code></td>
<td>
<p>Optional matrix of hard core distances</p>
</td></tr>
<tr><td><code id="HierStraussHard_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
<tr><td><code id="HierStraussHard_+3A_archy">archy</code></td>
<td>
<p>Optional: the hierarchical order. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a hierarchical point process model
for a multitype point pattern
(Hogmander and 
Sarkka, 1999;
Grabarnik and Sarkka, 2009).
It is appropriate for analysing multitype point pattern data
in which the types are ordered so that
the points of type <code class="reqn">j</code> depend on the points of type
<code class="reqn">1,2,\ldots,j-1</code>.
</p>
<p>The hierarchical version of the (stationary) 
Strauss hard core process with <code class="reqn">m</code> types, with interaction radii
<code class="reqn">r_{ij}</code>, hard core distances <code class="reqn">h_{ij}</code> and 
parameters <code class="reqn">\beta_j</code> and <code class="reqn">\gamma_{ij}</code>
is a point process
in which each point of type <code class="reqn">j</code>
contributes a factor <code class="reqn">\beta_j</code> to the 
probability density of the point pattern, and a pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code> closer than <code class="reqn">r_{ij}</code>
units apart contributes a factor
<code class="reqn">\gamma_{ij}</code> to the density
<b>provided</b> <code class="reqn">i \le j</code>. If any pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code> lies closer than <code class="reqn">h_{ij}</code>
units apart, the configuration of points is impossible (probability
density zero).
</p>
<p>The nonstationary hierarchical Strauss hard core
process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location and type, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>,
which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the hierarchical
Strauss hard core process pairwise interaction is
yielded by the function <code>HierStraussHard()</code>. See the examples below.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the HierStraussHard interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrix <code>radii</code>.
</p>
<p>The argument <code>archy</code> can be used to specify a hierarchical
ordering of the types. It can be either a vector of integers
or a character vector matching the possible types.
The default is the sequence
<code class="reqn">1,2, \ldots, m</code> meaning that type <code class="reqn">j</code>
depends on types <code class="reqn">1,2, \ldots, j-1</code>.
</p>
<p>The matrices <code>iradii</code> and <code>hradii</code> must be square, with entries
which are either positive numbers or zero or <code>NA</code>. 
A value of zero or <code>NA</code> indicates that no interaction term
should be included for this combination of types.
</p>
<p>Note that only the interaction radii and hard core distances are
specified in <code>HierStraussHard</code>.  The canonical
parameters <code class="reqn">\log(\beta_j)</code> and
<code class="reqn">\log(\gamma_{ij})</code> are estimated by
<code><a href="#topic+ppm">ppm</a>()</code>, not fixed in <code>HierStraussHard()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the hierarchical Strauss-hard core process with
interaction radii <code class="reqn">iradii[i,j]</code> and hard core distances
<code class="reqn">hradii[i,j]</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Grabarnik, P. and Sarkka, A. (2009)
Modelling the spatial structure of forest stands by
multivariate point processes with hierarchical interactions.
<em>Ecological Modelling</em> <b>220</b>, 1232&ndash;1240.
</p>
<p>Hogmander, H. and 
Sarkka, A. (1999)
Multitype spatial point patterns with hierarchical interactions.
<em>Biometrics</em> <b>55</b>, 1051&ndash;1058.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code> for the corresponding
symmetrical interaction.
</p>
<p><code><a href="#topic+HierHard">HierHard</a></code>,
<code><a href="#topic+HierStrauss">HierStrauss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   r &lt;- matrix(c(30, NA, 40, 30), nrow=2,ncol=2)
   h &lt;- matrix(c(4, NA, 10, 15), 2, 2)
   HierStraussHard(r, h)
   # prints a sensible description of itself
   ppm(ants ~1, HierStraussHard(r, h))
   # fit the stationary hierarchical Strauss-hard core process to ants data
</code></pre>

<hr>
<h2 id='Hybrid'>
Hybrid Interaction Point Process Model
</h2><span id='topic+Hybrid'></span>

<h3>Description</h3>

<p>Creates an instance of a hybrid point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hybrid(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hybrid_+3A_...">...</code></td>
<td>

<p>Two or more interactions (objects of class <code>"interact"</code>)
or objects which can be converted to interactions.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>hybrid</em> (Baddeley, Turner, Mateu and Bevan, 2013)
is a point process model created by combining two or more
point process models, or an interpoint interaction created by combining
two or more interpoint interactions.
</p>
<p>The <em>hybrid</em> of two point processes, with probability densities
<code class="reqn">f(x)</code> and <code class="reqn">g(x)</code> respectively,
is the point process with probability density 
</p>
<p style="text-align: center;"><code class="reqn">h(x) = c \, f(x) \, g(x)</code>
</p>

<p>where <code class="reqn">c</code> is a normalising constant.
</p>
<p>Equivalently, the hybrid of two point processes with conditional intensities
<code class="reqn">\lambda(u,x)</code> and <code class="reqn">\kappa(u,x)</code>
is the point process with conditional intensity
</p>
<p style="text-align: center;"><code class="reqn">
    \phi(u,x) = \lambda(u,x) \, \kappa(u,x).
  </code>
</p>

<p>The hybrid of <code class="reqn">m &gt; 3</code> point processes is defined in a similar way.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a></code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of a hybrid interaction is
yielded by the function <code>Hybrid()</code>. 
</p>
<p>The arguments <code>...</code> will be interpreted as interpoint interactions
(objects of class <code>"interact"</code>) and the result will be the hybrid
of these interactions. Each argument must either be an
interpoint interaction (object of class <code>"interact"</code>),
or a point process model (object of class <code>"ppm"</code>) from which the
interpoint interaction will be extracted.
</p>
<p>The arguments <code>...</code> may also be given in the form
<code>name=value</code>. This is purely cosmetic: it can be used to attach
simple mnemonic names to the component interactions, and makes the
printed output from <code><a href="#topic+print.ppm">print.ppm</a></code> neater.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing an interpoint interaction structure.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 1&ndash;43.
<code>DOI: 10.18637/jss.v055.i11</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Hybrid(Strauss(0.1), Geyer(0.2, 3))

  Hybrid(Ha=Hardcore(0.05), St=Strauss(0.1), Ge=Geyer(0.2, 3))

  fit &lt;- ppm(redwood, ~1, Hybrid(A=Strauss(0.02), B=Geyer(0.1, 2)))
  fit

  ctr &lt;- rmhcontrol(nrep=5e4, expand=1)
  plot(simulate(fit, control=ctr))

  # hybrid components can be models (including hybrid models)
  Hybrid(fit, S=Softcore(0.5))

  # plot.fii only works if every component is a pairwise interaction
  fit2 &lt;- ppm(swedishpines, ~1, Hybrid(DG=DiggleGratton(2,10), S=Strauss(5)))
  plot(fitin(fit2))
  plot(fitin(fit2), separate=TRUE, mar.panel=rep(4,4))
</code></pre>

<hr>
<h2 id='hybrid.family'>
Hybrid Interaction Family
</h2><span id='topic+hybrid.family'></span>

<h3>Description</h3>

<p>An object describing the family of all hybrid interactions.
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes 
the family of all hybrid point process models.
</p>
<p>If you need to create a specific hybrid interaction model for use in 
modelling, use the function <code><a href="#topic+Hybrid">Hybrid</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+Hybrid">Hybrid</a></code> to make hybrid interactions.
</p>
<p>Other families: 
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>,
<code><a href="#topic+inforder.family">inforder.family</a></code>.
</p>

<hr>
<h2 id='ic.kppm'>Model selection criteria for the intensity function of a point process</h2><span id='topic+ic'></span><span id='topic+ic.ppm'></span><span id='topic+ic.kppm'></span>

<h3>Description</h3>

<p>Information criteria for selecting the intensity function model
of a Poisson, cluster or Cox point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ic(object)

  ## S3 method for class 'ppm'
ic(object)

  ## S3 method for class 'kppm'
ic(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic.kppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns information criteria for selecting the
intensity function model of a Poisson, Cox or cluster point process
fitted by first order composite likelihood
(i.e. using the Poisson likelihood function). 
</p>
<p>Degrees of freedom <code class="reqn">df</code> for the information criteria are given by
the trace of <code class="reqn">S^{-1} \Sigma</code> where <code class="reqn">S</code> is the sensitivity matrix
and <code class="reqn">\Sigma</code> is the variance matrix for the log composite
likelihood score function. In case of a Poisson process, <code class="reqn">df</code> is
the number of parameters in the model for the intensity function. 
</p>
<p>The composite Bayesian information criterion (cbic) is
<code class="reqn">-2\ell + \log(n) df</code>
where <code class="reqn">\ell</code> is the maximal log first-order composite likelihood
(Poisson loglikelihood for the intensity function) and
<code class="reqn">n</code> is the observed number of points.
It reduces to the BIC criterion in case of a Poisson process.
</p>
<p>The composite information criterion (cic) is
<code class="reqn">-2\ell + 2 df</code>
and reduces to the AIC in case of a Poisson process.
</p>
<p>NOTE: the information criteria are for selecting the intensity
function model (a set of covariates) within a given model class.
They cannot be used to choose among different types of cluster
or Cox point process models (e.g. can not be used to choose
between Thomas and LGCP models).
</p>


<h3>Value</h3>

<p>A list with entries <code>loglike</code>, <code>cbic</code>, <code>cic</code> and
<code>df</code>. 
Here <code>loglike</code> is the fitted log first-order composite likelihood,
<code>cbic</code> is composite Bayesian information criterion,
<code>cic</code> is is the composite likelihood criterion and
<code>df</code> is the adjusted degrees of freedom for the
fitted intensity function model.
</p>


<h3>Author(s)</h3>

<p>Achmad Choiruddin, Jean-Francois Coeurjolly and Rasmus Waagepetersen.
</p>


<h3>References</h3>

<p>Choiruddin, A., Coeurjolly, J.F. and Waagepetersen, R. (2020) 
Information criteria for inhomogeneous spatial point processes.
<em>Australian and New Zealand Journal of Statistics</em>.
To appear. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {

    # model with one covariate
    fit1 &lt;- kppm(bei~elev,data=bei.extra)
    ic1  &lt;- ic(fit1)

    # model with two covariates
    fit2 &lt;- kppm(bei~elev+grad,data=bei.extra)
    ic2  &lt;- ic(fit2)
  
    # smallest cbic for fit1 but smallest cic for fit2
  }
</code></pre>

<hr>
<h2 id='improve.kppm'>Improve Intensity Estimate of Fitted Cluster Point Process Model</h2><span id='topic+improve.kppm'></span>

<h3>Description</h3>

<p>Update the fitted intensity of a fitted cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve.kppm(object, type=c("quasi", "wclik1", "clik1"), rmax = NULL,
             eps.rmax = 0.01, dimyx = 50, maxIter = 100, tolerance = 1e-06,
             fast = TRUE, vcov = FALSE, fast.vcov = FALSE, verbose = FALSE,
                          save.internals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improve.kppm_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model (object of class <code>"kppm"</code>).
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_type">type</code></td>
<td>

<p>A character string indicating the method of estimation.
Current options are <code>"clik1"</code>, <code>"wclik1"</code> and <code>"quasi"</code>
for, respectively, first order composite (Poisson) likelihood,
weighted first order composite likelihood and quasi-likelihood.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The dependence range. Not usually specified by the user.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_eps.rmax">eps.rmax</code></td>
<td>

<p>Numeric. A small positive number which is used to determine <code>rmax</code>
from the tail behaviour of the pair correlation function. Namely
<code>rmax</code> is the smallest value of <code class="reqn">r</code>
at which <code class="reqn">(g(r)-1)/(g(0)-1)</code>
falls below <code>eps.rmax</code>. 
Ignored if <code>rmax</code> is provided.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_dimyx">dimyx</code></td>
<td>

<p>Pixel array dimensions. See Details.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_maxiter">maxIter</code></td>
<td>

<p>Integer. Maximum number of iterations of iterative weighted least squares
(Fisher scoring).
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_tolerance">tolerance</code></td>
<td>

<p>Numeric. Tolerance value specifying when to stop iterative weighted
least squares (Fisher scoring).
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_fast">fast</code></td>
<td>

<p>Logical value indicating whether tapering should be used to make the 
computations faster (requires the package <span class="pkg">Matrix</span>).
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_vcov">vcov</code></td>
<td>

<p>Logical value indicating whether to calculate the asymptotic variance
covariance/matrix.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_fast.vcov">fast.vcov</code></td>
<td>

<p>Logical value indicating whether tapering should be used for the
variance/covariance matrix to make the computations faster
(requires the package <span class="pkg">Matrix</span>). Caution:
This is expected to underestimate the true asymptotic variances/covariances.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_verbose">verbose</code></td>
<td>

<p>A logical indicating whether the details of computations should be printed.
</p>
</td></tr>
<tr><td><code id="improve.kppm_+3A_save.internals">save.internals</code></td>
<td>

<p>A logical indicating whether internal quantities should be saved in the
returned object (mostly for development purposes).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reestimates the intensity parameters in a fitted <code>"kppm"</code>
object. If <code>type="clik1"</code> estimates are based on the first order
composite (Poisson) likelihood, which ignores dependence between the
points. Note that <code>type="clik1"</code> is mainly included for testing
purposes and is not recommended for the typical user;
instead the more efficient <code><a href="#topic+kppm">kppm</a></code>
with <code>improve.type="none"</code> should be used.
</p>
<p>When <code>type="quasi"</code> or <code>type="wclik1"</code> the dependence
structure between the points is incorporated in the estimation
procedure by using the estimated pair correlation function in the
estimating equation.
</p>
<p>In all cases the estimating equation is based on dividing the
observation window into small subregions and count the number of points
in each subregion. To do this the observation window is first
converted into a digital mask by <code><a href="grid.html#topic+as.mask">as.mask</a></code> where the
resolution is controlled by the argument <code>dimyx</code>. The
computational time grows with the cube of the number of subregions, so fine
grids may take very long to compute (or even run out of memory).
</p>


<h3>Value</h3>

<p>A fitted cluster point process model of class <code>"kppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian <a href="mailto:jalilian@razi.ac.ir">jalilian@razi.ac.ir</a> and Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Waagepetersen, R. (2007) An estimating function approach to inference
for inhomogeneous Neyman-Scott processes, <em>Biometrics</em>,
<b>63</b>, 252-258.
</p>
<p>Guan, Y. and Shen, Y. (2010) A weighted estimating equation approach
to inference for inhomogeneous spatial point processes, <em>Biometrika</em>,
<b>97</b>, 867-880.
</p>
<p>Guan, Y., Jalilian, A. and Waagepetersen, R. (2015)
Quasi-likelihood for spatial point processes. 
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 677&ndash;697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+improve.kppm">improve.kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # fit a Thomas process using minimum contrast estimation method 
  # to model interaction between points of the pattern
  fit0 &lt;- kppm(bei ~ elev + grad, data = bei.extra)

  # fit the log-linear intensity model with quasi-likelihood method
  fit1 &lt;- improve.kppm(fit0, type="quasi")

  # compare
  coef(fit0)
  coef(fit1)
</code></pre>

<hr>
<h2 id='influence.ppm'>
Influence Measure for Spatial Point Process Model
</h2><span id='topic+influence.ppm'></span>

<h3>Description</h3>

<p>Computes the influence measure for a fitted spatial point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
influence(model, ...,
        drop = FALSE, iScore=NULL, iHessian=NULL, iArgs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence.ppm_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="influence.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="influence.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical. Whether to include (<code>drop=FALSE</code>) or
exclude (<code>drop=TRUE</code>) contributions from quadrature
points that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="influence.ppm_+3A_iscore">iScore</code>, <code id="influence.ppm_+3A_ihessian">iHessian</code></td>
<td>

<p>Components of the score vector and Hessian matrix for
the irregular parameters, if required. See Details.
</p>
</td></tr>
<tr><td><code id="influence.ppm_+3A_iargs">iArgs</code></td>
<td>

<p>List of extra arguments for the functions <code>iScore</code>,
<code>iHessian</code> if required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a fitted spatial point process model <code>model</code>,
this function computes the influence measure
described in Baddeley, Chang and Song (2013)
and Baddeley, Rubak and Turner (2019).
</p>
<p>The function <code><a href="stats.html#topic+influence">influence</a></code> is generic,
and <code>influence.ppm</code> is the method for objects of class
<code>"ppm"</code> representing point process models.
</p>
<p>The influence of a point process model is a value attached to each data point
(i.e. each point of the point pattern to which the <code>model</code>
was fitted).
The influence value <code class="reqn">s(x_i)</code> at a data point
<code class="reqn">x_i</code> represents the change in the maximised log (pseudo)likelihood
that occurs when the point <code class="reqn">x_i</code> is deleted.
A relatively large value of <code class="reqn">s(x_i)</code> indicates a 
data point with a large influence on the fitted model.
</p>
<p>If the point process model trend has irregular parameters that were
fitted (using <code><a href="#topic+ippm">ippm</a></code>)
then the influence calculation requires the first and second
derivatives of the log trend with respect to the irregular parameters. 
The argument <code>iScore</code> should be a list,
with one entry for each irregular parameter, of <span class="rlang"><b>R</b></span> functions that compute the
partial derivatives of the log trend (i.e. log intensity or
log conditional intensity) with respect to each irregular
parameter. The argument <code>iHessian</code> should be a list,
with <code class="reqn">p^2</code> entries where <code class="reqn">p</code> is the number of irregular
parameters, of <span class="rlang"><b>R</b></span> functions that compute the second order
partial derivatives of the
log trend with respect to each pair of irregular parameters.
</p>
<p>The result of <code>influence.ppm</code> is 
an object of class <code>"influence.ppm"</code>. It can be printed and plotted.
It can be converted to a marked
point pattern by <code>as.ppp</code> (see <code><a href="#topic+as.ppp.influence.ppm">as.ppp.influence.ppm</a></code>).
There are also methods for <code>[</code>,
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>, <code><a href="spatstat.geom.html#topic+domain">domain</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>, <code><a href="grDevices.html#topic+integral">integral</a></code> and <code><a href="spatstat.explore.html#topic+Smooth">Smooth</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"influence.ppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2019)
Leverage and influence diagnostics for Gibbs spatial point processes.
<em>Spatial Statistics</em> <b>29</b>, 15&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>,
<code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>,
<code><a href="#topic+ppmInfluence">ppmInfluence</a></code>,
<code><a href="#topic+plot.influence.ppm">plot.influence.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   plot(influence(fit))
</code></pre>

<hr>
<h2 id='inforder.family'>Infinite Order Interaction Family</h2><span id='topic+inforder.family'></span>

<h3>Description</h3>

<p>An object describing the family of all Gibbs point processes
with infinite interaction order.
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes the interaction structure
of Gibbs point processes which have infinite order of interaction,
such as the area-interaction process <cite><a href="#topic+AreaInter">AreaInter</a></cite>.
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AreaInter">AreaInter</a></code> to create the area interaction process
structure.
</p>
<p>Other families:
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>.
</p>

<hr>
<h2 id='integral.msr'>
Integral of a Measure
</h2><span id='topic+integral.msr'></span>

<h3>Description</h3>

<p>Computes the integral (total value) of a measure over its domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msr'
integral(f, domain=NULL, weight=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.msr_+3A_f">f</code></td>
<td>

<p>A signed measure or vector-valued measure (object of class
<code>"msr"</code>).
</p>
</td></tr>
<tr><td><code id="integral.msr_+3A_domain">domain</code></td>
<td>

<p>Optional window specifying the domain of integration.
Alternatively a tessellation.
</p>
</td></tr>
<tr><td><code id="integral.msr_+3A_weight">weight</code></td>
<td>

<p>Optional. A pixel image (object of class <code>"im"</code>)
or a <code>function(x,y)</code> giving a numerical weight
to be applied to the integration.
</p>
</td></tr>
<tr><td><code id="integral.msr_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integral (total value) of the measure over its domain is
calculated.
</p>
<p>If <code>domain</code> is a window (class <code>"owin"</code>) then the integration
will be restricted to this window. If <code>domain</code> is a tessellation
(class <code>"tess"</code>) then the integral of <code>f</code> in each
tile of <code>domain</code> will be computed.
</p>
<p>For a multitype measure <code>m</code>, use <code><a href="#topic+split.msr">split.msr</a></code>
to separate the contributions for each type of point,
as shown in the Examples.
</p>
<p>If <code>weight</code> is given, it should be a pixel image or a function of
coordinates <code class="reqn">x</code> and <code class="reqn">y</code> returning numerical values.
Then each increment of the measure
will be multiplied by the corresponding value of <code>weight</code>.
Effectively, <code>weight</code> becomes the integrand, and 
the result is the integral of <code>weight</code> with respect to the
measure <code>f</code>.
</p>


<h3>Value</h3>

<p>A numeric value, vector, or matrix.
</p>
<p><code>integral(f)</code> returns a numeric value (for a signed measure)
or a vector of values (for a vector-valued measure).
</p>
<p>If <code>domain</code> is a tessellation then <code>integral(f, domain)</code>
returns a numeric vector with one entry for each tile
(if <code>f</code> is a signed measure)
or a numeric matrix with one row for each tile
(if <code>f</code> is a vector-valued measure).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="grDevices.html#topic+integral">integral</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ x)
   rr &lt;- residuals(fit)
   integral(rr)

   # vector-valued measure
   rs &lt;- residuals(fit, type="score")
   integral(rs)

   # multitype
   fitA &lt;- ppm(amacrine ~ x)
   rrA &lt;- residuals(fitA)
   sapply(split(rrA), integral)

   # multitype and vector-valued
   rsA &lt;- residuals(fitA, type="score")
   sapply(split(rsA), integral)

   ## integral over a subregion
   integral(rr, domain=square(0.5))
   ## integrals over the tiles of a tessellation
   integral(rr, domain=quadrats(cells, 2))

   ## weighted integral
   integral(rr, weight=function(x,y){y})
</code></pre>

<hr>
<h2 id='intensity.dppm'>Intensity of Determinantal Point Process Model</h2><span id='topic+intensity.dppm'></span><span id='topic+intensity.detpointprocfamily'></span>

<h3>Description</h3>

<p>Extracts the intensity of a determinantal point process model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'detpointprocfamily'
intensity(X, ...)

  ## S3 method for class 'dppm'
intensity(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.dppm_+3A_x">X</code></td>
<td>

<p>A determinantal point process model (object of class
<code>"detpointprocfamily"</code> or <code>"dppm"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.dppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value (if the model is stationary), a pixel image
(if the model is non-stationary) or <code>NA</code> if the intensity is
unknown for the model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>

<hr>
<h2 id='intensity.ppm'>
Intensity of Fitted Point Process Model
</h2><span id='topic+intensity.ppm'></span>

<h3>Description</h3>

<p>Computes the intensity of a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppm'
intensity(X, ..., approx=c("Poisson", "DPP"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.ppm_+3A_x">X</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+predict.ppm">predict.ppm</a></code> in some cases.
See Details.
</p>
</td></tr>
<tr><td><code id="intensity.ppm_+3A_approx">approx</code></td>
<td>

<p>Character string (partially matched) specifying the type of
approximation to the intensity for a non-Poisson model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>
for fitted point process models (class <code>"ppm"</code>).
</p>
<p>The intensity of a point process model is the expected
number of random points per unit area. 
</p>
<p>If <code>X</code> is a Poisson point process model, the intensity of the
process is computed exactly.
The result is a numerical value if <code>X</code>
is a stationary Poisson point process, and a pixel image if <code>X</code>
is non-stationary. (In the latter case, the resolution of the pixel
image is controlled by the arguments <code>...</code> which are passed
to <code><a href="#topic+predict.ppm">predict.ppm</a></code>.)
</p>
<p>If <code>X</code> is a Gibbs point process model that is not a Poisson model,
the intensity is computed approximately:
</p>

<ul>
<li><p> if <code>approx="Poisson"</code> (the default),
the intensity is computed  using the Poisson-saddlepoint approximation
(Baddeley and Nair, 2012a, 2012b, 2017; Anderssen et al, 2014).
This approximation is currently available for pairwise-interaction
models (Baddeley and Nair, 2012a, 2012b)
and for the area-interaction model and Geyer saturation model
(Baddeley and Nair, 2017).
</p>
<p>If the model is non-stationary. the pseudostationary solution
(Baddeley and Nair, 2012b; Anderssen et al, 2014) is used.
The result is a pixel image,
whose resolution is controlled by the arguments <code>...</code>
which are passed to <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>
</li>
<li><p> if <code>approx="DPP"</code>, the intensity is calculated using
the approximation of (Coeurjolly and Lavancier, 2018) based on a
determinantal point process. This approximation is more accurate
than the Poisson saddlepoint approximation, for inhibitory
interactions. However the DPP approximation is only available
for stationary pairwise interaction models.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric value (if the model is stationary)
or a pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Gopalan Nair, and Frederic Lavancier.
</p>


<h3>References</h3>

<p>Anderssen, R.S., Baddeley, A., DeHoog, F.R. and Nair, G.M. (2014)
Solution of an integral equation arising in spatial point process theory.
<em>Journal of Integral Equations and Applications</em> 
<b>26</b> (4) 437&ndash;453.
</p>
<p>Baddeley, A. and Nair, G. (2012a) 
Fast approximation of the intensity of Gibbs point processes.
<em>Electronic Journal of Statistics</em> <b>6</b> 1155&ndash;1169.
</p>
<p>Baddeley, A. and Nair, G. (2012b)
Approximating the moments of a spatial point process.
<em>Stat</em> <b>1</b>, 1, 18&ndash;30.
<code>DOI: 10.1002/sta4.5</code>
</p>
<p>Baddeley, A. and Nair, G. (2017)
Poisson-saddlepoint approximation for Gibbs point
processes with infinite-order interaction: in memory
of Peter Hall.
<em>Journal of Applied Probability</em> <b>54</b>, 4, 1008&ndash;1026.
</p>
<p>Coeurjolly, J.-F. and Lavancier, F. (2018)
Approximation intensity for pairwise interaction Gibbs point processes
using determinantal point processes.
<em>Electronic Journal of Statistics</em> <b>12</b> 3181&ndash;3203.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>,
<code><a href="spatstat.geom.html#topic+intensity.ppp">intensity.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fitP &lt;- ppm(swedishpines ~ 1)
  intensity(fitP)
  fitS &lt;- ppm(swedishpines ~ 1, Strauss(9))
  intensity(fitS)
  intensity(fitS, approx="D")
  fitSx &lt;- ppm(swedishpines ~ x, Strauss(9))
  lamSx &lt;- intensity(fitSx)
  fitG &lt;- ppm(swedishpines ~ 1, Geyer(9, 1))
  lamG &lt;- intensity(fitG)
  fitA &lt;- ppm(swedishpines ~ 1, AreaInter(7))
  lamA &lt;- intensity(fitA)
</code></pre>

<hr>
<h2 id='intensity.slrm'>
Intensity of Fitted Spatial Logistic Regression Model
</h2><span id='topic+intensity.slrm'></span>

<h3>Description</h3>

<p>Computes the intensity of a fitted spatial logistic regression model,
treated as a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slrm'
intensity(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.slrm_+3A_x">X</code></td>
<td>

<p>A fitted spatial logistic regression model (object of class <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.slrm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+predict.slrm">predict.slrm</a></code> in some cases.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>
for spatial logistic regression models (class <code>"slrm"</code>).
</p>
<p>The fitted spatial logistic regression model <code>X</code> is interpreted
as a point process model. The intensity of a point process model is
defined as the expected number of random points per unit area. The
fitted probabilities of presence according to <code>X</code> are converted
to intensity values.
</p>
<p>The result is a numerical value if <code>X</code>
is stationary, and a pixel image if <code>X</code>
is non-stationary. In the latter case, the resolution of the pixel
image is controlled by the arguments <code>...</code> which are passed
to <code><a href="#topic+predict.slrm">predict.slrm</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value (if the model is stationary)
or a pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Berman, M., Fisher, N.I., Hardegen, A., Milne, R.K.,
Schuhmacher, D., Shah, R. and Turner, R. (2010)
Spatial logistic regression and change-of-support
for spatial Poisson point processes.
<em>Electronic Journal of Statistics</em>
<b>4</b>, 1151&ndash;1201.
<code>DOI: 10.1214/10-EJS581</code>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>,
<code><a href="#topic+intensity.ppm">intensity.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fitS &lt;- slrm(swedishpines ~ 1)
  intensity(fitS)
  fitX &lt;- slrm(swedishpines ~ x)
  intensity(fitX)
</code></pre>

<hr>
<h2 id='interactionorder'>
Determine the Order of Interpoint Interaction in a Model
</h2><span id='topic+interactionorder'></span><span id='topic+interactionorder.isf'></span><span id='topic+interactionorder.interact'></span><span id='topic+interactionorder.fii'></span><span id='topic+interactionorder.ppm'></span>

<h3>Description</h3>

<p>Given a point process model, report
the order of interpoint interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactionorder(object)

## S3 method for class 'ppm'
interactionorder(object)

## S3 method for class 'interact'
interactionorder(object)

## S3 method for class 'isf'
interactionorder(object)

## S3 method for class 'fii'
interactionorder(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactionorder_+3A_object">object</code></td>
<td>

<p>A point process model (class <code>"ppm"</code>)
or similar information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the order of interpoint interaction
in a Gibbs point process model (or a related object).
</p>
<p>The interaction order is defined as the largest number <code>k</code> such
that the probability density of the model contains terms involving <code>k</code> points at a time.
For example, in a pairwise interaction
process such as the Strauss process, the probability density contains
interaction terms between each pair of points, but does not contain
any terms that involve three points at a time, so the interaction order is 2.
</p>
<p>Poisson point processes have interaction order 1.
Pairwise-interaction processes have interaction order 2.
Point processes with the triplet interaction <code><a href="#topic+Triplets">Triplets</a></code>
have interaction order 3. The Geyer saturation model
<code><a href="#topic+Geyer">Geyer</a></code> and the area-interaction model
<code><a href="#topic+AreaInter">AreaInter</a></code> have infinite order of interaction.
</p>


<h3>Value</h3>

<p>A positive integer, or <code>Inf</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  interactionorder(ppm(cells ~ 1))
  interactionorder(Strauss(0.1))
  interactionorder(Triplets(0.1))
  interactionorder(Geyer(0.1, 2))
  interactionorder(Hybrid(Strauss(0.1), Triplets(0.2)))
</code></pre>

<hr>
<h2 id='ippm'>
Fit Point Process Model Involving Irregular Trend Parameters
</h2><span id='topic+ippm'></span>

<h3>Description</h3>

<p>Experimental extension to <code>ppm</code>
which finds optimal values of the irregular trend parameters in a
point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ippm(Q, ...,
          iScore=NULL,
          start=list(),
          covfunargs=start,
          nlm.args=list(stepmax=1/2),
          silent=FALSE,
          warn.unused=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ippm_+3A_q">Q</code>, <code id="ippm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit the point process model.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_iscore">iScore</code></td>
<td>

<p>Optional. A named list of <span class="rlang"><b>R</b></span> functions that compute the partial derivatives
of the logarithm of the trend, with respect to each irregular parameter.
See Details.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_start">start</code></td>
<td>

<p>Named list containing initial values of the
irregular parameters over which to optimise.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_covfunargs">covfunargs</code></td>
<td>

<p>Argument passed to <code><a href="#topic+ppm">ppm</a></code>.
A named list containing values for <em>all</em> irregular parameters
required by the covariates in the model.
Must include all the parameters named in <code>start</code>.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_nlm.args">nlm.args</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="stats.html#topic+nlm">nlm</a></code>
to control the optimization algorithm.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_silent">silent</code></td>
<td>

<p>Logical. Whether to print warnings if the optimization algorithm
fails to converge.
</p>
</td></tr>
<tr><td><code id="ippm_+3A_warn.unused">warn.unused</code></td>
<td>

<p>Logical. Whether to print a warning if some of the parameters
in <code>start</code> are not used in the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an experimental extension to the
point process model fitting command <code><a href="#topic+ppm">ppm</a></code>.
The extension allows the trend of the model to include irregular parameters,
which will be maximised by a Newton-type iterative
method, using <code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>
<p>For the sake of explanation,
consider a Poisson point process with intensity function
<code class="reqn">\lambda(u)</code> at location <code class="reqn">u</code>. Assume that
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u) = \exp(\alpha + \beta Z(u)) \, f(u, \gamma)
  </code>
</p>

<p>where <code class="reqn">\alpha,\beta,\gamma</code> are
parameters to be estimated, <code class="reqn">Z(u)</code> is a spatial covariate
function, and <code class="reqn">f</code> is some known function.
Then the parameters
<code class="reqn">\alpha,\beta</code> are called <em>regular</em> because they
appear in a loglinear form; the parameter 
<code class="reqn">\gamma</code> is called <em>irregular</em>.
</p>
<p>To fit this model using <code>ippm</code>, we specify the
intensity using the <code>trend</code> formula
in the same way as usual for <code><a href="#topic+ppm">ppm</a></code>.
The trend formula is a representation of the log intensity.
In the above example the log intensity is
</p>
<p style="text-align: center;"><code class="reqn">
    \log\lambda(u) = \alpha + \beta Z(u) + \log f(u, \gamma)
  </code>
</p>

<p>So the model above would be encoded with the trend formula
<code>~Z + offset(log(f))</code>. Note that the irregular part of the model
is an <em>offset</em> term, which means that it is included in the log trend
as it is, without being multiplied by another regular parameter.
</p>
<p>The optimisation runs faster if we specify the derivative
of <code class="reqn">\log f(u,\gamma)</code> with
respect to <code class="reqn">\gamma</code>. We call this the
<em>irregular score</em>. To specify this, the user must write an <span class="rlang"><b>R</b></span> function
that computes the irregular score for any value of
<code class="reqn">\gamma</code> at any location <code>(x,y)</code>.
</p>
<p>Thus, to code such a problem,
</p>

<ol>
<li><p> The argument <code>trend</code> should define the
log intensity, with the irregular part as an offset;
</p>
</li>
<li><p> The argument <code>start</code> should be a list
containing initial values of each of the irregular parameters;
</p>
</li>
<li><p> The argument <code>iScore</code>, if provided,
must be a list (with one entry
for each entry of <code>start</code>) of functions
with arguments <code>x,y,...</code>, that evaluate the partial derivatives
of <code class="reqn">\log f(u,\gamma)</code> with
respect to each irregular parameter.
</p>
</li></ol>

<p>The coded example below illustrates the model with two irregular
parameters <code class="reqn">\gamma,\delta</code> and irregular term
</p>
<p style="text-align: center;"><code class="reqn">
    f((x,y), (\gamma, \delta)) = 1 + \exp(\gamma - \delta x^3)
  </code>
</p>

<p>Arguments <code>...</code> passed to <code><a href="#topic+ppm">ppm</a></code> may
also include <code>interaction</code>. In this case the model is not
a Poisson point process but a more general Gibbs point process;
the trend formula <code>trend</code> 
determines the first-order trend
of the model (the first order component of the conditional intensity),
not the intensity.
</p>


<h3>Value</h3>

<p>A fitted point process model (object of class <code>"ppm"</code>)
which also belongs to the special class <code>"ippm"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+profilepl">profilepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nd &lt;- 32
  
  
  gamma0 &lt;- 3
  delta0 &lt;- 5
  POW &lt;- 3
  # Terms in intensity
  Z &lt;- function(x,y) { -2*y }
  f &lt;- function(x,y,gamma,delta) { 1 + exp(gamma - delta * x^POW) }
  # True intensity
  lamb &lt;- function(x,y,gamma,delta) { 200 * exp(Z(x,y)) * f(x,y,gamma,delta) }
  # Simulate realisation
  lmax &lt;- max(lamb(0,0,gamma0,delta0), lamb(1,1,gamma0,delta0))
  set.seed(42)
  X &lt;- rpoispp(lamb, lmax=lmax, win=owin(), gamma=gamma0, delta=delta0)
  # Partial derivatives of log f
  DlogfDgamma &lt;- function(x,y, gamma, delta) {
    topbit &lt;- exp(gamma - delta * x^POW)
    topbit/(1 + topbit)
  }
  DlogfDdelta &lt;- function(x,y, gamma, delta) {
    topbit &lt;- exp(gamma - delta * x^POW)
    - (x^POW) * topbit/(1 + topbit)
  }
  # irregular score
  Dlogf &lt;- list(gamma=DlogfDgamma, delta=DlogfDdelta)
  # fit model
  ippm(X ~Z + offset(log(f)),
       covariates=list(Z=Z, f=f),
       iScore=Dlogf,
       start=list(gamma=1, delta=1),
       nlm.args=list(stepmax=1),
       nd=nd)
</code></pre>

<hr>
<h2 id='is.dppm'>Recognise Fitted Determinantal Point Process Models</h2><span id='topic+is.dppm'></span>

<h3>Description</h3>

<p>Check that an object inherits the class dppm</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dppm(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dppm_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single logical value.</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='is.hybrid'>
Test Whether Object is a Hybrid
</h2><span id='topic+is.hybrid'></span><span id='topic+is.hybrid.ppm'></span><span id='topic+is.hybrid.interact'></span>

<h3>Description</h3>

<p>Tests where a point process model or point process interaction
is a hybrid of several interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hybrid(x)

## S3 method for class 'ppm'
is.hybrid(x)

## S3 method for class 'interact'
is.hybrid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.hybrid_+3A_x">x</code></td>
<td>

<p>A point process model (object of class <code>"ppm"</code>)
or a point process interaction structure
(object of class <code>"interact"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>hybrid</em> (Baddeley, Turner, Mateu and Bevan, 2012)
is a point process model created by combining two or more
point process models, or an interpoint interaction created by combining
two or more interpoint interactions.
</p>
<p>The function <code>is.hybrid</code> is generic, with methods for
point process models (objects of class <code>"ppm"</code>)
and point process interactions
(objects of class <code>"interact"</code>).
These functions return <code>TRUE</code> if the object <code>x</code> is a hybrid,
and <code>FALSE</code> if it is not a hybrid.
</p>
<p>Hybrids of two or more interpoint interactions
are created by the function <code><a href="#topic+Hybrid">Hybrid</a></code>.
Such a hybrid interaction can then be fitted to point pattern data
using <code><a href="#topic+ppm">ppm</a></code>. 
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the object is a hybrid, and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Mateu, J. and Bevan, A. (2013)
Hybrids of Gibbs point process models and their implementation.
<em>Journal of Statistical Software</em> <b>55</b>:11, 1&ndash;43.
<code>DOI: 10.18637/jss.v055.i11</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hybrid">Hybrid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  S &lt;- Strauss(0.1)
  is.hybrid(S)
  H &lt;- Hybrid(Strauss(0.1), Geyer(0.2, 3))
  is.hybrid(H)

  fit &lt;- ppm(redwood, ~1, H)
  is.hybrid(fit)
</code></pre>

<hr>
<h2 id='is.marked.ppm'>Test Whether A Point Process Model is Marked</h2><span id='topic+is.marked.ppm'></span>

<h3>Description</h3>

<p>Tests whether a fitted point process model involves &ldquo;marks&rdquo;
attached to the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
is.marked(X, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marked.ppm_+3A_x">X</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>)
usually obtained from <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="is.marked.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset contains
the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
</p>
<p>The argument <code>X</code> is a fitted point process model
(an object of class <code>"ppm"</code>) typically obtained
by fitting a model to point pattern data using <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>This function returns <code>TRUE</code> if the <em>original data</em>
(to which the model <code>X</code> was fitted) were a marked point pattern.
</p>
<p>Note that this is not the same as testing whether the
model involves terms that depend on the marks (i.e. whether the
fitted model ignores the marks in the data).
See the Examples for a trick to do this.
</p>
<p>If this function returns <code>TRUE</code>, the implications are
(for example) that
any simulation of this model will require simulation of random marks
as well as random point locations.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if
<code>X</code> is a model that was fitted to a marked point pattern dataset.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.marked">is.marked</a></code>,
<code><a href="spatstat.geom.html#topic+is.marked.ppp">is.marked.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- lansing
   # Multitype point pattern --- trees marked by species

   

  fit1 &lt;- ppm(X, ~ marks, Poisson())
  is.marked(fit1)

  fit2 &lt;- ppm(X, ~ 1, Poisson())
  is.marked(fit2)

  ## test whether the model formula involves marks
  "marks" %in% spatstat.utils::variablesinformula(formula(fit2))

  # Unmarked point pattern
  fit3 &lt;- ppm(cells, ~ 1, Poisson())
  is.marked(fit3)
  # FALSE
</code></pre>

<hr>
<h2 id='is.multitype.ppm'>Test Whether A Point Process Model is Multitype</h2><span id='topic+is.multitype.ppm'></span>

<h3>Description</h3>

<p>Tests whether a fitted point process model involves &ldquo;marks&rdquo;
attached to the points that classify the points into several types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
is.multitype(X, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multitype.ppm_+3A_x">X</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>)
usually obtained from <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="is.multitype.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+longleaf">longleaf</a></code> dataset
contains the locations of trees, each tree being marked by its diameter;
the <code><a href="spatstat.data.html#topic+amacrine">amacrine</a></code> dataset gives the locations of cells
of two types (on/off) and the type of cell may be regarded as a mark attached
to the location of the cell.
</p>
<p>The argument <code>X</code> is a fitted point process model
(an object of class <code>"ppm"</code>) typically obtained
by fitting a model to point pattern data using <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>This function returns <code>TRUE</code> if the <em>original data</em>
(to which the model <code>X</code> was fitted) were a multitype point pattern.
</p>
<p>Note that this is not the same as testing whether the
model involves terms that depend on the marks (i.e. whether the
fitted model ignores the marks in the data).
Currently we have not implemented a test for this.
</p>
<p>If this function returns <code>TRUE</code>, the implications are
(for example) that
any simulation of this model will require simulation of random marks
as well as random point locations.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if
<code>X</code> is a model that was fitted to a multitype point pattern dataset.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.multitype">is.multitype</a></code>,
<code><a href="spatstat.geom.html#topic+is.multitype.ppp">is.multitype.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- lansing
   # Multitype point pattern --- trees marked by species

   

  fit1 &lt;- ppm(X, ~ marks, Poisson())
  is.multitype(fit1)
  # TRUE

  fit2 &lt;- ppm(X, ~ 1, Poisson())
  is.multitype(fit2)
  # TRUE

  # Unmarked point pattern
  fit3 &lt;- ppm(cells, ~ 1, Poisson())
  is.multitype(fit3)
  # FALSE

</code></pre>

<hr>
<h2 id='is.poissonclusterprocess'>
Recognise Poisson Cluster Process Models
</h2><span id='topic+is.poissonclusterprocess'></span><span id='topic+is.poissonclusterprocess.kppm'></span><span id='topic+is.poissonclusterprocess.zclustermodel'></span><span id='topic+is.poissonclusterprocess.default'></span>

<h3>Description</h3>

<p>Given a point process model (either a model that has been fitted to
data, or a model specified by its parameters), 
determine whether the model is a Poisson cluster process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.poissonclusterprocess(model)
## S3 method for class 'kppm'
is.poissonclusterprocess(model)
## S3 method for class 'zclustermodel'
is.poissonclusterprocess(model)
## Default S3 method:
is.poissonclusterprocess(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.poissonclusterprocess_+3A_model">model</code></td>
<td>

<p>Any kind of object representing a spatial point process model,
either a model fitted to data, or a specification of a point process model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>model</code> represents a fitted spatial point process
model (such as an object of class <code>"ppm"</code>, <code>"kppm"</code> or
similar) or a specification of a point process model
(such as an object of class <code>"zclustermodel"</code>).
</p>
<p>This function returns <code>TRUE</code> if the <code>model</code> is a Poisson cluster
process, and <code>FALSE</code> otherwise.
</p>
<p>The function <code>is.poissonclusterprocess</code> is generic, with methods
for classes <code>kppm</code> and <code>zclustermodel</code>, and a default
method. 
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>, <code><a href="#topic+zclustermodel">zclustermodel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fut &lt;- kppm(redwood ~ 1, "Thomas")
  is.poissonclusterprocess(fut)
  fot &lt;- slrm(cells ~ x, dimyx=16)
  is.poissonclusterprocess(fot)
</code></pre>

<hr>
<h2 id='is.ppm'>Test Whether An Object Is A Fitted Point Process Model</h2><span id='topic+is.ppm'></span><span id='topic+is.lppm'></span><span id='topic+is.kppm'></span><span id='topic+is.slrm'></span>

<h3>Description</h3>

<p>Checks whether its argument is a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, 
<code>"lppm"</code>
or <code>"slrm"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ppm(x)
is.kppm(x)
is.lppm(x)
is.slrm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ppm_+3A_x">x</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions test whether the object <code>x</code>
is a fitted point process model object of the specified class.
</p>
<p>The result of <code>is.ppm(x)</code> is <code>TRUE</code> if <code>x</code>
has <code>"ppm"</code> amongst its classes, and 
otherwise <code>FALSE</code>. Similarly for the other functions.
</p>


<h3>Value</h3>

<p>A single logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='is.stationary.ppm'>
Recognise Stationary and Poisson Point Process Models
</h2><span id='topic+is.stationary.ppm'></span><span id='topic+is.stationary.kppm'></span><span id='topic+is.stationary.slrm'></span><span id='topic+is.stationary.dppm'></span><span id='topic+is.stationary.detpointprocfamily'></span><span id='topic+is.poisson.ppm'></span><span id='topic+is.poisson.kppm'></span><span id='topic+is.poisson.slrm'></span><span id='topic+is.poisson.interact'></span>

<h3>Description</h3>

<p>Given a point process model (either a model that has been fitted to
data, or a model specified by its parameters), 
determine whether the model is a stationary point process,
and whether it is a Poisson point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
is.stationary(x)
## S3 method for class 'kppm'
is.stationary(x)
## S3 method for class 'slrm'
is.stationary(x)
## S3 method for class 'dppm'
is.stationary(x)
## S3 method for class 'detpointprocfamily'
is.stationary(x)

## S3 method for class 'ppm'
is.poisson(x)
## S3 method for class 'kppm'
is.poisson(x)
## S3 method for class 'slrm'
is.poisson(x)
## S3 method for class 'interact'
is.poisson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stationary.ppm_+3A_x">x</code></td>
<td>

<p>A fitted spatial point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>,
<code>"lppm"</code>, <code>"dppm"</code> or <code>"slrm"</code>)
or a specification of a Gibbs point process model
(object of class <code>"rmhmodel"</code>)
or a similar object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> represents a fitted spatial point process model
or a similar object.
</p>
<p><code>is.stationary(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a stationary point process, and <code>FALSE</code> if not.
</p>
<p><code>is.poisson(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a Poisson point process, and <code>FALSE</code> if not.
</p>
<p>The functions <code>is.stationary</code> and <code>is.poisson</code> are generic,
with methods for the classes <code>"ppm"</code> (Gibbs point process models),
<code>"kppm"</code> (cluster or Cox point process models),
<code>"slrm"</code> (spatial logistic regression models) and
<code>"rmhmodel"</code> (model specifications for the
Metropolis-Hastings algorithm).
Additionally <code>is.stationary</code> has a method for
classes <code>"detpointprocfamily"</code> and <code>"dppm"</code>
(both determinantal point processes) and
<code>is.poisson</code> has a method for 
class <code>"interact"</code> (interaction structures for Gibbs models). 
</p>
<p><code>is.poisson.kppm</code> will return <code>FALSE</code>, unless
the model <code>x</code> is degenerate:
either <code>x</code> has zero intensity so that its realisations are empty
with probability 1, or it is a log-Gaussian Cox process
where the log intensity has zero variance.
</p>
<p><code>is.poisson.slrm</code> will always return <code>TRUE</code>,
by convention.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.marked">is.marked</a></code> to determine whether a model is a marked
point process. 
</p>
<p><code><a href="#topic+summary.ppm">summary.ppm</a></code> for detailed information about a
fitted model.
</p>
<p>Model-fitting functions 
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+slrm">slrm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ x)
  is.stationary(fit)
  is.poisson(fit)

  fut &lt;- kppm(redwood ~ 1, "MatClust")
  is.stationary(fut)
  is.poisson(fut)

  fot &lt;- slrm(cells ~ x)
  is.stationary(fot)
  is.poisson(fot)

</code></pre>

<hr>
<h2 id='isf.object'>Interaction Structure Family Objects</h2><span id='topic+isf.object'></span>

<h3>Description</h3>

<p>Objects of class <code>"isf"</code> are used internally by the
<span class="pkg">spatstat</span> package to represent the structure
of the interpoint interactions in a family of point process models.
</p>


<h3>Details</h3>

<p><em>Advanced Use Only!</em>
</p>
<p>An object of class <code>"isf"</code> (Interaction Structure Family)
is used internally by the <span class="pkg">spatstat</span> package to
represent the common mathematical and algorithmic structure of
the interpoint interactions in a family of point process models.
</p>
<p>The existing objects of class <code>"isf"</code> are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairwise.family">pairwise.family</a></code> </td><td style="text-align: left;">
    pairwise interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+triplet.family">triplet.family</a></code> </td><td style="text-align: left;">
    triplet interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairsat.family">pairsat.family</a></code> </td><td style="text-align: left;">
    saturated pairwise interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hierpair.family">hierpair.family</a></code> </td><td style="text-align: left;">
    hierarchical pairwise interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+inforder.family">inforder.family</a></code> </td><td style="text-align: left;">
    infinite order interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hybrid.family">hybrid.family</a></code> </td><td style="text-align: left;">
    hybrids of several interactions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ord.family">ord.family</a></code> </td><td style="text-align: left;"> Ord interactions </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The information contained in these objects enables the
<span class="pkg">spatstat</span> package to select the appropriate algorithm
for fitting, predicting and simulating each point process model.
</p>
<p>For example, in order to fit a model that involves pairwise
interactions, the model-fitting function <code><a href="#topic+ppm">ppm</a></code> would use
information contained in <code><a href="#topic+pairwise.family">pairwise.family</a></code> to select the
appropriate algorithms.
</p>
<p>An object of class <code>"isf"</code> is essentially a list of functions
for various tasks.
The internal format is undocumented and may be changed
without notice.
</p>


<h3>Value</h3>

<p>An object of class <code>"isf"</code>, essentially a list of functions
for various tasks.
</p>
<p>The internal format is undocumented and may be changed
without notice.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.</p>

<hr>
<h2 id='Kcom'>
Model Compensator of K Function
</h2><span id='topic+Kcom'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the <em>compensator</em> 
of the <code class="reqn">K</code> function based on the fitted model 
(as well as the usual nonparametric estimates
of <code class="reqn">K</code> based on the data alone).
Comparison between the nonparametric and model-compensated <code class="reqn">K</code>
functions serves as a diagnostic for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kcom(object, r = NULL, breaks = NULL, ...,
     correction = c("border", "isotropic", "translate"),
     conditional = !is.poisson(object),
     restrict = FALSE,
     model = NULL,
     trend = ~1, interaction = Poisson(), rbord = reach(interaction),
     compute.var = TRUE,
     truecoef = NULL, hi.res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kcom_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>)
or a point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
function <code class="reqn">K(r)</code> should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for advanced use only.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_correction">correction</code></td>
<td>

<p>Optional vector of character strings specifying the edge
correction(s) to be used. See <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> for options.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_conditional">conditional</code></td>
<td>

<p>Optional. Logical value indicating whether to 
compute the estimates for the conditional case. See Details.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_restrict">restrict</code></td>
<td>

<p>Logical value indicating
whether to compute the restriction estimator (<code>restrict=TRUE</code>) or
the reweighting estimator (<code>restrict=FALSE</code>, the default).
Applies only if <code>conditional=TRUE</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_model">model</code></td>
<td>

<p>Optional. A fitted point process model (object of
class <code>"ppm"</code>) to be re-fitted to the data
using <code><a href="#topic+update.ppm">update.ppm</a></code>, if <code>object</code> is a point pattern.
Overrides the arguments <code>trend,interaction,rbord</code>.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_trend">trend</code>, <code id="Kcom_+3A_interaction">interaction</code>, <code id="Kcom_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern.
See <code><a href="#topic+ppm">ppm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_compute.var">compute.var</code></td>
<td>

<p>Logical value indicating whether to compute the
Poincare variance bound for the residual <code class="reqn">K</code> function
(calculation is only implemented for the isotropic correction).
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_truecoef">truecoef</code></td>
<td>

<p>Optional. Numeric vector. If present, this will be treated as 
if it were the true coefficient vector of the point process model,
in calculating the diagnostic. Incompatible with <code>hi.res</code>.
</p>
</td></tr>
<tr><td><code id="Kcom_+3A_hi.res">hi.res</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
If this argument is present, the model will be
re-fitted at high resolution as specified by these parameters.
The coefficients
of the resulting fitted model will be taken as the true coefficients.
Then the diagnostic will be computed for the default
quadrature scheme, but using the high resolution coefficients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command provides a diagnostic for the goodness-of-fit of
a point process model fitted to a point pattern dataset.
It computes an estimate of the <code class="reqn">K</code> function of the
dataset, together with a <em>model compensator</em> of the
<code class="reqn">K</code> function, which should be approximately equal if the model is a good
fit to the data.
</p>
<p>The first argument, <code>object</code>, is usually a fitted point process model
(object of class <code>"ppm"</code>), obtained from the
model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>For convenience, <code>object</code> can also be a point pattern
(object of class <code>"ppp"</code>). In that case, a point process
model will be fitted to it, by calling <code><a href="#topic+ppm">ppm</a></code> using the arguments
<code>trend</code> (for the first order trend),
<code>interaction</code> (for the interpoint interaction)
and <code>rbord</code> (for the erosion distance in the border correction
for the pseudolikelihood). See <code><a href="#topic+ppm">ppm</a></code> for details
of these arguments.
</p>
<p>The algorithm first extracts the original point pattern dataset
(to which the model was fitted) and computes the 
standard nonparametric estimates of the <code class="reqn">K</code> function.
It then also computes the <em>model compensator</em> of the
<code class="reqn">K</code> function. The different function estimates are returned
as columns in a data frame (of class <code>"fv"</code>).
</p>
<p>The argument <code>correction</code> determines the edge correction(s)
to be applied. See <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> for explanation of the principle
of edge corrections. The following table gives the options
for the <code>correction</code> argument, and the corresponding
column names in the result:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>correction</code> </td><td style="text-align: left;">
    <b>description of correction</b> </td><td style="text-align: left;">
    <b>nonparametric</b> </td><td style="text-align: left;"> <b>compensator</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"isotropic"</code> </td><td style="text-align: left;"> Ripley isotropic correction
    </td><td style="text-align: left;"> <code>iso</code> </td><td style="text-align: left;"> <code>icom</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"translate"</code> </td><td style="text-align: left;"> Ohser-Stoyan translation correction
    </td><td style="text-align: left;"> <code>trans</code> </td><td style="text-align: left;"> <code>tcom</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"border"</code> </td><td style="text-align: left;"> border correction
    </td><td style="text-align: left;"> <code>border</code> </td><td style="text-align: left;"> <code>bcom</code>
  </td>
</tr>

</table>

<p>The nonparametric estimates can all be expressed in the form
</p>
<p style="text-align: center;"><code class="reqn">
    \hat K(r) = \sum_i \sum_{j &lt; i} e(x_i,x_j,r,x) I\{ d(x_i,x_j) \le r \}
  </code>
</p>

<p>where <code class="reqn">x_i</code> is the <code class="reqn">i</code>-th data point,
<code class="reqn">d(x_i,x_j)</code> is the distance between <code class="reqn">x_i</code> and
<code class="reqn">x_j</code>, and <code class="reqn">e(x_i,x_j,r,x)</code> is
a term that serves to correct edge effects and to re-normalise the
sum. The corresponding model compensator is
</p>
<p style="text-align: center;"><code class="reqn">
    {\bf C} \, \tilde K(r) = \int_W \lambda(u,x) \sum_j e(u,x_j,r,x \cup u) I\{ d(u,x_j) \le r\}
  </code>
</p>

<p>where the integral is over all locations <code class="reqn">u</code> in
the observation window, 
<code class="reqn">\lambda(u,x)</code> denotes the conditional intensity
of the model at the location <code class="reqn">u</code>, and <code class="reqn">x \cup u</code> denotes the
data point pattern <code class="reqn">x</code> augmented by adding the extra point <code class="reqn">u</code>.
</p>
<p>If the fitted model is a Poisson point process, then the formulae above
are exactly what is computed. If the fitted model is not Poisson, the 
formulae above are modified slightly to handle edge effects.
</p>
<p>The modification is determined by the arguments
<code>conditional</code> and <code>restrict</code>.
The value of <code>conditional</code> defaults to <code>FALSE</code> for Poisson models
and <code>TRUE</code> for non-Poisson models.
If <code>conditional=FALSE</code> then the formulae above are not modified.
If <code>conditional=TRUE</code>, then the algorithm calculates
the <em>restriction estimator</em> if <code>restrict=TRUE</code>,
and calculates the <em>reweighting estimator</em> if <code>restrict=FALSE</code>.
See Appendix D of Baddeley, Rubak and Moller (2011).
Thus, by default, the reweighting estimator is computed
for non-Poisson models.
</p>
<p>The nonparametric estimates of <code class="reqn">K(r)</code> are approximately unbiased
estimates of the <code class="reqn">K</code>-function, assuming the point process is
stationary. The model compensators are unbiased estimates
<em>of the mean values of the corresponding nonparametric estimates</em>,
assuming the model is true. Thus, if the model is a good fit, the mean value
of the difference between the nonparametric estimates and model compensators
is approximately zero.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Related functions: 
<code><a href="#topic+Kres">Kres</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>.
</p>
<p>Alternative functions:
<code><a href="#topic+Gcom">Gcom</a></code>,
<code><a href="#topic+psstG">psstG</a></code>, <code><a href="#topic+psstA">psstA</a></code>,  <code><a href="#topic+psst">psst</a></code>.
</p>
<p>Point process models: <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit0 &lt;- ppm(cells, ~1) # uniform Poisson
    

    if(interactive()) {
      plot(Kcom(fit0))
# compare the isotropic-correction estimates
      plot(Kcom(fit0), cbind(iso, icom) ~ r)
# uniform Poisson is clearly not correct
    }

    fit1 &lt;- ppm(cells, ~1, Strauss(0.08))
    
    K1 &lt;- Kcom(fit1)
    K1
    if(interactive()) {
      plot(K1)
      plot(K1, cbind(iso, icom) ~ r)
      plot(K1, cbind(trans, tcom) ~ r)
# how to plot the difference between nonparametric estimates and compensators
      plot(K1, iso - icom ~ r)
# fit looks approximately OK; try adjusting interaction distance
    }
    fit2 &lt;- ppm(cells, ~1, Strauss(0.12))
    
    K2 &lt;- Kcom(fit2)
    if(interactive()) {
      plot(K2)
      plot(K2, cbind(iso, icom) ~ r)
      plot(K2, iso - icom ~ r)
    }
</code></pre>

<hr>
<h2 id='Kmodel'>K Function or Pair Correlation Function of a Point Process Model</h2><span id='topic+Kmodel'></span><span id='topic+pcfmodel'></span>

<h3>Description</h3>

<p>Returns the theoretical <code class="reqn">K</code> function or the pair correlation function
of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Kmodel(model, ...)

   pcfmodel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmodel_+3A_model">model</code></td>
<td>

<p>A fitted point process model of some kind.
</p>
</td></tr>
<tr><td><code id="Kmodel_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For certain types of point process models, it is possible to
write down a mathematical expression for the <code class="reqn">K</code> function
or the pair correlation function of the model. 
</p>
<p>The functions <code>Kmodel</code> and <code>pcfmodel</code> give the
theoretical <code class="reqn">K</code>-function and the theoretical pair correlation
function for a point process model that has been fitted to data.
</p>
<p>The functions <code>Kmodel</code> and <code>pcfmodel</code> are generic,
with methods for the classes <code>"kppm"</code> (cluster processes
and Cox processes) and <code>"ppm"</code> (Gibbs processes).
</p>
<p>The return value is a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
Evaluation of this function, on a numeric vector <code>r</code>,
yields values of the desired <code class="reqn">K</code> function or pair correlation
function at these distance values.
</p>


<h3>Value</h3>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>
to estimate the <code class="reqn">K</code> function or pair correlation function
nonparametrically from data.
</p>
<p><code><a href="#topic+Kmodel.kppm">Kmodel.kppm</a></code> for the method for cluster processes
and Cox processes.
</p>
<p><code><a href="#topic+Kmodel.ppm">Kmodel.ppm</a></code> for the method for Gibbs processes.
</p>

<hr>
<h2 id='Kmodel.dppm'>
K-function or Pair Correlation Function of a
Determinantal Point Process Model
</h2><span id='topic+Kmodel.detpointprocfamily'></span><span id='topic+pcfmodel.detpointprocfamily'></span><span id='topic+Kmodel.dppm'></span><span id='topic+pcfmodel.dppm'></span>

<h3>Description</h3>

<p>Returns the theoretical <code class="reqn">K</code>-function
or theoretical pair correlation function of a determinantal point
process model as a function of one argument <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'dppm'
Kmodel(model, ...)

   ## S3 method for class 'dppm'
pcfmodel(model, ...)

   ## S3 method for class 'detpointprocfamily'
Kmodel(model, ...)

   ## S3 method for class 'detpointprocfamily'
pcfmodel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmodel.dppm_+3A_model">model</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code> or <code>"dppm"</code>.</p>
</td></tr>
<tr><td><code id="Kmodel.dppm_+3A_...">...</code></td>
<td>
<p>Ignored (not quite true &ndash; there is some undocumented internal use)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span> language, with one numeric argument <code>r</code>,
that can be used to evaluate the theoretical <code class="reqn">K</code>-function or
pair correlation function of the model at distances <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  model &lt;- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
  KMatern &lt;- Kmodel(model)
  pcfMatern &lt;- pcfmodel(model)
  plot(KMatern, xlim = c(0,0.05))
  plot(pcfMatern, xlim = c(0,0.05))
</code></pre>

<hr>
<h2 id='Kmodel.kppm'>K Function or Pair Correlation Function of Cluster Model or Cox model</h2><span id='topic+Kmodel.kppm'></span><span id='topic+pcfmodel.kppm'></span>

<h3>Description</h3>

<p>Returns the theoretical <code class="reqn">K</code> function or the pair correlation function
of a cluster point process model or Cox point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'kppm'
Kmodel(model, ...)

   ## S3 method for class 'kppm'
pcfmodel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmodel.kppm_+3A_model">model</code></td>
<td>

<p>A fitted cluster point process model (object of
class <code>"kppm"</code>) typically obtained from
the model-fitting algorithm <code><a href="#topic+kppm">kppm</a></code>. 
</p>
</td></tr>
<tr><td><code id="Kmodel.kppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For certain types of point process models, it is possible to
write down a mathematical expression for the <code class="reqn">K</code> function
or the pair correlation function of the model. In particular this
is possible for a fitted cluster point process model 
(object of class <code>"kppm"</code> obtained from <code><a href="#topic+kppm">kppm</a></code>).
</p>
<p>The functions <code><a href="#topic+Kmodel">Kmodel</a></code> and <code><a href="#topic+pcfmodel">pcfmodel</a></code> are generic.
The functions documented here are the methods for the class <code>"kppm"</code>.
</p>
<p>The return value is a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
Evaluation of this function, on a numeric vector <code>r</code>,
yields values of the desired <code class="reqn">K</code> function or pair correlation
function at these distance values.
</p>


<h3>Value</h3>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>
to estimate the <code class="reqn">K</code> function or pair correlation function
nonparametrically from data.
</p>
<p><code><a href="#topic+kppm">kppm</a></code> to fit cluster models.
</p>
<p><code><a href="#topic+Kmodel">Kmodel</a></code> for the generic functions.
</p>
<p><code><a href="#topic+Kmodel.ppm">Kmodel.ppm</a></code> for the method for Gibbs processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood, ~x, "MatClust")
  K &lt;- Kmodel(fit)
  K(c(0.1, 0.2))
  curve(K(x), from=0, to=0.25)
</code></pre>

<hr>
<h2 id='Kmodel.ppm'>K Function or Pair Correlation Function of Gibbs Point Process model</h2><span id='topic+Kmodel.ppm'></span><span id='topic+pcfmodel.ppm'></span>

<h3>Description</h3>

<p>Returns the theoretical <code class="reqn">K</code> function or the pair correlation function
of a fitted Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'ppm'
Kmodel(model, ...)

   ## S3 method for class 'ppm'
pcfmodel(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kmodel.ppm_+3A_model">model</code></td>
<td>

<p>A fitted Poisson or Gibbs point process model (object of
class <code>"ppm"</code>) typically obtained from
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>. 
</p>
</td></tr>
<tr><td><code id="Kmodel.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an <em>approximation</em> to the <code class="reqn">K</code> function
or the pair correlation function of a Gibbs point process.
</p>
<p>The functions <code><a href="#topic+Kmodel">Kmodel</a></code> and <code><a href="#topic+pcfmodel">pcfmodel</a></code> are generic.
The functions documented here are the methods for the class
<code>"ppm"</code>.
</p>
<p>The approximation is only available for stationary 
pairwise-interaction models.
It uses the second order Poisson-saddlepoint approximation
(Baddeley and Nair, 2012b) which is a combination of
the Poisson-Boltzmann-Emden and Percus-Yevick approximations.
</p>
<p>The return value is a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
Evaluation of this function, on a numeric vector <code>r</code>,
yields values of the desired <code class="reqn">K</code> function or pair correlation
function at these distance values.
</p>


<h3>Value</h3>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language,
which takes one argument <code>r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Gopalan Nair.
</p>


<h3>References</h3>

<p>Baddeley, A. and Nair, G. (2012a) 
Fast approximation of the intensity of Gibbs point processes.
<em>Electronic Journal of Statistics</em> <b>6</b> 1155&ndash;1169.
</p>
<p>Baddeley, A. and Nair, G. (2012b)
Approximating the moments of a spatial point process.
<em>Stat</em> <b>1</b>, 1, 18&ndash;30.
<code>DOI: 10.1002/sta4.5</code>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>
to estimate the <code class="reqn">K</code> function or pair correlation function
nonparametrically from data.
</p>
<p><code><a href="#topic+ppm">ppm</a></code> to fit Gibbs models.
</p>
<p><code><a href="#topic+Kmodel">Kmodel</a></code> for the generic functions.
</p>
<p><code><a href="#topic+Kmodel.kppm">Kmodel.kppm</a></code> for the method for cluster/Cox processes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(swedishpines, ~1, Strauss(8))
  p &lt;- pcfmodel(fit)
  K &lt;- Kmodel(fit)
  p(6)
  K(8)
  curve(K(x), from=0, to=15)
</code></pre>

<hr>
<h2 id='kppm'>Fit Cluster or Cox Point Process Model</h2><span id='topic+kppm'></span><span id='topic+kppm.formula'></span><span id='topic+kppm.ppp'></span><span id='topic+kppm.quad'></span>

<h3>Description</h3>

<p>Fit a homogeneous or inhomogeneous cluster process or
Cox point process model to a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kppm(X, ...)

  ## S3 method for class 'formula'
kppm(X,
                clusters = c("Thomas","MatClust","Cauchy","VarGamma","LGCP"),
                ...,
                data=NULL)

  ## S3 method for class 'ppp'
kppm(X,
       trend = ~1,
       clusters = c("Thomas","MatClust","Cauchy","VarGamma","LGCP"),
       data = NULL,
       ...,
       covariates=data,
       subset,
       method = c("mincon", "clik2", "palm", "adapcl"),
       penalised = FALSE,
       improve.type = c("none", "clik1", "wclik1", "quasi"),
       improve.args = list(),
       weightfun=NULL,
       control=list(),
       stabilize=TRUE,
       algorithm,
       trajectory=FALSE,
       statistic="K",
       statargs=list(),
       rmax = NULL,
       epsilon=0.01,
       covfunargs=NULL,
       use.gam=FALSE,
       nd=NULL, eps=NULL,
       ppm.improve.type=c("none", "ho", "enet"),
       ppm.improve.args=list())

## S3 method for class 'quad'
kppm(X,
       trend = ~1,
       clusters = c("Thomas","MatClust","Cauchy","VarGamma","LGCP"),
       data = NULL,
       ...,
       covariates=data,
       subset,
       method = c("mincon", "clik2", "palm", "adapcl"),
       penalised = FALSE,
       improve.type = c("none", "clik1", "wclik1", "quasi"),
       improve.args = list(),
       weightfun=NULL,
       control=list(),
       stabilize=TRUE,
       algorithm,
       trajectory=FALSE,
       statistic="K",
       statargs=list(),
       rmax = NULL,
       epsilon=0.01,
       covfunargs=NULL,
       use.gam=FALSE,
       nd=NULL, eps=NULL,
       ppm.improve.type=c("none", "ho", "enet"),
       ppm.improve.args=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kppm_+3A_x">X</code></td>
<td>

<p>A point pattern dataset (object of class <code>"ppp"</code> or
<code>"quad"</code>) to which the model should be fitted, or a
<code>formula</code> in the <span class="rlang"><b>R</b></span> language defining the model. See Details.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_trend">trend</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> formula, with no left hand side,
specifying the form of the log intensity.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_clusters">clusters</code></td>
<td>

<p>Character string determining the cluster model.
Partially matched.
Options are <code>"Thomas"</code>, <code>"MatClust"</code>,
<code>"Cauchy"</code>, <code>"VarGamma"</code> and <code>"LGCP"</code>.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_data">data</code>, <code id="kppm_+3A_covariates">covariates</code></td>
<td>

<p>The values of spatial covariates (other than the Cartesian
coordinates) required by the model.
A named list of pixel images, functions, windows,
tessellations or numeric constants.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_...">...</code></td>
<td>

<p>Additional arguments. See Details.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_subset">subset</code></td>
<td>

<p>Optional.
A subset of the spatial domain,
to which the model-fitting should be restricted.
A window (object of class <code>"owin"</code>)
or a logical-valued pixel image (object of class <code>"im"</code>),
or an expression (possibly involving the names of entries in <code>data</code>)
which can be evaluated to yield a window or pixel image.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_method">method</code></td>
<td>

<p>The fitting method. Either 
<code>"mincon"</code> for minimum contrast,
<code>"clik2"</code> for second order composite likelihood,
<code>"adapcl"</code> for adaptive second order composite likelihood,
or <code>"palm"</code> for Palm likelihood.
Partially matched.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_penalised">penalised</code></td>
<td>

<p>Logical value specifying whether the objective function (the composite
likelihood or contrast) should be modified by adding a penalty against
extreme values of cluster scale. 
</p>
</td></tr>
<tr><td><code id="kppm_+3A_improve.type">improve.type</code></td>
<td>

<p>Method for updating the initial estimate of the trend.
Initially the trend is estimated as if the process
is an inhomogeneous Poisson process.
The default, <code>improve.type = "none"</code>, is to use this initial estimate.
Otherwise, the trend estimate is
updated by <code><a href="#topic+improve.kppm">improve.kppm</a></code>, using information
about the pair correlation function.
Options are <code>"clik1"</code>
(first order composite likelihood, essentially equivalent to <code>"none"</code>),
<code>"wclik1"</code> (weighted first order composite likelihood) and
<code>"quasi"</code> (quasi likelihood).
</p>
</td></tr>
<tr><td><code id="kppm_+3A_improve.args">improve.args</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+improve.kppm">improve.kppm</a></code> when
<code>improve.type != "none"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_weightfun">weightfun</code></td>
<td>

<p>Optional weighting function <code class="reqn">w</code>
in the composite likelihoods or Palm likelihood.
A <code>function</code> in the <span class="rlang"><b>R</b></span> language,
or one of the strings <code>"threshold"</code> or <code>"taper"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_control">control</code></td>
<td>

<p>List of control parameters passed to the optimization function
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_stabilize">stabilize</code></td>
<td>

<p>Logical value specifying whether to numerically stabilize
the optimization algorithm, by specifying suitable default values of
<code>control$fnscale</code> and <code>control$parscale</code>.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_algorithm">algorithm</code></td>
<td>

<p>Character string determining the mathematical algorithm
to be used to solve the fitting problem.
If <code>method="mincon", "clik2"</code> or <code>"palm"</code> this argument
is passed to the generic optimization function
<code><a href="stats.html#topic+optim">optim</a></code>
(renamed as the argument <code>method</code> to <code><a href="stats.html#topic+optim">optim</a></code>)
with default <code>"Nelder-Mead"</code>.
If <code>method="adapcl"</code> the argument is passed to the
equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
(renamed as the argument <code>method</code> to <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>)
with default <code>"Bryden"</code>.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_trajectory">trajectory</code></td>
<td>

<p>Logical value specifying whether to save the history of all
function evaluations performed by the optimization algorithm.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_statistic">statistic</code></td>
<td>

<p>Name of the summary statistic to be used
for minimum contrast estimation: either <code>"K"</code> or <code>"pcf"</code>.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_statargs">statargs</code></td>
<td>

<p>Optional list of arguments to be used when calculating
the <code>statistic</code>. See Details.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_rmax">rmax</code></td>
<td>

<p>Maximum value of interpoint distance
to use in the composite likelihood.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_epsilon">epsilon</code></td>
<td>

<p>Tuning parameter for the adaptive composite likelihood method.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_covfunargs">covfunargs</code>, <code id="kppm_+3A_use.gam">use.gam</code>, <code id="kppm_+3A_nd">nd</code>, <code id="kppm_+3A_eps">eps</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+ppm">ppm</a></code> when fitting the intensity.
</p>
</td></tr>
<tr><td><code id="kppm_+3A_ppm.improve.type">ppm.improve.type</code>, <code id="kppm_+3A_ppm.improve.args">ppm.improve.args</code></td>
<td>

<p>Arguments controlling the initial fit of the trend.
Passed to <code><a href="#topic+ppm">ppm</a></code> as the arguments
<code>improve.type</code> and <code>improve.args</code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a clustered point process model to the
point pattern dataset <code>X</code>. 
</p>
<p>The model may be either a <em>Neyman-Scott cluster process</em>
or another <em>Cox process</em>.
The type of model is determined by the argument <code>clusters</code>.
Currently the options 
are <code>clusters="Thomas"</code> for the Thomas process,
<code>clusters="MatClust"</code> for the Matern cluster process,
<code>clusters="Cauchy"</code> for the Neyman-Scott cluster process
with Cauchy kernel,
<code>clusters="VarGamma"</code> for the Neyman-Scott cluster process
with Variance Gamma kernel (requires an additional argument <code>nu</code>
to be passed through the dots; see <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code> for details),
and <code>clusters="LGCP"</code> for the log-Gaussian Cox process (may
require additional arguments passed through <code>...</code>; see
<code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code> for details on argument names).
The first four models are Neyman-Scott cluster processes.
</p>
<p>The algorithm first estimates the intensity function
of the point process using <code><a href="#topic+ppm">ppm</a></code>.
The argument <code>X</code> may be a point pattern
(object of class <code>"ppp"</code>) or a quadrature scheme
(object of class <code>"quad"</code>). The intensity is specified by
the <code>trend</code> argument.
If the trend formula is <code>~1</code> (the default)
then the model is <em>homogeneous</em>. The algorithm begins by
estimating the intensity as the number of points divided by
the area of the window.
Otherwise, the model is <em>inhomogeneous</em>. 
The algorithm begins by fitting a Poisson process with log intensity
of the form specified by the formula <code>trend</code>.
(See <code><a href="#topic+ppm">ppm</a></code> for further explanation).
</p>
<p>The argument <code>X</code> may also be a <code>formula</code> in the
<span class="rlang"><b>R</b></span> language. The right hand side of the formula gives the
<code>trend</code> as described above. The left hand side of the formula
gives the point pattern dataset to which the model should be fitted.
</p>
<p>If <code>improve.type="none"</code> this is the final estimate of the
intensity. Otherwise, the intensity estimate is updated, as explained in
<code><a href="#topic+improve.kppm">improve.kppm</a></code>. Additional arguments to
<code><a href="#topic+improve.kppm">improve.kppm</a></code> are passed as a named list in
<code>improve.args</code>.
</p>
<p>The cluster parameters of the model are then fitted
either by minimum contrast estimation,
or by a composite likelihood method (maximum
composite likelihood, maximum Palm likelihood, or by solving the adaptive 
composite likelihood estimating equation).
</p>

<dl>
<dt>Minimum contrast:</dt><dd>
<p>If <code>method = "mincon"</code> (the default) clustering parameters of
the model will be fitted
by minimum contrast estimation, that is, by matching the theoretical
<code class="reqn">K</code>-function of the model to the empirical <code class="reqn">K</code>-function
of the data, as explained in <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>For a homogeneous model (<code> trend = ~1 </code>)
the empirical <code class="reqn">K</code>-function of the data is computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
and the parameters of the cluster model are estimated by
the method of minimum contrast.
</p>
<p>For an inhomogeneous model, 
the inhomogeneous <code class="reqn">K</code> function is estimated
by <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code> using the fitted intensity.
Then the parameters of the cluster model
are estimated by the method of minimum contrast using the
inhomogeneous <code class="reqn">K</code> function. This two-step estimation
procedure is due to Waagepetersen (2007).
</p>
<p>If <code>statistic="pcf"</code> then instead of using the
<code class="reqn">K</code>-function, the algorithm will use
the pair correlation function <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> for homogeneous
models and the inhomogeneous pair correlation function
<code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code> for inhomogeneous models.
In this case, the smoothing parameters of the pair correlation
can be controlled using the argument <code>statargs</code>,
as shown in the Examples.
</p>
<p>Additional arguments <code>...</code> will be passed to
<code><a href="#topic+clusterfit">clusterfit</a></code> to control the minimum contrast fitting
algorithm.
</p>
<p>The optimisation is performed by the generic
optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</dd>
<dt>Second order composite likelihood:</dt><dd>
<p>If <code>method = "clik2"</code> the clustering parameters of the
model will be fitted by maximising the second-order composite likelihood
(Guan, 2006). The log composite likelihood is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(d_{ij}) \log\rho(d_{ij}; \theta)
	- \left( \sum_{i,j} w(d_{ij}) \right)
	\log \int_D \int_D w(\|u-v\|) \rho(\|u-v\|; \theta)\, du\, dv
      </code>
</p>

<p>where the sums are taken over all pairs of data points
<code class="reqn">x_i, x_j</code> separated by a distance
<code class="reqn">d_{ij} = \| x_i - x_j\|</code>
less than <code>rmax</code>,
and the double integral is taken over all pairs of locations
<code class="reqn">u,v</code> in the spatial window of the data.
Here <code class="reqn">\rho(d;\theta)</code> is the
pair correlation function of the model with
cluster parameters <code class="reqn">\theta</code>.
</p>
<p>The function <code class="reqn">w</code> in the composite likelihood
is a weighting function and may be chosen arbitrarily.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
a threshold weight function,
<code class="reqn">w(d) = 1(d \le R)</code>, where <code class="reqn">R</code> is <code>rmax/2</code>.
If it is specified, the argument <code>weightfun</code> should
be a <code>function</code> in the <span class="rlang"><b>R</b></span> language with one argument.
Alternatively <code>weightfun</code> may be
one of the strings <code>"threshold"</code> or <code>"taper"</code>
representing the functions
<code class="reqn">w(d) = 1(d \le R)</code>
and
<code class="reqn">w(d) = min(1, R/d)</code> respectively.
</p>
<p>The optimisation is performed by the generic
optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</dd>
<dt>Palm likelihood:</dt><dd>
<p>If <code>method = "palm"</code> the clustering parameters of the
model will be fitted by maximising the Palm loglikelihood
(Tanaka et al, 2008)
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{i,j} w(x_i, x_j) \log \lambda_P(x_j \mid x_i; \theta)
	- \int_D w(x_i, u) \lambda_P(u \mid x_i; \theta) {\rm d} u
      </code>
</p>

<p>with the same notation as above. Here
<code class="reqn">\lambda_P(u|v;\theta)</code> is the Palm intensity of
the model at location <code class="reqn">u</code> given there is a point at <code class="reqn">v</code>.
</p>
<p>The optimisation is performed by the generic
optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</dd>
<dt>Adaptive Composite likelihood:</dt><dd>
<p>If <code>method = "cladap"</code> the clustering parameters of the
model will be fitted by solving the adaptive second order 
composite likelihood estimating equation (Lavancier et al, 2021).
The estimating function is
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_{u, v}
	w(\epsilon \frac{| g(0; \theta) - 1 |}{g(\|u-v\|; \theta)-1})
  	\frac{\nabla_\theta g(\|u-v\|;\theta)}{g(\|u-v\|;\theta)}
	- 
	\int_D \int_D
	w(\epsilon \frac{ | g(u,v; \theta) - 1|}{g(\|u-v\|; \theta)-1})
	\nabla_\theta g(\|u-v\|; \theta) 
	\rho(u) \rho(v)\, du\, dv
      </code>
</p>

<p>where the sum is taken over all distinct pairs of points.
Here <code class="reqn">g(d;\theta)</code> is the
pair correlation function  with
parameters <code class="reqn">\theta</code>.
The partial derivative with respect to <code class="reqn">\theta</code> 
is <code class="reqn">g'(d; \theta)</code>, and <code class="reqn">\rho(u)</code> denotes
the fitted intensity function of the model.
</p>
<p>The tuning parameter <code class="reqn">\epsilon</code> is 
independent of the data. It can be specified by the
argument <code>epsilon</code> and has default value <code class="reqn">0.01</code>.
</p>
<p>The function <code class="reqn">w</code> in the estimating function
is a weighting function of bounded support <code class="reqn">[-1,1]</code>.
It is specified by the argument <code>weightfun</code>.
If this is missing or <code>NULL</code> then the default is
<code class="reqn">
	w(d) = 1(\|d\| \le 1) \exp(1/(r^2-1))</code>
The estimating equation is solved using the
nonlinear equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
from the package <span class="pkg">nleqslv</span>. The package <span class="pkg">nleqslv</span>
must be installed in order to use this option.
</p>
</dd>   
</dl>

<p>If <code>penalised=TRUE</code>, the fitting procedure is modified by
adding a penalty against extreme values of the cluster scale,
as proposed by Baddeley et al (2022).
</p>
<p>If <code>trajectory=TRUE</code>, the resulting object contains the history
of all points in the cluster parameter space which were evaluated by
the optimization algorithm. The trajectory can be extracted by
<code>traj(fit)</code> or <code>traj(obsurf(fit))</code> where <code>fit</code> is the
fitted model object.
</p>


<h3>Value</h3>

<p>An object of class <code>"kppm"</code> representing the fitted model.
There are methods for printing, plotting, predicting, simulating
and updating objects of this class.
</p>


<h3>Cluster parameters for Neyman-Scott models</h3>

<p>For Neyman-Scott models, the fitting procedure searches
for the best-fitting values of the parameters
that control the intensity of parents and the physical scale
of the clusters. (Any parameters that control the shape of the clusters
must be specified separately and are assumed to be fixed.)
</p>
<p>The fitted object <code>fit</code> contains the fitted cluster parameters as
the element <code>fit$par</code> in the format described below.
Initial estimates for these cluster
parameters can be specified using the argument <code>startpar</code> in the
same format.
</p>
<p>The cluster parameters will be stored in a <em>named</em> numeric vector
<code>par</code> of length 2. The first value is always <code>kappa</code>,
the intensity of parents (cluster centres).
The format is as follows:
</p>

<ul>
<li>
<p>for <code>clusters="Thomas"</code>,
a vector <code>c(kappa, sigma2)</code> where
<code>sigma2</code> is the square of the cluster standard deviation;
</p>
</li>
<li>
<p>for <code>clusters="MatClust"</code>,
a vector <code>c(kappa, R)</code> where
<code>R</code> is the radius of the cluster;
</p>
</li>
<li>
<p>for <code>clusters="Cauchy"</code>,
a vector <code>c(kappa, eta2)</code> where
<code>eta2 = code{4 * scale^2}</code>
where <code>scale</code> is the scale parameter for the model
as used in <code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>;
</p>
</li>
<li>
<p>for <code>clusters="VarGamma"</code>,
a vector <code>c(kappa, eta)</code> where
<code>eta</code> is equivalent to the
scale parameter <code>omega</code> used in  <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>.
</p>
</li></ul>

<p>For <code>clusters="VarGamma"</code> it will be necessary to specify
the shape parameter <code>nu</code> as described in the help for
<code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>. This is specified separately as an argument
<code>nu</code> in the call to <code>kppm</code>.
</p>


<h3>Optimization algorithm</h3>

<p>The following details allow greater control over the fitting
procedure.
</p>
<p>For the first three fitting methods
(<code>method="mincon", "clik2"</code> and <code>"palm"</code>), 
the optimisation is performed by the generic
optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
The behaviour of this algorithm can be controlled
by the following arguments to <code>kppm</code>:
</p>

<ul>
<li>
<p><code>startpar</code> determines the initial estimates of the cluster parameters.
</p>
</li>
<li>
<p><code>algorithm</code> determines the particular optimization
method. This argument is passed to <code><a href="stats.html#topic+optim">optim</a></code> as the
argument <code>method</code>. Options are listed in the help for
<code><a href="stats.html#topic+optim">optim</a></code>. The default is the Nelder-Mead
simplex method.
</p>
</li>
<li>
<p><code>control</code> is a named list of control parameters,
documented in the help for <code><a href="stats.html#topic+optim">optim</a></code>.
Useful control arguments include
<code>trace</code>, <code>maxit</code> and <code>abstol</code>.
</p>
</li>
<li>
<p><code>lower</code> and <code>upper</code> specify bounds for the
cluster parameters, when <code>algorithm="L-BFGS-B"</code> or
<code>algorithm="Brent"</code>, as described in the help for <code><a href="stats.html#topic+optim">optim</a></code>. 
</p>
</li></ul>

<p>For <code>method="adapcl"</code>, the estimating equation is solved
using the nonlinear equation solver <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
from the package <span class="pkg">nleqslv</span>. 
The package <span class="pkg">nleqslv</span> must be installed in order to use this
option.
The behaviour of this algorithm can be controlled
by the following arguments to <code>kppm</code>:
</p>

<ul>
<li>
<p><code>startpar</code> determines the initial estimates of the cluster parameters.
</p>
</li>
<li>
<p><code>algorithm</code> determines the method for solving
the equation. This argument is passed to <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code> as the
argument <code>method</code>. Options are listed in the help for
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.
</p>
</li>
<li>
<p><code>globStrat</code> determines the global strategy
to be applied. This argument is is passed to <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
as the argument <code>global</code>. Options are listed in the help for
<code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.
</p>
</li>
<li>
<p><code>control</code> is a named list of control parameters,
documented in the help for <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.
</p>
</li></ul>



<h3>Log-Gaussian Cox Models</h3>

<p>To fit a log-Gaussian Cox model,
specify <code>clusters="LGCP"</code> and use additional arguments
to specify the covariance structure. These additional arguments can
be given individually in the call to <code>kppm</code>, or they can be
collected together in a list called <code>covmodel</code>.
</p>
<p>For example a Matern model with parameter <code class="reqn">\nu=0.5</code> could be specified
either by <code>kppm(X, clusters="LGCP", model="matern", nu=0.5)</code> or by
<code>kppm(X, clusters="LGCP", covmodel=list(model="matern", nu=0.5))</code>.
</p>
<p>The argument <code>model</code> specifies the type of covariance
model: the default is <code>model="exp"</code> for an exponential covariance.
Additional arguments specify the shape parameters of the covariance
model. For example if <code>model="matern"</code> then the additional argument
<code>nu</code> is required. 
</p>
<p>The available models are as follows:
</p>

<dl>
<dt><code>model="exponential"</code>:</dt><dd>
<p>the exponential covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \sigma^2 \exp(-r/h)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the (fitted) variance parameter,
and <code class="reqn">h</code> is the (fitted) scale parameter.
No shape parameters are required.
</p>
</dd>
<dt><code>model="gauss"</code>:</dt><dd>
<p>the Gaussian covariance function
</p>
<p style="text-align: center;"><code class="reqn">C(r) = \sigma^2 \exp(-(r/h)^2)</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the (fitted) variance parameter,
and <code class="reqn">h</code> is the (fitted) scale parameter.
No shape parameters are required.
</p>
</dd>
<dt><code>model="stable"</code>:</dt><dd>
<p>the stable covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 \exp(-(r/h)^\alpha)
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the (fitted) variance parameter,
<code class="reqn">h</code> is the (fitted) scale parameter,
and <code class="reqn">\alpha</code> is the shape parameter <code>alpha</code>.
The parameter <code>alpha</code> must be given, either as a stand-alone
argument, or as an entry in the list <code>covmodel</code>.
</p>
</dd>
<dt><code>model="gencauchy"</code>:</dt><dd>
<p>the generalised Cauchy covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 (1 + (x/h)^\alpha)^{-\beta/\alpha}
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the (fitted) variance parameter,
<code class="reqn">h</code> is the (fitted) scale parameter,
and <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are the shape parameters
<code>alpha</code> and <code>beta</code>.
The parameters <code>alpha</code> and <code>beta</code>
must be given, either as stand-alone arguments, or as entries
in the list <code>covmodel</code>.
</p>
</dd>
<dt><code>model="matern"</code>:</dt><dd>
<p>the Whittle-Matern covariance function
</p>
<p style="text-align: center;"><code class="reqn">
	C(r) = \sigma^2 \frac{1}{2^{\nu-1} \Gamma(\nu)}
	       (\sqrt{2 \nu} \, r/h)^\nu K_\nu(\sqrt{2\nu}\, r/h)
      </code>
</p>

<p>where <code class="reqn">\sigma^2</code> is the (fitted) variance parameter,
<code class="reqn">h</code> is the (fitted) scale parameter,
and <code class="reqn">\nu</code> is the shape parameter <code>nu</code>.
The parameter <code>nu</code> must be given, either as a stand-alone
argument, or as an entry in the list <code>covmodel</code>.
</p>
</dd>
</dl>

<p>Note that it is not possible to use <em>anisotropic</em> covariance models
because the <code>kppm</code> technique assumes the pair correlation function
is isotropic.
</p>


<h3>Error and warning messages</h3>

<p>See <code><a href="#topic+ppm.ppp">ppm.ppp</a></code> for a list of common error messages
and warnings originating from the first stage of model-fitting.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>,
with contributions from Abdollah Jalilian <a href="mailto:jalilian@razi.ac.ir">jalilian@razi.ac.ir</a> and Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adaptive composite likelihood method contributed by Chiara Fend
and modified by Adrian Baddeley.
Penalised optimization developed by Adrian Baddeley, Tilman Davies <a href="mailto:Tilman.Davies@otago.ac.nz">Tilman.Davies@otago.ac.nz</a>
and Martin Hazelton <a href="mailto:Martin.Hazelton@otago.ac.nz">Martin.Hazelton@otago.ac.nz</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Davies, T.M., Hazelton, M.L., Rakshit, S. and Turner,
R. (2022) Fundamental problems in fitting spatial cluster
process models. <em>Spatial Statistics</em> <b>52</b>, 100709.
DOI: <code>10.1016/j.spasta.2022.100709</code>
</p>
<p>Guan, Y. (2006) 
A composite likelihood approach in fitting spatial point process models.
<em>Journal of the American Statistical Association</em>
<b>101</b>, 1502&ndash;1512.
</p>
<p>Guan, Y., Jalilian, A. and Waagepetersen, R. (2015)
Quasi-likelihood for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 677-697.
</p>
<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2012)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119&ndash;137.
</p>
<p>Lavancier, F., Poinas, A., and Waagepetersen, R. (2021)
Adaptive estimating function inference for nonstationary
determinantal point processes.
<em>Scandinavian Journal of Statistics</em>, <b>48</b> (1), 87&ndash;107.
</p>
<p>Tanaka, U. and Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for
Neyman-Scott point processes. 
<em>Biometrical Journal</em> <b>50</b>, 43&ndash;57.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p>Methods for <code>kppm</code> objects:
<code><a href="#topic+plot.kppm">plot.kppm</a></code>,
<code><a href="#topic+fitted.kppm">fitted.kppm</a></code>,
<code><a href="#topic+predict.kppm">predict.kppm</a></code>,
<code><a href="#topic+simulate.kppm">simulate.kppm</a></code>,
<code><a href="#topic+update.kppm">update.kppm</a></code>,
<code><a href="#topic+vcov.kppm">vcov.kppm</a></code>,
<code><a href="#topic+methods.kppm">methods.kppm</a></code>,
<code><a href="#topic+as.ppm.kppm">as.ppm.kppm</a></code>,
<code><a href="#topic+as.fv.kppm">as.fv.kppm</a></code>,
<code><a href="#topic+Kmodel.kppm">Kmodel.kppm</a></code>,
<code><a href="#topic+pcfmodel.kppm">pcfmodel.kppm</a></code>.
</p>
<p>See also <code><a href="#topic+improve.kppm">improve.kppm</a></code> for improving the fit of a
<code>kppm</code> object.
</p>
<p>Minimum contrast fitting algorithm:
higher level interface <code><a href="#topic+clusterfit">clusterfit</a></code>;
low-level algorithm <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>Alternative fitting algorithms:
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
<code><a href="#topic+matclust.estK">matclust.estK</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+cauchy.estK">cauchy.estK</a></code>,
<code><a href="#topic+vargamma.estK">vargamma.estK</a></code>,
<code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code>,
<code><a href="#topic+matclust.estpcf">matclust.estpcf</a></code>,
<code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code>,
<code><a href="#topic+cauchy.estpcf">cauchy.estpcf</a></code>,
<code><a href="#topic+vargamma.estpcf">vargamma.estpcf</a></code>.
</p>
<p>Summary statistics:
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code>.
</p>
<p>For fitting Poisson or Gibbs point process models, see <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  online &lt;- interactive()
  if(!online) op &lt;- spatstat.options(npixel=32, ndummy.min=16)

  # method for point patterns
  kppm(redwood, ~1, "Thomas")
  # method for formulas
  kppm(redwood ~ 1, "Thomas")

  # different models for clustering
  if(online) kppm(redwood ~ x, "MatClust") 
  kppm(redwood ~ x, "MatClust", statistic="pcf", statargs=list(stoyan=0.2)) 
  kppm(redwood ~ x, cluster="Cauchy", statistic="K")
  kppm(redwood, cluster="VarGamma", nu = 0.5, statistic="pcf")

  # log-Gaussian Cox process (LGCP) models
  kppm(redwood ~ 1, "LGCP", statistic="pcf")
  kppm(redwood ~ x, "LGCP", statistic="pcf",
                            model="matern", nu=0.3,
                            control=list(maxit=10))

  # Different fitting techniques
  fitc &lt;- kppm(redwood ~ 1, "Thomas", method="c")
  fitp &lt;- kppm(redwood ~ 1, "Thomas", method="p")
  # penalised fit
  fitmp &lt;- kppm(redwood ~ 1, "Thomas", penalised=TRUE)
  # quasi-likelihood improvement 
  fitq &lt;- kppm(redwood ~ x, "Thomas", improve.type = "quasi")

  if(!online) spatstat.options(op)
</code></pre>

<hr>
<h2 id='Kres'>
Residual K Function
</h2><span id='topic+Kres'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the residual <code class="reqn">K</code> function,
which serves as a diagnostic for goodness-of-fit of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   Kres(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kres_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>),
a point pattern (object of class <code>"ppp"</code>),
a quadrature scheme (object of class <code>"quad"</code>),
or the value returned by a previous call to <code><a href="#topic+Kcom">Kcom</a></code>.
</p>
</td></tr>
<tr><td><code id="Kres_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+Kcom">Kcom</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command provides a diagnostic for the goodness-of-fit of
a point process model fitted to a point pattern dataset.
It computes a residual version of the <code class="reqn">K</code> function of the
dataset, which should be approximately zero if the model is a good
fit to the data.
</p>
<p>In normal use, <code>object</code> is a fitted point process model
or a point pattern. Then <code>Kres</code> first calls <code><a href="#topic+Kcom">Kcom</a></code>
to compute both the nonparametric estimate of the <code class="reqn">K</code> function
and its model compensator. Then <code>Kres</code> computes the
difference between them, which is the residual <code class="reqn">K</code>-function.
</p>
<p>Alternatively, <code>object</code> may be a function value table
(object of class <code>"fv"</code>) that was returned by
a previous call to <code><a href="#topic+Kcom">Kcom</a></code>. Then <code>Kres</code> computes the
residual from this object. 
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Related functions:
<code><a href="#topic+Kcom">Kcom</a></code>, 
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>.
</p>
<p>Alternative functions:
<code><a href="#topic+Gres">Gres</a></code>,
<code><a href="#topic+psstG">psstG</a></code>, <code><a href="#topic+psstA">psstA</a></code>,  <code><a href="#topic+psst">psst</a></code>.
</p>
<p>Point process models: <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit0 &lt;- ppm(cells ~1) # uniform Poisson
    
    K0 &lt;- Kres(fit0)
    K0
    plot(K0)
# isotropic-correction estimate
    plot(K0, ires ~ r)
# uniform Poisson is clearly not correct

    fit1 &lt;- ppm(cells ~1, Strauss(0.08))
    
    K1 &lt;- Kres(fit1)

    if(interactive()) {
      plot(K1, ires ~ r)
   # fit looks approximately OK; try adjusting interaction distance
      plot(Kres(cells, interaction=Strauss(0.12)))
    }

# How to make envelopes
    
      E &lt;- envelope(fit1, Kres, model=fit1, nsim=19)
      plot(E)
    

# For computational efficiency
    Kc &lt;- Kcom(fit1)
    K1 &lt;- Kres(Kc)
</code></pre>

<hr>
<h2 id='LambertW'>
Lambert's W Function
</h2><span id='topic+LambertW'></span>

<h3>Description</h3>

<p>Computes Lambert's W-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LambertW(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambertW_+3A_x">x</code></td>
<td>

<p>Vector of nonnegative numbers.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lambert's W-function is the inverse function of
<code class="reqn">f(y) = y e^y</code>.
That is, <code class="reqn">W</code> is the function such that
</p>
<p style="text-align: center;"><code class="reqn">
    W(x) e^{W(x)} = x
  </code>
</p>

<p>This command <code>LambertW</code> computes <code class="reqn">W(x)</code> for each entry
in the argument <code>x</code>. 
If the library <span class="pkg">gsl</span> has been installed, then the function
<code>lambert_W0</code> in that library is invoked. Otherwise,
values of the W-function are computed by root-finding, using the
function <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>
<p>Computation using <span class="pkg">gsl</span> is about 100 times faster.
</p>
<p>If any entries of <code>x</code> are infinite or <code>NA</code>, the corresponding
results are <code>NA</code>.
</p>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Corless, R, Gonnet, G, Hare, D, Jeffrey, D and Knuth, D (1996),
On the Lambert W function.
<em>Computational Mathematics</em>, <b>5</b>, 325&ndash;359.
</p>
<p>Roy, R and Olver, F (2010),
Lambert W function. In Olver, F, Lozier, D and Boisvert, R (eds.),
<em>NIST Handbook of Mathematical Functions</em>,
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   LambertW(exp(1))
</code></pre>

<hr>
<h2 id='LennardJones'>The Lennard-Jones Potential</h2><span id='topic+LennardJones'></span>

<h3>Description</h3>

<p>Creates the Lennard-Jones pairwise interaction structure
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LennardJones(sigma0=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LennardJones_+3A_sigma0">sigma0</code></td>
<td>

<p>Optional. Initial estimate of the parameter <code class="reqn">\sigma</code>.
A positive number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a pairwise interaction point process with the
Lennard-Jones pair potential (Lennard-Jones, 1924)
each pair of points in the point pattern,
a distance <code class="reqn">d</code> apart,
contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">
    v(d) = \exp \left\{
    -
    4\epsilon
    \left[
       \left(
          \frac{\sigma}{d}
       \right)^{12}
       -
       \left(
          \frac{\sigma}{d}
       \right)^6
    \right]
    \right\}
  </code>
</p>

<p>to the probability density,
where <code class="reqn">\sigma</code> and <code class="reqn">\epsilon</code> are
positive parameters to be estimated.
</p>
<p>See <b>Examples</b> for a plot of this expression.
</p>
<p>This potential causes very strong inhibition between points at short
range, and attraction between points at medium range.
The parameter  <code class="reqn">\sigma</code> is called the
<em>characteristic diameter</em> and controls the scale of interaction.
The parameter <code class="reqn">\epsilon</code> is called the <em>well depth</em>
and determines the strength of attraction.
The potential switches from inhibition to attraction at
<code class="reqn">d=\sigma</code>.
The maximum value of the pair potential is
<code class="reqn">\exp(\epsilon)</code>
occuring at distance
<code class="reqn">d = 2^{1/6} \sigma</code>.
Interaction is usually considered to be negligible for distances
<code class="reqn">d &gt; 2.5 \sigma \max\{1,\epsilon^{1/6}\}</code>.
</p>
<p>This potential is used 
to model interactions between uncharged molecules in statistical physics.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Lennard-Jones pairwise interaction is
yielded by the function <code>LennardJones()</code>.
See the examples below.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the Lennard-Jones interpoint interaction
structure.
</p>


<h3>Rescaling</h3>

<p>To avoid numerical instability,
the interpoint distances <code>d</code> are rescaled
when fitting the model.
</p>
<p>Distances are rescaled by dividing by <code>sigma0</code>.
In the formula for <code class="reqn">v(d)</code> above,
the interpoint distance <code class="reqn">d</code> will be replaced by <code>d/sigma0</code>.
</p>
<p>The rescaling happens automatically by default.
If the argument <code>sigma0</code> is missing or <code>NA</code> (the default),
then <code>sigma0</code> is taken to be the minimum
nearest-neighbour distance in the data point pattern (in the
call to <code><a href="#topic+ppm">ppm</a></code>). 
</p>
<p>If the argument <code>sigma0</code> is given, it should be a positive
number, and it should be a rough estimate of the
parameter <code class="reqn">\sigma</code>. 
</p>
<p>The &ldquo;canonical regular parameters&rdquo; estimated by <code><a href="#topic+ppm">ppm</a></code> are
<code class="reqn">\theta_1 = 4 \epsilon (\sigma/\sigma_0)^{12}</code>
and 
<code class="reqn">\theta_2 = 4 \epsilon (\sigma/\sigma_0)^6</code>.
</p>


<h3>Warnings and Errors</h3>

<p>Fitting the Lennard-Jones model is extremely unstable, because
of the strong dependence between the functions <code class="reqn">d^{-12}</code>
and <code class="reqn">d^{-6}</code>. The fitting algorithm often fails to
converge. Try increasing the number of
iterations of the GLM fitting algorithm, by setting
<code>gcontrol=list(maxit=1e3)</code> in the call to <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>Errors are likely to occur if this model is fitted to a point pattern dataset
which does not exhibit both short-range inhibition and
medium-range attraction between points.  The values of the parameters
<code class="reqn">\sigma</code> and <code class="reqn">\epsilon</code> may be <code>NA</code>
(because the fitted canonical parameters have opposite sign, which
usually occurs when the pattern is completely random).
</p>
<p>An absence of warnings does not mean that the fitted model is sensible.
A negative value of <code class="reqn">\epsilon</code> may be obtained (usually when
the pattern is strongly clustered); this does not correspond
to a valid point process model, but the software does not issue a warning.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Lennard-Jones, J.E. (1924) On the determination of molecular fields.
<em>Proc Royal Soc London A</em> <b>106</b>, 463&ndash;477.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   badfit &lt;- ppm(cells ~1, LennardJones(), rbord=0.1)
   badfit

   fit &lt;- ppm(unmark(longleaf) ~1, LennardJones(), rbord=1)
   fit
   plot(fitin(fit))
   # Note the Longleaf Pines coordinates are rounded to the nearest decimetre
   # (multiple of 0.1 metres) so the apparent inhibition may be an artefact
</code></pre>

<hr>
<h2 id='leverage.ppm'>
Leverage Measure for Spatial Point Process Model
</h2><span id='topic+leverage'></span><span id='topic+leverage.ppm'></span>

<h3>Description</h3>

<p>Computes the leverage measure for a fitted spatial point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage(model, ...)

## S3 method for class 'ppm'
leverage(model, ...,
         drop = FALSE, iScore=NULL, iHessian=NULL, iArgs=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage.ppm_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="leverage.ppm_+3A_...">...</code></td>
<td>

<p>Ignored, except for the arguments <code>dimyx</code> and <code>eps</code>
which are passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to control the spatial resolution of the result.
</p>
</td></tr>
<tr><td><code id="leverage.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical. Whether to include (<code>drop=FALSE</code>) or
exclude (<code>drop=TRUE</code>) contributions from quadrature
points that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="leverage.ppm_+3A_iscore">iScore</code>, <code id="leverage.ppm_+3A_ihessian">iHessian</code></td>
<td>

<p>Components of the score vector and Hessian matrix for
the irregular parameters, if required. See Details.
</p>
</td></tr>
<tr><td><code id="leverage.ppm_+3A_iargs">iArgs</code></td>
<td>

<p>List of extra arguments for the functions <code>iScore</code>,
<code>iHessian</code> if required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>leverage</code> is generic, and
<code>leverage.ppm</code> is the method for objects of class <code>"ppm"</code>.
</p>
<p>Given a fitted spatial point process model <code>model</code>,
the function <code>leverage.ppm</code> computes the leverage of the model,
described in Baddeley, Chang and Song (2013)
and Baddeley, Rubak and Turner (2019).
</p>
<p>The leverage of a spatial point process model
is a function of spatial location, and is typically
displayed as a colour pixel image. 
The leverage value <code class="reqn">h(u)</code> at a spatial location <code class="reqn">u</code> represents the
change in the fitted trend of the fitted point process model that would have
occurred if a data point were to have occurred at the location <code class="reqn">u</code>. 
A relatively large value of <code class="reqn">h()</code> indicates a 
part of the space where the data have a <em>potentially</em>
strong effect on the fitted model (specifically, a strong effect
on the intensity or conditional intensity of the fitted model)
due to the values of the covariates. 
</p>
<p>If the point process model trend has irregular parameters that were
fitted (using <code><a href="#topic+ippm">ippm</a></code>)
then the leverage calculation requires the first and second
derivatives of the log trend with respect to the irregular parameters. 
The argument <code>iScore</code> should be a list,
with one entry for each irregular parameter, of <span class="rlang"><b>R</b></span> functions that compute the
partial derivatives of the log trend (i.e. log intensity or
log conditional intensity) with respect to each irregular
parameter. The argument <code>iHessian</code> should be a list,
with <code class="reqn">p^2</code> entries where <code class="reqn">p</code> is the number of irregular
parameters, of <span class="rlang"><b>R</b></span> functions that compute the second order
partial derivatives of the log trend with respect to each
pair of irregular parameters.  
</p>
<p>The result of <code>leverage.ppm</code> is an object of
class <code>"leverage.ppm"</code>. It can be printed or plotted.
It can be converted to a pixel image
by <code>as.im</code> (see <code><a href="#topic+as.im.leverage.ppm">as.im.leverage.ppm</a></code>).
There are also methods for <code>contour</code>, <code>persp</code>,
<code>[</code>, <code>as.function</code>, 
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>, <code><a href="spatstat.geom.html#topic+domain">domain</a></code>, <code><a href="spatstat.explore.html#topic+Smooth">Smooth</a></code>,
<code><a href="grDevices.html#topic+integral">integral</a></code>,  and <code>mean</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"leverage.ppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2019)
Leverage and influence diagnostics for Gibbs spatial point processes.
<em>Spatial Statistics</em> <b>29</b>, 15&ndash;48.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence.ppm">influence.ppm</a></code>,
<code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>,
<code><a href="#topic+ppmInfluence">ppmInfluence</a></code>,
<code><a href="#topic+plot.leverage.ppm">plot.leverage.ppm</a></code>
<code><a href="#topic+as.function.leverage.ppm">as.function.leverage.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(offline &lt;- !interactive()) op &lt;- spatstat.options(npixel=32, ndummy.min=16)

   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   le &lt;- leverage(fit)
   if(!offline) plot(le)
   mean(le)

if(offline) spatstat.options(op)
</code></pre>

<hr>
<h2 id='leverage.slrm'>
Leverage and Influence Diagnostics for Spatial Logistic Regression
</h2><span id='topic+leverage.slrm'></span><span id='topic+influence.slrm'></span><span id='topic+dfbetas.slrm'></span><span id='topic+dffit.slrm'></span>

<h3>Description</h3>

<p>For a fitted spatial logistic regression model, these functions
compute diagnostics of leverage and influence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slrm'
leverage(model, ...)
## S3 method for class 'slrm'
influence(model, ...)
## S3 method for class 'slrm'
dfbetas(model, ...)
## S3 method for class 'slrm'
dffit(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage.slrm_+3A_model">model</code>, <code id="leverage.slrm_+3A_object">object</code></td>
<td>

<p>A fitted spatial logistic regression model
(object of class <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="leverage.slrm_+3A_...">...</code></td>
<td>

<p>Arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generics
<code><a href="#topic+leverage">leverage</a></code>, <code><a href="stats.html#topic+influence">influence</a></code>,
<code><a href="stats.html#topic+dfbetas">dfbetas</a></code> and <code><a href="#topic+dffit">dffit</a></code>
for the class <code>"slrm"</code>.
</p>
<p>These functions adapt the standard diagnostics for logistic regression
(see <code><a href="stats.html#topic+influence.measures">influence.measures</a></code>) to a
fitted spatial logistic regression model (object of class
<code>"slrm"</code>). This adaptation was described by Baddeley, Chang
and Song (2013).
</p>
<p><code>leverage.slrm</code> computes the leverage value (diagonal of the hat
matrix) for the covariate data in each pixel.
The result is a pixel image.
</p>
<p><code>influence.slrm</code> computes the likelihood influence 
for the data (covariates and presence/absence of points) in each pixel.
The result is a pixel image.
</p>
<p><code>dfbetas.slrm</code> computes the parameter influence 
for the data (covariates and presence/absence of points) in each pixel.
The result is a list of pixel images, one image for each of the
model coefficients in <code>coef(model)</code>. The list can be plotted
immediately.
</p>
<p><code>dffit.slrm</code> computes the total influence 
for the data (covariates and presence/absence of points) in each pixel.
The result is a pixel image.
</p>


<h3>Value</h3>

<p>A pixel image, or a list of pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+influence.measures">influence.measures</a></code>.
</p>
<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>,
<code><a href="#topic+influence.ppm">influence.ppm</a></code>,
<code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>,
<code><a href="#topic+dffit.ppm">dffit.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   H &lt;- unmark(humberside)
   fit &lt;- slrm(H ~ x+y, dimyx=32)
   plot(leverage(fit))
   plot(influence(fit))
   plot(dfbetas(fit))
   plot(dffit(fit))
</code></pre>

<hr>
<h2 id='lgcp.estK'>Fit a Log-Gaussian Cox Point Process by Minimum Contrast</h2><span id='topic+lgcp.estK'></span>

<h3>Description</h3>

<p>Fits a log-Gaussian Cox point process model
to a point pattern dataset by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcp.estK(X, startpar=c(var=1,scale=1),
             covmodel=list(model="exponential"),
             lambda=NULL,
             q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcp.estK_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
log-Gaussian Cox process model.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_covmodel">covmodel</code></td>
<td>

<p>Specification of the covariance model
for the log-Gaussian field. See Details.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_q">q</code>, <code id="lgcp.estK_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_rmin">rmin</code>, <code id="lgcp.estK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="lgcp.estK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits a log-Gaussian Cox point process (LGCP) model
to a point pattern dataset by the Method of Minimum Contrast,
using the K function of the point pattern.
</p>
<p>The shape of the covariance of the LGCP must be specified:
the default is the exponential covariance function,
but other covariance models can be selected.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The <code class="reqn">K</code> function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the <code class="reqn">K</code> function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits a log-Gaussian Cox point process (LGCP)
model to <code>X</code>,  by finding the parameters of the LGCP model
which give the closest match between the
theoretical <code class="reqn">K</code> function of the LGCP model
and the observed <code class="reqn">K</code> function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The model fitted is a stationary, isotropic log-Gaussian Cox process
(Moller and Waagepetersen, 2003, pp. 72-76).
To define this process we start with
a stationary Gaussian random field <code class="reqn">Z</code> in the two-dimensional plane,
with constant mean <code class="reqn">\mu</code> and covariance function <code class="reqn">C(r)</code>.
Given <code class="reqn">Z</code>, we generate a Poisson point process <code class="reqn">Y</code> with intensity
function <code class="reqn">\lambda(u) = \exp(Z(u))</code> at
location <code class="reqn">u</code>. Then <code class="reqn">Y</code> is a log-Gaussian Cox process.
</p>
<p>The <code class="reqn">K</code>-function of the LGCP is
</p>
<p style="text-align: center;"><code class="reqn">
    K(r) = \int_0^r 2\pi s \exp(C(s)) \, {\rm d}s.
  </code>
</p>

<p>The intensity of the LGCP is 
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda = \exp(\mu + \frac{C(0)}{2}).
  </code>
</p>

<p>The covariance function <code class="reqn">C(r)</code> is parametrised in the form
</p>
<p style="text-align: center;"><code class="reqn">
    C(r) = \sigma^2 c(r/\alpha)
  </code>
</p>

<p>where <code class="reqn">\sigma^2</code> and <code class="reqn">\alpha</code> are parameters
controlling the strength and the scale of autocorrelation,
respectively, and <code class="reqn">c(r)</code> is a known covariance function
determining the shape of the covariance. 
The strength and scale parameters
<code class="reqn">\sigma^2</code> and <code class="reqn">\alpha</code>
will be estimated by the algorithm as the values
<code>var</code> and <code>scale</code> respectively.
The template covariance function <code class="reqn">c(r)</code> must be specified
as explained below.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\sigma^2</code>
and <code class="reqn">\alpha</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>The template covariance function <code class="reqn">c(r)</code> is specified
using the argument <code>covmodel</code>. This should be of the form
<code>list(model="modelname", ...)</code> where
<code>modelname</code> is a string identifying the template model
as explained below, and  <code>...</code> are optional arguments of the
form <code>tag=value</code> giving the values of parameters controlling the
<em>shape</em> of the template model.
The default is the exponential covariance
<code class="reqn">c(r) = e^{-r}</code>
so that the scaled covariance is 
</p>
<p style="text-align: center;"><code class="reqn">
    C(r) = \sigma^2 e^{-r/\alpha}.
  </code>
</p>

<p>For a list of available models see <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is considerably slower than <code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code>
because of the computation time required for the integral
in the <code class="reqn">K</code>-function.
</p>
<p>Computation can be accelerated, at the cost of less accurate results,
by setting <code>spatstat.options(fastK.lgcp=TRUE)</code>. 
</p>


<h3>Author(s)</h3>

<p>Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
Further modifications by Rasmus Waagepetersen
and Shen Guochun, and by Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Moller, J, Syversveen, A. and Waagepetersen, R. (1998)
Log Gaussian Cox Processes.
<em>Scandinavian Journal of Statistics</em> <b>25</b>, 451&ndash;482.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code> and
<code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code> for alternative methods of fitting LGCP.
</p>
<p><code><a href="#topic+matclust.estK">matclust.estK</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code> for other models.
</p>
<p><code><a href="#topic+mincontrast">mincontrast</a></code> for the generic minimum contrast
fitting algorithm, including important parameters that affect
the accuracy of the fit.
</p>
<p><code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> for the <code class="reqn">K</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    if(interactive()) {
      u &lt;- lgcp.estK(redwood)
      print(u)
      plot(u)
    } else {
      # faster - better starting point
      u &lt;- lgcp.estK(redwood, c(var=1.05, scale=0.1))
    }
  
    
    if(FALSE) {
      ## takes several minutes!
      lgcp.estK(redwood, covmodel=list(model="matern", nu=0.3))
    }
</code></pre>

<hr>
<h2 id='lgcp.estpcf'>Fit a Log-Gaussian Cox Point Process by Minimum Contrast</h2><span id='topic+lgcp.estpcf'></span>

<h3>Description</h3>

<p>Fits a log-Gaussian Cox point process model
to a point pattern dataset by the Method of Minimum Contrast
using the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcp.estpcf(X,
            startpar=c(var=1,scale=1),
            covmodel=list(model="exponential"),
            lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ..., pcfargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcp.estpcf_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
log-Gaussian Cox process model.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_covmodel">covmodel</code></td>
<td>

<p>Specification of the covariance model
for the log-Gaussian field. See Details.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_q">q</code>, <code id="lgcp.estpcf_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_rmin">rmin</code>, <code id="lgcp.estpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="lgcp.estpcf_+3A_pcfargs">pcfargs</code></td>
<td>

<p>Optional list containing arguments passed to <code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
to control the smoothing in the estimation of the
pair correlation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits a log-Gaussian Cox point process (LGCP) model
to a point pattern dataset by the Method of Minimum Contrast,
using the estimated pair correlation function of the point pattern.
</p>
<p>The shape of the covariance of the LGCP must be specified:
the default is the exponential covariance function,
but other covariance models can be selected.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The pair correlation function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the pair correlation function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits a log-Gaussian Cox point process (LGCP)
model to <code>X</code>,  by finding the parameters of the LGCP model
which give the closest match between the
theoretical pair correlation function of the LGCP model
and the observed pair correlation function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The model fitted is a stationary, isotropic log-Gaussian Cox process
(Moller and Waagepetersen, 2003, pp. 72-76).
To define this process we start with
a stationary Gaussian random field <code class="reqn">Z</code> in the two-dimensional plane,
with constant mean <code class="reqn">\mu</code> and covariance function <code class="reqn">C(r)</code>.
Given <code class="reqn">Z</code>, we generate a Poisson point process <code class="reqn">Y</code> with intensity
function <code class="reqn">\lambda(u) = \exp(Z(u))</code> at
location <code class="reqn">u</code>. Then <code class="reqn">Y</code> is a log-Gaussian Cox process.
</p>
<p>The theoretical pair correlation function of the LGCP is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = \exp(C(s))
  </code>
</p>

<p>The intensity of the LGCP is 
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda = \exp(\mu + \frac{C(0)}{2}).
  </code>
</p>

<p>The covariance function <code class="reqn">C(r)</code> takes the form
</p>
<p style="text-align: center;"><code class="reqn">
    C(r) = \sigma^2 c(r/\alpha)
  </code>
</p>

<p>where <code class="reqn">\sigma^2</code> and <code class="reqn">\alpha</code> are parameters
controlling the strength and the scale of autocorrelation,
respectively, and <code class="reqn">c(r)</code> is a known covariance function
determining the shape of the covariance. 
The strength and scale parameters
<code class="reqn">\sigma^2</code> and <code class="reqn">\alpha</code>
will be estimated by the algorithm.
The template covariance function <code class="reqn">c(r)</code> must be specified
as explained below.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\sigma^2</code>
and <code class="reqn">\alpha</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>The template covariance function <code class="reqn">c(r)</code> is specified
using the argument <code>covmodel</code>. This should be of the form
<code>list(model="modelname", ...)</code> where
<code>modelname</code> is a string identifying the template model
as explained below, and  <code>...</code> are optional arguments of the
form <code>tag=value</code> giving the values of parameters controlling the
<em>shape</em> of the template model.
The default is the exponential covariance
<code class="reqn">c(r) = e^{-r}</code>
so that the scaled covariance is 
</p>
<p style="text-align: center;"><code class="reqn">
    C(r) = \sigma^2 e^{-r/\alpha}.
  </code>
</p>

<p>For a list of available models see <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
with modifications by Shen Guochun and 
Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Moller, J.,
Syversveen, A. and Waagepetersen, R. (1998)
Log Gaussian Cox Processes.
<em>Scandinavian Journal of Statistics</em> <b>25</b>, 451&ndash;482.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code> and <code><a href="#topic+lgcp.estK">lgcp.estK</a></code>
for alternative methods of fitting LGCP.
</p>
<p><code><a href="#topic+matclust.estpcf">matclust.estpcf</a></code>,
<code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code> for other models.
</p>
<p><code><a href="#topic+mincontrast">mincontrast</a></code> for the generic minimum contrast
fitting algorithm, including important parameters that affect
the accuracy of the fit.
</p>
<p><code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> for the pair correlation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- lgcp.estpcf(redwood, c(var=1, scale=0.1))
    u
    plot(u)
    lgcp.estpcf(redwood, covmodel=list(model="matern", nu=0.3))
</code></pre>

<hr>
<h2 id='logLik.dppm'>Log Likelihood and AIC for Fitted Determinantal Point Process Model</h2><span id='topic+logLik.dppm'></span><span id='topic+AIC.dppm'></span><span id='topic+extractAIC.dppm'></span><span id='topic+nobs.dppm'></span>

<h3>Description</h3>

<p>Extracts the log Palm likelihood, deviance, and AIC
of a fitted determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dppm'
logLik(object, ...)
## S3 method for class 'dppm'
AIC(object, ..., k=2)
## S3 method for class 'dppm'
extractAIC(fit, scale=0, k=2, ...)
## S3 method for class 'dppm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.dppm_+3A_object">object</code>, <code id="logLik.dppm_+3A_fit">fit</code></td>
<td>
<p>Fitted point process model.
An object of class <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="logLik.dppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.dppm_+3A_scale">scale</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.dppm_+3A_k">k</code></td>
<td>
<p>Numeric value specifying the weight of the
equivalent degrees of freedom in the AIC. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>  and
<code><a href="stats.html#topic+nobs">nobs</a></code>
for the class <code>"dppm"</code>.
</p>
<p>An object of class <code>"dppm"</code> represents a fitted
Cox or cluster point process model.
It is obtained from the model-fitting function <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p>These methods apply only when the model was fitted
by maximising the Palm likelihood (Tanaka et al, 2008)
by calling <code><a href="#topic+dppm">dppm</a></code> with the argument <code>method="palm"</code>.
</p>
<p>The method <code>logLik.dppm</code> computes the
maximised value of the log Palm likelihood for the fitted model <code>object</code>.
</p>
<p>The methods <code>AIC.dppm</code> and <code>extractAIC.dppm</code> compute the
Akaike Information Criterion AIC for the fitted model
based on the Palm likelihood (Tanaka et al, 2008)
</p>
<p style="text-align: center;"><code class="reqn">
    AIC = -2 \log(PL) + k \times \mbox{edf}
  </code>
</p>

<p>where <code class="reqn">PL</code> is the maximised Palm likelihood of the fitted model,
and <code class="reqn">\mbox{edf}</code> is the effective degrees of freedom
of the model.
</p>
<p>The method <code>nobs.dppm</code> returns the number of points
in the original data point pattern to which the model was fitted.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+step">step</a></code> uses these methods, but it does
not work for determinantal models yet due to a missing implementation
of <code>update.dppm</code>.
</p>


<h3>Value</h3>

<p><code>logLik</code> returns a numerical value, belonging to the class
<code>"logLik"</code>, with an attribute <code>"df"</code> giving the degrees of
freedom.
</p>
<p><code>AIC</code> returns a numerical value.
</p>
<p><code>extractAIC</code> returns a numeric vector of length 2
containing the degrees of freedom and the AIC value.
</p>
<p><code>nobs</code> returns an integer value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Tanaka, U. and Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for
Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43&ndash;57.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+logLik.ppm">logLik.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- dppm(swedishpines ~ x, dppGauss(), method="palm")
  nobs(fit)
  logLik(fit)
  extractAIC(fit)
  AIC(fit)
</code></pre>

<hr>
<h2 id='logLik.kppm'>Log Likelihood and AIC for Fitted Cox or Cluster Point Process Model</h2><span id='topic+logLik.kppm'></span><span id='topic+AIC.kppm'></span><span id='topic+extractAIC.kppm'></span><span id='topic+nobs.kppm'></span>

<h3>Description</h3>

<p>Extracts the log composite likelihood, deviance, and AIC
of a fitted Cox or cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kppm'
logLik(object, ...)
## S3 method for class 'kppm'
AIC(object, ..., k=2)
## S3 method for class 'kppm'
extractAIC(fit, scale=0, k=2, ...)
## S3 method for class 'kppm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.kppm_+3A_object">object</code>, <code id="logLik.kppm_+3A_fit">fit</code></td>
<td>
<p>Fitted point process model.
An object of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="logLik.kppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.kppm_+3A_scale">scale</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.kppm_+3A_k">k</code></td>
<td>
<p>Numeric value specifying the weight of the
equivalent degrees of freedom in the AIC. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>  and
<code><a href="stats.html#topic+nobs">nobs</a></code>
for the class <code>"kppm"</code>.
</p>
<p>An object of class <code>"kppm"</code> represents a fitted
Cox or cluster point process model.
It is obtained from the model-fitting function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>These methods apply only when the model was fitted
by maximising a composite likelihood:
either the Palm likelihood (Tanaka et al, 2008)
or the second order composite likelihood (Guan, 2006),
by calling <code><a href="#topic+kppm">kppm</a></code> with the argument <code>method="palm"</code>
or <code>method="clik2"</code> respectively. 
</p>
<p>The method <code>logLik.kppm</code> computes the 
maximised value of the log composite likelihood
for the fitted model <code>object</code>.
</p>
<p>The methods <code>AIC.kppm</code> and <code>extractAIC.kppm</code> compute the
Akaike Information Criterion AIC for the fitted model
based on the composite likelihood
</p>
<p style="text-align: center;"><code class="reqn">
    AIC = -2 \log(CL) + k \times \mbox{edf}
  </code>
</p>

<p>where <code class="reqn">CL</code> is the maximised composite likelihood of the fitted model,
and <code class="reqn">\mbox{edf}</code> is the effective degrees of freedom
of the model. 
</p>
<p>The method <code>nobs.kppm</code> returns the number of points
in the original data point pattern to which the model was fitted.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+step">step</a></code> uses these methods.
</p>


<h3>Value</h3>

<p><code>logLik</code> returns a numerical value, belonging to the class
<code>"logLik"</code>, with an attribute <code>"df"</code> giving the degrees of
freedom.
</p>
<p><code>AIC</code> returns a numerical value.
</p>
<p><code>extractAIC</code> returns a numeric vector of length 2
containing the degrees of freedom and the AIC value.
</p>
<p><code>nobs</code> returns an integer value.
</p>


<h3>Model comparison</h3>

<p>The values of log-likelihood and AIC returned by these functions
are based on the <em>composite likelihood</em> of the cluster process or Cox
process model. They are available only when the model was fitted
using <code>method="palm"</code> or <code>method="clik2"</code>.
</p>
<p>For model comparison and model selection,
it is valid to compare the <code>logLik</code> values,
or to compare the <code>AIC</code> values, but only when
all the models are of class <code>"kppm"</code>
and were fitted using the same <code>method</code>.
</p>
<p>For <code>method="palm"</code> some theoretical justification was provided by
Tanaka et al (2008).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Guan, Y. (2006) 
A composite likelihood approach in fitting spatial point process
models.
<em>Journal of the American Statistical Association</em>
<b>101</b>, 1502&ndash;1512.
</p>
<p>Tanaka, U. and Ogata, Y. and Stoyan, D. (2008) 
Parameter estimation and model selection for
Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43&ndash;57.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>, 
<code><a href="#topic+logLik.ppm">logLik.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ x, "Thomas", method="palm")
  nobs(fit)
  logLik(fit)
  extractAIC(fit)
  AIC(fit)
  step(fit)
</code></pre>

<hr>
<h2 id='logLik.mppm'>Log Likelihood and AIC for Multiple Point Process Model</h2><span id='topic+logLik.mppm'></span><span id='topic+AIC.mppm'></span><span id='topic+extractAIC.mppm'></span><span id='topic+nobs.mppm'></span><span id='topic+getCall.mppm'></span><span id='topic+terms.mppm'></span>

<h3>Description</h3>

<p>For a point process model that has been fitted to multiple point
patterns, these functions extract the log likelihood and AIC,
or analogous quantities based on the pseudolikelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'mppm'
logLik(object, ..., warn=TRUE)

 ## S3 method for class 'mppm'
AIC(object, ..., k=2, takeuchi=TRUE)

 ## S3 method for class 'mppm'
extractAIC(fit, scale = 0, k = 2, ..., takeuchi = TRUE) 

 ## S3 method for class 'mppm'
nobs(object, ...)

 ## S3 method for class 'mppm'
getCall(x, ...)

 ## S3 method for class 'mppm'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.mppm_+3A_object">object</code>, <code id="logLik.mppm_+3A_fit">fit</code>, <code id="logLik.mppm_+3A_x">x</code></td>
<td>

<p>Fitted point process model (fitted to multiple point
patterns). An object of class <code>"mppm"</code>.
</p>
</td></tr>
<tr><td><code id="logLik.mppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.mppm_+3A_warn">warn</code></td>
<td>

<p>If <code>TRUE</code>, a warning is given when the
pseudolikelihood is returned instead of the likelihood.
</p>
</td></tr>
<tr><td><code id="logLik.mppm_+3A_scale">scale</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.mppm_+3A_k">k</code></td>
<td>
<p>Numeric value specifying the weight of the
equivalent degrees of freedom in the AIC. See Details.
</p>
</td></tr>
<tr><td><code id="logLik.mppm_+3A_takeuchi">takeuchi</code></td>
<td>

<p>Logical value specifying whether to use the Takeuchi penalty
(<code>takeuchi=TRUE</code>) or the
number of fitted parameters (<code>takeuchi=FALSE</code>)
in calculating AIC.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+AIC">AIC</a></code>,
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>,
<code><a href="stats.html#topic+terms">terms</a></code> and
<code><a href="stats.html#topic+update">getCall</a></code> 
for the class <code>"mppm"</code>.
</p>
<p>An object of class <code>"mppm"</code> represents a fitted
Poisson or Gibbs point process model fitted to several point patterns.
It is obtained from the model-fitting function <code><a href="#topic+mppm">mppm</a></code>.
</p>
<p>The method <code>logLik.mppm</code> extracts the 
maximised value of the log likelihood for the fitted model
(as approximated by quadrature using the Berman-Turner approximation).
If <code>object</code> is not a Poisson process, the maximised log
<em>pseudolikelihood</em> is returned, with a warning.
</p>
<p>The Akaike Information Criterion AIC for a fitted model is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    AIC = -2 \log(L) + k \times \mbox{penalty}
  </code>
</p>

<p>where <code class="reqn">L</code> is the maximised likelihood of the fitted model,
and <code class="reqn">\mbox{penalty}</code> is a penalty for model complexity,
usually equal to the effective degrees of freedom of the model.
The method <code>extractAIC.mppm</code> returns the <em>analogous</em> quantity
<code class="reqn">AIC*</code> in which <code class="reqn">L</code> is replaced by <code class="reqn">L*</code>,
the quadrature approximation
to the likelihood (if <code>fit</code> is a Poisson model)
or the pseudolikelihood (if <code>fit</code> is a Gibbs model).
</p>
<p>The <code class="reqn">\mbox{penalty}</code> term is calculated
as follows. If <code>takeuchi=FALSE</code> then <code class="reqn">\mbox{penalty}</code> is
the number of fitted parameters. If <code>takeuchi=TRUE</code> then
<code class="reqn">\mbox{penalty} = \mbox{trace}(J H^{-1})</code>
where <code class="reqn">J</code> and <code class="reqn">H</code> are the estimated variance and hessian,
respectively, of the composite score.
These two choices are equivalent for a Poisson process.
</p>
<p>The method <code>nobs.mppm</code> returns the total number of points
in the original data point patterns to which the model was fitted.
</p>
<p>The method <code>getCall.mppm</code> extracts the original call to
<code><a href="#topic+mppm">mppm</a></code> which caused the model to be fitted.
</p>
<p>The method <code>terms.mppm</code> extracts the covariate terms in the
model formula as a <code>terms</code> object. Note that these terms do not
include the interaction component of the model.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+step">step</a></code> uses these methods.
</p>


<h3>Value</h3>

<p>See the help files for the corresponding generic functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- mppm(Bugs ~ x, hyperframe(Bugs=waterstriders))
  logLik(fit)
  AIC(fit)
  nobs(fit)
  getCall(fit)
</code></pre>

<hr>
<h2 id='logLik.ppm'>Log Likelihood and AIC for Point Process Model</h2><span id='topic+logLik.ppm'></span><span id='topic+deviance.ppm'></span><span id='topic+AIC.ppm'></span><span id='topic+extractAIC.ppm'></span><span id='topic+nobs.ppm'></span>

<h3>Description</h3>

<p>Extracts the log likelihood, deviance, and AIC
of a fitted Poisson point process
model, or analogous quantities based on the pseudolikelihood
or logistic likelihood for a fitted Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
logLik(object, ..., new.coef=NULL, warn=TRUE, absolute=FALSE)

## S3 method for class 'ppm'
deviance(object, ...)

## S3 method for class 'ppm'
AIC(object, ..., k=2, takeuchi=TRUE)

## S3 method for class 'ppm'
extractAIC(fit, scale=0, k=2, ..., takeuchi=TRUE)

## S3 method for class 'ppm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.ppm_+3A_object">object</code>, <code id="logLik.ppm_+3A_fit">fit</code></td>
<td>
<p>Fitted point process model.
An object of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_warn">warn</code></td>
<td>

<p>If <code>TRUE</code>, a warning is given when the
pseudolikelihood or logistic likelihood
is returned instead of the likelihood.
</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_absolute">absolute</code></td>
<td>

<p>Logical value indicating whether to include 
constant terms in the loglikelihood. 
</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_scale">scale</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_k">k</code></td>
<td>
<p>Numeric value specifying the weight of the
equivalent degrees of freedom in the AIC. See Details.
</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="logLik.ppm_+3A_takeuchi">takeuchi</code></td>
<td>

<p>Logical value specifying whether to use the Takeuchi penalty
(<code>takeuchi=TRUE</code>) or the
number of fitted parameters (<code>takeuchi=FALSE</code>)
in calculating AIC.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>,
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>  and
<code><a href="stats.html#topic+nobs">nobs</a></code>
for the class <code>"ppm"</code>.
</p>
<p>An object of class <code>"ppm"</code> represents a fitted
Poisson or Gibbs point process model.
It is obtained from the model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The method <code>logLik.ppm</code> computes the 
maximised value of the log likelihood for the fitted model <code>object</code>
(as approximated by quadrature using the Berman-Turner approximation)
is extracted. If <code>object</code> is not a Poisson process, the maximised log
<em>pseudolikelihood</em> is returned, with a warning (if <code>warn=TRUE</code>).
</p>
<p>The Akaike Information Criterion AIC for a fitted model is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    AIC = -2 \log(L) + k \times \mbox{penalty}
  </code>
</p>

<p>where <code class="reqn">L</code> is the maximised likelihood of the fitted model,
and <code class="reqn">\mbox{penalty}</code> is a penalty for model complexity,
usually equal to the effective degrees of freedom of the model.
The method <code>extractAIC.ppm</code> returns the <em>analogous</em> quantity
<code class="reqn">AIC*</code> in which <code class="reqn">L</code> is replaced by <code class="reqn">L*</code>,
the quadrature approximation
to the likelihood (if <code>fit</code> is a Poisson model)
or the pseudolikelihood or logistic likelihood
(if <code>fit</code> is a Gibbs model).
</p>
<p>The <code class="reqn">\mbox{penalty}</code> term is calculated
as follows. If <code>takeuchi=FALSE</code> then <code class="reqn">\mbox{penalty}</code> is
the number of fitted parameters. If <code>takeuchi=TRUE</code> then
<code class="reqn">\mbox{penalty} = \mbox{trace}(J H^{-1})</code>
where <code class="reqn">J</code> and <code class="reqn">H</code> are the estimated variance and hessian,
respectively, of the composite score.
These two choices are equivalent for a Poisson process.
</p>
<p>The method <code>nobs.ppm</code> returns the number of points
in the original data point pattern to which the model was fitted.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+step">step</a></code> uses these methods.
</p>


<h3>Value</h3>

<p><code>logLik</code> returns a numerical value, belonging to the class
<code>"logLik"</code>, with an attribute <code>"df"</code> giving the degrees of
freedom.
</p>
<p><code>AIC</code> returns a numerical value.
</p>
<p><code>extractAIC</code> returns a numeric vector of length 2
containing the degrees of freedom and the AIC value.
</p>
<p><code>nobs</code> returns an integer value.
</p>


<h3>Model comparison</h3>

<p>The values of <code>logLik</code> and <code>AIC</code> returned by these functions
are based on the <em>pseudolikelihood</em> of the Gibbs point process
model. If the model is a Poisson process, then the pseudolikelihood
is the same as the likelihood, but for other Gibbs models,
the pseudolikelihood is different from the likelihood (and the
likelihood of a Gibbs model is hard to compute).
</p>
<p>For model comparison and model selection,
it is valid to compare the <code>logLik</code> values,
or to compare the <code>AIC</code> values, but only when
all the models are of class <code>"ppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Varin, C. and Vidoni, P. (2005)
A note on composite likelihood inference and model selection.
<em>Biometrika</em> <b>92</b>, 519&ndash;528.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,  
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="#topic+anova.ppm">anova.ppm</a></code>,
<code><a href="#topic+coef.ppm">coef.ppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="#topic+formula.ppm">formula.ppm</a></code>,
<code><a href="#topic+model.frame.ppm">model.frame.ppm</a></code>,
<code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="#topic+summary.ppm">summary.ppm</a></code>,
<code><a href="#topic+terms.ppm">terms.ppm</a></code>,
<code><a href="#topic+update.ppm">update.ppm</a></code>,
<code><a href="#topic+vcov.ppm">vcov.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells, ~x)
  nobs(fit)
  logLik(fit)
  deviance(fit)
  extractAIC(fit)
  AIC(fit)
  step(fit)
</code></pre>

<hr>
<h2 id='logLik.slrm'>
Loglikelihood of Spatial Logistic Regression
</h2><span id='topic+logLik.slrm'></span>

<h3>Description</h3>

<p>Computes the (maximised) loglikelihood of a fitted
Spatial Logistic Regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
logLik(object, ..., adjust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.slrm_+3A_object">object</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="logLik.slrm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="logLik.slrm_+3A_adjust">adjust</code></td>
<td>

<p>Logical value indicating whether to adjust the loglikelihood
of the model to make it comparable with a point process
likelihood. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+logLik">logLik</a></code> for fitted spatial logistic
regression models (objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>). It computes the log-likelihood
of a fitted spatial logistic regression model.
</p>
<p>If <code>adjust=FALSE</code>, the loglikelihood is computed
using the standard formula for the loglikelihood of a
logistic regression model for a finite set of (pixel) observations.
</p>
<p>If <code>adjust=TRUE</code> then the loglikelihood is adjusted so that it
is approximately comparable with the likelihood of a point process
in continuous space, by subtracting the value
<code class="reqn">n \log(a)</code>
where <code class="reqn">n</code> is the number of points in the original point pattern
dataset, and <code class="reqn">a</code> is the area of one pixel.
</p>


<h3>Value</h3>

<p>A numerical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- slrm(X ~ x+y)
  logLik(fit)
  logLik(fit, adjust=FALSE)
</code></pre>

<hr>
<h2 id='lurking'>Lurking Variable Plot</h2><span id='topic+lurking'></span><span id='topic+lurking.ppp'></span><span id='topic+lurking.ppm'></span>

<h3>Description</h3>

<p>Plot spatial point process residuals against a covariate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lurking(object, ...)

## S3 method for class 'ppm'
lurking(object, covariate,
                    type="eem",
                    cumulative=TRUE,
                    ...,
                    plot.it = TRUE,
                    plot.sd = is.poisson(object),
                    clipwindow=default.clipwindow(object),
                    rv = NULL,
                    envelope=FALSE, nsim=39, nrank=1,
                    typename,
                    covname,
                    oldstyle=FALSE,
                    check=TRUE,
                    verbose=TRUE,
                    nx=128,
                    splineargs=list(spar=0.5),
                    internal=NULL) 

## S3 method for class 'ppp'
lurking(object, covariate,
                    type="eem",
                    cumulative=TRUE,
                    ...,
                    plot.it = TRUE,
                    plot.sd = is.poisson(object),
                    clipwindow=default.clipwindow(object),
                    rv = NULL,
                    envelope=FALSE, nsim=39, nrank=1,
                    typename,
                    covname,
                    oldstyle=FALSE,
                    check=TRUE,
                    verbose=TRUE,
                    nx=128,
                    splineargs=list(spar=0.5),
                    internal=NULL) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lurking_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which diagnostics should be produced. This object
is usually obtained from <code><a href="#topic+ppm">ppm</a></code>. Alternatively,
<code>object</code> may be a point pattern (object of class
<code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="lurking_+3A_covariate">covariate</code></td>
<td>

<p>The covariate against which residuals should be plotted.
Either a numeric vector, a pixel image, or an <code>expression</code>.
See <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_type">type</code></td>
<td>

<p>String indicating the type of residuals or weights to be computed.
Choices include <code>"eem"</code>,
<code>"raw"</code>, <code>"inverse"</code> and <code>"pearson"</code>.
See <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> for all possible choices.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_cumulative">cumulative</code></td>
<td>

<p>Logical flag indicating whether to plot a
cumulative sum of marks (<code>cumulative=TRUE</code>) or the derivative
of this sum, a marginal density of the smoothed residual field
(<code>cumulative=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="lurking_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code> to control the plot behaviour.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_plot.it">plot.it</code></td>
<td>

<p>Logical value indicating whether 
plots should be shown. If <code>plot.it=FALSE</code>, only
the computed coordinates for the plots are returned.
See <em>Value</em>.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_plot.sd">plot.sd</code></td>
<td>

<p>Logical value indicating whether 
error bounds should be added to plot.
The default is <code>TRUE</code> for Poisson models and
<code>FALSE</code> for non-Poisson models. See Details.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_clipwindow">clipwindow</code></td>
<td>

<p>If not <code>NULL</code> this argument indicates that residuals shall
only be computed inside a subregion of the window containing the
original point pattern data. Then <code>clipwindow</code> should be
a window object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_rv">rv</code></td>
<td>

<p>Usually absent. 
If this argument is present, the point process residuals will not be
calculated from the fitted model <code>object</code>,
but will instead be taken directly from <code>rv</code>. 
</p>
</td></tr>
<tr><td><code id="lurking_+3A_envelope">envelope</code></td>
<td>

<p>Logical value indicating whether to compute simulation envelopes
for the plot. Alternatively <code>envelope</code> may be a list of
point patterns to use for computing the simulation envelopes,
or an object of class <code>"envelope"</code> containing simulated point
patterns.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns to be generated
to produce the simulation envelope, if <code>envelope=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_typename">typename</code></td>
<td>

<p>Usually absent. 
If this argument is present, it should be a string, and will be used
(in the axis labels of plots) to describe the type of residuals.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_covname">covname</code></td>
<td>

<p>A string name for the covariate, to be used in axis labels of plots.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_oldstyle">oldstyle</code></td>
<td>

<p>Logical flag indicating whether error bounds should be plotted
using the approximation given in the original paper
(<code>oldstyle=TRUE</code>),
or using the correct asymptotic formula (<code>oldstyle=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="lurking_+3A_check">check</code></td>
<td>

<p>Logical flag indicating whether the integrity of the data structure
in <code>object</code> should be checked.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating
whether to print progress reports during Monte Carlo simulation.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_nx">nx</code></td>
<td>

<p>Integer. Number of covariate values to be used in the plot.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_splineargs">splineargs</code></td>
<td>

<p>A list of arguments passed to <code>smooth.spline</code>
for the estimation of the derivatives in the case <code>cumulative=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="lurking_+3A_internal">internal</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a &lsquo;lurking variable&rsquo; plot for a
fitted point process model. 
Residuals from the model represented by <code>object</code>
are plotted against the covariate specified by <code>covariate</code>.
This plot can be used to reveal departures from the fitted model,
in particular, to reveal that the point pattern depends on the covariate.
</p>
<p>The function <code>lurking</code> is generic, with methods for
<code>ppm</code> and <code>ppp</code> documented here, and possibly other methods.
</p>
<p>The argument <code>object</code> would usually be a fitted point process model
(object of class <code>"ppm"</code>) produced by the
model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>). If
<code>object</code> is a point pattern (object of class <code>"ppp"</code>) then
the model is taken to be the uniform Poisson process (Complete
Spatial Randomness) fitted to this point pattern.
</p>
<p>First the residuals from the fitted model (Baddeley et al, 2004)
are computed at each quadrature point,
or alternatively the &lsquo;exponential energy marks&rsquo; (Stoyan and Grabarnik,
1991) are computed at each data point.
The argument <code>type</code> selects the type of
residual or weight. See <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> for options
and explanation.
</p>
<p>A lurking variable plot for point processes (Baddeley et al, 2004)
displays either the cumulative sum of residuals/weights
(if <code>cumulative = TRUE</code>) or a kernel-weighted average of the
residuals/weights (if <code>cumulative = FALSE</code>) plotted against
the covariate. The empirical plot (solid lines) is shown
together with its expected value assuming the model is true
(dashed lines) and optionally also the pointwise
two-standard-deviation limits (grey shading).
</p>
<p>To be more precise, let <code class="reqn">Z(u)</code> denote the value of the covariate
at a spatial location <code class="reqn">u</code>. 
</p>

<ul>
<li>
<p>If <code>cumulative=TRUE</code> then we plot <code class="reqn">H(z)</code> against <code class="reqn">z</code>,
where <code class="reqn">H(z)</code> is the sum of the residuals 
over all quadrature points where the covariate takes
a value less than or equal to <code class="reqn">z</code>, or the sum of the
exponential energy weights over all data points where the covariate
takes a value less than or equal to <code class="reqn">z</code>.
</p>
</li>
<li>
<p>If <code>cumulative=FALSE</code> then we plot <code class="reqn">h(z)</code> against <code class="reqn">z</code>,
where <code class="reqn">h(z)</code> is the derivative of <code class="reqn">H(z)</code>,
computed approximately by spline smoothing.
</p>
</li></ul>

<p>For the point process residuals <code class="reqn">E(H(z)) = 0</code>,
while for the exponential energy weights
<code class="reqn">E(H(z)) = </code> area of the subset of the window 
satisfying <code class="reqn">Z(u) &lt;= z</code>. 
</p>
<p>If the empirical and theoretical curves deviate substantially
from one another, the interpretation is that the fitted model does
not correctly account for dependence on the covariate.
The correct form (of the spatial trend part of the model)
may be suggested by the shape of the plot.
</p>
<p>If <code>plot.sd = TRUE</code>, then superimposed on the lurking variable
plot are the pointwise
two-standard-deviation error limits for <code class="reqn">H(x)</code> calculated for the
inhomogeneous Poisson process. The default is <code>plot.sd = TRUE</code>
for Poisson models and <code>plot.sd = FALSE</code> for non-Poisson
models.
</p>
<p>By default, the two-standard-deviation limits are calculated
from the exact formula for the asymptotic variance
of the residuals under the asymptotic normal approximation,
equation (37) of Baddeley et al (2006).
However, for compatibility with the original paper
of Baddeley et al (2005), if <code>oldstyle=TRUE</code>,
the two-standard-deviation limits are calculated
using the innovation variance, an over-estimate of the true
variance of the residuals.
</p>
<p>The argument <code>covariate</code> is either a numeric vector, a pixel
image, or an R language expression.
If it is a numeric vector, it is assumed to contain
the values of the covariate for each of the quadrature points
in the fitted model. The quadrature points can be extracted by
<code><a href="#topic+quad.ppm">quad.ppm</a>(object)</code>.
</p>
<p>If <code>covariate</code> is a pixel image, it is assumed to contain the
values of the covariate at each location in the window. The values of
this image at the quadrature points will be extracted.
</p>
<p>Alternatively, if <code>covariate</code>
is an <code>expression</code>, it will be evaluated in the same environment
as the model formula used in fitting the model <code>object</code>. It must
yield a vector of the same length as the number of quadrature points.
The expression may contain the terms <code>x</code> and <code>y</code> representing the
cartesian coordinates, and may also contain other variables that were
available when the model was fitted. Certain variable names are
reserved words; see <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>Note that lurking variable plots for the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
are also generated by <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>, amongst other
types of diagnostic plots. This function is more general in that it
enables the user to plot the residuals against any chosen covariate
that may have been present.
</p>
<p>For advanced use, even the values of the residuals/weights
can be altered. If the argument <code>rv</code> is present,
the residuals will not be calculated from the fitted model
<code>object</code> but will instead be taken directly from the object <code>rv</code>.
If <code>type = "eem"</code> then <code>rv</code> should be similar to the
return value of <code><a href="#topic+eem">eem</a></code>, namely, a numeric vector
with length equal to the number of data points in the original point
pattern. Otherwise, <code>rv</code> should be
similar to the return value of <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
that is, <code>rv</code> should be an object of class
<code>"msr"</code> (see <code><a href="#topic+msr">msr</a></code>) representing a signed measure.
</p>


<h3>Value</h3>

<p>The (invisible) return value is an object 
belonging to the class <code>"lurk"</code>, for which there
are methods for <code>plot</code> and <code>print</code>.
</p>
<p>This object is a list containing two dataframes
<code>empirical</code> and <code>theoretical</code>. 
The first dataframe <code>empirical</code> contains columns
<code>covariate</code> and <code>value</code> giving the coordinates of the
lurking variable plot. The second dataframe <code>theoretical</code>
contains columns <code>covariate</code>, <code>mean</code> and <code>sd</code>
giving the coordinates of the plot of the theoretical mean
and standard deviation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2006)
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>
<p>Stoyan, D. and Grabarnik, P. (1991)
Second-order characteristics for stochastic structures connected with
Gibbs point processes.
<em>Mathematische Nachrichten</em>, 151:95&ndash;100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+qqplot.ppm">qqplot.ppm</a></code>,
<code><a href="#topic+eem">eem</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  (a &lt;- lurking(nztrees, expression(x), type="raw"))
  fit &lt;- ppm(nztrees ~x, Poisson(), nd=128)
  (b &lt;- lurking(fit, expression(x), type="raw"))
  lurking(fit, expression(x), type="raw", cumulative=FALSE)
</code></pre>

<hr>
<h2 id='lurking.mppm'>
Lurking Variable Plot for Multiple Point Patterns
</h2><span id='topic+lurking.mppm'></span>

<h3>Description</h3>

<p>Generate a lurking variable plot of spatial point process residuals
against a covariate, for a model fitted to several point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppm'
lurking(object, covariate, type="eem",
                       ...,
                       separate = FALSE, 
                       plot.it = TRUE,
                       covname, oldstyle = FALSE, nx = 512, main="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lurking.mppm_+3A_object">object</code></td>
<td>

<p>The fitted model. An object of class <code>"mppm"</code> representing a
point process model fitted to several point patterns.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_covariate">covariate</code></td>
<td>

<p>The covariate to be used on the horizontal axis.
Either an <code>expression</code> which can be evaluated in the
original data, or a list of pixel images, one image for each
point pattern in the original data.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_type">type</code></td>
<td>

<p>String indicating the type of residuals or weights to be computed.
Choices include <code>"eem"</code>,
<code>"raw"</code>, <code>"inverse"</code> and <code>"pearson"</code>.
See <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> for all possible choices.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+lurking.ppm">lurking.ppm</a></code>,
including arguments controlling the plot.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_separate">separate</code></td>
<td>

<p>Logical value indicating whether to compute a separate lurking
variable plot for each of the original point patterns.
If <code>FALSE</code> (the default), a single lurking-variable plot
is produced by combining residuals from all patterns.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_plot.it">plot.it</code></td>
<td>

<p>Logical value indicating whether 
plots should be shown. If <code>plot.it=FALSE</code>, only
the computed coordinates for the plots are returned.
See <em>Value</em>.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_covname">covname</code></td>
<td>

<p>A string name for the covariate, to be used in axis labels of plots.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_oldstyle">oldstyle</code></td>
<td>

<p>Logical flag indicating whether error bounds should be plotted
using the approximation given in the original paper
(<code>oldstyle=TRUE</code>),
or using the correct asymptotic formula (<code>oldstyle=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_nx">nx</code></td>
<td>

<p>Integer. Number of covariate values to be used in the plot.
</p>
</td></tr>
<tr><td><code id="lurking.mppm_+3A_main">main</code></td>
<td>

<p>Character string giving a main title for the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a &lsquo;lurking variable&rsquo; plot for a
point process model fitted to several point patterns.
Residuals from the model represented by <code>object</code>
are plotted against the covariate specified by <code>covariate</code>.
This plot can be used to reveal departures from the fitted model.
</p>
<p>The function <code>lurking</code> is generic. This is the method
for the class <code>mppm</code>.
The argument <code>object</code> must be a fitted point process model
object of class <code>"mppm"</code>) produced by the
model-fitting algorithm <code><a href="#topic+mppm">mppm</a></code>.
</p>


<h3>Value</h3>

<p>If <code>separate=FALSE</code> (the default), 
the return value is an object 
belonging to the class <code>"lurk"</code>, for which there
are methods for <code>plot</code> and <code>print</code>.
See <code><a href="#topic+lurking">lurking</a></code> for details of the format.
</p>
<p>If <code>separate=TRUE</code>, the result is a list of such objects,
and also belongs to the class <code>anylist</code> so that it can be
printed and plotted. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
with thanks to Nicholas Read.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lurking.ppm">lurking.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- mppm(Points ~ Image + Group, demohyper)
  lurking(fit, expression(Image), type="P")
  lurking(fit, expression(Image), type="P", separate=TRUE)
</code></pre>

<hr>
<h2 id='matclust.estK'>Fit the Matern Cluster Point Process by Minimum Contrast</h2><span id='topic+matclust.estK'></span>

<h3>Description</h3>

<p>Fits the Matern Cluster point process to a point pattern dataset
by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matclust.estK(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matclust.estK_+3A_x">X</code></td>
<td>

<p>Data to which the Matern Cluster model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="matclust.estK_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
Matern Cluster process.
</p>
</td></tr>
<tr><td><code id="matclust.estK_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="matclust.estK_+3A_q">q</code>, <code id="matclust.estK_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="matclust.estK_+3A_rmin">rmin</code>, <code id="matclust.estK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="matclust.estK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Matern Cluster point process model
to a point pattern dataset
by the Method of Minimum Contrast, using the <code class="reqn">K</code> function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The <code class="reqn">K</code> function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the <code class="reqn">K</code> function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Matern Cluster point process to <code>X</code>,
by finding the parameters of the Matern Cluster model
which give the closest match between the
theoretical <code class="reqn">K</code> function of the Matern Cluster process
and the observed <code class="reqn">K</code> function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Matern Cluster point process is described in Moller and Waagepetersen
(2003, p. 62). It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
are independent and uniformly distributed inside a circle of radius
<code class="reqn">R</code> centred on the parent point, where <code class="reqn">R</code> is equal to
the parameter <code>scale</code>. The named vector of stating values can use
either <code>R</code> or <code>scale</code> as the name of the second component,
but the latter is recommended for consistency with other cluster models.
</p>
<p>The theoretical <code class="reqn">K</code>-function of the Matern Cluster process is
</p>
<p style="text-align: center;"><code class="reqn">
    K(r) = \pi r^2 + \frac 1 \kappa h(\frac{r}{2R})
  </code>
</p>

<p>where the radius R is the parameter <code>scale</code> and
</p>
<p style="text-align: center;"><code class="reqn">
    h(z) = 2 + \frac 1 \pi [ ( 8 z^2 - 4 ) \mbox{arccos}(z)
    - 2 \mbox{arcsin}(z)
    + 4 z \sqrt{(1 - z^2)^3}
    - 6 z \sqrt{1 - z^2}
    ]
  </code>
</p>

<p>for <code class="reqn">z &lt;= 1</code>, and <code class="reqn">h(z) = 1</code> for <code class="reqn">z &gt; 1</code>.
The theoretical intensity
of the Matern Cluster process
is <code class="reqn">\lambda = \kappa \mu</code>.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\kappa</code>
and <code class="reqn">R</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Matern Cluster process can be simulated, using
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>.
</p>
<p>Homogeneous or inhomogeneous Matern Cluster models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code> to simulate the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- matclust.estK(redwood, c(kappa=10, scale=0.1))
    u
    plot(u)
</code></pre>

<hr>
<h2 id='matclust.estpcf'>Fit the Matern Cluster Point Process by Minimum Contrast Using Pair Correlation</h2><span id='topic+matclust.estpcf'></span>

<h3>Description</h3>

<p>Fits the Matern Cluster point process to a point pattern dataset
by the Method of Minimum Contrast using the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matclust.estpcf(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...,
            pcfargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matclust.estpcf_+3A_x">X</code></td>
<td>

<p>Data to which the Matern Cluster model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
Matern Cluster process.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_q">q</code>, <code id="matclust.estpcf_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_rmin">rmin</code>, <code id="matclust.estpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="matclust.estpcf_+3A_pcfargs">pcfargs</code></td>
<td>

<p>Optional list containing arguments passed to <code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
to control the smoothing in the estimation of the
pair correlation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Matern Cluster point process model
to a point pattern dataset
by the Method of Minimum Contrast, using the pair correlation function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The pair correlation function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the pair correlation function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Matern Cluster point process to <code>X</code>,
by finding the parameters of the Matern Cluster model
which give the closest match between the
theoretical pair correlation function of the Matern Cluster process
and the observed pair correlation function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>. 
</p>
<p>The Matern Cluster point process is described in Moller and Waagepetersen
(2003, p. 62). It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
are independent and uniformly distributed inside a circle of radius
<code class="reqn">R</code> centred on the parent point, where <code class="reqn">R</code> is equal to
the parameter <code>scale</code>. The named vector of stating values can use
either <code>R</code> or <code>scale</code> as the name of the second component,
but the latter is recommended for consistency with other cluster models.
</p>
<p>The theoretical pair correlation function of the Matern Cluster process is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = 1 + \frac 1 {4\pi R \kappa r} h(\frac{r}{2R})
  </code>
</p>

<p>where the radius R is the parameter <code>scale</code> and
</p>
<p style="text-align: center;"><code class="reqn">
    h(z) = \frac {16} \pi [ z \mbox{arccos}(z) - z^2 \sqrt{1 - z^2} ]
  </code>
</p>

<p>for <code class="reqn">z &lt;= 1</code>, and <code class="reqn">h(z) = 0</code> for <code class="reqn">z &gt; 1</code>.
The theoretical intensity
of the Matern Cluster process
is <code class="reqn">\lambda = \kappa \mu</code>.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\kappa</code>
and <code class="reqn">R</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Matern Cluster process can be simulated, using
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>.
</p>
<p>Homogeneous or inhomogeneous Matern Cluster models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+matclust.estK">matclust.estK</a></code>,
<code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code> to simulate the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- matclust.estpcf(redwood, c(kappa=10, R=0.1))
    u
    plot(u, legendpos="topright")
</code></pre>

<hr>
<h2 id='measureContinuous'>
Discrete and Continuous Components of a Measure
</h2><span id='topic+measureContinuous'></span><span id='topic+measureDiscrete'></span>

<h3>Description</h3>

<p>Given a measure <code>A</code> (object of class <code>"msr"</code>)
these functions find the discrete and continuous parts
of <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureDiscrete(x)
measureContinuous(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureContinuous_+3A_x">x</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>measureDiscrete</code> and <code>measureContinuous</code>
return the discrete and continuous components, respectively,
of a measure.
</p>
<p>If <code>x</code> is a measure, then <code>measureDiscrete(x)</code> is a measure
consisting only of the discrete (atomic) component of <code>x</code>,
and <code>measureContinuous(x)</code> is a measure consisting only of the
continuous (diffuse) component of <code>x</code>.
</p>


<h3>Value</h3>

<p>Another measure (object of class <code>"msr"</code>)
on the same spatial domain.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Halmos, P.R. (1950) <em>Measure Theory</em>. Van Nostrand.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>, <code><a href="#topic+with.msr">with.msr</a></code>, <code><a href="#topic+split.msr">split.msr</a></code>,
<code><a href="#topic+measurePositive">measurePositive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")

   rp
   measureDiscrete(rp)
   measureContinuous(rp)
</code></pre>

<hr>
<h2 id='measureVariation'>
Positive and Negative Parts, and Variation, of a Measure
</h2><span id='topic+measureVariation'></span><span id='topic+measurePositive'></span><span id='topic+measureNegative'></span><span id='topic+totalVariation'></span>

<h3>Description</h3>

<p>Given a measure <code>A</code> (object of class <code>"msr"</code>)
these functions find the positive part, negative part and variation
of <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurePositive(x)
measureNegative(x)
measureVariation(x)
totalVariation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureVariation_+3A_x">x</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>measurePositive</code> and <code>measureNegative</code>
return the positive and negative parts of the measure,
and <code>measureVariation</code> returns the variation (sum of positive and
negative parts). The function <code>totalVariation</code> returns the total
variation norm.
</p>
<p>If <code class="reqn">\mu</code> is a signed measure,
it can be represented as
</p>
<p style="text-align: center;"><code class="reqn">\mu = \mu_{+} - \mu_{-}</code>
</p>

<p>where <code class="reqn">\mu_{+}</code> and <code class="reqn">\mu_{-}</code>
are <em>nonnegative</em> measures called the positive and negative
parts of <code class="reqn">\mu</code>.
In a nutshell, the positive part of <code class="reqn">\mu</code>
consists of all positive contributions or increments,
and the negative part consists of all negative contributions
multiplied by <code>-1</code>. 
</p>
<p>The variation <code class="reqn">|\mu|</code> is defined by 
</p>
<p style="text-align: center;"><code class="reqn">\mu = \mu_{+} + \mu_{-}</code>
</p>

<p>and is also a nonnegative measure.
</p>
<p>The total variation norm is the integral of the variation. 
</p>


<h3>Value</h3>

<p>The result of <code>measurePositive</code>, <code>measureNegative</code>
and <code>measureVariation</code> is another measure (object of class <code>"msr"</code>)
on the same spatial domain.
The result of <code>totalVariation</code> is a non-negative number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Halmos, P.R. (1950) <em>Measure Theory</em>. Van Nostrand.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>, <code><a href="#topic+with.msr">with.msr</a></code>, <code><a href="#topic+split.msr">split.msr</a></code>,
<code><a href="#topic+measureDiscrete">measureDiscrete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")

   measurePositive(rp)
   measureNegative(rp)
   measureVariation(rp)

   # total variation norm
   totalVariation(rp)
</code></pre>

<hr>
<h2 id='measureWeighted'>
Weighted Version of a Measure
</h2><span id='topic+measureWeighted'></span>

<h3>Description</h3>

<p>Given a measure <code>m</code> (object of class <code>"msr"</code>)
and a spatially-varying weight function, construct the
weighted version of <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measureWeighted(m, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measureWeighted_+3A_m">m</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
<tr><td><code id="measureWeighted_+3A_w">w</code></td>
<td>

<p>A pixel image (object of class <code>"im"</code>)
or a <code>function(x,y)</code> giving the numeric weight at each spatial location.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any region of space <code>B</code>,
the weighted measure <code>wm</code> has the value
</p>
<p style="text-align: center;"><code class="reqn">
    wm(B) = \int_B w(x) dm(x)
  </code>
</p>

<p>In any small region of space, the increment of the
weighted measure <code>wm</code> is equal to the increment of the 
original measure <code>m</code> multiplied by the weight <code>w</code> at that
location.
</p>


<h3>Value</h3>

<p>Another measure (object of class <code>"msr"</code>)
on the same spatial domain.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Halmos, P.R. (1950) <em>Measure Theory</em>. Van Nostrand.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>, <code><a href="#topic+with.msr">with.msr</a></code>, <code><a href="#topic+split.msr">split.msr</a></code>,
<code><a href="#topic+measurePositive">measurePositive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ x)
   res &lt;- residuals(fit)
   measureWeighted(res, function(x,y){x})
</code></pre>

<hr>
<h2 id='methods.dppm'>
Methods for Determinantal Point Process Models
</h2><span id='topic+methods.dppm'></span><span id='topic+coef.dppm'></span><span id='topic+formula.dppm'></span><span id='topic+print.dppm'></span><span id='topic+terms.dppm'></span><span id='topic+labels.dppm'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"dppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dppm'
coef(object, ...)
## S3 method for class 'dppm'
formula(x, ...)
## S3 method for class 'dppm'
print(x, ...)
## S3 method for class 'dppm'
terms(x, ...)
## S3 method for class 'dppm'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.dppm_+3A_x">x</code>, <code id="methods.dppm_+3A_object">object</code></td>
<td>

<p>An object of class <code>"dppm"</code>,
representing a fitted determinantal point process model.
</p>
</td></tr>
<tr><td><code id="methods.dppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="stats.html#topic+terms">terms</a></code> and 
<code><a href="base.html#topic+labels">labels</a></code>
for the class <code>"dppm"</code>.
</p>
<p>An object of class <code>"dppm"</code> represents a fitted
determinantal point process model. It is obtained from <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p>The method <code>coef.dppm</code> returns the vector of
<em>regression coefficients</em> of the fitted model.
It does not return the interaction parameters.
</p>


<h3>Value</h3>

<p>See the help files for the corresponding generic functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>,  <code><a href="#topic+plot.dppm">plot.dppm</a></code>,
<code><a href="#topic+predict.dppm">predict.dppm</a></code>, <code><a href="#topic+simulate.dppm">simulate.dppm</a></code>,
<code><a href="#topic+as.ppm.dppm">as.ppm.dppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- dppm(swedishpines ~ x + y, dppGauss, method="c")
  coef(fit)
  formula(fit)
  tf &lt;- terms(fit)
  labels(fit)
</code></pre>

<hr>
<h2 id='methods.fii'>
Methods for Fitted Interactions
</h2><span id='topic+methods.fii'></span><span id='topic+print.fii'></span><span id='topic+plot.fii'></span><span id='topic+coef.fii'></span><span id='topic+coef+3C-.fii'></span><span id='topic+summary.fii'></span><span id='topic+print.summary.fii'></span><span id='topic+coef.summary.fii'></span>

<h3>Description</h3>

<p>These are methods specifically for the class <code>"fii"</code> of
fitted interpoint interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fii'
print(x, ...)

## S3 method for class 'fii'
coef(object, ...)

## S3 replacement method for class 'fii'
coef(object, ...) &lt;- value

## S3 method for class 'fii'
plot(x, ...)

## S3 method for class 'fii'
summary(object,...)

## S3 method for class 'summary.fii'
print(x, ...)

## S3 method for class 'summary.fii'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.fii_+3A_x">x</code>, <code id="methods.fii_+3A_object">object</code></td>
<td>

<p>An object of class <code>"fii"</code> representing a fitted
interpoint interaction.
</p>
</td></tr>
<tr><td><code id="methods.fii_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.fii_+3A_value">value</code></td>
<td>

<p>Numeric vector containing new values for the fitted
interaction coefficients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the class <code>"fii"</code>.
An object of class <code>"fii"</code> represents a fitted interpoint
interaction. It is usually obtained by
using the command <code><a href="#topic+fitin">fitin</a></code> to extract the fitted
interaction part of a fitted point process model. 
See <code><a href="#topic+fitin">fitin</a></code> for further explanation of this class.
</p>
<p>The commands listed here are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>
and <code><a href="nlme.html#topic+coef+3C-">coef&lt;-</a></code>
for objects of the class <code>"fii"</code>.
</p>
<p>Following the usual convention, <code>summary.fii</code> returns an object of class
<code>summary.fii</code>, for which there is a print method.
The effect is that, when the user types <code>summary(x)</code>,
the summary is printed, but when the user types <code>y &lt;- summary(x)</code>,
the summary information is saved.
</p>
<p>The method <code>coef.fii</code> extracts the canonical coefficients of
the fitted interaction, and returns them as a numeric vector.
The method <code>coef.summary.fii</code> transforms these values into
quantities that are more easily interpretable, in a format that
depends on the particular model.
</p>
<p>There are also methods for the generic commands <code><a href="spatstat.random.html#topic+reach">reach</a></code> and
<code><a href="#topic+as.interact">as.interact</a></code>, described elsewhere.
</p>


<h3>Value</h3>

<p>The <code>print</code> and <code>plot</code> methods return <code>NULL</code>.
</p>
<p>The <code>summary</code> method returns an object of class
<code>summary.fii</code>.
</p>
<p><code>coef.fii</code> returns a numeric vector.
<code>coef.summary.fii</code> returns data whose structure
depends on the model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitin">fitin</a></code>,
<code><a href="#topic+reach.fii">reach.fii</a></code>,
<code><a href="#topic+as.interact.fii">as.interact.fii</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mod &lt;- ppm(cells, ~1, Strauss(0.1))
  f &lt;- fitin(mod)
  f
  summary(f)
  plot(f)
  coef(f)
  coef(summary(f))
</code></pre>

<hr>
<h2 id='methods.influence.ppm'>Methods for Influence Objects</h2><span id='topic+methods.influence.ppm'></span><span id='topic+as.ppp.influence.ppm'></span><span id='topic+as.owin.influence.ppm'></span><span id='topic+domain.influence.ppm'></span><span id='topic+integral.influence.ppm'></span><span id='topic+Smooth.influence.ppm'></span><span id='topic+Window.influence.ppm'></span>

<h3>Description</h3>

<p>Methods for the class <code>"influence.ppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'influence.ppm'
as.ppp(X, ...)

 ## S3 method for class 'influence.ppm'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'influence.ppm'
domain(X, ...)

 ## S3 method for class 'influence.ppm'
Smooth(X, ...)

 ## S3 method for class 'influence.ppm'
Window(X, ...)

 ## S3 method for class 'influence.ppm'
integral(f, domain, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.influence.ppm_+3A_x">X</code>, <code id="methods.influence.ppm_+3A_w">W</code>, <code id="methods.influence.ppm_+3A_f">f</code></td>
<td>
<p>An object of class <code>"influence.ppm"</code>.</p>
</td></tr>
<tr><td><code id="methods.influence.ppm_+3A_domain">domain</code></td>
<td>

<p>Optional. Domain of integration: a window (class <code>"owin"</code>)
or a tessellation (class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="methods.influence.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments.
See Details.
</p>
</td></tr>
<tr><td><code id="methods.influence.ppm_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating what to do if the data cannot be
converted to a window. If <code>fatal=TRUE</code> (the default)
an error occurs. If <code>fatal=FALSE</code> a value of <code>NULL</code>
is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the class <code>"influence.ppm"</code>.
An object of this class
represents the influence measure of a fitted point process model
(see <code><a href="#topic+influence.ppm">influence.ppm</a></code>).
</p>
<p>For <code>as.ppp</code>, <code>domain</code>, <code>integral</code> and <code>Window</code>,
additional arguments (<code>...</code>) are ignored.
For <code>as.owin</code> and <code>Smooth</code>, 
additional arguments are passed to the method for class <code>"ppp"</code>.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>) for
<code>as.owin</code>, <code>domain</code> and <code>Window</code>.
A point pattern (object of class <code>"ppp"</code>) for
<code>as.ppp</code>. A numeric value or numeric vector for <code>integral</code>.
A pixel image, or list of pixel images, for <code>Smooth</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence.ppm">influence.ppm</a></code>, <code><a href="#topic+plot.influence.ppm">plot.influence.ppm</a></code>,
<code><a href="#topic++5B.influence.ppm">[.influence.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- ppm(cells ~ x)
 a &lt;- influence(fit)
 Window(a)
</code></pre>

<hr>
<h2 id='methods.kppm'>
Methods for Cluster Point Process Models
</h2><span id='topic+methods.kppm'></span><span id='topic+coef.kppm'></span><span id='topic+formula.kppm'></span><span id='topic+print.kppm'></span><span id='topic+terms.kppm'></span><span id='topic+labels.kppm'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"kppm"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kppm'
coef(object, ...)
## S3 method for class 'kppm'
formula(x, ...)
## S3 method for class 'kppm'
print(x, ...)
## S3 method for class 'kppm'
terms(x, ...)
## S3 method for class 'kppm'
labels(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.kppm_+3A_x">x</code>, <code id="methods.kppm_+3A_object">object</code></td>
<td>

<p>An object of class <code>"kppm"</code>,
representing a fitted cluster point process model.
</p>
</td></tr>
<tr><td><code id="methods.kppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="stats.html#topic+terms">terms</a></code> and
<code><a href="base.html#topic+labels">labels</a></code>
for the class <code>"kppm"</code>.
</p>
<p>An object of class <code>"kppm"</code> represents a fitted
cluster point process model. It is obtained from <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The method <code>coef.kppm</code> returns the vector of
<em>regression coefficients</em> of the fitted model.
It does not return the clustering parameters.
</p>


<h3>Value</h3>

<p>See the help files for the corresponding generic functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,  <code><a href="#topic+plot.kppm">plot.kppm</a></code>,
<code><a href="#topic+predict.kppm">predict.kppm</a></code>, <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>,
<code><a href="#topic+update.kppm">update.kppm</a></code>, <code><a href="#topic+vcov.kppm">vcov.kppm</a></code>,
<code><a href="#topic+as.ppm.kppm">as.ppm.kppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ x, "MatClust")
  coef(fit)
  formula(fit)
  tf &lt;- terms(fit)
  labels(fit)
</code></pre>

<hr>
<h2 id='methods.leverage.ppm'>Methods for Leverage Objects</h2><span id='topic+methods.leverage.ppm'></span><span id='topic+as.im.leverage.ppm'></span><span id='topic+as.owin.leverage.ppm'></span><span id='topic+domain.leverage.ppm'></span><span id='topic+integral.leverage.ppm'></span><span id='topic+mean.leverage.ppm'></span><span id='topic+Smooth.leverage.ppm'></span><span id='topic+Window.leverage.ppm'></span>

<h3>Description</h3>

<p>Methods for the class <code>"leverage.ppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'leverage.ppm'
as.im(X, ..., what=c("smooth", "nearest"))

 ## S3 method for class 'leverage.ppm'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'leverage.ppm'
domain(X, ...)

 ## S3 method for class 'leverage.ppm'
integral(f, domain, ...)

 ## S3 method for class 'leverage.ppm'
mean(x, ...)

 ## S3 method for class 'leverage.ppm'
Smooth(X, ...)

 ## S3 method for class 'leverage.ppm'
Window(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.leverage.ppm_+3A_x">X</code>, <code id="methods.leverage.ppm_+3A_x">x</code>, <code id="methods.leverage.ppm_+3A_w">W</code>, <code id="methods.leverage.ppm_+3A_f">f</code></td>
<td>
<p>An object of class <code>"leverage.ppm"</code>.</p>
</td></tr>
<tr><td><code id="methods.leverage.ppm_+3A_domain">domain</code></td>
<td>

<p>Optional. Domain of integration: a window (class <code>"owin"</code>)
or a tessellation (class <code>"tess"</code>).
</p>
</td></tr>
<tr><td><code id="methods.leverage.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments.
See Details.
</p>
</td></tr>
<tr><td><code id="methods.leverage.ppm_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating what to do if the data cannot be
converted to a window. If <code>fatal=TRUE</code> (the default)
an error occurs. If <code>fatal=FALSE</code> a value of <code>NULL</code>
is returned.
</p>
</td></tr>
<tr><td><code id="methods.leverage.ppm_+3A_what">what</code></td>
<td>

<p>Character string (partially matched) specifying which image data
should be extracted. See <code><a href="#topic+plot.leverage.ppm">plot.leverage.ppm</a></code> for
explanation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the class <code>"leverage.ppm"</code>.
An object of this class
represents the leverage measure of a fitted point process model
(see <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>).
</p>
<p>For <code>as.im</code>, <code>domain</code> and <code>Window</code>,
additional arguments (<code>...</code>) are ignored.
For <code>as.owin</code>, <code>integral</code>, <code>mean</code> and <code>Smooth</code>, 
additional arguments are passed to the method for class <code>"im"</code>.
</p>


<h3>Value</h3>

<p>A window (object of class <code>"owin"</code>) for
<code>as.owin</code>, <code>domain</code> and <code>Window</code>.
A numeric value or numeric vector for <code>integral</code>.
A pixel image, or list of pixel images, for <code>as.im</code> and <code>Smooth</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>, <code><a href="#topic+plot.leverage.ppm">plot.leverage.ppm</a></code>,
<code><a href="#topic++5B.leverage.ppm">[.leverage.ppm</a></code>, <code><a href="#topic+as.function.leverage.ppm">as.function.leverage.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- ppm(cells ~ x)
 a &lt;- leverage(fit)
 integral(a)
</code></pre>

<hr>
<h2 id='methods.objsurf'>
Methods for Objective Function Surfaces
</h2><span id='topic+methods.objsurf'></span><span id='topic+print.objsurf'></span><span id='topic+plot.objsurf'></span><span id='topic+persp.objsurf'></span><span id='topic+image.objsurf'></span><span id='topic+contour.objsurf'></span><span id='topic+summary.objsurf'></span><span id='topic+print.summary.objsurf'></span>

<h3>Description</h3>

<p>Methods for printing and plotting an objective function surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'objsurf'
print(x, ...)
## S3 method for class 'objsurf'
plot(x, ...)
## S3 method for class 'objsurf'
image(x, ...)
## S3 method for class 'objsurf'
contour(x, ...)
## S3 method for class 'objsurf'
persp(x, ...)
## S3 method for class 'objsurf'
summary(object, ...)
## S3 method for class 'summary.objsurf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.objsurf_+3A_x">x</code>, <code id="methods.objsurf_+3A_object">object</code></td>
<td>

<p>Object of class <code>"objsurf"</code> representing an objective function surface.
</p>
</td></tr>
<tr><td><code id="methods.objsurf_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to plot methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>
and <code><a href="base.html#topic+summary">summary</a></code> for the class <code>"objsurf"</code>.
</p>


<h3>Value</h3>

<p>For <code>print.objsurf</code>, <code>print.summary.objsurf</code>,
<code>plot.objsurf</code> and <code>image.objsurf</code> the value is <code>NULL</code>.
</p>
<p>For <code>contour.objsurf</code> and <code>persp.objsurf</code>
the value is described in the help for
<code><a href="graphics.html#topic+contour.default">contour.default</a></code> and <code><a href="graphics.html#topic+persp.default">persp.default</a></code>
respectively.
</p>
<p>For <code>summary.objsurf</code> the result is a list, of class
<code>summary.objsurf</code>, containing summary information. This list is
printed in sensible format by <code>print.summary.objsurf</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+objsurf">objsurf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- kppm(redwood ~ 1, "Thomas")
 os &lt;- objsurf(fit)
  os
  summary(os)
  plot(os)
  contour(os, add=TRUE)
  persp(os)
</code></pre>

<hr>
<h2 id='methods.slrm'>
Methods for Spatial Logistic Regression Models
</h2><span id='topic+methods.slrm'></span><span id='topic+formula.slrm'></span><span id='topic+update.slrm'></span><span id='topic+print.slrm'></span><span id='topic+summary.slrm'></span><span id='topic+terms.slrm'></span><span id='topic+labels.slrm'></span><span id='topic+deviance.slrm'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"slrm"</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'slrm'
formula(x, ...)
## S3 method for class 'slrm'
print(x, ...)
## S3 method for class 'slrm'
summary(object, ...)
## S3 method for class 'slrm'
terms(x, ...)
## S3 method for class 'slrm'
labels(object, ...)
## S3 method for class 'slrm'
deviance(object, ...)
## S3 method for class 'slrm'
update(object, fmla, ..., evaluate = TRUE, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.slrm_+3A_x">x</code>, <code id="methods.slrm_+3A_object">object</code></td>
<td>

<p>An object of class <code>"slrm"</code>,
representing a fitted spatial logistic regression model.
</p>
</td></tr>
<tr><td><code id="methods.slrm_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.slrm_+3A_fmla">fmla</code></td>
<td>

<p>Optional. A formula, to replace the formula of the model.
</p>
</td></tr>
<tr><td><code id="methods.slrm_+3A_evaluate">evaluate</code></td>
<td>

<p>Logical value. If <code>TRUE</code>, evaluate the updated call to
<code>slrm</code>, so that the model is refitted; 
if <code>FALSE</code>, simply return the updated call.
</p>
</td></tr>
<tr><td><code id="methods.slrm_+3A_env">env</code></td>
<td>

<p>Optional environment in which the model should be updated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic commands
<code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="stats.html#topic+update">update</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="base.html#topic+labels">labels</a></code> and 
<code><a href="stats.html#topic+deviance">deviance</a></code>
for the class <code>"slrm"</code>.
</p>
<p>An object of class <code>"slrm"</code> represents a fitted
spatial logistic regression model. It is obtained from <code><a href="#topic+slrm">slrm</a></code>.
</p>


<h3>Value</h3>

<p>See the help files for the corresponding generic functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>,  <code><a href="#topic+plot.slrm">plot.slrm</a></code>,
<code><a href="#topic+predict.slrm">predict.slrm</a></code>, <code><a href="#topic+simulate.slrm">simulate.slrm</a></code>,
<code><a href="#topic+vcov.slrm">vcov.slrm</a></code>,
<code><a href="#topic+coef.slrm">coef.slrm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- slrm(redwood ~ x)
  coef(fit)
  formula(fit)
  tf &lt;- terms(fit)  
  labels(fit)
  deviance(fit) 
</code></pre>

<hr>
<h2 id='methods.traj'>
Methods for Trajectories of Function Evaluations
</h2><span id='topic+methods.traj'></span><span id='topic+lines.traj'></span><span id='topic+plot.traj'></span><span id='topic+print.traj'></span>

<h3>Description</h3>

<p>Methods for objects of class <code>"traj"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'traj'
print(x, ...)
## S3 method for class 'traj'
plot(x, ..., show.ends=TRUE, add=FALSE, xlab=NULL, ylab=NULL)
## S3 method for class 'traj'
lines(x, ..., directed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.traj_+3A_x">x</code></td>
<td>

<p>Object of class <code>"traj"</code>.
</p>
</td></tr>
<tr><td><code id="methods.traj_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.traj_+3A_directed">directed</code></td>
<td>

<p>Logical value specifying whether to draw arrows instead of
undirected lines.
</p>
</td></tr>
<tr><td><code id="methods.traj_+3A_show.ends">show.ends</code></td>
<td>

<p>Logical value specifying whether to indicate the start and finish of
the trajectory. The start is a blue circle; the finish is a red cross.
</p>
</td></tr>
<tr><td><code id="methods.traj_+3A_add">add</code></td>
<td>

<p>Logical value specifying whether to draw the trajectory on the
existing plot (<code>add=TRUE</code>) or to start a new plot
(<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="methods.traj_+3A_xlab">xlab</code>, <code id="methods.traj_+3A_ylab">ylab</code></td>
<td>
<p>Optional labels for the horizontal and vertical axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"traj"</code> represents
the history of evaluations of the objective function
performed when a cluster process model was fitted.
It is a data frame containing the input parameter values for
the objective function, and the corresponding value of the objective
function, that were considered by the optimisation algorithm.
</p>
<p>These functions are methods for the generic
<code>print</code>, <code>plot</code> and <code>lines</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traj">traj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood, pspace=list(save=TRUE))
  h &lt;- traj(fit)
  h
  plot(h)
  lines(h)
</code></pre>

<hr>
<h2 id='methods.zclustermodel'>
Methods for Cluster Models
</h2><span id='topic+methods.zclustermodel'></span><span id='topic+pcfmodel.zclustermodel'></span><span id='topic+Kmodel.zclustermodel'></span><span id='topic+predict.zclustermodel'></span><span id='topic+intensity.zclustermodel'></span><span id='topic+print.zclustermodel'></span><span id='topic+clusterradius.zclustermodel'></span><span id='topic+reach.zclustermodel'></span>

<h3>Description</h3>

<p>Methods for the experimental class of cluster models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'zclustermodel'
pcfmodel(model, ...)

 ## S3 method for class 'zclustermodel'
Kmodel(model, ...)

 ## S3 method for class 'zclustermodel'
intensity(X, ...)

 ## S3 method for class 'zclustermodel'
predict(object, ...,
                  locations, type = "intensity", ngrid = NULL)

 ## S3 method for class 'zclustermodel'
print(x, ...)

 ## S3 method for class 'zclustermodel'
clusterradius(model,...,thresh=NULL, precision=FALSE)

 ## S3 method for class 'zclustermodel'
reach(x, ..., epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.zclustermodel_+3A_model">model</code>, <code id="methods.zclustermodel_+3A_object">object</code>, <code id="methods.zclustermodel_+3A_x">x</code>, <code id="methods.zclustermodel_+3A_x">X</code></td>
<td>

<p>Object of class <code>"zclustermodel"</code>.
</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_locations">locations</code></td>
<td>

<p>Locations where prediction should be performed.
A window or a point pattern.
</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_type">type</code></td>
<td>

<p>Currently must equal <code>"intensity"</code>.
</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_ngrid">ngrid</code></td>
<td>

<p>Pixel grid dimensions for prediction, if <code>locations</code> is
a rectangle or polygon.
</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_thresh">thresh</code>, <code id="methods.zclustermodel_+3A_epsilon">epsilon</code></td>
<td>
<p>Tolerance thresholds</p>
</td></tr>
<tr><td><code id="methods.zclustermodel_+3A_precision">precision</code></td>
<td>

<p>Logical value stipulating whether the precision should also be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental.
</p>


<h3>Value</h3>

<p>Same as for other methods.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zclustermodel">zclustermodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- zclustermodel("Thomas", kappa=10, mu=5, scale=0.1)
  m2 &lt;- zclustermodel("VarGamma", kappa=10, mu=10, scale=0.1, nu=0.7)
  m
  m2
  g &lt;- pcfmodel(m)
  g(0.2)
  g2 &lt;- pcfmodel(m2)
  g2(1)
  Z &lt;- predict(m, locations=square(2))
  Z2 &lt;- predict(m2, locations=square(1))
  varcount(m, square(1))
  varcount(m2, square(1))
</code></pre>

<hr>
<h2 id='methods.zgibbsmodel'>
Methods for Gibbs Models
</h2><span id='topic+methods.zgibbsmodel'></span><span id='topic+as.interact.zgibbsmodel'></span><span id='topic+as.isf.zgibbsmodel'></span><span id='topic+interactionorder.zgibbsmodel'></span><span id='topic+intensity.zgibbsmodel'></span><span id='topic+is.poisson.zgibbsmodel'></span><span id='topic+is.stationary.zgibbsmodel'></span><span id='topic+print.zgibbsmodel'></span>

<h3>Description</h3>

<p>Methods for the experimental class of Gibbs models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zgibbsmodel'
as.interact(object)
## S3 method for class 'zgibbsmodel'
as.isf(object)
## S3 method for class 'zgibbsmodel'
interactionorder(object)
## S3 method for class 'zgibbsmodel'
is.poisson(x)
## S3 method for class 'zgibbsmodel'
is.stationary(x)
## S3 method for class 'zgibbsmodel'
print(x, ...)
## S3 method for class 'zgibbsmodel'
intensity(X, ..., approx=c("Poisson", "DPP"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.zgibbsmodel_+3A_object">object</code>, <code id="methods.zgibbsmodel_+3A_x">x</code>, <code id="methods.zgibbsmodel_+3A_x">X</code></td>
<td>

<p>Object of class <code>"zgibbsmodel"</code>.
</p>
</td></tr>
<tr><td><code id="methods.zgibbsmodel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="methods.zgibbsmodel_+3A_approx">approx</code></td>
<td>

<p>Character string (partially matched) specifying the type
of approximation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental.
</p>


<h3>Value</h3>

<p>Same as for other methods.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zgibbsmodel">zgibbsmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- zgibbsmodel(10, Strauss(0.1), -0.5)
  m
  is.poisson(m)
  is.stationary(m)
  interactionorder(m)
  as.interact(m)
  as.isf(m)
  intensity(m)
  intensity(m, approx="D")
</code></pre>

<hr>
<h2 id='mincontrast'>Method of Minimum Contrast</h2><span id='topic+mincontrast'></span>

<h3>Description</h3>

<p>A general low-level algorithm for fitting theoretical point process models
to point pattern data by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mincontrast(observed, theoretical, startpar, ...,
          ctrl=list(q = 1/4, p = 2, rmin=NULL, rmax=NULL),
          fvlab=list(label=NULL, desc="minimum contrast fit"),
          explain=list(dataname=NULL, modelname=NULL, fname=NULL),
          action.bad.values=c("warn", "stop", "silent"),
          control=list(), stabilize=TRUE,
          pspace=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mincontrast_+3A_observed">observed</code></td>
<td>

<p>Summary statistic, computed for the data.
An object of class <code>"fv"</code>.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_theoretical">theoretical</code></td>
<td>

<p>An R language function that calculates the theoretical expected value
of the summary statistic, given the model parameters.
See Details.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_startpar">startpar</code></td>
<td>

<p>Vector of initial values of the parameters of the
point process model (passed to <code>theoretical</code>). 
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the function <code>theoretical</code>
and to the optimisation algorithm <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_ctrl">ctrl</code></td>
<td>

<p>Optional. List of arguments controlling the optimisation. See Details.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_fvlab">fvlab</code></td>
<td>

<p>Optional. List containing some labels for the return value. See Details.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_explain">explain</code></td>
<td>

<p>Optional. List containing strings that give a human-readable description
of the model, the data and the summary statistic.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_action.bad.values">action.bad.values</code></td>
<td>

<p>String (partially matched) specifying what to do if
values of the summary statistic are <code>NA</code>, <code>NaN</code> or
infinite. See Details.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_control">control</code></td>
<td>

<p>Optional. Argument passed to <code><a href="stats.html#topic+optim">optim</a></code>.
A list of parameters which control the behaviour of the optimization algorithm.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_stabilize">stabilize</code></td>
<td>

<p>Logical value specifying whether to numerically stabilize
the optimization algorithm, by specifying suitable default values of
<code>control$fnscale</code> and <code>control$parscale</code>.
</p>
</td></tr>
<tr><td><code id="mincontrast_+3A_pspace">pspace</code></td>
<td>

<p>For internal use by the package only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a general algorithm for fitting point process models
by the Method of Minimum Contrast. If you want to fit the
Thomas process, see <code><a href="#topic+thomas.estK">thomas.estK</a></code>.
If you want to fit a log-Gaussian Cox process, see
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>.  If you want to fit the Matern cluster
process, see <code><a href="#topic+matclust.estK">matclust.estK</a></code>.
</p>
<p>The Method of Minimum Contrast (Pfanzagl, 1969; Diggle and Gratton, 1984)
is a general technique for fitting
a point process model to point pattern data. First a summary function
(typically the <code class="reqn">K</code> function) is computed from the data point
pattern. Second, the theoretical expected
value of this summary statistic under the point process model
is derived (if possible, as an algebraic expression involving the
parameters of the model) or estimated from simulations of the model. 
Then the model is fitted by finding the optimal parameter values
for the model to give the closest match between the theoretical
and empirical curves. 
</p>
<p>The argument <code>observed</code> should be an object of class <code>"fv"</code>
(see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>) containing the values of a summary
statistic computed from the data point pattern. Usually this is the
function <code class="reqn">K(r)</code> computed by <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
<p>The argument <code>theoretical</code> should be a user-supplied function
that computes the theoretical expected value of the summary statistic.
It must have an argument named <code>par</code> that will be the vector
of parameter values for the model (the length and format of this
vector are determined by the starting values in <code>startpar</code>).
The function <code>theoretical</code> should also expect a second argument
(the first argument other than <code>par</code>)
containing values of the distance <code class="reqn">r</code> for which the theoretical
value of the summary statistic <code class="reqn">K(r)</code> should be computed.
The value returned by <code>theoretical</code> should be a vector of the
same length as the given vector of <code class="reqn">r</code> values.
</p>
<p>The argument <code>ctrl</code> determines the contrast criterion
(the objective function that will be minimised). 
The algorithm minimises the criterion
</p>
<p style="text-align: center;"><code class="reqn">
    D(\theta)=
    \int_{r_{\mbox{\scriptsize min}}}^{r_{\mbox{\scriptsize max}}}
    |\hat F(r)^q - F_\theta(r)^q|^p \, {\rm d}r
  </code>
</p>

<p>where <code class="reqn">\theta</code> is the vector of parameters of the model,
<code class="reqn">\hat F(r)</code> is the observed value of the summary statistic
computed from the data, <code class="reqn">F_\theta(r)</code> is the
theoretical expected value of the summary statistic,
and <code class="reqn">p,q</code> are two exponents. The default is <code>q = 1/4</code>,
<code>p=2</code> so that the contrast criterion is the integrated squared
difference between the fourth roots of the two functions
(Waagepetersen, 2007).
</p>
<p>The argument <code>action.bad.values</code> specifies what to do if
some of the values of the summary statistic are <code>NA</code>, <code>NaN</code> or
infinite. If <code>action.bad.values="stop"</code>, or if all of the values are bad,
then a fatal error occurs. Otherwise, the domain of the summary
function is shortened to avoid the bad values. The shortened domain is the
longest interval on which the function values are finite 
(provided this interval is at least half the length of the original
domain). A warning is issued if <code>action.bad.values="warn"</code> (the default)
and no warning is issued if <code>action.bad.values="silent"</code>.
</p>
<p>The other arguments just make things print nicely.
The argument <code>fvlab</code> contains labels for the component
<code>fit</code> of the return value.
The argument <code>explain</code> contains human-readable strings
describing the data, the model and the summary statistic.
</p>
<p>The <code>"..."</code> argument of <code>mincontrast</code> can be used to
pass extra arguments to the function <code>theoretical</code>
and/or to the optimisation function <code><a href="stats.html#topic+optim">optim</a></code>.
In this case, the function <code>theoretical</code>
should also have a <code>"..."</code> argument and should ignore it
(so that it ignores arguments intended for <code><a href="stats.html#topic+optim">optim</a></code>).
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>The object returned from the optimizer <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>crtl</code></td>
<td>
<p>List of parameters determining the contrast objective.</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>List of explanatory strings.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adapted for <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Pfanzagl, J. (1969).
On the measurability and consistency of minimum contrast estimates.
<em>Metrika</em> <b>14</b>, 249&ndash;276.
</p>
<p>Waagepetersen, R. (2007).
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+matclust.estK">matclust.estK</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
</p>

<hr>
<h2 id='model.depends'>
Identify Covariates Involved in each Model Term
</h2><span id='topic+model.depends'></span><span id='topic+model.is.additive'></span><span id='topic+model.covariates'></span><span id='topic+has.offset.term'></span><span id='topic+has.offset'></span>

<h3>Description</h3>

<p>Given a fitted model (of any kind), identify which of the covariates
is involved in each term of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.depends(object)
model.is.additive(object)
model.covariates(object, fitted=TRUE, offset=TRUE)
has.offset.term(object)
has.offset(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.depends_+3A_object">object</code></td>
<td>

<p>A fitted model of any kind.
</p>
</td></tr>
<tr><td><code id="model.depends_+3A_fitted">fitted</code>, <code id="model.depends_+3A_offset">offset</code></td>
<td>

<p>Logical values determining which type of covariates to include.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>object</code> can be a fitted model of any kind,
including models of the classes <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>
and <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>To be precise,
<code>object</code> must belong to a class for which there are methods
for <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>
and <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>
<p>The command <code>model.depends</code> determines the relationship between
the original covariates (the data supplied when <code>object</code> was
fitted) and the canonical covariates (the columns of the design matrix).
It returns a logical matrix, with one row for each canonical
covariate, and one column for each of the original covariates,
with the <code>i,j</code> entry equal to <code>TRUE</code> if the
<code>i</code>th canonical covariate depends on the <code>j</code>th
original covariate.
</p>
<p>If the model formula of <code>object</code> includes offset terms
(see <code><a href="stats.html#topic+offset">offset</a></code>), then the return value of <code>model.depends</code>
also has an attribute <code>"offset"</code>. This is a logical value or
matrix with one row for each offset term and one column for each of
the original covariates, with the <code>i,j</code> entry equal to <code>TRUE</code> if the
<code>i</code>th offset term depends on the <code>j</code>th
original covariate.
</p>
<p>The command <code>model.covariates</code> returns a character vector
containing the names of all (original) covariates that were actually
used to fit the model. By default, this includes all covariates that
appear in the model formula, including offset terms as well as 
canonical covariate terms. To omit the offset terms, set
<code>offset=FALSE</code>. To omit the canonical covariate terms,
set <code>fitted=FALSE</code>.
</p>
<p>The command <code>model.is.additive</code> determines whether the model
is additive, in the sense that there is no canonical covariate that
depends on two or more original covariates. It returns a logical value.
</p>
<p>The command <code>has.offset.term</code> is a faster way to determine whether the
model <em>formula</em> includes an <code>offset</code> term.
</p>
<p>The functions <code>model.depends</code> and <code>has.offset.term</code>
only detect <code>offset</code> terms which are present
in the model formula. They do not detect numerical offsets in the
model object, that were inserted using the <code>offset</code> argument
in <code>lm</code>, <code>glm</code> etc. To detect the presence of offsets
of both kinds, use <code>has.offset</code>.
</p>


<h3>Value</h3>

<p>A logical value or matrix.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- 1:10
   y &lt;- 3*x + 2
   z &lt;- rep(c(-1,1), 5)
   fit &lt;- lm(y ~ poly(x,2) + sin(z))
   model.depends(fit)
   model.covariates(fit)
   model.is.additive(fit)

   fitoff1 &lt;- lm(y ~ x + offset(z))
   fitoff2 &lt;- lm(y ~ x, offset=z)
   has.offset.term(fitoff1)
   has.offset(fitoff1)
   has.offset.term(fitoff2)
   has.offset(fitoff2)
</code></pre>

<hr>
<h2 id='model.frame.ppm'>
Extract the Variables in a Point Process Model
</h2><span id='topic+model.frame.ppm'></span><span id='topic+model.frame.kppm'></span><span id='topic+model.frame.dppm'></span><span id='topic+model.frame.slrm'></span>

<h3>Description</h3>

<p>Given a fitted point process model, this function
returns a data frame containing all the variables needed to
fit the model using the Berman-Turner device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppm'
model.frame(formula, ...)

 ## S3 method for class 'kppm'
model.frame(formula, ...)

 ## S3 method for class 'dppm'
model.frame(formula, ...)

 ## S3 method for class 'slrm'
model.frame(formula, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.ppm_+3A_formula">formula</code></td>
<td>

<p>A fitted point process model.
An object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>,
or <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.frame.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+model.frame.glm">model.frame.glm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="stats.html#topic+model.frame">model.frame</a></code> is generic.
These functions are method for <code><a href="stats.html#topic+model.frame">model.frame</a></code>
for fitted point process models (objects of class <code>"ppm"</code>,
<code>"kppm"</code>, <code>"slrm"</code>,
or <code>"dppm"</code>).
The first argument should be a fitted point process model;
it has to be named <code>formula</code> for consistency with the generic
function.
</p>
<p>The result is a data frame containing all the variables used in
fitting the model. The data frame has one row for each quadrature point
used in fitting the model. The quadrature scheme can be extracted using
<code><a href="#topic+quad.ppm">quad.ppm</a></code>.  
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing all the variables used in the
fitted model, plus additional variables specified in <code>...</code>.
It has an additional attribute <code>"terms"</code> containing information
about the model formula. For details see <code><a href="stats.html#topic+model.frame.glm">model.frame.glm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+slrm">slrm</a></code>,
<code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ x)
  mf &lt;- model.frame(fit)
  kfit &lt;- kppm(redwood ~ x, "Thomas")
  kmf &lt;- model.frame(kfit)
  sfit &lt;- slrm(cells ~ x)
  smf &lt;- model.frame(sfit)
</code></pre>

<hr>
<h2 id='model.images'>Compute Images of Constructed Covariates</h2><span id='topic+model.images'></span><span id='topic+model.images.ppm'></span><span id='topic+model.images.dppm'></span><span id='topic+model.images.kppm'></span><span id='topic+model.images.slrm'></span>

<h3>Description</h3>

<p>For a point process model fitted to spatial point pattern data,
this function computes pixel images of the covariates
in the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  model.images(object, ...)

  ## S3 method for class 'ppm'
model.images(object, W = as.owin(object), ...)

  ## S3 method for class 'kppm'
model.images(object, W = as.owin(object), ...)

  ## S3 method for class 'dppm'
model.images(object, W = as.owin(object), ...)


  ## S3 method for class 'slrm'
model.images(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.images_+3A_object">object</code></td>
<td>

<p>The fitted point process model. An object of class <code>"ppm"</code>
or <code>"kppm"</code>
or <code>"slrm"</code> or <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.images_+3A_w">W</code></td>
<td>

<p>A window (object of class <code>"owin"</code>) in which the
images should be computed. Defaults to the window
in which the model was fitted.
</p>
</td></tr>
<tr><td><code id="model.images_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is similar to <code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code> except
that it computes pixel images of the covariates,
instead of computing the covariate values at certain points only.
</p>
<p>The <code>object</code> must be a fitted spatial point process model
object of class <code>"ppm"</code> (produced by the model-fitting
function <code><a href="#topic+ppm">ppm</a></code>) or class <code>"kppm"</code> (produced by the
fitting function <code><a href="#topic+kppm">kppm</a></code>)
or class <code>"dppm"</code> (produced by the
fitting function <code><a href="#topic+dppm">dppm</a></code>)
or class <code>"slrm"</code> (produced by <code><a href="#topic+slrm">slrm</a></code>). 
</p>
<p>The spatial covariates required by the model-fitting procedure
are computed at every pixel location in the window <code>W</code>.
For <code>slrm</code> objects, the
covariates are computed on the pixels that were used to fit the
model.
</p>
<p>Note that the spatial covariates computed here
are not necessarily the original covariates
that were supplied when fitting the
model. Rather, they are the canonical covariates,
the covariates that appear in the
loglinear representation of the (conditional) intensity
and in the columns of the design matrix. For example, they might include
dummy or indicator variables for different levels of a factor,
depending on the contrasts that are in force.
</p>
<p>The pixel resolution is determined by <code>W</code> 
if <code>W</code> is a mask (that is <code>W$type = "mask"</code>).
Otherwise, the pixel resolution is determined by
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>.
</p>
<p>The format of the result depends on whether the original point pattern
data were marked or unmarked.
</p>

<ul>
<li>
<p>If the original dataset was unmarked,
the result is a named list of pixel images (objects of class
<code>"im"</code>) containing the values of the spatial covariates.
The names of the list elements are the names of the covariates
determined by <code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
The result is also of class <code>"solist"</code> so that it can
be plotted immediately.
</p>
</li>
<li> 
<p>If the original dataset was a multitype point pattern,
the result is a <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>
with one column for each possible type of points.
Each column is a named list of pixel images (objects of class
<code>"im"</code>) containing the values of the spatial covariates.
The row names of the hyperframe are the names of the covariates
determined by <code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list (of class <code>"solist"</code>) or
array (of class <code>"hyperframe"</code>) containing
pixel images (objects of class <code>"im"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+slrm">slrm</a></code>,
<code><a href="spatstat.geom.html#topic+im">im</a></code>,
<code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>,
<code><a href="spatstat.geom.html#topic+plot.solist">plot.solist</a></code>,
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ x)
   model.images(fit)
   B &lt;- owin(c(0.2, 0.4), c(0.3, 0.8))
   model.images(fit, B)
   fit2 &lt;- ppm(cells ~ cut(x,3))
   model.images(fit2)
   fit3 &lt;- slrm(japanesepines ~ x)
   model.images(fit3)
   fit4 &lt;- ppm(amacrine ~ marks + x)
   model.images(fit4)
</code></pre>

<hr>
<h2 id='model.matrix.mppm'>Extract Design Matrix of Point Process Model for Several Point Patterns</h2><span id='topic+model.matrix.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a list of point patterns,
this function extracts the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mppm'
model.matrix(object, ..., keepNA=TRUE, separate=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.mppm_+3A_object">object</code></td>
<td>

<p>A point process model fitted to several point patterns. 
An object of class <code>"mppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.mppm_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix.lm">model.matrix.lm</a></code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.mppm_+3A_keepna">keepNA</code></td>
<td>

<p>Logical. Determines whether rows containing <code>NA</code> values will be
deleted or retained.
</p>
</td></tr>
<tr><td><code id="model.matrix.mppm_+3A_separate">separate</code></td>
<td>

<p>Logical value indicating whether to split the model matrix into
sub-matrices corresponding to each of the original point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is a method for the generic function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. It extracts the design matrix of a
point process model fitted to several point patterns. 
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"mppm"</code>) produced by the 
fitting algorithm <code><a href="#topic+mppm">mppm</a></code>). This represents a
point process model that has been fitted
to a list of several point pattern datasets. See <code><a href="#topic+mppm">mppm</a></code>
for information.
</p>
<p>The result is a matrix with one column for every
constructed covariate in the model, and one row
for every quadrature point.
</p>
<p>If <code>separate=TRUE</code> this matrix will be split into
sub-matrices corresponding to the original point patterns,
and the result will be a list containing these matrices.
</p>


<h3>Value</h3>

<p>A matrix (or list of matrices).
Columns of the matrix are canonical covariates in the model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+mppm">mppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- mppm(Points ~ Image + x, demohyper)
   head(model.matrix(fit))
   # matrix with three columns: '(Intercept)', 'x' and 'Image'
</code></pre>

<hr>
<h2 id='model.matrix.ppm'>Extract Design Matrix from Point Process Model</h2><span id='topic+model.matrix.ppm'></span><span id='topic+model.matrix.kppm'></span><span id='topic+model.matrix.dppm'></span><span id='topic+model.matrix.ippm'></span>

<h3>Description</h3>

<p>Given a point process model that has been
fitted to spatial point pattern data,
this function extracts the design matrix of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'ppm'
model.matrix(object,
                              data=model.frame(object, na.action=NULL),
                              ..., 
                              Q=NULL, keepNA=TRUE)

   ## S3 method for class 'kppm'
model.matrix(object,
                              data=model.frame(object, na.action=NULL),
                              ..., 
                              Q=NULL, keepNA=TRUE)

   ## S3 method for class 'dppm'
model.matrix(object,
                              data=model.frame(object, na.action=NULL),
                              ..., 
                              Q=NULL, keepNA=TRUE)


   ## S3 method for class 'ippm'
model.matrix(object,
                              data=model.frame(object, na.action=NULL),
                              ..., 
                              Q=NULL, keepNA=TRUE,
			      irregular=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.ppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model. An object of class <code>"ppm"</code>
or <code>"kppm"</code> or <code>"dppm"</code> 
or <code>"ippm"</code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.ppm_+3A_data">data</code></td>
<td>

<p>A model frame, containing the data required for the Berman-Turner device.
</p>
</td></tr>
<tr><td><code id="model.matrix.ppm_+3A_q">Q</code></td>
<td>

<p>A point pattern (class <code>"ppp"</code>) or quadrature scheme
(class <code>"quad"</code>) specifying new locations where the
covariates should be computed.
</p>
</td></tr>
<tr><td><code id="model.matrix.ppm_+3A_keepna">keepNA</code></td>
<td>

<p>Logical. Determines whether rows containing NA values will be
deleted or retained.
</p>
</td></tr>
<tr><td><code id="model.matrix.ppm_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix.lm">model.matrix.lm</a></code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.ppm_+3A_irregular">irregular</code></td>
<td>

<p>Logical value indicating whether to include the irregular score
components.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These commands are methods for the generic function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
They extract the design matrix of a spatial point process model
(class <code>"ppm"</code> or <code>"kppm"</code> 
or <code>"dppm"</code>).
</p>
<p>More precisely, this command extracts
the design matrix of the generalised linear model associated with
a spatial point process model. 
</p>
<p>The <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code>
or <code>"dppm"</code>)
fitted to spatial point pattern data.
Such objects are produced by the model-fitting
functions <code><a href="#topic+ppm">ppm</a></code>, <code><a href="#topic+kppm">kppm</a></code>, 
and <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p>The methods <code>model.matrix.ppm</code>,
<code>model.matrix.kppm</code>, 
and <code>model.matrix.dppm</code>
extract the model matrix for the GLM.
</p>
<p>The result is a matrix, with one row for every quadrature point
in the fitting procedure, and one column for every constructed
covariate in the design matrix.
</p>
<p>If there are <code>NA</code> values in the covariates,
the argument <code>keepNA</code> determines whether to retain or delete
the corresponding rows of the model matrix. The default
<code>keepNA=TRUE</code> is to retain them. Note that this differs from
the default behaviour of many other methods for <code>model.matrix</code>,
which typically delete rows containing <code>NA</code>.
</p>
<p>The quadrature points themselves can be extracted using
<code><a href="#topic+quad.ppm">quad.ppm</a></code>.
</p>


<h3>Value</h3>

<p>A matrix. Columns of the matrix are canonical covariates in the model.
Rows of the matrix correspond to quadrature points
in the fitting procedure (provided <code>keepNA=TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+model.images">model.images</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+ippm">ippm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+quad.ppm">quad.ppm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ x)
   head(model.matrix(fit))
   model.matrix(fit, Q=runifpoint(5))
   kfit &lt;- kppm(redwood ~ x, "Thomas")
   m &lt;- model.matrix(kfit)
</code></pre>

<hr>
<h2 id='model.matrix.slrm'>Extract Design Matrix from Spatial Logistic Regression Model</h2><span id='topic+model.matrix.slrm'></span>

<h3>Description</h3>

<p>This function extracts the design matrix of a
spatial logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'slrm'
model.matrix(object, ..., keepNA=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.slrm_+3A_object">object</code></td>
<td>

<p>A fitted spatial logistic regression model. An object of class 
<code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.slrm_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix.lm">model.matrix.lm</a></code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.slrm_+3A_keepna">keepNA</code></td>
<td>

<p>Logical. Determines whether rows containing <code>NA</code> values will be
deleted or retained.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is a method for the generic function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. It extracts the design matrix of a
spatial logistic regression.
</p>
<p>The <code>object</code> must be a fitted
spatial logistic regression 
(object of class <code>"slrm"</code>).
Such objects are produced by the model-fitting
function <code><a href="#topic+slrm">slrm</a></code>.
</p>
<p>Usually the result is a matrix with one column for every
constructed covariate in the model, and one row
for every pixel in the grid used to fit the model.
</p>
<p>If <code>object</code> was fitted using split pixels (by calling
<code><a href="#topic+slrm">slrm</a></code> using the argument <code>splitby</code>) then the
matrix has one row for every pixel or half-pixel.
</p>


<h3>Value</h3>

<p>A matrix. Columns of the matrix are canonical covariates in the model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+model.images">model.images</a></code>,
<code><a href="#topic+slrm">slrm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- slrm(japanesepines ~x)
   head(model.matrix(fit))
   # matrix with two columns: '(Intercept)' and 'x'
</code></pre>

<hr>
<h2 id='mppm'>Fit Point Process Model to Several Point Patterns</h2><span id='topic+mppm'></span>

<h3>Description</h3>

<p>Fits a Gibbs point process model to several point patterns
simultaneously. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   mppm(formula, data, interaction=Poisson(), ...,
        iformula=NULL, 
        random=NULL,
        weights=NULL,
        use.gam = FALSE, 
        reltol.pql=1e-3,
        gcontrol=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mppm_+3A_formula">formula</code></td>
<td>

<p>A formula describing the systematic part of the model.
Variables in the formula are names of columns in <code>data</code>.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_data">data</code></td>
<td>

<p>A hyperframe (object of class <code>"hyperframe"</code>,
see <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>) containing the
point pattern responses and the explanatory variables. 
</p>
</td></tr>
<tr><td><code id="mppm_+3A_interaction">interaction</code></td>
<td>

<p>Interpoint interaction(s) appearing in the model.
Either an object of class <code>"interact"</code>
describing the point process interaction
structure, or a hyperframe (with the same number of
rows as <code>data</code>) whose entries are objects of class
<code>"interact"</code>.     
</p>
</td></tr>
<tr><td><code id="mppm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ppm">ppm</a></code> controlling
the fitting procedure.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_iformula">iformula</code></td>
<td>

<p>Optional. A formula (with no left hand side)
describing the interaction to be applied to each case.
Each variable name in the formula should either be the name of a column
in the hyperframe <code>interaction</code>, or the name of a column
in the hyperframe <code>data</code> that is a vector or factor.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_random">random</code></td>
<td>

<p>Optional. A formula (with no left hand side)
describing a random effect. Variable names in the formula
may be any of the column names of <code>data</code> and <code>interaction</code>.
The formula must be recognisable to <code><a href="nlme.html#topic+lme">lme</a></code>. 
</p>
</td></tr>
<tr><td><code id="mppm_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of case weights for each row of <code>data</code>.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_use.gam">use.gam</code></td>
<td>
<p>Logical flag indicating whether to fit the model
using <code><a href="mgcv.html#topic+gam">gam</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_reltol.pql">reltol.pql</code></td>
<td>

<p>Relative tolerance for successive steps in
the penalised quasi-likelihood algorithm,
used when the model includes random effects.
The algorithm terminates when the root mean square of the
relative change in coefficients is less than <code>reltol.pql</code>.
</p>
</td></tr>
<tr><td><code id="mppm_+3A_gcontrol">gcontrol</code></td>
<td>

<p>List of arguments to control the fitting algorithm.
Arguments are passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>
or <code><a href="mgcv.html#topic+gam.control">gam.control</a></code>
or <code><a href="nlme.html#topic+lmeControl">lmeControl</a></code>
depending on the kind of model being fitted.
If the model has random effects, the arguments are passed to
<code><a href="nlme.html#topic+lmeControl">lmeControl</a></code>. Otherwise,
if <code>use.gam=TRUE</code> the arguments are passed to
<code><a href="mgcv.html#topic+gam.control">gam.control</a></code>, and if
<code>use.gam=FALSE</code> (the default) they are passed to
<code><a href="stats.html#topic+glm.control">glm.control</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a common point process model to a dataset
containing several different point patterns.
</p>
<p>It extends the capabilities of the function <code><a href="#topic+ppm">ppm</a></code>
to deal with data such as
</p>

<ul>
<li><p> replicated observations of spatial point patterns
</p>
</li>
<li><p> two groups of spatial point patterns
</p>
</li>
<li><p> a designed experiment in which the response from each unit
is a point pattern.
</p>
</li></ul>

<p>The syntax of this function is similar to that of
standard <span class="rlang"><b>R</b></span> model-fitting functions like <code><a href="stats.html#topic+lm">lm</a></code> and
<code><a href="stats.html#topic+glm">glm</a></code>. The first argument <code>formula</code>  is an <span class="rlang"><b>R</b></span> formula
describing the systematic part of the model. The second argument
<code>data</code> contains the responses and the explanatory variables.
Other arguments determine the stochastic structure of the model.
</p>
<p>Schematically,
the data are regarded as the results of a designed experiment
involving <code class="reqn">n</code> experimental units.  Each unit has a
&lsquo;response&rsquo;, and optionally some &lsquo;explanatory variables&rsquo;
(covariates) describing the experimental conditions for that unit.
In this context,
<em>the response from each unit is a point pattern</em>.
The value of a particular covariate for each unit can be
either a single value (numerical, logical or factor),
or a spatial covariate.
A &lsquo;spatial&rsquo; covariate is a quantity that depends on spatial location,
for example, the soil acidity or altitude at each location.
For the purposes of <code>mppm</code>, a spatial covariate must be stored
as a pixel image (object of class <code>"im"</code>) which gives the values
of the covariate at a fine grid of locations.
</p>
<p>The argument <code>data</code> is a hyperframe (a generalisation of
a data frame, see <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>). This is like a data frame
except that the entries can be objects of any class.
The hyperframe has one row for each experimental unit,
and one column for each variable (response or explanatory variable).
</p>
<p>The <code>formula</code> should be an <span class="rlang"><b>R</b></span> formula.
The left hand side of <code>formula</code> determines the &lsquo;response&rsquo;
variable. This should be a single name, which
should correspond to a column in <code>data</code>.
</p>
<p>The right hand side of <code>formula</code> determines the 
spatial trend of the model. It specifies the linear predictor,
and effectively represents the <b>logarithm</b>
of the spatial trend.
Variables in the formula must be the names of columns of
<code>data</code>, or one of the reserved names
</p>

<dl>
<dt>x,y</dt><dd><p>Cartesian coordinates of location</p>
</dd>
<dt>marks</dt><dd><p>Mark attached to point</p>
</dd>
<dt>id</dt><dd><p>which is a factor representing the
serial number (<code class="reqn">1</code> to <code class="reqn">n</code>) of the point pattern,
i.e. the row number in the data hyperframe.
</p>
</dd>
</dl>

<p>The column of responses in <code>data</code>
must consist of point patterns (objects of class <code>"ppp"</code>).
The individual point pattern responses 
can be defined in different spatial windows.
If some of the point patterns are marked, then they must all be
marked, and must have the same type of marks.
</p>
<p>The scope of models that can be fitted to each pattern is the same as the
scope of <code><a href="#topic+ppm">ppm</a></code>, that is, Gibbs point processes with
interaction terms that belong to a specified list, including
for example the Poisson process, Strauss process, Geyer's saturation
model, and piecewise constant pairwise interaction models.
Additionally, it is possible to include random effects
as explained in the section on Random Effects below.
</p>
<p>The stochastic part of the model is determined by
the arguments <code>interaction</code> and (optionally) <code>iformula</code>.
</p>

<ul>
<li> 
<p>In the simplest case, <code>interaction</code> is 
an object of class <code>"interact"</code>,
determining the interpoint interaction structure of the point
process model, for all experimental units.
</p>
</li>
<li>
<p>Alternatively, <code>interaction</code> may be a hyperframe,
whose entries are objects of class <code>"interact"</code>.
It should have the same number of rows as <code>data</code>.
</p>

<ul>
<li>
<p>If <code>interaction</code> consists of only one column,
then the entry in row <code>i</code> is taken to be the
interpoint interaction for the <code>i</code>th experimental unit
(corresponding to the <code>i</code>th row of <code>data</code>).
</p>
</li>
<li>
<p>If <code>interaction</code> has more than one column,
then the argument <code>iformula</code> is also required.
Each row of <code>interaction</code> determines
several interpoint interaction structures that might be applied
to the corresponding row of <code>data</code>.
The choice of interaction is determined by <code>iformula</code>;
this should be an <span class="rlang"><b>R</b></span> formula,
without a left hand side.
For example if <code>interaction</code> has two columns called
<code>A</code> and <code>B</code> then <code>iformula = ~B</code> indicates that the
interpoint interactions are taken from the second column.
</p>
</li></ul>

</li></ul>

<p>Variables in <code>iformula</code>
typically refer to column names of <code>interaction</code>.
They can also be names of columns in
<code>data</code>, but only for columns of numeric, logical or factor
values. For example <code>iformula = ~B * group</code> (where <code>group</code>
is a column of <code>data</code> that contains a factor) causes the
model with interpoint interaction <code>B</code> to be fitted
with different interaction parameters for each level of <code>group</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"mppm"</code> representing the
fitted model.
</p>
<p>There are methods for
<code>print</code>, <code>summary</code>, <code>coef</code>,
<code>AIC</code>, <code>anova</code>, <code>fitted</code>, <code>fixef</code>, <code>logLik</code>,
<code>plot</code>, <code>predict</code>, <code>ranef</code>, <code>residuals</code>,
<code>summary</code>, <code>terms</code> and <code>vcov</code> for this class.
</p>
<p>The default methods for <code><a href="stats.html#topic+update">update</a></code>
and <code><a href="stats.html#topic+formula">formula</a></code> also work on this class.
</p>


<h3>Random Effects</h3>

<p>It is also possible to include random effects in the
trend term. The argument <code>random</code> is a formula,
with no left-hand side, that specifies the structure of the
random effects. The formula should be recognisable to
<code><a href="nlme.html#topic+lme">lme</a></code> (see the description of the argument <code>random</code>
for <code><a href="nlme.html#topic+lme">lme</a></code>).
</p>
<p>The names in the formula <code>random</code> may be any of the covariates
supplied by <code>data</code>.
Additionally the formula may involve the name
<code>id</code>, which is a factor representing the
serial number (<code class="reqn">1</code> to <code class="reqn">n</code>) of the point pattern in the
list <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented in <span class="pkg">spatstat</span> by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R.
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> (2000) 283&ndash;322.
</p>
<p>Baddeley, A., Bischof, L., Sintorn, I.-M., Haggarty, S.,
Bell, M. and Turner, R. 
Analysis of a designed experiment where the response is a spatial
point pattern. In preparation.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Bell, M. and Grunwald, G. (2004)
Mixed models for the analysis of replicated spatial point patterns.
<em>Biostatistics</em> <b>5</b>, 633&ndash;648.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+print.mppm">print.mppm</a></code>,
<code><a href="#topic+summary.mppm">summary.mppm</a></code>,
<code><a href="#topic+coef.mppm">coef.mppm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Waterstriders data
 H &lt;- hyperframe(Y = waterstriders)
 mppm(Y ~ 1,  data=H)
 mppm(Y ~ 1,  data=H, Strauss(7))
 mppm(Y ~ id, data=H)
 mppm(Y ~ x,  data=H)

# Synthetic data from known model
n &lt;- 10
H &lt;- hyperframe(V=1:n,
                U=runif(n, min=-1, max=1),
                M=factor(letters[1 + (1:n) %% 3]))
H$Z &lt;- setcov(square(1))
H$U &lt;- with(H, as.im(U, as.rectangle(Z)))
H$Y &lt;- with(H, rpoispp(eval.im(exp(2+3*Z))))

fit &lt;- mppm(Y ~Z + U + V, data=H)
</code></pre>

<hr>
<h2 id='msr'>
Signed or Vector-Valued Measure
</h2><span id='topic+msr'></span>

<h3>Description</h3>

<p>Defines an object representing a signed measure or vector-valued
measure on a spatial domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  msr(qscheme, discrete, density, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msr_+3A_qscheme">qscheme</code></td>
<td>

<p>A quadrature scheme (object of class <code>"quad"</code> usually
extracted from a fitted point process model).
</p>
</td></tr>
<tr><td><code id="msr_+3A_discrete">discrete</code></td>
<td>

<p>Vector or matrix containing the values (masses) of the discrete component
of the measure, for each of the data points in <code>qscheme</code>.
</p>
</td></tr>
<tr><td><code id="msr_+3A_density">density</code></td>
<td>

<p>Vector or matrix containing values of the density of the
diffuse component of the measure, for each of the
quadrature points in <code>qscheme</code>.
</p>
</td></tr>
<tr><td><code id="msr_+3A_check">check</code></td>
<td>

<p>Logical. Whether to check validity of the arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates an object that represents a
signed or vector valued <em>measure</em> on the two-dimensional plane.
It is not normally called directly by the user.
</p>
<p>A signed measure is a classical mathematical object
(Diestel and Uhl, 1977)
which can be visualised as a collection of electric charges, positive and/or
negative, spread over the plane. Electric charges may be
concentrated at specific points (atoms), or spread diffusely over a
region. 
</p>
<p>An object of class <code>"msr"</code> represents a signed (i.e. real-valued)
or vector-valued measure in the <span class="pkg">spatstat</span> package.
</p>
<p>Spatial residuals for point process models
(Baddeley et al, 2005, 2008) take the form of a real-valued
or vector-valued measure. The function
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code> returns an object of
class <code>"msr"</code> representing the residual measure.
Various other diagnostic tools such as <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code> and
<code><a href="#topic+dffit.ppm">dffit.ppm</a></code> also return an object of class <code>"msr"</code>.
</p>
<p>The function <code>msr</code>  would not normally be called directly by the
user. It is the low-level creator function that
makes an object of class <code>"msr"</code> from raw data.
</p>
<p>The first argument <code>qscheme</code> is a quadrature scheme (object of
class <code>"quad"</code>). It is typically created by <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code> or
extracted from a fitted point process model using
<code><a href="#topic+quad.ppm">quad.ppm</a></code>. A quadrature scheme contains both data points
and dummy points. The data points of <code>qscheme</code> are used as the locations
of the atoms of the measure. All quadrature points
(i.e. both data points and dummy points)
of <code>qscheme</code> are used as sampling points for the density
of the continuous component of the measure.
</p>
<p>The argument <code>discrete</code> gives the values of the
atomic component of the measure for each <em>data point</em> in <code>qscheme</code>.
It should be either a numeric vector with one entry for each
data point, or a numeric matrix with one row
for each data point. 
</p>
<p>The argument <code>density</code> gives the values of the <em>density</em>
of the diffuse component of the measure, at each
<em>quadrature point</em> in <code>qscheme</code>.
It should be either a numeric vector with one entry for each
quadrature point, or a numeric matrix with one row
for each quadrature point. 
</p>
<p>If both <code>discrete</code> and <code>density</code> are vectors
(or one-column matrices) then the result is a signed (real-valued) measure.
Otherwise, the result is a vector-valued measure, with the dimension
of the vector space being determined by the number of columns
in the matrices <code>discrete</code> and/or <code>density</code>.
(If one of these is a <code class="reqn">k</code>-column matrix and the other
is a 1-column matrix, then the latter is replicated to <code class="reqn">k</code> columns).
</p>
<p>The class <code>"msr"</code> has methods for <code>print</code>,
<code>plot</code> and <code>[</code>. 
There is also a function <code><a href="#topic+Smooth.msr">Smooth.msr</a></code> for smoothing a measure.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code>.
</p>


<h3>Guide to using measures</h3>

<p>Objects of class <code>"msr"</code>, representing measures, are returned by the
functions <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>, <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>,
<code><a href="#topic+dffit.ppm">dffit.ppm</a></code> and possibly by other functions.
</p>
<p>There are methods for printing and plotting a measure, along with
many other operations, which can be listed by
typing <code>methods(class="msr")</code>.
</p>
<p>The <code>print</code> and <code>summary</code> methods report basic information
about a measure, such as the total value of the measure, and the
spatial domain on which it is defined.
</p>
<p>The <code>plot</code> method displays the measure. It is documented separately in
<code><a href="#topic+plot.msr">plot.msr</a></code>.
</p>
<p>A measure can be smoothed using <code><a href="#topic+Smooth.msr">Smooth.msr</a></code>, yielding a
pixel image which is sometimes easier to interpret than the plot
of the measure itself.
</p>
<p>The subset operator <code>[</code> can be used to restrict the measure to
a subregion of space, or to extract one of the scalar components of a
vector-valued measure. It is documented separately in
<code><a href="#topic++5B.msr">[.msr</a></code>.
</p>
<p>The total value of a measure, or the value on a subregion,
can be obtained using <code><a href="#topic+integral.msr">integral.msr</a></code>.
The value of a measure <code>m</code> on a subregion
<code>B</code> can be obtained by <code>integral(m, domain=B)</code> or
<code>integral(m[B])</code>. The values of a measure <code>m</code> on each tile
of a tessellation <code>A</code> can be obtained by
<code>integral(m, domain=A)</code>.
</p>
<p>Some mathematical operations on measures are supported, such as
multiplying a measure by a single number, or adding two measures.
</p>
<p>Measures can be separated into components in different ways using
<code><a href="#topic+as.layered.msr">as.layered.msr</a></code>, <code><a href="#topic+unstack.msr">unstack.msr</a></code>
and <code><a href="#topic+split.msr">split.msr</a></code>.
</p>
<p>Internal components of the data structure of an <code>"msr"</code> object
can be extracted using <code><a href="#topic+with.msr">with.msr</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J.  and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J.  and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>
<p>Diestel, J. and Uhl, J.J. Jr (1977)
<em>Vector measures</em>.
Providence, RI, USA: American Mathematical Society.
</p>
<p>Halmos, P.R. (1950) <em>Measure Theory</em>. Van Nostrand.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.msr">plot.msr</a></code>,
<code><a href="#topic+Smooth.msr">Smooth.msr</a></code>,
<code><a href="#topic++5B.msr">[.msr</a></code>,
<code><a href="#topic+with.msr">with.msr</a></code>,
<code><a href="#topic+split.msr">split.msr</a></code>,
<code><a href="#topic+Ops.msr">Ops.msr</a></code>,
<code><a href="#topic+measureVariation">measureVariation</a></code>,
<code><a href="#topic+measureWeighted">measureWeighted</a></code>,
<code><a href="#topic+measureContinuous">measureContinuous</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   
   rp &lt;- residuals(fit, type="pearson")
   rp

   rs &lt;- residuals(fit, type="score")
   rs
   colnames(rs)

   # An equivalent way to construct the Pearson residual measure by hand
   Q &lt;- quad.ppm(fit)
   lambda &lt;- fitted(fit)
   slam &lt;- sqrt(lambda)
   Z &lt;- is.data(Q)
   m &lt;- msr(Q, discrete=1/slam[Z], density = -slam)
   m
</code></pre>

<hr>
<h2 id='MultiHard'>The Multitype Hard Core Point Process Model</h2><span id='topic+MultiHard'></span>

<h3>Description</h3>

<p>Creates an instance of the multitype hard core point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MultiHard(hradii, types=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiHard_+3A_hradii">hradii</code></td>
<td>
<p>Matrix of hard core radii</p>
</td></tr>
<tr><td><code id="MultiHard_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a multitype version of the hard core process.
A pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code>
must not lie closer than <code class="reqn">h_{ij}</code> units apart.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the MultiStrauss interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrix <code>hradii</code>.
</p>
<p>The matrix <code>hradii</code>
must be symmetric, with entries
which are either positive numbers or <code>NA</code>. 
A value of <code>NA</code> indicates that no distance constraint should be applied
for this combination of types.
</p>
<p>Note that only the hardcore radii
are specified in <code>MultiHard</code>.
The canonical parameters <code class="reqn">\log(\beta_j)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>MultiHard()</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the multitype hard core process with
hard core radii <code class="reqn">hradii[i,j]</code>.
</p>


<h3>Warnings</h3>

<p>In order that <code><a href="#topic+ppm">ppm</a></code> can fit the multitype hard core
model correctly to a point pattern <code>X</code>, this pattern must
be marked, with <code>markformat</code> equal to <code>vector</code> and the
mark vector <code>marks(X)</code> must be a factor.  If the argument
<code>types</code> is specified it is interpreted as a set of factor
levels and this set must equal <code>levels(marks(X))</code>.
</p>


<h3>Changed Syntax</h3>

<p>Before <span class="pkg">spatstat</span> version <code>1.37-0</code>,
the syntax of this function was different:
<code>MultiHard(types=NULL, hradii)</code>.
The new code attempts to handle the old syntax as well.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>.
</p>
<p>See <code><a href="spatstat.random.html#topic+ragsMultiHard">ragsMultiHard</a></code> and <code><a href="spatstat.random.html#topic+rmh">rmh</a></code> for
simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   h &lt;- matrix(c(1,2,2,1), nrow=2,ncol=2)

   # prints a sensible description of itself
   MultiHard(h)

   # Fit the stationary multitype hardcore process to `amacrine'
   # with hard core operating only between cells of the same type.
   h &lt;- 0.02 * matrix(c(1, NA, NA, 1), nrow=2,ncol=2)
   ppm(amacrine ~1, MultiHard(h))
</code></pre>

<hr>
<h2 id='MultiStrauss'>The Multitype Strauss Point Process Model</h2><span id='topic+MultiStrauss'></span>

<h3>Description</h3>

<p>Creates an instance of the multitype Strauss point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MultiStrauss(radii, types=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiStrauss_+3A_radii">radii</code></td>
<td>
<p>Matrix of interaction radii</p>
</td></tr>
<tr><td><code id="MultiStrauss_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (stationary) multitype
Strauss process with <code class="reqn">m</code> types, with interaction radii
<code class="reqn">r_{ij}</code> and 
parameters <code class="reqn">\beta_j</code> and <code class="reqn">\gamma_{ij}</code>
is the pairwise interaction point process
in which each point of type <code class="reqn">j</code>
contributes a factor <code class="reqn">\beta_j</code> to the 
probability density of the point pattern, and a pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code> closer than <code class="reqn">r_{ij}</code>
units apart contributes a factor
<code class="reqn">\gamma_{ij}</code> to the density.
</p>
<p>The nonstationary multitype Strauss process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location and type, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the multitype
Strauss process pairwise interaction is
yielded by the function <code>MultiStrauss()</code>. See the examples below.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the MultiStrauss interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrix <code>radii</code>.
</p>
<p>The matrix <code>radii</code> must be symmetric, with entries
which are either positive numbers or <code>NA</code>. 
A value of <code>NA</code> indicates that no interaction term should be included
for this combination of types.
</p>
<p>Note that only the interaction radii are
specified in <code>MultiStrauss</code>.  The canonical
parameters <code class="reqn">\log(\beta_j)</code> and
<code class="reqn">\log(\gamma_{ij})</code> are estimated by
<code><a href="#topic+ppm">ppm</a>()</code>, not fixed in <code>MultiStrauss()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the multitype Strauss process with
interaction radii <code class="reqn">radii[i,j]</code>.
</p>


<h3>Warnings</h3>

<p>In order that <code><a href="#topic+ppm">ppm</a></code> can fit the multitype Strauss
model correctly to a point pattern <code>X</code>, this pattern must
be marked, with <code>markformat</code> equal to <code>vector</code> and the
mark vector <code>marks(X)</code> must be a factor.  If the argument
<code>types</code> is specified it is interpreted as a set of factor
levels and this set must equal <code>levels(marks(X))</code>.
</p>


<h3>Changed Syntax</h3>

<p>Before <span class="pkg">spatstat</span> version <code>1.37-0</code>,
the syntax of this function was different:
<code>MultiStrauss(types=NULL, radii)</code>.
The new code attempts to handle the old syntax as well.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+MultiHard">MultiHard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   r &lt;- matrix(c(1,2,2,1), nrow=2,ncol=2)
   MultiStrauss(r)
   # prints a sensible description of itself
   r &lt;- 0.03 * matrix(c(1,2,2,1), nrow=2,ncol=2)
   X &lt;- amacrine
   
   ppm(X ~1, MultiStrauss(r))
   # fit the stationary multitype Strauss process to `amacrine'

   
     ppm(X ~polynom(x,y,3), MultiStrauss(r, c("off","on")))
     # fit a nonstationary multitype Strauss process with log-cubic trend
   
</code></pre>

<hr>
<h2 id='MultiStraussHard'>The Multitype/Hard Core Strauss Point Process Model</h2><span id='topic+MultiStraussHard'></span>

<h3>Description</h3>

<p>Creates an instance of the multitype/hard core Strauss point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  MultiStraussHard(iradii, hradii, types=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiStraussHard_+3A_iradii">iradii</code></td>
<td>
<p>Matrix of interaction radii</p>
</td></tr>
<tr><td><code id="MultiStraussHard_+3A_hradii">hradii</code></td>
<td>
<p>Matrix of hard core radii</p>
</td></tr>
<tr><td><code id="MultiStraussHard_+3A_types">types</code></td>
<td>
<p>Optional; vector of all possible types (i.e. the possible levels
of the <code>marks</code> variable in the data)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a hybrid of the multitype Strauss process
(see <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>) and the hard core process
(case <code class="reqn">\gamma=0</code> of the Strauss process).
A pair of points
of types <code class="reqn">i</code> and <code class="reqn">j</code>
must not lie closer than <code class="reqn">h_{ij}</code> units apart;
if the pair lies more than <code class="reqn">h_{ij}</code> and less than 
<code class="reqn">r_{ij}</code> units apart, it
contributes a factor
<code class="reqn">\gamma_{ij}</code> to the probability density.
</p>
<p>The argument <code>types</code> need not be specified in normal use.
It will be determined automatically from the point pattern data set
to which the MultiStraussHard interaction is applied,
when the user calls <code><a href="#topic+ppm">ppm</a></code>. 
However, the user should be confident that
the ordering of types in the dataset corresponds to the ordering of
rows and columns in the matrices <code>iradii</code> and <code>hradii</code>.
</p>
<p>The matrices <code>iradii</code> and <code>hradii</code>
must be symmetric, with entries
which are either positive numbers or <code>NA</code>. 
A value of <code>NA</code> indicates that no interaction term should be included
for this combination of types.
</p>
<p>Note that only the interaction radii and hardcore radii
are specified in <code>MultiStraussHard</code>.
The canonical parameters <code class="reqn">\log(\beta_j)</code>
and <code class="reqn">\log(\gamma_{ij})</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>MultiStraussHard()</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the multitype/hard core Strauss process with
interaction radii <code class="reqn">iradii[i,j]</code>
and hard core radii <code class="reqn">hradii[i,j]</code>.
</p>


<h3>Warnings</h3>

<p>In order that <code><a href="#topic+ppm">ppm</a></code> can fit the multitype/hard core
Strauss model correctly to a point pattern <code>X</code>, this pattern
must be marked, with <code>markformat</code> equal to <code>vector</code>
and the mark vector <code>marks(X)</code> must be a factor.  If the
argument <code>types</code> is specified it is interpreted as a set of
factor levels and this set must equal <code>levels(marks(X))</code>.
</p>


<h3>Changed Syntax</h3>

<p>Before <span class="pkg">spatstat</span> version <code>1.37-0</code>,
the syntax of this function was different:
<code>MultiStraussHard(types=NULL, iradii, hradii)</code>.
The new code attempts to handle the old syntax as well.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiHard">MultiHard</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   r &lt;- matrix(3, nrow=2,ncol=2)
   h &lt;- matrix(c(1,2,2,1), nrow=2,ncol=2)
   MultiStraussHard(r,h)
   # prints a sensible description of itself
   r &lt;- 0.04 * matrix(c(1,2,2,1), nrow=2,ncol=2)
   h &lt;- 0.02 * matrix(c(1,NA,NA,1), nrow=2,ncol=2)
   X &lt;- amacrine
   
   fit &lt;- ppm(X ~1, MultiStraussHard(r,h))
   # fit stationary multitype hardcore Strauss process to `amacrine'
</code></pre>

<hr>
<h2 id='npfun'>
Dummy Function Returns Number of Points
</h2><span id='topic+npfun'></span>

<h3>Description</h3>

<p>Returns a summary function which is constant with value equal to
the number of points in the point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npfun(X, ..., r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npfun_+3A_x">X</code></td>
<td>

<p>Point pattern.
</p>
</td></tr>
<tr><td><code id="npfun_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="npfun_+3A_r">r</code></td>
<td>

<p>Vector of values of the distance argument <code class="reqn">r</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is normally not called by the user. Instead it is passed
as an argument to the function <code><a href="#topic+psst">psst</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"fv"</code> representing a constant function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psst">psst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit0 &lt;- ppm(cells, ~1, nd=10)
  v &lt;- psst(fit0, npfun)
</code></pre>

<hr>
<h2 id='objsurf'>
Objective Function Surface
</h2><span id='topic+objsurf'></span><span id='topic+objsurf.dppm'></span><span id='topic+objsurf.kppm'></span><span id='topic+objsurf.minconfit'></span>

<h3>Description</h3>

<p>For a model that was fitted by optimisation,
compute the values of the objective function in a neighbourhood
of the optimal value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objsurf(x, ...)

## S3 method for class 'dppm'
objsurf(x, ..., ngrid = 32, xlim=NULL, ylim=NULL,
                               enclose=FALSE,
                               ratio = 1.5, verbose = TRUE)

## S3 method for class 'kppm'
objsurf(x, ..., ngrid = 32, xlim=NULL, ylim=NULL,
                               enclose=FALSE,
                               ratio = 1.5, verbose = TRUE)

## S3 method for class 'minconfit'
objsurf(x, ..., ngrid = 32, xlim=NULL, ylim=NULL,
                               ratio = 1.5, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objsurf_+3A_x">x</code></td>
<td>

<p>Some kind of model that was fitted
by finding the optimal value of an objective function. 
An object of class <code>"dppm"</code>, <code>"kppm"</code> or <code>"minconfit"</code>.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_...">...</code></td>
<td>

<p>Extra arguments are usually ignored.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_ngrid">ngrid</code></td>
<td>

<p>Number of grid points to evaluate along each axis.
Either a single integer, or a pair of integers.
For example <code>ngrid=32</code> would mean a <code>32 * 32</code> grid.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_xlim">xlim</code>, <code id="objsurf_+3A_ylim">ylim</code></td>
<td>

<p>Optional. Numeric vectors of length 2, specifying the
limits for the two parameters to be considered.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_enclose">enclose</code></td>
<td>

<p>Logical value specifying whether the default values of
<code>xlim</code> and <code>ylim</code> should enclose the history of all
function evaluations. See Details.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_ratio">ratio</code></td>
<td>

<p>Number greater than 1 determining the default ranges of parameter
values. See Details.
</p>
</td></tr>
<tr><td><code id="objsurf_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>x</code> should be some kind of model that was fitted
by maximising or minimising the value of an objective function.
The objective function will be evaluated on a grid of
values of the model parameters. 
</p>
<p>Currently the following types of objects are accepted:
</p>

<ul>
<li>
<p>an object of class <code>"dppm"</code> representing a
determinantal point process.
See <code><a href="#topic+dppm">dppm</a></code>.
</p>
</li>
<li>
<p>an object of class <code>"kppm"</code> representing a
cluster point process or Cox point process. 
See <code><a href="#topic+kppm">kppm</a></code>.
</p>
</li>
<li>
<p>an object of class <code>"minconfit"</code> representing a
minimum-contrast fit between a summary function and its
theoretical counterpart. 
See <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
</li></ul>

<p>The result is an object of class <code>"objsurf"</code> which can be
printed and plotted: see <code><a href="#topic+methods.objsurf">methods.objsurf</a></code>.
</p>
<p>The range of parameter values to be considered is determined by
<code>xlim</code> and <code>ylim</code>. 
The default values of <code>xlim</code> and <code>ylim</code> are
chosen as follows.
</p>

<ul>
<li><p> if <code>enclose=FALSE</code> (the default), 
the default values of <code>xlim</code> and <code>ylim</code> are
the ranges from <code>opt/ratio</code> to <code>opt * ratio</code>
where <code>opt</code> is the optimal parameter value on the surface.
</p>
</li>
<li> 
<p>If <code>enclose=TRUE</code>, 
and if <code>x</code> contains a trajectory
(history of function evaluations),
then <code>xlim</code> and <code>ylim</code> will be the ranges
of parameter values examined in the trajectory.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"objsurf"</code> which can be
printed and plotted.
Essentially a list containing entries <code>x</code>, <code>y</code>, <code>z</code>
giving the parameter values and objective function values.
</p>
<p>There are methods for <code>plot</code>, <code>print</code>, <code>summary</code>,
<code>image</code>, <code>contour</code> and <code>persp</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.objsurf">methods.objsurf</a></code>,
<code><a href="#topic+kppm">kppm</a></code>, 
<code><a href="#topic+mincontrast">mincontrast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- kppm(redwood ~ 1, "Thomas")
   os &lt;- objsurf(fit)

   if(interactive()) {
     plot(os)
     contour(os, add=TRUE)
     persp(os)
   }
</code></pre>

<hr>
<h2 id='Ops.msr'>Arithmetic Operations on Measures</h2><span id='topic+Ops.msr'></span>

<h3>Description</h3>

<p>These group generic methods for the class <code>"msr"</code>
allow the arithmetic operators
<code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> to be applied
directly to measures. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Ops(e1, e2)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.msr_+3A_e1">e1</code>, <code id="Ops.msr_+3A_e2">e2</code></td>
<td>
<p>objects of class <code>"msr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arithmetic operators on a measure <code>A</code> are only defined
in some cases. The arithmetic operator is effectively applied
to the value of <code>A(W)</code> for every spatial domain <code>W</code>.
If the result is a measure, then this operation is valid.
</p>
<p>If <code>A</code> is a measure (object of class <code>"msr"</code>)
then the operations <code>-A</code> and <code>+A</code> are defined.
</p>
<p>If <code>A</code> and <code>B</code> are measures with the same dimension
(i.e. both are scalar-valued, or both are <code>k</code>-dimensional vector-valued)
then <code>A + B</code> and <code>A - B</code> are defined.
</p>
<p>If <code>A</code> is a measure and <code>z</code> is a numeric value,
then <code>A * z</code> and <code>A / z</code> are defined,
and <code>z * A</code> is defined.
</p>


<h3>Value</h3>

<p>Another measure (object of class <code>"msr"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+with.msr">with.msr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")
   rp

   -rp
   2 * rp
   rp /2

   rp - rp

   rr &lt;- residuals(fit, type="raw")
   rp - rr
</code></pre>

<hr>
<h2 id='Ord'>Generic Ord Interaction model</h2><span id='topic+Ord'></span>

<h3>Description</h3>

<p>Creates an instance of an Ord-type interaction point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Ord(pot, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ord_+3A_pot">pot</code></td>
<td>
<p>An S language function giving the user-supplied
interaction potential.</p>
</td></tr>
<tr><td><code id="Ord_+3A_name">name</code></td>
<td>
<p>Character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ord's point process model (Ord, 1977) is a Gibbs point process
of infinite order. Each point <code class="reqn">x_i</code> in the point pattern
<code class="reqn">x</code> contributes a factor <code class="reqn">g(a_i)</code> where
<code class="reqn">a_i = a(x_i, x)</code> is the area of the
tile associated with <code class="reqn">x_i</code>
in the Dirichlet tessellation of <code class="reqn">x</code>.
</p>
<p>Ord (1977) proposed fitting this model to forestry data
when <code class="reqn">g(a)</code> has a simple &ldquo;threshold&rdquo; form. That model is
implemented in our function <code><a href="#topic+OrdThresh">OrdThresh</a></code>.
The present function <code>Ord</code> implements the case of a
completely general Ord potential <code class="reqn">g(a)</code>
specified as an S language function <code>pot</code>.
</p>
<p>This is experimental. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ord, J.K. (1977) 
Contribution to the discussion of Ripley (1977).
</p>
<p>Ord, J.K. (1978) 
How many trees in a forest?
<em>Mathematical Scientist</em> <b>3</b>, 23&ndash;33.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>
</p>

<hr>
<h2 id='ord.family'>Ord Interaction Process Family</h2><span id='topic+ord.family'></span>

<h3>Description</h3>

<p>An object describing the family of all Ord interaction point processes
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes 
the family of point process models introduced by Ord (1977).
</p>
<p>If you need to create a specific Ord-type model for use in 
analysis, use the function <code><a href="#topic+OrdThresh">OrdThresh</a></code> or
<code><a href="#topic+Ord">Ord</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ord, J.K. (1977) 
Contribution to the discussion of Ripley (1977).
</p>
<p>Ord, J.K. (1978) 
How many trees in a forest?
<em>Mathematical Scientist</em> <b>3</b>, 23&ndash;33.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+Ord">Ord</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>
</p>

<hr>
<h2 id='OrdThresh'>Ord's Interaction model</h2><span id='topic+OrdThresh'></span>

<h3>Description</h3>

<p>Creates an instance of Ord's point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  OrdThresh(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OrdThresh_+3A_r">r</code></td>
<td>
<p>Positive number giving the threshold value
for Ord's model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ord's point process model (Ord, 1977) is a Gibbs point process
of infinite order. Each point <code class="reqn">x_i</code> in the point pattern
<code class="reqn">x</code> contributes a factor <code class="reqn">g(a_i)</code> where
<code class="reqn">a_i = a(x_i, x)</code> is the area of the
tile associated with <code class="reqn">x_i</code>
in the Dirichlet tessellation of <code class="reqn">x</code>. The function <code class="reqn">g</code> is
simply <code class="reqn">g(a) = 1</code> if <code class="reqn">a \ge r</code> and
<code class="reqn">g(a) = \gamma &lt; 1</code> if <code class="reqn">a &lt; r</code>,
where <code class="reqn">r</code> is called the threshold value.
</p>
<p>This function creates an instance of Ord's model with a given
value of <code class="reqn">r</code>. It can then be fitted to point process data
using <code><a href="#topic+ppm">ppm</a></code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ord, J.K. (1977) 
Contribution to the discussion of Ripley (1977).
</p>
<p>Ord, J.K. (1978) 
How many trees in a forest?
<em>Mathematical Scientist</em> <b>3</b>, 23&ndash;33.
</p>
<p>Ripley, B.D. (1977)
Modelling spatial patterns (with discussion).
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>39</b>, 172 &ndash; 212.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>

<hr>
<h2 id='PairPiece'>The Piecewise Constant Pairwise Interaction Point Process Model</h2><span id='topic+PairPiece'></span>

<h3>Description</h3>

<p>Creates an instance of a pairwise interaction point process model
with piecewise constant potential function. The model
can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PairPiece(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PairPiece_+3A_r">r</code></td>
<td>
<p>vector of jump points for the potential function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pairwise interaction point process in a bounded region
is a stochastic point process with probability density of the form
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \prod_i b(x_i) \prod_{i &lt; j} h(x_i, x_j)
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern. The first product on the right hand side is
over all points of the pattern; the second product is over all
unordered pairs of points of the pattern.
</p>
<p>Thus each point <code class="reqn">x_i</code> of the pattern contributes a factor 
<code class="reqn">b(x_i)</code> to the probability density, and each pair of
points <code class="reqn">x_i, x_j</code> contributes a factor
<code class="reqn">h(x_i,x_j)</code> to the density.
</p>
<p>The pairwise interaction term <code class="reqn">h(u, v)</code> is called
<em>piecewise constant</em>
if it depends only on the distance between <code class="reqn">u</code> and <code class="reqn">v</code>,
say <code class="reqn">h(u,v) = H(||u-v||)</code>, and <code class="reqn">H</code> is a piecewise constant
function (a function which is constant except for jumps at a finite
number of places). The use of piecewise constant interaction terms
was first suggested by Takacs (1986).
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the piecewise constant pairwise
interaction is yielded by the function <code>PairPiece()</code>.
See the examples below.
</p>
<p>The entries of <code>r</code> must be strictly increasing, positive numbers.
They are interpreted as the points of discontinuity of <code class="reqn">H</code>.
It is assumed that <code class="reqn">H(s) =1</code> for all <code class="reqn">s &gt; r_{max}</code>
where <code class="reqn">r_{max}</code> is the maximum value in <code>r</code>. Thus the
model has as many regular parameters (see <code><a href="#topic+ppm">ppm</a></code>) 
as there are entries in <code>r</code>. The <code class="reqn">i</code>-th regular parameter
<code class="reqn">\theta_i</code> is the logarithm of the value of the
interaction function <code class="reqn">H</code> on the interval
<code class="reqn">[r_{i-1},r_i)</code>. 
</p>
<p>If <code>r</code> is a single number, this model is similar to the 
Strauss process, see <code><a href="#topic+Strauss">Strauss</a></code>. The difference is that
in <code>PairPiece</code> the interaction function is continuous on the
right, while in <code><a href="#topic+Strauss">Strauss</a></code> it is continuous on the left.
</p>
<p>The analogue of this model for multitype point processes
has not yet been implemented.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. The process is a pairwise interaction process,
whose interaction potential is piecewise constant, with jumps
at the distances given in the vector <code class="reqn">r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Takacs, R. (1986)
Estimator for the pair potential of a Gibbsian point process.
<em>Statistics</em> <b>17</b>, 429&ndash;433.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>
<code><a href="#topic+rmh.ppm">rmh.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   PairPiece(c(0.1,0.2))
   # prints a sensible description of itself

   ppm(cells ~1, PairPiece(r = c(0.05, 0.1, 0.2)))
   # fit a stationary piecewise constant pairwise interaction process

   
     ppm(cells ~polynom(x,y,3), PairPiece(c(0.05, 0.1)))
     # nonstationary process with log-cubic polynomial trend
   
</code></pre>

<hr>
<h2 id='pairsat.family'>Saturated Pairwise Interaction Point Process Family</h2><span id='topic+pairsat.family'></span>

<h3>Description</h3>

<p>An object describing the Saturated Pairwise Interaction
family of point process models
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes the &ldquo;saturated pairwise interaction&rdquo;
family of point process models.
</p>
<p>If you need to create a specific interaction model for use in 
spatial pattern analysis, use the function <code><a href="#topic+Saturated">Saturated</a>()</code>
or the two existing implementations of models in this family,
<code><a href="#topic+Geyer">Geyer</a>()</code> and <code><a href="#topic+SatPiece">SatPiece</a>()</code>.
</p>
<p>Geyer (1999) introduced the &ldquo;saturation process&rdquo;, a modification of the
Strauss process in which the total contribution
to the potential  from each point (from its pairwise interaction with all 
other points) is trimmed to a maximum value <code class="reqn">c</code>. 
This model is implemented in the function <code><a href="#topic+Geyer">Geyer</a>()</code>.
</p>
<p>The present class <code>pairsat.family</code> is the 
extension of this saturation idea to all pairwise interactions.
Note that the resulting models are no longer pairwise interaction
processes - they have interactions of infinite order.
</p>
<p><code>pairsat.family</code> is an object of class <code>"isf"</code> 
containing a function <code>pairwise$eval</code> for
evaluating the sufficient statistics of any saturated pairwise interaction
point process model in which the original pair potentials 
take an exponential family form. 
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point Processes.
Chapter 3 in 
O.E. Barndorff-Nielsen, W.S. Kendall and M.N.M. Van Lieshout (eds)
<em>Stochastic Geometry: Likelihood and Computation</em>,
Chapman and Hall / CRC, 
Monographs on Statistics and Applied Probability, number 80.
Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Geyer">Geyer</a></code> to create the Geyer saturation process.
</p>
<p><code><a href="#topic+SatPiece">SatPiece</a></code> to create a saturated process with
piecewise constant pair potential.
</p>
<p><code><a href="#topic+Saturated">Saturated</a></code> to create a more general saturation model.
</p>
<p>Other families:
<code><a href="#topic+inforder.family">inforder.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>.
</p>

<hr>
<h2 id='Pairwise'>Generic Pairwise Interaction model</h2><span id='topic+Pairwise'></span>

<h3>Description</h3>

<p>Creates an instance of a pairwise interaction point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Pairwise(pot, name, par, parnames, printfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pairwise_+3A_pot">pot</code></td>
<td>
<p>An R language function giving the user-supplied
pairwise interaction potential.</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_name">name</code></td>
<td>
<p>Character string.</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_par">par</code></td>
<td>
<p>List of numerical values for irregular parameters</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_parnames">parnames</code></td>
<td>
<p>Vector of names of irregular parameters</p>
</td></tr>
<tr><td><code id="Pairwise_+3A_printfun">printfun</code></td>
<td>
<p>Do not specify this argument: for internal use only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code constructs a member of the
pairwise interaction family <code><a href="#topic+pairwise.family">pairwise.family</a></code>
with arbitrary pairwise interaction potential given by
the user.
</p>
<p>Each pair of points in the point pattern contributes a factor
<code class="reqn">h(d)</code> to the probability density, where <code class="reqn">d</code> is the distance
between the two points. The factor term <code class="reqn">h(d)</code> is
</p>
<p style="text-align: center;"><code class="reqn">h(d) = \exp(-\theta \mbox{pot}(d))</code>
</p>

<p>provided <code class="reqn">\mbox{pot}(d)</code> is finite, 
where <code class="reqn">\theta</code> is the coefficient vector in the model.  
</p>
<p>The function <code>pot</code> must take as its first argument
a matrix of interpoint distances, and evaluate the
potential for each of these distances. The result must be
either a matrix with the same dimensions as its input,
or an array with its first two dimensions the same as its input
(the latter case corresponds to a vector-valued potential).
</p>
<p>If irregular parameters are present, then the second argument
to <code>pot</code> should be a vector of the same type as <code>par</code>
giving those parameter values.
</p>
<p>The values returned by <code>pot</code> may be finite numeric values,
or <code>-Inf</code> indicating a hard core (that is, the corresponding
interpoint distance is forbidden). We define
<code class="reqn">h(d) = 0</code> if <code class="reqn">\mbox{pot}(d) = -\infty</code>.
Thus, a potential value of minus infinity is <em>always</em> interpreted
as corresponding to <code class="reqn">h(d) = 0</code>, regardless of the sign
and magnitude of <code class="reqn">\theta</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   #This is the same as StraussHard(r=0.7,h=0.05)
   strpot &lt;- function(d,par) {
         r &lt;- par$r
         h &lt;- par$h
         value &lt;- (d &lt;= r)
         value[d &lt; h] &lt;- -Inf
         value
   }
   mySH &lt;- Pairwise(strpot, "StraussHard process", list(r=0.7,h=0.05),
           c("interaction distance r", "hard core distance h"))
   ppm(cells ~ 1, mySH, correction="isotropic")

   # Fiksel (1984) double exponential interaction
   # see Stoyan, Kendall, Mecke 1987 p 161

   fikspot &lt;- function(d, par) {
      r &lt;- par$r
      h &lt;- par$h
      zeta &lt;- par$zeta
      value &lt;- exp(-zeta * d)
      value[d &lt; h] &lt;- -Inf
      value[d &gt; r] &lt;- 0
      value
   }
   Fiksel &lt;- Pairwise(fikspot, "Fiksel double exponential process",
                      list(r=3.5, h=1, zeta=1),
                      c("interaction distance r",
                        "hard core distance h",
                        "exponential coefficient zeta"))
   fit &lt;- ppm(unmark(spruces) ~1, Fiksel, rbord=3.5)
   fit
   plot(fitin(fit), xlim=c(0,4))
   coef(fit)
   # corresponding values obtained by Fiksel (1984) were -1.9 and -6.0
</code></pre>

<hr>
<h2 id='pairwise.family'>Pairwise Interaction Process Family</h2><span id='topic+pairwise.family'></span>

<h3>Description</h3>

<p>An object describing the family of all pairwise interaction Gibbs
point processes.
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes 
the pairwise interaction family of point process models.
</p>
<p>If you need to create a specific pairwise interaction model for use in 
modelling, use the function <code><a href="#topic+Pairwise">Pairwise</a></code> or one of the existing
functions listed below.
</p>
<p>Anyway, <code>pairwise.family</code> is an object of class <code>"isf"</code>
containing a function <code>pairwise.family$eval</code> for
evaluating the sufficient statistics of any pairwise interaction
point process model taking an exponential family form. 
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p>Other families: 
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>,
<code><a href="#topic+inforder.family">inforder.family</a></code>.
</p>
<p>Pairwise interactions:
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+Pairwise">Pairwise</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+Fiksel">Fiksel</a></code>,
<code><a href="#topic+Hardcore">Hardcore</a></code>,
<code><a href="#topic+LennardJones">LennardJones</a></code>,
<code><a href="#topic+MultiHard">MultiHard</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>,
<code><a href="#topic+Softcore">Softcore</a></code>.
</p>
<p>Other interactions:
<code><a href="#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+Saturated">Saturated</a></code>,
<code><a href="#topic+Ord">Ord</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>.
</p>

<hr>
<h2 id='palmdiagnose'>
Diagnostic based on Palm Intensity
</h2><span id='topic+palmdiagnose'></span>

<h3>Description</h3>

<p>Given a fitted cluster process or Cox process model,
calculate a diagnostic which compares nonparametric and parametric
estimates of the Palm intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palmdiagnose(object, ..., breaks = 30, trim = 30, rmax=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palmdiagnose_+3A_object">object</code></td>
<td>

<p>Fitted model (object of class <code>"kppm"</code>)
or a list of fitted models.
</p>
</td></tr>
<tr><td><code id="palmdiagnose_+3A_...">...</code></td>
<td>

<p>Optional.
Additional arguments which are fitted models of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="palmdiagnose_+3A_breaks">breaks</code></td>
<td>

<p>Optional argument passed to <code><a href="base.html#topic+cut.default">cut.default</a></code>
determining the breakpoints of distance values 
for the nonparametric estimate. Either an integer specifying the
number of breakpoints, or a numeric vector of distance values to be
used as the breakpoints.
</p>
</td></tr>
<tr><td><code id="palmdiagnose_+3A_trim">trim</code></td>
<td>

<p>Optional. Maximum value of the translation edge correction weight.
</p>
</td></tr>
<tr><td><code id="palmdiagnose_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Maximum interpoint distance <code class="reqn">r</code> that should be
considered. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the diagnostic proposed by
Tanaka, Ogata and Stoyan (2008, Section 2.3)
for assessing goodness-of-fit of a Neyman-Scott cluster process model
to a point pattern dataset.
</p>
<p>The fitted model <code>object</code> should be an object of class <code>"kppm"</code>
representing a Neyman-Scott cluster process model or a Cox process
model. In the current implementation, the model must be stationary.
</p>
<p>The code computes parametric and non-parametric estimates of the
Palm intensity <code class="reqn">\lambda_0(r)</code>, loosely speaking,
the intensity of the point process given that there is a point at the origin.
The parametric estimate is obtained from the fitted model by
substituting the fitted parameter estimates into
expressions for the pair correlation and the intensity.
</p>
<p>The non-parametric estimate is obtained by considering all pairs of
data points, dividing the range of interpoint distances into
several equally-spaced bands (determined by the argument
<code>breaks</code>), counting the number of pairs of points whose
interpoint distances fall in each band, and numerically adjusting for
edge effects. Tanaka, Ogata and Stoyan (2008) used the
periodic (toroidal) edge correction; our code uses the
translation edge correction so that the method can be applied to
data in any window.
</p>
<p>The result is a function value table (object of class <code>"fv"</code>)
containing the nonparametric and parametric estimates of the Palm
intensity. The result also belongs to the class <code>"palmdiag"</code>
which has a method for <code>plot</code>. The default behaviour of
<code><a href="#topic+plot.palmdiag">plot.palmdiag</a></code> is to plot the model fit as a curve,
and to display the nonparametric estimates as dots; this is the plot style
proposed by Tanaka, Ogata and Stoyan (2008). Alternative display
styles are also supported by <code><a href="#topic+plot.palmdiag">plot.palmdiag</a></code>.
</p>
<p>For computational efficiency, the argument <code>rmax</code>
specifies the maximum value of interpoint distance <code class="reqn">r</code>
for which estimates of <code class="reqn">\lambda_0(r)</code> shall be computed.
The default <code>rmax = Inf</code> implies
there is no constraint on interpoint distance,
and the resulting function object contains estimates of
<code class="reqn">\lambda_0(r)</code> up to
the maximum distance that would have been observable
in the window containing the original point pattern data. 
</p>
<p>If there are additional arguments <code>...</code> which are fitted models
of class <code>"kppm"</code>, or if <code>object</code> is a list of fitted models
of class <code>"kppm"</code>, then the parametric estimates for each
of the fitted models will be included in the resulting function object.
If names are attached to these fitted models, the names will be used
in the resulting function object.
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>) containing the
nonparametric and parametric estimates of the Palm intensity.
Also belongs to the class <code>"palmdiag"</code> which has a <code>plot</code> method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for Neyman-Scott Point
Processes.
<em>Biometrical Journal</em> <b>50</b>, 1, 43&ndash;57.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.palmdiag">plot.palmdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fitK &lt;- kppm(redwood)
   R &lt;- palmdiagnose(fitK)
   plot(R)

   fitg &lt;- kppm(redwood, statistic="pcf")
   R2 &lt;- palmdiagnose(A=fitK, B=fitg)
   plot(R2)
</code></pre>

<hr>
<h2 id='panel.contour'>
Panel Plots using Colour Image or Contour Lines
</h2><span id='topic+panel.contour'></span><span id='topic+panel.image'></span><span id='topic+panel.histogram'></span>

<h3>Description</h3>

<p>These functions can be passed to <code><a href="graphics.html#topic+pairs">pairs</a></code> or
<code><a href="graphics.html#topic+coplot">coplot</a></code>
to determine what kind of plotting is done in each panel
of a multi-panel graphical display. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.contour(x, y, ..., sigma = NULL)

panel.image(x, y, ..., sigma = NULL)

panel.histogram(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.contour_+3A_x">x</code>, <code id="panel.contour_+3A_y">y</code></td>
<td>

<p>Coordinates of points in a scatterplot.
</p>
</td></tr>
<tr><td><code id="panel.contour_+3A_...">...</code></td>
<td>

<p>Extra graphics arguments, passed to <code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code>,
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> or <code><a href="graphics.html#topic+rect">rect</a></code>, respectively,
to control the appearance of the panel.
</p>
</td></tr>
<tr><td><code id="panel.contour_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth of kernel smoother, on a scale where
<code class="reqn">x</code> and <code class="reqn">y</code> range between 0 and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can serve as one of the arguments <code>panel</code>,
<code>lower.panel</code>, <code>upper.panel</code>, <code>diag.panel</code>
passed to graphics commands like
<code><a href="graphics.html#topic+pairs">pairs</a></code> or <code><a href="graphics.html#topic+coplot">coplot</a></code>,
to determine what kind of plotting is done in each panel
of a multi-panel graphical display. In particular they work
with <code><a href="spatstat.explore.html#topic+pairs.im">pairs.im</a></code>.
</p>
<p>The functions <code>panel.contour</code> and <code>panel.contour</code>
are suitable for the off-diagonal plots which involve
two datasets <code>x</code> and <code>y</code>.
They first rescale <code>x</code> and <code>y</code> to the unit square,
then apply kernel smoothing with bandwidth <code>sigma</code>
using <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code>.
Then <code>panel.contour</code> draws a contour plot
while <code>panel.image</code> draws a colour image.
</p>
<p>The function <code>panel.histogram</code> is suitable for the
diagonal plots which involve a single dataset <code>x</code>.
It displays a histogram of the data.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+pairs.im">pairs.im</a></code>,
<code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>,
<code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pairs(bei.extra,
        panel      = panel.contour,
        diag.panel = panel.histogram)
  with(bei.extra,
        pairs(grad, elev, 
              panel      = panel.image,
              diag.panel = panel.histogram))
  pairs(marks(finpines), panel=panel.contour, diag.panel=panel.histogram)
</code></pre>

<hr>
<h2 id='panysib'>
Probability that a Point Has Any Siblings
</h2><span id='topic+panysib'></span>

<h3>Description</h3>

<p>Given a cluster process model, calculate the probability
that a point of the process has any siblings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panysib(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panysib_+3A_object">object</code></td>
<td>

<p>Fitted cluster process model (object of class <code>"kppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Poisson cluster process, two points are called <em>siblings</em>
if they belong to the same cluster, that is, if they had the same
parent point. This function computes the probability that a 
given random point has <code>any</code> siblings.
</p>
<p>If <code>object</code> is a stationary point process, the result is a single
number, which is the probability that a typical point of the process
has any siblings.
If this number is small,
then the process is approximately a homogeneous Poisson process
(complete spatial randomness). The converse is not true (Baddeley et al, 2022).
</p>
<p>Otherwise, the result is a pixel image, in which the value at any
location <code>u</code> is the conditional probability,
given there is a point of the
process at <code>u</code>, that this point has any siblings.
If the pixel values are all small,
then the process is approximately an inhomogeneous Poisson process.
</p>
<p>This concept was proposed by Baddeley et al (2022).
</p>


<h3>Value</h3>

<p>A single number (if <code>object</code> is a stationary point process)
or a pixel image (otherwise).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Davies, T.M., Hazelton, M.L., Rakshit, S. and Turner, R. 
(2022)
Fundamental problems in fitting spatial cluster process models.
<em>Spatial Statistics</em> <b>52</b>, 100709.
DOI: <code>10.1016/j.spasta.2022.100709</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psib">psib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ polynom(x,y,2))
  plot(panysib(fit))
</code></pre>

<hr>
<h2 id='parameters'>
Extract Model Parameters in Understandable Form
</h2><span id='topic+parameters'></span><span id='topic+parameters.dppm'></span><span id='topic+parameters.kppm'></span><span id='topic+parameters.slrm'></span><span id='topic+parameters.ppm'></span><span id='topic+parameters.profilepl'></span><span id='topic+parameters.interact'></span><span id='topic+parameters.fii'></span>

<h3>Description</h3>

<p>Given a fitted model of some kind, this function
extracts all the parameters needed to specify the model,
and returns them as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(model, ...)

## S3 method for class 'dppm'
parameters(model, ...)

## S3 method for class 'kppm'
parameters(model, ...)

## S3 method for class 'slrm'
parameters(model, ...)

## S3 method for class 'ppm'
parameters(model, ...)

## S3 method for class 'profilepl'
parameters(model, ...)

## S3 method for class 'fii'
parameters(model, ...)

## S3 method for class 'interact'
parameters(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_model">model</code></td>
<td>

<p>A fitted model of some kind.
</p>
</td></tr>
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>

<p>Arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>model</code> should be a fitted model of some kind.
This function extracts all the parameters that would be needed to
specify the model, and returns them as a list.
</p>
<p>The function <code>parameters</code> is generic, with methods
for class <code>"ppm"</code>, <code>"kppm"</code>, <code>"dppm"</code> and <code>"profilepl"</code>
and other classes.
</p>


<h3>Value</h3>

<p>A named list, whose format depends on the fitted model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  parameters(Strauss(0.1))
  fit1 &lt;- ppm(cells ~ x, Strauss(0.1))
  parameters(fit1)
  fit2 &lt;- kppm(redwood ~ x, "Thomas")
  parameters(fit2)
</code></pre>

<hr>
<h2 id='parres'>
Partial Residuals for Point Process Model
</h2><span id='topic+parres'></span>

<h3>Description</h3>

<p>Computes the smoothed partial residuals, a diagnostic
for transformation of a covariate in a Poisson point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parres(model, covariate, ...,
       smooth.effect=FALSE, subregion=NULL,
       bw = "nrd0", adjust=1, from = NULL, to = NULL, n = 512,
       bw.input = c("points", "quad"), bw.restrict=FALSE, covname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parres_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="parres_+3A_covariate">covariate</code></td>
<td>

<p>The covariate of interest.
Either a character string matching the name of one of
the canonical covariates in the model, or one of the names
<code>"x"</code> or <code>"y"</code> referring to the Cartesian coordinates,
or one of the names of the covariates given when <code>model</code> was fitted,
or a pixel image (object of class <code>"im"</code>)
or <code>function(x,y)</code> supplying the
values of a covariate at any location.
If the <code>model</code> depends on only one covariate,
then this covariate is the default; otherwise a covariate must be specified.
</p>
</td></tr>
<tr><td><code id="parres_+3A_smooth.effect">smooth.effect</code></td>
<td>

<p>Logical. Determines the choice of algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="parres_+3A_subregion">subregion</code></td>
<td>

<p>Optional.  A window (object of class <code>"owin"</code>)
specifying a subset of the spatial domain of the data.
The calculation will be confined to the data in this subregion.
</p>
</td></tr>
<tr><td><code id="parres_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth or bandwidth rule
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="parres_+3A_adjust">adjust</code></td>
<td>

<p>Smoothing bandwidth adjustment factor
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="parres_+3A_n">n</code>, <code id="parres_+3A_from">from</code>, <code id="parres_+3A_to">to</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code> to
control the number and range of values at which the function
will be estimated.
</p>
</td></tr>
<tr><td><code id="parres_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="parres_+3A_bw.input">bw.input</code></td>
<td>

<p>Character string specifying the input data used for automatic
bandwidth selection. 
</p>
</td></tr>
<tr><td><code id="parres_+3A_bw.restrict">bw.restrict</code></td>
<td>

<p>Logical value, specifying whether bandwidth selection is performed using
data from the entire spatial domain or from the <code>subregion</code>.
</p>
</td></tr>
<tr><td><code id="parres_+3A_covname">covname</code></td>
<td>

<p>Optional. Character string to use as the name of the covariate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the smoothed partial residual diagnostic
(Baddeley, Chang, Song and Turner, 2012) 
for the transformation of a covariate
in a Poisson point process model.
</p>
<p>The argument <code>model</code> must be a fitted Poisson point process model.
</p>
<p>The diagnostic works in two different ways:
</p>

<dl>
<dt>Canonical covariate:</dt><dd>
<p>The argument <code>covariate</code> may be a character string
which is the name of one of the <em>canonical covariates</em> in the
model. 
The canonical covariates are the
functions <code class="reqn">Z_j</code> that appear
in the expression for the Poisson point process intensity
</p>
<p style="text-align: center;"><code class="reqn">
	\lambda(u) = \exp(\beta_1 Z_1(u) + \ldots + \beta_p Z_p(u))
      </code>
</p>

<p>at spatial location <code class="reqn">u</code>.
Type <code>names(coef(model))</code> to see the names of the
canonical covariates in <code>model</code>.
If the selected covariate is <code class="reqn">Z_j</code>, then 
the diagnostic plot concerns the model term
<code class="reqn">\beta_j Z_j(u)</code>. The plot shows a smooth
estimate of a function <code class="reqn">h(z)</code> that should replace this linear
term, that is, <code class="reqn">\beta_j Z_j(u)</code> should be
replaced by <code class="reqn">h(Z_j(u))</code>. The linear function is
also plotted as a dotted line.
</p>
</dd>
<dt>New covariate:</dt><dd>
<p>If the argument <code>covariate</code> is a pixel image
(object of class <code>"im"</code>) or a <code>function(x,y)</code>,
it is assumed to provide the values of a covariate that is
not present in the model.
Alternatively <code>covariate</code> can be the name of a
covariate that was supplied when the model was fitted
(i.e. in the call to <code><a href="#topic+ppm">ppm</a></code>)
but which does not feature in the model formula.
In either case we speak of a new covariate <code class="reqn">Z(u)</code>.
If the fitted model intensity is <code class="reqn">\lambda(u)</code>
then we consider modifying this to
<code class="reqn">\lambda(u) \exp(h(Z(u)))</code>
where <code class="reqn">h(z)</code> is some function. The diagnostic plot shows
an estimate of <code class="reqn">h(z)</code>.
<b>Warning: in this case the diagnostic is not theoretically
justified. This option is provided for research purposes.</b>
</p>
</dd>
</dl>

<p>Alternatively <code>covariate</code> can be one of the character strings
<code>"x"</code> or <code>"y"</code> signifying the Cartesian coordinates.
The behaviour here depends on whether the coordinate was one of the
canonical covariates in the model.
</p>
<p>If there is more than one canonical covariate in the model
that depends on the specified <code>covariate</code>, then
the covariate effect is computed using all these canonical covariates.
For example in a log-quadratic model which includes the terms <code>x</code> and
<code>I(x^2)</code>, the quadratic effect involving both these terms
will be computed.
</p>
<p>There are two choices for the algorithm.
If <code>smooth.effect=TRUE</code>, the fitted covariate effect (according
to <code>model</code>) is added to the point process residuals, then
smoothing is applied to these values. If <code>smooth.effect=FALSE</code>,
the point process residuals are smoothed first, and then the fitted
covariate effect is added to the result.
</p>
<p>The smoothing bandwidth is controlled by the arguments
<code>bw</code>, <code>adjust</code>, <code>bw.input</code> and <code>bw.restrict</code>.
If <code>bw</code> is a numeric value, then
the bandwidth is taken to be <code>adjust * bw</code>.
If <code>bw</code> is a string representing a bandwidth selection rule
(recognised by <code><a href="stats.html#topic+density.default">density.default</a></code>)
then the bandwidth is selected by this rule.
</p>
<p>The data used for automatic bandwidth selection are
specified by <code>bw.input</code> and <code>bw.restrict</code>.
If <code>bw.input="points"</code>  (the default) then bandwidth selection is
based on the covariate values at the points of the original point
pattern dataset to which the model was fitted.
If <code>bw.input="quad"</code> then bandwidth selection is
based on the covariate values at every quadrature point used to
fit the model.
If <code>bw.restrict=TRUE</code> then the bandwidth selection is performed
using only data from inside the <code>subregion</code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the values of the smoothed partial residual,
the estimated variance, and the fitted effect of the covariate.
Also belongs to the class <code>"parres"</code>
which has methods for <code>print</code> and <code>plot</code>.
</p>


<h3>Slow computation</h3>

<p>In a large dataset, computation can be very slow if the default
settings are used, because the smoothing bandwidth is selected
automatically. To avoid this, specify a numerical value
for the bandwidth <code>bw</code>. One strategy is to use a coarser
subset of the data to select <code>bw</code> automatically.
The selected bandwidth can be read off the print output for
<code>parres</code>.  
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
Ya-Mei Chang and Yong Song.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2013)
Residual diagnostics for covariate effects in
spatial point process models.
<em>Journal of Computational and Graphical Statistics</em>,
<b>22</b>, 886&ndash;905.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addvar">addvar</a></code>,
<code><a href="spatstat.explore.html#topic+rhohat">rhohat</a></code>,
<code><a href="spatstat.explore.html#topic+rho2hat">rho2hat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;-  rpoispp(function(x,y){exp(3+x+2*x^2)})
  model &lt;- ppm(X ~x+y)
  tra &lt;- parres(model, "x")
  plot(tra)
  tra
  plot(parres(model, "x", subregion=square(0.5)))
  model2 &lt;- ppm(X ~x+I(x^2)+y)
  plot(parres(model2, "x"))
  Z &lt;- setcov(owin())
  plot(parres(model2, Z))

  #' when the model involves only one covariate
  modelb &lt;- ppm(bei ~ elev + I(elev^2), data=bei.extra)
  plot(parres(modelb))
</code></pre>

<hr>
<h2 id='Penttinen'>Penttinen Interaction</h2><span id='topic+Penttinen'></span>

<h3>Description</h3>

<p>Creates an instance of the Penttinen pairwise interaction
point process model, which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Penttinen(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Penttinen_+3A_r">r</code></td>
<td>
<p>circle radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Penttinen (1984, Example 2.1, page 18), citing Cormack (1979),
described the pairwise interaction point process with interaction factor
</p>
<p style="text-align: center;"><code class="reqn">
    h(d) = e^{\theta A(d)} = \gamma^{A(d)}
  </code>
</p>

<p>between each pair of points separated by a distance $d$.
Here <code class="reqn">A(d)</code> is the area of intersection between two discs
of radius <code class="reqn">r</code> separated by a distance <code class="reqn">d</code>, normalised so that
<code class="reqn">A(0) = 1</code>.
</p>
<p>The scale of interaction is controlled by the disc radius <code class="reqn">r</code>:
two points interact if they are closer than <code class="reqn">2 r</code> apart.
The strength of interaction is controlled by the
canonical parameter <code class="reqn">\theta</code>, which 
must be less than or equal to zero, or equivalently by the
parameter <code class="reqn">\gamma = e^\theta</code>,
which must lie between 0 and 1.
</p>
<p>The potential is inhibitory, i.e.\ this model is only appropriate for
regular point patterns. 
For <code class="reqn">\gamma=0</code> the model is
a hard core process with hard core diameter <code class="reqn">2 r</code>.
For <code class="reqn">\gamma=1</code> the model is a Poisson process.
</p>
<p>The irregular parameter
<code class="reqn">r</code> must be given in the call to
<code>Penttinen</code>, while the
regular parameter <code class="reqn">\theta</code> will be estimated.
</p>
<p>This model can be considered as a pairwise approximation
to the area-interaction model <code><a href="#topic+AreaInter">AreaInter</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Cormack, R.M. (1979)
Spatial aspects of competition between individuals.
Pages 151&ndash;212 in <em>Spatial and Temporal Analysis in Ecology</em>,
eds. R.M. Cormack and J.K. Ord, International Co-operative
Publishing House, Fairland, MD, USA. 
</p>
<p>Penttinen, A. (1984) 
<em>Modelling Interaction in Spatial Point Patterns:
Parameter Estimation by the Maximum Likelihood Method.</em>
Jyvaskyla
Studies in Computer Science, Economics and Statistics <b>7</b>,
University of Jyvaskyla, Finland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+Pairwise">Pairwise</a></code>,
<code><a href="#topic+AreaInter">AreaInter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ 1, Penttinen(0.07))
   fit
   reach(fit) # interaction range is circle DIAMETER
</code></pre>

<hr>
<h2 id='plot.dppm'>Plot a fitted determinantal point process</h2><span id='topic+plot.dppm'></span>

<h3>Description</h3>

<p>Plots a fitted determinantal point process model,
displaying the fitted intensity and the fitted summary function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
plot(x, ..., what=c("intensity", "statistic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dppm_+3A_x">x</code></td>
<td>

<p>Fitted determinantal point process model.
An object of class <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.dppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.ppm">plot.ppm</a></code>
and <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code> to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.dppm_+3A_what">what</code></td>
<td>

<p>Character vector determining what will be plotted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="graphics.html#topic+plot">plot</a></code> for the class <code>"dppm"</code> of fitted
determinantal point process models.
</p>
<p>The argument <code>x</code> should be a determinantal point process model
(object of class <code>"dppm"</code>) obtained using
the function <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p>The choice of plots (and the order in which they are
displayed) is controlled by the argument <code>what</code>.
The options (partially matched) are <code>"intensity"</code> and
<code>"statistic"</code>.
</p>
<p>This command is capable of producing two different plots:
</p>

<dl>
<dt>what=&quot;intensity&quot;</dt><dd><p>specifies the fitted intensity of the model,
which is plotted using <code><a href="#topic+plot.ppm">plot.ppm</a></code>. By default this plot
is not produced for stationary models.</p>
</dd>
<dt>what=&quot;statistic&quot;</dt><dd><p>specifies the empirical and fitted summary
statistics, which are plotted using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>. This is
only meaningful if the model has been fitted using the Method of
Minimum Contrast, and it is turned off otherwise.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- dppm(swedishpines ~ x + y, dppGauss, method="c")
  plot(fit)
</code></pre>

<hr>
<h2 id='plot.influence.ppm'>
Plot Influence Measure
</h2><span id='topic+plot.influence.ppm'></span>

<h3>Description</h3>

<p>Plots an influence measure that has been
computed by <code><a href="#topic+influence.ppm">influence.ppm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'influence.ppm'
plot(x, ..., multiplot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.influence.ppm_+3A_x">x</code></td>
<td>

<p>Influence measure (object of class <code>"influence.ppm"</code>) computed by
<code><a href="#topic+influence.ppm">influence.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.influence.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
to control the plotting.
</p>
</td></tr>
<tr><td><code id="plot.influence.ppm_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value indicating whether it is permissible to
plot more than one panel. This happens if the original point process
model is multitype.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for objects of class <code>"influence.ppm"</code>.
These objects are computed by the command <code><a href="#topic+influence.ppm">influence.ppm</a></code>.
</p>
<p>For a point process model fitted by maximum likelihood or
maximum pseudolikelihood (the default), influence values are
associated with the data points.
The display shows circles centred at the data points
with radii proportional to the influence values.
If the original data were a multitype point pattern, then
if <code>multiplot=TRUE</code> (the default), 
there is one such display for each possible type of point,
while if <code>multiplot=FALSE</code> there is a single plot
combining all data points regardless of type.
</p>
<p>For a model fitted by logistic composite likelihood
(<code>method="logi"</code> in <code><a href="#topic+ppm">ppm</a></code>) influence values
are associated with the data points and also with the
dummy points used to fit the model. The display consist of two
panels, for the data points and dummy points respectively,
showing circles with radii proportional to the influence values.
If the original data were a multitype point pattern, then
if <code>multiplot=TRUE</code> (the default), 
there is one pair of panels for each possible type of point,
while if <code>multiplot=FALSE</code> there is a single plot
combining all data and dummy points regardless of type.
</p>
<p>Use the argument <code>clipwin</code> to restrict the plot to a subset
of the full data.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence.ppm">influence.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   plot(influence(fit))
</code></pre>

<hr>
<h2 id='plot.kppm'>Plot a fitted cluster point process</h2><span id='topic+plot.kppm'></span>

<h3>Description</h3>

<p>Plots a fitted cluster point process model,
displaying the fitted intensity and the fitted <code class="reqn">K</code>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
plot(x, ...,
                      what=c("intensity", "statistic", "cluster"),
                      pause=interactive(),
                      xname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kppm_+3A_x">x</code></td>
<td>

<p>Fitted cluster point process model.
An object of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.kppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.ppm">plot.ppm</a></code>
and <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code> to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.kppm_+3A_what">what</code></td>
<td>

<p>Character vector determining what will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.kppm_+3A_pause">pause</code></td>
<td>

<p>Logical value specifying whether to pause between plots.
</p>
</td></tr>
<tr><td><code id="plot.kppm_+3A_xname">xname</code></td>
<td>

<p>Optional. Character string. The name of the object <code>x</code>
for use in the title of the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="graphics.html#topic+plot">plot</a></code> for the class <code>"kppm"</code> of fitted
cluster point process models.
</p>
<p>The argument <code>x</code> should be a cluster point process model
(object of class <code>"kppm"</code>) obtained using
the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The choice of plots (and the order in which they are
displayed) is controlled by the argument <code>what</code>.
The options (partially matched) are <code>"intensity"</code>,
<code>"statistic"</code> and <code>"cluster"</code>.
</p>
<p>This command is capable of producing three different plots:
</p>

<dl>
<dt>what=&quot;intensity&quot;</dt><dd><p>specifies the fitted intensity of the model,
which is plotted using <code><a href="#topic+plot.ppm">plot.ppm</a></code>. By default this plot
is not produced for stationary models.</p>
</dd>
<dt>what=&quot;statistic&quot;</dt><dd><p>specifies the empirical and fitted summary
statistics, which are plotted using <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>. This is
only meaningful if the model has been fitted using the Method of
Minimum Contrast, and it is turned off otherwise.</p>
</dd>
<dt>what=&quot;cluster&quot;</dt><dd><p>specifies a fitted cluster, which is computed
by <code><a href="spatstat.random.html#topic+clusterfield">clusterfield</a></code> and plotted by
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>. It is only meaningful for Poisson cluster
(incl. Neyman-Scott) processes, and it is turned off for
log-Gaussian Cox processes (LGCP). If the model is stationary (and
non-LGCP) this option is turned on by default and shows a fitted
cluster positioned at the centroid of the observation window. For
non-stationary (and non-LGCP) models this option is only invoked if
explicitly told so, and in that case an additional argument
<code>locations</code> (see <code><a href="spatstat.random.html#topic+clusterfield">clusterfield</a></code>) must be given to
specify where to position the parent point(s) .</p>
</dd>
</dl>

<p>Alternatively <code>what="all"</code> selects all available options.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood~1, "Thomas")
  plot(fit)
</code></pre>

<hr>
<h2 id='plot.leverage.ppm'>
Plot Leverage Function
</h2><span id='topic+plot.leverage.ppm'></span><span id='topic+contour.leverage.ppm'></span><span id='topic+persp.leverage.ppm'></span>

<h3>Description</h3>

<p>Generate a pixel image plot, or a contour plot, or a perspective plot,
of a leverage function that has been computed by <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'leverage.ppm'
plot(x, ...,
                             what=c("smooth", "nearest", "exact"),
                             showcut=TRUE,
                             args.cut=list(drawlabels=FALSE), 
                             multiplot=TRUE)

 ## S3 method for class 'leverage.ppm'
contour(x, ...,
                             what=c("smooth", "nearest"),
                             showcut=TRUE,
                             args.cut=list(col=3, lwd=3, drawlabels=FALSE), 
                             multiplot=TRUE)

 ## S3 method for class 'leverage.ppm'
persp(x, ...,
               what=c("smooth", "nearest"),
               main, zlab="leverage")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.leverage.ppm_+3A_x">x</code></td>
<td>

<p>Leverage function (object of class <code>"leverage.ppm"</code>) computed by
<code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> or <code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code>
or <code><a href="spatstat.geom.html#topic+persp.im">persp.im</a></code> controlling the plot.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_what">what</code></td>
<td>

<p>Character string (partially matched)
specifying the values to be plotted. See Details.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_showcut">showcut</code></td>
<td>

<p>Logical. If <code>TRUE</code>, a contour line is plotted at the
level equal to the theoretical mean of the leverage.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_args.cut">args.cut</code></td>
<td>

<p>Optional list of arguments passed to
<code><a href="graphics.html#topic+contour.default">contour.default</a></code> to control the
plotting of the contour line for the mean leverage.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value indicating whether it is permissible to display
several plot panels.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_main">main</code></td>
<td>

<p>Optional main title. A character string or character vector.
</p>
</td></tr>
<tr><td><code id="plot.leverage.ppm_+3A_zlab">zlab</code></td>
<td>

<p>Label for the <code class="reqn">z</code> axis. A character string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are the <code>plot</code>, <code>contour</code> and <code>persp</code> methods
for objects of class <code>"leverage.ppm"</code>.
Such objects are computed by the command <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>
<p>The <code>plot</code> method displays the leverage function 
as a colour pixel image using <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>,
and draws a single contour line at the mean leverage value
using <code><a href="graphics.html#topic+contour.default">contour.default</a></code>.
Use the argument <code>clipwin</code> to restrict the plot to a subset
of the full data.
</p>
<p>The <code>contour</code> method displays the leverage function as a contour
plot, and also draws a single contour line at the mean leverage value,
using <code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code>.
</p>
<p>The <code>persp</code> method displays the leverage function as a surface
in perspective view, using <code><a href="spatstat.geom.html#topic+persp.im">persp.im</a></code>.
</p>
<p>Since the exact values of leverage are computed only
at a finite set of quadrature locations, there are several options for
these plots:
</p>

<dl>
<dt><code>what="smooth"</code>:</dt><dd>
<p>(the default) an image plot showing a smooth function,
obtained by applying kernel smoothing to the exact leverage values;
</p>
</dd>
<dt><code>what="nearest"</code>:</dt><dd>
<p>an image plot showing a piecewise-constant function,
obtained by taking the exact leverage value at the nearest
quadrature point;
</p>
</dd>
<dt><code>what="exact"</code>:</dt><dd>
<p>a symbol plot showing the exact values of leverage as
circles, centred at the quadrature points,
with diameters proportional to leverage.
</p>
</dd>
</dl>

<p>The pixel images are already contained in the object <code>x</code>
and were computed by <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>;
the resolution of these images is controlled
by arguments to <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>


<h3>Value</h3>

<p>Same as for <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>, <code><a href="spatstat.geom.html#topic+contour.im">contour.im</a></code>
and <code><a href="spatstat.geom.html#topic+persp.im">persp.im</a></code> respectively.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.M. and Song, Y. (2013)
Leverage and influence diagnostics for spatial point process models.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 86&ndash;104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(offline &lt;- !interactive()) op &lt;- spatstat.options(npixel=32, ndummy.min=16)

   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~x+y)
   lef &lt;- leverage(fit)
   plot(lef)
   contour(lef)
   persp(lef)

if(offline) spatstat.options(op)
</code></pre>

<hr>
<h2 id='plot.mppm'>plot a Fitted Multiple Point Process Model</h2><span id='topic+plot.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to multiple point patterns
by <code><a href="#topic+mppm">mppm</a></code>,
compute spatial trend or conditional intensity surface of the model,
in a form suitable for plotting, and (optionally) plot this
surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mppm'
plot(x, ...,
                trend=TRUE, cif=FALSE, se=FALSE,
                how=c("image", "contour", "persp"),
                main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mppm_+3A_x">x</code></td>
<td>

<p>A point process model fitted to multiple point patterns,
typically obtained from
the model-fitting algorithm <code><a href="#topic+mppm">mppm</a></code>.
An object of class <code>"mppm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.ppm">plot.ppm</a></code> or
<code><a href="spatstat.geom.html#topic+plot.anylist">plot.anylist</a></code> controlling the plot.
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_trend">trend</code></td>
<td>

<p>Logical value indicating whether to plot the fitted trend.
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_cif">cif</code></td>
<td>

<p>Logical value indicating whether to plot the fitted conditional intensity.
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to plot the standard error of the
fitted trend.
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_how">how</code></td>
<td>

<p>Single character string indicating the style of plot to be performed. 
</p>
</td></tr>
<tr><td><code id="plot.mppm_+3A_main">main</code></td>
<td>

<p>Character string for the main title of the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"mppm"</code>
of point process models fitted to multiple point patterns
(see <code><a href="#topic+mppm">mppm</a></code>).
</p>
<p>It invokes <code><a href="#topic+subfits">subfits</a></code> to compute the fitted model for
each individual point pattern dataset, then calls
<code><a href="#topic+plot.ppm">plot.ppm</a></code> to plot these individual models. These
individual plots are displayed using <code><a href="spatstat.geom.html#topic+plot.anylist">plot.anylist</a></code>,
which generates either a series of separate plot frames or an
array of plot panels on a single page. 
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ppm">plot.ppm</a></code>,
<code><a href="#topic+mppm">mppm</a></code>,
<code><a href="spatstat.geom.html#topic+plot.listof">plot.listof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Synthetic data from known model
  n &lt;- 9
  H &lt;- hyperframe(V=1:n,
                  U=runif(n, min=-1, max=1))
  H$Z &lt;- setcov(square(1))
  H$U &lt;- with(H, as.im(U, as.rectangle(Z)))
  H$Y &lt;- with(H, rpoispp(eval.im(exp(2+3*Z))))

  fit &lt;- mppm(Y ~Z + U + V, data=H)

  plot(fit)
</code></pre>

<hr>
<h2 id='plot.msr'>Plot a Signed or Vector-Valued Measure</h2><span id='topic+plot.msr'></span>

<h3>Description</h3>

<p>Plot a signed measure or vector-valued measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'msr'
plot(x, ...,
                     add = FALSE,
                     how = c("image", "contour", "imagecontour"),
                     main = NULL,
                     do.plot = TRUE,
                     multiplot = TRUE,
                     massthresh = 0,
                     equal.markscale = FALSE,
                     equal.ribbon = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.msr_+3A_x">x</code></td>
<td>

<p>The signed or vector measure to be plotted.
An object of class <code>"msr"</code> (see <code><a href="#topic+msr">msr</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
to control the interpolation of the
continuous density component of <code>x</code>,
or passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> or <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
to control the appearance of the plot.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_add">add</code></td>
<td>

<p>Logical flag; if <code>TRUE</code>, the graphics are added to the existing
plot. If <code>FALSE</code> (the default) a new plot is initialised.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_how">how</code></td>
<td>

<p>String indicating how to display the continuous density component.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_main">main</code></td>
<td>

<p>String. Main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value determining whether to actually perform the plotting.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value indicating whether it is permissible to display
a plot with multiple panels (representing different components of
a vector-valued measure, or different types of points in a multitype
measure.) 
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_massthresh">massthresh</code></td>
<td>

<p>Threshold for plotting atoms.
A single numeric value or <code>NULL</code>.
If <code>massthresh=0</code> (the default) then only atoms with
nonzero mass will be plotted.
If <code>massthresh &gt; 0</code> then only atoms whose absolute mass
exceeds <code>massthresh</code> will be plotted.
If <code>massthresh=NULL</code>, then all atoms of the measure will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_equal.markscale">equal.markscale</code></td>
<td>

<p>Logical value indicating whether different panels should use the
same symbol map (to represent the masses of atoms of the measure).
</p>
</td></tr>
<tr><td><code id="plot.msr_+3A_equal.ribbon">equal.ribbon</code></td>
<td>

<p>Logical value indicating whether different panels should use the
same colour map (to represent the density values in the
diffuse component of the measure).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"msr"</code>.
</p>
<p>The continuous density component of <code>x</code> is interpolated
from the existing data by <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>,
and then displayed as a colour image by <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>
<p>The discrete atomic component of <code>x</code> is then superimposed on this
image by plotting the atoms as circles (for positive mass)
or squares (for negative mass) by <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
By default, atoms with zero mass are not plotted at all. 
</p>
<p>To smooth both the discrete and continuous components,
use   <code><a href="#topic+Smooth.msr">Smooth.msr</a></code>.
</p>
<p>Use the argument <code>clipwin</code> to restrict the plot to a subset
of the full data.
</p>
<p>To remove atoms with tiny masses, use the argument <code>massthresh</code>.
</p>


<h3>Value</h3>

<p>(Invisible) colour map (object of class <code>"colourmap"</code>) for the
colour image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>,
<code><a href="#topic+Smooth.msr">Smooth.msr</a></code>,
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>,
<code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")
   rs &lt;- residuals(fit, type="score")

   plot(rp)
   plot(rs)
   plot(rs, how="contour")
</code></pre>

<hr>
<h2 id='plot.palmdiag'>
Plot the Palm Intensity Diagnostic
</h2><span id='topic+plot.palmdiag'></span>

<h3>Description</h3>

<p>Plot the Palm intensity diagnostic for a fitted cluster process
or Cox process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'palmdiag'
plot(x, ...,
          style = c("intervals", "dots", "bands"),
          args.dots = list(pch = 16), args.intervals = list(),
          xlim=NULL, main)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.palmdiag_+3A_x">x</code></td>
<td>

<p>Object of class <code>"palmdiag"</code> produced by <code><a href="#topic+palmdiagnose">palmdiagnose</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>
when the fitted curve is plotted.
</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_style">style</code></td>
<td>

<p>Character string specifying the style of plot for the
nonparametric estimates. See Details.
</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_args.dots">args.dots</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+points">points</a></code>
when <code>style="dots"</code>.
</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_args.intervals">args.intervals</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code>
when <code>style="intervals"</code>.
</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_xlim">xlim</code></td>
<td>
<p>Optional range of distances plotted along the horizontal
axis. A numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="plot.palmdiag_+3A_main">main</code></td>
<td>
<p>Optional main title for plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the diagnostic proposed by
Tanaka, Ogata and Stoyan (2008, Section 2.3)
for assessing goodness-of-fit of a Neyman-Scott cluster process model
to a point pattern dataset. The diagnostic is computed by
the function <code><a href="#topic+palmdiagnose">palmdiagnose</a></code>.
</p>
<p>First the Palm intensity of the fitted model is plotted as a
function of interpoint distance <code class="reqn">r</code> using
<code><a href="spatstat.explore.html#topic+plot.fv">plot.fv</a></code>. Then the nonparametric estimates
of the Palm intensity are plotted on the same graph as follows:
</p>

<ul>
<li><p> if <code>style="dots"</code>, the nonparametric
estimate for each band of distances is plotted as a dot,
with horizontal coordinate at the middle of the band.
This is the style proposed by Tanaka et al (2008).
</p>
</li>
<li><p> if <code>style="intervals"</code> (the default), each nonparametric estimate
is plotted as a dot, and a 95% confidence interval is
plotted as a vertical line segment, centred on the dot.
The confidence interval is based on the Poisson approximation.
</p>
</li>
<li><p> if <code>style="bands"</code>, the nonparametric estimates
are drawn as a continuous curve which is flat on each band of
distances. The 95% confidence intervals are drawn as grey shading.
</p>
</li></ul>



<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for Neyman-Scott Point
Processes.
<em>Biometrical Journal</em> <b>50</b>, 1, 43&ndash;57.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+palmdiagnose">palmdiagnose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- kppm(redwood)
   R &lt;- palmdiagnose(fit)
   plot(R, style="d")
   plot(R)
   plot(R, style="b")
</code></pre>

<hr>
<h2 id='plot.plotppm'>Plot a plotppm Object Created by plot.ppm</h2><span id='topic+plot.plotppm'></span>

<h3>Description</h3>

<p>The function plot.ppm produces objects which specify plots
of fitted point process models.  The function plot.plotppm
carries out the actual plotting of these objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'plotppm'
plot(x, data = NULL, trend = TRUE, cif = TRUE,
             se = TRUE, pause = interactive(),
             how = c("persp", "image", "contour"),
             ..., pppargs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.plotppm_+3A_x">x</code></td>
<td>

<p>An object of class <code>plotppm</code> produced by
<code><a href="#topic+plot.ppm">plot.ppm</a>()</code>
</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="plot.plotppm_+3A_data">data</code></td>
<td>

<p>The point pattern (an object of class <code>ppp</code>)
to which the point process model was fitted (by <code><a href="#topic+ppm">ppm</a></code>).
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_trend">trend</code></td>
<td>

<p>Logical scalar; should the trend component of
the fitted model be plotted?
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_cif">cif</code></td>
<td>

<p>Logical scalar; should the complete conditional
intensity of the fitted model be plotted?
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_se">se</code></td>
<td>

<p>Logical scalar; should the estimated standard error
of the fitted intensity be plotted?
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_pause">pause</code></td>
<td>

<p>Logical scalar indicating whether to pause with a prompt 
after each plot. Set <code>pause=FALSE</code> if plotting to a file.
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_how">how</code></td>
<td>

<p>Character string or character vector indicating the style or styles of
plots to be performed.
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_...">...</code></td>
<td>

<p>Extra arguments to the plotting functions
<code><a href="graphics.html#topic+persp">persp</a></code>, <code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.plotppm_+3A_pppargs">pppargs</code></td>
<td>

<p>List of extra arguments passed to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
when displaying the original point pattern data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>data</code> is supplied then the point pattern will
be superimposed on the image and contour plots.
</p>
<p>Sometimes a fitted model does not have a trend component, or the
trend component may constitute all of the conditional intensity (if
the model is Poisson).  In such cases the object <code>x</code> will not
contain a trend component, or will contain only a trend component.
This will also be the case if one of the arguments <code>trend</code>
and <code>cif</code> was set equal to <code>FALSE</code> in the call to
<code>plot.ppm()</code> which produced <code>x</code>.  If this is so then
only the item which is present will be plotted.  Explicitly setting
<code>trend=TRUE</code>, or <code>cif=TRUE</code>, respectively, will then give
an error.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Warning</h3>

<p>Arguments which are passed to <code>persp</code>, <code>image</code>, and
<code>contour</code> via the ... argument get passed to any of the
other functions listed in the <code>how</code> argument, and won't be
recognized by them.  This leads to a lot of annoying but harmless
warning messages.  Arguments to <code>persp</code> may be supplied via
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a>()</code> which alleviates the warning
messages in this instance.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.ppm">plot.ppm</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> if(interactive()) {
 m &lt;- ppm(cells ~ 1, Strauss(0.05))
 mpic &lt;- plot(m)
 # Perspective plot only, with altered parameters:
  plot(mpic,how="persp", theta=-30,phi=40,d=4)
 # All plots, with altered parameters for perspective plot:
 op &lt;- spatstat.options(par.persp=list(theta=-30,phi=40,d=4))
 plot(mpic)
 # Revert
 spatstat.options(op)
 }
</code></pre>

<hr>
<h2 id='plot.ppm'>plot a Fitted Point Process Model</h2><span id='topic+plot.ppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model obtained by <code><a href="#topic+ppm">ppm</a></code>,
create spatial trend and conditional intensity surfaces of the model,
in a form suitable for plotting, and (optionally) plot these
surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
plot(x, ngrid = c(40,40), superimpose = TRUE, 
                  trend = TRUE, cif = TRUE, se = TRUE, pause = interactive(),
                  how=c("persp","image", "contour"), plot.it = TRUE,
                  locations = NULL, covariates=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ppm_+3A_x">x</code></td>
<td>

<p>A fitted point process model, typically obtained from
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>.
An object of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_ngrid">ngrid</code></td>
<td>

<p>The dimensions for a grid on which to evaluate,
for plotting, the spatial trend and conditional intensity.
A vector of 1 or 2 integers. If it is of length 1,
<code>ngrid</code> is replaced by <code>c(ngrid,ngrid)</code>.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_superimpose">superimpose</code></td>
<td>

<p>logical flag; if <code>TRUE</code> (and if <code>plot=TRUE</code>) the
original data point pattern will be superimposed on the plots.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_trend">trend</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, the spatial trend surface will be produced.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_cif">cif</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, the conditional intensity surface will be
produced.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_se">se</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, the estimated standard error of the
spatial trend surface will be produced.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_pause">pause</code></td>
<td>

<p>logical flag indicating whether to pause with a prompt 
after each plot. Set <code>pause=FALSE</code> if plotting to a file.
(This flag is ignored if <code>plot=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_how">how</code></td>
<td>

<p>character string or character vector indicating the style or styles of
plots to be performed. Ignored if <code>plot=FALSE</code>.  
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_plot.it">plot.it</code></td>
<td>

<p>logical scalar; should a plot be produced immediately?
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_locations">locations</code></td>
<td>

<p>If present, this determines the locations of the pixels
at which predictions are computed. It must be a binary pixel image
(an object of class <code>"owin"</code> with type <code>"mask"</code>).
(Incompatible with <code>ngrid</code>).
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_covariates">covariates</code></td>
<td>

<p>Values of external covariates required by the fitted model.
Passed to <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.ppm_+3A_...">...</code></td>
<td>

<p>extra arguments to the plotting functions <code><a href="graphics.html#topic+persp">persp</a></code>,
<code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for the class <code>"ppm"</code>
(see <code><a href="#topic+ppm.object">ppm.object</a></code> for details of this class).
</p>
<p>It invokes <code><a href="#topic+predict.ppm">predict.ppm</a></code> to compute the spatial 
trend and conditional intensity of the fitted point process model.
See <code><a href="#topic+predict.ppm">predict.ppm</a></code> for more explanation about spatial trend
and conditional intensity.
</p>
<p>The default action is to create a rectangular grid
of points in (the bounding box of) the observation window of
the data point pattern, and evaluate the spatial trend and
conditional intensity of the fitted spatial point process model
<code>x</code> at these locations.  If the argument <code>locations=</code>
is supplied, then the spatial trend
and conditional intensity are calculated at the grid of points
specified by this argument.
</p>
<p>The argument <code>locations</code>, if present, should be a
binary image mask (an object of class <code>"owin"</code>
and type <code>"mask"</code>). This determines a rectangular grid
of locations, or a subset of such a grid, at which predictions
will be computed. Binary image masks
are conveniently created using <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>
<p>The argument <code>covariates</code> gives the values of any spatial covariates
at the prediction locations.
If the trend formula in the fitted model 
involves spatial covariates (other than
the Cartesian coordinates <code>x</code>, <code>y</code>)
then <code>covariates</code> is required.
</p>
<p>The argument <code>covariates</code> has the same format and interpretation
as in <code><a href="#topic+predict.ppm">predict.ppm</a></code>. It may be
either a data frame (the number of whose rows must match
the number of pixels in <code>locations</code> multiplied by the number of
possible marks in the point pattern),  or a list of images.
If argument <code>locations</code>
is not supplied, and <code>covariates</code> <b>is</b> supplied, then
it <b>must</b> be a list of images.
</p>
<p>If the fitted model was a marked (multitype) point process, then 
predictions are made for each possible mark value in turn.
</p>
<p>If the fitted model had no spatial trend, then the default is 
to omit calculating this (flat) surface, unless <code>trend=TRUE</code>
is set explicitly.
</p>
<p>If the fitted model was Poisson, so that there were no spatial interactions,
then the conditional intensity and spatial trend are identical, and the
default is to omit the conditional intensity, unless <code>cif=TRUE</code> is set
explicitly.
</p>
<p>If <code>plot.it=TRUE</code> then <code><a href="#topic+plot.plotppm">plot.plotppm</a>()</code> is called
upon to plot the class <code>plotppm</code> object which is produced.
(That object is also returned, silently.)
</p>
<p>Plots are produced successively using <code><a href="graphics.html#topic+persp">persp</a></code>,
<code><a href="Matrix.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code> (or only a
selection of these three, if <code>how</code> is given).  Extra
graphical parameters controlling the display may be passed
directly via the arguments <code>...</code> or indirectly reset using
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>plotppm</code>.  Such objects may be plotted by
<code><a href="#topic+plot.plotppm">plot.plotppm</a>()</code>.
</p>
<p>This is a list with components named <code>trend</code> and <code>cif</code>,
either of which may
be missing. They will be missing if the corresponding component
does not make sense for the model, or if the corresponding
argument was set equal to <code>FALSE</code>.
</p>
<p>Both <code>trend</code> and <code>cif</code> are lists of images.
If the model is an unmarked point process, then they are lists of
length 1, so that <code>trend[[1]]</code> is an image of the spatial trend
and <code>cif[[1]]</code> is an image of the conditional intensity.
</p>
<p>If the model is a marked point process, then <code>trend[[i]]</code>
is an image of the spatial trend for the mark <code>m[i]</code>,
and <code>cif[[1]]</code> is an image of the conditional intensity
for the mark <code>m[i]</code>, where <code>m</code> is the vector of levels
of the marks.
</p>


<h3>Warnings</h3>

<p>See warnings in <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.plotppm">plot.plotppm</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="#topic+print.ppm">print.ppm</a></code>,
<code><a href="graphics.html#topic+persp">persp</a></code>,
<code><a href="Matrix.html#topic+image">image</a></code>,
<code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> m &lt;- ppm(cells ~1, Strauss(0.05))
 pm &lt;- plot(m) # The object ``pm'' will be plotted as well as saved
               # for future plotting.
 pm
</code></pre>

<hr>
<h2 id='plot.profilepl'>
Plot Profile Likelihood
</h2><span id='topic+plot.profilepl'></span>

<h3>Description</h3>

<p>Plot the profile (pseudo) likelihood 
against the irregular parameters, for a model that was fitted by
maximum profile (pseudo)likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profilepl'
plot(x, ..., add = FALSE, main = NULL, tag = TRUE,
                         coeff = NULL, xvariable = NULL,
                         col = 1, lty = 1, lwd = 1,
                         col.opt = "green", lty.opt = 3, lwd.opt = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profilepl_+3A_x">x</code></td>
<td>

<p>A point process model fitted by maximum profile (pseudo)likelihood.
Object of class <code>"profilepl"</code>, obtained from <code><a href="#topic+profilepl">profilepl</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_...">...</code></td>
<td>

<p>Additional plot arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
and <code><a href="graphics.html#topic+lines">lines</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_add">add</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the plot is drawn over the existing plot.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_main">main</code></td>
<td>

<p>Optional. Main title for the plot. A character string or character vector.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_tag">tag</code></td>
<td>

<p>Logical value. If <code>TRUE</code> (the default), 
when the plot contains multiple curves corresponding to different
values of a parameter, each curve will be labelled 
with the values of the irregular parameter.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_coeff">coeff</code></td>
<td>

<p>Optional. If this is given, it should be a character string matching
the name of one of the fitted model coefficients. This coefficient
will then be plotted on the vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_xvariable">xvariable</code></td>
<td>

<p>Optional. The name of the irregular parameter that should be plotted
along the horizontal axis. The default is the first irregular
parameter. 
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_col">col</code>, <code id="plot.profilepl_+3A_lty">lty</code>, <code id="plot.profilepl_+3A_lwd">lwd</code></td>
<td>

<p>Graphical parameters (colour, line type, line width) for
the curves on the plot. 
</p>
</td></tr>
<tr><td><code id="plot.profilepl_+3A_col.opt">col.opt</code>, <code id="plot.profilepl_+3A_lty.opt">lty.opt</code>, <code id="plot.profilepl_+3A_lwd.opt">lwd.opt</code></td>
<td>

<p>Graphical parameters for indicating the optimal parameter value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code><a href="graphics.html#topic+plot">plot</a></code> method for the
class <code>"profilepl"</code> of fitted point process models obtained
by maximising the profile likelihood or profile pseudolikelihood.
</p>
<p>The default behaviour is to plot the profile likelihood or profile
pseudolikelihood on the vertical axis, against the value of the
irregular parameter on the horizontal axis.
</p>
<p>If there are several irregular parameters, then one of them
is plotted on the horizontal axis, and the plot consists of many different
curves, corresponding to different values of the other parameters.
The parameter to be plotted on the horizontal axis is specified by the
argument <code>xvariable</code>; the default is to use the parameter that was
listed first in the original call to <code><a href="#topic+profilepl">profilepl</a></code>.
</p>
<p>If <code>coeff</code> is given, it should be the name of one of the
fitted model coefficients <code>names(coef(as.ppm(x)))</code>. 
The fitted value of that coefficient is plotted on the vertical axis.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profilepl">profilepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  live &lt;- interactive()
  nr &lt;- if(live) 20 else 3

  # one irregular parameter
  rr &lt;- data.frame(r=seq(0.05,0.15, length=nr))
  ps &lt;- profilepl(rr, Strauss, cells)
  plot(ps)                      # profile pseudolikelihood 
  plot(ps, coeff="Interaction") # fitted interaction coefficient log(gamma)

  # two irregular parameters
  smax &lt;- if(live) 3 else 2
  rs &lt;- expand.grid(r=seq(0.05,0.15, length=nr), sat=1:smax)
  pg &lt;- profilepl(rs, Geyer, cells)
  plot(pg) # profile pseudolikelihood against r for each value of 'sat'
  plot(pg, coeff="Interaction")
  plot(pg, xvariable="sat", col=ifelse(r &lt; 0.1, "red", "green"))
</code></pre>

<hr>
<h2 id='plot.rppm'>
Plot a Recursively Partitioned Point Process Model
</h2><span id='topic+plot.rppm'></span>

<h3>Description</h3>

<p>Given a model which has been fitted to point pattern data
by recursive partitioning, plot the partition tree
or the fitted intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rppm'
plot(x, ..., what = c("tree", "spatial"), treeplot=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rppm_+3A_x">x</code></td>
<td>

<p>Fitted point process model of class <code>"rppm"</code>
produced by the function <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.rppm_+3A_what">what</code></td>
<td>

<p>Character string (partially matched) specifying whether to plot the
partition tree or the fitted intensity.
</p>
</td></tr>
<tr><td><code id="plot.rppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="rpart.html#topic+plot.rpart">plot.rpart</a></code>
and <code><a href="rpart.html#topic+text.rpart">text.rpart</a></code> (if <code>what="tree"</code>)
or passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> (if <code>what="spatial"</code>)
controlling the appearance of the plot.
</p>
</td></tr>
<tr><td><code id="plot.rppm_+3A_treeplot">treeplot</code></td>
<td>

<p>Optional. A function to be used to plot and label the partition tree,
replacing the two functions  <code><a href="rpart.html#topic+plot.rpart">plot.rpart</a></code>
and <code><a href="rpart.html#topic+text.rpart">text.rpart</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>what="tree"</code> (the default), the partition tree will be plotted
using <code><a href="rpart.html#topic+plot.rpart">plot.rpart</a></code>, and labelled using
<code><a href="rpart.html#topic+text.rpart">text.rpart</a></code>.
</p>
<p>If the argument <code>treeplot</code> is
given, then plotting and labelling will be performed by
<code>treeplot</code> instead. A good choice is the function
<code>prp</code> in package <span class="pkg">rpart.plot</span>.
</p>
<p>If <code>what="spatial"</code>, the predicted intensity
will be computed using <code><a href="#topic+predict.rppm">predict.rppm</a></code>, and
this intensity will be plotted as an image using <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>


<h3>Value</h3>

<p>If <code>what="tree"</code>, a list containing <code>x</code> and <code>y</code>
coordinates of the plotted nodes of the tree.
If <code>what="spatial"</code>, the return value of <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rppm">rppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # Murchison gold data
    mur &lt;- solapply(murchison, rescale, s=1000, unitname="km")
    mur$dfault &lt;- distfun(mur$faults)
    # 
    fit &lt;- rppm(gold ~ dfault + greenstone, data=mur)
    #
    opa &lt;- par(mfrow=c(1,2))
    plot(fit)
    plot(fit, what="spatial")
    par(opa)
</code></pre>

<hr>
<h2 id='plot.slrm'>
Plot a Fitted Spatial Logistic Regression
</h2><span id='topic+plot.slrm'></span>

<h3>Description</h3>

<p>Plots a fitted Spatial Logistic Regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
plot(x, ..., type = "intensity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.slrm_+3A_x">x</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="plot.slrm_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> to
control the appearance of the plot.
</p>
</td></tr>
<tr><td><code id="plot.slrm_+3A_type">type</code></td>
<td>

<p>Character string (partially) matching one of 
<code>"probabilities"</code>, <code>"intensity"</code> or <code>"link"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="graphics.html#topic+plot">plot</a></code> for fitted spatial logistic
regression models (objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>).
</p>
<p>This function plots the result of <code><a href="#topic+predict.slrm">predict.slrm</a></code>.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>, 
<code><a href="#topic+predict.slrm">predict.slrm</a></code>, 
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- copper$SouthPoints
   Y &lt;- copper$SouthLines
   Z &lt;- distmap(Y)
   fit &lt;- slrm(X ~ Z)
   plot(fit)
   plot(fit, type="link")
</code></pre>

<hr>
<h2 id='Poisson'>Poisson Point Process Model</h2><span id='topic+Poisson'></span>

<h3>Description</h3>

<p>Creates an instance of the Poisson point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Poisson()
</code></pre>


<h3>Details</h3>

<p>The function <code><a href="#topic+ppm">ppm</a></code>, which fits point process models to 
point pattern data, requires an argument <code>interaction</code>
of class <code>"interact"</code>
describing the interpoint interaction structure
of the model to be fitted. 
The appropriate description of the Poisson process is 
provided by the value of the function <code>Poisson</code>.
</p>
<p>This works for all types of Poisson processes including
multitype and nonstationary Poisson processes.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction 
structure of the Poisson point process
(namely, there are no interactions).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ppm(nztrees ~1, Poisson())
 # fit the stationary Poisson process to 'nztrees'
 # no edge correction needed

 lon &lt;- longleaf
 
 longadult &lt;- unmark(subset(lon, marks &gt;= 30))
 ppm(longadult ~ x, Poisson())
 # fit the nonstationary Poisson process 
 # with intensity lambda(x,y) = exp( a + bx)

 # trees marked by species
 lans &lt;- lansing
 
 ppm(lans ~ marks, Poisson())
 # fit stationary marked Poisson process
 # with different intensity for each species

 
   ppm(lansing ~ marks * polynom(x,y,3), Poisson())
   # fit nonstationary marked Poisson process
   # with different log-cubic trend for each species
 
 
</code></pre>

<hr>
<h2 id='polynom'>
Polynomial in One or Two Variables
</h2><span id='topic+polynom'></span>

<h3>Description</h3>

<p>This function is used to represent a polynomial term in a model
formula.
It computes the homogeneous terms in the polynomial of degree <code>n</code>
in one variable <code>x</code> or two variables <code>x,y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  polynom(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polynom_+3A_x">x</code></td>
<td>

<p>A numerical vector.
</p>
</td></tr>
<tr><td><code id="polynom_+3A_...">...</code></td>
<td>

<p>Either a single integer <code>n</code> specifying the degree of the polynomial,
or two arguments <code>y,n</code> giving another vector of data <code>y</code>
and the degree of the polynomial.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is typically used inside a model formula
in order to specify the most general possible polynomial
of order <code>n</code> involving one numerical variable <code>x</code>
or two numerical variables <code>x,y</code>.
</p>
<p>It is equivalent to <code><a href="stats.html#topic+poly">poly</a>(, raw=TRUE)</code>.
</p>
<p>If only one numerical vector argument <code>x</code> is given, 
the function computes the vectors <code>x^k</code> for
<code>k = 1, 2, ..., n</code>. These vectors are combined into a matrix
with <code>n</code> columns.
</p>
<p>If two numerical vector arguments <code>x,y</code> are given,
the function computes the vectors <code>x^k * y^m</code> for
<code>k &gt;= 0</code> and <code>m &gt;= 0</code> satisfying
<code>0 &lt; k + m &lt;= n</code>. These vectors are combined into a matrix
with one column for each homogeneous term.
</p>


<h3>Value</h3>

<p>A numeric matrix, with rows corresponding to the entries of <code>x</code>,
and columns corresponding to the terms in the polynomial.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+poly">poly</a></code>,
<code><a href="#topic+harmonic">harmonic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- 1:4
   y &lt;- 10 * (0:3)
   polynom(x, 3)
   polynom(x, y, 3)
</code></pre>

<hr>
<h2 id='ppm'>
Fit Point Process Model to Data
</h2><span id='topic+ppm'></span><span id='topic+ppm.formula'></span>

<h3>Description</h3>

<p>Fits a point process model to an observed point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ppm(Q, ...)

   ## S3 method for class 'formula'
ppm(Q, interaction=NULL, ..., data=NULL, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppm_+3A_q">Q</code></td>
<td>

<p>A <code>formula</code> in the <span class="rlang"><b>R</b></span> language describing the model
to be fitted. 
</p>
</td></tr>
<tr><td><code id="ppm_+3A_interaction">interaction</code></td>
<td>

<p>An object of class <code>"interact"</code>
describing the point process interaction
structure, or a function that makes such an object,
or <code>NULL</code> indicating that a Poisson process (stationary
or nonstationary) should be fitted.
</p>
</td></tr>
<tr><td><code id="ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+ppm.ppp">ppm.ppp</a></code>
or <code><a href="#topic+ppm.quad">ppm.quad</a></code> to control the model-fitting process.
</p>
</td></tr>
<tr><td><code id="ppm_+3A_data">data</code></td>
<td>

<p>Optional. The values of spatial covariates (other than the Cartesian
coordinates) required by the model.
Either a data frame, or a list whose entries are images,
functions, windows, tessellations or single numbers. See Details.
</p>
</td></tr>
<tr><td><code id="ppm_+3A_subset">subset</code></td>
<td>

<p>Optional.
An expression (which may involve the names of the
Cartesian coordinates <code>x</code> and <code>y</code>
and the names of entries in <code>data</code>)
defining a subset of the spatial domain,
to which the model-fitting should be restricted.
The result of evaluating the expression should be either a logical
vector, or a window (object of class <code>"owin"</code>)
or a logical-valued pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a point process model
to an observed point pattern.
The model may include
spatial trend, interpoint interaction, and dependence on covariates.
</p>
<p>The model fitted by <code>ppm</code>
is either a Poisson point process (in which different points
do not interact with each other) or a Gibbs point process (in which
different points typically inhibit each other).
For clustered point process models, use <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The function <code>ppm</code> is generic, with methods for
the classes <code>formula</code>, <code>ppp</code> and <code>quad</code>.
This page describes the method for a <code>formula</code>.
</p>
<p>The first argument is a <code>formula</code> in the <span class="rlang"><b>R</b></span> language
describing the spatial trend model to be fitted. It has the general form
<code>pattern ~ trend</code> where the left hand side <code>pattern</code> is usually
the name of a spatial point pattern (object of class <code>"ppp"</code>)
to which the model should be fitted, or an expression which evaluates
to a point pattern;
and the right hand side <code>trend</code> is an expression specifying the
spatial trend of the model.
</p>
<p>Systematic effects (spatial trend and/or dependence on 
spatial covariates) are specified by the 
<code>trend</code> expression on the right hand side of the formula.
The trend may involve
the Cartesian coordinates <code>x</code>, <code>y</code>,
the marks <code>marks</code>,
the names of entries in the argument <code>data</code> (if supplied),
or the names of objects that exist in the <span class="rlang"><b>R</b></span> session.
The trend formula specifies the <b>logarithm</b> of the
intensity of a Poisson process, or in general, the logarithm of
the first order potential of the Gibbs process.
The formula should not use any names beginning with <code>.mpl</code>
as these are reserved for internal use.
If the formula is <code>pattern~1</code>, then
the model to be fitted is stationary (or at least, its first order 
potential is constant).
</p>
<p>The symbol <code>.</code> in the trend expression stands for
all the covariates supplied in the argument <code>data</code>.
For example the formula <code>pattern ~ .</code> indicates an additive
model with a main effect for each covariate in <code>data</code>.
</p>
<p>Stochastic interactions between random points of the point process
are defined by the argument <code>interaction</code>. This is an object of
class <code>"interact"</code> which is initialised in a very similar way to the
usage of family objects in <code><a href="stats.html#topic+glm">glm</a></code> and <code>gam</code>.
The interaction models currently available are:
<code><a href="#topic+AreaInter">AreaInter</a></code>, <code><a href="#topic+BadGey">BadGey</a></code>, <code><a href="#topic+Concom">Concom</a></code>, <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="#topic+Fiksel">Fiksel</a></code>, <code><a href="#topic+Geyer">Geyer</a></code>, <code><a href="#topic+Hardcore">Hardcore</a></code>, <code><a href="#topic+HierHard">HierHard</a></code>, <code><a href="#topic+HierStrauss">HierStrauss</a></code>, <code><a href="#topic+HierStraussHard">HierStraussHard</a></code>, <code><a href="#topic+Hybrid">Hybrid</a></code>, <code><a href="#topic+LennardJones">LennardJones</a></code>, <code><a href="#topic+MultiHard">MultiHard</a></code>, <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="#topic+OrdThresh">OrdThresh</a></code>, <code><a href="#topic+Ord">Ord</a></code>, <code><a href="#topic+Pairwise">Pairwise</a></code>, <code><a href="#topic+PairPiece">PairPiece</a></code>, <code><a href="#topic+Penttinen">Penttinen</a></code>, <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Saturated">Saturated</a></code>, <code><a href="#topic+SatPiece">SatPiece</a></code>, <code><a href="#topic+Softcore">Softcore</a></code>, <code><a href="#topic+Strauss">Strauss</a></code>, <code><a href="#topic+StraussHard">StraussHard</a></code> and <code><a href="#topic+Triplets">Triplets</a></code>.
See the examples below.
Note that it is possible to combine several interactions
using <code><a href="#topic+Hybrid">Hybrid</a></code>.
</p>
<p>If <code>interaction</code> is missing or <code>NULL</code>,
then the model to be fitted
has no interpoint interactions, that is, it is a Poisson process
(stationary or nonstationary according to <code>trend</code>). In this case
the methods of maximum pseudolikelihood and maximum logistic likelihood
coincide with maximum likelihood. 
</p>
<p>The fitted point process model returned by this function can be printed 
(by the print method <code><a href="#topic+print.ppm">print.ppm</a></code>)
to inspect the fitted parameter values.
If a nonparametric spatial trend was fitted, this can be extracted using
the predict method <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>
<p>To fit a model involving spatial covariates
other than the Cartesian coordinates <code class="reqn">x</code> and <code class="reqn">y</code>,
the values of the covariates should either be supplied in the
argument <code>data</code>, or should be stored in objects that exist
in the <span class="rlang"><b>R</b></span> session.
Note that it is not sufficient to have observed
the covariate only at the points of the data point pattern; 
the covariate must also have been observed at other 
locations in the window.
</p>
<p>If it is given, the argument <code>data</code> is typically
a list, with names corresponding to variables in the <code>trend</code> formula.
Each entry in the list is either
</p>

<dl>
<dt>a pixel image,</dt><dd>
<p>giving the values of a spatial covariate at 
a fine grid of locations. It should be an object of
class <code>"im"</code>, see <code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>.
</p>
</dd>
<dt>a function,</dt><dd>
<p>which can be evaluated
at any location <code>(x,y)</code> to obtain the value of the spatial
covariate. It should be a <code>function(x, y)</code>
or <code>function(x, y, ...)</code> in the <span class="rlang"><b>R</b></span> language.
For marked point pattern data, the covariate can be a
<code>function(x, y, marks)</code> or <code>function(x, y, marks, ...)</code>.
The first two arguments of the function should be the
Cartesian coordinates <code class="reqn">x</code> and <code class="reqn">y</code>.
The function may have additional arguments;
if the function does not have default
values for these additional arguments, then the user must
supply values for them, in <code>covfunargs</code>.
See the Examples.
</p>
</dd>
<dt>a window,</dt><dd>
<p>interpreted as a logical variable
which is <code>TRUE</code> inside the window and <code>FALSE</code> outside
it. This should be an object of class <code>"owin"</code>.
</p>
</dd>
<dt>a tessellation,</dt><dd>
<p>interpreted as a factor covariate.
For each spatial location, the factor value indicates
which tile of the tessellation it belongs to.
This should be an object of class <code>"tess"</code>.
(To make a covariate in which each tile of the tessellation
has a numerical value, convert the tessellation to a <code>function(x,y)</code>
using <code><a href="spatstat.geom.html#topic+as.function.tess">as.function.tess</a></code>.)
</p>
</dd>
<dt>a single number,</dt><dd><p>indicating a covariate that is
constant in this dataset.
</p>
</dd>
</dl>

<p>The software will look up
the values of each covariate at the required locations
(quadrature points).
</p>
<p>Note that, for covariate functions, only the <em>name</em> of the
function appears in the trend formula. A covariate function is
treated as if it were a single variable. The function arguments do not
appear in the trend formula. See the Examples.
</p>
<p>If <code>data</code> is a list,
the list entries should have names corresponding to
(some of) the names of covariates in the model formula <code>trend</code>.
The variable names <code>x</code>, <code>y</code> and <code>marks</code>
are reserved for the Cartesian 
coordinates and the mark values,
and these should not be used for variables in <code>data</code>.
</p>
<p>Alternatively, <code>data</code> may be a data frame
giving the values of the covariates at specified locations.
Then <code>pattern</code> should be a quadrature scheme (object of class
<code>"quad"</code>) giving the corresponding locations.
See <code><a href="#topic+ppm.quad">ppm.quad</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class <code>"ppm"</code> describing a fitted point process
model.
</p>
<p>See <code><a href="#topic+ppm.object">ppm.object</a></code> for details of the format of this object
and methods available for manipulating it.
</p>


<h3>Interaction parameters</h3>

<p>Apart from the Poisson model, every point process model fitted by
<code>ppm</code> has parameters that determine the strength and
range of &lsquo;interaction&rsquo; or dependence between points.
These parameters are of two types:
</p>

<dl>
<dt>regular parameters:</dt><dd>
<p>A parameter <code class="reqn">\phi</code> is called <em>regular</em>
if the log likelihood is a linear function of <code class="reqn">\theta</code> where 
<code class="reqn">\theta = \theta(\psi)</code> is some transformation of 
<code class="reqn">\psi</code>. [Then <code class="reqn">\theta</code> is called the canonical
parameter.]
</p>
</dd>
<dt>irregular parameters</dt><dd>
<p>Other parameters are called <em>irregular</em>. 
</p>
</dd>
</dl>

<p>Typically, regular parameters determine the &lsquo;strength&rsquo;
of the interaction, while irregular parameters determine the
&lsquo;range&rsquo; of the interaction. For example, the Strauss process
has a regular parameter <code class="reqn">\gamma</code> controlling the strength
of interpoint inhibition, and an irregular parameter <code class="reqn">r</code>
determining the range of interaction.
</p>
<p>The <code>ppm</code> command is only designed to estimate regular
parameters of the interaction.
It requires the values of any irregular parameters of the interaction
to be fixed. For example, to fit a Strauss process model to the <code>cells</code>
dataset, you could type <code>ppm(cells ~ 1, Strauss(r=0.07))</code>.
Note that the value of the irregular parameter <code>r</code> must be given.
The result of this command will be a fitted model in which the
regular parameter <code class="reqn">\gamma</code> has been estimated.
</p>
<p>To determine the irregular parameters, there are several
practical techniques, but no general statistical theory available.
Useful techniques include maximum profile pseudolikelihood, which
is implemented in the command <code><a href="#topic+profilepl">profilepl</a></code>,
and Newton-Raphson maximisation, implemented in the
experimental command <code><a href="#topic+ippm">ippm</a></code>. 
</p>
<p>Some irregular parameters can be estimated directly from data:
the hard-core radius in the model <code><a href="#topic+Hardcore">Hardcore</a></code>
and the matrix of hard-core radii in <code><a href="#topic+MultiHard">MultiHard</a></code> can be
estimated easily from data. In these cases, <code>ppm</code> allows the user
to specify the interaction without giving
the value of the irregular parameter. The user can give the
hard core interaction as <code>interaction=Hardcore()</code>
or even <code>interaction=Hardcore</code>, and 
the hard core radius will then be estimated from the data.
</p>


<h3>Technical Warnings and Error Messages</h3>

<p>See <code><a href="#topic+ppm.ppp">ppm.ppp</a></code> for some technical warnings about the
weaknesses of the algorithm, and explanation of some common error messages.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Coeurjolly, J.-F., Rubak, E. and Waagepetersen, R. (2014)
Logistic regression for spatial Gibbs point processes.
<em>Biometrika</em> <b>101</b> (2) 377&ndash;392.
</p>
<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> 283&ndash;322.
</p>
<p>Berman, M. and Turner, T.R. (1992)
Approximating point process likelihoods with GLIM.
<em>Applied Statistics</em> <b>41</b>,  31&ndash;38.
</p>
<p>Besag, J. (1975)
Statistical analysis of non-lattice data.
<em>The Statistician</em> <b>24</b>, 179-195.
</p>
<p>Diggle, P.J., Fiksel, T., Grabarnik, P., Ogata, Y., Stoyan, D. and
Tanemura, M. (1994)
On parameter estimation for pairwise interaction processes.
<em>International Statistical Review</em> <b>62</b>, 99-117.
</p>
<p>Huang, F. and Ogata, Y. (1999)
Improvements of the maximum pseudo-likelihood estimators
in various spatial statistical models.
<em>Journal of Computational and Graphical Statistics</em>
<b>8</b>, 510&ndash;530.
</p>
<p>Jensen, J.L. and Moeller, M. (1991)
Pseudolikelihood for exponential family models of spatial point processes.
<em>Annals of Applied Probability</em> <b>1</b>, 445&ndash;461.
</p>
<p>Jensen, J.L. and Kuensch, H.R. (1994)
On asymptotic normality of pseudo likelihood
estimates for pairwise interaction processes,
<em>Annals of the Institute of Statistical Mathematics</em>
<b>46</b>, 475&ndash;486.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.ppp">ppm.ppp</a></code> and <code><a href="#topic+ppm.quad">ppm.quad</a></code> for
more details on the fitting technique and edge correction.
</p>
<p><code><a href="#topic+ppm.object">ppm.object</a></code> for details of how to
print, plot and manipulate a fitted model.
</p>
<p><code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> and <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>
for constructing data.
</p>
<p>Interactions: <code><a href="#topic+AreaInter">AreaInter</a></code>, <code><a href="#topic+BadGey">BadGey</a></code>, <code><a href="#topic+Concom">Concom</a></code>, <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="#topic+Fiksel">Fiksel</a></code>, <code><a href="#topic+Geyer">Geyer</a></code>, <code><a href="#topic+Hardcore">Hardcore</a></code>, <code><a href="#topic+HierHard">HierHard</a></code>, <code><a href="#topic+HierStrauss">HierStrauss</a></code>, <code><a href="#topic+HierStraussHard">HierStraussHard</a></code>, <code><a href="#topic+Hybrid">Hybrid</a></code>, <code><a href="#topic+LennardJones">LennardJones</a></code>, <code><a href="#topic+MultiHard">MultiHard</a></code>, <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="#topic+OrdThresh">OrdThresh</a></code>, <code><a href="#topic+Ord">Ord</a></code>, <code><a href="#topic+Pairwise">Pairwise</a></code>, <code><a href="#topic+PairPiece">PairPiece</a></code>, <code><a href="#topic+Penttinen">Penttinen</a></code>, <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Saturated">Saturated</a></code>, <code><a href="#topic+SatPiece">SatPiece</a></code>, <code><a href="#topic+Softcore">Softcore</a></code>, <code><a href="#topic+Strauss">Strauss</a></code>, <code><a href="#topic+StraussHard">StraussHard</a></code> and <code><a href="#topic+Triplets">Triplets</a></code>.
</p>
<p>See <code><a href="#topic+profilepl">profilepl</a></code> for advice on
fitting nuisance parameters in the interaction,
and <code><a href="#topic+ippm">ippm</a></code> for irregular parameters in the trend.
</p>
<p>See <code><a href="#topic+valid.ppm">valid.ppm</a></code> and <code><a href="#topic+project.ppm">project.ppm</a></code> for
ensuring the fitted model is a valid point process.
</p>
<p>See <code><a href="#topic+kppm">kppm</a></code> for fitting Cox point process models
and cluster point process models, and <code><a href="#topic+dppm">dppm</a></code> for fitting
determinantal point process models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> online &lt;- interactive()
 if(!online) {
    # reduce grid sizes for efficiency in tests
    spatstat.options(npixel=32, ndummy.min=16)
 }

 # fit the stationary Poisson process
 # to point pattern 'nztrees'

 ppm(nztrees ~ 1)

 if(online) {
   Q &lt;- quadscheme(nztrees) 
   ppm(Q ~ 1) 
   # equivalent.
 }

 fit1 &lt;- ppm(nztrees ~ x)
 # fit the nonstationary Poisson process 
 # with intensity function lambda(x,y) = exp(a + bx)
 # where x,y are the Cartesian coordinates
 # and a,b are parameters to be estimated

 fit1
 coef(fit1)
 coef(summary(fit1))

 ppm(nztrees ~ polynom(x,2))

 # fit the nonstationary Poisson process 
 # with intensity function lambda(x,y) = exp(a + bx + cx^2)

 if(online) {
   library(splines)
   ppm(nztrees ~ bs(x,df=3))
 }
 # Fits the nonstationary Poisson process 
 # with intensity function lambda(x,y) = exp(B(x))
 # where B is a B-spline with df = 3

 ppm(nztrees ~ 1, Strauss(r=10), rbord=10)

 # Fit the stationary Strauss process with interaction range r=10
 # using the border method with margin rbord=10

 ppm(nztrees ~ x, Strauss(13), correction="periodic")

 # Fit the nonstationary Strauss process with interaction range r=13
 # and exp(first order potential) =  activity = beta(x,y) = exp(a+bx)
 # using the periodic correction.

  # Compare Maximum Pseudolikelihood, Huang-Ogata and Variational Bayes fits:
  if(online) ppm(swedishpines ~ 1, Strauss(9))

  ppm(swedishpines ~ 1, Strauss(9), method="VBlogi")

  ppm(swedishpines ~ 1, Strauss(9), improve.type="ho",
      nsim=if(!online) 8 else 99)

  # Elastic net fit:
  if(require(glmnet)) {
    ppm(swedishpines ~ x+y, Strauss(9), improve.type="enet")
  }

 # COVARIATES
 #
 X &lt;- rpoispp(20)
 weirdfunction &lt;- function(x,y){ 10 * x^2 + 5 * sin(10 * y) }
 #
 # (a) covariate values as function
 ppm(X ~ y + weirdfunction)
 #
 # (b) covariate values in pixel image
 Zimage &lt;- as.im(weirdfunction, unit.square())
 ppm(X ~ y + Z, covariates=list(Z=Zimage))
 #
 # (c) covariate values in data frame
 Q &lt;- quadscheme(X)
 xQ &lt;- x.quad(Q)
 yQ &lt;- y.quad(Q)
 Zvalues &lt;- weirdfunction(xQ,yQ)
 ppm(Q ~  y + Z, data=data.frame(Z=Zvalues))
 # Note Q not X

 # COVARIATE FUNCTION WITH EXTRA ARGUMENTS
 #
f &lt;- function(x,y,a){ y - a }
ppm(X ~ x + f, covfunargs=list(a=1/2))

 # COVARIATE: logical value TRUE inside window, FALSE outside
 b &lt;- owin(c(0.1, 0.6), c(0.1, 0.9))
 ppm(X ~ b)

 ## MULTITYPE POINT PROCESSES ### 
 # fit stationary marked Poisson process
 # with different intensity for each species
 if(online) {
   ppm(lansing ~  marks, Poisson())
 } else {
  ama &lt;- amacrine[square(0.7)]
  a &lt;- ppm(ama ~  marks, Poisson(), nd=16)
 }

 # fit nonstationary marked Poisson process
 # with different log-cubic trend for each species
 if(online) {
  ppm(lansing ~  marks * polynom(x,y,3), Poisson())
 } else {
  b &lt;- ppm(ama ~  marks * polynom(x,y,2), Poisson(), nd=16)
 }

</code></pre>

<hr>
<h2 id='ppm.object'>Class of Fitted Point Process Models</h2><span id='topic+ppm.object'></span><span id='topic+methods.ppm'></span>

<h3>Description</h3>

<p>A class <code>ppm</code> to represent a fitted stochastic model
for a point process. The output of <code><a href="#topic+ppm">ppm</a></code>.
</p>


<h3>Details</h3>

<p>An object of class <code>ppm</code> represents a stochastic point process
model that has been fitted to a point pattern dataset.
Typically it is the output of the model fitter,
<code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The class <code>ppm</code> has methods for the following
standard generic functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    generic </td><td style="text-align: left;"> method </td><td style="text-align: left;"> description </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>print</code> </td><td style="text-align: left;"> <code><a href="#topic+print.ppm">print.ppm</a></code>
    </td><td style="text-align: left;"> print details </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot</code> </td><td style="text-align: left;"> <code><a href="#topic+plot.ppm">plot.ppm</a></code>
    </td><td style="text-align: left;"> plot fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>predict</code> </td><td style="text-align: left;"> <code><a href="#topic+predict.ppm">predict.ppm</a></code>
    </td><td style="text-align: left;"> fitted intensity and conditional intensity </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>fitted</code> </td><td style="text-align: left;"> <code><a href="#topic+fitted.ppm">fitted.ppm</a></code>
    </td><td style="text-align: left;"> fitted intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>coef</code> </td><td style="text-align: left;"> <code><a href="#topic+coef.ppm">coef.ppm</a></code>
    </td><td style="text-align: left;"> fitted coefficients of model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>anova</code> </td><td style="text-align: left;"> <code><a href="#topic+anova.ppm">anova.ppm</a></code>
    </td><td style="text-align: left;"> Analysis of Deviance </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>formula</code> </td><td style="text-align: left;"> <code><a href="#topic+formula.ppm">formula.ppm</a></code>
    </td><td style="text-align: left;"> Extract model formula </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>terms</code> </td><td style="text-align: left;"> <code><a href="#topic+terms.ppm">terms.ppm</a></code>
    </td><td style="text-align: left;"> Terms in the model formula </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>labels</code> </td><td style="text-align: left;"> <code>labels.ppm</code>
    </td><td style="text-align: left;"> Names of estimable terms in the model formula </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>residuals</code> </td><td style="text-align: left;"> <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
    </td><td style="text-align: left;"> Point process residuals </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>simulate</code> </td><td style="text-align: left;"> <code><a href="#topic+simulate.ppm">simulate.ppm</a></code>
    </td><td style="text-align: left;"> Simulate the fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>update</code> </td><td style="text-align: left;"> <code><a href="#topic+update.ppm">update.ppm</a></code>
    </td><td style="text-align: left;"> Change or refit the model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>vcov</code> </td><td style="text-align: left;"> <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>
    </td><td style="text-align: left;"> Variance/covariance matrix of parameter estimates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>model.frame</code> </td><td style="text-align: left;"> <code><a href="#topic+model.frame.ppm">model.frame.ppm</a></code>
    </td><td style="text-align: left;"> Model frame </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>model.matrix</code> </td><td style="text-align: left;"> <code><a href="#topic+model.matrix.ppm">model.matrix.ppm</a></code>
    </td><td style="text-align: left;"> Design matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>logLik</code> </td><td style="text-align: left;"> <code><a href="#topic+logLik.ppm">logLik.ppm</a></code>
    </td><td style="text-align: left;"> log <em>pseudo</em> likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>extractAIC</code> </td><td style="text-align: left;"> <code><a href="#topic+extractAIC.ppm">extractAIC.ppm</a></code>
    </td><td style="text-align: left;"> pseudolikelihood counterpart of AIC </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>nobs</code> </td><td style="text-align: left;"> <code><a href="#topic+nobs.ppm">nobs.ppm</a></code>
    </td><td style="text-align: left;"> number of observations 
  </td>
</tr>

</table>

<p>Objects of class <code>ppm</code> can also be handled by the
following standard functions, without requiring a special method:
</p>

<table>
<tr>
 <td style="text-align: left;">
    name </td><td style="text-align: left;"> description </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="stats.html#topic+confint">confint</a></code> </td><td style="text-align: left;"> Confidence intervals for parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="stats.html#topic+step">step</a></code> </td><td style="text-align: left;"> Stepwise model selection </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="stats.html#topic+drop1">drop1</a></code> </td><td style="text-align: left;"> One-step model improvement </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="stats.html#topic+add1">add1</a></code> </td><td style="text-align: left;">  One-step model improvement
  </td>
</tr>

</table>

<p>The class <code>ppm</code> also has methods for the following
generic functions defined in the <span class="pkg">spatstat</span> package:
</p>

<table>
<tr>
 <td style="text-align: left;">
    generic </td><td style="text-align: left;"> method </td><td style="text-align: left;"> description </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.interact">as.interact</a></code> </td><td style="text-align: left;"> <code><a href="#topic+as.interact.ppm">as.interact.ppm</a></code>
    </td><td style="text-align: left;"> Interpoint interaction structure </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code> </td><td style="text-align: left;"> <code><a href="#topic+as.owin.ppm">as.owin.ppm</a></code>
    </td><td style="text-align: left;"> Observation window of data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.explore.html#topic+berman.test">berman.test</a></code> </td><td style="text-align: left;"> <code><a href="#topic+berman.test.ppm">berman.test.ppm</a></code>
    </td><td style="text-align: left;"> Berman's test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="boot.html#topic+envelope">envelope</a></code> </td><td style="text-align: left;"> <code><a href="#topic+envelope.ppm">envelope.ppm</a></code>
    </td><td style="text-align: left;"> Simulation envelopes </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitin">fitin</a></code> </td><td style="text-align: left;"> <code><a href="#topic+fitin.ppm">fitin.ppm</a></code>
    </td><td style="text-align: left;"> Fitted interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.geom.html#topic+is.marked">is.marked</a></code> </td><td style="text-align: left;"> <code><a href="#topic+is.marked.ppm">is.marked.ppm</a></code>
    </td><td style="text-align: left;"> Determine whether the model is marked </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.geom.html#topic+is.multitype">is.multitype</a></code> </td><td style="text-align: left;"> <code><a href="#topic+is.multitype.ppm">is.multitype.ppm</a></code>
    </td><td style="text-align: left;"> Determine whether the model is multitype </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+is.poisson">is.poisson</a></code> </td><td style="text-align: left;"> <code><a href="#topic+is.poisson.ppm">is.poisson.ppm</a></code>
    </td><td style="text-align: left;"> Determine whether the model is Poisson </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+is.stationary">is.stationary</a></code> </td><td style="text-align: left;"> <code><a href="#topic+is.stationary.ppm">is.stationary.ppm</a></code>
    </td><td style="text-align: left;"> Determine whether the model is stationary </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code> </td><td style="text-align: left;"> <code><a href="#topic+cdf.test.ppm">cdf.test.ppm</a></code>
    </td><td style="text-align: left;"> Spatial distribution test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code> </td><td style="text-align: left;"> <code><a href="#topic+quadrat.test.ppm">quadrat.test.ppm</a></code>
    </td><td style="text-align: left;"> Quadrat counting test </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+reach">reach</a></code> </td><td style="text-align: left;"> <code><a href="#topic+reach.ppm">reach.ppm</a></code>
    </td><td style="text-align: left;"> Interaction range of model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rmhmodel">rmhmodel</a></code> </td><td style="text-align: left;"> <code><a href="#topic+rmhmodel.ppm">rmhmodel.ppm</a></code>
    </td><td style="text-align: left;"> Model in a form that can be simulated </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rmh">rmh</a></code> </td><td style="text-align: left;"> <code><a href="#topic+rmh.ppm">rmh.ppm</a></code>
    </td><td style="text-align: left;"> Perform simulation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.geom.html#topic+unitname">unitname</a></code> </td><td style="text-align: left;"> <code><a href="#topic+unitname.ppm">unitname.ppm</a></code>
    </td><td style="text-align: left;"> Name of unit of length
    </td>
</tr>

</table>

<p>Information about the data (to which the model was fitted)
can be extracted using <code><a href="#topic+data.ppm">data.ppm</a></code>, <code><a href="#topic+dummy.ppm">dummy.ppm</a></code>
and <code><a href="#topic+quad.ppm">quad.ppm</a></code>.
</p>


<h3>Internal format</h3>

<p>If you really need to get at the internals,
a <code>ppm</code> object contains at least the following entries:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>coef</code> </td><td style="text-align: left;">  the fitted regular parameters (as returned by
                     <code>glm</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>trend</code> </td><td style="text-align: left;">  the trend formula or <code>NULL</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>interaction</code> </td><td style="text-align: left;"> the point process interaction family 
                        (an object of class <code>"interact"</code>)
			or <code>NULL</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>Q</code> </td><td style="text-align: left;">      the quadrature scheme used </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>maxlogpl</code> </td><td style="text-align: left;"> the maximised value of log pseudolikelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>correction</code> </td><td style="text-align: left;">  name of edge correction method used </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>See <code><a href="#topic+ppm">ppm</a></code> for explanation of these concepts.
The irregular parameters (e.g. the interaction radius of the
Strauss process) are encoded in the <code>interaction</code> entry.
However see the Warnings.
</p>


<h3>Warnings</h3>

<p>The internal representation of <code>ppm</code> objects
may change slightly between releases of the <span class="pkg">spatstat</span> package.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+coef.ppm">coef.ppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="#topic+print.ppm">print.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ x, Strauss(0.1), correction="periodic")
  fit
  coef(fit)
  
    pred &lt;- predict(fit)
  
  pred &lt;- predict(fit, ngrid=20, type="trend")
  if(interactive()) {
  plot(fit)
  }  
</code></pre>

<hr>
<h2 id='ppm.ppp'>
Fit Point Process Model to Point Pattern Data
</h2><span id='topic+ppm.ppp'></span><span id='topic+ppm.quad'></span>

<h3>Description</h3>

<p>Fits a point process model to an observed point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'ppp'
ppm(Q, trend=~1, interaction=Poisson(),
       ...,
       covariates=data,
       data=NULL,
       covfunargs = list(),
       subset,
       clipwin,
       correction="border",
       rbord=reach(interaction),
       use.gam=FALSE,
       method=c("mpl", "logi", "VBlogi"),
       forcefit=FALSE,
       improve.type = c("none", "ho", "enet"),
       improve.args=list(),
       emend=project,
       project=FALSE,
       prior.mean = NULL,
       prior.var = NULL,
       nd = NULL,
       eps = NULL,
       gcontrol=list(),
       nsim=100, nrmh=1e5, start=NULL, control=list(nrep=nrmh),
       verb=TRUE,
       callstring=NULL)

   ## S3 method for class 'quad'
ppm(Q, trend=~1, interaction=Poisson(),
       ...,
       covariates=data,
       data=NULL,
       covfunargs = list(),
       subset,
       clipwin,
       correction="border",
       rbord=reach(interaction),
       use.gam=FALSE,
       method=c("mpl", "logi", "VBlogi"),
       forcefit=FALSE,
       improve.type = c("none", "ho", "enet"),
       improve.args=list(),
       emend=project,
       project=FALSE,
       prior.mean = NULL,
       prior.var = NULL,
       nd = NULL,
       eps = NULL,
       gcontrol=list(),
       nsim=100, nrmh=1e5, start=NULL, control=list(nrep=nrmh),
       verb=TRUE,
       callstring=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppm.ppp_+3A_q">Q</code></td>
<td>

<p>A data point pattern (of class <code>"ppp"</code>)
to which the model will be fitted,
or a quadrature scheme (of class <code>"quad"</code>)
containing this pattern.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_trend">trend</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> formula object specifying the spatial trend to be fitted. 
The default formula, <code>~1</code>, indicates the model is stationary
and no trend is to be fitted. 
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_interaction">interaction</code></td>
<td>

<p>An object of class <code>"interact"</code>
describing the point process interaction
structure, or a function that makes such an object,
or <code>NULL</code> indicating that a Poisson process (stationary
or nonstationary) should be fitted.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_data">data</code>, <code id="ppm.ppp_+3A_covariates">covariates</code></td>
<td>

<p>The values of any spatial covariates (other than the Cartesian
coordinates) required by the model.
Either a data frame, or a list whose entries are images,
functions, windows, tessellations or single numbers. See Details.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_subset">subset</code></td>
<td>

<p>Optional.
An expression (which may involve the names of the
Cartesian coordinates <code>x</code> and <code>y</code>
and the names of entries in <code>data</code>)
defining a subset of the spatial domain,
to which the likelihood or pseudolikelihood should be restricted.
See Details.
The result of evaluating the expression should be either a logical
vector, or a window (object of class <code>"owin"</code>)
or a logical-valued pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_clipwin">clipwin</code></td>
<td>

<p>Optional. A spatial window (object of class <code>"owin"</code>)
to which data will be restricted, before model-fitting
is performed. See Details.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_covfunargs">covfunargs</code></td>
<td>

<p>A named list containing the values of any additional arguments
required by covariate functions.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_correction">correction</code></td>
<td>

<p>The name of the edge correction to be used. The default 
is <code>"border"</code> indicating the border correction.
Other possibilities may include <code>"Ripley"</code>, <code>"isotropic"</code>,
<code>"periodic"</code>, <code>"translate"</code> and <code>"none"</code>, depending on the 
<code>interaction</code>.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_rbord">rbord</code></td>
<td>

<p>If <code>correction = "border"</code>
this argument specifies the distance by which
the window should be eroded for the border correction.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_use.gam">use.gam</code></td>
<td>

<p>Logical flag; if <code>TRUE</code> then computations are performed
using <code>gam</code> instead of <code><a href="stats.html#topic+glm">glm</a></code>.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_method">method</code></td>
<td>

<p>String (partially matched) specifying the method used to fit the
model. Options are 
<code>"mpl"</code> for the method of Maximum PseudoLikelihood (the default),
<code>"logi"</code> for the Logistic Likelihood method and
<code>"VBlogi"</code> for the Variational Bayes Logistic Likelihood method.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_forcefit">forcefit</code></td>
<td>

<p>Logical flag for internal use.
If <code>forcefit=FALSE</code>, some trivial models will be
fitted by a shortcut. If <code>forcefit=TRUE</code>,
the generic fitting method will always be used. 
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_improve.type">improve.type</code></td>
<td>

<p>String (partially matched) specifying a method for improving the
initial fit. 
If <code>improve.type = "none"</code> (the default), no improvement is
performed. If <code>improve.type="ho"</code>, the Huang-Ogata approximate
maximum likelihood method is used. If <code>improve.type="enet"</code>,
the model coefficients are re-estimated using a regularized version
of the composite likelihood.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_improve.args">improve.args</code></td>
<td>

<p>Arguments used to control the algorithm
for improving the initial fit. See Details.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_emend">emend</code>, <code id="ppm.ppp_+3A_project">project</code></td>
<td>

<p>(These are equivalent: <code>project</code> is an older name for
<code>emend</code>.)
Logical value. Setting <code>emend=TRUE</code> will ensure that the
fitted model is always a valid point process by
applying <code><a href="#topic+emend.ppm">emend.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_prior.mean">prior.mean</code></td>
<td>

<p>Optional vector of prior means for canonical parameters (for
<code>method="VBlogi"</code>). See Details.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_prior.var">prior.var</code></td>
<td>

<p>Optional prior variance covariance matrix for canonical parameters (for <code>method="VBlogi"</code>). See Details.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_nd">nd</code></td>
<td>

<p>Optional. Integer or pair of integers.
The dimension of the grid of dummy points (<code>nd * nd</code>
or <code>nd[1] * nd[2]</code>)
used to evaluate the integral in the pseudolikelihood.
Incompatible with <code>eps</code>.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_eps">eps</code></td>
<td>

<p>Optional. 
A positive number, or a vector of two positive numbers, giving the
horizontal and vertical spacing, respectively, of the grid of
dummy points. Incompatible with <code>nd</code>.
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_gcontrol">gcontrol</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>
(or passed to <code><a href="mgcv.html#topic+gam.control">gam.control</a></code> if <code>use.gam=TRUE</code>)
controlling the model-fitting algorithm. 
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations
to generate (for <code>improve.type="ho"</code>)
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_nrmh">nrmh</code></td>
<td>

<p>Number of Metropolis-Hastings iterations
for each simulated realisation (for <code>improve.type="ho"</code>)
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_start">start</code>, <code id="ppm.ppp_+3A_control">control</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.random.html#topic+rmh">rmh</a></code> controlling the behaviour
of the Metropolis-Hastings algorithm (for <code>improve.type="ho"</code>)
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_verb">verb</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
(for <code>improve.type="ho"</code>)
</p>
</td></tr>
<tr><td><code id="ppm.ppp_+3A_callstring">callstring</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>NOTE:</b> This help page describes the <b>old syntax</b> of the
function <code>ppm</code>, described in many older documents.
This old syntax is still supported. However, if you are learning about
<code>ppm</code> for the first time, we recommend you use the
<b>new syntax</b> described in the help file for <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>This function fits a point process model
to an observed point pattern.
The model may include
spatial trend, interpoint interaction, and dependence on covariates.
</p>

<dl>
<dt>basic use:</dt><dd>
<p>In basic use, <code>Q</code> is a point pattern dataset
(an object of class <code>"ppp"</code>) to which we wish to fit a model.
</p>
<p>The syntax of <code>ppm()</code> is closely analogous to the <span class="rlang"><b>R</b></span> functions
<code><a href="stats.html#topic+glm">glm</a></code> and <code>gam</code>.
The analogy is:
</p>

<table>
<tr>
 <td style="text-align: left;">
	<b>glm</b> </td><td style="text-align: left;"> <b>ppm</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>formula</code> </td><td style="text-align: left;"> <code>trend</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>family</code> </td><td style="text-align: left;"> <code>interaction</code>
      </td>
</tr>

</table>

<p>The point process model to be fitted is specified by the 
arguments <code>trend</code> and <code>interaction</code>
which are respectively analogous to
the <code>formula</code> and <code>family</code> arguments of glm(). 
</p>
<p>Systematic effects (spatial trend and/or dependence on 
spatial covariates) are specified by the argument
<code>trend</code>. This is an <span class="rlang"><b>R</b></span> formula object, which may be expressed
in terms of the Cartesian coordinates <code>x</code>, <code>y</code>,
the marks <code>marks</code>,
or the variables in <code>covariates</code> (if supplied), or both.
It specifies the <b>logarithm</b> of the first order potential
of the process.
The formula should not use any names beginning with <code>.mpl</code>
as these are reserved for internal use.
If <code>trend</code> is absent or equal to the default, <code>~1</code>, then
the model to be fitted is stationary (or at least, its first order 
potential is constant). 
</p>
<p>The symbol <code>.</code> in the trend expression stands for
all the covariates supplied in the argument <code>data</code>.
For example the formula <code>~ .</code> indicates an additive
model with a main effect for each covariate in <code>data</code>.
</p>
<p>Stochastic interactions between random points of the point process
are defined by the argument <code>interaction</code>. This is an object of
class <code>"interact"</code> which is initialised in a very similar way to the
usage of family objects in <code><a href="stats.html#topic+glm">glm</a></code> and <code>gam</code>.
The models currently available are:
<code><a href="#topic+AreaInter">AreaInter</a></code>, <code><a href="#topic+BadGey">BadGey</a></code>, <code><a href="#topic+Concom">Concom</a></code>, <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="#topic+Fiksel">Fiksel</a></code>, <code><a href="#topic+Geyer">Geyer</a></code>, <code><a href="#topic+Hardcore">Hardcore</a></code>, <code><a href="#topic+HierHard">HierHard</a></code>, <code><a href="#topic+HierStrauss">HierStrauss</a></code>, <code><a href="#topic+HierStraussHard">HierStraussHard</a></code>, <code><a href="#topic+Hybrid">Hybrid</a></code>, <code><a href="#topic+LennardJones">LennardJones</a></code>, <code><a href="#topic+MultiHard">MultiHard</a></code>, <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="#topic+OrdThresh">OrdThresh</a></code>, <code><a href="#topic+Ord">Ord</a></code>, <code><a href="#topic+Pairwise">Pairwise</a></code>, <code><a href="#topic+PairPiece">PairPiece</a></code>, <code><a href="#topic+Penttinen">Penttinen</a></code>, <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Saturated">Saturated</a></code>, <code><a href="#topic+SatPiece">SatPiece</a></code>, <code><a href="#topic+Softcore">Softcore</a></code>, <code><a href="#topic+Strauss">Strauss</a></code>, <code><a href="#topic+StraussHard">StraussHard</a></code> and <code><a href="#topic+Triplets">Triplets</a></code>.
See the examples below.
It is also possible to combine several interactions
using <code><a href="#topic+Hybrid">Hybrid</a></code>.
</p>
<p>If <code>interaction</code> is missing or <code>NULL</code>,
then the model to be fitted
has no interpoint interactions, that is, it is a Poisson process
(stationary or nonstationary according to <code>trend</code>). In this case
the methods of maximum pseudolikelihood and maximum logistic likelihood
coincide with maximum likelihood. 
</p>
<p>The fitted point process model returned by this function can be printed 
(by the print method <code><a href="#topic+print.ppm">print.ppm</a></code>)
to inspect the fitted parameter values.
If a nonparametric spatial trend was fitted, this can be extracted using
the predict method <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
</p>
</dd>
<dt>Models with covariates:</dt><dd>
<p>To fit a model involving spatial covariates
other than the Cartesian coordinates <code class="reqn">x</code> and <code class="reqn">y</code>,
the values of the covariates should be supplied in the
argument <code>covariates</code>. 
Note that it is not sufficient to have observed
the covariate only at the points of the data point pattern; 
the covariate must also have been observed at other 
locations in the window.
</p>
<p>Typically the argument <code>covariates</code> is a list,
with names corresponding to variables in the <code>trend</code> formula.
Each entry in the list is either
</p>

<dl>
<dt>a pixel image,</dt><dd>
<p>giving the values of a spatial covariate at 
a fine grid of locations. It should be an object of
class <code>"im"</code>, see <code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>.
</p>
</dd>
<dt>a function,</dt><dd>
<p>which can be evaluated
at any location <code>(x,y)</code> to obtain the value of the spatial
covariate. It should be a <code>function(x, y)</code>
or <code>function(x, y, ...)</code> in the <span class="rlang"><b>R</b></span> language.
For marked point pattern data, the covariate can be a
<code>function(x, y, marks)</code> or <code>function(x, y, marks, ...)</code>.
The first two arguments of the function should be the
Cartesian coordinates <code class="reqn">x</code> and <code class="reqn">y</code>. The function may have
additional arguments; if the function does not have default
values for these additional arguments, then the user must
supply values for them, in <code>covfunargs</code>.
See the Examples.
</p>
</dd>
<dt>a window,</dt><dd>
<p>interpreted as a logical variable
which is <code>TRUE</code> inside the window and <code>FALSE</code> outside
it. This should be an object of class <code>"owin"</code>.
</p>
</dd>
<dt>a tessellation,</dt><dd>
<p>interpreted as a factor covariate.
For each spatial location, the factor value indicates
which tile of the tessellation it belongs to.
This should be an object of class <code>"tess"</code>.
</p>
</dd>
<dt>a single number,</dt><dd><p>indicating a covariate that is
constant in this dataset.
</p>
</dd>
</dl>

<p>The software will look up
the values of each covariate at the required locations
(quadrature points).
</p>
<p>Note that, for covariate functions, only the <em>name</em> of the
function appears in the trend formula. A covariate function is
treated as if it were a single variable. The function arguments do not
appear in the trend formula. See the Examples.
</p>
<p>If <code>covariates</code> is a list,
the list entries should have names corresponding to
the names of covariates in the model formula <code>trend</code>.
The variable names <code>x</code>, <code>y</code> and <code>marks</code>
are reserved for the Cartesian 
coordinates and the mark values,
and these should not be used for variables in <code>covariates</code>.
</p>
<p>If <code>covariates</code> is a data frame, <code>Q</code> must be a
quadrature scheme (see under Quadrature Schemes below).
Then <code>covariates</code> must have
as many rows as there are points in <code>Q</code>.
The <code class="reqn">i</code>th row of <code>covariates</code> should contain the values of
spatial variables which have been observed
at the <code class="reqn">i</code>th point of <code>Q</code>. 
</p>
</dd>
<dt>Quadrature schemes:</dt><dd>
<p>In advanced use, <code>Q</code> may be a &lsquo;quadrature scheme&rsquo;.
This was originally just a technicality but it has turned out
to have practical uses, as we explain below.
</p>
<p>Quadrature schemes are required for our implementation of
the method of maximum pseudolikelihood.
The definition of the pseudolikelihood involves an integral over
the spatial window containing the data. In practice this integral
must be approximated by a finite sum over a set of quadrature points.
We use the technique of Baddeley and Turner (2000), a generalisation
of the Berman-Turner (1992) device. In this technique the quadrature
points for the numerical approximation include all the data points
(points of the observed point pattern) as well as
additional &lsquo;dummy&rsquo; points. 
</p>
<p>Quadrature schemes are also required for 
the method of maximum logistic likelihood, which
combines the data points with additional &lsquo;dummy&rsquo; points.
</p>
<p>A quadrature scheme is an object of class <code>"quad"</code>
(see <code><a href="spatstat.geom.html#topic+quad.object">quad.object</a></code>)
which specifies both the data point pattern and the dummy points
for the quadrature scheme, as well as the quadrature weights
associated with these points.
If <code>Q</code> is simply a point pattern
(of class <code>"ppp"</code>, see <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>)
then it is interpreted as specifying the
data points only; a set of dummy points specified
by <code><a href="spatstat.geom.html#topic+default.dummy">default.dummy</a>()</code> is added,
and the default weighting rule is
invoked to compute the quadrature weights.
</p>
<p>Finer quadrature schemes (i.e. those with more dummy
points) generally yield a better approximation, at the
expense of higher computational load. 
</p>
<p>An easy way to fit models using a finer quadrature scheme
is to let <code>Q</code> be the original point pattern data,
and use the argument <code>nd</code>
to determine the number of dummy points in the quadrature scheme.
</p>
<p>Complete control over the quadrature scheme is possible.
See <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code> for an overview.
Use <code>quadscheme(X, D, method="dirichlet")</code> to compute
quadrature weights based on the Dirichlet tessellation,
or <code>quadscheme(X, D, method="grid")</code> to compute
quadrature weights by counting points in grid squares,
where <code>X</code> and <code>D</code> are the patterns of data points
and dummy points respectively.
Alternatively use <code><a href="spatstat.geom.html#topic+pixelquad">pixelquad</a></code> to make a quadrature
scheme with a dummy point at every pixel in a pixel image.
</p>
<p>A practical advantage of quadrature schemes arises when we want to fit
a model involving covariates (e.g. soil pH). Suppose we have only been
able to observe the covariates at a small number of locations.
Suppose <code>cov.dat</code> is a data frame containing the values of
the covariates at the data points (i.e.\ <code>cov.dat[i,]</code>
contains the observations for the <code>i</code>th data point)
and <code>cov.dum</code> is another data frame (with the same columns as
<code>cov.dat</code>) containing the covariate values at another
set of points whose locations are given by the point pattern <code>Y</code>.
Then setting <code>Q = quadscheme(X,Y)</code> combines the data points
and dummy points into a quadrature scheme, and 
<code>covariates = rbind(cov.dat, cov.dum)</code> combines the covariate
data frames. We can then fit the model by calling
<code>ppm(Q, ..., covariates)</code>.
</p>
</dd>
<dt>Model-fitting technique:</dt><dd>
<p>There are several choices for the technique used
to fit the model.
</p>

<dl>
<dt>method=&quot;mpl&quot;</dt><dd>
<p>(the default):
the model will be fitted by maximising the 
pseudolikelihood (Besag, 1975) using the
Berman-Turner computational approximation
(Berman and Turner, 1992; Baddeley and Turner, 2000).
Maximum pseudolikelihood is equivalent to maximum likelihood
if the model is a Poisson process. 
Maximum pseudolikelihood is biased if the
interpoint interaction is very strong, unless there
is a large number of dummy points.
The default settings for <code>method='mpl'</code>
specify a moderately large number of dummy points,
striking a compromise between speed and accuracy.
</p>
</dd>
<dt>method=&quot;logi&quot;:</dt><dd>
<p>the model will be fitted by maximising the 
logistic likelihood (Baddeley et al, 2014).
This technique is roughly equivalent in speed to
maximum pseudolikelihood, but is 
believed to be less biased. Because it is less biased,
the default settings for <code>method='logi'</code>
specify a relatively small number of dummy points,
so that this method is the fastest, in practice.
</p>
</dd>
<dt>method=&quot;VBlogi&quot;:</dt><dd>	  
<p>the model will be fitted in a Bayesian setup by maximising the
posterior probability density for the canonical model
parameters. This uses the variational Bayes approximation to
the posterior derived from the logistic likelihood as described
in Rajala (2014). The prior is assumed to be multivariate
Gaussian with mean vector <code>prior.mean</code> and variance-covariance
matrix <code>prior.var</code>.	  
</p>
</dd>
</dl>

<p>Note that <code>method='logi'</code> and <code>method='VBlogi'</code>
involve randomisation, so that the results are
subject to random variation.
</p>
<p>After this initial fit, there are several ways to improve the fit:
</p>

<dl>
<dt>improve.type=&quot;none&quot;:</dt><dd>
<p>No further improvement is performed.
</p>
</dd>
<dt>improve.type=&quot;ho&quot;:</dt><dd>
<p>the model will be re-fitted
by applying the approximate maximum likelihood
method of Huang and Ogata (1999). See below.
The Huang-Ogata method is slower than the other options,
but has better statistical properties.
This method involves randomisation, so the results are subject
to random variation.
</p>
</dd>
<dt>improve.type=&quot;enet&quot;:</dt><dd>
<p>The model will be re-fitted using a regularized version of the
composite likelihood. See below.
</p>
</dd>
</dl>

</dd>
<dt>Huang-Ogata method:</dt><dd>
<p>If <code>improve.type="ho"</code> then the model will be fitted using
the Huang-Ogata (1999) approximate maximum likelihood method.
First the model is fitted by maximum pseudolikelihood as
described above, yielding an initial estimate of the parameter
vector <code class="reqn">\theta_0</code>.
From this initial model, <code>nsim</code> simulated
realisations are generated. The score and Fisher information of
the model at <code class="reqn">\theta=\theta_0</code>
are estimated from the simulated realisations. Then one step
of the Fisher scoring algorithm is taken, yielding an updated
estimate <code class="reqn">\theta_1</code>. The corresponding model is
returned.
</p>
<p>Simulated realisations are generated using <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
The iterative behaviour of the Metropolis-Hastings algorithm
is controlled by the arguments <code>start</code> and <code>control</code>
which are passed to <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
</p>
<p>As a shortcut, the argument
<code>nrmh</code> determines the number of Metropolis-Hastings
iterations run to produce one simulated realisation (if
<code>control</code> is absent). Also
if <code>start</code> is absent or equal to <code>NULL</code>, it defaults to
<code>list(n.start=N)</code> where <code>N</code> is the number of points
in the data point pattern.
</p>
</dd>
<dt>Regularization:</dt><dd>
<p>This requires the package <span class="pkg">glmnet</span>. 
<b>Details to be written.</b>
</p>
</dd>
<dt>Edge correction</dt><dd>
<p>Edge correction should be applied to the sufficient statistics
of the model, to reduce bias.
The argument <code>correction</code> is the name of an edge correction
method.
The default <code>correction="border"</code> specifies the border correction,
in which the quadrature window (the domain of integration of the 
pseudolikelihood) is obtained by trimming off a margin of width
<code>rbord</code> from the observation window of the data pattern.
Not all edge corrections are implemented (or implementable)
for arbitrary windows.
Other options depend on the argument <code>interaction</code>, but these
generally include <code>correction="periodic"</code> (the periodic or toroidal edge
correction in which opposite edges of a rectangular window are
identified) and <code>correction="translate"</code> (the translation correction,
see Baddeley 1998 and Baddeley and Turner 2000).
For pairwise interaction models
there is also Ripley's isotropic correction,
identified by <code>correction="isotropic"</code> or <code>"Ripley"</code>.
</p>
</dd>
<dt>Subsetting</dt><dd>
<p>The arguments <code>subset</code> and <code>clipwin</code> specify that the
model should be fitted to a restricted subset of the available
data. These arguments are equivalent for Poisson point process models,
but different for Gibbs models.
If <code>clipwin</code> is specified, then all the available data will
be restricted to this spatial region, and data outside this region
will be discarded, before the model is fitted.
If <code>subset</code> is specified, then no data are deleted, but
the domain of integration of the likelihood or pseudolikelihood
is restricted to the <code>subset</code>.
For Poisson models, these two arguments have the same effect;
but for a Gibbs model, 
interactions between points inside and outside the <code>subset</code>
are taken into account, while
interactions between points inside and outside the <code>clipwin</code>
are ignored.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>"ppm"</code> describing a fitted point process
model.
</p>
<p>See <code><a href="#topic+ppm.object">ppm.object</a></code> for details of the format of this object
and methods available for manipulating it.
</p>


<h3>Interaction parameters</h3>

<p>Apart from the Poisson model, every point process model fitted by
<code>ppm</code> has parameters that determine the strength and
range of &lsquo;interaction&rsquo; or dependence between points.
These parameters are of two types:
</p>

<dl>
<dt>regular parameters:</dt><dd>
<p>A parameter <code class="reqn">\phi</code> is called <em>regular</em>
if the log likelihood is a linear function of <code class="reqn">\theta</code> where 
<code class="reqn">\theta = \theta(\psi)</code> is some transformation of 
<code class="reqn">\psi</code>. [Then <code class="reqn">\theta</code> is called the canonical
parameter.]
</p>
</dd>
<dt>irregular parameters</dt><dd>
<p>Other parameters are called <em>irregular</em>. 
</p>
</dd>
</dl>

<p>Typically, regular parameters determine the &lsquo;strength&rsquo;
of the interaction, while irregular parameters determine the
&lsquo;range&rsquo; of the interaction. For example, the Strauss process
has a regular parameter <code class="reqn">\gamma</code> controlling the strength
of interpoint inhibition, and an irregular parameter <code class="reqn">r</code>
determining the range of interaction.
</p>
<p>The <code>ppm</code> command is only designed to estimate regular
parameters of the interaction.
It requires the values of any irregular parameters of the interaction
to be fixed. For example, to fit a Strauss process model to the <code>cells</code>
dataset, you could type <code>ppm(cells, ~1, Strauss(r=0.07))</code>.
Note that the value of the irregular parameter <code>r</code> must be given.
The result of this command will be a fitted model in which the
regular parameter <code class="reqn">\gamma</code> has been estimated.
</p>
<p>To determine the irregular parameters, there are several
practical techniques, but no general statistical theory available.
Useful techniques include maximum profile pseudolikelihood, which
is implemented in the command <code><a href="#topic+profilepl">profilepl</a></code>,
and Newton-Raphson maximisation, implemented in the
experimental command <code><a href="#topic+ippm">ippm</a></code>. 
</p>
<p>Some irregular parameters can be estimated directly from data:
the hard-core radius in the model <code><a href="#topic+Hardcore">Hardcore</a></code>
and the matrix of hard-core radii in <code><a href="#topic+MultiHard">MultiHard</a></code> can be
estimated easily from data. In these cases, <code>ppm</code> allows the user
to specify the interaction without giving
the value of the irregular parameter. The user can give the
hard core interaction as <code>interaction=Hardcore()</code>
or even <code>interaction=Hardcore</code>, and 
the hard core radius will then be estimated from the data.
</p>


<h3>Error and Warning Messages</h3>

<p>Some common error messages and warning messages 
are listed below, with explanations.
</p>

<dl>
<dt>&ldquo;Model is invalid&rdquo; or &ldquo;Model is not valid&rdquo;</dt><dd>
<p>The fitted model coefficients do not define a valid point
process. This can occur because some of the fitted coefficients
are <code>NA</code> (perhaps because the model formula included redundant
covariates so that the coefficients cannot be estimated), or
because the fitted interaction coefficients do not define
a valid point process (e.g. because a point process
model which always has inhibition between points was fitted to a
clustered point pattern). See <code><a href="#topic+valid.ppm">valid.ppm</a></code> for detailed
information. 
</p>
</dd>
<dt>&ldquo;System is computationally singular&rdquo; or
&ldquo;Fisher information matrix is singular&rdquo;</dt><dd>
<p>The software cannot calculate standard errors or confidence
intervals for the coefficients of the fitted model.
This requires the (asymptotic) variance-covariance
matrix, which is the inverse matrix of the Fisher information
matrix of the fitted model. The error message states
that the determinant of the Fisher information matrix is zero,
or close to zero, so that the matrix cannot be inverted.
This error is usually reported when the model is printed,
because the <code>print</code> method calculates standard errors for the
fitted parameters. Singularity usually occurs because the spatial
coordinates in the original data were very large numbers
(e.g. expressed in metres) so that the fitted coefficients were
very small numbers. The simple remedy is to
<b>rescale the data</b>, for example, to convert from metres to
kilometres by <code>X &lt;- <a href="spatstat.geom.html#topic+rescale">rescale</a>(X, 1000)</code>, then re-fit the
model. Singularity can also occur if the covariate values are
very large numbers, or if the covariates are approximately
collinear.       
</p>
</dd>
<dt>&ldquo;Covariate values were NA or undefined at X%
(M out of N) of the quadrature points&rdquo;</dt><dd>
<p>The covariate data (typically a pixel image) did not provide
values of the covariate at some of the spatial locations in the 
observation window of the point pattern. This means that the
spatial domain of the pixel image does not completely cover the
observation window of the point pattern. If the percentage
is small, this warning can be ignored - typically it happens
because of rounding effects which cause the pixel image
to be one-pixel-width narrower than the observation window.
However if more than a few percent of covariate values are
undefined, it would be prudent to check that the pixel images
are correct, and are correctly registered in their spatial relation to
the observation window.
</p>
</dd>
<dt>&ldquo;Some tiles with positive area do not contain any
quadrature points: relative error = X%&rdquo;</dt><dd>
<p>A problem has arisen when creating the quadrature scheme
used to fit the model. In the default rule for computing the
quadrature weights, space is divided into rectangular tiles,
and the number of quadrature points (data and dummy points) in
each tile is counted. It is possible for a tile with non-zero area
to contain no quadrature points; in this case, the quadrature
scheme will contribute a bias to the model-fitting procedure.
<b>A small relative error (less than 2 percent) is not	important.</b>
Relative errors of a few percent can occur because of the shape of
the window.
If the relative error is greater than about 5 percent, we
recommend trying different parameters for the quadrature scheme,
perhaps setting a larger value of <code>nd</code> to increase the number
of dummy points. A relative error greater than 10 percent
indicates a major problem with the input data: in this case,
extract the quadrature scheme by applying <code><a href="#topic+quad.ppm">quad.ppm</a></code>
to the fitted model, and inspect it. 
(The most likely cause of this problem is that the spatial coordinates
of the original data were not handled correctly, for example,
coordinates of the locations and the window boundary were incompatible.)
</p>
</dd>
<dt>&ldquo;Model is unidentifiable&rdquo;</dt><dd>
<p>It is not possible to estimate all the model parameters
from this dataset. The error message gives a further explanation,
such as &ldquo;data pattern is empty&rdquo;.
Choose a simpler model, or check the data.
</p>
</dd>
<dt>&ldquo;N data points are illegal (zero conditional intensity)&rdquo;</dt><dd>
<p>In a Gibbs model (i.e. with interaction between
points), the conditional intensity may be zero at some spatial
locations, indicating that the model forbids the presence of a 
point at these locations. However if the conditional intensity is
zero <em>at a data point</em>, this means that the model is
inconsistent with the data. Modify the interaction parameters so
that the data point is not illegal (e.g. reduce the value of the
hard core radius) or choose a different interaction.
</p>
</dd>
</dl>



<h3>Warnings</h3>

<p>The implementation of the Huang-Ogata method is experimental;
several bugs were fixed in <span class="pkg">spatstat</span> 1.19-0.
</p>
<p>See the comments above about the possible inefficiency
and bias of the maximum pseudolikelihood estimator.
</p>
<p>The accuracy of the Berman-Turner approximation to
the pseudolikelihood depends on the number of dummy points used
in the quadrature scheme. The number of dummy points should 
at least equal the number of data points.
</p>
<p>The parameter values of the fitted model
do not necessarily determine a valid point process.
Some of the point process models are only defined when the parameter
values lie in a certain subset. For example the Strauss process only 
exists when the interaction parameter <code class="reqn">\gamma</code>
is less than or equal to <code class="reqn">1</code>,
corresponding to a value of <code>ppm()$theta[2]</code>
less than or equal to <code>0</code>.
</p>
<p>By default (if <code>emend=FALSE</code>) the algorithm
maximises the pseudolikelihood
without constraining the parameters, and does not apply any checks for
sanity after fitting the model.
This is because the fitted parameter value
could be useful information for data analysis.
To constrain the parameters to ensure that the model is a valid
point process, set <code>emend=TRUE</code>. See also the functions
<code><a href="#topic+valid.ppm">valid.ppm</a></code> and <code><a href="#topic+emend.ppm">emend.ppm</a></code>.
</p>
<p>The <code>trend</code> formula should not use any variable names
beginning with the prefixes <code>.mpl</code> or <code>Interaction</code>
as these names are reserved
for internal use. The data frame <code>covariates</code> should have as many rows
as there are points in <code>Q</code>. It should not contain
variables called <code>x</code>, <code>y</code> or <code>marks</code>
as these names are reserved for the Cartesian coordinates
and the marks.
</p>
<p>If the model formula involves one of the functions
<code>poly()</code>, <code>bs()</code>
or <code>ns()</code>
(e.g. applied to spatial coordinates <code>x</code> and <code>y</code>),
the fitted coefficients can be misleading.
The resulting fit is not to the raw spatial variates
(<code>x</code>, <code>x^2</code>, <code>x*y</code>, etc.) 
but to a transformation of these variates.  The transformation is implemented
by <code>poly()</code> in order to achieve better numerical stability.
However the
resulting coefficients are appropriate for use with the transformed
variates, not with the raw variates.  
This affects the interpretation of the constant
term in the fitted model, <code>logbeta</code>. 
Conventionally, <code class="reqn">\beta</code> is the background intensity, i.e. the  
value taken by the conditional intensity function when all predictors
(including spatial or &ldquo;trend&rdquo; predictors) are set equal to <code class="reqn">0</code>.
However the coefficient actually produced is the value that the
log conditional intensity takes when all the predictors, 
including the <em>transformed</em>
spatial predictors, are set equal to <code>0</code>, which is not the same thing.
</p>
<p>Worse still, the result of <code><a href="#topic+predict.ppm">predict.ppm</a></code> can be
completely wrong if the trend formula contains one of the
functions <code>poly()</code>, <code>bs()</code>
or <code>ns()</code>. This is a weakness of the underlying
function <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>. 
</p>
<p>If you wish to fit a polynomial trend, 
we offer an alternative to <code><a href="stats.html#topic+poly">poly</a>()</code>,
namely <code>polynom()</code>, which avoids the
difficulty induced by transformations.  It is completely analogous
to <code>poly</code> except that it does not orthonormalise.
The resulting coefficient estimates then have
their natural interpretation and can be predicted correctly. 
Numerical stability may be compromised.
</p>
<p>Values of the maximised pseudolikelihood are not comparable
if they have been obtained with different values of <code>rbord</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Coeurjolly, J.-F., Rubak, E. and Waagepetersen, R. (2014)
Logistic regression for spatial Gibbs point processes.
<em>Biometrika</em> <b>101</b> (2) 377&ndash;392.
</p>
<p>Baddeley, A. and Turner, R.
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> (2000) 283&ndash;322.
</p>
<p>Berman, M. and Turner, T.R. 
Approximating point process likelihoods with GLIM.
<em>Applied Statistics</em> <b>41</b> (1992) 31&ndash;38.
</p>
<p>Besag, J.
Statistical analysis of non-lattice data.
<em>The Statistician</em> <b>24</b> (1975) 179-195.
</p>
<p>Diggle, P.J., Fiksel, T., Grabarnik, P., Ogata, Y., Stoyan, D. and
Tanemura, M.
On parameter estimation for pairwise interaction processes.
<em>International Statistical Review</em> <b>62</b> (1994) 99-117.
</p>
<p>Huang, F. and Ogata, Y.
Improvements of the maximum pseudo-likelihood estimators
in various spatial statistical models.
<em>Journal of Computational and Graphical Statistics</em>
<b>8</b> (1999) 510-530.
</p>
<p>Jensen, J.L. and Moeller, M.
Pseudolikelihood for exponential family models of spatial point processes.
<em>Annals of Applied Probability</em> <b>1</b> (1991) 445&ndash;461.
</p>
<p>Jensen, J.L. and Kuensch, H.R. 
On asymptotic normality of pseudo likelihood
estimates for pairwise interaction processes,
<em>Annals of the Institute of Statistical Mathematics</em>
<b>46</b> (1994) 475-486.
</p>
<p>Rajala T. (2014)
<em>A note on Bayesian logistic regression for spatial exponential family
Gibbs point processes</em>,
Preprint on ArXiv.org. <a href="https://arxiv.org/abs/1411.0539">https://arxiv.org/abs/1411.0539</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code> for details of how to
print, plot and manipulate a fitted model.
</p>
<p><code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> and <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>
for constructing data.
</p>
<p>Interactions:
<code><a href="#topic+AreaInter">AreaInter</a></code>, <code><a href="#topic+BadGey">BadGey</a></code>, <code><a href="#topic+Concom">Concom</a></code>, <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="#topic+Fiksel">Fiksel</a></code>, <code><a href="#topic+Geyer">Geyer</a></code>, <code><a href="#topic+Hardcore">Hardcore</a></code>, <code><a href="#topic+HierHard">HierHard</a></code>, <code><a href="#topic+HierStrauss">HierStrauss</a></code>, <code><a href="#topic+HierStraussHard">HierStraussHard</a></code>, <code><a href="#topic+Hybrid">Hybrid</a></code>, <code><a href="#topic+LennardJones">LennardJones</a></code>, <code><a href="#topic+MultiHard">MultiHard</a></code>, <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="#topic+OrdThresh">OrdThresh</a></code>, <code><a href="#topic+Ord">Ord</a></code>, <code><a href="#topic+Pairwise">Pairwise</a></code>, <code><a href="#topic+PairPiece">PairPiece</a></code>, <code><a href="#topic+Penttinen">Penttinen</a></code>, <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Saturated">Saturated</a></code>, <code><a href="#topic+SatPiece">SatPiece</a></code>, <code><a href="#topic+Softcore">Softcore</a></code>, <code><a href="#topic+Strauss">Strauss</a></code>, <code><a href="#topic+StraussHard">StraussHard</a></code> and <code><a href="#topic+Triplets">Triplets</a></code>.
</p>
<p>See <code><a href="#topic+profilepl">profilepl</a></code> for advice on
fitting nuisance parameters in the interaction,
and <code><a href="#topic+ippm">ippm</a></code> for irregular parameters in the trend.
</p>
<p>See <code><a href="#topic+valid.ppm">valid.ppm</a></code> and <code><a href="#topic+emend.ppm">emend.ppm</a></code> for
ensuring the fitted model is a valid point process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # fit the stationary Poisson process
 # to point pattern 'nztrees'

 ppm(nztrees)
 ppm(nztrees ~ 1)
 # equivalent.

 Q &lt;- quadscheme(nztrees) 
 ppm(Q) 
 # equivalent.

 fit1 &lt;- ppm(nztrees, ~ x)
 # fit the nonstationary Poisson process 
 # with intensity function lambda(x,y) = exp(a + bx)
 # where x,y are the Cartesian coordinates
 # and a,b are parameters to be estimated

 # For other examples, see help(ppm)
</code></pre>

<hr>
<h2 id='ppmInfluence'>
Leverage and Influence Measures for Spatial Point Process Model
</h2><span id='topic+ppmInfluence'></span>

<h3>Description</h3>

<p>Calculates all the leverage and
influence measures described in <code><a href="#topic+influence.ppm">influence.ppm</a></code>,
<code><a href="#topic+leverage.ppm">leverage.ppm</a></code> and <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ppmInfluence(fit,
                what = c("leverage", "influence", "dfbetas"),
                ...,
                iScore = NULL, iHessian = NULL, iArgs = NULL,
                drop = FALSE,
                fitname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppmInfluence_+3A_fit">fit</code></td>
<td>

<p>A fitted point process model of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_what">what</code></td>
<td>

<p>Character vector specifying which quantities are to be calculated.
Default is to calculate all quantities.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_iscore">iScore</code>, <code id="ppmInfluence_+3A_ihessian">iHessian</code></td>
<td>

<p>Components of the score vector and Hessian matrix for
the irregular parameters, if required. See Details.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_iargs">iArgs</code></td>
<td>

<p>List of extra arguments for the functions <code>iScore</code>,
<code>iHessian</code> if required.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_drop">drop</code></td>
<td>

<p>Logical. Whether to include (<code>drop=FALSE</code>) or
exclude (<code>drop=TRUE</code>) contributions from quadrature
points that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="ppmInfluence_+3A_fitname">fitname</code></td>
<td>

<p>Optional character string name for the fitted model <code>fit</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates all the
leverage and influence measures
described in <code><a href="#topic+influence.ppm">influence.ppm</a></code>, <code><a href="#topic+leverage.ppm">leverage.ppm</a></code>
and <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>.
</p>
<p>When analysing large datasets, the user can
call <code>ppmInfluence</code> to perform the calculations efficiently,
then extract the leverage and influence values as desired.
For example the leverage can be extracted either as
<code>result$leverage</code> or <code>leverage(result)</code>.
</p>
<p>If the point process model trend has irregular parameters that were
fitted (using <code><a href="#topic+ippm">ippm</a></code>)
then the influence calculation requires the first and second
derivatives of the log trend with respect to the irregular parameters. 
The argument <code>iScore</code> should be a list,
with one entry for each irregular parameter, of <span class="rlang"><b>R</b></span> functions that compute the
partial derivatives of the log trend (i.e. log intensity or
log conditional intensity) with respect to each irregular
parameter. The argument <code>iHessian</code> should be a list,
with <code class="reqn">p^2</code> entries where <code class="reqn">p</code> is the number of irregular
parameters, of <span class="rlang"><b>R</b></span> functions that compute the second order
partial derivatives of the
log trend with respect to each pair of irregular parameters.
</p>


<h3>Value</h3>

<p>A list containing the leverage and influence measures specified by
<code>what</code>. The result also belongs to the class <code>"ppmInfluence"</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leverage.ppm">leverage.ppm</a></code>,
<code><a href="#topic+influence.ppm">influence.ppm</a></code>,
<code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X ~ x+y)
   fI &lt;- ppmInfluence(fit)

   fitlev &lt;- fI$leverage
   fitlev &lt;- leverage(fI)

   fitinf &lt;- fI$influence
   fitinf &lt;- influence(fI)

   fitdfb &lt;- fI$dfbetas
   fitdfb &lt;- dfbetas(fI) 
</code></pre>

<hr>
<h2 id='predict.dppm'>Prediction from a Fitted Determinantal Point Process Model</h2><span id='topic+predict.dppm'></span><span id='topic+fitted.dppm'></span>

<h3>Description</h3>

<p>Given a fitted determinantal point process model,
these functions compute the fitted intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
fitted(object, ...)

  ## S3 method for class 'dppm'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dppm_+3A_object">object</code></td>
<td>

<p>Fitted determinantal point process model.
An object of class <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="predict.dppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+fitted.ppm">fitted.ppm</a></code> or
<code><a href="#topic+predict.ppm">predict.ppm</a></code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic functions
<code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code>.
The argument <code>object</code> should be a determinantal point process model
(object of class <code>"dppm"</code>) obtained using
the function <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p>The <em>intensity</em> of the fitted model
is computed, using <code><a href="#topic+fitted.ppm">fitted.ppm</a></code> or
<code><a href="#topic+predict.ppm">predict.ppm</a></code> respectively.
</p>


<h3>Value</h3>

<p>The value of <code>fitted.dppm</code> is a numeric vector
giving the fitted values at the quadrature points.
</p>
<p>The value of <code>predict.dppm</code> is usually a pixel image
(object of class <code>"im"</code>), but see <code><a href="#topic+predict.ppm">predict.ppm</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>,
<code><a href="#topic+plot.dppm">plot.dppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    fit &lt;- dppm(swedishpines ~ x + y, dppGauss())
  } else {
    fit &lt;- dppm(redwood ~ x, dppGauss())
  }
  predict(fit)
</code></pre>

<hr>
<h2 id='predict.kppm'>Prediction from a Fitted Cluster Point Process Model</h2><span id='topic+predict.kppm'></span><span id='topic+fitted.kppm'></span>

<h3>Description</h3>

<p>Given a fitted cluster point process model,
these functions compute the fitted intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
fitted(object, ...)

  ## S3 method for class 'kppm'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.kppm_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model.
An object of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="predict.kppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+fitted.ppm">fitted.ppm</a></code> or
<code><a href="#topic+predict.ppm">predict.ppm</a></code> respectively.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic functions
<code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code>.
The argument <code>object</code> should be a cluster point process model
(object of class <code>"kppm"</code>) obtained using
the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The <em>intensity</em> of the fitted model
is computed, using <code><a href="#topic+fitted.ppm">fitted.ppm</a></code> or
<code><a href="#topic+predict.ppm">predict.ppm</a></code> respectively.
</p>


<h3>Value</h3>

<p>The value of <code>fitted.kppm</code> is a numeric vector
giving the fitted values at the quadrature points. 
</p>
<p>The value of <code>predict.kppm</code> is usually a pixel image
(object of class <code>"im"</code>), but see <code><a href="#topic+predict.ppm">predict.ppm</a></code>
for details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+plot.kppm">plot.kppm</a></code>,
<code><a href="#topic+vcov.kppm">vcov.kppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ x, "Thomas")
  predict(fit)
</code></pre>

<hr>
<h2 id='predict.mppm'>Prediction for Fitted Multiple Point Process Model</h2><span id='topic+predict.mppm'></span>

<h3>Description</h3>

<p>Given a fitted multiple point process model obtained by <code><a href="#topic+mppm">mppm</a></code>,
evaluate the spatial trend and/or the conditional intensity of the
model. By default, predictions are evaluated over a grid of
locations, yielding pixel images of the trend and conditional intensity.
Alternatively predictions may be evaluated at specified
locations with specified values of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppm'
predict(object, ..., newdata = NULL, type = c("trend", "cif"),
             ngrid = 40, locations=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mppm_+3A_object">object</code></td>
<td>
<p>The fitted model. An object of class <code>"mppm"</code>
obtained from <code><a href="#topic+mppm">mppm</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_newdata">newdata</code></td>
<td>

<p>Optional.
New values of the covariates, for which the predictions should be computed.
See Details.
</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_type">type</code></td>
<td>

<p>Type of predicted values required. A character string or vector of
character strings. Options are <code>"trend"</code> for the spatial trend
(first-order term) and <code>"cif"</code> or <code>"lambda"</code> for the
conditional intensity.
Alternatively <code>type="all"</code> selects all options.
</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_ngrid">ngrid</code></td>
<td>

<p>Dimensions of the grid of spatial locations at which prediction will be
performed (if <code>locations=NULL</code>). An integer or a pair of integers.
</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_locations">locations</code></td>
<td>

<p>Optional. The locations at which
predictions should be performed. A list of point patterns, with one entry
for each row of <code>newdata</code>.
</p>
</td></tr>
<tr><td><code id="predict.mppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the spatial trend and the conditional
intensity of a spatial point process model that has been fitted to
several spatial point patterns. See Chapter 16 of
Baddeley, Rubak and Turner (2015) for explanation and examples.
</p>
<p>Note that by &ldquo;spatial trend&rdquo; we mean the (exponentiated) first
order potential and not the intensity of the process. [For example
if we fit the stationary Strauss process with parameters
<code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
then the spatial trend is constant and equal to <code class="reqn">\beta</code>.]
The conditional intensity <code class="reqn">\lambda(u,X)</code> of the fitted
model is evaluated at each required spatial location u, with respect
to the response point pattern X.
</p>
<p>If <code>newdata=NULL</code>, predictions are computed for the original
values of the covariates, to which the model was fitted.
Otherwise <code>newdata</code> should be a hyperframe
(see <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>) containing columns of covariates
as required by the model. If <code>type</code> includes <code>"cif"</code>,
then <code>newdata</code> must also include a column of spatial point
pattern responses, in order to compute the conditional intensity.
</p>
<p>If <code>locations=NULL</code>, then predictions are performed
at an <code>ngrid</code> by <code>ngrid</code> grid of locations in the window
for each response point pattern. The result will be a hyperframe
containing a column of images of the trend (if selected)
and a column of images of the conditional intensity (if selected).
The result can be plotted.
</p>
<p>If <code>locations</code> is given, then it should be a list of point
patterns (objects of class <code>"ppp"</code>). Predictions are performed at these
points, and the results are returned as mark values attached to the
<code>locations</code>. The result is a hyperframe containing columns
called <code>trend</code> and/or <code>cif</code>. The column called <code>trend</code>
contains marked point patterns in which the point locations are
the <code>locations</code> and the mark value is the predicted trend.
The column called <code>cif</code>
contains marked point patterns in which the point locations are
the <code>locations</code> and the mark value is the predicted conditional
intensity.
</p>


<h3>Value</h3>

<p>A hyperframe with columns named <code>trend</code> and/or <code>cif</code>.
</p>
<p>If  <code>locations=NULL</code>, the entries of the hyperframe are
pixel images.
</p>
<p>If <code>locations</code> is not null, the entries are
marked point patterns constructed by attaching the predicted values
to the <code>locations</code> point patterns.
</p>


<h3>Models that depend on row number</h3>

<p>The point process model that is described by an <code>mppm</code> object
may be a different point process for each row of the original
hyperframe of data. This occurs if
the model formula includes the variable <code>id</code> (representing
row number) or if the model has a different interpoint interaction on
each row.
</p>
<p>If the point process model
is different on each row of the original data,
then either
</p>

<ul>
<li> <p><code>newdata</code> is missing. Predictions are computed for
each row of the original data using the point process model
that applies on each row.
</p>
</li>
<li> <p><code>newdata</code> must have the same number of rows
as the original data. Each row of <code>newdata</code> is assumed
to be a replacement for the corresponding row of the original data.
The prediction for row <code>i</code> of <code>newdata</code>
will be computed for the point process model that applies to row <code>i</code>
of the original data.
</p>
</li>
<li> <p><code>newdata</code> must include a column called <code>id</code>
specifying the row number, and therefore identifying which
of the point process models should apply.
The predictions for row <code>i</code>
of <code>newdata</code> will be computed for the point process model that applies
to row <code>k</code> of the original data, where <code>k = newdata$id[i]</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R.
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> (2000) 283&ndash;322.
</p>
<p>Baddeley, A., Bischof, L., Sintorn, I.-M., Haggarty, S.,
Bell, M. and Turner, R. 
Analysis of a designed experiment where the response is a spatial
point pattern. In preparation.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="#topic+fitted.mppm">fitted.mppm</a></code>,
<code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  h &lt;- hyperframe(Bugs=waterstriders)
  fit &lt;- mppm(Bugs ~ x, data=h, interaction=Strauss(7))
  # prediction on a grid
  p &lt;- predict(fit)
  plot(p$trend)
  # prediction at specified locations
  loc &lt;- with(h, runifpoint(20, Window(Bugs)))
  p2 &lt;- predict(fit, locations=loc)
  plot(p2$trend)
</code></pre>

<hr>
<h2 id='predict.ppm'>Prediction from a Fitted Point Process Model</h2><span id='topic+predict.ppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model obtained by <code><a href="#topic+ppm">ppm</a></code>,	
evaluate the spatial trend or the conditional intensity of the model
at new locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'ppm'
predict(object, window=NULL, ngrid=NULL, locations=NULL,
   covariates=NULL,
   type=c("trend", "cif", "intensity", "count"),
   se=FALSE,
   interval=c("none", "confidence", "prediction"),
   level = 0.95, 
   X=data.ppm(object), correction, ignore.hardcore=FALSE,
   ...,
   dimyx=NULL, eps=NULL,
   rule.eps = c("adjust.eps", "grow.frame", "shrink.frame"),
   new.coef=NULL, check=TRUE, repair=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ppm_+3A_object">object</code></td>
<td>

<p>A fitted point process model, typically obtained from
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>. An object of
class <code>"ppm"</code> (see <code><a href="#topic+ppm.object">ppm.object</a></code>).
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_window">window</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>)
<em>delimiting</em> the locations where predictions
should be computed. Defaults to the window of the
original data used to fit the model <code>object</code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_ngrid">ngrid</code></td>
<td>

<p>Optional. Dimensions of a rectangular grid of locations
inside <code>window</code> where the predictions should be computed.
An integer, or an integer vector of length 2,
specifying the number of grid points in the <code class="reqn">y</code> and <code class="reqn">x</code>
directions. (Incompatible with <code>locations</code>. Equivalent to
<code>dimyx</code>.) 
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_locations">locations</code></td>
<td>

<p>Optional. Data giving the exact
<code class="reqn">x,y</code> coordinates (and marks, if required)
of locations at which predictions should be computed.
Either a point pattern, or a data frame with columns named <code>x</code> and
<code>y</code>, or a binary image mask, or a pixel image.
(Incompatible with <code>ngrid</code>, <code>dimyx</code> and <code>eps</code>).
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_covariates">covariates</code></td>
<td>

<p>Values of external covariates required by the model.
Either a data frame or a list of images.
See Details.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_type">type</code></td>
<td>

<p>Character string.
Indicates which property of the fitted model should be predicted.
Options are <code>"trend"</code> for the spatial trend, 
<code>"cif"</code> or <code>"lambda"</code> for the conditional intensity,
<code>"intensity"</code> for the intensity, and
<code>"count"</code> for the total number of points in <code>window</code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to calculate
standard errors as well.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_interval">interval</code></td>
<td>

<p>String (partially matched) indicating whether to produce
estimates (<code>interval="none"</code>, the default)
or a confidence interval (<code>interval="confidence"</code>)
or a prediction interval (<code>interval="prediction"</code>).
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_level">level</code></td>
<td>

<p>Coverage probability for the confidence or prediction interval.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_x">X</code></td>
<td>

<p>Optional. A point pattern (object of class <code>"ppp"</code>)
to be taken as the data point pattern when calculating the
conditional intensity. The default is to use the original data
to which the model was fitted.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_correction">correction</code></td>
<td>

<p>Name of the edge correction to be used
in calculating the conditional intensity.
Options include <code>"border"</code> and <code>"none"</code>.
Other options may include <code>"periodic"</code>,
<code>"isotropic"</code> and <code>"translate"</code> depending on the model.
The default correction is the one that was used to fit <code>object</code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_ignore.hardcore">ignore.hardcore</code></td>
<td>

<p>Advanced use only.
Logical value specifying whether to compute only the
finite part of the interaction potential (effectively removing
any hard core interaction terms).
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_dimyx">dimyx</code></td>
<td>

<p>Equivalent to <code>ngrid</code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_eps">eps</code></td>
<td>

<p>Width and height of pixels in the prediction grid.
A numerical value, or numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Argument passed to <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> controlling the
discretisation. See <code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>Numeric vector of parameter values to replace the 
fitted model parameters <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>object</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="predict.ppm_+3A_repair">repair</code></td>
<td>

<p>Logical value indicating whether to repair the internal format
of <code>object</code>, if it is found to be damaged. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes properties of a fitted spatial point process
model (object of class <code>"ppm"</code>). For a Poisson point process
it can compute the fitted intensity function, or the expected number of
points in a region. For a Gibbs point process it can compute the
spatial trend (first order potential), conditional intensity,
and approximate intensity of the process. 
Point estimates, standard errors,
confidence intervals and prediction intervals are available.
</p>
<p>Given a point pattern dataset, we may fit
a point process model to the data using the 
model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>. This
returns an object of class <code>"ppm"</code> representing 
the fitted point process model (see <code><a href="#topic+ppm.object">ppm.object</a></code>).
The parameter estimates in this fitted model can be read off 
simply by printing the <code>ppm</code> object.
The spatial trend, conditional intensity and intensity of the 
fitted model are evaluated using this function <code>predict.ppm</code>.
</p>
<p>The default action is to create a rectangular grid of points
in the observation window of the data point pattern, and evaluate
the spatial trend at these locations.
</p>
<p>The argument <code>type</code> specifies the values that are desired:
</p>

<dl>
<dt>If <code>type="trend"</code>:</dt><dd>
<p>the &ldquo;spatial trend&rdquo; of the fitted model is evaluated at each
required spatial location <code class="reqn">u</code>. See below.
</p>
</dd>
<dt>If <code>type="cif"</code>:</dt><dd>
<p>the conditional intensity <code class="reqn">\lambda(u, X)</code> of the
fitted model is evaluated at each required spatial location <code class="reqn">u</code>,
with respect to the data point pattern <code class="reqn">X</code>.
</p>
</dd>
<dt>If <code>type="intensity"</code>:</dt><dd>
<p>the intensity <code class="reqn">\lambda(u)</code> of the
fitted model is evaluated at each required spatial location <code class="reqn">u</code>.
</p>
</dd>
<dt>If <code>type="count"</code>:</dt><dd>
<p>the expected total number of points (or the expected number
of points falling in <code>window</code>) is evaluated. 
If <code>window</code> is a tessellation,
the expected number of points in each tile of the tessellation
is evaluated.
</p>
</dd>
</dl>

<p>The spatial trend, conditional intensity, and intensity
are all equivalent if the fitted model is a Poisson point process.
However, if the model is not a Poisson process, then they are
all different. The &ldquo;spatial trend&rdquo; is the (exponentiated)
first order potential, and not the intensity of the process.
[For example if we fit the
stationary Strauss process with parameters
<code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
then the spatial trend is constant and equal to <code class="reqn">\beta</code>,
while the intensity is a smaller value.]
</p>
<p>The default is to compute an estimate of the desired quantity.
If <code>interval="confidence"</code> or <code>interval="prediction"</code>,
the estimate is replaced by a confidence interval or prediction interval.
</p>
<p>If <code>se=TRUE</code>, then a standard error is also calculated,
and is returned together with the (point or interval) estimate.
</p>
<p>The spatial locations where predictions are required,
are determined by the (incompatible)
arguments <code>ngrid</code> and <code>locations</code>.
</p>

<ul>
<li> 
<p>If the argument <code>ngrid</code> is present, then
predictions are performed at a rectangular 
grid of locations in the window <code>window</code>. 
The result of prediction will be a pixel image or images.
</p>
</li>
<li> 
<p>If <code>locations</code> is present, then predictions
will be performed at the spatial locations given by
this dataset. These may be an arbitrary list of spatial locations,
or they may be a rectangular grid. 
The result of prediction will be either a numeric vector
or a pixel image or images.
</p>
</li>
<li> 
<p>If neither <code>ngrid</code> nor <code>locations</code> is given, then
<code>ngrid</code> is assumed. The value of <code>ngrid</code> defaults to
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a>("npixel")</code>, which is initialised to 128
when <span class="pkg">spatstat</span> is loaded.
</p>
</li></ul>

<p>The argument <code>locations</code> may be a point pattern,
a data frame or a list specifying arbitrary locations;
or it may be a binary image mask (an object of class <code>"owin"</code>
with type <code>"mask"</code>) or a pixel image (object of class
<code>"im"</code>) specifying (a subset of) a rectangular
grid of locations. 
</p>

<ul>
<li> 
<p>If <code>locations</code> is a point pattern (object of class <code>"ppp"</code>),
then prediction will be performed at the points of the point pattern.
The result of prediction will be a vector of predicted values,
one value for each point.
If the model is a marked point process, then
<code>locations</code> should be a marked point pattern, with marks of the
same kind as the model; prediction will be performed at these
marked points.
The result of prediction will be a vector of predicted values,
one value for each (marked) point.
</p>
</li>
<li> 
<p>If <code>locations</code> is a data frame or list, then it must contain
vectors <code>locations$x</code> and <code>locations$y</code> specifying the
<code class="reqn">x,y</code> coordinates of the prediction locations. Additionally, if
the model is a marked point process, then <code>locations</code> must also contain
a factor <code>locations$marks</code> specifying the marks of the
prediction locations. These vectors must have equal length.
The result of prediction will be a vector of predicted values,
of the same length.
</p>
</li>
<li> 
<p>If <code>locations</code> is a binary image mask, then prediction will be
performed at each pixel in this binary image where the pixel value
is <code>TRUE</code> (in other words, at each pixel that is inside the
window). If the fitted model is an unmarked point process, then the
result of prediction will be an image. If the fitted model is a
marked point process, then prediction will
be performed for each possible value of the mark at each such
location, and the result of prediction will be a 
list of images, one for each mark value.
</p>
</li>
<li> 
<p>If <code>locations</code> is a pixel image (object of class <code>"im"</code>),
then prediction will be performed at each pixel in this image where
the pixel value is defined (i.e.\ where the pixel value is not
<code>NA</code>).
</p>
</li></ul>

<p>The argument <code>covariates</code> gives the values of any spatial covariates
at the prediction locations.
If the trend formula in the fitted model 
involves spatial covariates (other than
the Cartesian coordinates <code>x</code>, <code>y</code>)
then <code>covariates</code> is required.
The format and use of <code>covariates</code> are analogous to those of the
argument of the same name in <code><a href="#topic+ppm">ppm</a></code>.
It is either a data frame or a list of images.
</p>

<ul>
<li>
<p>If <code>covariates</code> is a list of images, then
the names of the entries should correspond to
the names of covariates in the model formula <code>trend</code>.
Each entry in the list must be an image object (of class <code>"im"</code>,
see <code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>).
The software will look up
the pixel values of each image at the quadrature points.
</p>
</li>
<li> 
<p>If <code>covariates</code> is a data frame, then the
<code>i</code>th row of <code>covariates</code>
is assumed to contain covariate data for the <code>i</code>th location.
When <code>locations</code> is a data frame,
this just means that each row of <code>covariates</code> contains the
covariate data for the location specified in the corresponding row of
<code>locations</code>. When <code>locations</code> is a binary image
mask, the row <code>covariates[i,]</code> must correspond to the location
<code>x[i],y[i]</code> where <code>x = as.vector(raster.x(locations))</code>
and <code>y = as.vector(raster.y(locations))</code>.
</p>
</li></ul>

<p>Note that if you only want to use prediction in order to
generate a plot of the predicted values,
it may be easier to use <code><a href="#topic+plot.ppm">plot.ppm</a></code> which calls
this function and plots the results.
</p>


<h3>Value</h3>

<p><em>If <code>total</code> is given:</em>
a numeric vector or matrix.  
</p>
<p><em>If <code>locations</code> is given and is a data frame:</em>
a vector of predicted values for the spatial locations
(and marks, if required) given in <code>locations</code>.
</p>
<p><em>If <code>ngrid</code> is given, or if <code>locations</code> is given
and is a binary image mask or a pixel image:</em>
If <code>object</code> is an unmarked point process,
the result is a pixel image object (of class <code>"im"</code>, see
<code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>) containing the predictions. 
If <code>object</code> is a multitype point process,
the result is a list of pixel images, containing the predictions
for each type at the same grid of locations.
</p>
<p>The &ldquo;predicted values&rdquo; are either values of the spatial trend
(if <code>type="trend"</code>), values of the conditional intensity
(if <code>type="cif"</code> or <code>type="lambda"</code>), 
values of the intensity (if <code>type="intensity"</code>)
or numbers of points (if <code>type="count"</code>).
</p>
<p>If <code>se=TRUE</code>, then the result is a list with two entries,
the first being the predicted values in the format described above,
and the second being the standard errors in the same format.
</p>


<h3>Warnings</h3>

<p>The current implementation invokes <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
so that <b>prediction is wrong</b> if the trend formula in
<code>object</code> involves terms in <code>ns()</code>,
<code>bs()</code> or <code>poly()</code>.
This is a weakness of <code><a href="stats.html#topic+predict.glm">predict.glm</a></code> itself!
</p>
<p>Error messages may be very opaque,
as they tend to come from deep in the workings of 
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.
If you are passing the <code>covariates</code> argument
and the function crashes,
it is advisable to start by checking that all the conditions 
listed above are satisfied.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R.
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b> (2000) 283&ndash;322.
</p>
<p>Berman, M. and Turner, T.R. 
Approximating point process likelihoods with GLIM.
<em>Applied Statistics</em> <b>41</b> (1992) 31&ndash;38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+plot.ppm">plot.ppm</a></code>,
<code><a href="#topic+print.ppm">print.ppm</a></code>,
<code><a href="#topic+fitted.ppm">fitted.ppm</a></code>,
<code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  m &lt;- ppm(cells ~ polynom(x,y,2), Strauss(0.05))
  trend &lt;- predict(m, type="trend")
  if(human &lt;- interactive()) {
  image(trend)
  points(cells)
  }
  cif &lt;- predict(m, type="cif")
  if(human) {
  persp(cif)
  }
  mj &lt;- ppm(japanesepines ~ harmonic(x,y,2))
  se &lt;- predict(mj, se=TRUE) # image of standard error
  ci &lt;- predict(mj, interval="c") # two images, confidence interval

  # prediction interval for total number of points
  predict(mj, type="count", interval="p")

  # prediction intervals for counts in tiles
  predict(mj, window=quadrats(japanesepines, 3), type="count", interval="p")

  # prediction at arbitrary locations
  predict(mj, locations=data.frame(x=0.3, y=0.4))

  X &lt;- runifpoint(5, Window(japanesepines))
  predict(mj, locations=X, se=TRUE)

  # multitype
  rr &lt;- matrix(0.06, 2, 2)
  ma &lt;- ppm(amacrine ~ marks,  MultiStrauss(rr))
  Z &lt;- predict(ma)
  Z &lt;- predict(ma, type="cif")
  predict(ma, locations=data.frame(x=0.8, y=0.5,marks="on"), type="cif")

  
</code></pre>

<hr>
<h2 id='predict.rppm'>
Make Predictions From a Recursively Partitioned Point Process Model
</h2><span id='topic+fitted.rppm'></span><span id='topic+predict.rppm'></span>

<h3>Description</h3>

<p>Given a model which has been fitted to point pattern data
by recursive partitioning, compute the predicted intensity
of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rppm'
predict(object, ...)

## S3 method for class 'rppm'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.rppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model of class <code>"rppm"</code>
produced by the function <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.rppm_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="#topic+predict.ppm">predict.ppm</a></code>
to specify the locations where prediction is required.
(Ignored by <code>fitted.rppm</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic functions
<code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="stats.html#topic+predict">predict</a></code>.
They compute the fitted intensity of a point process model.
The argument <code>object</code> should be a fitted point process model
of class <code>"rppm"</code> produced by the function <code><a href="#topic+rppm">rppm</a></code>.
</p>
<p>The <code>fitted</code> method computes the fitted intensity at the original data
points, yielding a numeric vector with one entry for each data point.
</p>
<p>The <code>predict</code> method computes the fitted intensity at
any locations. By default, predictions are
calculated at a regular grid of spatial locations, and the result
is a pixel image giving the predicted intensity values at these
locations.
</p>
<p>Alternatively, predictions can be performed at other
locations, or a finer grid of locations, or only at certain specified
locations, using additional arguments <code>...</code>
which will be interpreted by <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
Common arguments are <code>ngrid</code> to increase the grid resolution,
<code>window</code> to specify the prediction region, and <code>locations</code>
to specify the exact locations of predictions.
See <code><a href="#topic+predict.ppm">predict.ppm</a></code> for details of these arguments.
</p>
<p>Predictions are computed by evaluating the explanatory covariates at
each desired location, and applying the recursive partitioning rule
to each set of covariate values.
</p>


<h3>Value</h3>

<p>The result of <code>fitted.rppm</code> is a numeric vector.
</p>
<p>The result of <code>predict.rppm</code> is a pixel image, a list of pixel images,
or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rppm">rppm</a></code>,
<code><a href="#topic+plot.rppm">plot.rppm</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit &lt;- rppm(unmark(gorillas) ~ vegetation, data=gorillas.extra)
    plot(predict(fit))
    lambdaX &lt;- fitted(fit)
    lambdaX[1:5]
    # Mondriaan pictures
    plot(predict(rppm(redwoodfull ~ x + y)))
    points(redwoodfull)
</code></pre>

<hr>
<h2 id='predict.slrm'>
Predicted or Fitted Values from Spatial Logistic Regression
</h2><span id='topic+predict.slrm'></span>

<h3>Description</h3>

<p>Given a fitted Spatial Logistic Regression model,
this function computes the fitted probabilities for each pixel,
or the fitted point process intensity, or the values of the
linear predictor in each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'slrm'
predict(object, ..., type = "intensity",
                        newdata=NULL, window=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.slrm_+3A_object">object</code></td>
<td>

<p>a fitted spatial logistic regression model.
An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="predict.slrm_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="spatstat.geom.html#topic+pixellate">pixellate</a></code>
determining the pixel resolution for the discretisation
of the point pattern.
</p>
</td></tr>
<tr><td><code id="predict.slrm_+3A_type">type</code></td>
<td>

<p>Character string (partially) matching one of 
<code>"probabilities"</code>, <code>"intensity"</code> or <code>"link"</code>.
</p>
</td></tr>
<tr><td><code id="predict.slrm_+3A_newdata">newdata</code></td>
<td>

<p>Optional.  List containing new covariate values for the prediction.
See Details.
</p>
</td></tr>
<tr><td><code id="predict.slrm_+3A_window">window</code></td>
<td>

<p>Optional.  New window in which to predict.
An object of class <code>"owin"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+predict">predict</a></code> for spatial logistic
regression models (objects of class <code>"slrm"</code>, usually obtained
from the function <code><a href="#topic+slrm">slrm</a></code>).
</p>
<p>The argument <code>type</code> determines which quantity is computed.
If <code>type="intensity"</code>), the value of the point process intensity
is computed at each pixel. If <code>type="probabilities"</code>) the 
probability of the presence of a random point in each pixel is
computed. If <code>type="link"</code>, the value of the linear predictor is
computed at each pixel. 
</p>
<p>If <code>newdata = NULL</code> (the default), the algorithm computes
fitted values of the model (based on the data that was originally used
to fit the model <code>object</code>). 
</p>
<p>If <code>newdata</code> is given, the algorithm computes predicted values
of the model, using the new values of the covariates provided by
<code>newdata</code>. The argument <code>newdata</code> should be a list;
names of entries in the list should correspond
to variables appearing in the model formula of the <code>object</code>.
Each list entry may be a pixel image or a single numeric
value. 
</p>


<h3>Value</h3>

<p>A pixel image (object of class <code>"im"</code>) containing the predicted
values for each pixel.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- slrm(X ~ x+y)
  plot(predict(fit))

  X &lt;- copper$SouthPoints
  Y &lt;- copper$SouthLines
  Z &lt;- distmap(Y)
  fitc &lt;- slrm(X ~ Z)
  pc &lt;- predict(fitc)

  Znew &lt;- distmap(copper$Lines)[copper$SouthWindow]
  pcnew &lt;- predict(fitc, newdata=list(Z=Znew))
</code></pre>

<hr>
<h2 id='print.ppm'>Print a Fitted Point Process Model</h2><span id='topic+print.ppm'></span>

<h3>Description</h3>

<p>Default <code>print</code> method for a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppm'
print(x,...,
     what=c("all", "model", "trend", "interaction", "se", "errors"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ppm_+3A_x">x</code></td>
<td>

<p>A fitted point process model, typically obtained from
the model-fittingg algorithm <code><a href="#topic+ppm">ppm</a></code>.
An object of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="print.ppm_+3A_what">what</code></td>
<td>

<p>Character vector (partially-matched) indicating what information
should be printed.
</p>
</td></tr>
<tr><td><code id="print.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>print</code> method for the class <code>"ppm"</code>.
It prints information about the fitted model in a sensible format.
</p>
<p>The argument <code>what</code> makes it possible to print only some
of the information.
</p>
<p>If <code>what</code> is missing, then by default,
standard errors for the estimated coefficients of the model
will be printed only if the model is a Poisson point process.
To print the standard errors for a non-Poisson model,
call <code>print.ppm</code> with the argument <code>what</code> given explicitly,
or reset the default rule by typing
<code>spatstat.options(print.ppm.SE="always")</code>.
</p>


<h3>Value</h3>

<p>none.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code> for details of the class <code>"ppm"</code>.
</p>
<p><code><a href="#topic+ppm">ppm</a></code> for generating these objects.
</p>
<p><code><a href="#topic+plot.ppm">plot.ppm</a></code>,
<code><a href="#topic+predict.ppm">predict.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
   m &lt;- ppm(cells ~1, Strauss(0.05))
   m
  
</code></pre>

<hr>
<h2 id='profilepl'>Fit Models by Profile Maximum Pseudolikelihood or AIC</h2><span id='topic+profilepl'></span>

<h3>Description</h3>

<p>Fits point process models by maximising the profile likelihood,
profile pseudolikelihood, profile composite likelihood or AIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profilepl(s, f, ..., aic=FALSE, rbord=NULL, verbose = TRUE, fast=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profilepl_+3A_s">s</code></td>
<td>

<p>Data frame containing values of the irregular parameters
over which the criterion will be computed.
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_f">f</code></td>
<td>

<p>Function (such as <code><a href="#topic+Strauss">Strauss</a></code>)
that generates an interpoint interaction object, given
values of the irregular parameters.
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_...">...</code></td>
<td>

<p>Data passed to <code><a href="#topic+ppm">ppm</a></code> to fit the model.
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_aic">aic</code></td>
<td>

<p>Logical value indicating whether to find the parameter values
which minimise the AIC (<code>aic=TRUE</code>) or maximise the
profile likelihood (<code>aic=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_rbord">rbord</code></td>
<td>

<p>Radius for border correction (same for all models).
If omitted, this will be computed from the interactions.
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="profilepl_+3A_fast">fast</code></td>
<td>

<p>Logical value indicating whether to use a faster, less accurate
model-fitting technique when computing the profile pseudolikelihood.
See Section on Speed and Accuracy.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model-fitting function <code><a href="#topic+ppm">ppm</a></code> fits point process
models to point pattern data. However, 
only the &lsquo;regular&rsquo; parameters of the model can be fitted by
<code><a href="#topic+ppm">ppm</a></code>. The model may also depend on &lsquo;irregular&rsquo;
parameters that must be fixed in any call to <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>This function <code>profilepl</code> is a wrapper which finds the values of the
irregular parameters that give the best fit.
If <code>aic=FALSE</code> (the default),
the best fit is the model which maximises the
likelihood (if the models are Poisson processes) or maximises
the pseudolikelihood or logistic likelihood. 
If <code>aic=TRUE</code> then the best fit is the model which
minimises the Akaike Information Criterion <code><a href="#topic+AIC.ppm">AIC.ppm</a></code>.
</p>
<p>The argument <code>s</code> must be a data frame whose columns contain
values of the irregular parameters over which the maximisation is
to be performed.
</p>
<p>An irregular parameter may affect either the interpoint interaction
or the spatial trend. 
</p>

<dl>
<dt>interaction parameters:</dt><dd>
<p>in a call to <code><a href="#topic+ppm">ppm</a></code>, the argument <code>interaction</code>
determines the interaction between points. It is usually
a call to a function such as <code><a href="#topic+Strauss">Strauss</a></code>. The
arguments of this call are irregular parameters.
For example, the interaction radius parameter <code class="reqn">r</code> of the Strauss
process, determined by the argument <code>r</code>
to the function <code><a href="#topic+Strauss">Strauss</a></code>, is an irregular parameter.
</p>
</dd>
<dt>trend parameters:</dt><dd>
<p>in a call to <code><a href="#topic+ppm">ppm</a></code>, the spatial trend may depend on
covariates, which are supplied by the argument <code>covariates</code>.
These covariates may be functions written by the user,
of the form <code>function(x,y,...)</code>, and the extra arguments
<code>...</code> are irregular parameters.
</p>
</dd>
</dl>

<p>The argument <code>f</code> determines the interaction
for each model to be fitted. It would typically be one of the functions
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+BadGey">BadGey</a></code>,
<code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="#topic+Fiksel">Fiksel</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+Hardcore">Hardcore</a></code>,
<code><a href="#topic+LennardJones">LennardJones</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>, 
<code><a href="#topic+Softcore">Softcore</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code> or
<code><a href="#topic+StraussHard">StraussHard</a></code>.
Alternatively it could be a function written by the user.
</p>
<p>Columns of <code>s</code> which match the names of arguments of <code>f</code>
will be interpreted as interaction parameters. Other columns will be
interpreted as trend parameters.
</p>
<p>The data frame <code>s</code> must provide values for each argument of
<code>f</code>, except for the optional arguments, which are those arguments of
<code>f</code> that have the default value <code>NA</code>.  
</p>
<p>To find the best fit,
each row of <code>s</code> will be taken in turn. Interaction parameters in this
row will be passed to <code>f</code>, resulting in an interaction object. 
Then <code><a href="#topic+ppm">ppm</a></code> will be applied to the data <code>...</code>
using this interaction. Any trend parameters will be passed to
<code><a href="#topic+ppm">ppm</a></code> through the argument <code>covfunargs</code>.
This results in a fitted point process model.
The value of the log pseudolikelihood or AIC from this model is stored.
After all rows of <code>s</code> have been processed in this way, the
row giving the maximum value of log pseudolikelihood will be found.
</p>
<p>The object returned by <code>profilepl</code> contains the profile
pseudolikelihood (or profile AIC) function,
the best fitting model, and other data.
It can be plotted (yielding a
plot of the log pseudolikelihood or AIC values against the irregular
parameters) or printed (yielding information about the best fitting
values of the irregular parameters). 
</p>
<p>In general, <code>f</code> may be any function that will return
an interaction object (object of class <code>"interact"</code>)
that can be used in a call to <code><a href="#topic+ppm">ppm</a></code>. Each argument of
<code>f</code> must be a single value. 
</p>


<h3>Value</h3>

<p>An object of class <code>"profilepl"</code>. There are methods
for <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>,
<code><a href="#topic+as.ppm">as.ppm</a></code>,
<code><a href="#topic+fitin">fitin</a></code>
and 
<code><a href="#topic+parameters">parameters</a></code> for objects of this class.
</p>
<p>The components of the object include
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Best-fitting model</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>The data frame <code>s</code></p>
</td></tr>
<tr><td><code>iopt</code></td>
<td>
<p>Row index of the best-fitting parameters in <code>s</code></p>
</td></tr>
</table>
<p>To extract the best fitting model you can also use <code><a href="#topic+as.ppm">as.ppm</a></code>.
</p>


<h3>Speed and Accuracy</h3>

<p>Computation of the profile pseudolikelihood can be time-consuming.
We recommend starting with a small experiment in which
<code>s</code> contains only a few rows of values. This will indicate 
roughly the optimal values of the parameters.
Then a full calculation using more finely
spaced values can identify the exact optimal values.
</p>
<p>It is normal that the procedure appears to slow down at the end.
During the computation of the profile pseudolikelihood,
the model-fitting procedure is accelerated by omitting some
calculations that are not needed for computing the pseudolikelihood.
When the optimal parameter values have been identified, they are used to
fit the final model in its entirety. Fitting the final model
can take longer than computing the profile pseudolikelihood.
</p>
<p>If <code>fast=TRUE</code> (the default), then additional shortcuts are taken
in order to accelerate the computation of the profile
log pseudolikelihood. These shortcuts mean that the values of the profile
log pseudolikelihood in the result (<code>$prof</code>)
may not be equal to the values that would be obtained if the model was
fitted normally. Currently this happens only for the area interaction
<code><a href="#topic+AreaInter">AreaInter</a></code>. It may be wise to do a small experiment with
<code>fast=TRUE</code> and then a definitive calculation with <code>fast=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.profilepl">plot.profilepl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # one irregular parameter
    rr &lt;- data.frame(r=seq(0.05,0.15, by=0.01))
    
    ps &lt;- profilepl(rr, Strauss, cells)
    ps
    plot(ps)

    # two irregular parameters
    rs &lt;- expand.grid(r=seq(0.05,0.15, by=0.01),sat=1:3)
    
    pg &lt;- profilepl(rs, Geyer, cells)
    pg
    as.ppm(pg)

    ## more information 
    summary(pg)

    
    # multitype pattern with a common interaction radius
    RR &lt;- data.frame(R=seq(0.03,0.05,by=0.01))
    MS &lt;- function(R) { MultiStrauss(radii=diag(c(R,R))) }
    pm &lt;- profilepl(RR, MS, amacrine ~marks)
    

</code></pre>

<hr>
<h2 id='prune.rppm'>
Prune a Recursively Partitioned Point Process Model
</h2><span id='topic+prune.rppm'></span>

<h3>Description</h3>

<p>Given a model which has been fitted to point pattern data
by recursive partitioning, apply pruning to reduce the
complexity of the partition tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rppm'
prune(tree, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.rppm_+3A_tree">tree</code></td>
<td>

<p>Fitted point process model of class <code>"rppm"</code>
produced by the function <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
<tr><td><code id="prune.rppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="rpart.html#topic+prune.rpart">prune.rpart</a></code>
to control the pruning procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="rpart.html#topic+prune">prune</a></code>
for the class <code>"rppm"</code>. An object of this class is a
point process model, fitted to point pattern data by
recursive partitioning, by the function <code><a href="#topic+rppm">rppm</a></code>.
</p>
<p>The recursive partition tree will be pruned using
<code><a href="rpart.html#topic+prune.rpart">prune.rpart</a></code>. The result is another
object of class <code>"rppm"</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"rppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rppm">rppm</a></code>,
<code><a href="#topic+plot.rppm">plot.rppm</a></code>,
<code><a href="#topic+predict.rppm">predict.rppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Murchison gold data
  mur &lt;- solapply(murchison, rescale, s=1000, unitname="km")
  mur$dfault &lt;- distfun(mur$faults)
  fit &lt;- rppm(gold ~ dfault + greenstone, data=mur)
  fit
  prune(fit, cp=0.1)
</code></pre>

<hr>
<h2 id='pseudoR2'>
Calculate Pseudo-R-Squared for Point Process Model
</h2><span id='topic+pseudoR2'></span><span id='topic+pseudoR2.ppm'></span><span id='topic+pseudoR2.slrm'></span>

<h3>Description</h3>

<p>Given a fitted point process model, calculate 
the pseudo-R-squared value, which measures the 
fraction of variation in the data that is explained
by the model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pseudoR2(object, ...)

  ## S3 method for class 'ppm'
pseudoR2(object, ..., keepoffset=TRUE)

  ## S3 method for class 'slrm'
pseudoR2(object, ..., keepoffset=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoR2_+3A_object">object</code></td>
<td>

<p>Fitted point process model.
An object of class <code>"ppm"</code> or <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_keepoffset">keepoffset</code></td>
<td>

<p>Logical value indicating whether to retain offset terms in the model
when computing the deviance difference. See Details.
</p>
</td></tr>
<tr><td><code id="pseudoR2_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to 
<code><a href="#topic+deviance.ppm">deviance.ppm</a></code> or <code><a href="#topic+deviance.slrm">deviance.slrm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pseudoR2</code> is generic, with methods
for fitted point process models
of class <code>"ppm"</code> and <code>"slrm"</code>.
</p>
<p>This function computes McFadden's pseudo-Rsquared
</p>
<p style="text-align: center;"><code class="reqn">
    R^2 = 1 - \frac{D}{D_0}
  </code>
</p>

<p>where <code class="reqn">D</code> is the deviance of the fitted model <code>object</code>,
and <code class="reqn">D_0</code> is the deviance of the null model.
Deviance is defined as twice the negative log-likelihood
or log-pseudolikelihood.
</p>
<p>The null model is usually obtained by re-fitting the model
using the trend formula <code>~1</code>.
However if the original model formula included <code>offset</code> terms,
and if <code>keepoffset=TRUE</code> (the default),
then the null model formula consists of these offset terms. This
ensures that the <code>pseudoR2</code> value is non-negative.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deviance.ppm">deviance.ppm</a></code>, 
<code><a href="#topic+deviance.slrm">deviance.slrm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(swedishpines ~ x+y)
  pseudoR2(fit)

  xcoord &lt;- as.im(function(x,y) x, Window(swedishpines))
  fut &lt;- ppm(swedishpines ~ offset(xcoord/200) + y)
  pseudoR2(fut)
</code></pre>

<hr>
<h2 id='psib'>
Sibling Probability of Cluster Point Process
</h2><span id='topic+psib'></span><span id='topic+psib.kppm'></span>

<h3>Description</h3>

<p>Computes the sibling probability of a cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  psib(object)

  ## S3 method for class 'kppm'
psib(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psib_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model
(object of class <code>"kppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Poisson cluster process, two points are called <em>siblings</em>
if they belong to the same cluster, that is, if they had the same
parent point. If two points of the process are
separated by a distance <code class="reqn">r</code>, the probability that
they are siblings is <code class="reqn">p(r) = 1 - 1/g(r)</code> where <code class="reqn">g</code> is the
pair correlation function of the process.
</p>
<p>The value <code class="reqn">p(0) = 1 - 1/g(0)</code> is the probability that,
if two points of the process are situated very close to each other,
they came from the same cluster. This probability
is an index of the strength of clustering, with high values
suggesting strong clustering.
</p>
<p>This concept was proposed in Baddeley, Rubak and Turner (2015, page 479)
and Baddeley (2017). It was shown in Baddeley et al (2022) that
the sibling probability is directly related to the strength of clustering.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017)
Local composite likelihood for spatial point processes.
<em>Spatial Statistics</em> <b>22</b>, 261&ndash;295.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Baddeley, A., Davies, T.M., Hazelton, M.L., Rakshit, S. and Turner, R. 
(2022)
Fundamental problems in fitting spatial cluster process models.
<em>Spatial Statistics</em> <b>52</b>, 100709.
DOI: <code>10.1016/j.spasta.2022.100709</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>, <code><a href="#topic+panysib">panysib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~1, "Thomas")
  psib(fit)
</code></pre>

<hr>
<h2 id='psst'>
Pseudoscore Diagnostic For Fitted Model against General Alternative
</h2><span id='topic+psst'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
and any choice of functional summary statistic,
this function computes the pseudoscore test statistic
of goodness-of-fit for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psst(object, fun, r = NULL, breaks = NULL, ...,
     model=NULL,
     trend = ~1, interaction = Poisson(), rbord = reach(interaction),
     truecoef=NULL, hi.res=NULL, funargs = list(correction="best"),
     verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psst_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>)
or a point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="psst_+3A_fun">fun</code></td>
<td>

<p>Summary function to be applied to each point pattern.
</p>
</td></tr>
<tr><td><code id="psst_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
function <code class="reqn">S(r)</code> should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="psst_+3A_breaks">breaks</code></td>
<td>

<p>Optional alternative to <code>r</code> for advanced use.
</p>
</td></tr>
<tr><td><code id="psst_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="psst_+3A_model">model</code></td>
<td>

<p>Optional. A fitted point process model (object of
class <code>"ppm"</code>) to be re-fitted to the data
using <code><a href="#topic+update.ppm">update.ppm</a></code>, if <code>object</code> is a point pattern.
Overrides the arguments <code>trend,interaction,rbord</code>.
</p>
</td></tr>
<tr><td><code id="psst_+3A_trend">trend</code>, <code id="psst_+3A_interaction">interaction</code>, <code id="psst_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern.
See <code><a href="#topic+ppm">ppm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="psst_+3A_truecoef">truecoef</code></td>
<td>

<p>Optional. Numeric vector. If present, this will be treated as 
if it were the true coefficient vector of the point process model,
in calculating the diagnostic. Incompatible with <code>hi.res</code>.
</p>
</td></tr>
<tr><td><code id="psst_+3A_hi.res">hi.res</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
If this argument is present, the model will be
re-fitted at high resolution as specified by these parameters.
The coefficients
of the resulting fitted model will be taken as the true coefficients.
Then the diagnostic will be computed for the default
quadrature scheme, but using the high resolution coefficients.
</p>
</td></tr>
<tr><td><code id="psst_+3A_funargs">funargs</code></td>
<td>

<p>List of additional arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="psst_+3A_verbose">verbose</code></td>
<td>

<p>Logical value determining whether to print progress reports
during the computation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">x</code> be a point pattern dataset consisting of points
<code class="reqn">x_1,\ldots,x_n</code> in a window <code class="reqn">W</code>.
Consider a point process model fitted to <code class="reqn">x</code>, with
conditional intensity
<code class="reqn">\lambda(u,x)</code> at location <code class="reqn">u</code>.
For the purpose of testing goodness-of-fit, we regard the fitted model
as the null hypothesis. Given a functional summary statistic <code class="reqn">S</code>,
consider a family of alternative models obtained by exponential
tilting of the null model by <code class="reqn">S</code>. 
The pseudoscore for the null model is
</p>
<p style="text-align: center;"><code class="reqn">
    V(r) = \sum_i \Delta S(x_i, x, r) - \int_W \Delta S(u,x, r) \lambda(u,x)
    {\rm d} u
  </code>
</p>

<p>where the <code class="reqn">\Delta</code> operator is
</p>
<p style="text-align: center;"><code class="reqn">
    \Delta S(u,x, r) = S(x\cup\{u\}, r) - S(x\setminus u, r)
  </code>
</p>

<p>the difference between the values of <code class="reqn">S</code> for the
point pattern with and without the point <code class="reqn">u</code>.
</p>
<p>According to the Georgii-Nguyen-Zessin formula, <code class="reqn">V(r)</code> should have
mean zero if the model is correct (ignoring the fact that the
parameters of the model have been estimated). Hence <code class="reqn">V(r)</code> can be
used as a diagnostic for goodness-of-fit.
</p>
<p>This algorithm computes <code class="reqn">V(r)</code> by direct evaluation of the sum and
integral. It is computationally intensive, but it is available for
any summary statistic <code class="reqn">S(r)</code>.
</p>
<p>The diagnostic <code class="reqn">V(r)</code> is also called 
the <b>pseudoresidual</b> of <code class="reqn">S</code>. On the right
hand side of the equation for <code class="reqn">V(r)</code> given above,
the sum over points of <code class="reqn">x</code> is called the
<b>pseudosum</b> and the integral is called the <b>pseudocompensator</b>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
</p>
<p>Columns in this data frame include <code>dat</code> for the pseudosum,
<code>com</code> for the compensator and <code>res</code> for the
pseudoresidual.
</p>
<p>There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Special cases:
<code><a href="#topic+psstA">psstA</a></code>,
<code><a href="#topic+psstG">psstG</a></code>.
</p>
<p>Alternative functions:
<code><a href="#topic+Kres">Kres</a></code>,
<code><a href="#topic+Gres">Gres</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    if(live &lt;- interactive()) {
      fit0 &lt;- ppm(cells ~ 1)
    } else {
      fit0 &lt;- ppm(cells ~ 1, nd=8)
    }
    G0 &lt;- psst(fit0, Gest)
    G0
    if(live) plot(G0)
</code></pre>

<hr>
<h2 id='psstA'>
Pseudoscore Diagnostic For Fitted Model against Area-Interaction Alternative
</h2><span id='topic+psstA'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the pseudoscore diagnostic 
of goodness-of-fit for the model, against moderately
clustered or moderately inhibited alternatives of area-interaction type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psstA(object, r = NULL, breaks = NULL, ...,
      model = NULL, 
      trend = ~1, interaction = Poisson(),
      rbord = reach(interaction), ppmcorrection = "border",
      correction = "all",
      truecoef = NULL, hi.res = NULL,
      nr=spatstat.options("psstA.nr"),
      ngrid=spatstat.options("psstA.ngrid"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psstA_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>)
or a point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="psstA_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
diagnostic should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_breaks">breaks</code></td>
<td>

<p>This argument is for internal use only.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code> to determine
the quadrature scheme, if <code>object</code> is a point pattern.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_model">model</code></td>
<td>

<p>Optional. A fitted point process model (object of
class <code>"ppm"</code>) to be re-fitted to the data
using <code><a href="#topic+update.ppm">update.ppm</a></code>, if <code>object</code> is a point pattern.
Overrides the arguments <code>trend,interaction,rbord,ppmcorrection</code>.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_trend">trend</code>, <code id="psstA_+3A_interaction">interaction</code>, <code id="psstA_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern.
See <code><a href="#topic+ppm">ppm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_ppmcorrection">ppmcorrection</code></td>
<td>

<p>Optional. Character string specifying the edge correction
for the pseudolikelihood to be used
in fitting the point process model. Passed to <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_correction">correction</code></td>
<td>

<p>Optional. Character string specifying which diagnostic quantities
will be computed. Options are <code>"all"</code> and <code>"best"</code>.
The default is to compute all diagnostic quantities.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_truecoef">truecoef</code></td>
<td>

<p>Optional. Numeric vector. If present, this will be treated as 
if it were the true coefficient vector of the point process model,
in calculating the diagnostic. Incompatible with <code>hi.res</code>.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_hi.res">hi.res</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
If this argument is present, the model will be
re-fitted at high resolution as specified by these parameters.
The coefficients
of the resulting fitted model will be taken as the true coefficients.
Then the diagnostic will be computed for the default
quadrature scheme, but using the high resolution coefficients.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_nr">nr</code></td>
<td>

<p>Optional. Number of <code>r</code> values to be used
if <code>r</code> is not specified.
</p>
</td></tr>
<tr><td><code id="psstA_+3A_ngrid">ngrid</code></td>
<td>

<p>Integer. Number of points in the square grid used to compute
the approximate area.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the pseudoscore test statistic
which can be used as a diagnostic for goodness-of-fit of a fitted
point process model.
</p>
<p>Let <code class="reqn">x</code> be a point pattern dataset consisting of points
<code class="reqn">x_1,\ldots,x_n</code> in a window <code class="reqn">W</code>.
Consider a point process model fitted to <code class="reqn">x</code>, with
conditional intensity
<code class="reqn">\lambda(u,x)</code> at location <code class="reqn">u</code>.
For the purpose of testing goodness-of-fit, we regard the fitted model
as the null hypothesis.
The alternative hypothesis is a family of
hybrid models obtained by combining 
the fitted model with the area-interaction process
(see <code><a href="#topic+AreaInter">AreaInter</a></code>). The family of alternatives includes
models that are slightly more regular than the fitted model,
and others that are slightly more clustered than the fitted model.
</p>
<p>The pseudoscore, evaluated at the null model, is
</p>
<p style="text-align: center;"><code class="reqn">
    V(r) = \sum_i A(x_i, x, r) - \int_W A(u,x, r) \lambda(u,x)
    {\rm d} u
  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
    A(u,x,r) = B(x\cup\{u\},r) - B(x\setminus u, r)
  </code>
</p>

<p>where <code class="reqn">B(x,r)</code> is the area of the union of the discs of radius
<code class="reqn">r</code> centred at the points of <code class="reqn">x</code> (i.e. <code class="reqn">B(x,r)</code> is the area
of the dilation of <code class="reqn">x</code> by a distance <code class="reqn">r</code>).
Thus <code class="reqn">A(u,x,r)</code> is the <em>unclaimed area</em> associated with
<code class="reqn">u</code>, that is, the area of that part of the disc
of radius <code class="reqn">r</code> centred at the point <code class="reqn">u</code> that is
not covered by any of the discs of radius <code class="reqn">r</code> centred at
points of <code class="reqn">x</code>.
</p>
<p>According to the Georgii-Nguyen-Zessin formula, <code class="reqn">V(r)</code> should have
mean zero if the model is correct (ignoring the fact that the
parameters of the model have been estimated). Hence <code class="reqn">V(r)</code> can be
used as a diagnostic for goodness-of-fit.
</p>
<p>The diagnostic <code class="reqn">V(r)</code> is also called 
the <b>pseudoresidual</b> of <code class="reqn">S</code>. On the right
hand side of the equation for <code class="reqn">V(r)</code> given above,
the sum over points of <code class="reqn">x</code> is called the
<b>pseudosum</b> and the integral is called the <b>pseudocompensator</b>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
</p>
<p>Columns in this data frame include <code>dat</code> for the pseudosum,
<code>com</code> for the compensator and <code>res</code> for the
pseudoresidual.
</p>
<p>There is a plot method for this class. See <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Warning</h3>

<p>This computation can take a <b>very long time</b>.
</p>
<p>To shorten the computation time, choose smaller values of the
arguments <code>nr</code> and <code>ngrid</code>, or reduce the values of their
defaults <code>spatstat.options("psstA.nr")</code>
and <code>spatstat.options("psstA.ngrid")</code>.
</p>
<p>Computation time is roughly proportional to
<code>nr * npoints * ngrid^2</code> where <code>npoints</code> is the number
of points in the point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Alternative functions:
<code><a href="#topic+psstG">psstG</a></code>,
<code><a href="#topic+psst">psst</a></code>,
<code><a href="#topic+Gres">Gres</a></code>,
<code><a href="#topic+Kres">Kres</a></code>.
</p>
<p>Point process models: <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>Options: <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(live &lt;- interactive()) {
     X &lt;- rStrauss(200,0.1,0.05)
   } else {
     pso &lt;- spatstat.options(psstA.ngrid=16,psstA.nr=10,
            ndummy.min=16,npixel=32)
     X &lt;- cells
   }

   plot(psstA(X))
   plot(psstA(X, interaction=Strauss(0.05)))

   if(!live) spatstat.options(pso)
</code></pre>

<hr>
<h2 id='psstG'>
Pseudoscore Diagnostic For Fitted Model against Saturation Alternative
</h2><span id='topic+psstG'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern dataset,
this function computes the pseudoscore  diagnostic 
of goodness-of-fit for the model, against moderately
clustered or moderately inhibited alternatives of saturation type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psstG(object, r = NULL, breaks = NULL, ...,
      model=NULL,
      trend = ~1, interaction = Poisson(), rbord = reach(interaction),
      truecoef = NULL, hi.res = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psstG_+3A_object">object</code></td>
<td>

<p>Object to be analysed.
Either a fitted point process model (object of class <code>"ppm"</code>)
or a point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="psstG_+3A_r">r</code></td>
<td>

<p>Optional. 
Vector of values of the argument <code class="reqn">r</code> at which the
diagnostic should be computed.
This argument is usually not specified. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="psstG_+3A_breaks">breaks</code></td>
<td>

<p>Optional alternative to <code>r</code> for advanced use. 
</p>
</td></tr>
<tr><td><code id="psstG_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="psstG_+3A_model">model</code></td>
<td>

<p>Optional. A fitted point process model (object of
class <code>"ppm"</code>) to be re-fitted to the data
using <code><a href="#topic+update.ppm">update.ppm</a></code>, if <code>object</code> is a point pattern.
Overrides the arguments <code>trend,interaction,rbord,ppmcorrection</code>.
</p>
</td></tr>
<tr><td><code id="psstG_+3A_trend">trend</code>, <code id="psstG_+3A_interaction">interaction</code>, <code id="psstG_+3A_rbord">rbord</code></td>
<td>

<p>Optional. Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
to fit a point process model to the data,
if <code>object</code> is a point pattern.
See <code><a href="#topic+ppm">ppm</a></code> for details.
</p>
</td></tr>
<tr><td><code id="psstG_+3A_truecoef">truecoef</code></td>
<td>

<p>Optional. Numeric vector. If present, this will be treated as 
if it were the true coefficient vector of the point process model,
in calculating the diagnostic. Incompatible with <code>hi.res</code>.
</p>
</td></tr>
<tr><td><code id="psstG_+3A_hi.res">hi.res</code></td>
<td>

<p>Optional. List of parameters passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
If this argument is present, the model will be
re-fitted at high resolution as specified by these parameters.
The coefficients
of the resulting fitted model will be taken as the true coefficients.
Then the diagnostic will be computed for the default
quadrature scheme, but using the high resolution coefficients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
computes the pseudoscore test statistic
which can be used as a diagnostic for goodness-of-fit of a fitted
point process model.
</p>
<p>Consider a point process model fitted to <code class="reqn">x</code>, with
conditional intensity
<code class="reqn">\lambda(u,x)</code> at location <code class="reqn">u</code>.
For the purpose of testing goodness-of-fit, we regard the fitted model
as the null hypothesis.
The alternative hypothesis is a family of
hybrid models obtained by combining 
the fitted model with the Geyer saturation process
(see <code><a href="#topic+Geyer">Geyer</a></code>) with saturation parameter 1.
The family of alternatives includes
models that are more regular than the fitted model,
and others that are more clustered than the fitted model.
</p>
<p>For any point pattern <code class="reqn">x</code>, and any <code class="reqn">r &gt; 0</code>, let
<code class="reqn">S(x,r)</code> be the number of points in <code class="reqn">x</code> whose nearest
neighbour (the nearest other point in <code class="reqn">x</code>)
is closer than <code class="reqn">r</code> units. Then the pseudoscore for the null model is
</p>
<p style="text-align: center;"><code class="reqn">
    V(r) = \sum_i \Delta S(x_i, x, r ) - \int_W \Delta S(u,x,r) \lambda(u,x)
    {\rm d} u
  </code>
</p>

<p>where the <code class="reqn">\Delta</code> operator is
</p>
<p style="text-align: center;"><code class="reqn">
    \Delta S(u,x,r) = S(x\cup\{u\}, r) - S(x\setminus u, r)
  </code>
</p>

<p>the difference between the values of <code class="reqn">S</code> for the
point pattern with and without the point <code class="reqn">u</code>.
</p>
<p>According to the Georgii-Nguyen-Zessin formula, <code class="reqn">V(r)</code> should have
mean zero if the model is correct (ignoring the fact that the
parameters of the model have been estimated). Hence <code class="reqn">V(r)</code> can be
used as a diagnostic for goodness-of-fit.
</p>
<p>The diagnostic <code class="reqn">V(r)</code> is also called 
the <b>pseudoresidual</b> of <code class="reqn">S</code>. On the right
hand side of the equation for <code class="reqn">V(r)</code> given above,
the sum over points of <code class="reqn">x</code> is called the
<b>pseudosum</b> and the integral is called the <b>pseudocompensator</b>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>),
essentially a data frame of function values.
</p>
<p>Columns in this data frame include <code>dat</code> for the pseudosum,
<code>com</code> for the compensator and <code>res</code> for the
pseudoresidual.
</p>
<p>There is a plot method for this class. See
<code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jesper Moller.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Moller, J. (2011)
Score, pseudo-score and residual
diagnostics for spatial point process models.
<em>Statistical Science</em> <b>26</b>, 613&ndash;646.
</p>


<h3>See Also</h3>

<p>Alternative functions:
<code><a href="#topic+psstA">psstA</a></code>,
<code><a href="#topic+psst">psst</a></code>,
<code><a href="#topic+Kres">Kres</a></code>,
<code><a href="#topic+Gres">Gres</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(live &lt;- interactive()) {
     X &lt;- rStrauss(200,0.1,0.05)
   } else {
     pso &lt;- spatstat.options(ndummy.min=16,npixel=32)
     X &lt;- cells
   }

   plot(psstG(X))
   plot(psstG(X, interaction=Strauss(0.05)))

   if(!live) spatstat.options(pso)
</code></pre>

<hr>
<h2 id='qqplot.ppm'>
Q-Q Plot of Residuals from Fitted Point Process Model
</h2><span id='topic+qqplot.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
produce a Q-Q plot based on residuals from the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qqplot.ppm(fit, nsim=100, expr=NULL, ..., type="raw",
             style="mean", fast=TRUE, verbose=TRUE, plot.it=TRUE,
             dimyx=NULL, nrep=if(fast) 5e4 else 1e5,
             control=update(default.rmhcontrol(fit), nrep=nrep),
             saveall=FALSE,
             monochrome=FALSE,
             limcol=if(monochrome) "black" else "red",
             maxerr=max(100, ceiling(nsim/10)),
             check=TRUE, repair=TRUE, envir.expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplot.ppm_+3A_fit">fit</code></td>
<td>

<p>The fitted point process model, which is to be assessed
using the Q-Q plot. An object of class <code>"ppm"</code>.
Smoothed residuals obtained from this fitted model will provide the
&ldquo;data&rdquo; quantiles for the Q-Q plot.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulations from the &ldquo;reference&rdquo; point process model.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_expr">expr</code></td>
<td>

<p>Determines the simulation mechanism
which provides the &ldquo;theoretical&rdquo; quantiles for the
Q-Q plot. See Details.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> influencing the
computation of residuals.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_type">type</code></td>
<td>

<p>String indicating the type of residuals or weights to be used.
Current options are <code>"eem"</code>
for the Stoyan-Grabarnik exponential energy weights,
<code>"raw"</code> for the raw residuals,
<code>"inverse"</code> for the inverse-lambda residuals,
and <code>"pearson"</code> for the Pearson residuals.
A partial match is adequate.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_style">style</code></td>
<td>

<p>Character string controlling the type of Q-Q plot.
Options are <code>"classical"</code> and <code>"mean"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_fast">fast</code></td>
<td>

<p>Logical flag controlling the speed and accuracy of computation.
Use <code>fast=TRUE</code> for interactive use and <code>fast=FALSE</code>
for publication standard plots. See Details.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag controlling whether the algorithm prints progress
reports during long computations.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_plot.it">plot.it</code></td>
<td>

<p>Logical flag controlling whether the function produces a plot
or simply returns a value (silently).
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_dimyx">dimyx</code></td>
<td>

<p>Dimensions of the pixel grid on which the smoothed residual field
will be calculated. A vector of two integers.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_nrep">nrep</code></td>
<td>

<p>If <code>control</code> is absent, then <code>nrep</code> gives the
number of iterations of the Metropolis-Hastings algorithm
that should be used to generate one simulation of the fitted point process.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_control">control</code></td>
<td>

<p>List of parameters controlling the Metropolis-Hastings algorithm
<code><a href="spatstat.random.html#topic+rmh">rmh</a></code> which generates each simulated realisation from
the model (unless the model is Poisson).
This list becomes the argument <code>control</code>
of <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>. It overrides <code>nrep</code>.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_saveall">saveall</code></td>
<td>

<p>Logical flag indicating whether to save all the intermediate
calculations. 
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_monochrome">monochrome</code></td>
<td>

<p>Logical flag indicating whether the plot should be
in black and white (<code>monochrome=TRUE</code>), or in colour
(<code>monochrome=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_limcol">limcol</code></td>
<td>

<p>String. The colour to be used when plotting the 95% limit
curves.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_maxerr">maxerr</code></td>
<td>

<p>Maximum number of failures tolerated while generating
simulated realisations. See Details.
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>fit</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_repair">repair</code></td>
<td>

<p>Logical value indicating whether to repair the internal format
of <code>fit</code>, if it is found to be damaged. 
</p>
</td></tr>
<tr><td><code id="qqplot.ppm_+3A_envir.expr">envir.expr</code></td>
<td>

<p>Optional. An environment in which the expression
<code>expr</code> should be evaluated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a Q-Q plot of the residuals from a
fitted point process model. It is an addendum to the suite of
diagnostic plots produced by the function <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>,
kept separate because it is computationally intensive. The
quantiles of the theoretical distribution are estimated by simulation.
</p>
<p>In classical statistics, a Q-Q plot of residuals is a useful
diagnostic for checking the distributional assumptions. Analogously,
in spatial statistics, a Q-Q plot of the (smoothed) residuals from a
fitted point process model is a useful way
to check the interpoint interaction part of the model
(Baddeley et al, 2005). The systematic part of the model
(spatial trend, covariate effects, etc) is assessed using
other plots made by <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>.
</p>
<p>The argument <code>fit</code> represents the fitted point process
model. It must be an object of class <code>"ppm"</code> (typically produced
by the maximum pseudolikelihood fitting algorithm <code><a href="#topic+ppm">ppm</a></code>).
Residuals will be computed for this fitted model using
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
and the residuals will be kernel-smoothed to produce a &ldquo;residual
field&rdquo;. The values of this residual field will provide the
&ldquo;data&rdquo; quantiles for the Q-Q plot.
</p>
<p>The argument <code>expr</code> is not usually specified.
It provides a way to modify the &ldquo;theoretical&rdquo; or &ldquo;reference&rdquo;
quantiles for the Q-Q plot.
</p>
<p>In normal usage we set <code>expr=NULL</code>. The default
is to generate <code>nsim</code> simulated realisations
of the fitted model <code>fit</code>, re-fit this model to
each of the simulated patterns,
evaluate the residuals from
these fitted models, and use the kernel-smoothed residual field
from these fitted models as a sample from the reference distribution
for the Q-Q plot.
</p>
<p>In advanced use, <code>expr</code> may be an <code>expression</code>.
It will be re-evaluated <code>nsim</code> times, and should include
random computations so that the results are not identical
each time. The result of evaluating <code>expr</code>
should be either a point pattern (object of class
<code>"ppp"</code>) or a fitted point process model (object of class
<code>"ppm"</code>). If the value is a point pattern, then the
original fitted model <code>fit</code> will be fitted to this new point
pattern using <code><a href="#topic+update.ppm">update.ppm</a></code>, to yield another fitted
model. Smoothed residuals obtained from these
<code>nsim</code> fitted models will yield the &ldquo;theoretical&rdquo; quantiles for the
Q-Q plot.
</p>
<p>Alternatively <code>expr</code> can be a list of point patterns,
or an <code>envelope</code> object that contains a list of point patterns
(typically generated by calling <code><a href="boot.html#topic+envelope">envelope</a></code> with
<code>savepatterns=TRUE</code>). These point patterns will be used
as the simulated patterns. 
</p>
<p>Simulation is performed (if <code>expr=NULL</code>)
using the Metropolis-Hastings algorithm <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>.
Each simulated realisation is the result of
running the Metropolis-Hastings algorithm
from an independent random starting state each time.
The iterative and termination behaviour of the Metropolis-Hastings
algorithm are governed by the argument <code>control</code>.
See <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code> for information about this argument.
As a shortcut, the argument <code>nrep</code> determines
the number of Metropolis-Hastings iterations used to generate
each simulated realisation, if <code>control</code> is absent.
</p>
<p>By default, simulations are generated in an expanded
window. Use the argument <code>control</code> to change this,
as explained in the section on <em>Warning messages</em>.
</p>
<p>The argument <code>type</code> selects the type of residual or weight
that will be computed. For options, see <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>.
</p>
<p>The argument <code>style</code> determines the type of Q-Q plot. It is
highly recommended to use the default, <code>style="mean"</code>.
</p>

<dl>
<dt><code>style="classical"</code></dt><dd>
<p>The quantiles of the residual field for the data (on the <code class="reqn">y</code>
axis) are plotted against the
quantiles of the <b>pooled</b> simulations (on the <code class="reqn">x</code> axis).
This plot is biased, and therefore difficult to interpret,
because of strong autocorrelations in the residual field
and the large differences in sample size.
</p>
</dd>
<dt><code>style="mean"</code></dt><dd>
<p>The order statistics of the residual field for the data are plotted
against the sample means, over the <code>nsim</code> simulations,
of the corresponding order statistics of the residual field
for the simulated datasets.
Dotted lines show the 2.5 and 97.5 percentiles, over the
<code>nsim</code> simulations, of each order statistic.
</p>
</dd>
</dl>

<p>The argument <code>fast</code> is a simple way to control
the accuracy and speed of computation.
If <code>fast=FALSE</code>, the residual field is computed on
a fine grid of pixels (by default 100 by 100 pixels, see below)
and the Q-Q plot is based on the complete set of order statistics
(usually 10,000 quantiles).
If <code>fast=TRUE</code>, the residual field is computed on a coarse
grid (at most 40 by 40 pixels) and the Q-Q plot is based on the
<em>percentiles</em> only. This is about 7 times faster.
It is recommended to use <code>fast=TRUE</code> for interactive data
analysis and <code>fast=FALSE</code> for definitive plots for
publication.
</p>
<p>The argument <code>dimyx</code> gives full control over the resolution of the
pixel grid used to calculate the smoothed residuals.
Its interpretation is the same as the argument <code>dimyx</code>
to the function <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
Note that <code>dimyx[1]</code> is the number of
pixels in the <code class="reqn">y</code> direction, and <code>dimyx[2]</code> is the number
in the <code class="reqn">x</code> direction. 
If <code>dimyx</code> is not present, then the default pixel grid dimensions
are controlled by <code>spatstat.options("npixel")</code>.
</p>
<p>Since the computation is so time-consuming, <code>qqplot.ppm</code> returns
a list containing all the data necessary to re-display the Q-Q plot.
It is advisable to assign the result of <code>qqplot.ppm</code> to something
(or use <code>.Last.value</code> if you forgot to.)
The return value is an object of class <code>"qqppm"</code>. There are methods for
<code><a href="#topic+plot.qqppm">plot.qqppm</a></code> and <code><a href="#topic+print.qqppm">print.qqppm</a></code>. See the
Examples.
</p>
<p>The argument <code>saveall</code> is usually set to <code>FALSE</code>.
If <code>saveall=TRUE</code>, then the intermediate results of calculation for each
simulated realisation are saved and returned. The return value
includes a 3-dimensional array <code>sim</code> containing the
smoothed residual field images for each of the <code>nsim</code> 
realisations. When <code>saveall=TRUE</code>, the return value is an object of very
large size, and should not be saved on disk.
</p>
<p>Errors may occur during the simulation process, because
random data are generated. For example:
</p>

<ul>
<li><p> one of the simulated patterns may be empty.
</p>
</li>
<li><p> one of the simulated patterns may 
cause an error in the code that fits the point process model.
</p>
</li>
<li><p> the user-supplied argument <code>expr</code> may have a bug.
</p>
</li></ul>

<p>Empty point patterns do not cause a problem for the code,
but they are reported.
Other problems that would lead to a crash are trapped; 
the offending simulated data are discarded, and the simulation is
retried. The argument <code>maxerr</code> determines the maximum number of
times that such errors will be tolerated (mainly as a
safeguard against an infinite loop).
</p>


<h3>Value</h3>

<p>An object of class <code>"qqppm"</code> containing the information
needed to reproduce the Q-Q plot.
Entries <code>x</code> and <code>y</code> are numeric vectors containing 
quantiles of the simulations and of the data, respectively.
</p>


<h3>Side Effects</h3>

<p>Produces a Q-Q plot if <code>plot.it</code> is TRUE.
</p>


<h3>Warning messages</h3>

<p>A warning message will be issued if any of the simulations
trapped an error (a potential crash).
</p>
<p>A warning message will be issued if all, or many, of the
simulated point patterns are empty.
This usually indicates a problem with the simulation procedure.
</p>
<p>The default behaviour of <code>qqplot.ppm</code> is to simulate patterns 
on an expanded window (specified through the argument
<code>control</code>) in order to avoid edge effects.
The model's trend is extrapolated over this expanded
window. If the trend is strongly inhomogeneous, the 
extrapolated trend may have very large (or even infinite)
values. This can cause the simulation algorithm to 
produce empty patterns.
</p>
<p>The only way to suppress this problem entirely is to
prohibit the expansion of the window, by setting
the <code>control</code> argument to something like
<code>control=list(nrep=1e6, expand=1)</code>. Here <code>expand=1</code>
means there will be no expansion. See <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>
for more information about the argument <code>control</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Stoyan, D. and Grabarnik, P. (1991)
Second-order characteristics for stochastic structures connected with
Gibbs point processes.
<em>Mathematische Nachrichten</em>, 151:95&ndash;100.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>,
<code><a href="#topic+lurking">lurking</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>,
<code><a href="#topic+eem">eem</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="spatstat.random.html#topic+rmh">rmh</a></code>,
<code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit &lt;- ppm(cells ~1, Poisson())
    diagnose.ppm(fit)  # no suggestion of departure from stationarity
    if(interactive()) {
       qqplot.ppm(fit, 80)  # strong evidence of non-Poisson interaction
     diagnose.ppm(fit, type="pearson")  
     qqplot.ppm(fit, type="pearson")
    }
    

    
      # capture the plot coordinates
      mypreciousdata &lt;- qqplot.ppm(fit, 4, type="pearson")
      ## or use the idiom .Last.value if you forgot to assign them
      qqplot.ppm(fit, 4, type="pearson")
      mypreciousdata &lt;- .Last.value
      plot(mypreciousdata)
    

    ######################################################
    # Q-Q plots based on fixed n
    # The above QQ plots used simulations from the (fitted) Poisson process.
    # But I want to simulate conditional on n, instead of Poisson
    # Do this by setting rmhcontrol(p=1)
    fixit &lt;- list(p=1)
    if(interactive()) {qqplot.ppm(fit, 100, control=fixit)}
    

    ######################################################
    # Inhomogeneous Poisson data
    X &lt;- rpoispp(function(x,y){1000 * exp(-3*x)}, 1000)
    plot(X)
    # Inhomogeneous Poisson model
    fit &lt;- ppm(X ~x, Poisson())
    if(interactive()) {qqplot.ppm(fit, 100)}
    
    # conclusion: fitted inhomogeneous Poisson model looks OK

    ######################################################
    # Advanced use of 'expr' argument
    # 
    # set the initial conditions in Metropolis-Hastings algorithm
    # 
    expr &lt;- expression(rmh(fit, start=list(n.start=42), verbose=FALSE))
    if(interactive()) qqplot.ppm(fit, 100, expr)
    

</code></pre>

<hr>
<h2 id='quad.ppm'>Extract Quadrature Scheme Used to Fit a Point Process Model</h2><span id='topic+quad.ppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model,
this function extracts the 
quadrature scheme used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  quad.ppm(object, drop=FALSE, clip=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quad.ppm_+3A_object">object</code></td>
<td>

<p>fitted point process model (an object of class <code>"ppm"</code>
or <code>"kppm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="quad.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical value determining whether to delete quadrature points
that were not used to fit the model.
</p>
</td></tr>
<tr><td><code id="quad.ppm_+3A_clip">clip</code></td>
<td>

<p>Logical value determining whether to erode the window,
if <code>object</code> was fitted using the border correction.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"ppm"</code> represents a point process model
that has been fitted to data. It is typically produced by
the model-fitting algorithm <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The maximum pseudolikelihood algorithm in <code><a href="#topic+ppm">ppm</a></code>
approximates the pseudolikelihood
integral by a sum over a finite set of quadrature points,
which is constructed by augmenting
the original data point pattern by a set of &ldquo;dummy&rdquo; points.
The fitted model object returned by <code><a href="#topic+ppm">ppm</a></code>
contains complete information about this quadrature scheme.
See <code><a href="#topic+ppm">ppm</a></code> or <code><a href="#topic+ppm.object">ppm.object</a></code> for further
information.
</p>
<p>This function <code>quad.ppm</code> extracts the quadrature scheme.
A typical use of this function would be to inspect the quadrature scheme
(points and weights) to gauge the accuracy of the approximation to the
exact pseudolikelihood.
</p>
<p>Some quadrature points may not have been used in
fitting the model. This happens if the border correction is used,
and in other cases (e.g. when the value of a covariate is <code>NA</code>
at these points). The argument <code>drop</code> specifies whether these
unused quadrature points shall be deleted (<code>drop=TRUE</code>) or
retained (<code>drop=FALSE</code>) in the return value.
</p>
<p>The quadrature scheme has a <em>window</em>, which by default is set to
equal the window of the original data. However this window may be
larger than the actual domain of integration of the pseudolikelihood
or composite likelihood that was used to fit the model.
If <code>clip=TRUE</code> then the window of the quadrature scheme is
set to the actual domain of integration. This option only has an effect
when the model was fitted using the border correction; then
the window is obtained by eroding the original data window
by the border correction distance. 
</p>
<p>See <code><a href="#topic+ppm.object">ppm.object</a></code> for a list of all operations that can be
performed on objects of class <code>"ppm"</code>.
See <code><a href="spatstat.geom.html#topic+quad.object">quad.object</a></code> for a list of all operations that can be
performed on objects of class <code>"quad"</code>.
</p>
<p>This function can also be applied to objects of class <code>"kppm"</code>
and <code>"lppm"</code>.
</p>


<h3>Value</h3>

<p>A quadrature scheme (object of class <code>"quad"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="spatstat.geom.html#topic+quad.object">quad.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- ppm(cells ~1, Strauss(r=0.1))
 Q &lt;- quad.ppm(fit)
 
   plot(Q)
 
 npoints(Q$data)
 npoints(Q$dummy)
</code></pre>

<hr>
<h2 id='quadrat.test.mppm'>Chi-Squared Test for Multiple Point Process Model Based on
Quadrat Counts</h2><span id='topic+quadrat.test.mppm'></span>

<h3>Description</h3>

<p>Performs a chi-squared goodness-of-fit test of a 
Poisson point process model fitted to multiple point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mppm'
quadrat.test(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrat.test.mppm_+3A_x">X</code></td>
<td>

<p>An object of class <code>"mppm"</code> representing a
point process model fitted to multiple point patterns.
It should be a Poisson model.
</p>
</td></tr>
<tr><td><code id="quadrat.test.mppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+quadrat.test.ppm">quadrat.test.ppm</a></code>
which determine the size of the quadrats.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a <code class="reqn">\chi^2</code> test of goodness-of-fit
for a Poisson point process model, based on quadrat counts.
It can also be used to perform a test of Complete Spatial Randomness
for a list of point patterns.
</p>
<p>The function <code>quadrat.test</code> is generic, with methods for
point patterns (class <code>"ppp"</code>), point process models
(class <code>"ppm"</code>) and
multiple point process models (class
<code>"mppm"</code>).
</p>
<p>For this function, the argument <code>X</code> should be a
multiple point process model (object of class <code>"mppm"</code>)
obtained by fitting a point process model to a list of
point patterns using the function <code><a href="#topic+mppm">mppm</a></code>.
</p>
<p>To perform the test, the data point patterns are extracted from <code>X</code>.
For each point pattern
</p>

<ul>
<li><p> the window of observation is divided
into rectangular tiles, and the number of data points in each tile is
counted, as described in <code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a></code>.
</p>
</li>
<li> 
<p>The expected number of points in each quadrat is calculated,
as determined by the fitted model.
</p>
</li></ul>

<p>Then we perform a single <code class="reqn">\chi^2</code> test of goodness-of-fit
based on these observed and expected counts. 
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code>.
Printing the object gives comprehensible output
about the outcome of the test.
The <code class="reqn">p</code>-value of the test is stored in the
component <code>p.value</code>.
</p>
<p>The return value also belongs to
the special class <code>"quadrat.test"</code>. Plotting the object
will display, for each window, the position of the quadrats,
annotated by their observed and expected
counts and the Pearson residuals. See the examples.
</p>
<p>The return value also has an attribute <code>"components"</code>
which is a list containing the results of 
<code class="reqn">\chi^2</code> tests of goodness-of-fit
for each individual point pattern.
</p>


<h3>Testing Complete Spatial Randomness</h3>

<p>If the intention is to test Complete Spatial Randomness (CSR)
there are two options:
</p>

<ul>
<li><p> CSR with the same intensity of points in each point pattern;
</p>
</li>
<li><p> CSR with a different, unrelated intensity of points in each
point pattern.
</p>
</li></ul>

<p>In the first case, 
suppose <code>P</code> is a list of point patterns we want to test.
Then fit the multiple model <code>fit1 &lt;- mppm(P ~1)</code> which signifies a
Poisson point process model with a constant intensity. Then
apply <code>quadrat.test(fit1)</code>.
</p>
<p>In the second case, fit the model <code>fit2 &lt;- mppm(P ~id)</code>
which signifies a Poisson point process with a different constant
intensity for each point pattern. Then apply <code>quadrat.test(fit2)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  H &lt;- hyperframe(X=waterstriders)
  # Poisson with constant intensity for all patterns
  fit1 &lt;- mppm(X~1, H)
  quadrat.test(fit1, nx=2)

  # uniform Poisson with different intensity for each pattern
  fit2 &lt;- mppm(X ~ id, H)
  quadrat.test(fit2, nx=2)
</code></pre>

<hr>
<h2 id='quadrat.test.ppm'>Dispersion Test for Spatial Point Pattern Based on
Quadrat Counts</h2><span id='topic+quadrat.test.ppm'></span><span id='topic+quadrat.test.slrm'></span>

<h3>Description</h3>

<p>Performs a test of Complete Spatial Randomness
for a given point pattern, based on quadrat counts.
Alternatively performs a goodness-of-fit test of a fitted
inhomogeneous Poisson model.
By default performs chi-squared tests; can also perform
Monte Carlo based tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
quadrat.test(X, nx=5, ny=nx, 
                          alternative=c("two.sided", "regular", "clustered"),
                           method=c("Chisq", "MonteCarlo"),
                           conditional=TRUE, CR=1, df.est=NULL,
                           ..., 
                           xbreaks=NULL, ybreaks=NULL, tess=NULL,
                           nsim=1999)

## S3 method for class 'slrm'
quadrat.test(X, nx=5, ny=nx, 
                           alternative=c("two.sided", "regular", "clustered"),
                           method=c("Chisq", "MonteCarlo"),
                           conditional=TRUE, CR=1, df.est=NULL,
                           ..., 
                           xbreaks=NULL, ybreaks=NULL, tess=NULL,
                           nsim=1999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrat.test.ppm_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
to be subjected to the goodness-of-fit test.
Alternatively a fitted point process model (object of class
<code>"ppm"</code> or <code>"slrm"</code>) to be tested.
Alternatively <code>X</code> can be the result of applying
<code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a></code> to a point pattern.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_nx">nx</code>, <code id="quadrat.test.ppm_+3A_ny">ny</code></td>
<td>

<p>Numbers of quadrats in the <code class="reqn">x</code> and <code class="reqn">y</code> directions.
Incompatible with <code>xbreaks</code> and <code>ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_alternative">alternative</code></td>
<td>

<p>Character string (partially matched) specifying the alternative
hypothesis.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_method">method</code></td>
<td>

<p>Character string (partially matched) specifying the test to use:
either <code>method="Chisq"</code> for the chi-squared test (the default),
or <code>method="MonteCarlo"</code> for a Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_conditional">conditional</code></td>
<td>

<p>Logical.  Should the Monte Carlo test be conducted
conditionally upon the observed number of points of the pattern?
Ignored if <code>method="Chisq"</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_cr">CR</code></td>
<td>

<p>Optional. Numerical value. The exponent
for the Cressie-Read test statistic. See Details.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_df.est">df.est</code></td>
<td>

<p>Optional. Advanced use only.
The number of fitted parameters, or the
number of degrees of freedom lost by estimation of
parameters. 
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_xbreaks">xbreaks</code></td>
<td>

<p>Optional. Numeric vector giving the <code class="reqn">x</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>nx</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_ybreaks">ybreaks</code></td>
<td>

<p>Optional. Numeric vector giving the <code class="reqn">y</code> coordinates of the
boundaries of the quadrats. Incompatible with <code>ny</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_tess">tess</code></td>
<td>

<p>Tessellation (object of class <code>"tess"</code> or something acceptable
to <code><a href="spatstat.geom.html#topic+as.tess">as.tess</a></code>) determining the
quadrats. Incompatible with <code>nx, ny, xbreaks, ybreaks</code>.
</p>
</td></tr>
<tr><td><code id="quadrat.test.ppm_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulated samples to generate when
<code>method="MonteCarlo"</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform <code class="reqn">\chi^2</code> tests or Monte Carlo tests
of goodness-of-fit for a point process model, based on quadrat counts.
</p>
<p>The function <code>quadrat.test</code> is generic, with methods for
point patterns (class <code>"ppp"</code>), split point patterns
(class <code>"splitppp"</code>), point process models
(class <code>"ppm"</code> or <code>"slrm"</code>)
and quadrat count tables (class <code>"quadratcount"</code>).
</p>

<ul>
<li>
<p>if <code>X</code> is a point pattern, we test the null hypothesis
that the data pattern is a realisation of Complete Spatial
Randomness (the uniform Poisson point process). Marks in the point
pattern are ignored. (If <code>lambda</code> is given then the null
hypothesis is the Poisson process with intensity <code>lambda</code>.)
</p>
</li>
<li> 
<p>if <code>X</code> is a split point pattern, then for each of the
component point patterns (taken separately) we test 
the null hypotheses of Complete Spatial Randomness.
See <code><a href="spatstat.explore.html#topic+quadrat.test.splitppp">quadrat.test.splitppp</a></code> for documentation.
</p>
</li>
<li>
<p>If <code>X</code> is a fitted point process model, then it should be
a Poisson point process model. The 
data to which this model was fitted are extracted from the model
object, and are treated as the data point pattern for the test.
We test the null hypothesis 
that the data pattern is a realisation of the (inhomogeneous) Poisson point
process specified by <code>X</code>.
</p>
</li></ul>

<p>In all cases, the window of observation is divided
into tiles, and the number of data points in each tile is
counted, as described in <code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a></code>.
The quadrats are rectangular by default, or may be regions of arbitrary shape
specified by the argument <code>tess</code>.
The expected number of points in each quadrat is also calculated,
as determined by CSR (in the first case) or by the fitted model
(in the second case).
Then the Pearson <code class="reqn">X^2</code> statistic 
</p>
<p style="text-align: center;"><code class="reqn">
    X^2 = sum((observed - expected)^2/expected)
  </code>
</p>

<p>is computed.
</p>
<p>If <code>method="Chisq"</code> then a <code class="reqn">\chi^2</code> test of
goodness-of-fit is performed by comparing the test statistic
to the <code class="reqn">\chi^2</code> distribution
with <code class="reqn">m-k</code> degrees of freedom, where <code>m</code> is the number of
quadrats and <code class="reqn">k</code> is the number of fitted parameters
(equal to 1 for <code>quadrat.test.ppp</code>). The default is to
compute the <em>two-sided</em> <code class="reqn">p</code>-value, so that the test will
be declared significant if <code class="reqn">X^2</code> is either very large or very
small. One-sided <code class="reqn">p</code>-values can be obtained by specifying the
<code>alternative</code>. An important requirement of the
<code class="reqn">\chi^2</code> test is that the expected counts in each quadrat
be greater than 5.
</p>
<p>If <code>method="MonteCarlo"</code> then a Monte Carlo test is performed,
obviating the need for all expected counts to be at least 5.  In the
Monte Carlo test, <code>nsim</code> random point patterns are generated
from the null hypothesis (either CSR or the fitted point process
model). The Pearson <code class="reqn">X^2</code> statistic is computed as above.
The <code class="reqn">p</code>-value is determined by comparing the <code class="reqn">X^2</code>
statistic for the observed point pattern, with the values obtained
from the simulations. Again the default is to
compute the <em>two-sided</em> <code class="reqn">p</code>-value.
</p>
<p>If <code>conditional</code> is <code>TRUE</code> then the simulated samples are
generated from the multinomial distribution with the number of &ldquo;trials&rdquo;
equal to the number of observed points and the vector of probabilities
equal to the expected counts divided by the sum of the expected counts.
Otherwise the simulated samples are independent Poisson counts, with
means equal to the expected counts.
</p>
<p>If the argument <code>CR</code> is given, then instead of the
Pearson <code class="reqn">X^2</code> statistic, the Cressie-Read (1984) power divergence
test statistic
</p>
<p style="text-align: center;"><code class="reqn">
    2nI = \frac{2}{CR(CR+1)}
           \sum_i \left[ \left( \frac{X_i}{E_i} \right)^CR - 1 \right]
  </code>
</p>

<p>is computed, where <code class="reqn">X_i</code> is the <code class="reqn">i</code>th observed count
and <code class="reqn">E_i</code> is the corresponding expected count.
The value <code>CR=1</code> gives the Pearson <code class="reqn">X^2</code> statistic;
<code>CR=0</code> gives the likelihood ratio test statistic <code class="reqn">G^2</code>;
<code>CR=-1/2</code> gives the Freeman-Tukey statistic <code class="reqn">T^2</code>;
<code>CR=-1</code> gives the modified likelihood ratio test statistic <code class="reqn">GM^2</code>;
and <code>CR=-2</code> gives Neyman's modified statistic <code class="reqn">NM^2</code>.
In all cases the asymptotic distribution of this test statistic is
the same <code class="reqn">\chi^2</code> distribution as above.
</p>
<p>The return value is an object of class <code>"htest"</code>.
Printing the object gives comprehensible output
about the outcome of the test.
</p>
<p>The return value also belongs to
the special class <code>"quadrat.test"</code>. Plotting the object
will display the quadrats, annotated by their observed and expected
counts and the Pearson residuals. See the examples.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code>. See <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
for explanation. 
</p>
<p>The return value is also an object of the special class
<code>"quadrattest"</code>, and there is a plot method for this class.
See the examples.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Cressie, N. and Read, T.R.C. (1984)
Multinomial goodness-of-fit tests.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>46</b>, 440&ndash;464. 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+quadrat.test.splitppp">quadrat.test.splitppp</a></code>,
<code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a></code>,
<code><a href="spatstat.geom.html#topic+quadrats">quadrats</a></code>,
<code><a href="spatstat.random.html#topic+quadratresample">quadratresample</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>.
</p>
<p>To test a Poisson point process model against a specific alternative,
use <code><a href="#topic+anova.ppm">anova.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # fitted model: inhomogeneous Poisson
  fitx &lt;- ppm(simdat ~ x)
  quadrat.test(fitx)

  # an equivalent test (results differ due to discretisation effects):
  quadrat.test(simdat, lambda=predict(fitx), df.est=length(coef(fitx)))

</code></pre>

<hr>
<h2 id='ranef.mppm'>
Extract Random Effects from Point Process Model
</h2><span id='topic+ranef.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a list of point patterns,
extract the fixed effects of the model.
A method for <code>ranef</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'mppm'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.mppm_+3A_object">object</code></td>
<td>

<p>A fitted point process model (an object of class <code>"mppm"</code>).
</p>
</td></tr>
<tr><td><code id="ranef.mppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="nlme.html#topic+ranef">ranef</a></code>.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"mppm"</code>) produced by the 
fitting algorithm <code><a href="#topic+mppm">mppm</a></code>). This represents a
point process model that has been fitted
to a list of several point pattern datasets. See <code><a href="#topic+mppm">mppm</a></code>
for information.
</p>
<p>This function extracts the coefficients of the random effects
of the model.
</p>


<h3>Value</h3>

<p>A data frame, or list of data frames, as described in the help for
<code><a href="nlme.html#topic+ranef.lme">ranef.lme</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented in <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.mppm">fixef.mppm</a></code>,
<code><a href="#topic+coef.mppm">coef.mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> H &lt;- hyperframe(Y = waterstriders)
 # Tweak data to exaggerate differences
 H$Y[[1]] &lt;- rthin(H$Y[[1]], 0.3)

 m1 &lt;- mppm(Y ~ id,  data=H, Strauss(7))
 ranef(m1)
 m2 &lt;- mppm(Y ~ 1,  random=~1|id, data=H, Strauss(7))
 ranef(m2)
</code></pre>

<hr>
<h2 id='rdpp'>Simulation of a Determinantal Point Process</h2><span id='topic+rdpp'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a determinantal point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rdpp(eig, index, basis = "fourierbasis",
       window = boxx(rep(list(0:1), ncol(index))),
       reject_max = 10000, progress = 0, debug = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdpp_+3A_eig">eig</code></td>
<td>

<p>vector of values between 0 and 1 specifying the non-zero
eigenvalues for the process.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_index">index</code></td>
<td>

<p><code>data.frame</code> or <code>matrix</code> (or something acceptable to
<code><a href="base.html#topic+as.matrix">as.matrix</a></code>) specifying indices of the basis
functions.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_basis">basis</code></td>
<td>
<p>character string giving the name of the basis.</p>
</td></tr>
<tr><td><code id="rdpp_+3A_window">window</code></td>
<td>

<p>window (of class <code>"owin"</code>, <code>"box3"</code> or <code>"boxx"</code>)
giving the domain of the point process.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_reject_max">reject_max</code></td>
<td>

<p>integer giving the maximal number of trials for rejection sampling.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_progress">progress</code></td>
<td>

<p>integer giving the interval for making a progress report. The value
zero turns reporting off.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_debug">debug</code></td>
<td>

<p>logical value indicating whether debug informationb
should be outputted.
</p>
</td></tr>
<tr><td><code id="rdpp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- expand.grid(-2:2,-2:2)
eig &lt;- exp(-rowSums(index^2))
X &lt;- rdpp(eig, index)
X
## To simulate a det. projection p. p. with the given indices set eig=1:
XX &lt;- rdpp(1, index)
XX
</code></pre>

<hr>
<h2 id='reach'>Interaction Distance of a Point Process Model</h2><span id='topic+reach.ppm'></span><span id='topic+reach.interact'></span><span id='topic+reach.fii'></span>

<h3>Description</h3>

<p>Computes the interaction distance of a point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
reach(x, ..., epsilon=0)

  ## S3 method for class 'interact'
reach(x, ...)

  ## S3 method for class 'fii'
reach(x, ..., epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reach_+3A_x">x</code></td>
<td>
<p>Either a fitted point process model (object of class
<code>"ppm"</code>), an interpoint interaction (object of class
<code>"interact"</code>), a fitted interpoint interaction (object of
class <code>"fii"</code>) or a point process model for simulation
(object of class <code>"rmhmodel"</code>).
</p>
</td></tr>
<tr><td><code id="reach_+3A_epsilon">epsilon</code></td>
<td>

<p>Numerical threshold below which interaction is treated as zero.
See details.
</p>
</td></tr>
<tr><td><code id="reach_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>reach</code> computes the 
&lsquo;interaction distance&rsquo; or &lsquo;interaction range&rsquo; of a point process
model.
</p>
<p>The definition of the interaction distance depends on the
type of point process model. This help page explains the
interaction distance for a Gibbs point process. For other kinds of
models, see <code><a href="#topic+reach.kppm">reach.kppm</a></code> and
<code><a href="#topic+reach.dppm">reach.dppm</a></code>.
</p>
<p>For a Gibbs point process model, the interaction distance
is the shortest distance <code class="reqn">D</code> such that any two points in the
process which are separated by a distance greater than <code class="reqn">D</code> do not
interact with each other.
</p>
<p>For example, the interaction range of a Strauss process
(see <code><a href="#topic+Strauss">Strauss</a></code> or <code><a href="spatstat.random.html#topic+rStrauss">rStrauss</a></code>)
with parameters <code class="reqn">\beta,\gamma,r</code> is equal to
<code class="reqn">r</code>, unless <code class="reqn">\gamma=1</code> in which case the model is
Poisson and the interaction
range is <code class="reqn">0</code>.
The interaction range of a Poisson process is zero.
The interaction range of the Ord threshold process
(see <code><a href="#topic+OrdThresh">OrdThresh</a></code>) is infinite, since two points <em>may</em>
interact at any distance apart.
</p>
<p>The function <code>reach</code> is generic, with methods
for the case where <code>x</code> is 
</p>

<ul>
<li>
<p>a fitted point process model
(object of class <code>"ppm"</code>, usually obtained from the model-fitting
function <code><a href="#topic+ppm">ppm</a></code>);
</p>
</li>
<li>
<p>an interpoint interaction structure (object of class
<code>"interact"</code>)
created by one of the functions
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+Softcore">Softcore</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="#topic+Pairwise">Pairwise</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+LennardJones">LennardJones</a></code>,
<code><a href="#topic+Saturated">Saturated</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>
or
<code><a href="#topic+Ord">Ord</a></code>;
</p>
</li>
<li>
<p>a fitted interpoint interaction (object of class
<code>"fii"</code>)
extracted from a fitted point process model
by the command <code><a href="#topic+fitin">fitin</a></code>;
</p>
</li>
<li>
<p>a point process model for simulation (object of class
<code>"rmhmodel"</code>), usually obtained from <code><a href="spatstat.random.html#topic+rmhmodel">rmhmodel</a></code>.
</p>
</li></ul>

<p>When <code>x</code> is an <code>"interact"</code> object,
<code>reach(x)</code> returns the maximum possible interaction range
for any point process model with interaction structure given by <code>x</code>.
For example, <code>reach(Strauss(0.2))</code> returns <code>0.2</code>.
</p>
<p>When <code>x</code> is a <code>"ppm"</code> object,
<code>reach(x)</code> returns the interaction range
for the point process model represented by <code>x</code>.
For example, a fitted Strauss process model
with parameters <code>beta,gamma,r</code> will return
either <code>0</code> or <code>r</code>, depending on whether the fitted
interaction parameter <code>gamma</code> is equal or not equal to 1.
</p>
<p>For some point process models, such as the soft core process
(see <code><a href="#topic+Softcore">Softcore</a></code>), the interaction distance is
infinite, because the interaction terms are positive for all
pairs of points. A practical solution is to compute 
the distance at which the interaction contribution
from a pair of points falls below a threshold <code>epsilon</code>,
on the scale of the log conditional intensity. This is done
by setting the argument <code>epsilon</code> to a positive value.
</p>


<h3>Value</h3>

<p>The interaction distance, or <code>NA</code> if this cannot be
computed from the information given.
</p>


<h3>Other types of models</h3>

<p>Methods for <code>reach</code> are also defined for
point process models of class <code>"kppm"</code> and <code>"dppm"</code>.
Their technical definition is different from this one.
See <code><a href="#topic+reach.kppm">reach.kppm</a></code> and <code><a href="#topic+reach.dppm">reach.dppm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+Softcore">Softcore</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="#topic+Pairwise">Pairwise</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+LennardJones">LennardJones</a></code>,
<code><a href="#topic+Saturated">Saturated</a></code>,
<code><a href="#topic+OrdThresh">OrdThresh</a></code>,
<code><a href="#topic+Ord">Ord</a></code>.
</p>
<p><code><a href="spatstat.random.html#topic+reach.rmhmodel">reach.rmhmodel</a></code>
</p>
<p>See <code><a href="#topic+reach.kppm">reach.kppm</a></code> and <code><a href="#topic+reach.dppm">reach.dppm</a></code>
for other types of point process models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    reach(Poisson())
    # returns 0

    reach(Strauss(r=7))
    # returns 7
    fit &lt;- ppm(swedishpines ~ 1, Strauss(r=7))
    reach(fit)
    # returns 7

    reach(OrdThresh(42))
    # returns Inf
    
    reach(MultiStrauss(matrix(c(1,3,3,1),2,2)))
    # returns 3
</code></pre>

<hr>
<h2 id='reach.dppm'>Range of Interaction for a Determinantal Point Process Model</h2><span id='topic+reach.dppm'></span><span id='topic+reach.detpointprocfamily'></span>

<h3>Description</h3>

<p>Returns the range of interaction for a determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
reach(x, ...)

  ## S3 method for class 'detpointprocfamily'
reach(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reach.dppm_+3A_x">x</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code> or <code>"dppm"</code>.</p>
</td></tr>
<tr><td><code id="reach.dppm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the range function
of the given model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The range of interaction for a determinantal point
process model may defined as the smallest number <code class="reqn">R</code> such that
<code class="reqn">g(r)=1</code> for all <code class="reqn">r\ge R</code>, where <code class="reqn">g</code> is the pair
correlation function. For many models the range is infinite, but one
may instead use a value where the pair correlation function is
sufficiently close to 1. For example in the Matern model this defaults
to finding <code class="reqn">R</code> such that <code class="reqn">g(R)=0.99</code>.
</p>


<h3>Value</h3>

<p>Numeric</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reach(dppMatern(lambda=100, alpha=.01, nu=1, d=2))
</code></pre>

<hr>
<h2 id='reach.kppm'>Range of Interaction for a Cox or Cluster Point Process Model</h2><span id='topic+reach.kppm'></span>

<h3>Description</h3>

<p>Returns the range of interaction for a Cox or cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
reach(x, ..., epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reach.kppm_+3A_x">x</code></td>
<td>

<p>Fitted point process model of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="reach.kppm_+3A_epsilon">epsilon</code></td>
<td>

<p>Optional numerical value. Differences smaller than
<code>epsilon</code> are treated as zero.
</p>
</td></tr>
<tr><td><code id="reach.kppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the range function
of the given model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The range of interaction for a fitted point process model
of class <code>"kppm"</code>
may defined as the smallest number <code class="reqn">R</code> such that
<code class="reqn">g(r)=1</code> for all <code class="reqn">r\ge R</code>, where <code class="reqn">g</code> is the pair
correlation function. 
</p>
<p>For many models the range is infinite, but one
may instead use a value where the pair correlation function is
sufficiently close to 1. The argument <code>epsilon</code> specifies the
tolerance; there is a sensible default.
</p>


<h3>Value</h3>

<p>Numeric</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood ~ 1)
  reach(fit)
</code></pre>

<hr>
<h2 id='relrisk.ppm'>
Parametric Estimate of Spatially-Varying Relative Risk
</h2><span id='topic+relrisk.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a multitype point pattern,
this function computes the fitted spatially-varying probability
of each type of point, or the ratios of such probabilities,
according to the fitted model. Optionally the standard errors of the estimates
are also computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppm'
relrisk(X, ...,
                     at = c("pixels", "points"),
                     relative = FALSE, se = FALSE,
                     casecontrol = TRUE, control = 1, case,
                     ngrid = NULL, window = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrisk.ppm_+3A_x">X</code></td>
<td>

<p>A fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the probability values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_relative">relative</code></td>
<td>

<p>Logical.
If <code>FALSE</code> (the default) the algorithm
computes the probabilities of each type of point.
If <code>TRUE</code>, it computes the    
<em>relative risk</em>, the ratio of probabilities
of each type relative to the probability of a control.
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to compute standard errors
as well.
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_casecontrol">casecontrol</code></td>
<td>

<p>Logical. Whether to treat a bivariate point pattern
as consisting of cases and controls, and return only the
probability or relative risk of a case.
Ignored if there are more than 2 types of points.
See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_control">control</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a control. 
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_case">case</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a case (rather than a control)
in a bivariate point pattern.
This is an alternative to the argument <code>control</code>
in a bivariate point pattern. 
Ignored if there are more than 2 types of points.
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_ngrid">ngrid</code></td>
<td>

<p>Optional. Dimensions of a rectangular grid of locations
inside <code>window</code> where the predictions should be computed.
An integer, or an integer vector of length 2,
specifying the number of grid points in the <code class="reqn">y</code> and <code class="reqn">x</code>
directions.
(Applies only when <code>at="pixels"</code>.)
</p>
</td></tr>
<tr><td><code id="relrisk.ppm_+3A_window">window</code></td>
<td>

<p>Optional. A window (object of class <code>"owin"</code>)
<em>delimiting</em> the locations where predictions
should be computed. Defaults to the window of the
original data used to fit the model <code>object</code>.
(Applies only when <code>at="pixels"</code>.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code><a href="spatstat.explore.html#topic+relrisk">relrisk</a></code> is generic and can be used to
estimate relative risk in different ways.
</p>
<p>This function <code>relrisk.ppm</code> is the method for fitted point
process models (class <code>"ppm"</code>). It computes <em>parametric</em>
estimates of relative risk, using the fitted model.
</p>
<p>If <code>X</code>  is a bivariate point pattern
(a multitype point pattern consisting of two types of points)
then by default,
the points of the first type (the first level of <code>marks(X)</code>)
are treated as controls or non-events, and points of the second type
are treated as cases or events. Then by default this command computes
the spatially-varying <em>probability</em> of a case,
i.e. the probability <code class="reqn">p(u)</code>
that a point at spatial location <code class="reqn">u</code>
will be a case. If <code>relative=TRUE</code>, it computes the
spatially-varying <em>relative risk</em> of a case relative to a
control, <code class="reqn">r(u) = p(u)/(1- p(u))</code>.
</p>
<p>If <code>X</code> is a multitype point pattern with <code class="reqn">m &gt; 2</code> types,
or if <code>X</code> is a bivariate point pattern
and <code>casecontrol=FALSE</code>,
then by default this command computes, for each type <code class="reqn">j</code>,
a nonparametric estimate of
the spatially-varying <em>probability</em> of an event of type <code class="reqn">j</code>.
This is the probability <code class="reqn">p_j(u)</code>
that a point at spatial location <code class="reqn">u</code>
will belong to type <code class="reqn">j</code>.
If <code>relative=TRUE</code>, the command computes the
<em>relative risk</em> of an event of type <code class="reqn">j</code>
relative to a control,
<code class="reqn">r_j(u) = p_j(u)/p_k(u)</code>,
where events of type <code class="reqn">k</code> are treated as controls.
The argument <code>control</code> determines which type <code class="reqn">k</code>
is treated as a control.
</p>
<p>If <code>at = "pixels"</code> the calculation is performed for
every spatial location <code class="reqn">u</code> on a fine pixel grid, and the result
is a pixel image representing the function <code class="reqn">p(u)</code>
or a list of pixel images representing the functions 
<code class="reqn">p_j(u)</code> or <code class="reqn">r_j(u)</code>
for <code class="reqn">j = 1,\ldots,m</code>.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>NA</code>.
</p>
<p>If <code>at = "points"</code> the calculation is performed
only at the data points <code class="reqn">x_i</code>. By default
the result is a vector of values
<code class="reqn">p(x_i)</code> giving the estimated probability of a case
at each data point, or a matrix of values 
<code class="reqn">p_j(x_i)</code> giving the estimated probability of
each possible type <code class="reqn">j</code> at each data point.
If <code>relative=TRUE</code> then the relative risks
<code class="reqn">r(x_i)</code> or <code class="reqn">r_j(x_i)</code> are
returned.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>Inf</code>.
</p>
<p>Probabilities and risks are computed from the fitted intensity of the model,
using <code><a href="#topic+predict.ppm">predict.ppm</a></code>.
If <code>se=TRUE</code> then standard errors will also be computed,
based on asymptotic theory, using <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>.
</p>


<h3>Value</h3>

<p>If <code>se=FALSE</code> (the default), the format is described below.
If <code>se=TRUE</code>, the result is a list of two entries,
<code>estimate</code> and <code>SE</code>, each having the format described below.
</p>
<p>If <code>X</code> consists of only two types of points,
and if <code>casecontrol=TRUE</code>,
the result is a pixel image (if <code>at="pixels"</code>)
or a vector (if <code>at="points"</code>).
The pixel values or vector values
are the probabilities of a case if <code>relative=FALSE</code>,
or the relative risk of a case (probability of a case divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>X</code> consists of more than two types of points,
or if <code>casecontrol=FALSE</code>, the result is:
</p>

<ul>
<li><p> (if <code>at="pixels"</code>)
a list of pixel images, with one image for each possible type of point.
The result also belongs to the class <code>"solist"</code> so that it can
be printed and plotted.
</p>
</li>
<li>
<p>(if <code>at="points"</code>)
a matrix of probabilities, with rows corresponding to
data points <code class="reqn">x_i</code>, and columns corresponding
to types <code class="reqn">j</code>.
</p>
</li></ul>

<p>The pixel values or matrix entries
are the probabilities of each type of point if <code>relative=FALSE</code>,
or the relative risk of each type (probability of each type divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>relative=FALSE</code>, the resulting values always lie between 0
and 1. If <code>relative=TRUE</code>, the results are either non-negative
numbers, or the values <code>Inf</code> or <code>NA</code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>There is another method <code><a href="spatstat.explore.html#topic+relrisk.ppp">relrisk.ppp</a></code> for point pattern datasets
which computes <em>nonparametric</em> estimates of relative risk
by kernel smoothing.
</p>
<p>See also
<code><a href="spatstat.explore.html#topic+relrisk">relrisk</a></code>, 
<code><a href="spatstat.explore.html#topic+relrisk.ppp">relrisk.ppp</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(chorley ~ marks * (x+y))
  rr &lt;- relrisk(fit, relative=TRUE, control="lung", se=TRUE)
  plot(rr$estimate)
  plot(rr$SE)
  rrX &lt;- relrisk(fit, at="points", relative=TRUE, control="lung")
</code></pre>

<hr>
<h2 id='repul.dppm'>
Repulsiveness Index of a Determinantal Point Process Model
</h2><span id='topic+repul'></span><span id='topic+repul.dppm'></span>

<h3>Description</h3>

<p>Computes a measure of the degree of repulsion between points
in a determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repul(model, ...)

## S3 method for class 'dppm'
repul(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repul.dppm_+3A_model">model</code></td>
<td>

<p>A fitted point process model
of determinantal type (object of class <code>"dppm"</code>).
</p>
</td></tr>
<tr><td><code id="repul.dppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The repulsiveness index <code class="reqn">\mu</code> of a determinantal
point process model was defined by
Lavancier, Moller and Rubak (2015) as
</p>
<p style="text-align: center;"><code class="reqn">
    \mu = \lambda \int (1- g(x)) \, dx
  </code>
</p>

<p>where <code class="reqn">\lambda</code> is the intensity of the model and
<code class="reqn">g(x)</code> is the pair correlation function, and
the integral is taken over all two-dimensional vectors <code class="reqn">x</code>.
</p>
<p>Values of <code class="reqn">\mu</code> are dimensionless.
Larger values of <code class="reqn">\mu</code> indicate stronger repulsion
between points.
</p>
<p>If the model is stationary, the result is a single number.
</p>
<p>If the model is not stationary, 
the result is a pixel image (obtained by multiplying
the spatially-varying intensity by the integral defined above).
</p>


<h3>Value</h3>

<p>A numeric value or a pixel image.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Lavancier, F., Moller, J.  and Rubak, E. (2015),
Determinantal point process models and statistical inference.
<em>Journal of Royal Statistical Society:
Series B (Statistical Methodology)</em>,
<b>77</b>, 853&ndash;877.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  jpines &lt;- residualspaper$Fig1
  
  fit &lt;- dppm(jpines ~ 1, dppGauss)
  repul(fit)
</code></pre>

<hr>
<h2 id='residualMeasure'>
Residual Measure for an Observed Point Pattern and a Fitted Intensity
</h2><span id='topic+residualMeasure'></span>

<h3>Description</h3>

<p>Given a point pattern and an estimate of its intensity function
obtained in any fashion, compute the residual measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualMeasure(Q, lambda,
               type = c("raw", "inverse", "Pearson", "pearson"),
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualMeasure_+3A_q">Q</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>)
or quadrature scheme (object of class <code>"quad"</code>).
</p>
</td></tr>
<tr><td><code id="residualMeasure_+3A_lambda">lambda</code></td>
<td>

<p>Predicted intensity. An image (object of class <code>"im"</code>)
or a list of images.
</p>
</td></tr>
<tr><td><code id="residualMeasure_+3A_type">type</code></td>
<td>

<p>Character string (partially matched) specifying the type of residuals.
</p>
</td></tr>
<tr><td><code id="residualMeasure_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>
if <code>Q</code> is a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command constructs the residual measure
for the model in which <code>Q</code> is the observed point pattern
or quadrature scheme, and <code>lambda</code> is the estimated intensity
function obtained in some fashion.
</p>


<h3>Value</h3>

<p>A measure (object of class <code>"msr"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## nonparametric regression estimate of intensity
  ## as a function of terrain elevation
  f &lt;- rhohat(bei, bei.extra$elev)
  ## predicted intensity as a function of location
  lam &lt;- predict(f)
  ## residuals
  res &lt;- residualMeasure(bei, lam)
  res
  plot(res)
</code></pre>

<hr>
<h2 id='residuals.dppm'>
Residuals for Fitted Determinantal Point Process Model
</h2><span id='topic+residuals.dppm'></span>

<h3>Description</h3>

<p>Given a determinantal point process model fitted to a point pattern,
compute residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.dppm_+3A_object">object</code></td>
<td>

<p>The fitted determinatal point process model (an object of class <code>"dppm"</code>)
for which residuals should be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.dppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the intensity component of the model using
<code><a href="#topic+as.ppm">as.ppm</a></code> and then applies <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
to compute the residuals.
</p>
<p>Use <code><a href="#topic+plot.msr">plot.msr</a></code> to plot the residuals directly.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code>
representing a signed measure or vector-valued measure
(see <code><a href="#topic+msr">msr</a></code>). This object can be plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic+dppm">dppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- dppm(swedishpines ~ x, dppGauss, method="c")
   rr &lt;- residuals(fit)
</code></pre>

<hr>
<h2 id='residuals.kppm'>
Residuals for Fitted Cox or Cluster Point Process Model
</h2><span id='topic+residuals.kppm'></span>

<h3>Description</h3>

<p>Given a Cox or cluster point process model fitted to a point pattern,
compute residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.kppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"kppm"</code>)
for which residuals should be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.kppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the intensity component of the model using
<code><a href="#topic+as.ppm">as.ppm</a></code> and then applies <code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
to compute the residuals.
</p>
<p>Use <code><a href="#topic+plot.msr">plot.msr</a></code> to plot the residuals directly.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code> 
representing a signed measure or vector-valued measure
(see <code><a href="#topic+msr">msr</a></code>). This object can be plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic+kppm">kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- kppm(redwood ~ x, "Thomas")
   rr &lt;- residuals(fit)
</code></pre>

<hr>
<h2 id='residuals.mppm'>Residuals for Point Process Model Fitted to Multiple Point Patterns</h2><span id='topic+residuals.mppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to multiple point patterns,
compute residuals for each pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mppm'
residuals(object, type = "raw", ..., 
                             fittedvalues = fitted.mppm(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.mppm_+3A_object">object</code></td>
<td>
<p>Fitted point process model (object of class <code>"mppm"</code>).</p>
</td></tr>
<tr><td><code id="residuals.mppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="residuals.mppm_+3A_type">type</code></td>
<td>
<p>Type of residuals: either <code>"raw"</code>, <code>"pearson"</code>
or <code>"inverse"</code>. Partially matched.</p>
</td></tr>
<tr><td><code id="residuals.mppm_+3A_fittedvalues">fittedvalues</code></td>
<td>
<p>Advanced use only.
Fitted values of the model to be used in the calculation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Baddeley et al (2005) defined residuals for the fit of
a point process model to spatial point pattern data.
For an explanation of these residuals, see the help file for
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>.
</p>
<p>This function computes the residuals
for a point process model fitted to <em>multiple</em> point patterns.
The <code>object</code> should be an object of class <code>"mppm"</code> obtained
from <code><a href="#topic+mppm">mppm</a></code>.
</p>
<p>The return value is a list.
The number of entries in the list equals the
number of point patterns in the original data. Each entry in the list
has the same format as the output of
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>.
That is, each entry in the list is a signed measure (object of
class <code>"msr"</code>) giving the residual measure for the corresponding
point pattern. 
</p>


<h3>Value</h3>

<p>A list of signed measures (objects of class <code>"msr"</code>)
giving the residual measure for each of the original point patterns.
See Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="#topic+residuals.mppm">residuals.mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fit &lt;- mppm(Bugs ~ x, hyperframe(Bugs=waterstriders))
    r &lt;- residuals(fit)
    # compute total residual for each point pattern
    rtot &lt;- sapply(r, integral.msr)
    # standardise the total residuals
    areas &lt;- sapply(windows.mppm(fit), area.owin)
    rtot/sqrt(areas)
</code></pre>

<hr>
<h2 id='residuals.ppm'>
Residuals for Fitted Point Process Model
</h2><span id='topic+residuals.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern,
compute residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
residuals(object, type="raw", ...,
                check=TRUE, drop=FALSE,
                fittedvalues=NULL, 
                new.coef=NULL, dropcoef=FALSE,
                quad=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.ppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which residuals should be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_type">type</code></td>
<td>

<p>String indicating the type of residuals to be calculated.
Current options are
<code>"raw"</code>, <code>"inverse"</code>, <code>"pearson"</code> and <code>"score"</code>.
A partial match is adequate.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_check">check</code></td>
<td>

<p>Logical value indicating whether to check the internal format
of <code>object</code>. If there is any possibility that this object
has been restored from a dump file, or has otherwise lost track of
the environment where it was originally computed, set
<code>check=TRUE</code>. 
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical value determining whether to delete quadrature points
that were not used to fit the model. See <code><a href="#topic+quad.ppm">quad.ppm</a></code> for
explanation. 
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_fittedvalues">fittedvalues</code></td>
<td>

<p>Vector of fitted values for the conditional intensity at 
the quadrature points,
from which the residuals will be computed. 
For expert use only.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>Optional. Numeric vector of coefficients for the model,
replacing <code>coef(object)</code>.
See the section on Modified Residuals below.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_dropcoef">dropcoef</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
<tr><td><code id="residuals.ppm_+3A_quad">quad</code></td>
<td>

<p>Optional. Data specifying how to re-fit the model.
A list of arguments passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code>.
See the section on Modified Residuals below.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes several kinds of residuals for the fit of
a point process model to a spatial point pattern dataset
(Baddeley et al, 2005).
Use <code><a href="#topic+plot.msr">plot.msr</a></code> to plot the residuals directly,
or <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>
to produce diagnostic plots based on these residuals.
</p>
<p>The argument <code>object</code> must be a fitted point process model
(object of class <code>"ppm"</code>). Such objects are produced by the maximum
pseudolikelihood fitting algorithm <code><a href="#topic+ppm">ppm</a></code>.
This fitted model object contains complete
information about the original data pattern. 
</p>
<p>Residuals are attached both to the data points and to some
other points in the window of observation (namely, to the dummy
points of the quadrature scheme used to fit the model).
If the fitted model is correct, then the sum of the 
residuals over all (data and dummy) points in a spatial region <code class="reqn">B</code>
has mean zero. For further explanation, see Baddeley et al (2005).
</p>
<p>The type of residual
is chosen by the argument <code>type</code>. Current options are
</p>

<dl>
<dt><code>"raw"</code>:</dt><dd>
<p>the raw residuals
</p>
<p style="text-align: center;"><code class="reqn">
	r_j = z_j - w_j \lambda_j
      </code>
</p>

<p>at the quadrature points <code class="reqn">u_j</code>,
where <code class="reqn">z_j</code> is the indicator equal to 1 if <code class="reqn">u_j</code>
is a data point and 0 if <code class="reqn">u_j</code> is a dummy point;
<code class="reqn">w_j</code> is the quadrature weight attached to
<code class="reqn">u_j</code>; and
</p>
<p style="text-align: center;"><code class="reqn">\lambda_j = \hat\lambda(u_j,x)</code>
</p>

<p>is the conditional intensity of the fitted model at <code class="reqn">u_j</code>.
These are the spatial analogue of the martingale residuals
of a one-dimensional counting process.
</p>
</dd>
<dt><code>"inverse"</code>:</dt><dd>
<p>the &lsquo;inverse-lambda&rsquo; residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r^{(I)}_j = \frac{r_j}{\lambda_j}
        = \frac{z_j}{\lambda_j} - w_j
      </code>
</p>

<p>obtained by dividing the raw residuals by 
the fitted conditional intensity. These are 
a counterpart of the exponential energy marks (see <code><a href="#topic+eem">eem</a></code>).
</p>
</dd>
<dt><code>"pearson"</code>:</dt><dd>
<p>the Pearson residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r^{(P)}_j = \frac{r_j}{\sqrt{\lambda_j}}
        = \frac{z_j}{\sqrt{\lambda_j}}
        - w_j \sqrt{\lambda_j}
      </code>
</p>

<p>obtained by dividing the raw residuals by the
square root of the fitted conditional intensity.
The Pearson residuals are standardised, in the sense
that if the model (true and fitted) is Poisson,
then the sum of the Pearson residuals in a spatial region <code class="reqn">B</code>
has variance equal to the area of <code class="reqn">B</code>.
</p>
</dd>
<dt><code>"score"</code>:</dt><dd>
<p>the score residuals (Baddeley et al, 2005)
</p>
<p style="text-align: center;"><code class="reqn">
	r_j = (z_j - w_j \lambda_j) x_j
      </code>
</p>

<p>obtained by multiplying the raw residuals <code class="reqn">r_j</code>
by the covariates <code class="reqn">x_j</code> for quadrature point <code class="reqn">j</code>.
The score residuals always sum to zero.
</p>
</dd>
</dl>

<p>The result of <code>residuals.ppm</code> is a measure
(object of class <code>"msr"</code>).
Use <code><a href="#topic+plot.msr">plot.msr</a></code> to plot the residuals directly,
or <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> to produce diagnostic plots
based on these residuals.
Use <code><a href="#topic+integral.msr">integral.msr</a></code> to compute the total residual.
</p>
<p>By default, 
the window of the measure is the same as the original window
of the data. If <code>drop=TRUE</code> then the window is the
domain of integration of the pseudolikelihood or composite likelihood.
This only matters when the model <code>object</code> was fitted using
the border correction: in that case, if <code>drop=TRUE</code> the
window of the residuals is the erosion of the original data window
by the border correction distance <code>rbord</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"msr"</code> 
representing a signed measure or vector-valued measure
(see <code><a href="#topic+msr">msr</a></code>). This object can be plotted.
</p>


<h3>Modified Residuals</h3>

<p>Sometimes we want to modify the calculation of residuals by using
different values for the model parameters. This capability is
provided by the arguments <code>new.coef</code> and <code>quad</code>.
</p>
<p>If <code>new.coef</code> is given, then the residuals will be computed
by taking the model parameters to be <code>new.coef</code>.
This should be a numeric vector
of the same length as the vector of fitted model parameters
<code>coef(object)</code>. 
</p>
<p>If <code>new.coef</code> is missing and <code>quad</code> is given,
then the model parameters will
be determined by re-fitting the model using a new
quadrature scheme specified by <code>quad</code>. 
Residuals will be computed for the
original model <code>object</code> using these new parameter values.
</p>
<p>The argument <code>quad</code> should normally be
a list of arguments in <code>name=value</code> format that will be
passed to <code><a href="spatstat.geom.html#topic+quadscheme">quadscheme</a></code> (together with
the original data points) to determine the new quadrature scheme.
It may also be a quadrature scheme (object of class
<code>"quad"</code>) to which the model should be fitted, or a
point pattern (object of class <code>"ppp"</code>) specifying the
<em>dummy points</em> in a new quadrature scheme.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells, ~x, Strauss(r=0.15))

   # Pearson residuals
   rp &lt;- residuals(fit, type="pe")
   rp

   # simulated data
   X &lt;- rStrauss(100,0.7,0.05)
   # fit Strauss model 
   fit &lt;- ppm(X, ~1, Strauss(0.05))
   res.fit &lt;- residuals(fit)

   # check that total residual is 0 
   integral.msr(residuals(fit, drop=TRUE))

   # true model parameters
   truecoef &lt;- c(log(100), log(0.7))
   res.true &lt;- residuals(fit, new.coef=truecoef)  
</code></pre>

<hr>
<h2 id='residuals.rppm'>
Residuals for Recursively Partitioned Point Process Model
</h2><span id='topic+residuals.rppm'></span>

<h3>Description</h3>

<p>Given a point process model
that was fitted to a point pattern
by recursive partitioning (regression tree) methods,
compute the residual measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'rppm'
residuals(object,
                           type=c("raw", "inverse", "Pearson"),
                           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.rppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which residuals should be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.rppm_+3A_type">type</code></td>
<td>

<p>String (partially matched)
indicating the type of residuals to be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.rppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the residual measure for a
point process model that was fitted to point pattern data
by recursive partitioning of the covariates.
</p>
<p>The argument <code>object</code> must be a fitted model object
of class <code>"rppm"</code>). Such objects are
created by the fitting algorithm <code><a href="#topic+rppm">rppm</a></code>.
</p>
<p>The type of residual is chosen by the argument <code>type</code>.
</p>


<h3>Value</h3>

<p>A measure (object of class <code>"msr"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- rppm(bei ~ elev + grad, data=bei.extra)
  res &lt;- residuals(fit)
  plot(res)
</code></pre>

<hr>
<h2 id='residuals.slrm'>
Residuals for Fitted Spatial Logistic Regression Model
</h2><span id='topic+residuals.slrm'></span>

<h3>Description</h3>

<p>Given a spatial logistic regression model fitted to a point pattern,
compute the residuals for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
residuals(object,
                           type=c("raw", "deviance", "pearson", "working", 
                                  "response", "partial", "score"),
                           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.slrm_+3A_object">object</code></td>
<td>

<p>The fitted point process model (an object of class <code>"ppm"</code>)
for which residuals should be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.slrm_+3A_type">type</code></td>
<td>

<p>String (partially matched)
indicating the type of residuals to be calculated.
</p>
</td></tr>
<tr><td><code id="residuals.slrm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes several kinds of residuals for the fit of
a spatial logistic regression model to a spatial point pattern dataset.
</p>
<p>The argument <code>object</code> must be a fitted spatial logistic
regression model (object of class <code>"slrm"</code>). Such objects are
created by the fitting algorithm <code><a href="#topic+slrm">slrm</a></code>.
</p>
<p>The residuals are computed for each pixel
that was used to fit the original model. The residuals are
returned as a pixel image (if the residual values are scalar),
or a list of pixel images (if the residual values are vectors).
</p>
<p>The type of residual is chosen by the argument <code>type</code>.
</p>
<p>For a given pixel, suppose <code class="reqn">p</code> is the fitted probability of
presence of a point, and <code class="reqn">y</code> is the presence indicator
(equal to 1 if the pixel contains any data points, and equal to 0
otherwise). Then 
</p>

<ul>
<li> <p><code>type="raw"</code> or <code>type="response"</code> specifies
the response residual
</p>
<p style="text-align: center;"><code class="reqn">r = y - p</code>
</p>

</li>
<li> <p><code>type="pearson"</code> is the Pearson residual
</p>
<p style="text-align: center;"><code class="reqn">
      r_P = \frac{y - p}{\sqrt{p (1-p)}}
    </code>
</p>

</li>
<li> <p><code>type="deviance"</code> is the deviance residual
</p>
<p style="text-align: center;"><code class="reqn">
      r_D = (-1)^{y+1} \sqrt{-2(y log p + (1-y) log(1-p))}
    </code>
</p>

</li>
<li> <p><code>type="score"</code> specifies the score residuals
</p>
<p style="text-align: center;"><code class="reqn">
      r_S = (y-p) x
    </code>
</p>

<p>where <code>x</code> is the vector of canonical covariate values
for the pixel
</p>
</li>
<li> <p><code>type="working"</code> specifies the working residuals
as defined in <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>
</p>
</li>
<li> <p><code>type="partial"</code> specifies the partial residuals
as defined in <code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A pixel image (if the residual values are scalar),
or a list of pixel images (if the residual values are vectors).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>,
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   d &lt;- if(interactive()) 128 else 32
   H &lt;- unmark(humberside)
   fit &lt;- slrm(H ~ x + y, dimyx=d)

   plot(residuals(fit))

   plot(residuals(fit, type="score"))
</code></pre>

<hr>
<h2 id='response'>
Extract the Values of the Response from a Fitted Model
</h2><span id='topic+response'></span><span id='topic+response.lm'></span><span id='topic+response.glm'></span><span id='topic+response.ppm'></span><span id='topic+response.dppm'></span><span id='topic+response.kppm'></span><span id='topic+response.slrm'></span><span id='topic+response.rppm'></span><span id='topic+response.mppm'></span>

<h3>Description</h3>

<p>Given a fitted model (of any kind)
extract the values of the response variable.
For a point process model, the observed point pattern is extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response(object)

## S3 method for class 'lm'
response(object)

## S3 method for class 'glm'
response(object)

## S3 method for class 'ppm'
response(object)

## S3 method for class 'kppm'
response(object)

## S3 method for class 'dppm'
response(object)

## S3 method for class 'slrm'
response(object)

## S3 method for class 'rppm'
response(object)

## S3 method for class 'mppm'
response(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_+3A_object">object</code></td>
<td>

<p>A fitted model (object of class
<code>"lm"</code>,
<code>"glm"</code>,
<code>"ppm"</code>,
<code>"kppm"</code>,
<code>"dppm"</code>,
<code>"slrm"</code>, 
<code>"rppm"</code>, or
<code>"mppm"</code>
or some other class).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fitted linear models of class <code>"lm"</code>
and fitted generalized linear models of class <code>"glm"</code>,
the numerical values of the response variable are extracted
if they are available, and otherwise <code>NULL</code> is returned.
</p>
<p>For fitted point process models of class
<code>"ppm"</code>,
<code>"kppm"</code>,
<code>"dppm"</code>,
<code>"slrm"</code>, <code>"lppm"</code> or <code>"rppm"</code>,
the original data point pattern is extracted.
</p>
<p>For a fitted point process model of class <code>"mppm"</code>,
the list of original data point patterns is extracted.
</p>


<h3>Value</h3>

<p>For <code>response.lm</code> and <code>response.glm</code>,
a numeric vector, or <code>NULL</code>.
</p>
<p>For
<code>response.ppm</code>,
<code>response.kppm</code>,
<code>response.dppm</code>,
<code>response.slrm</code>
and <code>response.rppm</code>,
a two-dimensional spatial point pattern (class <code>"ppp"</code>).
</p>
<p>For <code>response.mppm</code>, a list of
two-dimensional spatial point patterns (objects of class
<code>"ppp"</code>).
The list also belongs to classes <code>"solist"</code> and <code>"ppplist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(cells ~ x)
  response(fit)  
</code></pre>

<hr>
<h2 id='rex'>
Richardson Extrapolation
</h2><span id='topic+rex'></span>

<h3>Description</h3>

<p>Performs Richardson Extrapolation on a sequence of
approximate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rex(x, r = 2, k = 1, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rex_+3A_x">x</code></td>
<td>

<p>A numeric vector or matrix,
whose columns are successive estimates or approximations
to a vector of parameters.
</p>
</td></tr>
<tr><td><code id="rex_+3A_r">r</code></td>
<td>

<p>A number greater than 1.
The ratio of successive step sizes.
See Details.
</p>
</td></tr>
<tr><td><code id="rex_+3A_k">k</code></td>
<td>

<p>Integer. The order of convergence assumed. See Details.
</p>
</td></tr>
<tr><td><code id="rex_+3A_recursive">recursive</code></td>
<td>

<p>Logical value indicating whether to perform one step of
Richardson extrapolation (<code>recursive=FALSE</code>, the default)
or repeat the extrapolation procedure until a best estimate
is obtained (<code>recursive=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Richardson extrapolation is a general technique for improving numerical
approximations, often used in numerical integration (Brezinski and
Zaglia, 1991). It can also be used to improve parameter estimates
in statistical models (Baddeley and Turner, 2014). 
</p>
<p>The successive columns of <code>x</code> are assumed to
have been obtained using approximations with step sizes
<code class="reqn">a, a/r, a/r^2, \ldots</code>
where <code class="reqn">a</code> is the initial step size (which does not need to be
specified).
</p>
<p>Estimates based on a step size <code class="reqn">s</code> are assumed to have an error
of order <code class="reqn">s^k</code>.
</p>
<p>Thus, the default values <code>r=2</code> and <code>k=1</code> imply that the errors in
the second column of <code>x</code> should be roughly <code class="reqn">(1/r)^k = 1/2</code> as large
as the errors in the first column, and so on.
</p>


<h3>Value</h3>

<p>A matrix whose columns contain a sequence of improved estimates.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2014)
Bias correction for parameter estimates of spatial point process models.
<em>Journal of Statistical Computation and Simulation</em>
<b>84</b>, 1621&ndash;1643.
DOI: 10.1080/00949655.2012.755976
</p>
<p>Brezinski, C. and Zaglia, M.R. (1991)
<em>Extrapolation Methods. Theory and Practice</em>.
North-Holland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bc">bc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # integrals of sin(x) and cos(x) from 0 to pi
   # correct answers: 2, 0
   est &lt;- function(nsteps) {
     xx &lt;- seq(0, pi, length=nsteps)
     ans &lt;- pi * c(mean(sin(xx)), mean(cos(xx)))
     names(ans) &lt;- c("sin", "cos")
     ans
   }
   X &lt;- cbind(est(10), est(20), est(40))
   X
   rex(X)
   rex(X, recursive=TRUE)

   # fitted Gibbs point process model
   fit0 &lt;- ppm(cells ~ 1, Strauss(0.07), nd=16)
   fit1 &lt;- update(fit0, nd=32)
   fit2 &lt;- update(fit0, nd=64)
   co &lt;- cbind(coef(fit0), coef(fit1), coef(fit2))
   co 
   rex(co, k=2, recursive=TRUE)
</code></pre>

<hr>
<h2 id='rhohat.ppm'>
Nonparametric Estimate of Intensity as Function of a Covariate
</h2><span id='topic+rhohat.ppm'></span><span id='topic+rhohat.slrm'></span>

<h3>Description</h3>

<p>Computes a nonparametric estimate of the intensity of a point process,
as a function of a (continuous) spatial covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
rhohat(object, covariate, ...,
       weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
                  "mountain", "valley", "piecewise"),
       subset=NULL, 
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,
       dimyx=NULL, eps=NULL,
       rule.eps = c("adjust.eps", "grow.frame", "shrink.frame"),
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)

## S3 method for class 'slrm'
rhohat(object, covariate, ...,
       weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
                  "mountain", "valley", "piecewise"),
       subset=NULL, 
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhohat.ppm_+3A_object">object</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>),
a quadrature scheme (object of class <code>"quad"</code>)
or a fitted point process model (object of class <code>"ppm"</code>,
<code>"slrm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_covariate">covariate</code></td>
<td>

<p>Either a <code>function(x,y)</code> or a pixel image (object of
class <code>"im"</code>) providing the values of the covariate at any
location.
Alternatively one of the strings <code>"x"</code> or <code>"y"</code>
signifying the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_weights">weights</code></td>
<td>

<p>Optional weights attached to the data points.
Either a numeric vector of weights for each data point,
or a pixel image (object of class <code>"im"</code>) or
a <code>function(x,y)</code> providing the weights.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_method">method</code></td>
<td>

<p>Character string determining the estimation method. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_horvitz">horvitz</code></td>
<td>

<p>Logical value indicating whether to use Horvitz-Thompson weights.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_smoother">smoother</code></td>
<td>

<p>Character string determining the smoothing algorithm
and the type of curve that will be estimated. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_subset">subset</code></td>
<td>

<p>Optional. A spatial window (object of class <code>"owin"</code>)
specifying a subset of the data, from which the estimate should
be calculated.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_do.ci">do.CI</code></td>
<td>

<p>Logical value specifying whether to calculate standard errors
and confidence bands.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_jitter">jitter</code></td>
<td>

<p>Logical value. If <code>jitter=TRUE</code> (the default),
the values of the covariate at the
data points will be jittered (randomly perturbed by adding a small
amount of noise) using the function <code><a href="base.html#topic+jitter">jitter</a></code>.
If <code>jitter=FALSE</code>, the covariate values at the data points will
not be altered. See the section on <em>Randomisation and discretisation</em>.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_jitterfactor">jitterfactor</code></td>
<td>

<p>Numeric value controlling the scale of noise added to the
covariate values at the data points when <code>jitter=TRUE</code>.
Passed to the function <code><a href="base.html#topic+jitter">jitter</a></code>
as the argument <code>factor</code>.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value specifying whether to use spatial interpolation
to obtain the values of the covariate at the data points,
when the covariate is a pixel image
(object of class <code>"im"</code>).
If <code>interpolate=FALSE</code>, the covariate value for each data point
is simply the value of the covariate image at the pixel centre that
is nearest to the data point. If <code>interpolate=TRUE</code>, the
covariate value for each data point is obtained by interpolating the
nearest pixel values using <code><a href="spatstat.geom.html#topic+interp.im">interp.im</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_dimyx">dimyx</code>, <code id="rhohat.ppm_+3A_eps">eps</code>, <code id="rhohat.ppm_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Arguments controlling the pixel
resolution at which the covariate will be evaluated.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth or bandwidth rule
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_adjust">adjust</code></td>
<td>

<p>Smoothing bandwidth adjustment factor
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_n">n</code>, <code id="rhohat.ppm_+3A_from">from</code>, <code id="rhohat.ppm_+3A_to">to</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code> to
control the number and range of values at which the function
will be estimated.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_bwref">bwref</code></td>
<td>

<p>Optional. An alternative value of <code>bw</code> to use when smoothing
the reference density (the density of the covariate values
observed at all locations in the window).
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
or <code><a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_covname">covname</code></td>
<td>

<p>Optional. Character string to use as the name of the covariate.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level for confidence intervals.
A number between 0 and 1.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_positiveci">positiveCI</code></td>
<td>

<p>Logical value.
If <code>TRUE</code>, confidence limits are always positive numbers;
if <code>FALSE</code>, the lower limit of the
confidence interval may sometimes be negative.
Default is <code>FALSE</code> if <code>smoother="kernel"</code>
and <code>TRUE</code> if <code>smoother="local"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.ppm_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints for the piecewise-constant function
computed when <code>smoother='piecewise'</code>.
Either a vector of numeric values specifying the breakpoints,
or a single integer specifying the number of equally-spaced
breakpoints. There is a sensible default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command estimates the relationship between
point process intensity and a given spatial covariate.
Such a relationship is sometimes called a
<em>resource selection function</em> (if the points are organisms
and the covariate is a descriptor of habitat) or
a <em>prospectivity index</em> (if the points are mineral deposits
and the covariate is a geological variable). 
This command uses nonparametric methods which do not assume a
particular form for the relationship.  
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is missing or
null, this command assumes that <code>object</code> is a realisation of a
point process with intensity function
<code class="reqn">\lambda(u)</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u))</code>
</p>

<p>where <code class="reqn">Z</code> is the spatial
covariate function given by <code>covariate</code>, and
<code class="reqn">\rho(z)</code> is the resource selection function
or prospectivity index.
A nonparametric estimator of the function <code class="reqn">\rho(z)</code> is computed.
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is given,
then the intensity function is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u)) B(u)</code>
</p>

<p>where <code class="reqn">B(u)</code> is the baseline intensity at location <code class="reqn">u</code>.
A nonparametric estimator of the relative intensity  <code class="reqn">\rho(z)</code>
is computed.
</p>
<p>If <code>object</code> is a fitted point process model, suppose <code>X</code> is
the original data point pattern to which the model was fitted. Then
this command assumes <code>X</code> is a realisation of a Poisson point
process with intensity function of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u) = \rho(Z(u)) \kappa(u)
  </code>
</p>

<p>where <code class="reqn">\kappa(u)</code> is the intensity of the fitted model
<code>object</code>. A nonparametric estimator of
the relative intensity <code class="reqn">\rho(z)</code> is computed.
</p>
<p>The nonparametric estimation procedure is controlled by the
arguments <code>smoother</code>, <code>method</code> and <code>horvitz</code>.
</p>
<p>The argument <code>smoother</code> selects the type of estimation technique.
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code> (the default),
the nonparametric estimator is a <em>kernel smoothing estimator</em>
of <code class="reqn">\rho(z)</code> (Guan, 2008; Baddeley et al, 2012).
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code> which takes nonnegative values.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, 
the nonparametric estimator is a <em>local regression estimator</em>
of <code class="reqn">\rho(z)</code> (Baddeley et al, 2012) obtained using
local likelihood.
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code>.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="increasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is increasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="decreasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is decreasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="mountain"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with an inverted U shape,
with a single peak at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and a decreasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
increasing and then decreasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="valley"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with a U shape,
with a single minimum at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and an increasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
decreasing and then increasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="piecewise"</code>, the estimate of
<code class="reqn">\rho(z)</code> is piecewise constant.
The range of covariate values is divided into several intervals
(ranges or bands). The endpoints of these intervals are the
breakpoints, which may be specified by the argument <code>breaks</code>;
there is a sensible default. The estimate of 
<code class="reqn">\rho(z)</code> takes a constant value on each interval.
The estimate of <code class="reqn">\rho(z)</code> in each interval of covariate
values is simply the average intensity
(number of points per unit area) in the relevant sub-region.
If <code>do.CI=TRUE</code> (the default),
confidence bands are computed assuming a Poisson process.
</p>
</li></ul>

<p>See Baddeley (2018) for a comparison of these estimation techniques
(except for <code>"mountain"</code> and <code>"valley"</code>).
</p>
<p>If the argument <code>weights</code> is present, then the contribution
from each data point <code>X[i]</code> to the estimate of <code class="reqn">\rho</code> is
multiplied by <code>weights[i]</code>.
</p>
<p>If the argument <code>subset</code> is present, then the calculations are
performed using only the data inside this spatial region.
</p>
<p>This technique assumes that <code>covariate</code> has continuous values.
It is not applicable to covariates with categorical (factor) values
or discrete values such as small integers.
For a categorical covariate, use
<code><a href="spatstat.geom.html#topic+intensity.quadratcount">intensity.quadratcount</a></code> applied to the result of
<code><a href="spatstat.geom.html#topic+quadratcount">quadratcount</a>(X, tess=covariate)</code>.
</p>
<p>The argument <code>covariate</code> should be a pixel image, or a function,
or one of the strings <code>"x"</code> or <code>"y"</code> signifying the
cartesian coordinates. It will be evaluated on a fine grid of locations,
with spatial resolution controlled by the arguments
<code>dimyx,eps,rule.eps</code> which are passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the estimated values of <code class="reqn">\rho</code>
(and confidence limits) for a sequence of values of <code class="reqn">Z</code>.
Also belongs to the class <code>"rhohat"</code>
which has special methods for <code>print</code>, <code>plot</code>
and <code>predict</code>.
</p>


<h3>Smooth estimates</h3>

<p>Smooth estimators of <code class="reqn">\rho(z)</code>
were proposed by Baddeley and Turner (2005) and Baddeley et al (2012).
Similar estimators were proposed by Guan (2008) and in the literature
on relative distributions (Handcock and Morris, 1999).
</p>
<p>The estimated function <code class="reqn">\rho(z)</code> will be a smooth function
of <code class="reqn">z</code>.
</p>
<p>The smooth estimation procedure involves computing several density estimates
and combining them. The algorithm used to compute density estimates is 
determined by <code>smoother</code>:
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code>,
the smoothing procedure is based on
fixed-bandwidth kernel density estimation,
performed by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, the smoothing procedure
is based on local likelihood density estimation, performed by
<code><a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</li></ul>

<p>The argument <code>method</code> determines how the density estimates will be
combined to obtain an estimate of <code class="reqn">\rho(z)</code>:
</p>

<ul>
<li>
<p>If <code>method="ratio"</code>, then <code class="reqn">\rho(z)</code> is
estimated by the ratio of two density estimates,
The numerator is a (rescaled) density estimate obtained by
smoothing the values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>. The denominator
is a density estimate of the reference distribution of <code class="reqn">Z</code>.
See Baddeley et al (2012), equation (8). This is similar but not
identical to an estimator proposed by Guan (2008).
</p>
</li>
<li>
<p>If <code>method="reweight"</code>, then <code class="reqn">\rho(z)</code> is
estimated by applying density estimation to the 
values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>,
with weights inversely proportional to the reference density of
<code class="reqn">Z</code>.
See Baddeley et al (2012), equation (9).
</p>
</li>
<li> 
<p>If <code>method="transform"</code>,
the smoothing method is variable-bandwidth kernel
smoothing, implemented by applying the Probability Integral Transform
to the covariate values, yielding values in the range 0 to 1,
then applying edge-corrected density estimation on the interval
<code class="reqn">[0,1]</code>, and back-transforming.
See Baddeley et al (2012), equation (10).
</p>
</li></ul>

<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>Pointwise confidence intervals for the true value of <code class="reqn">\rho(z)</code>
are also calculated for each <code class="reqn">z</code>,
and will be plotted as grey shading.
The confidence intervals are derived using the central limit theorem,
based on variance calculations which assume a Poisson point process. 
If <code>positiveCI=FALSE</code>, the lower limit of the confidence
interval may sometimes be negative, because the confidence intervals
are based on a normal approximation to the estimate of <code class="reqn">\rho(z)</code>.
If <code>positiveCI=TRUE</code>, the confidence limits are always
positive, because the confidence interval is based on a normal
approximation to the estimate of <code class="reqn">\log(\rho(z))</code>.
For consistency with earlier versions, the default is
<code>positiveCI=FALSE</code> for <code>smoother="kernel"</code>
and <code>positiveCI=TRUE</code> for <code>smoother="local"</code>.
</p>


<h3>Monotone estimates</h3>

<p>The nonparametric maximum likelihood estimator
of a monotone function <code class="reqn">\rho(z)</code> was described by Sager (1982).
This method assumes that
<code class="reqn">\rho(z)</code> is either an increasing
function of <code class="reqn">z</code>, or a decreasing function of <code class="reqn">z</code>.
The estimated function will be a step function,
increasing or decreasing as a function of <code class="reqn">z</code>.
</p>
<p>This estimator is chosen by specifying
<code>smoother="increasing"</code> or <code>smoother="decreasing"</code>.
The argument <code>method</code> is ignored this case.
</p>
<p>To compute the estimate of <code class="reqn">\rho(z)</code>, the algorithm first
computes several primitive step-function estimates, and then takes
the maximum of these primitive functions.
</p>
<p>If <code>smoother="decreasing"</code>, each primitive step function
takes the form <code class="reqn">\rho(z) = \lambda</code> when <code class="reqn">z \le t</code>,
and <code class="reqn">\rho(z) = 0</code> when <code class="reqn">z &gt; t</code>, where
and <code class="reqn">\lambda</code> is a primitive estimate of intensity
based on the data for <code class="reqn">Z \le t</code>. The jump location <code class="reqn">t</code>
will be the value of the covariate <code class="reqn">Z</code> at one of the
data points. The primitive estimate <code class="reqn">\lambda</code>
is the average intensity (number of points divided by area)
for the region of space where the covariate value is less than
or equal to <code class="reqn">t</code>.
</p>
<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>Confidence intervals are not available
for the monotone estimators.
</p>


<h3>Unimodal estimators</h3>

<p>If <code>smoother="valley"</code> then we estimate a U-shaped function.
A function <code class="reqn">\rho(z)</code> is U-shaped if it is
decreasing when <code class="reqn">z &lt; z_0</code> and
increasing when <code class="reqn">z &gt; z_0</code>, where <code class="reqn">z_0</code> is
called the critical value. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over <code class="reqn">z_0</code>. 
The algorithm considers all possible candidate values of the critical value 
<code class="reqn">z_0</code>, and estimates the function <code class="reqn">\rho(z)</code>
separately on the left and right of <code class="reqn">z_0</code> using the monotone
estimators described above. These function estimates are combined into
a single function, and the Poisson point process likelihood is
computed. The optimal value of <code class="reqn">z_0</code>
is the one which maximises the Poisson point process likelihood.
</p>
<p>If <code>smoother="mountain"</code>  then we estimate a function which has
an inverted U shape. A function <code class="reqn">\rho(z)</code> is
inverted-U-shaped if it is
increasing when <code class="reqn">z &lt; z_0</code> and
decreasing when <code class="reqn">z &gt; z_0</code>. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over
<code class="reqn">z_0</code> using the same technique <em>mutatis mutandis</em>.
</p>
<p>Confidence intervals are not available for the unimodal estimators.
</p>


<h3>Randomisation</h3>

<p>By default, <code>rhohat</code> adds a small amount of random noise to the
data. This is designed to suppress the effects of
discretisation in pixel images.
</p>
<p>This strategy means that <code>rhohat</code>
does not produce exactly the same result when the computation is
repeated. If you need the results to be exactly reproducible, set
<code>jitter=FALSE</code>.
</p>
<p>By default, the values of the covariate at the data points
will be randomly perturbed by adding a small amount
of noise using the function <code><a href="base.html#topic+jitter">jitter</a></code>. To reduce this
effect, set <code>jitterfactor</code> to a number smaller than 1. To
suppress this effect entirely, set <code>jitter=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Smoothing algorithm by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, 
Ya-Mei Chang, Yong Song, 
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>
<p>Nonparametric maximum likelihood algorithm by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2012)
Nonparametric estimation of the dependence of a point
process on spatial covariates.
<em>Statistics and Its Interface</em> <b>5</b> (2), 221&ndash;236.
</p>
<p>Baddeley, A. and Turner, R. (2005)
Modelling spatial point patterns in R.
In: A. Baddeley, P. Gregori, J. Mateu, R. Stoica, and D. Stoyan,
editors, <em>Case Studies in Spatial Point Pattern Modelling</em>,
Lecture Notes in Statistics number 185. Pages 23&ndash;74.
Springer-Verlag, New York, 2006. 
ISBN: 0-387-28311-0.  
</p>
<p>Baddeley, A. (2018)
A statistical commentary on mineral prospectivity analysis.
Chapter 2, pages 25&ndash;65
in <em>Handbook of Mathematical Geosciences: Fifty Years of IAMG</em>,
edited by B.S. Daya Sagar, Q. Cheng and F.P. Agterberg.
Springer, Berlin.
</p>
<p>Guan, Y. (2008) On consistent nonparametric intensity estimation
for inhomogeneous spatial point processes.
<em>Journal of the American Statistical Association</em>
<b>103</b>, 1238&ndash;1247.
</p>
<p>Handcock, M.S. and Morris, M. (1999)
<em>Relative Distribution Methods in the Social Sciences</em>.
Springer, New York.
</p>
<p>Sager, T.W. (1982) 
Nonparametric maximum likelihood estimation of
spatial patterns. <em>Annals of Statistics</em> <b>10</b>, 1125&ndash;1136.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+rho2hat">rho2hat</a></code>,
<code><a href="spatstat.explore.html#topic+methods.rhohat">methods.rhohat</a></code>,
<code><a href="#topic+parres">parres</a></code>.
</p>
<p>See <code><a href="#topic+ppm">ppm</a></code> for a parametric method for the same problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;-  rpoispp(function(x,y){exp(3+3*x)})

  fit &lt;- ppm(X ~x)
  rr &lt;- rhohat(fit, "y")

</code></pre>

<hr>
<h2 id='rmh.ppm'>Simulate from a Fitted Point Process Model</h2><span id='topic+rmh.ppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to data, 
generate a random simulation of the model, 
using the Metropolis-Hastings algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
rmh(model, start=NULL,
                    control=default.rmhcontrol(model, w=w),
                    ...,
                    w = NULL, 
                    project=TRUE,
                    nsim=1, drop=TRUE, saveinfo=TRUE,
                    verbose=TRUE, new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmh.ppm_+3A_model">model</code></td>
<td>
<p>A fitted point process model (object of class
<code>"ppm"</code>, see <code><a href="#topic+ppm.object">ppm.object</a></code>) which it is desired
to simulate.  This fitted model is usually the result of a call
to <code><a href="#topic+ppm">ppm</a></code>.  See <b>Details</b> below.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_start">start</code></td>
<td>
<p>Data determining the initial state
of the Metropolis-Hastings algorithm.  See
<code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code> for description of these arguments.
Defaults to <code>list(x.start=data.ppm(model))</code>
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_control">control</code></td>
<td>
<p>Data controlling the iterative behaviour of
the Metropolis-Hastings algorithm.  See <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>
for description of these arguments.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>,
or to <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>, or to covariate functions in the model.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_w">w</code></td>
<td>

<p>Optional. Window in which the simulations should be generated.
Default is the window of the original data.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_project">project</code></td>
<td>

<p>Logical flag indicating what to do if the fitted model is
invalid (in the sense that the values of the fitted coefficients do not
specify a valid point process).
If <code>project=TRUE</code> the closest valid model will be simulated;
if <code>project=FALSE</code> an error will occur.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated point patterns that should be generated.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a single point pattern.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_saveinfo">saveinfo</code></td>
<td>

<p>Logical value indicating whether to save auxiliary information.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="rmh.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(model)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates simulated realisations from a point
process model that has been fitted to point pattern data.  It is
a method for the generic function <code><a href="spatstat.random.html#topic+rmh">rmh</a></code> for the
class <code>"ppm"</code> of fitted point process models.  To simulate
other kinds of point process models, see <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>
or <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>.
</p>
<p>The argument <code>model</code> describes the fitted model.  It must be
an object of class <code>"ppm"</code> (see <code><a href="#topic+ppm.object">ppm.object</a></code>),
and will typically be the result of a call to the point process
model fitting function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The current implementation enables simulation from any fitted model
involving the interactions
<code><a href="#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+Hardcore">Hardcore</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>
and <code><a href="#topic+Softcore">Softcore</a></code>,
including nonstationary models. See the examples.
</p>
<p>It is also possible to simulate <em>hybrids</em> of several such models.
See <code><a href="#topic+Hybrid">Hybrid</a></code> and the examples.
</p>
<p>It is possible that the fitted coefficients of a point process model
may be &ldquo;illegal&rdquo;, i.e. that there may not exist a
mathematically well-defined point process with the given parameter
values. For example, a Strauss process with interaction
parameter <code class="reqn">\gamma &gt; 1</code> does not exist,
but the model-fitting procedure used in <code><a href="#topic+ppm">ppm</a></code> will sometimes
produce values of <code class="reqn">\gamma</code> greater than 1.
In such cases, if <code>project=FALSE</code> then an error will occur,
while if <code>project=TRUE</code> then <code>rmh.ppm</code> will find
the nearest legal model and simulate
this model instead. (The nearest legal model is obtained by
projecting the vector of coefficients onto the set of
valid coefficient vectors. The result is usually the Poisson process
with the same fitted intensity.)
</p>
<p>The arguments <code>start</code> and <code>control</code> are lists of
parameters determining the initial state and the iterative
behaviour, respectively, of the Metropolis-Hastings algorithm.
</p>
<p>The argument <code>start</code> is passed directly to <code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code>.
See <code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code> for details of the parameters of the
initial state, and their default values.
</p>
<p>The argument <code>control</code> is first passed to
<code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>. Then if any additional arguments <code>...</code>
are given, <code><a href="spatstat.random.html#topic+update.rmhcontrol">update.rmhcontrol</a></code> is called to update the
parameter values. See <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code> for details of
the iterative behaviour parameters, and <code><a href="spatstat.random.html#topic+default.rmhcontrol">default.rmhcontrol</a></code>
for their default values.
</p>
<p>Note that if you specify expansion of the simulation window
using the parameter <code>expand</code> (so that the
model will be simulated on a window larger than the original data
window) then the model must be capable of extrapolation to this
larger window. This is usually not possible for models which
depend on external covariates, because the domain of a covariate image
is usually the same as the domain of the fitted model.
</p>
<p>After extracting the relevant information from the fitted model
object <code>model</code>, <code>rmh.ppm</code> invokes the default
<code>rmh</code> algorithm <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>, unless the model
is Poisson. If the model is Poisson then the Metropolis-Hastings
algorithm is not needed, and the model is simulated directly, using
one of <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>, <code><a href="spatstat.random.html#topic+rmpoispp">rmpoispp</a></code>,
<code><a href="spatstat.random.html#topic+rpoint">rpoint</a></code> or <code><a href="spatstat.random.html#topic+rmpoint">rmpoint</a></code>.
</p>
<p>See <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code> for further information about the
implementation, or about the Metropolis-Hastings algorithm.
</p>


<h3>Value</h3>

<p>A point pattern (an object of class <code>"ppp"</code>; see
<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>) or a list of point patterns.
</p>


<h3>Warnings</h3>

<p>See Warnings in <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="spatstat.random.html#topic+rmh">rmh</a></code>,
<code><a href="spatstat.random.html#topic+rmhmodel">rmhmodel</a></code>,
<code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="spatstat.random.html#topic+default.rmhcontrol">default.rmhcontrol</a></code>,
<code><a href="spatstat.random.html#topic+update.rmhcontrol">update.rmhcontrol</a></code>,
<code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code>,
<code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>,
<code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
</p>
<p>Interactions:
<code><a href="#topic+AreaInter">AreaInter</a></code>,
<code><a href="#topic+DiggleGratton">DiggleGratton</a></code>,
<code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+Hardcore">Hardcore</a></code>,
<code><a href="#topic+Hybrid">Hybrid</a></code>,
<code><a href="#topic+MultiStrauss">MultiStrauss</a></code>,
<code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+Poisson">Poisson</a></code>,
<code><a href="#topic+Strauss">Strauss</a></code>,
<code><a href="#topic+StraussHard">StraussHard</a></code>,
<code><a href="#topic+Softcore">Softcore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   live &lt;- interactive()
   op &lt;- spatstat.options()
   spatstat.options(rmh.nrep=1e5)
   Nrep &lt;- 1e5

   X &lt;- swedishpines
   if(live) plot(X, main="Swedish Pines data")

   # Poisson process
   fit &lt;- ppm(X, ~1, Poisson())
   Xsim &lt;- rmh(fit)
   if(live) plot(Xsim, main="simulation from fitted Poisson model")

   # Strauss process   
   fit &lt;- ppm(X, ~1, Strauss(r=7))
   Xsim &lt;- rmh(fit)
   if(live) plot(Xsim, main="simulation from fitted Strauss model")

   if(live) {
     # Strauss process simulated on a larger window
     # then clipped to original window
     Xsim &lt;- rmh(fit, control=list(nrep=Nrep, expand=1.1, periodic=TRUE))
     Xsim &lt;- rmh(fit, nrep=Nrep, expand=2, periodic=TRUE)
   }

   if(live) {
     X &lt;- rSSI(0.05, 100)
     # piecewise-constant pairwise interaction function
     fit &lt;- ppm(X, ~1, PairPiece(seq(0.02, 0.1, by=0.01)))
     Xsim &lt;- rmh(fit)
   }

    # marked point pattern
    Y &lt;- amacrine

   if(live) {
     # marked Poisson models
     fit &lt;- ppm(Y)
     fit &lt;- ppm(Y,~marks)
     fit &lt;- ppm(Y,~polynom(x,2))
     fit &lt;- ppm(Y,~marks+polynom(x,2))
     fit &lt;- ppm(Y,~marks*polynom(x,y,2))
     Ysim &lt;- rmh(fit)
   }

   # multitype Strauss models
   MS &lt;- MultiStrauss(radii=matrix(0.07, ncol=2, nrow=2),
                      types = levels(Y$marks))
   if(live) {
    fit &lt;- ppm(Y ~marks, MS)
    Ysim &lt;- rmh(fit)
   }

   fit &lt;- ppm(Y ~ marks*polynom(x,y,2), MS)
   Ysim &lt;- rmh(fit)
   if(live) plot(Ysim, main="simulation from fitted inhomogeneous Multitype Strauss")

   spatstat.options(op)

  if(live) {
    # Hybrid model
    fit &lt;- ppm(redwood, ~1, Hybrid(A=Strauss(0.02), B=Geyer(0.1, 2)))
    Y &lt;- rmh(fit)
  }
</code></pre>

<hr>
<h2 id='rmhmodel.ppm'>Interpret Fitted Model for Metropolis-Hastings Simulation.</h2><span id='topic+rmhmodel.ppm'></span>

<h3>Description</h3>

<p>Converts a fitted point process model
into a format that can be used to simulate the model
by the Metropolis-Hastings algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
rmhmodel(model, w, ..., verbose=TRUE, project=TRUE,
                         control=rmhcontrol(),
                         new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmhmodel.ppm_+3A_model">model</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_w">w</code></td>
<td>

<p>Optional. Window in which the simulations should be generated.
</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
while the model is being converted.
</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_project">project</code></td>
<td>
<p>Logical flag indicating what to do if the fitted model
does not correspond to a valid point process. See Details.</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_control">control</code></td>
<td>

<p>Parameters determining the iterative behaviour of the simulation
algorithm. Passed to <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>.
</p>
</td></tr>
<tr><td><code id="rmhmodel.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(model)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic function <code><a href="spatstat.random.html#topic+rmhmodel">rmhmodel</a></code> takes a
description of a point process model in some format, and
converts it into an object of class <code>"rmhmodel"</code>
so that simulations of the model can be generated using
the Metropolis-Hastings algorithm <code><a href="spatstat.random.html#topic+rmh">rmh</a></code>. 
</p>
<p>This function <code>rmhmodel.ppm</code> is the method for
the class <code>"ppm"</code> of fitted point process models.
</p>
<p>The argument <code>model</code> should be a fitted point process model
(object of class <code>"ppm"</code>) typically obtained from the
model-fitting function <code><a href="#topic+ppm">ppm</a></code>.
This will be converted into an object of class <code>"rmhmodel"</code>.
</p>
<p>The optional argument <code>w</code> specifies the window
in which the pattern is to be generated.  If specified, it must be in
a form which can be coerced to an object of class <code>owin</code>
by <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
<p>Not all fitted point process models
obtained from <code><a href="#topic+ppm">ppm</a></code> can be simulated.
We have not yet implemented simulation code for
the <code><a href="#topic+LennardJones">LennardJones</a></code> and <code><a href="#topic+OrdThresh">OrdThresh</a></code>
models.
</p>
<p>It is also possible that a fitted point process model
obtained from <code><a href="#topic+ppm">ppm</a></code>  may not correspond to a valid
point process. For example a fitted model with the <code><a href="#topic+Strauss">Strauss</a></code>
interpoint interaction may have any value of the interaction parameter
<code class="reqn">\gamma</code>; however the Strauss 
process is not well-defined for 
<code class="reqn">\gamma &gt; 1</code> (Kelly and Ripley, 1976).
</p>
<p>The argument <code>project</code> determines what to do in such cases.
If <code>project=FALSE</code>, a fatal error will occur.
If <code>project=TRUE</code>, the fitted model parameters will be
adjusted to the nearest values which do correspond to a valid
point process. For example a Strauss process with <code class="reqn">\gamma &gt;
    1</code> will be projected to a Strauss process with
<code class="reqn">\gamma = 1</code>, equivalent to a Poisson process.
</p>


<h3>Value</h3>

<p>An object of class <code>"rmhmodel"</code>, which is essentially
a list of parameter values for the model.
</p>
<p>There is a <code>print</code> method for this class, which prints
a sensible description of the model chosen.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Diggle, P. J. (2003) <em>Statistical Analysis of Spatial Point
Patterns</em> (2nd ed.) Arnold, London.
</p>
<p>Diggle, P.J. and Gratton, R.J. (1984)
Monte Carlo methods of inference for implicit statistical models.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 193 &ndash; 212.
</p>
<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point
Processes. Chapter 3 in  O.E. Barndorff-Nielsen, W.S. Kendall and
M.N.M. Van Lieshout (eds) <em>Stochastic Geometry: Likelihood and
Computation</em>, Chapman and Hall / CRC,  Monographs on Statistics and
Applied Probability, number 80. Pages 79&ndash;140.
</p>
<p>Kelly, F.P. and Ripley, B.D. (1976)
On Strauss's model for clustering.
<em>Biometrika</em> <b>63</b>, 357&ndash;360.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rmhmodel">rmhmodel</a></code>,
<code><a href="spatstat.random.html#topic+rmhmodel.list">rmhmodel.list</a></code>,
<code><a href="spatstat.random.html#topic+rmhmodel.default">rmhmodel.default</a></code>,
<code><a href="spatstat.random.html#topic+rmh">rmh</a></code>,
<code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>,
<code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code>,
<code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+AreaInter">AreaInter</a></code>, <code><a href="#topic+BadGey">BadGey</a></code>, <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a></code>, <code><a href="#topic+DiggleGratton">DiggleGratton</a></code>, <code><a href="#topic+Fiksel">Fiksel</a></code>, <code><a href="#topic+Geyer">Geyer</a></code>, <code><a href="#topic+Hardcore">Hardcore</a></code>, <code><a href="#topic+Hybrid">Hybrid</a></code>, <code><a href="#topic+LennardJones">LennardJones</a></code>, <code><a href="#topic+MultiStrauss">MultiStrauss</a></code>, <code><a href="#topic+MultiStraussHard">MultiStraussHard</a></code>, <code><a href="#topic+PairPiece">PairPiece</a></code>, <code><a href="#topic+Penttinen">Penttinen</a></code>, <code><a href="#topic+Poisson">Poisson</a></code>, <code><a href="#topic+Softcore">Softcore</a></code>, <code><a href="#topic+Strauss">Strauss</a></code>, <code><a href="#topic+StraussHard">StraussHard</a></code> and <code><a href="#topic+Triplets">Triplets</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit1 &lt;- ppm(cells ~1, Strauss(0.07))
  mod1 &lt;- rmhmodel(fit1)

  fit2 &lt;- ppm(cells ~x, Geyer(0.07, 2))
  mod2 &lt;- rmhmodel(fit2)

  fit3 &lt;- ppm(cells ~x, Hardcore(0.07))
  mod3 &lt;- rmhmodel(fit3)

  # Then rmh(mod1), etc
</code></pre>

<hr>
<h2 id='roc.ppm'>
Receiver Operating Characteristic
</h2><span id='topic+roc.ppm'></span><span id='topic+roc.kppm'></span><span id='topic+roc.slrm'></span>

<h3>Description</h3>

<p>Computes the Receiver Operating Characteristic curve
for a point pattern or a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ppm'
roc(X, ...)

## S3 method for class 'kppm'
roc(X, ...)

## S3 method for class 'slrm'
roc(X, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.ppm_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>)
or fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="roc.ppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes Receiver Operating
Characteristic curve. The area under the ROC is computed by <code><a href="spatstat.explore.html#topic+auc">auc</a></code>.
</p>
<p>For a point pattern <code>X</code> and a covariate <code>Z</code>, the
ROC is a plot showing the ability of the 
covariate to separate the spatial domain
into areas of high and low density of points.
For each possible threshold <code class="reqn">z</code>, the algorithm calculates
the fraction <code class="reqn">a(z)</code> of area in the study region where the
covariate takes a value greater than <code class="reqn">z</code>, and the
fraction <code class="reqn">b(z)</code> of data points for which the covariate value
is greater than <code class="reqn">z</code>. The ROC is a plot of <code class="reqn">b(z)</code> against
<code class="reqn">a(z)</code> for all thresholds <code class="reqn">z</code>. 
</p>
<p>For a fitted point process model, 
the ROC shows the ability of the
fitted model intensity to separate the spatial domain
into areas of high and low density of points.
The ROC is <b>not</b> a diagnostic for the goodness-of-fit of the model
(Lobo et al, 2007).
</p>
<p>(For spatial logistic regression models (class <code>"slrm"</code>)
replace &ldquo;intensity&rdquo; by &ldquo;probability of presence&rdquo;
in the text above.)
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>)
which can be plotted to show the ROC curve.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+auc">auc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- ppm(swedishpines ~ x+y)
  plot(roc(fit))
</code></pre>

<hr>
<h2 id='rppm'>
Recursively Partitioned Point Process Model
</h2><span id='topic+rppm'></span>

<h3>Description</h3>

<p>Fits a recursive partition model to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rppm(..., rpargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+ppm">ppm</a></code>
specifying the point pattern data and the explanatory covariates.
</p>
</td></tr>
<tr><td><code id="rppm_+3A_rpargs">rpargs</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="rpart.html#topic+rpart">rpart</a></code>
controlling the recursive partitioning procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to find a simple rule for predicting
low and high intensity regions of points in a point pattern,
using explanatory covariates.
</p>
<p>The arguments <code>...</code> specify the point pattern data
and explanatory covariates in the same way as they would be
in the function <code><a href="#topic+ppm">ppm</a></code>. 
</p>
<p>The recursive partitioning algorithm <code><a href="rpart.html#topic+rpart">rpart</a></code>
is then used to find a partitioning rule.
</p>


<h3>Value</h3>

<p>An object of class <code>"rppm"</code>. There are methods
for <code>print</code>, <code>plot</code>, <code>fitted</code>, <code>predict</code> and
<code>prune</code> for this class.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Breiman, L., Friedman, J. H., Olshen, R. A., and Stone, C. J. (1984)
<em>Classification and Regression Trees</em>. Wadsworth.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rppm">plot.rppm</a></code>, 
<code><a href="#topic+predict.rppm">predict.rppm</a></code>, 
<code><a href="#topic+update.rppm">update.rppm</a></code>, 
<code><a href="#topic+prune.rppm">prune.rppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # New Zealand trees data: trees planted along border
    # Use covariates 'x', 'y'
    nzfit &lt;- rppm(nztrees ~ x + y)
    nzfit
    prune(nzfit, cp=0.035)
    # Murchison gold data: numeric and logical covariates
    mur &lt;- solapply(murchison, rescale, s=1000, unitname="km")
    mur$dfault &lt;- distfun(mur$faults)
    # 
    mfit &lt;- rppm(gold ~ dfault + greenstone, data=mur)
    mfit
    # Gorillas data: factor covariates
    #          (symbol '.' indicates 'all variables')
    gfit &lt;- rppm(unmark(gorillas) ~ . , data=gorillas.extra)
    gfit
</code></pre>

<hr>
<h2 id='SatPiece'>Piecewise Constant Saturated Pairwise Interaction Point Process Model</h2><span id='topic+SatPiece'></span>

<h3>Description</h3>

<p>Creates an instance of a saturated pairwise interaction point process model
with piecewise constant potential function. The model
can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SatPiece(r, sat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SatPiece_+3A_r">r</code></td>
<td>
<p>vector of jump points for the potential function</p>
</td></tr>
<tr><td><code id="SatPiece_+3A_sat">sat</code></td>
<td>

<p>vector of saturation values,
or a single saturation value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalisation of the Geyer saturation point process model,
described in <code><a href="#topic+Geyer">Geyer</a></code>, to the case of multiple interaction
distances. It can also be described as the saturated analogue of a
pairwise interaction process with piecewise-constant pair potential,
described in <code><a href="#topic+PairPiece">PairPiece</a></code>.
</p>
<p>The saturated point process with interaction radii
<code class="reqn">r_1,\ldots,r_k</code>,
saturation thresholds <code class="reqn">s_1,\ldots,s_k</code>,
intensity parameter <code class="reqn">\beta</code> and
interaction parameters
<code class="reqn">\gamma_1,\ldots,gamma_k</code>,
is the point process
in which each point
<code class="reqn">x_i</code> in the pattern <code class="reqn">X</code>
contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">
    \beta \gamma_1^{v_1(x_i, X)} \ldots gamma_k^{v_k(x_i,X)}
  </code>
</p>

<p>to the probability density of the point pattern,
where
</p>
<p style="text-align: center;"><code class="reqn">
    v_j(x_i, X) = \min( s_j, t_j(x_i,X) )
  </code>
</p>

<p>where <code class="reqn">t_j(x_i, X)</code> denotes the
number of points in the pattern <code class="reqn">X</code> which lie
at a distance between <code class="reqn">r_{j-1}</code> and <code class="reqn">r_j</code>
from the point <code class="reqn">x_i</code>. We take <code class="reqn">r_0 = 0</code>
so that <code class="reqn">t_1(x_i,X)</code> is the number of points of
<code class="reqn">X</code> that lie within a distance <code class="reqn">r_1</code> of the point
<code class="reqn">x_i</code>. 
</p>
<p><code>SatPiece</code> is used to fit this model to data.
The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the piecewise constant Saturated pairwise
interaction is yielded by the function <code>SatPiece()</code>.
See the examples below.
</p>
<p>Simulation of this point process model is not yet implemented.
This model is not locally stable (the conditional intensity is
unbounded).
</p>
<p>The argument <code>r</code> specifies the vector of interaction distances.
The entries of <code>r</code> must be strictly increasing, positive numbers.
</p>
<p>The argument <code>sat</code> specifies the vector of saturation parameters.
It should be a vector of the same length as <code>r</code>, and its entries
should be nonnegative numbers. Thus <code>sat[1]</code> corresponds to the
distance range from <code>0</code> to <code>r[1]</code>, and <code>sat[2]</code> to the
distance range from <code>r[1]</code> to <code>r[2]</code>, etc.
Alternatively <code>sat</code> may be a single number, and this saturation
value will be applied to every distance range.
</p>
<p>Infinite values of the
saturation parameters are also permitted; in this case
<code class="reqn">v_j(x_i,X) = t_j(x_i,X)</code>
and there is effectively no &lsquo;saturation&rsquo; for the distance range in
question. If all the saturation parameters are set to <code>Inf</code> then
the model is effectively a pairwise interaction process, equivalent to
<code><a href="#topic+PairPiece">PairPiece</a></code> (however the interaction parameters
<code class="reqn">\gamma</code> obtained from <code><a href="#topic+SatPiece">SatPiece</a></code> are the
square roots of the parameters <code class="reqn">\gamma</code>
obtained from <code><a href="#topic+PairPiece">PairPiece</a></code>).
</p>
<p>If <code>r</code> is a single number, this model is virtually equivalent to the 
Geyer process, see <code><a href="#topic+Geyer">Geyer</a></code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
in collaboration with Hao Wang and Jeff Picka
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+PairPiece">PairPiece</a></code>,
<code><a href="#topic+BadGey">BadGey</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   SatPiece(c(0.1,0.2), c(1,1))
   # prints a sensible description of itself
   SatPiece(c(0.1,0.2), 1)

   ppm(cells ~1, SatPiece(c(0.07, 0.1, 0.13), 2))
   # fit a stationary piecewise constant Saturated pairwise interaction process

   
     ppm(cells ~polynom(x,y,3), SatPiece(c(0.07, 0.1, 0.13), 2))
     # nonstationary process with log-cubic polynomial trend
   
</code></pre>

<hr>
<h2 id='Saturated'>Saturated Pairwise Interaction model</h2><span id='topic+Saturated'></span>

<h3>Description</h3>

<p>Experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Saturated(pot, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Saturated_+3A_pot">pot</code></td>
<td>
<p>An S language function giving the user-supplied
pairwise interaction potential.</p>
</td></tr>
<tr><td><code id="Saturated_+3A_name">name</code></td>
<td>
<p>Character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is experimental. It constructs a member of the
&ldquo;saturated pairwise&rdquo; family <code><a href="#topic+pairsat.family">pairsat.family</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of a point process. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+Geyer">Geyer</a></code>,
<code><a href="#topic+SatPiece">SatPiece</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>

<hr>
<h2 id='simulate.dppm'>Simulation of Determinantal Point Process Model</h2><span id='topic+simulate.dppm'></span><span id='topic+simulate.detpointprocfamily'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
simulate(object, nsim = 1, seed = NULL, ...,
    W = NULL, trunc = 0.99, correction = "periodic", rbord = reach(object))

  ## S3 method for class 'detpointprocfamily'
simulate(object, nsim = 1, seed = NULL, ...,
    W = NULL, trunc = 0.99, correction = "periodic", rbord = reach(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.dppm_+3A_object">object</code></td>
<td>

<p>Determinantal point process model. An object of class
<code>"detpointprocfamily"</code> or <code>"dppm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations.</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_seed">seed</code></td>
<td>

<p>an object specifying whether and how to initialise the random
number generator. Either <code>NULL</code> or an integer that will be
used in a call to <code><a href="base.html#topic+Random">set.seed</a></code> before
simulating the point patterns.
</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+rdpp">rdpp</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_w">W</code></td>
<td>

<p>Object specifying the window of simulation (defaults to a unit
box if nothing else is sensible &ndash; see Details). Can be any single
argument acceptable to <code><a href="spatstat.geom.html#topic+as.boxx">as.boxx</a></code> (e.g. an <code>"owin"</code>,
<code>"box3"</code> or <code>"boxx"</code> object).
</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_trunc">trunc</code></td>
<td>

<p>Numeric value specifying how the model truncation is preformed. See
Details.
</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_correction">correction</code></td>
<td>

<p>Character string specifying the type of correction to use.
The options are <code>"periodic"</code> (default) and <code>"border"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="simulate.dppm_+3A_rbord">rbord</code></td>
<td>

<p>Numeric value specifying the extent of the border correction if this
correction is used. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the classes <code>"detpointprocfamily"</code> and
<code>"dppm"</code> of determinantal point process models.
</p>
<p>The return value is a list of <code>nsim</code> point patterns.
It also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
This follows the convention used in
<code>simulate.lm</code> (see <code><a href="stats.html#topic+simulate">simulate</a></code>).
It can be used to force a sequence of simulations to be
repeated exactly, as shown in the examples for
<code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>
<p>The exact simulation of a determinantal point process model involves
an infinite series, which typically has no analytical solution. In the
implementation a truncation is performed. The truncation
<code>trunc</code> can be specified either directly as a positive integer
or as a fraction between 0 and 1. In the latter case the truncation is chosen
such that the expected number of points in a simulation is
<code>trunc</code> times the theoretical expected number of points in the
model. The default is 0.99.
</p>
<p>The window of the returned point pattern(s) can be specified via the
argument <code>W</code>. For a fitted model (of class <code>"dppm"</code>) it
defaults to the observation window of the data used to fit the
model. For inhomogeneous models it defaults to the window of the
intensity image. Otherwise it defaults to a unit box.  For
non-rectangular windows simulation is done in the containing rectangle
and then restricted to the window.  For inhomogeneous models a
stationary model is first simulated using the maximum intensity and
then the result is obtained by thinning.
</p>
<p>The default is to use periodic edge correction for simulation such
that opposite edges are glued together.  If border correction is used
then the simulation is done in an extended window. Edge effects are
theoretically completely removed by doubling the size of the window in
each spatial dimension, but for practical purposes much less extension
may be sufficient. The numeric <code>rbord</code> determines the extent of
the extra space added to the window.
</p>


<h3>Value</h3>

<p>A list of length <code>nsim</code> containing simulated point patterns.
If the patterns are two-dimensional, then they are 
objects of class <code>"ppp"</code>, and the list has class <code>"solist"</code>.
Otherwise, the patterns are objects of class <code>"ppx"</code> and the
list has class <code>"anylist"</code>.
</p>
<p>The return value also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
See Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lavancier, F. Moller, J. and Rubak, E. (2015)
Determinantal point process models and statistical inference
<em>Journal of the Royal Statistical Society, Series B</em>
<b>77</b>, 853&ndash;977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdpp">rdpp</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()) {
   nsim &lt;- 2
   lam &lt;- 100
} else {
   nsim &lt;- 1
   lam &lt;- 30
}
model &lt;- dppGauss(lambda=lam, alpha=.05, d=2)
simulate(model, nsim)
</code></pre>

<hr>
<h2 id='simulate.kppm'>Simulate a Fitted Cluster Point Process Model</h2><span id='topic+simulate.kppm'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a fitted cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
simulate(object, nsim = 1, seed=NULL, ...,
         window=NULL, covariates=NULL,
         n.cond = NULL, w.cond = NULL,
         verbose=TRUE, retry=10,
         drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.kppm_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model. An object of class <code>"kppm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_seed">seed</code></td>
<td>

<p>an object specifying whether and how to initialise
the random number generator. Either <code>NULL</code> or an integer that will
be used in a call to <code><a href="base.html#topic+Random">set.seed</a></code>
before simulating the point patterns. 
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the relevant random generator.
See Details.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_window">window</code></td>
<td>

<p>Optional. Window (object of class <code>"owin"</code>) in which the
model should be simulated.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_covariates">covariates</code></td>
<td>

<p>Optional. A named list containing new values for the covariates in the
model. 
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_n.cond">n.cond</code></td>
<td>

<p>Optional. Integer specifying a fixed number of points.
See the section on <em>Conditional Simulation</em>.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_w.cond">w.cond</code></td>
<td>

<p>Optional. Conditioning region. A window (object of class <code>"owin"</code>)
specifying the region which must contain exactly <code>n.cond</code> points.
See the section on <em>Conditional Simulation</em>.
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Whether to print progress reports (when <code>nsim &gt; 1</code>).
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_retry">retry</code></td>
<td>

<p>Number of times to repeat the simulation if it fails
(e.g. because of insufficient memory).
</p>
</td></tr>
<tr><td><code id="simulate.kppm_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code>, the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the class <code>"kppm"</code> of fitted
cluster point process models.
</p>
<p>Simulations are performed by
<code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>,
<code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>,
<code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>
or <code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>
depending on the model.
</p>
<p>Additional arguments <code>...</code> are passed to the relevant function
performing the simulation.
For example the argument <code>saveLambda</code> is recognised by all of the
simulation functions.
</p>
<p>The return value is a list of point patterns.
It also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
This follows the convention used in
<code>simulate.lm</code> (see <code><a href="stats.html#topic+simulate">simulate</a></code>).
It can be used to force a sequence of simulations to be
repeated exactly, as shown in the examples for <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nsim</code> containing simulated point patterns
(objects of class <code>"ppp"</code>). (For conditional simulation,
the length of the result may be shorter than <code>nsim</code>).
</p>
<p>The return value also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
See Details.
</p>


<h3>Conditional Simulation</h3>

<p>If <code>n.cond</code> is specified, it should be a single integer.
Simulation will be conditional on the event 
that the pattern contains exactly <code>n.cond</code> points
(or contains exactly <code>n.cond</code> points inside
the region <code>w.cond</code> if it is given).
</p>
<p>Conditional simulation uses the rejection algorithm described
in Section 6.2 of Moller, Syversveen and Waagepetersen (1998).
There is a maximum number of proposals which will be attempted.
Consequently the return value may contain fewer
than <code>nsim</code> point patterns.
</p>


<h3>Warning: new implementation for LGCP</h3>

<p>The simulation algorithm for log-Gaussian Cox processes
has been completely re-written
in <span class="pkg">spatstat.random</span> version <code>3.2-0</code> to avoid depending on
the package <span class="pkg">RandomFields</span> which is now defunct (and is sadly missed).
</p>
<p>It is no longer possible to replicate results
of <code>simulate.kppm</code> for log-Gaussian Cox processes
that were obtained using previous versions of <span class="pkg">spatstat.random</span>.
</p>
<p>The current code for simulating log-Gaussian Cox processes
is a new implementation and should be considered vulnerable to new bugs. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>
<p>Moller, J., Syversveen, A. and Waagepetersen, R. (1998)
Log Gaussian Cox Processes.
<em>Scandinavian Journal of Statistics</em> <b>25</b>, 451&ndash;482.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>,
<code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>,
<code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>,
<code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>,
<code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>,
<code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(offline &lt;- !interactive()) {
    spatstat.options(npixel=32, ndummy.min=16)
  }

  fit &lt;- kppm(redwood ~x, "Thomas")
  simulate(fit, 2)

  simulate(fit, n.cond=60)

  if(offline) reset.spatstat.options()
</code></pre>

<hr>
<h2 id='simulate.mppm'>Simulate a Point Process Model Fitted to Several Point Patterns</h2><span id='topic+simulate.mppm'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a 
point process model that was fitted to several point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mppm'
simulate(object, nsim=1, ..., verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.mppm_+3A_object">object</code></td>
<td>

<p>Point process model fitted to several point patterns.
An object of class <code>"mppm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.mppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations (of each original pattern).
</p>
</td></tr>
<tr><td><code id="simulate.mppm_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="#topic+simulate.ppm">simulate.ppm</a></code>
to control the simulation.
</p>
</td></tr>
<tr><td><code id="simulate.mppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the class <code>"mppm"</code> of fitted
point process models for replicated point pattern data.
</p>
<p>The result is a hyperframe with <code>n</code> rows and <code>nsim</code> columns,
where <code>n</code> is the number of original point pattern
datasets to which the model was fitted. Each column of the hyperframe
contains a simulated version of the original data.
</p>
<p>For each of the original point pattern datasets, the
fitted model for this dataset is extracted using
<code><a href="#topic+subfits">subfits</a></code>, then <code>nsim</code> simulated realisations
of this model are generated using <code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
and these are stored in the corresponding row of the output.
</p>


<h3>Value</h3>

<p>A hyperframe.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="#topic+simulate.ppm">simulate.ppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  H &lt;- hyperframe(Bugs=waterstriders)
  fit &lt;- mppm(Bugs ~ id, H)
  y &lt;- simulate(fit, nsim=2)
  y
  plot(y[1,,drop=TRUE], main="Simulations for Waterstriders pattern 1")
  plot(y[,1,drop=TRUE], main="Simulation 1 for each Waterstriders pattern")
</code></pre>

<hr>
<h2 id='simulate.ppm'>Simulate a Fitted Gibbs Point Process Model</h2><span id='topic+simulate.ppm'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a fitted Gibbs or Poisson
point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
simulate(object, nsim=1, ...,
                         singlerun = FALSE,
                         start = NULL,
                         control = default.rmhcontrol(object, w=w),
                         w = window, 
                         window = NULL, 
                         project=TRUE, new.coef=NULL,
                         verbose=FALSE, progress=(nsim &gt; 1),
                         drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model.
An object of class <code>"ppm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_singlerun">singlerun</code></td>
<td>

<p>Logical. Whether to generate the simulated realisations
from a single long run of the Metropolis-Hastings algorithm
(<code>singlerun=TRUE</code>) or from separate, independent runs of the
algorithm (<code>singlerun=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_start">start</code></td>
<td>
<p>Data determining the initial state
of the Metropolis-Hastings algorithm.  See
<code><a href="spatstat.random.html#topic+rmhstart">rmhstart</a></code> for description of these arguments.
Defaults to <code>list(n.start=npoints(data.ppm(object)))</code>
meaning that the initial state of the algorithm
has the same number of points as the original dataset.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_control">control</code></td>
<td>
<p>Data controlling the running of
the Metropolis-Hastings algorithm.  See <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>
for description of these arguments.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_w">w</code>, <code id="simulate.ppm_+3A_window">window</code></td>
<td>

<p>Optional. The window in which the model is defined.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>,
or to <code><a href="spatstat.random.html#topic+rmh.default">rmh.default</a></code>, or to covariate functions in the model.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_project">project</code></td>
<td>

<p>Logical flag indicating what to do if the fitted model is
invalid (in the sense that the values of the fitted coefficients do not
specify a valid point process).
If <code>project=TRUE</code> the closest valid model will be simulated;
if <code>project=FALSE</code> an error will occur.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
from <code><a href="#topic+rmh.ppm">rmh.ppm</a></code>
during the simulation of each point pattern.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_progress">progress</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
for the sequence of simulations.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="simulate.ppm_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code>, the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the class <code>"ppm"</code> of fitted
point process models.
</p>
<p>Simulations are performed by <code><a href="#topic+rmh.ppm">rmh.ppm</a></code>.
</p>
<p>If <code>singlerun=FALSE</code> (the default), the simulated patterns are
the results of independent runs of the Metropolis-Hastings
algorithm. If <code>singlerun=TRUE</code>, a single long run of the
algorithm is performed, and the state of the simulation is saved
every <code>nsave</code> iterations to yield the simulated patterns.
</p>
<p>In the case of a single run, the behaviour is controlled
by the parameters <code>nsave,nburn,nrep</code>. These 
are described in <code><a href="spatstat.random.html#topic+rmhcontrol">rmhcontrol</a></code>. They may be passed
in the <code>...</code> arguments or included in <code>control</code>.
It is sufficient to specify two
of the three parameters <code>nsave,nburn,nrep</code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nsim</code> containing simulated point patterns
(objects of class <code>"ppp"</code>).
It also belongs to the class <code>"solist"</code>, so that it can be
plotted, and the class <code>"timed"</code>, so that the total computation
time is recorded.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+simulate.kppm">simulate.kppm</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  fit &lt;- ppm(japanesepines, ~1, Strauss(0.1))
  simulate(fit, 2)
  simulate(fit, 2, singlerun=TRUE, nsave=1e4, nburn=1e4)
  
</code></pre>

<hr>
<h2 id='simulate.slrm'>Simulate a Fitted Spatial Logistic Regression Model</h2><span id='topic+simulate.slrm'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a fitted
spatial logistic regresson model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
simulate(object, nsim = 1, seed=NULL, ...,
         window=NULL, covariates=NULL, verbose=TRUE, drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.slrm_+3A_object">object</code></td>
<td>

<p>Fitted spatial logistic regression model. An object of class <code>"slrm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations.
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_seed">seed</code></td>
<td>

<p>an object specifying whether and how to initialise
the random number generator. Either <code>NULL</code> or an integer that will
be used in a call to <code><a href="base.html#topic+Random">set.seed</a></code>
before simulating the point patterns. 
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_window">window</code></td>
<td>

<p>Optional. Window (object of class <code>"owin"</code>) in which the
model should be simulated.
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_covariates">covariates</code></td>
<td>

<p>Optional. A named list containing new values for the covariates in the
model. 
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_verbose">verbose</code></td>
<td>

<p>Logical. Whether to print progress reports (when <code>nsim &gt; 1</code>).
</p>
</td></tr>
<tr><td><code id="simulate.slrm_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code>, the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the class <code>"slrm"</code> of fitted
spatial logistic regression models.
</p>
<p>Simulations are performed by <code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>
after the intensity has been computed by <code><a href="#topic+predict.slrm">predict.slrm</a></code>.
</p>
<p>The return value is a list of point patterns.
It also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
This follows the convention used in
<code>simulate.lm</code> (see <code><a href="stats.html#topic+simulate">simulate</a></code>).
It can be used to force a sequence of simulations to be
repeated exactly, as shown in the examples for <code><a href="stats.html#topic+simulate">simulate</a></code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nsim</code> containing simulated point patterns
(objects of class <code>"ppp"</code>).
</p>
<p>The return value also carries an attribute <code>"seed"</code> that
captures the initial state of the random number generator.
See Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>,
<code><a href="spatstat.random.html#topic+rpoispp">rpoispp</a></code>,
<code><a href="#topic+simulate.ppm">simulate.ppm</a></code>,
<code><a href="#topic+simulate.kppm">simulate.kppm</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- copper$SouthPoints
  fit &lt;- slrm(X ~ 1)
  simulate(fit, 2)
  fitxy &lt;- slrm(X ~ x+y)
  simulate(fitxy, 2, window=square(2))
</code></pre>

<hr>
<h2 id='slrm'>Spatial Logistic Regression</h2><span id='topic+slrm'></span>

<h3>Description</h3>

<p>Fits a spatial logistic regression model
to a spatial point pattern. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slrm(formula, ..., data = NULL, offset = TRUE, link = "logit",
                   dataAtPoints=NULL, splitby=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slrm_+3A_formula">formula</code></td>
<td>
<p>The model formula. See Details.</p>
</td></tr>
<tr><td><code id="slrm_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
determining the pixel resolution for the discretisation
of the point pattern.
</p>
</td></tr>
<tr><td><code id="slrm_+3A_data">data</code></td>
<td>

<p>Optional. A list containing data required in the formula.
The names of entries in the list should correspond to variable
names in the formula. The entries should be point patterns,
pixel images or windows.
</p>
</td></tr>
<tr><td><code id="slrm_+3A_offset">offset</code></td>
<td>

<p>Logical flag indicating whether the model formula
should be augmented by an offset equal to the logarithm of the
pixel area.
</p>
</td></tr>
<tr><td><code id="slrm_+3A_link">link</code></td>
<td>
<p>The link function for the regression model.
A character string, specifying a link function
for binary regression.
</p>
</td></tr>
<tr><td><code id="slrm_+3A_dataatpoints">dataAtPoints</code></td>
<td>
<p>Optional.
Exact values of the covariates at the data points.
A data frame, with column names corresponding to
variables in the <code>formula</code>, with one row for each
point in the point pattern dataset.
</p>
</td></tr>
<tr><td><code id="slrm_+3A_splitby">splitby</code></td>
<td>

<p>Optional. Character string identifying a window. The window will be used
to split pixels into sub-pixels. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Spatial Logistic Regression model
(Tukey, 1972; Agterberg, 1974) to a spatial point pattern dataset. 
The logistic function may be replaced by another link function.
</p>
<p>The <code>formula</code> specifies the form of the model to be fitted,
and the data to which it should be fitted. The <code>formula</code>
must be an <span class="rlang"><b>R</b></span> formula with a left and right hand
side.
</p>
<p>The left hand side of the <code>formula</code> is the name of the
point pattern dataset, an object of class <code>"ppp"</code>. 
</p>
<p>The right hand side of the <code>formula</code> is an expression,
in the usual <span class="rlang"><b>R</b></span> formula syntax, representing the functional form of
the linear predictor for the model.
</p>
<p>Each variable name that appears in the formula may be 
</p>

<ul>
<li>
<p>one of the reserved names <code>x</code> and <code>y</code>,
referring to the Cartesian coordinates;
</p>
</li>
<li>
<p>the name of an entry in the list <code>data</code>, if this argument is given;
</p>
</li>
<li>
<p>the name of an object in the
parent environment, that is, in the environment where the call
to <code>slrm</code> was issued.
</p>
</li></ul>

<p>Each object appearing on the right hand side of the formula may be
</p>

<ul>
<li><p> a pixel image (object of class <code>"im"</code>)
containing the values of a covariate;
</p>
</li>
<li><p> a window (object of class <code>"owin"</code>), which will be
interpreted as a logical covariate which is <code>TRUE</code> inside the
window and <code>FALSE</code> outside it;
</p>
</li>
<li><p> a <code>function</code> in the <span class="rlang"><b>R</b></span> language, with arguments
<code>x,y</code>, which can be evaluated at any location to
obtain the values of a covariate.
</p>
</li></ul>

<p>See the Examples below.
</p>
<p>The fitting algorithm discretises the point pattern onto a pixel grid. The
value in each pixel is 1 if there are any points of the point pattern
in the pixel, and 0 if there are no points in the pixel.
The dimensions of the pixel grid will be determined as follows:
</p>

<ul>
<li>
<p>The pixel grid will be determined by the extra
arguments <code>...</code> if they are specified (for example the argument
<code>dimyx</code> can be used to specify the number of pixels).
</p>
</li>
<li>
<p>Otherwise, if the right hand side of the <code>formula</code> includes
the names of any pixel images containing covariate values,
these images will determine the pixel grid for the discretisation.
The covariate image with the finest grid (the smallest pixels) will
be used.
</p>
</li>
<li>
<p>Otherwise, the default pixel grid size is given by
<code>spatstat.options("npixel")</code>.
</p>
</li></ul>

<p>The covariates are evaluated at the centre of each pixel.
If <code>dataAtPoints</code> is given, then 
the covariate values at the corresponding pixels
are overwritten by the entries of <code>dataAtPoints</code>
(and the spatial coordinates are overwritten by the exact spatial
coordinates of the data points).
</p>
<p>If <code>link="logit"</code> (the default), the algorithm fits a Spatial Logistic
Regression model. This model states that the probability
<code class="reqn">p</code> that a given pixel contains a data point, is related to the
covariates through
</p>
<p style="text-align: center;"><code class="reqn">\log\frac{p}{1-p} = \eta</code>
</p>

<p>where <code class="reqn">\eta</code> is the linear predictor of the model
(a linear combination of the covariates,
whose form is specified by the <code>formula</code>).
</p>
<p>If <code>link="cloglog"</code> then the algorithm fits a model stating that
</p>
<p style="text-align: center;"><code class="reqn">\log(-\log(1-p)) = \eta</code>
</p>
<p>.
</p>
<p>If <code>offset=TRUE</code> (the default), the model formula will be
augmented by adding an offset term equal to the logarithm of the pixel
area. This ensures that the fitted parameters are
approximately independent of pixel size.
If <code>offset=FALSE</code>, the offset is not included, and the
traditional form of Spatial Logistic Regression is fitted.
</p>


<h3>Value</h3>

<p>An object of class <code>"slrm"</code> representing the fitted model.
</p>
<p>There are many methods for this class, including methods for
<code>print</code>, <code>fitted</code>, <code>predict</code>,
<code>anova</code>, <code>coef</code>, <code>logLik</code>, <code>terms</code>,
<code>update</code>, <code>formula</code> and <code>vcov</code>.
Automated stepwise model selection is possible using
<code><a href="stats.html#topic+step">step</a></code>. Confidence intervals for the parameters can be
computed using <code><a href="stats.html#topic+confint">confint</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Agterberg, F.P. (1974)
Automatic contouring of geological maps to detect target areas for
mineral exploration.
<em>Journal of the International Association for Mathematical Geology</em>
<b>6</b>, 373&ndash;395.
</p>
<p>Baddeley, A., Berman, M., Fisher, N.I., Hardegen, A., Milne, R.K.,
Schuhmacher, D., Shah, R. and Turner, R. (2010)
Spatial logistic regression and change-of-support
for spatial Poisson point processes.
<em>Electronic Journal of Statistics</em>
<b>4</b>, 1151&ndash;1201.
<code>DOI: 10.1214/10-EJS581</code>
</p>
<p>Tukey, J.W. (1972)
Discussion of paper by F.P. Agterberg and S.C. Robinson.
<em>Bulletin of the International Statistical Institute</em>
<b>44</b> (1) p. 596.
Proceedings, 38th Congress, International Statistical Institute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.slrm">anova.slrm</a></code>,
<code><a href="#topic+coef.slrm">coef.slrm</a></code>,
<code><a href="#topic+fitted.slrm">fitted.slrm</a></code>,
<code><a href="#topic+logLik.slrm">logLik.slrm</a></code>,
<code><a href="#topic+plot.slrm">plot.slrm</a></code>,
<code><a href="#topic+predict.slrm">predict.slrm</a></code>,
<code><a href="#topic+vcov.slrm">vcov.slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(offline &lt;- !interactive()) op &lt;- spatstat.options(npixel=32)

     X &lt;- copper$SouthPoints
     slrm(X ~ 1)
     slrm(X ~ x+y)

     slrm(X ~ x+y, link="cloglog")
     # specify a grid of 2-km-square pixels
     slrm(X ~ 1, eps=2)

     Y &lt;- copper$SouthLines
     Z &lt;- distmap(Y)
     slrm(X ~ Z)
     slrm(X ~ Z, dataAtPoints=list(Z=nncross(X,Y,what="dist")))

     mur &lt;- solapply(murchison, rescale, s=1000, unitname="km")
     mur$dfault &lt;- distfun(mur$faults)
     slrm(gold ~ dfault, data=mur)
     slrm(gold ~ dfault + greenstone, data=mur)
     slrm(gold ~ dfault, data=mur, splitby="greenstone")

if(offline) spatstat.options(op)
</code></pre>

<hr>
<h2 id='Smooth.msr'>
Smooth a Signed or Vector-Valued Measure
</h2><span id='topic+Smooth.msr'></span>

<h3>Description</h3>

<p>Apply kernel smoothing to a signed measure or vector-valued measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'msr'
Smooth(X, ..., drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.msr_+3A_x">X</code></td>
<td>

<p>Object of class <code>"msr"</code> representing a
signed measure or vector-valued measure.
</p>
</td></tr>
<tr><td><code id="Smooth.msr_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.explore.html#topic+density.ppp">density.ppp</a></code> controlling the
smoothing bandwidth and the pixel resolution.
</p>
</td></tr>
<tr><td><code id="Smooth.msr_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the result of smoothing
a scalar-valued measure is a pixel image. If <code>FALSE</code>, the
result of smoothing a scalar-valued measure is a list
containing one pixel image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies kernel smoothing to a signed measure or
vector-valued measure <code>X</code>. The Gaussian kernel is used.
</p>
<p>The object <code>X</code> would typically have been created by
<code><a href="#topic+residuals.ppm">residuals.ppm</a></code> or <code><a href="#topic+msr">msr</a></code>.
</p>


<h3>Value</h3>

<p>A pixel image or a list of pixel images.
For scalar-valued measures, a pixel image (object of class
<code>"im"</code>) provided <code>drop=TRUE</code>.
For vector-valued measures (or if <code>drop=FALSE</code>),
a list of pixel images; the list also
belongs to the class <code>"solist"</code> so that it can be printed and plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R., Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Baddeley, A., Moller, J. and Pakes, A.G. (2008) 
Properties of residuals for spatial point processes.
<em>Annals of the Institute of Statistical Mathematics</em>
<b>60</b>, 627&ndash;649.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Smooth">Smooth</a></code>,
<code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic+plot.msr">plot.msr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")
   rs &lt;- residuals(fit, type="score")

   plot(Smooth(rp))
   plot(Smooth(rs))
</code></pre>

<hr>
<h2 id='Softcore'>The Soft Core Point Process Model</h2><span id='topic+Softcore'></span>

<h3>Description</h3>

<p>Creates an instance of the Soft Core point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Softcore(kappa, sigma0=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Softcore_+3A_kappa">kappa</code></td>
<td>
<p>The exponent <code class="reqn">\kappa</code> of the Soft Core
interaction</p>
</td></tr>
<tr><td><code id="Softcore_+3A_sigma0">sigma0</code></td>
<td>

<p>Optional. Initial estimate of the parameter <code class="reqn">\sigma</code>.
A positive number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (stationary)
Soft Core point process with parameters <code class="reqn">\beta</code> and
<code class="reqn">\sigma</code> and exponent <code class="reqn">\kappa</code>
is the pairwise interaction point process in which 
each point contributes a factor <code class="reqn">\beta</code> to the 
probability density of the point pattern, and each pair of points
contributes a factor
</p>
<p style="text-align: center;"><code class="reqn">
    \exp \left\{ - \left( \frac{\sigma}{d} \right)^{2/\kappa} \right\}
  </code>
</p>

<p>to the density, where <code class="reqn">d</code> is the distance between the two points.
See the Examples for a plot of this interaction curve.
</p>
<p>Thus the process has probability density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)}
    \exp \left\{ - \sum_{i &lt; j} \left(
                 \frac{\sigma}{||x_i-x_j||}
    \right)^{2/\kappa} \right\}
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, <code class="reqn">\alpha</code> is the normalising constant,
and the sum on the right hand side is
over all unordered pairs of points of the pattern. 
</p>
<p>This model describes an &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; process,
with the strength of inhibition decreasing smoothly with distance.
The interaction is controlled by the parameters <code class="reqn">\sigma</code>
and <code class="reqn">\kappa</code>.
</p>

<ul>
<li>
<p>The <em>spatial scale</em> of interaction is controlled by the
parameter <code class="reqn">\sigma</code>, which is a positive real number
interpreted as a distance, expressed in the same units of distance as
the spatial data. The parameter <code class="reqn">\sigma</code> is the distance at which the
pair potential reaches the threshold value 0.37.
</p>
</li>
<li>
<p>The <em>shape</em> of the interaction function
is controlled by the exponent
<code class="reqn">\kappa</code> which is a dimensionless number
in the range <code class="reqn">(0,1)</code>, with larger values corresponding to
a flatter shape (or a more gradual decay rate).
The process is well-defined only for <code class="reqn">\kappa</code> in
<code class="reqn">(0,1)</code>.
The limit of the model as <code class="reqn">\kappa \to 0</code> is the
hard core process with hard core distance <code class="reqn">h=\sigma</code>.
</p>
</li>
<li>
<p>The &ldquo;strength&rdquo; of the interaction is determined by both of the
parameters <code class="reqn">\sigma</code> and <code class="reqn">\kappa</code>.
The larger the value of <code class="reqn">\kappa</code>, the wider the range of
distances over which the interaction has an effect.
If <code class="reqn">\sigma</code> is very small, the interaction is very weak
for all practical purposes (theoretically if <code class="reqn">\sigma = 0</code>
the model reduces to the Poisson point process).
</p>
</li></ul>

<p>The nonstationary Soft Core process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Soft Core process pairwise interaction is
yielded by the function <code>Softcore()</code>. See the examples below.
</p>
<p>The main argument is the exponent  <code>kappa</code>.
When <code>kappa</code> is fixed, the model becomes an exponential family
with canonical parameters <code class="reqn">\log \beta</code>
and </p>
<p style="text-align: center;"><code class="reqn">
    \log \gamma = \frac{2}{\kappa} \log\sigma
  </code>
</p>

<p>The canonical parameters are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>Softcore()</code>. 
</p>
<p>The optional argument <code>sigma0</code> can be used to improve
numerical stability. If <code>sigma0</code> is given, it should be a positive
number, and it should be a rough estimate of the
parameter <code class="reqn">\sigma</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the Soft Core process with exponent <code class="reqn">\kappa</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Ogata, Y, and Tanemura, M. (1981).
Estimation of interaction potentials of spatial point patterns
through the maximum likelihood procedure.
<em>Annals of the Institute of Statistical Mathematics</em>, B
<b>33</b>, 315&ndash;338.
</p>
<p>Ogata, Y, and Tanemura, M. (1984).
Likelihood analysis of spatial point patterns.
<em>Journal of the Royal Statistical Society, series B</em>
<b>46</b>, 496&ndash;518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # fit the stationary Soft Core process to `cells' 
   fit5 &lt;- ppm(cells ~1, Softcore(kappa=0.5), correction="isotropic")

   # study shape of interaction and explore effect of parameters
   fit2 &lt;- update(fit5, Softcore(kappa=0.2))
   fit8 &lt;- update(fit5, Softcore(kappa=0.8))
   plot(fitin(fit2), xlim=c(0, 0.4),
        main="Pair potential (sigma = 0.1)", 
        xlab=expression(d), ylab=expression(h(d)), legend=FALSE)
   plot(fitin(fit5), add=TRUE, col=4)
   plot(fitin(fit8), add=TRUE, col=3)
   legend("bottomright", col=c(1,4,3), lty=1,
          legend=expression(kappa==0.2, kappa==0.5, kappa==0.8))
</code></pre>

<hr>
<h2 id='spatstat.model-internal'>Internal spatstat.model functions</h2><span id='topic+accumulateStatus'></span><span id='topic+active.interactions'></span><span id='topic+adaptcoef'></span><span id='topic+affine.msr'></span><span id='topic+areadelta2'></span><span id='topic+as.isf'></span><span id='topic+augment.msr'></span><span id='topic+bigvaluerule'></span><span id='topic+blankcoefnames'></span><span id='topic+bt.frame'></span><span id='topic+cannot.update'></span><span id='topic+check.separable'></span><span id='topic+coef.summary.kppm'></span><span id='topic+coef.summary.ppm'></span><span id='topic+coef.summary.slrm'></span><span id='topic+coef.vblogit'></span><span id='topic+condSimCox'></span><span id='topic+damaged.ppm'></span><span id='topic+data.mppm'></span><span id='topic+deltasuffstat'></span><span id='topic+dfbetas.ppmInfluence'></span><span id='topic+diagnose.ppm.engine'></span><span id='topic+dim.msr'></span><span id='topic+dimnames.msr'></span><span id='topic+doMultiStraussHard'></span><span id='topic+dppDpcf'></span><span id='topic+dppmFixAlgorithm'></span><span id='topic+dppmFixIntensity'></span><span id='topic+DPPSaddle'></span><span id='topic+DPPSaddlePairwise'></span><span id='topic+enet.engine'></span><span id='topic+equalpairs'></span><span id='topic+evalInteraction'></span><span id='topic+evalInterEngine'></span><span id='topic+evalPairPotential'></span><span id='topic+evalPairwiseTerm'></span><span id='topic+expandDot'></span><span id='topic+extractAIC.slrm'></span><span id='topic+fakefii'></span><span id='topic+family.hackglmmPQL'></span><span id='topic+family.vblogit'></span><span id='topic+fill.coefs'></span><span id='topic+findCovariate'></span><span id='topic+fii'></span><span id='topic+flipxy.msr'></span><span id='topic+forbid.logi'></span><span id='topic+formula.hackglmmPQL'></span><span id='topic+getdataname'></span><span id='topic+getglmdata'></span><span id='topic+getglmdata.ppm'></span><span id='topic+getglmdata.mppm'></span><span id='topic+getglmdata.slrm'></span><span id='topic+getglmfit'></span><span id='topic+getglmfit.ppm'></span><span id='topic+getglmfit.mppm'></span><span id='topic+getglmfit.slrm'></span><span id='topic+getglmsubset'></span><span id='topic+getglmsubset.ppm'></span><span id='topic+getglmsubset.mppm'></span><span id='topic+getglmsubset.slrm'></span><span id='topic+getppmdatasubset'></span><span id='topic+getppmOriginalCovariates'></span><span id='topic+geyercounts'></span><span id='topic+geyerdelta2'></span><span id='topic+GLMpredict'></span><span id='topic+hackglmmPQL'></span><span id='topic+hasglmfit'></span><span id='topic+hasglmfit.ppm'></span><span id='topic+hasglmfit.mppm'></span><span id='topic+hasglmfit.slrm'></span><span id='topic+hierarchicalordering'></span><span id='topic+hiermat'></span><span id='topic+ho.engine'></span><span id='topic+illegal.iformula'></span><span id='topic+impliedpresence'></span><span id='topic+impliedcoefficients'></span><span id='topic+influence.ppmInfluence'></span><span id='topic+instantiate.interact'></span><span id='topic+interactionfamilyname'></span><span id='topic+intermaker'></span><span id='topic+is.expandable.ppm'></span><span id='topic+is.interact'></span><span id='topic+is.marked.mppm'></span><span id='topic+is.marked.msr'></span><span id='topic+is.marked.rppm'></span><span id='topic+is.marked.slrm'></span><span id='topic+is.mppm'></span><span id='topic+is.multitype.mppm'></span><span id='topic+is.multitype.msr'></span><span id='topic+is.multitype.rppm'></span><span id='topic+is.multitype.slrm'></span><span id='topic+is.poisson.mppm'></span><span id='topic+is.poisson.rppm'></span><span id='topic+Kpcf.kppm'></span><span id='topic+Kmodel.slrm'></span><span id='topic+killinteraction'></span><span id='topic+kppmComLik'></span><span id='topic+kppmMinCon'></span><span id='topic+kppmPalmLik'></span><span id='topic+kppmCLadap'></span><span id='topic+labels.ppm'></span><span id='topic+leverage.ppmInfluence'></span><span id='topic+lines.objsurf'></span><span id='topic+logi.engine'></span><span id='topic+logLik.vblogit'></span><span id='topic+LurkEngine'></span><span id='topic+make.pspace'></span><span id='topic+mapInterVars'></span><span id='topic+Mayer'></span><span id='topic+model.se.image'></span><span id='topic+modelFrameGam'></span><span id='topic+mpl.engine'></span><span id='topic+mpl.get.covariates'></span><span id='topic+mpl.prepare'></span><span id='topic+mpl.usable'></span><span id='topic+newformula'></span><span id='topic+newstyle.coeff.handling'></span><span id='topic+nndcumfun'></span><span id='topic+no.trend.ppm'></span><span id='topic+objsurfEngine'></span><span id='topic+optimConverged'></span><span id='topic+optimStatus'></span><span id='topic+optimNsteps'></span><span id='topic+outdated.interact'></span><span id='topic+oversize.quad'></span><span id='topic+parameters.detpointprocfamily'></span><span id='topic+PairPotentialType'></span><span id='topic+partialModelMatrix'></span><span id='topic+pcfmodel.slrm'></span><span id='topic+ploterodewin'></span><span id='topic+ploterodeimage'></span><span id='topic+plot.addvar'></span><span id='topic+plot.lurk'></span><span id='topic+plot.minconfit'></span><span id='topic+plot.parres'></span><span id='topic+plot.qqppm'></span><span id='topic+poisson.fits.better'></span><span id='topic+PoissonCompareCalc'></span><span id='topic+PoisSaddle'></span><span id='topic+PoisSaddleArea'></span><span id='topic+PoisSaddleGeyer'></span><span id='topic+PoisSaddlePairwise'></span><span id='topic+PPMmodelmatrix'></span><span id='topic+ppm.default'></span><span id='topic+ppmCovariates'></span><span id='topic+ppmDerivatives'></span><span id='topic+ppmInfluenceEngine'></span><span id='topic+predict.profilepl'></span><span id='topic+predict.vblogit'></span><span id='topic+printStatus'></span><span id='topic+printStatusList'></span><span id='topic+print.addvar'></span><span id='topic+print.bt.frame'></span><span id='topic+print.diagppm'></span><span id='topic+print.detpointprocfamily'></span><span id='topic+print.detpointprocfamilyfun'></span><span id='topic+print.hierarchicalordering'></span><span id='topic+print.influence.ppm'></span><span id='topic+print.interact'></span><span id='topic+print.intermaker'></span><span id='topic+print.isf'></span><span id='topic+print.leverage.ppm'></span><span id='topic+print.lurk'></span><span id='topic+print.minconfit'></span><span id='topic+print.mppm'></span><span id='topic+print.msr'></span><span id='topic+print.parres'></span><span id='topic+print.plotppm'></span><span id='topic+print.profilepl'></span><span id='topic+print.qqppm'></span><span id='topic+print.rppm'></span><span id='topic+print.summary.mppm'></span><span id='topic+print.summary.slrm'></span><span id='topic+print.vblogit'></span><span id='topic+quad.mppm'></span><span id='topic+quadBlockSizes'></span><span id='topic+reach.slrm'></span><span id='topic+reduceformula'></span><span id='topic+reincarnate.interact'></span><span id='topic+rescale.msr'></span><span id='topic+resid4plot'></span><span id='topic+resid1plot'></span><span id='topic+resid1panel'></span><span id='topic+rotate.msr'></span><span id='topic+SaddleApprox'></span><span id='topic+safeFiniteValue'></span><span id='topic+safePositiveValue'></span><span id='topic+scalardilate.msr'></span><span id='topic+shift.influence.ppm'></span><span id='topic+shift.leverage.ppm'></span><span id='topic+shift.msr'></span><span id='topic+signalStatus'></span><span id='topic+simulate.profilepl'></span><span id='topic+slr.prepare'></span><span id='topic+slrAssemblePixelData'></span><span id='topic+slrmInfluence'></span><span id='topic+spatialCovariateEvidence.ppm'></span><span id='topic+spatialCovariateEvidence.slrm'></span><span id='topic+spatialCovariateUnderModel'></span><span id='topic+spatialCovariateUnderModel.ppm'></span><span id='topic+spatialCovariateUnderModel.kppm'></span><span id='topic+spatialCovariateUnderModel.dppm'></span><span id='topic+spatialCovariateUnderModel.slrm'></span><span id='topic+spatstatDPPModelInfo'></span><span id='topic+splitHybridInteraction'></span><span id='topic+sp.foundclass'></span><span id='topic+sp.foundclasses'></span><span id='topic+strausscounts'></span><span id='topic+stripGLMM'></span><span id='topic+suffloc'></span><span id='topic+suffstat.generic'></span><span id='topic+suffstat.poisson'></span><span id='topic+summary.mppm'></span><span id='topic+summary.msr'></span><span id='topic+summary.profilepl'></span><span id='topic+summary.vblogit'></span><span id='topic+terms.rppm'></span><span id='topic+tweak.coefs'></span><span id='topic+unitname.msr'></span><span id='topic+unitname+3C-.msr'></span><span id='topic+update.ippm'></span><span id='topic+update.msr'></span><span id='topic+updateData.ppm'></span><span id='topic+updateData.kppm'></span><span id='topic+updateData.dppm'></span><span id='topic+updateData.slrm'></span><span id='topic+varcountEngine'></span><span id='topic+versionstring.interact'></span><span id='topic+versionstring.ppm'></span><span id='topic+windows.mppm'></span>

<h3>Description</h3>

<p>Internal spatstat.model functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

accumulateStatus(x, stats)
active.interactions(object)
adaptcoef(new.coef, fitcoef, drop)
## S3 method for class 'msr'
affine(X, mat, vec, ...)
areadelta2(X, r, ..., sparseOK)
as.isf(object)
augment.msr(x, ..., sigma, recompute)
blankcoefnames(x)
bt.frame(Q, trend, interaction, ..., covariates,
         correction, rbord, use.gam, allcovar)
bigvaluerule(objfun, objargs, startpar, ...)
cannot.update(...)
check.separable(dmat, covname, isconstant, fatal)
## S3 method for class 'summary.kppm'
coef(object, ...)
## S3 method for class 'summary.ppm'
coef(object, ...)
## S3 method for class 'summary.slrm'
coef(object, ...)
## S3 method for class 'vblogit'
coef(object, ...) 
condSimCox(object, nsim, ..., window, n.cond, w.cond,
           giveup, maxchunk, saveLambda, verbose, drop)
damaged.ppm(object)
data.mppm(x)
deltasuffstat(model, ...,
              restrict, dataonly, sparseOK, quadsub,
              force, warn.forced, verbose, use.special)
## S3 method for class 'ppmInfluence'
dfbetas(model, ...)
diagnose.ppm.engine(object, ..., type, typename, opt,
                         sigma, rbord, compute.sd, compute.cts,
                         envelope, nsim, nrank,
                         rv, oldstyle, splineargs, verbose)
## S3 method for class 'msr'
dim(x)
## S3 method for class 'msr'
dimnames(x)
doMultiStraussHard(iradii, hradii, types)
dppDpcf(model, ...)
dppmFixIntensity(DPP, lambda, po)
dppmFixAlgorithm(algorithm, changealgorithm, clusters, startpar)
DPPSaddle(beta, fi)
DPPSaddlePairwise(beta, fi)
enet.engine(model, ..., standardize, lambda, alpha, adaptive) 
equalpairs(U, X, marked=FALSE)
evalInteraction(X,P,E,interaction,correction,splitInf,...,
                precomputed,savecomputed)
evalInterEngine(X,P,E,interaction,correction,splitInf,...,
                Reach,precomputed,savecomputed)
evalPairPotential(X,P,E,pairpot,potpars,R)
evalPairwiseTerm(fint, d)
expandDot(f, dotvars)
## S3 method for class 'slrm'
extractAIC(fit, scale = 0, k = 2, ...)
fakefii(model)
## S3 method for class 'hackglmmPQL'
family(object, ...)
## S3 method for class 'vblogit'
family(object, ...)
fill.coefs(coefs, required)
findCovariate(covname, scope, scopename=NULL)
fii(interaction, coefs, Vnames, IsOffset, vnameprefix)
## S3 method for class 'msr'
flipxy(X)
forbid.logi(object)
## S3 method for class 'hackglmmPQL'
formula(x, ...)
getdataname(defaultvalue, ..., dataname)
getglmdata(object, ...)
## S3 method for class 'ppm'
getglmdata(object, ..., drop=FALSE)
## S3 method for class 'mppm'
getglmdata(object, ...)
## S3 method for class 'slrm'
getglmdata(object, ...)
getglmfit(object, ...)
## S3 method for class 'ppm'
getglmfit(object, ...)
## S3 method for class 'mppm'
getglmfit(object, ...)
## S3 method for class 'slrm'
getglmfit(object, ...)
getglmsubset(object, ...)
## S3 method for class 'ppm'
getglmsubset(object, ...)
## S3 method for class 'mppm'
getglmsubset(object, ...)
## S3 method for class 'slrm'
getglmsubset(object, ...)
getppmdatasubset(object)
getppmOriginalCovariates(object)
geyercounts(U,X,r,sat,Xcounts,EqualPairs)
geyerdelta2(X,r,sat,...,sparseOK, correction)
GLMpredict(fit, data, coefs, changecoef, type)
hackglmmPQL(fixed, random, family, data, correlation, weights,
            control, niter, verbose, subset, ..., reltol)
hasglmfit(object)
## S3 method for class 'mppm'
hasglmfit(object)
## S3 method for class 'ppm'
hasglmfit(object)
## S3 method for class 'slrm'
hasglmfit(object)
hierarchicalordering(i, s)
hiermat(x, h)
ho.engine(model, ..., nsim, nrmh, start, control, verb)
illegal.iformula(ifmla, itags, dfvarnames)
impliedpresence(tags, formula, df, extranames=character(0))
impliedcoefficients(object, tag, new.coef)
## S3 method for class 'ppmInfluence'
influence(model, ...)
instantiate.interact(x, par)
interactionfamilyname(object)
intermaker(f, blank)
## S3 method for class 'ppm'
is.expandable(x)  
is.interact(x)
## S3 method for class 'mppm'
is.marked(X, ...)
## S3 method for class 'msr'
is.marked(X, ...)
## S3 method for class 'rppm'
is.marked(X, ...)
## S3 method for class 'slrm'
is.marked(X, ...)
is.mppm(x)
## S3 method for class 'mppm'
is.multitype(X, ...)
## S3 method for class 'msr'
is.multitype(X, ...)
## S3 method for class 'rppm'
is.multitype(X, ...)
## S3 method for class 'slrm'
is.multitype(X, ...)
## S3 method for class 'mppm'
is.poisson(x)
## S3 method for class 'rppm'
is.poisson(x)
Kpcf.kppm(model, what)
## S3 method for class 'slrm'
Kmodel(model, ...)
killinteraction(model)
kppmComLik(X, Xname, po, clusters, control, stabilize, weightfun, rmax,
           algorithm, DPP, ..., pspace)
kppmMinCon(X, Xname, po, clusters, control, stabilize, statistic, statargs,
           algorithm, DPP, ..., pspace)
kppmPalmLik(X, Xname, po, clusters, control, stabilize, weightfun, rmax, 
           algorithm, DPP, ..., pspace)
kppmCLadap(X, Xname, po, clusters, control, weightfun, 
           rmax, epsilon, DPP, algorithm, ...,
           startpar, globStrat)
## S3 method for class 'ppm'
labels(object, ...)
## S3 method for class 'ppmInfluence'
leverage(model, ...)
## S3 method for class 'objsurf'
lines(x, ..., directed)
logi.engine(Q, trend, interaction, ..., 
            covariates, subsetexpr, clipwin,
            correction, rbord, covfunargs, allcovar, 
            vnamebase, vnameprefix, justQ, savecomputed, precomputed,
            VB)
## S3 method for class 'vblogit'
logLik(object, ...)
LurkEngine(object, type, cumulative, plot.sd, 
           quadpoints, wts, Z, subQset, 
           covvalues, resvalues, 
           clip, clipwindow, cov.is.im, covrange, 
           typename, covname,
           cl, clenv,
           oldstyle, check,
           verbose, nx, splineargs,
           envelope, nsim, nrank, Xsim,
           internal, checklength)
make.pspace(..., canonical, adjusted, trace, save, trajectory,
             nhalfgrid, strict, penalised, penalty,
             penal.args, tau, clusters, fitmethod,
             flatness, C0factor, xval, xval.args,
             debug, transfo)
mapInterVars(object, subs, mom)
Mayer(fi, exponent)
model.se.image(fit, W, ..., what, new.coef)
modelFrameGam(formula, ...)
mpl.engine(Q, trend, interaction, ...,
         covariates, subsetexpr, clipwin, covfunargs, correction,
	 rbord, use.gam, gcontrol,
         GLM, GLMfamily, GLMcontrol, famille,
         forcefit, nd, eps, allcovar, callstring,
         precomputed, savecomputed, preponly,
         rename.intercept, justQ, weightfactor)
mpl.get.covariates(covariates, locations, type, covfunargs, need.deriv)
mpl.prepare(Q, X, P, trend, interaction, covariates, 
            want.trend, want.inter, correction, rbord, Pname,
            callstring, ...,
            subsetexpr,
            covfunargs, allcovar, precomputed, savecomputed,
            vnamebase, vnameprefix, warn.illegal, warn.unidentifiable,
            weightfactor, skip.border, clip.interaction, splitInf)
mpl.usable(x)
newformula(old, change, eold, enew, expandpoly, dotvars)
newstyle.coeff.handling(object)
nndcumfun(X, ..., r)
no.trend.ppm(x)
objsurfEngine(objfun, optpar, objargs,
              ..., dotargs, objname,
              new.objargs, parmap, 
              ngrid, xlim, ylim, ratio, verbose)
optimConverged(x)
optimStatus(x, call)
optimNsteps(x)
outdated.interact(object)
oversize.quad(Q, ..., nU, nX, p)
PairPotentialType(pairpot)
## S3 method for class 'detpointprocfamily'
parameters(model, ...)
partialModelMatrix(X,D,model,callstring,...)
## S3 method for class 'slrm'
pcfmodel(model, ...)
ploterodewin(W1, W2, col.edge, col.inside, do.plot, ...)
ploterodeimage(W, Z, ..., Wcol, rangeZ, colsZ, do.plot)
## S3 method for class 'addvar'
plot(x, ..., do.points=FALSE)
## S3 method for class 'lurk'
plot(x, ..., shade)
## S3 method for class 'minconfit'
plot(x, ...)
## S3 method for class 'parres'
plot(x, ...)
## S3 method for class 'qqppm'
plot(x, ..., limits=TRUE,
           monochrome=spatstat.options('monochrome'),
           limcol=if(monochrome) "black" else "red")
poisson.fits.better(object)
PoissonCompareCalc(object)
PoisSaddle(beta, fi)
PoisSaddleArea(beta, fi)
PoisSaddleGeyer(beta, fi)
PoisSaddlePairwise(beta, fi)
PPMmodelmatrix(object, data, ..., subset, Q, keepNA, irregular,
               splitInf)
## Default S3 method:
ppm(Q, trend, interaction,
       ..., covariates, data, covfunargs, subset, clipwin,
       correction, rbord, use.gam, method, forcefit,
       improve.type, improve.args, emend, project,
       prior.mean, prior.var,
       nd, eps, gcontrol, nsim, nrmh, start, control,
       verb, callstring)
ppmCovariates(model)
ppmDerivatives(fit, what, Dcovfun, loc, covfunargs)
ppmInfluenceEngine(fit, what, ..., iScore, iHessian, iArgs,
              drop, method, fine, precomputed, sparseOK,
              fitname, multitypeOK, entrywise, matrix.action,
              dimyx, eps, rule.eps,
              geomsmooth)
## S3 method for class 'vblogit'
predict(object, newdata, type, se.fit, dispersion,
                          terms, na.action, ...)
## S3 method for class 'profilepl'
predict(object, ...)
printStatus(x, errors.only)
printStatusList(stats)
## S3 method for class 'addvar'
print(x, ...)
## S3 method for class 'bt.frame'
print(x, ...)
## S3 method for class 'diagppm'
print(x, ...)
## S3 method for class 'detpointprocfamily'
print(x, ...)
## S3 method for class 'detpointprocfamilyfun'
print(x, ...)
## S3 method for class 'hierarchicalordering'
print(x, ...)
## S3 method for class 'influence.ppm'
print(x, ...)
## S3 method for class 'interact'
print(x, ..., family, brief, banner)       
## S3 method for class 'intermaker'
print(x, ...)
## S3 method for class 'isf'
print(x, ...)
## S3 method for class 'leverage.ppm'
print(x, ...)
## S3 method for class 'lurk'
print(x, ...)
## S3 method for class 'minconfit'
print(x, ...)
## S3 method for class 'mppm'
print(x, ...)
## S3 method for class 'msr'
print(x, ...)
## S3 method for class 'parres'
print(x, ...)
## S3 method for class 'plotppm'
print(x, ...)
## S3 method for class 'profilepl'
print(x, ...)
## S3 method for class 'qqppm'
print(x, ...)
## S3 method for class 'rppm'
print(x, ...)
## S3 method for class 'summary.mppm'
print(x, ..., brief)
## S3 method for class 'summary.slrm'
print(x, ...)
## S3 method for class 'vblogit'
print(x, ...)
quad.mppm(x)
quadBlockSizes(nX, nD, p, nMAX, announce)
## S3 method for class 'slrm'
reach(x, ...)
reduceformula(fmla, deletevar, verbose)
reincarnate.interact(object)
## S3 method for class 'msr'
rescale(X, s, unitname)
resid4plot(RES, plot.neg, plot.smooth,
           spacing, outer, srange, monochrome, main,
           xlab, ylab, rlab, col.neg, col.smooth, ...)
resid1plot(RES, opt, plot.neg, plot.smooth,
              srange, monochrome, main,
              add, show.all, do.plot, col.neg, col.smooth, ...)
resid1panel(observedX, observedV,
            theoreticalX, theoreticalV, theoreticalSD,
            xlab,ylab, ..., do.plot)
## S3 method for class 'msr'
rotate(X, angle, ..., centre)
SaddleApprox(beta, fi, approx)
safeFiniteValue(x, default)
safePositiveValue(x, default)
## S3 method for class 'msr'
scalardilate(X, f, ...)
## S3 method for class 'influence.ppm'
shift(X, ...)
## S3 method for class 'leverage.ppm'
shift(X, ...)
## S3 method for class 'msr'
shift(X, ...)
signalStatus(x, errors.only)
## S3 method for class 'profilepl'
simulate(object, ...)
slr.prepare(CallInfo, envir, data, dataAtPoints, splitby, clip)
slrAssemblePixelData(Y, Yname, W, covimages, dataAtPoints, pixelarea)
slrmInfluence(model, what, ...)
## S3 method for class 'ppm'
spatialCovariateEvidence(model, covariate, ..., lambdatype,
          dimyx, eps, rule.eps, interpolate, jitter, jitterfactor,
          modelname, covname, dataname, subset, clip.predict) 
## S3 method for class 'slrm'
spatialCovariateEvidence(model, covariate, ..., lambdatype,
          jitter, jitterfactor,
          modelname, covname, dataname, subset, raster.action) 
spatialCovariateUnderModel(model, covariate, ...)
## S3 method for class 'ppm'
spatialCovariateUnderModel(model, covariate, ...)
## S3 method for class 'kppm'
spatialCovariateUnderModel(model, covariate, ...)
## S3 method for class 'dppm'
spatialCovariateUnderModel(model, covariate, ...)
## S3 method for class 'slrm'
spatialCovariateUnderModel(model, covariate, ...)
spatstatDPPModelInfo(model)
splitHybridInteraction(coeffs, inte)
sp.foundclass(cname, inlist, formalname, argsgiven)             
sp.foundclasses(cnames, inlist, formalname, argsgiven)
strausscounts(U,X,r,EqualPairs)
stripGLMM(object)
suffloc(object)
suffstat.generic(model, X, callstring)
suffstat.poisson(model, X, callstring)
## S3 method for class 'mppm'
summary(object, ..., brief=FALSE)
## S3 method for class 'msr'
summary(object, ...)
## S3 method for class 'profilepl'
summary(object, ...)
## S3 method for class 'vblogit'
summary(object, ...)
## S3 method for class 'rppm'
terms(x, ...)
tweak.coefs(model, new.coef)
## S3 method for class 'msr'
unitname(x) 
## S3 replacement method for class 'msr'
unitname(x) &lt;- value 
## S3 method for class 'ippm'
update(object, ..., envir) 
## S3 method for class 'msr'
update(object, ...)
## S3 method for class 'ppm'
updateData(model, X, ..., warn)
## S3 method for class 'kppm'
updateData(model, X, ...)
## S3 method for class 'dppm'
updateData(model, X, ...)
## S3 method for class 'slrm'
updateData(model, X, ...)
varcountEngine(g, B, lambdaB, f, R, what)
versionstring.interact(object)
versionstring.ppm(object)
windows.mppm(x)



</code></pre>


<h3>Details</h3>

<p>These internal <span class="pkg">spatstat.model</span> functions should not be called
directly by the user. Their names and capabilities may change
without warning from one version of <span class="pkg">spatstat.model</span> to the next.
</p>


<h3>Value</h3>

<p>The return values of these functions are not documented,
and may change without warning.
</p>

<hr>
<h2 id='spatstat.model-package'>The spatstat.model Package</h2><span id='topic+spatstat.model-package'></span><span id='topic+spatstat.model'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.model</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the core functionality
for parametric statistical modelling of spatial data.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span class="rlang"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.model</span> contains all the main
user-level functions
that perform parametric statistical modelling of spatial data.
</p>
<p>(The main exception is that functions for linear networks
are in the separate sub-package <span class="pkg">spatstat.linnet</span>.)
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the functionality
for exploratory analysis and nonparametric modelling of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for parametric modelling, analysis and inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li></ul>

<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
</p>
<p>For an overview of all the functions available in
the sub-packages of <span class="pkg">spatstat</span>,
see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package.
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li></ul>

<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Overview of Functionality in <span class="pkg">spatstat.model</span></h3>

<p>The <span class="pkg">spatstat</span> family of packages
is designed to support a complete statistical analysis
of spatial data. It supports
</p>

<ul>
<li><p> creation, manipulation and plotting of point patterns;
</p>
</li>
<li><p> exploratory data analysis;
</p>
</li>
<li><p> spatial random sampling;
</p>
</li>
<li><p> simulation of point process models;
</p>
</li>
<li><p> parametric model-fitting;
</p>
</li>
<li><p> non-parametric smoothing and regression;
</p>
</li>
<li><p> formal inference (hypothesis tests, confidence intervals);
</p>
</li>
<li><p> model diagnostics.
</p>
</li></ul>

<p>For an overview, see the help file for <code>"spatstat-package"</code>
in the <span class="pkg">spatstat</span> package. 
</p>
<p>Following is a list of the functionality provided in the
<span class="pkg">spatstat.model</span> package only.
</p>
<p><b>To simulate a random point pattern:</b>
</p>
<p>Functions for generating random point patterns
are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p><b>Exploratory analysis</b>
</p>
<p>Exploratory graphics, 
smoothing, and exploratory analysis of spatial data
are now provided in the <span class="pkg">spatstat.explore</span> package.
</p>
<p><b>Model fitting (Cox and cluster models)</b>
</p>
<p>Cluster process models (with homogeneous or inhomogeneous intensity)
and Cox processes can be fitted by the function <code><a href="#topic+kppm">kppm</a></code>.
Its result is an object of class <code>"kppm"</code>.
The fitted model can be printed, plotted, predicted, simulated
and updated.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+kppm">kppm</a></code> </td><td style="text-align: left;">  Fit model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.kppm">plot.kppm</a></code> </td><td style="text-align: left;">  Plot the fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+summary.kppm">summary.kppm</a></code> </td><td style="text-align: left;">  Summarise the fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitted.kppm">fitted.kppm</a></code> </td><td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict.kppm">predict.kppm</a></code> </td><td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+update.kppm">update.kppm</a></code> </td><td style="text-align: left;"> Update the model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+improve.kppm">improve.kppm</a></code> </td><td style="text-align: left;"> Refine the estimate of trend </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+simulate.kppm">simulate.kppm</a></code> </td><td style="text-align: left;"> Generate simulated realisations </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vcov.kppm">vcov.kppm</a></code> </td><td style="text-align: left;"> Variance-covariance matrix of coefficients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+methods.kppm">coef.kppm</a></code>
    </td><td style="text-align: left;"> Extract trend coefficients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+methods.kppm">formula.kppm</a></code>
    </td><td style="text-align: left;"> Extract trend formula </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+parameters">parameters</a></code> </td><td style="text-align: left;"> Extract all model parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clusterfield.kppm">clusterfield.kppm</a></code> </td><td style="text-align: left;"> Compute offspring density </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clusterradius.kppm">clusterradius.kppm</a></code> </td><td style="text-align: left;"> Radius of support of offspring density </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kmodel.kppm">Kmodel.kppm</a></code> </td><td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfmodel.kppm">pcfmodel.kppm</a></code> </td><td style="text-align: left;"> Pair correlation of fitted model 
  </td>
</tr>

</table>

<p>For model selection, you can also use 
the generic functions <code><a href="stats.html#topic+step">step</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code> 
and <code><a href="stats.html#topic+AIC">AIC</a></code> on fitted point process models.
For variable selection, see <code><a href="spatstat.explore.html#topic+sdr">sdr</a></code>.
</p>
<p>The theoretical models can also be simulated,
for any choice of parameter values,
using <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>, <code><a href="spatstat.random.html#topic+rMatClust">rMatClust</a></code>,
<code><a href="spatstat.random.html#topic+rCauchy">rCauchy</a></code>, <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>,
and <code><a href="spatstat.random.html#topic+rLGCP">rLGCP</a></code>.
</p>
<p>Lower-level fitting functions include:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lgcp.estK">lgcp.estK</a></code> </td><td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code> </td><td style="text-align: left;"> fit a log-Gaussian Cox process model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+thomas.estK">thomas.estK</a></code> </td><td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code> </td><td style="text-align: left;"> fit the Thomas process model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+matclust.estK">matclust.estK</a></code> </td><td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+matclust.estpcf">matclust.estpcf</a></code> </td><td style="text-align: left;"> fit the Matern Cluster process model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cauchy.estK">cauchy.estK</a></code> </td><td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+cauchy.estpcf">cauchy.estpcf</a></code> </td><td style="text-align: left;"> fit a Neyman-Scott Cauchy cluster process</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+vargamma.estK">vargamma.estK</a></code> </td><td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+vargamma.estpcf">vargamma.estpcf</a></code> </td><td style="text-align: left;"> fit a Neyman-Scott Variance Gamma process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mincontrast">mincontrast</a></code> </td><td style="text-align: left;"> low-level algorithm for fitting models
    </td>
</tr>
<tr>
 <td style="text-align: left;"> </td><td style="text-align: left;"> by the method of minimum contrast 
  </td>
</tr>

</table>

<p><b>Model fitting (Poisson and Gibbs models)</b>
</p>
<p>Poisson point processes are the simplest models for point patterns.
A Poisson model assumes that the points are stochastically
independent. It may allow the points to have a non-uniform spatial
density. The special case of a Poisson process with a uniform
spatial density is often called Complete Spatial Randomness.
</p>
<p>Poisson point processes are included in the more general class of Gibbs point
process models. In a Gibbs model, there is <em>interaction</em>
or dependence between points. Many different types of interaction
can be specified.
</p>
<p>For a detailed explanation of how to fit Poisson or
Gibbs point process models to point pattern data using <span class="pkg">spatstat</span>,
see Baddeley and Turner (2005b) or Baddeley (2008).
</p>
<p><b>To fit a Poisson or Gibbs point process model:</b>
</p>
<p>Model fitting in <span class="pkg">spatstat</span> is performed mainly by the function
<code><a href="#topic+ppm">ppm</a></code>. Its result is an object of class <code>"ppm"</code>.
</p>
<p>Here are some examples, where <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
 <td style="text-align: left;">
    <em>command</em> </td><td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppm(X)</code> </td><td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppm(X ~ 1)</code> </td><td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppm(X ~ x)</code> </td><td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
 <td style="text-align: left;">
                             </td><td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppm(X ~ 1, Strauss(0.1))</code> </td><td style="text-align: left;"> Stationary Strauss process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ppm(X ~ x, Strauss(0.1))</code> </td><td style="text-align: left;"> Strauss process with </td>
</tr>
<tr>
 <td style="text-align: left;">
                              </td><td style="text-align: left;"> conditional intensity loglinear in <code class="reqn">x</code>
  </td>
</tr>

</table>

<p>It is also possible to fit models that depend on
other covariates.
</p>
<p><b>Manipulating the fitted model:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.ppm">plot.ppm</a></code> </td><td style="text-align: left;"> 		Plot the fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict.ppm">predict.ppm</a></code>
    </td><td style="text-align: left;">   Compute the spatial trend and conditional intensity</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">   of the fitted point process model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+coef.ppm">coef.ppm</a></code> </td><td style="text-align: left;"> Extract the fitted model coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+parameters">parameters</a></code> </td><td style="text-align: left;"> Extract all model parameters</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+formula.ppm">formula.ppm</a></code> </td><td style="text-align: left;"> Extract the trend formula</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+intensity.ppm">intensity.ppm</a></code> </td><td style="text-align: left;"> Compute fitted intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kmodel.ppm">Kmodel.ppm</a></code> </td><td style="text-align: left;"> <code class="reqn">K</code> function of fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pcfmodel.ppm">pcfmodel.ppm</a></code> </td><td style="text-align: left;"> pair correlation of fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitted.ppm">fitted.ppm</a></code> </td><td style="text-align: left;"> Compute fitted conditional intensity at quadrature points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+residuals.ppm">residuals.ppm</a></code> </td><td style="text-align: left;"> Compute point process residuals at quadrature points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+update.ppm">update.ppm</a></code> </td><td style="text-align: left;"> Update the fit </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vcov.ppm">vcov.ppm</a></code> </td><td style="text-align: left;"> Variance-covariance matrix of estimates</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rmh.ppm">rmh.ppm</a></code> </td><td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+simulate.ppm">simulate.ppm</a></code> </td><td style="text-align: left;"> Simulate from fitted model  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.ppm">print.ppm</a></code> </td><td style="text-align: left;"> Print basic information about a fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+summary.ppm">summary.ppm</a></code> </td><td style="text-align: left;"> Summarise a fitted model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+effectfun">effectfun</a></code> </td><td style="text-align: left;"> Compute the fitted effect of one covariate</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+logLik.ppm">logLik.ppm</a></code> </td><td style="text-align: left;"> log-likelihood or log-pseudolikelihood</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+anova.ppm">anova.ppm</a></code> </td><td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.frame.ppm">model.frame.ppm</a></code> </td><td style="text-align: left;"> Extract data frame used to fit model  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.images">model.images</a></code> </td><td style="text-align: left;"> Extract spatial data used to fit model  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.depends">model.depends</a></code> </td><td style="text-align: left;"> Identify variables in the model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.interact">as.interact</a></code> </td><td style="text-align: left;"> Interpoint interaction component of model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitin">fitin</a></code> </td><td style="text-align: left;"> Extract fitted interpoint interaction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.hybrid">is.hybrid</a></code> </td><td style="text-align: left;"> Determine whether the model is a hybrid </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+valid.ppm">valid.ppm</a></code> </td><td style="text-align: left;"> Check the model is a valid point process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+project.ppm">project.ppm</a></code> </td><td style="text-align: left;"> Ensure the model is a valid point process 
  </td>
</tr>

</table>

<p>For model selection, you can also use 
the generic functions <code><a href="stats.html#topic+step">step</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code> 
and <code><a href="stats.html#topic+AIC">AIC</a></code> on fitted point process models.
For variable selection, see <code><a href="spatstat.explore.html#topic+sdr">sdr</a></code>.
</p>
<p>See <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code> to control plotting of fitted model.
</p>
<p><b>To specify a point process model:</b>
</p>
<p>The first order &ldquo;trend&rdquo; of the model is determined by an <span class="rlang"><b>R</b></span> 
language formula. The formula specifies the form of the
<em>logarithm</em> of the trend.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>X ~ 1</code>  </td><td style="text-align: left;"> No trend (stationary) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>X ~ x</code>   </td><td style="text-align: left;"> Loglinear trend
      <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta x)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> where <code class="reqn">x,y</code> are Cartesian coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>X ~ polynom(x,y,3)</code>  </td><td style="text-align: left;"> Log-cubic polynomial trend  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>X ~ harmonic(x,y,2)</code>  </td><td style="text-align: left;"> Log-harmonic polynomial trend </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>X ~ Z</code>   </td><td style="text-align: left;"> Loglinear function of covariate <code>Z</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;">  <code class="reqn">\lambda(x,y) = \exp(\alpha + \beta Z(x,y))</code> 
  </td>
</tr>

</table>

<p>The higher order (&ldquo;interaction&rdquo;) components are described by
an object of class <code>"interact"</code>. Such objects are created by:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Poisson">Poisson</a>()</code> </td><td style="text-align: left;">		the Poisson point process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+AreaInter">AreaInter</a>()</code>	 </td><td style="text-align: left;"> Area-interaction process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+BadGey">BadGey</a>()</code> </td><td style="text-align: left;">	multiscale Geyer process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Concom">Concom</a>()</code> </td><td style="text-align: left;">	connected component interaction</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+DiggleGratton">DiggleGratton</a>() </code> </td><td style="text-align: left;"> Diggle-Gratton potential </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+DiggleGatesStibbard">DiggleGatesStibbard</a>() </code> </td><td style="text-align: left;"> Diggle-Gates-Stibbard potential </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Fiksel">Fiksel</a>()</code>	 </td><td style="text-align: left;"> Fiksel pairwise interaction process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Geyer">Geyer</a>()</code>	 </td><td style="text-align: left;"> Geyer's saturation process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Hardcore">Hardcore</a>()</code>	 </td><td style="text-align: left;"> Hard core process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+HierHard">HierHard</a>()</code>	 </td><td style="text-align: left;"> Hierarchical multiype hard core process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+HierStrauss">HierStrauss</a>()</code>	 </td><td style="text-align: left;"> Hierarchical multiype Strauss process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+HierStraussHard">HierStraussHard</a>()</code>	 </td><td style="text-align: left;">
    Hierarchical multiype Strauss-hard core process</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Hybrid">Hybrid</a>()</code>	 </td><td style="text-align: left;"> Hybrid of several interactions</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+LennardJones">LennardJones</a>() </code> </td><td style="text-align: left;"> Lennard-Jones potential </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+MultiHard">MultiHard</a>()</code> </td><td style="text-align: left;"> 		multitype hard core process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+MultiStrauss">MultiStrauss</a>()</code> </td><td style="text-align: left;"> 		multitype Strauss process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+MultiStraussHard">MultiStraussHard</a>()</code> </td><td style="text-align: left;"> 	multitype Strauss/hard core process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+OrdThresh">OrdThresh</a>()</code> </td><td style="text-align: left;">		Ord process, threshold potential</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Ord">Ord</a>()</code> </td><td style="text-align: left;"> 		        Ord model, user-supplied potential </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+PairPiece">PairPiece</a>()</code> </td><td style="text-align: left;">		pairwise interaction, piecewise constant </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Pairwise">Pairwise</a>()</code> </td><td style="text-align: left;">	pairwise interaction, user-supplied potential</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Penttinen">Penttinen</a>()</code> </td><td style="text-align: left;">	Penttinen pairwise interaction</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+SatPiece">SatPiece</a>()</code> </td><td style="text-align: left;">	Saturated pair model, piecewise  constant potential</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Saturated">Saturated</a>()</code> </td><td style="text-align: left;">	Saturated pair model, user-supplied potential</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Softcore">Softcore</a>()</code> </td><td style="text-align: left;"> pairwise interaction, soft core potential</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Strauss">Strauss</a>()</code> </td><td style="text-align: left;">  Strauss process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+StraussHard">StraussHard</a>()</code> </td><td style="text-align: left;"> Strauss/hard core point process </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Triplets">Triplets</a>()</code> </td><td style="text-align: left;"> Geyer triplets process
  </td>
</tr>

</table>

<p>Note that it is also possible to combine several such interactions
using <code><a href="#topic+Hybrid">Hybrid</a></code>.
</p>
<p><b>Simulation and goodness-of-fit for fitted models:</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rmh.ppm">rmh.ppm</a></code> </td><td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+simulate.ppm">simulate.ppm</a></code> </td><td style="text-align: left;"> simulate realisations of a fitted model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope">envelope</a></code> </td><td style="text-align: left;"> compute simulation envelopes for a
    fitted model 
  </td>
</tr>

</table>

<p><b>Model fitting (determinantal point process models)</b>
</p>
<p>Code for fitting <em>determinantal point process models</em> has 
recently been added to <span class="pkg">spatstat</span>.
</p>
<p>For information, see the help file for <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p><b>Model fitting (spatial logistic regression)</b>
</p>
<p>Pixel-based spatial logistic regression is an alternative
technique for analysing spatial point patterns
that is widely used in Geographical Information Systems.
It is approximately equivalent to fitting a Poisson point process
model.
</p>
<p>In pixel-based logistic regression, the spatial domain is
divided into small pixels, the presence or absence of a
data point in each pixel is recorded, and logistic regression
is used to model the presence/absence indicators as a function
of any covariates.
</p>
<p>Facilities for performing spatial logistic regression are
provided in <span class="pkg">spatstat</span> for comparison purposes.
</p>
<p><b>Fitting a spatial logistic regression</b>
</p>
<p>Spatial logistic regression is performed by the function
<code><a href="#topic+slrm">slrm</a></code>. Its result is an object of class <code>"slrm"</code>.
There are many methods for this class, including methods for
<code>print</code>, <code>fitted</code>, <code>predict</code>, <code>simulate</code>,
<code>anova</code>, <code>coef</code>, <code>logLik</code>, <code>terms</code>,
<code>update</code>, <code>formula</code> and <code>vcov</code>. 
</p>
<p>For example, if <code>X</code> is a point pattern (class
<code>"ppp"</code>):
</p>

<table>
<tr>
 <td style="text-align: left;">
    <em>command</em> </td><td style="text-align: left;"> <em>model</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>slrm(X ~ 1)</code> </td><td style="text-align: left;"> Complete Spatial Randomness </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>slrm(X ~ x)</code> </td><td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> intensity loglinear in <code class="reqn">x</code> coordinate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>slrm(X ~ Z)</code> </td><td style="text-align: left;"> Poisson process with </td>
</tr>
<tr>
 <td style="text-align: left;">
                </td><td style="text-align: left;"> intensity loglinear in covariate <code>Z</code>
  </td>
</tr>

</table>

<p><b>Manipulating a fitted spatial logistic regression</b>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+anova.slrm">anova.slrm</a></code> </td><td style="text-align: left;"> Analysis of deviance </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+coef.slrm">coef.slrm</a></code>  </td><td style="text-align: left;"> Extract fitted coefficients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vcov.slrm">vcov.slrm</a></code>  </td><td style="text-align: left;"> Variance-covariance matrix of fitted coefficients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitted.slrm">fitted.slrm</a></code> </td><td style="text-align: left;"> Compute fitted probabilities or
    intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+logLik.slrm">logLik.slrm</a></code>   </td><td style="text-align: left;"> Evaluate loglikelihood of fitted
    model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.slrm">plot.slrm</a></code>    </td><td style="text-align: left;"> Plot fitted probabilities or
    intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict.slrm">predict.slrm</a></code> </td><td style="text-align: left;"> Compute predicted probabilities or
    intensity with new data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+simulate.slrm">simulate.slrm</a></code> </td><td style="text-align: left;"> Simulate model
  </td>
</tr>

</table>

<p>There are many other undocumented methods for this class,
including methods for <code>print</code>, <code>update</code>, <code>formula</code>
and <code>terms</code>. Stepwise model selection is
possible using <code>step</code> or <code>stepAIC</code>.
For variable selection, see <code><a href="spatstat.explore.html#topic+sdr">sdr</a></code>.
</p>
<p><b>Simulation</b>
</p>
<p>There are many ways to generate a random point pattern,
line segment pattern, pixel image or tessellation
in <span class="pkg">spatstat</span>. 
</p>
<p><b>Random point patterns:</b>
Functions for random generation are now contained in the <span class="pkg">spatstat.random</span> package.
</p>
<p>See also <code><a href="spatstat.explore.html#topic+varblock">varblock</a></code> for estimating the variance
of a summary statistic by block resampling, and
<code><a href="spatstat.explore.html#topic+lohboot">lohboot</a></code> for another bootstrap technique.
</p>
<p><b>Fitted point process models:</b>
</p>
<p>If you have fitted a point process model to a point pattern dataset,
the fitted model can be simulated.
</p>
<p>Cluster process models 
are fitted by the function <code><a href="#topic+kppm">kppm</a></code> yielding an
object of class <code>"kppm"</code>. To generate one or more simulated
realisations of this fitted model, use 
<code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>Gibbs point process models 
are fitted by the function <code><a href="#topic+ppm">ppm</a></code> yielding an
object of class <code>"ppm"</code>. To generate a simulated
realisation of this fitted model, use <code><a href="#topic+rmh.ppm">rmh.ppm</a></code>.
To generate one or more simulated realisations of the fitted model,
use <code><a href="#topic+simulate.ppm">simulate.ppm</a></code>.
</p>
<p><b>Other random patterns:</b>
Functions for random generation are now contained in the
<span class="pkg">spatstat.random</span> package.
</p>
<p><b>Simulation-based inference</b>
</p>
<p>Simulation-based inference including simulation envelopes
and hypothesis tests is now supported by the package <span class="pkg">spatstat.explore</span>.
</p>
<p><b>Sensitivity diagnostics:</b>
</p>
<p>Classical measures of model sensitivity such as leverage and influence
have been adapted to point process models.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+leverage.ppm">leverage.ppm</a></code> </td><td style="text-align: left;"> Leverage for point process model</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+influence.ppm">influence.ppm</a></code> </td><td style="text-align: left;"> Influence for point process model</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dfbetas.ppm">dfbetas.ppm</a></code> </td><td style="text-align: left;"> Parameter influence</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+dffit.ppm">dffit.ppm</a></code> </td><td style="text-align: left;"> Effect change diagnostic
    </td>
</tr>

</table>

<p><b>Diagnostics for covariate effect:</b>
</p>
<p>Classical diagnostics for covariate effects have been adapted to
point process models.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+parres">parres</a></code> </td><td style="text-align: left;"> Partial residual plot</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+addvar">addvar</a></code> </td><td style="text-align: left;"> Added variable plot </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rhohat.ppm">rhohat.ppm</a></code> </td><td style="text-align: left;"> Kernel estimate of covariate effect</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.explore.html#topic+rho2hat">rho2hat</a></code> </td><td style="text-align: left;"> Kernel estimate of covariate effect
    (bivariate) 
  </td>
</tr>

</table>

<p><b>Residual diagnostics:</b>
</p>
<p>Residuals for a fitted point process model, and diagnostic plots
based on the residuals, were introduced in Baddeley et al (2005) and
Baddeley, Rubak and Moller (2011).
</p>
<p>Type <code>demo(diagnose)</code>
for a demonstration of the diagnostics features.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+diagnose.ppm">diagnose.ppm</a></code> </td><td style="text-align: left;"> diagnostic plots for spatial trend</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+qqplot.ppm">qqplot.ppm</a></code> </td><td style="text-align: left;"> diagnostic Q-Q plot for interpoint interaction</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.data.html#topic+residualspaper">residualspaper</a></code> </td><td style="text-align: left;"> examples from Baddeley et al (2005) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kcom">Kcom</a></code> </td><td style="text-align: left;"> model compensator of <code class="reqn">K</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gcom">Gcom</a></code> </td><td style="text-align: left;"> model compensator of <code class="reqn">G</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Kres">Kres</a></code> </td><td style="text-align: left;"> score residual of <code class="reqn">K</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Gres">Gres</a></code> </td><td style="text-align: left;"> score residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+psst">psst</a></code> </td><td style="text-align: left;"> pseudoscore residual of summary function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+psstA">psstA</a></code> </td><td style="text-align: left;"> pseudoscore residual of empty space function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+psstG">psstG</a></code> </td><td style="text-align: left;"> pseudoscore residual of <code class="reqn">G</code> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+compareFit">compareFit</a></code> </td><td style="text-align: left;"> compare compensators of several fitted
    models
  </td>
</tr>

</table>

<p><b>Resampling and randomisation procedures</b>
</p>
<p>You can build your own tests based on randomisation
and resampling using the following capabilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+quadratresample">quadratresample</a></code> </td><td style="text-align: left;"> block resampling </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rshift">rshift</a></code> </td><td style="text-align: left;"> random shifting of (subsets of) points</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="spatstat.random.html#topic+rthin">rthin</a></code> </td><td style="text-align: left;">  random thinning  
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Kasper Klitgaard Berthelsen,
Ottmar Cronie,
Tilman Davies,
Julian Gilbey, 
Yongtao Guan,
Ute Hahn,
Kassel Hingee,
Abdollah Jalilian,
Marie-Colette van Lieshout,
Greg McSwiggan,
Tuomas Rajala,
Suman Rakshit,
Dominic Schuhmacher,
Rasmus Waagepetersen
and
Hangsheng Wang
made substantial contributions of code.
</p>
<p>For comments, corrections, bug alerts and suggestions, we thank
Monsuru Adepeju,
Corey Anderson,
Ang Qi Wei,
Ryan Arellano,
Jens Astrom,
Robert Aue,
Marcel Austenfeld,
Sandro Azaele,
Malissa Baddeley,
Guy Bayegnak,
Colin Beale,
Melanie Bell,
Thomas Bendtsen,
Ricardo Bernhardt,
Andrew Bevan,
Brad Biggerstaff,
Anders Bilgrau,
Leanne Bischof,
Christophe Biscio,
Roger Bivand,
Jose M. Blanco Moreno,
Florent Bonneu,
Jordan Brown,
Ian Buller,
Julian Burgos,
Simon Byers,
Ya-Mei Chang,
Jianbao Chen,
Igor Chernayavsky,
Y.C. Chin,
Bjarke Christensen,
Lucia Cobo Sanchez,
Jean-Francois Coeurjolly,
Kim Colyvas,
Hadrien Commenges,
Rochelle Constantine,
Robin Corria Ainslie,
Richard Cotton,
Marcelino de la Cruz,
Peter Dalgaard,
Mario D'Antuono,
Sourav Das,
Peter Diggle,
Patrick Donnelly,
Ian Dryden,
Stephen Eglen,
Ahmed El-Gabbas,
Belarmain Fandohan,
Olivier Flores,
David Ford,
Peter Forbes,
Shane Frank,
Janet Franklin,
Funwi-Gabga Neba,
Oscar Garcia,
Agnes Gault,
Jonas Geldmann,
Marc Genton,
Shaaban Ghalandarayeshi,
Jason Goldstick,
Pavel Grabarnik,
C. Graf,
Ute Hahn,
Andrew Hardegen,
Martin Bogsted Hansen,
Martin Hazelton,
Juha Heikkinen,
Mandy Hering,
Markus Herrmann,
Maximilian Hesselbarth,
Paul Hewson,
Hamidreza Heydarian,
Kurt Hornik,
Philipp Hunziker,
Jack Hywood,
Ross Ihaka,
Cenk Icos,
Aruna Jammalamadaka,
Robert John-Chandran,
Devin Johnson,
Mahdieh Khanmohammadi,
Bob Klaver,
Lily Kozmian-Ledward,
Peter Kovesi,
Mike Kuhn,
Jeff Laake,
Robert Lamb,
Frederic Lavancier,
Tom Lawrence,
Tomas Lazauskas,
Jonathan Lee,
George Leser,
Angela Li,
Li Haitao,
George Limitsios,
Andrew Lister,
Nestor Luambua,
Ben Madin,
Martin Maechler,
Kiran Marchikanti,
Jeff Marcus,
Robert Mark,
Peter McCullagh,
Monia Mahling,
Jorge Mateu Mahiques,
Ulf Mehlig,
Frederico Mestre,
Sebastian Wastl Meyer,
Mi Xiangcheng,
Lore De Middeleer,
Robin Milne,
Enrique Miranda,
Jesper Moller,
Annie Mollie,
Ines Moncada,
Mehdi Moradi,
Virginia Morera Pujol,
Erika Mudrak,
Gopalan Nair,
Nader Najari,
Nicoletta Nava,
Linda Stougaard Nielsen,
Felipe Nunes,
Jens Randel Nyengaard,
Jens Oehlschlaegel,
Thierry Onkelinx,
Sean O'Riordan,
Evgeni Parilov,
Jeff Picka,
Nicolas Picard,
Tim Pollington,
Mike Porter,
Sergiy Protsiv,
Adrian Raftery,
Ben Ramage,
Pablo Ramon,
Xavier Raynaud,
Nicholas Read,
Matt Reiter,
Ian Renner,
Tom Richardson,
Brian Ripley,
Ted Rosenbaum,
Barry Rowlingson,
Jason Rudokas,
Tyler Rudolph,
John Rudge,
Christopher Ryan,
Farzaneh Safavimanesh,
Aila Sarkka,
Cody Schank,
Katja Schladitz,
Sebastian Schutte,
Bryan Scott,
Olivia Semboli,
Francois Semecurbe,
Vadim Shcherbakov,
Shen Guochun,
Shi Peijian,
Harold-Jeffrey Ship,
Tammy L Silva,
Ida-Maria Sintorn,
Yong Song, 
Malte Spiess,
Mark Stevenson,
Kaspar Stucki,
Jan Sulavik,
Michael Sumner,
P. Surovy,
Ben Taylor,
Thordis Linda Thorarinsdottir,
Leigh Torres,
Berwin Turlach,
Torben Tvedebrink,
Kevin Ummer,
Medha Uppala,
Andrew van Burgel,
Tobias Verbeke,
Mikko Vihtakari,
Alexendre Villers,
Fabrice Vinatier,
Maximilian Vogtland,
Sasha Voss,
Sven Wagner,
Hao Wang,
H. Wendrock,
Jan Wild,
Carl G. Witthoft,
Selene Wong,
Maxime Woringer,
Luke Yates,
Mike Zamboni
and
Achim Zeileis.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='split.msr'>
Divide a Measure into Parts
</h2><span id='topic+split.msr'></span>

<h3>Description</h3>

<p>Decomposes a measure into components, each component being a measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'msr'
split(x, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.msr_+3A_x">x</code></td>
<td>

<p>Measure (object of class <code>"msr"</code>) to be decomposed.
</p>
</td></tr>
<tr><td><code id="split.msr_+3A_f">f</code></td>
<td>

<p>Factor or tessellation determining the decomposition.
Argument passed to <code><a href="spatstat.geom.html#topic+split.ppp">split.ppp</a></code>.
See Details.
</p>
</td></tr>
<tr><td><code id="split.msr_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether empty components should be retained
in the list (<code>drop=FALSE</code>, the default) or deleted (<code>drop=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="split.msr_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"msr"</code> represents a signed (i.e. real-valued)
or vector-valued measure in the <span class="pkg">spatstat</span> package.
See <code><a href="#topic+msr">msr</a></code> for explanation.
</p>
<p>This function is a method for the generic
<code><a href="base.html#topic+split">split</a></code>. It divides the measure <code>x</code> into
components, each of which is a measure.
</p>
<p>A measure <code>x</code> is represented in <span class="pkg">spatstat</span> by 
a finite set of sample points with values attached to them.
The function <code>split.msr</code> divides this pattern of sample points
into several sub-patterns of points using <code><a href="spatstat.geom.html#topic+split.ppp">split.ppp</a></code>.
For each sub-pattern, the values attached to these points are
extracted from <code>x</code>, and these values and sample points
determine a measure, which is a
component or piece of the original <code>x</code>.
</p>
<p>The argument <code>f</code> can be missing, if the sample points of <code>x</code>
are multitype points. In this case, <code>x</code> represents a measure
associated with marked spatial locations, and the command <code>split(x)</code>
separates <code>x</code> into a list of component measures, one for each
possible mark.
</p>
<p>Otherwise the argument <code>f</code> is passed to <code><a href="spatstat.geom.html#topic+split.ppp">split.ppp</a></code>.
It should be either a factor (of length equal to the number of
sample points of <code>x</code>) or a tessellation (object of class
<code>"tess"</code> representing a division of space into tiles)
as documented under <code><a href="spatstat.geom.html#topic+split.ppp">split.ppp</a></code>.
</p>


<h3>Value</h3>

<p>A list, each of whose entries is a measure (object of class
<code>"msr"</code>). 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic++5B.msr">[.msr</a></code>,
<code><a href="#topic+with.msr">with.msr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## split by tessellation
  a &lt;- residuals(ppm(cells ~ x))
  aa &lt;- split(a, dirichlet(runifpoint(4)))
  aa
  sapply(aa, integral)

  ## split by type of point
  b &lt;- residuals(ppm(amacrine ~ marks + x))
  bb &lt;- split(b)
  bb
</code></pre>

<hr>
<h2 id='Strauss'>The Strauss Point Process Model</h2><span id='topic+Strauss'></span>

<h3>Description</h3>

<p>Creates an instance of the Strauss point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Strauss(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Strauss_+3A_r">r</code></td>
<td>
<p>The interaction radius of the Strauss process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (stationary) Strauss process with interaction radius <code class="reqn">r</code> and 
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>
is the pairwise interaction point process
in which each point contributes a factor <code class="reqn">\beta</code> to the 
probability density of the point pattern, and each pair of points
closer than <code class="reqn">r</code> units apart contributes a factor
<code class="reqn">\gamma</code> to the density.
</p>
<p>Thus the probability density is
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \gamma^{s(x)}
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, <code class="reqn">s(x)</code> is the number of distinct unordered pairs of
points that are closer than <code class="reqn">r</code> units apart,
and <code class="reqn">\alpha</code> is the normalising constant.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> must be less than
or equal to <code class="reqn">1</code>
so that this model describes an &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; pattern.
</p>
<p>The nonstationary Strauss process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Strauss process pairwise interaction is
yielded by the function <code>Strauss()</code>. See the examples below.
</p>
<p>Note the only argument is the interaction radius <code>r</code>.
When <code>r</code> is fixed, the model becomes an exponential family.
The canonical parameters <code class="reqn">\log(\beta)</code>
and <code class="reqn">\log(\gamma)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>Strauss()</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the Strauss process with interaction radius <code class="reqn">r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>


<h3>References</h3>

<p>Kelly, F.P. and Ripley, B.D. (1976)
On Strauss's model for clustering.
<em>Biometrika</em> <b>63</b>, 357&ndash;360.
</p>
<p>Strauss, D.J. (1975)
A model for clustering.
<em>Biometrika</em> <b>62</b>, 467&ndash;475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Strauss(r=0.1)
   # prints a sensible description of itself

   
     ppm(cells ~1, Strauss(r=0.07))
     # fit the stationary Strauss process to `cells'
   

   ppm(cells ~polynom(x,y,3), Strauss(r=0.07))
   # fit a nonstationary Strauss process with log-cubic polynomial trend
</code></pre>

<hr>
<h2 id='StraussHard'>The Strauss / Hard Core Point Process Model</h2><span id='topic+StraussHard'></span>

<h3>Description</h3>

<p>Creates an instance of the &ldquo;Strauss/ hard core&rdquo; point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  StraussHard(r, hc=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StraussHard_+3A_r">r</code></td>
<td>
<p>The interaction radius of the Strauss interaction</p>
</td></tr>
<tr><td><code id="StraussHard_+3A_hc">hc</code></td>
<td>
<p>The hard core distance. Optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Strauss/hard core process with interaction radius <code class="reqn">r</code>,
hard core distance <code class="reqn">h &lt; r</code>, and 
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>,
is a pairwise interaction point process
in which
</p>

<ul>
<li><p> distinct points are not allowed to come closer
than a distance <code class="reqn">h</code> apart
</p>
</li>
<li><p> each pair of points closer than <code class="reqn">r</code> units apart
contributes a factor <code class="reqn">\gamma</code> to the probability density.
</p>
</li></ul>

<p>This is a hybrid of the Strauss process and the hard core process.
</p>
<p>The probability density is zero if any pair of points
is closer than <code class="reqn">h</code> units apart, and otherwise equals
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \gamma^{s(x)}
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, <code class="reqn">s(x)</code> is the number of distinct unordered pairs of
points that are closer than <code class="reqn">r</code> units apart,
and <code class="reqn">\alpha</code> is the normalising constant.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> may take any
positive value (unlike the case for the Strauss process).
If <code class="reqn">\gamma &lt; 1</code>,
the model describes an &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; pattern.
If <code class="reqn">\gamma &gt; 1</code>,
the model is &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; up to the distance
<code class="reqn">h</code>, but has an &ldquo;attraction&rdquo; between points lying at
distances in the range between <code class="reqn">h</code> and <code class="reqn">r</code>.
</p>
<p>If <code class="reqn">\gamma = 1</code>, the process reduces to a classical
hard core process with hard core distance <code class="reqn">h</code>.
If <code class="reqn">\gamma = 0</code>, the process reduces to a classical
hard core process with hard core distance <code class="reqn">r</code>.
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Strauss/hard core process
pairwise interaction is
yielded by the function <code>StraussHard()</code>. See the examples below.
</p>
<p>The canonical parameter <code class="reqn">\log(\gamma)</code>
is estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>StraussHard()</code>. 
</p>
<p>If the hard core distance argument <code>hc</code> is missing or <code>NA</code>,
it will be estimated from the data when <code><a href="#topic+ppm">ppm</a></code> is called.
The estimated value of <code>hc</code> is the minimum nearest neighbour distance
multiplied by <code class="reqn">n/(n+1)</code>, where <code class="reqn">n</code> is the
number of data points.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the &ldquo;Strauss/hard core&rdquo;
process with Strauss interaction radius <code class="reqn">r</code>
and hard core distance <code>hc</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>
<p>Ripley, B.D. (1981) 
<em>Spatial statistics</em>.
John Wiley and Sons.
</p>
<p>Strauss, D.J. (1975)
A model for clustering.
<em>Biometrika</em> <b>62</b>, 467&ndash;475.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   StraussHard(r=1,hc=0.02)
   # prints a sensible description of itself

   # ppm(cells ~1, StraussHard(r=0.1, hc=0.05))
   # fit the stationary Strauss/hard core  process to `cells'

   ppm(cells ~ polynom(x,y,3), StraussHard(r=0.1, hc=0.05))
   # fit a nonstationary Strauss/hard core process
   # with log-cubic polynomial trend
</code></pre>

<hr>
<h2 id='subfits'>Extract List of Individual Point Process Models</h2><span id='topic+subfits'></span><span id='topic+subfits.new'></span><span id='topic+subfits.old'></span>

<h3>Description</h3>

<p>Takes a Gibbs point process model that has been fitted
to several point patterns simultaneously, and produces a list
of fitted point process models for the individual point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   subfits(object, what="models", verbose=FALSE, new.coef=NULL)
   subfits.old(object, what="models", verbose=FALSE, new.coef=NULL)
   subfits.new(object, what="models", verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subfits_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mppm"</code>
representing a point process model fitted to several point patterns. 
</p>
</td></tr>
<tr><td><code id="subfits_+3A_what">what</code></td>
<td>

<p>What should be returned.
Either <code>"models"</code> to return the fitted models,
or <code>"interactions"</code> to return the fitted interactions only.
</p>
</td></tr>
<tr><td><code id="subfits_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="subfits_+3A_new.coef">new.coef</code></td>
<td>

<p>Advanced use only. Numeric vector or matrix of coefficients
to replaced the fitted coefficients <code>coef(object)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> is assumed to have been generated by
<code><a href="#topic+mppm">mppm</a></code>. It represents a point process model that has been
fitted to a list of several point patterns, with covariate data.
</p>
<p>For each of the <em>individual</em> point pattern
datasets, this function derives the corresponding fitted model
for that dataset only (i.e. a point process model for the <code class="reqn">i</code>th
point pattern, that is consistent with <code>object</code>). 
</p>
<p>If <code>what="models"</code>,
the result is a list of point process models (a list of objects of class
<code>"ppm"</code>), one model for each point pattern dataset in the
original fit.
If <code>what="interactions"</code>,
the result is a list of fitted interpoint interactions (a list of
objects of class
<code>"fii"</code>).
</p>
<p>Two different algorithms are provided, as
<code>subfits.old</code> and <code>subfits.new</code>.
Currently <code>subfits</code> is the same as the old algorithm
<code>subfits.old</code> because the newer algorithm is too memory-hungry.
</p>


<h3>Value</h3>

<p>A list of point process models (a list of objects of class
<code>"ppm"</code>) or a list of fitted interpoint interactions (a list of
objects of class <code>"fii"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented in <span class="pkg">spatstat</span> by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mppm">mppm</a></code>,
<code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  H &lt;- hyperframe(Wat=waterstriders)
  fit &lt;- mppm(Wat~x, data=H)
  subfits(fit)

  H$Wat[[3]] &lt;- rthin(H$Wat[[3]], 0.1)
  fit2 &lt;- mppm(Wat~x, data=H, random=~1|id)
  subfits(fit2)

  
</code></pre>

<hr>
<h2 id='suffstat'>Sufficient Statistic of Point Process Model</h2><span id='topic+suffstat'></span>

<h3>Description</h3>

<p>The canonical sufficient statistic of a 
point process model is evaluated for a given point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  suffstat(model, X=data.ppm(model))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suffstat_+3A_model">model</code></td>
<td>
<p>A fitted point process model (object of class
<code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="suffstat_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The canonical sufficient statistic
of <code>model</code> is evaluated for the point pattern <code>X</code>.
This computation is useful for various Monte Carlo methods.
</p>
<p>Here <code>model</code> should be a point process model (object of class
<code>"ppm"</code>, see <code><a href="#topic+ppm.object">ppm.object</a></code>), typically obtained
from the model-fitting function <code><a href="#topic+ppm">ppm</a></code>. The argument
<code>X</code> should be a point pattern (object of class <code>"ppp"</code>).
</p>
<p>Every point process model fitted by <code><a href="#topic+ppm">ppm</a></code> has
a probability density of the form
</p>
<p style="text-align: center;"><code class="reqn">f(x) = Z(\theta) \exp(\theta^T S(x))</code>
</p>

<p>where <code class="reqn">x</code> denotes a typical realisation (i.e. a point pattern),
<code class="reqn">\theta</code> is the vector of model coefficients,
<code class="reqn">Z(\theta)</code> is a normalising constant,
and <code class="reqn">S(x)</code> is a function of the realisation <code class="reqn">x</code>, called the
&ldquo;canonical sufficient statistic&rdquo; of the model.
</p>
<p>For example, the stationary Poisson process has canonical sufficient
statistic <code class="reqn">S(x)=n(x)</code>, the number of points in <code class="reqn">x</code>.
The stationary Strauss process with interaction range <code class="reqn">r</code>
(and fitted with no edge correction) has canonical sufficient statistic
<code class="reqn">S(x)=(n(x),s(x))</code> where <code class="reqn">s(x)</code> is the number of pairs
of points in <code class="reqn">x</code> which are closer than a distance <code class="reqn">r</code>
to each other. 
</p>
<p><code>suffstat(model, X)</code> returns the value of <code class="reqn">S(x)</code>, where <code class="reqn">S</code> is
the canonical sufficient statistic associated with <code>model</code>,
evaluated when <code class="reqn">x</code> is the given point pattern <code>X</code>.
The result is a numeric vector, with entries which correspond to the
entries of the coefficient vector <code>coef(model)</code>.
</p>
<p>The sufficient statistic <code class="reqn">S</code>
does not depend on the fitted coefficients
of the model. However it does depend on the irregular parameters
which are fixed in the original call to <code><a href="#topic+ppm">ppm</a></code>, for
example, the interaction range <code>r</code> of the Strauss process.
</p>
<p>The sufficient statistic also depends on the edge correction that
was used to fit the model. For example in a Strauss process,
</p>

<ul>
<li>
<p>If the model is fitted with <code>correction="none"</code>, the sufficient
statistic is <code class="reqn">S(x) = (n(x), s(x))</code> where <code class="reqn">n(x)</code> is the
number of points and <code class="reqn">s(x)</code> is the number of pairs of points
which are closer than <code class="reqn">r</code> units apart.
</p>
</li>
<li>
<p>If the model is fitted with <code>correction="periodic"</code>, the sufficient
statistic is the same as above, except that distances are measured
in the periodic sense. 
</p>
</li>
<li>
<p>If the model is fitted with
<code>correction="translate"</code>, then <code class="reqn">n(x)</code> is unchanged
but <code class="reqn">s(x)</code> is replaced by a weighted sum (the sum of the translation
correction weights for all pairs of points which are closer than
<code class="reqn">r</code> units apart).
</p>
</li>
<li>
<p>If the model is fitted with
<code>correction="border"</code> (the default), then points lying less than
<code class="reqn">r</code> units from the boundary of the observation window are
treated as fixed. Thus <code class="reqn">n(x)</code> is
replaced by the number <code class="reqn">n_r(x)</code>
of points lying at least <code class="reqn">r</code> units from
the boundary of the observation window, and <code class="reqn">s(x)</code> is replaced by
the number <code class="reqn">s_r(x)</code> of pairs of points, which are closer
than <code class="reqn">r</code> units apart, and at least one of which lies
more than <code class="reqn">r</code> units from the boundary of the observation window.
</p>
</li></ul>

<p>Non-finite values of the sufficient statistic (<code>NA</code> or
<code>-Inf</code>) may be returned if the point pattern <code>X</code> is
not a possible realisation of the model (i.e. if <code>X</code> has zero
probability of occurring under <code>model</code> for all values of
the canonical coefficients <code class="reqn">\theta</code>).
</p>


<h3>Value</h3>

<p>A numeric vector of sufficient statistics. The entries
correspond to the model coefficients <code>coef(model)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    fitS &lt;- ppm(swedishpines~1, Strauss(7))
    suffstat(fitS)
    X &lt;- rpoispp(intensity(swedishpines), win=Window(swedishpines))
    suffstat(fitS, X)
</code></pre>

<hr>
<h2 id='summary.dppm'>Summarizing a Fitted Determinantal Point Process Model</h2><span id='topic+summary.dppm'></span><span id='topic+print.summary.dppm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"dppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'dppm'
summary(object, ..., quick=FALSE)

  ## S3 method for class 'summary.dppm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dppm_+3A_object">object</code></td>
<td>

<p>A fitted determinantal point process model (object of
class <code>"dppm"</code>).
</p>
</td></tr>
<tr><td><code id="summary.dppm_+3A_quick">quick</code></td>
<td>
<p>Logical value controlling the scope of the summary.</p>
</td></tr>
<tr><td><code id="summary.dppm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+summary.ppm">summary.ppm</a></code> or
<code><a href="#topic+print.summary.ppm">print.summary.ppm</a></code> controlling the treatment of
the trend component of the model.</p>
</td></tr>
<tr><td><code id="summary.dppm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.dppm"</code> as returned by
<code>summary.dppm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+summary">summary</a></code>
for the class <code>"dppm"</code>. An object of class <code>"dppm"</code>
describes a fitted determinantal point process model.
See <code><a href="#topic+dppm">dppm</a></code>.
</p>
<p><code>summary.dppm</code> extracts information about the
type of model that has been fitted, the data to which the model was
fitted, and the values of the fitted coefficients.
</p>
<p><code>print.summary.dppm</code> prints this information in a
comprehensible format.
</p>
<p>In normal usage, <code>print.summary.dppm</code> is invoked implicitly
when the user calls <code>summary.dppm</code> without assigning its value
to anything. See the examples.
</p>


<h3>Value</h3>

<p><code>summary.dppm</code> returns an object of class <code>"summary.dppm"</code>,
while <code>print.summary.dppm</code> returns <code>NULL</code>.
</p>
<p>The result of <code>summary.dppm</code> includes at least the
following components:
</p>
<table>
<tr><td><code>Xname</code></td>
<td>
<p>character string name of the original point pattern data</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>logical value indicating whether the model is
stationary</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>Object of class <code>summary.ppm</code> summarising the trend</p>
</td></tr>
<tr><td><code>repul</code></td>
<td>
<p>Repulsiveness index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  jpines &lt;- residualspaper$Fig1
  
 fit &lt;- dppm(jpines ~ 1, dppGauss)
 summary(fit)
</code></pre>

<hr>
<h2 id='summary.kppm'>Summarizing a Fitted Cox or Cluster Point Process Model</h2><span id='topic+summary.kppm'></span><span id='topic+print.summary.kppm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"kppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kppm'
summary(object, ..., quick=FALSE)

  ## S3 method for class 'summary.kppm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.kppm_+3A_object">object</code></td>
<td>

<p>A fitted Cox or cluster point process model (object of
class <code>"kppm"</code>).
</p>
</td></tr>
<tr><td><code id="summary.kppm_+3A_quick">quick</code></td>
<td>
<p>Logical value controlling the scope of the summary.</p>
</td></tr>
<tr><td><code id="summary.kppm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+summary.ppm">summary.ppm</a></code> or
<code><a href="#topic+print.summary.ppm">print.summary.ppm</a></code> controlling the treatment of
the trend component of the model.</p>
</td></tr>
<tr><td><code id="summary.kppm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.kppm"</code> as returned by
<code>summary.kppm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+summary">summary</a></code>
for the class <code>"kppm"</code>. An object of class <code>"kppm"</code>
describes a fitted Cox or cluster point process model.
See <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p><code>summary.kppm</code> extracts information about the
type of model that has been fitted, the data to which the model was
fitted, and the values of the fitted coefficients.
</p>
<p><code>print.summary.kppm</code> prints this information in a
comprehensible format.
</p>
<p>In normal usage, <code>print.summary.kppm</code> is invoked implicitly
when the user calls <code>summary.kppm</code> without assigning its value
to anything. See the examples.
</p>
<p>You can also type <code>coef(summary(object))</code> to extract a table
of the fitted coefficients of the point process model <code>object</code>
together with standard errors and confidence limits.
</p>


<h3>Value</h3>

<p><code>summary.kppm</code> returns an object of class <code>"summary.kppm"</code>,
while <code>print.summary.kppm</code> returns <code>NULL</code>.
</p>
<p>The result of <code>summary.kppm</code> includes at least the
following components:
</p>
<table>
<tr><td><code>Xname</code></td>
<td>
<p>character string name of the original point pattern data</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>logical value indicating whether the model is
stationary</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the <code>clusters</code> argument to <code><a href="#topic+kppm">kppm</a></code></p>
</td></tr>
<tr><td><code>modelname</code></td>
<td>
<p>character string describing the model</p>
</td></tr>
<tr><td><code>isPCP</code></td>
<td>
<p><code>TRUE</code> if the model is a Poisson cluster process,
<code>FALSE</code> if it is a log-Gaussian Cox process</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Estimated intensity: numeric value, or pixel image</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Mean cluster size: numeric value, pixel image, or
<code>NULL</code></p>
</td></tr>
<tr><td><code>clustpar</code></td>
<td>
<p>list of fitted parameters for the cluster model</p>
</td></tr>
<tr><td><code>clustargs</code></td>
<td>
<p>list of fixed parameters for the cluster model, if
any</p>
</td></tr>
<tr><td><code>callstring</code></td>
<td>
<p>character string representing the original call to
<code><a href="#topic+kppm">kppm</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Davies, T.M., Hazelton, M.L., Rakshit, S. and Turner,
R. (2022) Fundamental problems in fitting spatial cluster
process models. <em>Spatial Statistics</em> <b>52</b>, 100709.
DOI: <code>10.1016/j.spasta.2022.100709</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- kppm(redwood ~ 1, "Thomas")
 summary(fit)
 coef(summary(fit))
</code></pre>

<hr>
<h2 id='summary.ppm'>Summarizing a Fitted Point Process Model</h2><span id='topic+summary.ppm'></span><span id='topic+print.summary.ppm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"ppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
summary(object, ..., quick=FALSE, fine=FALSE)
  ## S3 method for class 'summary.ppm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ppm_+3A_object">object</code></td>
<td>
<p>A fitted point process model.</p>
</td></tr>
<tr><td><code id="summary.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="summary.ppm_+3A_quick">quick</code></td>
<td>
<p>Logical flag controlling the scope of the summary.</p>
</td></tr>
<tr><td><code id="summary.ppm_+3A_fine">fine</code></td>
<td>

<p>Logical value passed to <code><a href="#topic+vcov.ppm">vcov.ppm</a></code> determining
whether to compute the quick, coarse estimate of variance
(<code>fine=FALSE</code>, the default) or the slower, finer estimate
(<code>fine=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="summary.ppm_+3A_x">x</code></td>
<td>
<p>Object of class <code>"summary.ppm"</code> as returned by
<code>summary.ppm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+summary">summary</a></code>
for the class <code>"ppm"</code>. An object of class <code>"ppm"</code>
describes a fitted point process model. See <code><a href="#topic+ppm.object">ppm.object</a></code>)
for details of this class. 
</p>
<p><code>summary.ppm</code> extracts information about the
type of model that has been fitted, the data to which the model was
fitted, and the values of the fitted coefficients.
(If <code>quick=TRUE</code> then only the information about the type
of model is extracted.)
</p>
<p><code>print.summary.ppm</code> prints this information in a
comprehensible format.
</p>
<p>In normal usage, <code>print.summary.ppm</code> is invoked implicitly
when the user calls <code>summary.ppm</code> without assigning its value
to anything. See the examples.
</p>
<p>You can also type <code>coef(summary(object))</code> to extract a table
of the fitted coefficients of the point process model <code>object</code>
together with standard errors and confidence limits. 
</p>


<h3>Value</h3>

<p><code>summary.ppm</code> returns an object of class <code>"summary.ppm"</code>,
while <code>print.summary.ppm</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # invent some data
  X &lt;- rpoispp(42)
  # fit a model to it
  fit &lt;- ppm(X ~ x, Strauss(r=0.1))
  # summarize the fitted model
  summary(fit)
  # `quick' option
  summary(fit, quick=TRUE)
  # coefficients with standard errors and CI
  coef(summary(fit))
  coef(summary(fit, fine=TRUE))

  # save the full summary
  s &lt;- summary(fit)
  # print it
  print(s)
  s
  # extract stuff
  names(s)
  coef(s)
  s$args$correction
  s$name
  s$trend$value

  
    # multitype pattern
    fit &lt;- ppm(demopat ~marks, Poisson())
    summary(fit)
  

  # model with external covariates
  fitX &lt;- ppm(X, ~Z, covariates=list(Z=function(x,y){x+y}))
  summary(fitX)
</code></pre>

<hr>
<h2 id='thomas.estK'>Fit the Thomas Point Process by Minimum Contrast</h2><span id='topic+thomas.estK'></span>

<h3>Description</h3>

<p>Fits the Thomas point process to a point pattern dataset by the Method of
Minimum Contrast using the K function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thomas.estK(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thomas.estK_+3A_x">X</code></td>
<td>

<p>Data to which the Thomas model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="thomas.estK_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
Thomas process.
</p>
</td></tr>
<tr><td><code id="thomas.estK_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="thomas.estK_+3A_q">q</code>, <code id="thomas.estK_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="thomas.estK_+3A_rmin">rmin</code>, <code id="thomas.estK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="thomas.estK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Thomas point process model to a point pattern dataset
by the Method of Minimum Contrast, using the <code class="reqn">K</code> function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The <code class="reqn">K</code> function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the <code class="reqn">K</code> function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Thomas point process to <code>X</code>,
by finding the parameters of the Thomas model
which give the closest match between the
theoretical <code class="reqn">K</code> function of the Thomas process
and the observed <code class="reqn">K</code> function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Thomas point process is described in
Moller and Waagepetersen (2003, pp. 61&ndash;62). It is a cluster
process formed by taking a pattern of parent points, generated
according to a Poisson process with intensity <code class="reqn">\kappa</code>, and
around each parent point, generating a random number of offspring
points, such that the number of offspring of each parent is a Poisson
random variable with mean <code class="reqn">\mu</code>, and the locations of the
offspring points of one parent are independent and isotropically
Normally distributed around the parent point with standard deviation
<code class="reqn">\sigma</code> which is equal to the parameter <code>scale</code>. The
named vector of stating values can use either <code>sigma2</code>
(<code class="reqn">\sigma^2</code>) or <code>scale</code> as the name of the second
component, but the latter is recommended for consistency with other
cluster models.
</p>
<p>The theoretical <code class="reqn">K</code>-function of the Thomas process is
</p>
<p style="text-align: center;"><code class="reqn">
    K(r) = \pi r^2 + \frac 1 \kappa (1 - \exp(-\frac{r^2}{4\sigma^2})).
  </code>
</p>

<p>The theoretical intensity
of the Thomas process is <code class="reqn">\lambda = \kappa \mu</code>.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\kappa</code>
and <code class="reqn">\sigma^2</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Thomas process can be simulated, using <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>.
</p>
<p>Homogeneous or inhomogeneous Thomas process models can also
be fitted using the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rasmus Plenge Waagepetersen <a href="mailto:rw@math.auc.dk">rw@math.auc.dk</a>.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Diggle, P. J., Besag, J. and Gleaves, J. T. (1976)
Statistical analysis of spatial point patterns by
means of distance methods. <em>Biometrics</em> <b>32</b> 659&ndash;667.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Thomas, M. (1949) A generalisation of Poisson's binomial limit for use
in ecology. <em>Biometrika</em> <b>36</b>, 18&ndash;25.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+matclust.estK">matclust.estK</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> to simulate the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- thomas.estK(redwood, c(kappa=10, scale=0.1))
    u
    plot(u)
</code></pre>

<hr>
<h2 id='thomas.estpcf'>Fit the Thomas Point Process by Minimum Contrast</h2><span id='topic+thomas.estpcf'></span>

<h3>Description</h3>

<p>Fits the Thomas point process to a point pattern dataset by the Method of
Minimum Contrast using the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thomas.estpcf(X, startpar=c(kappa=1,scale=1), lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ..., pcfargs=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thomas.estpcf_+3A_x">X</code></td>
<td>

<p>Data to which the Thomas model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the
Thomas process.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_q">q</code>, <code id="thomas.estpcf_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_rmin">rmin</code>, <code id="thomas.estpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="thomas.estpcf_+3A_pcfargs">pcfargs</code></td>
<td>

<p>Optional list containing arguments passed to <code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
to control the smoothing in the estimation of the
pair correlation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Thomas point process model to a point pattern dataset
by the Method of Minimum Contrast, using the pair correlation function
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The pair correlation function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the pair correlation function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Thomas point process to <code>X</code>,
by finding the parameters of the Thomas model
which give the closest match between the
theoretical pair correlation function of the Thomas process
and the observed pair correlation function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Thomas point process is described in
Moller and Waagepetersen (2003, pp. 61&ndash;62). It is a cluster
process formed by taking a pattern of parent points, generated
according to a Poisson process with intensity <code class="reqn">\kappa</code>, and
around each parent point, generating a random number of offspring
points, such that the number of offspring of each parent is a Poisson
random variable with mean <code class="reqn">\mu</code>, and the locations of the
offspring points of one parent are independent and isotropically
Normally distributed around the parent point with standard deviation
<code class="reqn">\sigma</code> which is equal to the parameter <code>scale</code>. The
named vector of stating values can use either <code>sigma2</code>
(<code class="reqn">\sigma^2</code>) or <code>scale</code> as the name of the second
component, but the latter is recommended for consistency with other
cluster models.
</p>
<p>The theoretical pair correlation function of the Thomas process is
</p>
<p style="text-align: center;"><code class="reqn">
    g(r) = 1 + \frac 1 {4\pi \kappa \sigma^2} \exp(-\frac{r^2}{4\sigma^2})).
  </code>
</p>

<p>The theoretical intensity
of the Thomas process is <code class="reqn">\lambda = \kappa \mu</code>.
</p>
<p>In this algorithm, the Method of Minimum Contrast is first used to find
optimal values of the parameters <code class="reqn">\kappa</code>
and <code class="reqn">\sigma^2</code>. Then the remaining parameter
<code class="reqn">\mu</code> is inferred from the estimated intensity
<code class="reqn">\lambda</code>.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of <code class="reqn">\lambda</code>. Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Thomas process can be simulated, using <code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code>.
</p>
<p>Homogeneous or inhomogeneous Thomas process models can also
be fitted using the function <code><a href="#topic+kppm">kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Diggle, P. J., Besag, J. and Gleaves, J. T. (1976)
Statistical analysis of spatial point patterns by
means of distance methods. <em>Biometrics</em> <b>32</b> 659&ndash;667.
</p>
<p>Moller, J. and Waagepetersen, R. (2003).
Statistical Inference and Simulation for Spatial Point Processes.
Chapman and Hall/CRC, Boca Raton.
</p>
<p>Thomas, M. (1949) A generalisation of Poisson's binomial limit for use
in ecology. <em>Biometrika</em> <b>36</b>, 18&ndash;25.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thomas.estK">thomas.estK</a></code>
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="spatstat.random.html#topic+rThomas">rThomas</a></code> to simulate the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- thomas.estpcf(redwood, c(kappa=10, scale=0.1))
    u
    plot(u, legendpos="topright")
    u2 &lt;- thomas.estpcf(redwood, c(kappa=10, scale=0.1),
          pcfargs=list(stoyan=0.12))
</code></pre>

<hr>
<h2 id='traj'>
Extract trajectory of function evaluations
</h2><span id='topic+traj'></span>

<h3>Description</h3>

<p>Extract the history of evaluations of the objective function
performed when a cluster process model was fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traj_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model (object of class <code>"kppm"</code>)
or objective function surface (object of class <code>"objsurf"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under appropriate circumstances, the fitted model <code>object</code>
contains the history of evaluations of the objective function
that were performed by the optimisation algorithm. This history is
extracted by <code>traj</code>.
</p>
<p>The result is a data frame containing the input parameter values for
the objective function, and the corresponding value of the objective
function, that were considered by the optimisation algorithm. This
data frame also belongs to the class <code>"traj"</code> which has
methods for <code>plot</code>, <code>print</code> and other purposes.
</p>


<h3>Value</h3>

<p>Either a data frame (belonging to class <code>"traj"</code>)
or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.traj">methods.traj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- kppm(redwood, trajectory=TRUE)
  h &lt;- traj(fit)
</code></pre>

<hr>
<h2 id='triplet.family'>Triplet Interaction Family</h2><span id='topic+triplet.family'></span>

<h3>Description</h3>

<p>An object describing the family of all Gibbs point processes
with interaction order equal to 3.
</p>


<h3>Details</h3>

<p><b>Advanced Use Only!</b>
</p>
<p>This structure would not normally be touched by
the user. It describes the interaction structure
of Gibbs point processes which have infinite order of interaction,
such as the triplet interaction process <cite><a href="#topic+Triplets">Triplets</a></cite>.
</p>
<p>Anyway, <code>triplet.family</code> is an object of class <code>"isf"</code>
containing a function <code>triplet.family$eval</code> for
evaluating the sufficient statistics of a Gibbs
point process model taking an exponential family form. 
</p>


<h3>Value</h3>

<p>Object of class <code>"isf"</code>, see <code><a href="#topic+isf.object">isf.object</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Triplets">Triplets</a></code> to create the triplet interaction process
structure.
</p>
<p>Other families:
<code><a href="#topic+pairwise.family">pairwise.family</a></code>,
<code><a href="#topic+pairsat.family">pairsat.family</a></code>,
<code><a href="#topic+inforder.family">inforder.family</a></code>,
<code><a href="#topic+ord.family">ord.family</a></code>.
</p>

<hr>
<h2 id='Triplets'>The Triplet Point Process Model</h2><span id='topic+Triplets'></span>

<h3>Description</h3>

<p>Creates an instance of Geyer's triplet interaction point process model
which can then be fitted to point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Triplets(r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Triplets_+3A_r">r</code></td>
<td>
<p>The interaction radius of the Triplets process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (stationary) Geyer triplet process (Geyer, 1999)
with interaction radius <code class="reqn">r</code> and 
parameters <code class="reqn">\beta</code> and <code class="reqn">\gamma</code>
is the point process
in which each point contributes a factor <code class="reqn">\beta</code> to the 
probability density of the point pattern, and each triplet of close points
contributes a factor <code class="reqn">\gamma</code> to the density.
A triplet of close points is a group of 3 points,
each pair of which is closer than <code class="reqn">r</code> units
apart.
</p>
<p>Thus the probability density is
</p>
<p style="text-align: center;"><code class="reqn">
    f(x_1,\ldots,x_n) =
    \alpha \beta^{n(x)} \gamma^{s(x)}
  </code>
</p>

<p>where <code class="reqn">x_1,\ldots,x_n</code> represent the 
points of the pattern, <code class="reqn">n(x)</code> is the number of points in the
pattern, <code class="reqn">s(x)</code> is the number of unordered triples of
points that are closer than <code class="reqn">r</code> units apart,
and <code class="reqn">\alpha</code> is the normalising constant.
</p>
<p>The interaction parameter <code class="reqn">\gamma</code> must be less than
or equal to <code class="reqn">1</code>
so that this model describes an &ldquo;ordered&rdquo; or &ldquo;inhibitive&rdquo; pattern.
</p>
<p>The nonstationary Triplets process is similar except that 
the contribution of each individual point <code class="reqn">x_i</code>
is a function <code class="reqn">\beta(x_i)</code>
of location, rather than a constant beta. 
</p>
<p>The function <code><a href="#topic+ppm">ppm</a>()</code>, which fits point process models to 
point pattern data, requires an argument 
of class <code>"interact"</code> describing the interpoint interaction
structure of the model to be fitted. 
The appropriate description of the Triplets process pairwise interaction is
yielded by the function <code>Triplets()</code>. See the examples below.
</p>
<p>Note the only argument is the interaction radius <code>r</code>.
When <code>r</code> is fixed, the model becomes an exponential family.
The canonical parameters <code class="reqn">\log(\beta)</code>
and <code class="reqn">\log(\gamma)</code>
are estimated by <code><a href="#topic+ppm">ppm</a>()</code>, not fixed in
<code>Triplets()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"interact"</code>
describing the interpoint interaction
structure of the Triplets process with interaction radius <code class="reqn">r</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Geyer, C.J. (1999)
Likelihood Inference for Spatial Point Processes.
Chapter 3 in 
O.E. Barndorff-Nielsen, W.S. Kendall and M.N.M. Van Lieshout (eds)
<em>Stochastic Geometry: Likelihood and Computation</em>,
Chapman and Hall / CRC, 
Monographs on Statistics and Applied Probability, number 80.
Pages 79&ndash;140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+triplet.family">triplet.family</a></code>,
<code><a href="#topic+ppm.object">ppm.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Triplets(r=0.1)
   # prints a sensible description of itself

   ppm(cells ~1, Triplets(r=0.2))
   # fit the stationary Triplets process to `cells'

   
     ppm(cells ~polynom(x,y,3), Triplets(r=0.2))
     # fit a nonstationary Triplets process with log-cubic polynomial trend
   
</code></pre>

<hr>
<h2 id='unitname'>Name for Unit of Length</h2><span id='topic+unitname.dppm'></span><span id='topic+unitname.kppm'></span><span id='topic+unitname.minconfit'></span><span id='topic+unitname.ppm'></span><span id='topic+unitname.slrm'></span><span id='topic+unitname+3C-.dppm'></span><span id='topic+unitname+3C-.kppm'></span><span id='topic+unitname+3C-.minconfit'></span><span id='topic+unitname+3C-.ppm'></span><span id='topic+unitname+3C-.slrm'></span>

<h3>Description</h3>

<p>Inspect or change the name of the unit of length
in a spatial dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dppm'
unitname(x)
## S3 method for class 'kppm'
unitname(x)
## S3 method for class 'minconfit'
unitname(x)
## S3 method for class 'ppm'
unitname(x)
## S3 method for class 'slrm'
unitname(x)
## S3 replacement method for class 'dppm'
unitname(x) &lt;- value
## S3 replacement method for class 'kppm'
unitname(x) &lt;- value
## S3 replacement method for class 'minconfit'
unitname(x) &lt;- value
## S3 replacement method for class 'ppm'
unitname(x) &lt;- value
## S3 replacement method for class 'slrm'
unitname(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitname_+3A_x">x</code></td>
<td>
<p>A spatial dataset.
Either a point pattern (object of class <code>"ppp"</code>),
a line segment pattern (object of class <code>"psp"</code>),
a window (object of class <code>"owin"</code>),
a pixel image (object of class <code>"im"</code>),
a tessellation (object of class <code>"tess"</code>),
a quadrature scheme (object of class <code>"quad"</code>),
or a fitted point process model
(object of class <code>"ppm"</code> or <code>"kppm"</code> or <code>"slrm"</code>
or <code>"dppm"</code> or <code>"minconfit"</code>).
</p>
</td></tr>
<tr><td><code id="unitname_+3A_value">value</code></td>
<td>

<p>Name of the unit of length. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial datasets in the <span class="pkg">spatstat</span> package
may include the name of the unit of length. This name is used
when printing or plotting the dataset, and in some other
applications. 
</p>
<p><code>unitname(x)</code> extracts this name,
and <code>unitname(x) &lt;- value</code> sets the name to <code>value</code>.
</p>
<p>A valid name is either
</p>

<ul>
<li><p> a single character string
</p>
</li>
<li><p> a vector of two character strings giving the
singular and plural forms of the unit name
</p>
</li>
<li><p> a list of length 3, containing two character strings
giving the singular and plural forms of the basic unit,
and a number specifying the multiple of this unit.
</p>
</li></ul>

<p>Note that re-setting the name of the unit of length <em>does not</em>
affect the numerical values in <code>x</code>. It changes only the string
containing the name of the unit of length. To rescale the numerical
values, use <code><a href="spatstat.geom.html#topic+rescale">rescale</a></code>.
</p>


<h3>Value</h3>

<p>The return value of <code>unitname</code> is an object of class <code>"unitname"</code>
containing the name of the unit of length in <code>x</code>. There are
methods for <code>print</code>, <code>summary</code>, <code>as.character</code>,
<code><a href="spatstat.geom.html#topic+rescale">rescale</a></code> and <code><a href="spatstat.geom.html#topic+compatible">compatible</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+rescale">rescale</a></code>,
<code><a href="spatstat.geom.html#topic+owin">owin</a></code>,
<code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runifrect(20)

  # if the unit of length is 1 metre:
  unitname(X) &lt;- c("metre", "metres")

  # if the unit of length is 6 inches:
  unitname(X) &lt;- list("inch", "inches", 6)
</code></pre>

<hr>
<h2 id='unstack.msr'>
Separate a Vector Measure into its Scalar Components
</h2><span id='topic+unstack.msr'></span>

<h3>Description</h3>

<p>Converts a vector-valued measure into a list of
scalar-valued measures. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msr'
unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack.msr_+3A_x">x</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
<tr><td><code id="unstack.msr_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic
<code><a href="utils.html#topic+unstack">unstack</a></code> for the class <code>"msr"</code> of measures. 
</p>
<p>If <code>x</code> is a vector-valued measure, then 
<code>y &lt;- unstack(x)</code> is a list of scalar-valued measures
defined by the components of <code>x</code>. 
The <code>j</code>th entry of the list, <code>y[[j]]</code>, is equivalent to
the <code>j</code>th component of the vector measure <code>x</code>.
</p>
<p>If <code>x</code> is a scalar-valued measure, then
the result is a list consisting of one entry, which is <code>x</code>.
</p>


<h3>Value</h3>

<p>A list of measures, of class <code>"solist"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+unstack">unstack</a></code>
</p>
<p><code><a href="spatstat.geom.html#topic+unstack.ppp">unstack.ppp</a></code>
</p>
<p><code><a href="#topic+split.msr">split.msr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- ppm(cells ~ x)
   m &lt;- residuals(fit, type="score")
   m
   unstack(m)
</code></pre>

<hr>
<h2 id='update.detpointprocfamily'>Set Parameter Values in a Determinantal Point Process Model</h2><span id='topic+update.detpointprocfamily'></span>

<h3>Description</h3>

<p>Set parameter values in a determinantal point process model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'detpointprocfamily'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.detpointprocfamily_+3A_object">object</code></td>
<td>
<p>object of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="update.detpointprocfamily_+3A_...">...</code></td>
<td>

<p>arguments of the form <code>tag=value</code> specifying the parameters 
values to set.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Another object of class <code>"detpointprocfamily"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='update.dppm'>Update a Fitted Determinantal Point Process Model</h2><span id='topic+update.dppm'></span>

<h3>Description</h3>

<p><code>update</code> method for class <code>"dppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'dppm'
update(object, ..., evaluate=TRUE,
                       envir=environment(terms(object)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.dppm_+3A_object">object</code></td>
<td>

<p>Fitted determinantal point process model.
An object of class <code>"dppm"</code>,
obtained from <code><a href="#topic+dppm">dppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.dppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+dppm">dppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.dppm_+3A_evaluate">evaluate</code></td>
<td>

<p>Logical value indicating whether to return the updated fitted model
(<code>evaluate=TRUE</code>, the default) or just the updated call to <code>dppm</code>
(<code>evaluate=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="update.dppm_+3A_envir">envir</code></td>
<td>

<p>Environment in which to re-evaluate the call to <code><a href="#topic+dppm">dppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> should be a fitted determinantal point process model,
obtained from the model-fitting function <code><a href="#topic+dppm">dppm</a></code>.
The model will be updated according to the new arguments provided.
</p>
<p>If the argument <code>trend</code> is provided, it determines the
intensity in the updated model. It should be an <span class="rlang"><b>R</b></span> formula
(with or without a left hand side). It may include the symbols
<code>+</code> or <code>-</code> to specify addition or deletion of terms
in the current model formula, as shown in the Examples below.
The symbol <code>.</code> refers to the current contents of the
formula.
</p>
<p>The intensity in the updated model is determined by the
argument <code>trend</code> if it is provided, or otherwise by any unnamed
argument that is a formula, or otherwise by the formula of the
original model, <code>formula(object)</code>.
</p>
<p>The spatial point pattern data to which the new model is fitted
is determined by the left hand side of the updated model formula,
if this is present. Otherwise it is determined by the argument
<code>X</code> if it is provided, or otherwise by any unnamed argument
that is a point pattern or a quadrature scheme.
</p>
<p>The model is refitted using <code><a href="#topic+dppm">dppm</a></code>.
</p>


<h3>Value</h3>

<p>Another fitted cluster point process model (object of
class <code>"dppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dppm">dppm</a></code>,  <code><a href="#topic+plot.dppm">plot.dppm</a></code>,
<code><a href="#topic+predict.dppm">predict.dppm</a></code>, <code><a href="#topic+simulate.dppm">simulate.dppm</a></code>,
<code><a href="#topic+methods.dppm">methods.dppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- dppm(swedishpines ~ x + y, dppGauss, method="c")
  fitx &lt;- update(fit, ~x)
  fit2 &lt;- update(fit, flipxy(swedishpines))
</code></pre>

<hr>
<h2 id='update.interact'>
Update an Interpoint Interaction
</h2><span id='topic+update.interact'></span>

<h3>Description</h3>

<p>This command updates the <code>object</code> using the
arguments given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'interact'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.interact_+3A_object">object</code></td>
<td>

<p>Interpoint interaction (object of class <code>"interact"</code>).
</p>
</td></tr>
<tr><td><code id="update.interact_+3A_...">...</code></td>
<td>

<p>Additional or replacement values of parameters of <code>object</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+update">update</a></code>
for the class <code>"interact"</code> of interpoint interactions.
It updates the <code>object</code> using the parameters given in the
extra arguments <code>...</code>.
</p>
<p>The extra arguments must be given in
the form <code>name=value</code> and must be recognisable to
the interaction object. They override any parameters
of the same name in <code>object</code>.
</p>


<h3>Value</h3>

<p>Another object of class <code>"interact"</code>, equivalent to <code>object</code>
except for changes in parameter values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update.ppm">update.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Str &lt;- Strauss(r=1)
  Str
  update(Str, r=2)

  M &lt;- MultiStrauss(radii=matrix(1,2,2))
  update(M, types=c("on", "off"))
</code></pre>

<hr>
<h2 id='update.kppm'>Update a Fitted Cluster Point Process Model</h2><span id='topic+update.kppm'></span>

<h3>Description</h3>

<p><code>update</code> method for class <code>"kppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'kppm'
update(object, ..., evaluate=TRUE,
                       envir=environment(terms(object)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.kppm_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model.
An object of class <code>"kppm"</code>,
obtained from <code><a href="#topic+kppm">kppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.kppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+kppm">kppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.kppm_+3A_evaluate">evaluate</code></td>
<td>

<p>Logical value indicating whether to return the updated fitted model
(<code>evaluate=TRUE</code>, the default) or just the updated call to <code>kppm</code>
(<code>evaluate=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="update.kppm_+3A_envir">envir</code></td>
<td>

<p>Environment in which to re-evaluate the call to <code><a href="#topic+kppm">kppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> should be a fitted cluster point process model,
obtained from the model-fitting function <code><a href="#topic+kppm">kppm</a></code>.
The model will be updated according to the new arguments provided.
</p>
<p>If the argument <code>trend</code> is provided, it determines the
intensity in the updated model. It should be an <span class="rlang"><b>R</b></span> formula
(with or without a left hand side). It may include the symbols
<code>+</code> or <code>-</code> to specify addition or deletion of terms
in the current model formula, as shown in the Examples below.
The symbol <code>.</code> refers to the current contents of the
formula.
</p>
<p>The intensity in the updated model is determined by the
argument <code>trend</code> if it is provided, or otherwise by any unnamed
argument that is a formula, or otherwise by the formula of the
original model, <code>formula(object)</code>.
</p>
<p>The spatial point pattern data to which the new model is fitted
is determined by the left hand side of the updated model formula,
if this is present. Otherwise it is determined by the argument
<code>X</code> if it is provided, or otherwise by any unnamed argument
that is a point pattern or a quadrature scheme.
</p>
<p>The model is refitted using <code><a href="#topic+kppm">kppm</a></code>.
</p>


<h3>Value</h3>

<p>Another fitted cluster point process model (object of
class <code>"kppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,  <code><a href="#topic+plot.kppm">plot.kppm</a></code>,
<code><a href="#topic+predict.kppm">predict.kppm</a></code>, <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>,
<code><a href="#topic+methods.kppm">methods.kppm</a></code>,
<code><a href="#topic+vcov.kppm">vcov.kppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- kppm(redwood ~1, "Thomas")
 fitx &lt;- update(fit, ~ . + x)
 fitM &lt;- update(fit, clusters="MatClust")
 fitC &lt;- update(fit, cells)
 fitCx &lt;- update(fit, cells ~ x)
</code></pre>

<hr>
<h2 id='update.ppm'>Update a Fitted Point Process Model</h2><span id='topic+update.ppm'></span>

<h3>Description</h3>

<p><code>update</code> method for class <code>"ppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
update(object, ..., fixdummy=TRUE, use.internal=NULL,
                                      envir=environment(terms(object)))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.ppm_+3A_object">object</code></td>
<td>

<p>An existing fitted point process model,
typically produced by <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.ppm_+3A_...">...</code></td>
<td>

<p>Arguments to be updated in the new call to <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.ppm_+3A_fixdummy">fixdummy</code></td>
<td>

<p>Logical flag indicating whether the quadrature scheme for the
call to <code><a href="#topic+ppm">ppm</a></code> should use the same set of dummy points
as that in the original call.
</p>
</td></tr>
<tr><td><code id="update.ppm_+3A_use.internal">use.internal</code></td>
<td>

<p>Optional. Logical flag indicating whether the model should be
refitted using the internally saved data (<code>use.internal=TRUE</code>)
or by re-evaluating these data in the
current frame (<code>use.internal=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="update.ppm_+3A_envir">envir</code></td>
<td>

<p>Environment in which to re-evaluate the call to <code><a href="#topic+ppm">ppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+update">update</a></code>
for the class <code>"ppm"</code>. An object of class <code>"ppm"</code>
describes a fitted point process model. See <code><a href="#topic+ppm.object">ppm.object</a></code>)
for details of this class.
</p>
<p><code>update.ppm</code> will modify the point process model
specified by <code>object</code> according to the new arguments given,
then re-fit it.
The actual re-fitting is performed by the model-fitting
function <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>If you are comparing several model fits to the same data,
or fits of the same model to different data, it is
strongly advisable to use <code>update.ppm</code>
rather than trying to fit them by hand.
This is because <code>update.ppm</code> re-fits the model
in a way which is comparable to the original fit.
</p>
<p>The arguments <code>...</code> are matched to the formal arguments
of <code><a href="#topic+ppm">ppm</a></code> as follows.
</p>
<p>First, all the <em>named</em> arguments in <code>...</code> are matched
with the formal arguments of <code><a href="#topic+ppm">ppm</a></code>.
Use <code>name=NULL</code> to remove the argument <code>name</code> from the
call.
</p>
<p>Second, any <em>unnamed</em> arguments in <code>...</code> are
matched with formal arguments of <code><a href="#topic+ppm">ppm</a></code> if the matching
is obvious from the class of the object. Thus <code>...</code> may contain
</p>

<ul>
<li>
<p>exactly one argument of class <code>"ppp"</code> or <code>"quad"</code>,
which will be interpreted as the named argument <code>Q</code>;
</p>
</li>
<li>
<p>exactly one argument of class <code>"formula"</code>, which will be
interpreted as the named argument <code>trend</code> (or as specifying
a change to the trend formula);
</p>
</li>
<li>
<p>exactly one argument of class <code>"interact"</code>, which will be
interpreted as the named argument <code>interaction</code>;
</p>
</li>
<li>
<p>exactly one argument of class <code>"data.frame"</code>, which will be
interpreted as the named argument <code>covariates</code>.
</p>
</li></ul>

<p>The <code>trend</code> argument can be a formula that specifies a
<em>change</em> to the current trend formula. For example, the
formula <code>~ . + Z</code> specifies that the additional covariate
<code>Z</code> will be added to the right hand side of the trend
formula in the existing <code>object</code>.
</p>
<p>The argument <code>fixdummy=TRUE</code> ensures comparability of the
objects before and after updating.
When <code>fixdummy=FALSE</code>, calling <code>update.ppm</code>
is exactly the same as calling <code>ppm</code> with the updated
arguments. However, the original and updated models
are not strictly comparable (for example, their pseudolikelihoods
are not strictly comparable) unless they used the same set of dummy
points for the quadrature scheme. Setting <code>fixdummy=TRUE</code>
ensures that the re-fitting will be performed using the same set
of dummy points. This is highly recommended.
</p>
<p>The value of <code>use.internal</code> determines where to find data
to re-evaluate the model (data for the arguments mentioned in
the original call to <code>ppm</code> that are not overwritten by
arguments to <code>update.ppm</code>).
</p>
<p>If <code>use.internal=FALSE</code>, then arguments 
to <code>ppm</code> are <em>re-evaluated</em> in the frame where you
call <code>update.ppm</code>. This is like the behaviour of the
other methods for <code><a href="stats.html#topic+update">update</a></code>. This means that if you have changed
any of the objects referred to in the call, these changes will be
taken into account. Also if the original call to <code>ppm</code> included
any calls to random number generators, these calls will be recomputed,
so that you will get a different outcome of the random numbers.
</p>
<p>If <code>use.internal=TRUE</code>, then arguments to <code>ppm</code> are extracted
from internal data stored inside the current fitted
model <code>object</code>. This is useful if you don't want to 
re-evaluate anything. It is also necessary if 
if <code>object</code> has been restored from a dump file
using <code><a href="base.html#topic+load">load</a></code> or <code><a href="base.html#topic+source">source</a></code>. In such cases,
we have lost the environment in which <code>object</code> was fitted,
and data cannot be re-evaluated.
</p>
<p>By default, if <code>use.internal</code> is missing, <code>update.ppm</code> will
re-evaluate the arguments if this is possible, and use internal data
if not.
</p>


<h3>Value</h3>

<p>Another fitted point process model (object of class <code>"ppm"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cells)

  # fit the stationary Poisson process
  fit &lt;- ppm(nztrees, ~ 1)

  # fit a nonstationary Poisson process
  fitP &lt;- update(fit, trend=~x)
  fitP &lt;- update(fit, ~x)

  # change the trend formula: add another term to the trend
  fitPxy &lt;- update(fitP, ~ . + y)
  # change the trend formula: remove the x variable
  fitPy &lt;- update(fitPxy, ~ . - x)

  # fit a stationary Strauss process
  fitS &lt;- update(fit, interaction=Strauss(13))
  fitS &lt;- update(fit, Strauss(13))

  # refit using a different edge correction
  fitS &lt;- update(fitS, correction="isotropic")

  # re-fit the model to a subset
  # of the original point pattern
  nzw &lt;- owin(c(0,148),c(0,95))
  nzsub &lt;- nztrees[,nzw]
  fut &lt;- update(fitS, Q=nzsub)
  fut &lt;- update(fitS, nzsub)

  # WARNING: the point pattern argument is called 'Q'

  ranfit &lt;- ppm(rpoispp(42), ~1, Poisson())
  ranfit
  # different random data!  
  update(ranfit)
  # the original data
  update(ranfit, use.internal=TRUE)  

</code></pre>

<hr>
<h2 id='update.rppm'>Update a Recursively Partitioned Point Process Model</h2><span id='topic+update.rppm'></span>

<h3>Description</h3>

<p><code>update</code> method for class <code>"rppm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'rppm'
update(object, ..., envir=environment(terms(object)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.rppm_+3A_object">object</code></td>
<td>

<p>Fitted recursively partitioned point process model.
An object of class <code>"rppm"</code>,
obtained from <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.rppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
<tr><td><code id="update.rppm_+3A_envir">envir</code></td>
<td>

<p>Environment in which to re-evaluate the call to <code><a href="#topic+rppm">rppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> should be a fitted recursively partitioned point process model,
obtained from the model-fitting function <code><a href="#topic+rppm">rppm</a></code>.
</p>
<p>The model will be updated according to the new arguments provided.
</p>


<h3>Value</h3>

<p>Another fitted recursively partitioned point process model (object of
class <code>"rppm"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rppm">rppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- rppm(nztrees ~ x)
 newfit &lt;- update(fit, . ~ x + y)
</code></pre>

<hr>
<h2 id='valid'>
Check Whether Point Process Model is Valid
</h2><span id='topic+valid'></span>

<h3>Description</h3>

<p>Determines whether a point process model object
corresponds to a valid point process.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  valid(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_+3A_object">object</code></td>
<td>

<p>Object of some class, describing a point process model.
</p>
</td></tr>
<tr><td><code id="valid_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>valid</code> is generic,
with methods for the classes <code>"ppm"</code> and <code>"dppmodel"</code>.
</p>
<p>An object representing a point process is called valid if
all its parameter values are known (for example, no parameter
takes the value <code>NA</code> or <code>NaN</code>) and the parameter values
correspond to a well-defined point process (for example, the
parameter values satisfy all the constraints that are imposed by
mathematical theory.) 
</p>
<p>See the methods for further details.
</p>


<h3>Value</h3>

<p>A logical value, or <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid.ppm">valid.ppm</a></code>,
<code><a href="#topic+valid.detpointprocfamily">valid.detpointprocfamily</a></code>
</p>

<hr>
<h2 id='valid.detpointprocfamily'>Check Validity of a Determinantal Point Process Model</h2><span id='topic+valid.detpointprocfamily'></span>

<h3>Description</h3>

<p>Checks the validity of a determinantal point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'detpointprocfamily'
valid(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.detpointprocfamily_+3A_object">object</code></td>
<td>
<p>Model of class <code>"detpointprocfamily"</code>.</p>
</td></tr>
<tr><td><code id="valid.detpointprocfamily_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+valid">valid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model1 &lt;- dppMatern(lambda=100, alpha=.01, nu=1, d=2)
valid(model1)
model2 &lt;- dppMatern(lambda=100, alpha=1, nu=1, d=2)
valid(model2)
</code></pre>

<hr>
<h2 id='valid.ppm'>
Check Whether Point Process Model is Valid
</h2><span id='topic+valid.ppm'></span>

<h3>Description</h3>

<p>Determines whether a fitted point process model 
satisfies the integrability conditions for existence of the point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
valid(object, warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.ppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model (object of class <code>"ppm"</code>).
</p>
</td></tr>
<tr><td><code id="valid.ppm_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
validity of the model cannot be checked (due to unavailability of
the required code).
</p>
</td></tr>
<tr><td><code id="valid.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+valid">valid</a></code>
for Poisson and Gibbs point process models (class <code>"ppm"</code>).
</p>
<p>The model-fitting function <code><a href="#topic+ppm">ppm</a></code>
fits Gibbs point process models to point pattern data.
By default, <code><a href="#topic+ppm">ppm</a></code> does not check whether the
fitted model actually exists as a point process. This checking
is done by <code>valid.ppm</code>.
</p>
<p>Unlike a regression model, which is well-defined for any values
of the fitted regression coefficients, a Gibbs point process model
is only well-defined if the fitted interaction parameters 
satisfy some constraints. 
A famous example is the Strauss process (see <code><a href="#topic+Strauss">Strauss</a></code>)
which exists only when the interaction parameter <code class="reqn">\gamma</code>
is less than or equal to 1. For values <code class="reqn">\gamma &gt; 1</code>,
the probability density is not integrable and the process does not
exist (and cannot be simulated).
</p>
<p>By default, <code><a href="#topic+ppm">ppm</a></code> does not enforce the constraint that
a fitted Strauss process (for example) must satisfy
<code class="reqn">\gamma \le 1</code>.
This is because a fitted parameter value of <code class="reqn">\gamma &gt; 1</code> 
could be useful information for data analysis, as it indicates that
the Strauss model is not appropriate, and suggests a clustered model should be
fitted.
</p>
<p>The function <code>valid.ppm</code> checks whether the fitted model
<code>object</code> specifies a well-defined point process. It returns
<code>TRUE</code> if the model is well-defined.
</p>
<p>Another possible reason for invalid models is that the data may not
be adequate for estimation of the model parameters. In this case,
some of the fitted coefficients could be <code>NA</code> or infinite
values. If this happens
then <code>valid.ppm</code> returns <code>FALSE</code>.
</p>
<p>Use the function <code><a href="#topic+project.ppm">project.ppm</a></code> to force the fitted model
to be valid.
</p>


<h3>Value</h3>

<p>A logical value, or <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppm">ppm</a></code>,
<code><a href="#topic+project.ppm">project.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit1 &lt;- ppm(cells, ~1, Strauss(0.1))
   valid(fit1)
   fit2 &lt;- ppm(redwood, ~1, Strauss(0.1))
   valid(fit2)
</code></pre>

<hr>
<h2 id='valid.slrm'>
Check Whether Spatial Logistic Regression Model is Valid
</h2><span id='topic+valid.slrm'></span>

<h3>Description</h3>

<p>Determines whether a fitted spatial logistic regression model
is a well-defined model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
valid(object, warn=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.slrm_+3A_object">object</code></td>
<td>

<p>Fitted spatial logistic regression model (object of class <code>"slrm"</code>).
</p>
</td></tr>
<tr><td><code id="valid.slrm_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the
validity of the model cannot be checked (due to unavailability of
the required code).
</p>
</td></tr>
<tr><td><code id="valid.slrm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="#topic+valid">valid</a></code>
for spatial logistic regression models (class <code>"slrm"</code>).
</p>
<p>In a model fitted by <code><a href="#topic+slrm">slrm</a></code>, some of the fitted
coefficients may be <code>NA</code> or infinite values.
This can occur if the data are not
adequate for estimation of the model parameters. The model is said
to be <em>unidentifiable</em> or <em>confounded</em>.
</p>
<p>The function <code>valid.slrm</code> checks whether the fitted coefficients of
<code>object</code> specify a well-defined model. It returns
<code>TRUE</code> if the model is well-defined, and <code>FALSE</code> otherwise.
</p>
<p>Use the function <code><a href="#topic+emend.slrm">emend.slrm</a></code> to force the fitted model
to be valid.
</p>


<h3>Value</h3>

<p>A logical value, or <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slrm">slrm</a></code>,
<code><a href="#topic+emend.slrm">emend.slrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit1 &lt;- slrm(cells ~ x)
   valid(fit1)
   fit2 &lt;- slrm(cells ~ x + I(x))
   valid(fit2)
</code></pre>

<hr>
<h2 id='varcount'>
Predicted Variance of the Number of Points 
</h2><span id='topic+varcount'></span>

<h3>Description</h3>

<p>Given a fitted point process model, calculate the predicted variance
of the number of points in a nominated set <code>B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varcount(model, B=Window(model), ..., dimyx = NULL, relative=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varcount_+3A_model">model</code></td>
<td>

<p>A fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
</p>
</td></tr>
<tr><td><code id="varcount_+3A_b">B</code></td>
<td>

<p>A window (object of class <code>"owin"</code> specifying the region in
which the points are counted.
Alternatively a pixel image (object of class <code>"im"</code>)
or a function of spatial coordinates specifying a numerical weight
for each random point.
The default is the window of the original point pattern data to which
the model was fitted.
</p>
</td></tr>
<tr><td><code id="varcount_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>B</code> when it is a function.
</p>
</td></tr>
<tr><td><code id="varcount_+3A_dimyx">dimyx</code></td>
<td>

<p>Spatial resolution for the calculations.
Argument passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>.
</p>
</td></tr>
<tr><td><code id="varcount_+3A_relative">relative</code></td>
<td>

<p>Logical value specifying whether to divide the variance
by the mean value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>varcount</code> calculates the variance of the number of points
falling in a specified window <code>B</code> according to the <code>model</code>.
It can also calculate the variance of a sum of weights attached
to each random point.
</p>
<p>If <code>relative=FALSE</code> (the default), the result is the variance.
If <code>relative=TRUE</code>, the result is the variance divided by the
mean, which is the overdispersion index (equal to 1 if the number of
points has a Poisson distribution).
</p>
<p>The <code>model</code> should be a fitted point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code> or <code>"dppm"</code>).
</p>

<ul>
<li>
<p>If <code>B</code> is a window, <code>varcount</code> calculates the variance
of the number of points falling in <code>B</code>, according to the
fitted <code>model</code>.
</p>
<p>If the <code>model</code> depends on spatial covariates other than the
Cartesian coordinates, then <code>B</code> should be a subset of the
domain in which these covariates are defined. 

</p>
</li>
<li>
<p>If <code>B</code> is a pixel image,
<code>varcount</code> calculates the variance of
<code class="reqn">T = \sum_i B(x_i)</code>,
the sum of the values of <code>B</code> over all random points
falling in the domain of the image.
</p>
<p>If the <code>model</code> depends on spatial covariates other than the
Cartesian coordinates, then the domain of the pixel image,
<code>as.owin(B)</code>, should be a subset of the domain in which these
covariates are defined. 

</p>
</li>
<li>
<p>If <code>B</code> is a <code>function(x,y)</code> or <code>function(x,y,...)</code>
then <code>varcount</code> calculates the variance of
<code class="reqn">T = \sum_i B(x_i)</code>,
the sum of the values of <code>B</code> over all random points
falling inside the window <code>W=as.owin(model)</code>, the window
in which the original data were observed.

</p>
</li></ul>

<p>The variance calculation involves the intensity and the
pair correlation function of the model.
The calculation is exact (up to discretisation error)
for models of class <code>"kppm"</code> and <code>"dppm"</code>,
and for Poisson point process models of class <code>"ppm"</code>.
For Gibbs point process models of class <code>"ppm"</code> the
calculation depends on the Poisson-saddlepoint approximations
to the intensity and pair correlation function, which are rough
approximations. The approximation is not yet implemented
for some Gibbs models.
</p>


<h3>Value</h3>

<p>A single number.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ppm">predict.ppm</a></code>,
<code><a href="#topic+predict.kppm">predict.kppm</a></code>,
<code><a href="#topic+predict.dppm">predict.dppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fitT &lt;- kppm(redwood ~ 1, "Thomas")
   B &lt;- owin(c(0, 0.5), c(-0.5, 0))
   varcount(fitT, B)

   fitS &lt;- ppm(swedishpines ~ 1, Strauss(9))
   BS &lt;- square(50)
   varcount(fitS, BS)
</code></pre>

<hr>
<h2 id='vargamma.estK'>Fit the Neyman-Scott Cluster Point Process with Variance Gamma kernel</h2><span id='topic+vargamma.estK'></span>

<h3>Description</h3>

<p>Fits the Neyman-Scott cluster point process, with Variance Gamma
kernel, to a point pattern dataset by the Method of Minimum Contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vargamma.estK(X, startpar=c(kappa=1,scale=1), nu = -1/4, lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vargamma.estK_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the model.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_nu">nu</code></td>
<td>

<p>Numerical value controlling the shape of the tail of the clusters.
A number greater than <code>-1/2</code>.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_q">q</code>, <code id="vargamma.estK_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_rmin">rmin</code>, <code id="vargamma.estK_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="vargamma.estK_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Neyman-Scott Cluster point process model
with Variance Gamma kernel (Jalilian et al, 2013)
to a point pattern dataset
by the Method of Minimum Contrast, using the <code class="reqn">K</code> function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The <code class="reqn">K</code> function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the <code class="reqn">K</code> function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Neyman-Scott Cluster point process
with Variance Gamma kernel to <code>X</code>,
by finding the parameters of the model
which give the closest match between the
theoretical <code class="reqn">K</code> function of the model
and the observed <code class="reqn">K</code> function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Neyman-Scott cluster point process with Variance Gamma
kernel is described in Jalilian et al (2013).
It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
have a common distribution described in Jalilian et al (2013).
</p>
<p>The shape of the kernel is determined by the dimensionless
index <code>nu</code>. This is the parameter
<code class="reqn">\nu^\prime = \alpha/2-1</code> appearing in
equation (12) on page 126 of Jalilian et al (2013).
In previous versions of spatstat instead of specifying <code>nu</code>
(called <code>nu.ker</code> at that time) the user could specify
<code>nu.pcf</code> which is the parameter <code class="reqn">\nu=\alpha-1</code>
appearing in equation (13), page 127 of Jalilian et al (2013).
These are related by <code>nu.pcf = 2 * nu.ker + 1</code>
and <code>nu.ker = (nu.pcf - 1)/2</code>. This syntax is still supported but
not recommended for consistency across the package. In that case
exactly one of <code>nu.ker</code> or <code>nu.pcf</code> must be specified.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of the point process intensity <code class="reqn">\lambda</code>.
Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The corresponding model can be simulated using <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>.
</p>
<p>The parameter <code>eta</code> appearing in <code>startpar</code> is equivalent to the
scale parameter <code>omega</code> used in  <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>.
</p>
<p>Homogeneous or inhomogeneous Neyman-Scott/VarGamma models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code> and the fitted models
can be simulated using <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+vargamma.estpcf">vargamma.estpcf</a></code>,
<code><a href="#topic+lgcp.estK">lgcp.estK</a></code>,
<code><a href="#topic+thomas.estK">thomas.estK</a></code>,
<code><a href="#topic+cauchy.estK">cauchy.estK</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
<code><a href="#topic+Kmodel">Kmodel</a></code>.
</p>
<p><code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code> to simulate the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
      u &lt;- vargamma.estK(redwood)
      print(u)
      plot(u)
   }
</code></pre>

<hr>
<h2 id='vargamma.estpcf'>Fit the Neyman-Scott Cluster Point Process with Variance Gamma kernel</h2><span id='topic+vargamma.estpcf'></span>

<h3>Description</h3>

<p>Fits the Neyman-Scott cluster point process, with Variance Gamma
kernel, to a point pattern dataset by the Method of Minimum Contrast,
using the pair correlation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vargamma.estpcf(X, startpar=c(kappa=1,scale=1), nu = -1/4, lambda=NULL,
            q = 1/4, p = 2, rmin = NULL, rmax = NULL,
            ..., pcfargs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vargamma.estpcf_+3A_x">X</code></td>
<td>

<p>Data to which the model will be fitted.
Either a point pattern or a summary statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_startpar">startpar</code></td>
<td>

<p>Vector of starting values for the parameters of the model.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_nu">nu</code></td>
<td>

<p>Numerical value controlling the shape of the tail of the clusters.
A number greater than <code>-1/2</code>.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_lambda">lambda</code></td>
<td>

<p>Optional. An estimate of the intensity of the point process.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_q">q</code>, <code id="vargamma.estpcf_+3A_p">p</code></td>
<td>

<p>Optional. Exponents for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_rmin">rmin</code>, <code id="vargamma.estpcf_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The interval of <code class="reqn">r</code> values for the contrast criterion.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>
to control the optimisation algorithm. See Details.
</p>
</td></tr>
<tr><td><code id="vargamma.estpcf_+3A_pcfargs">pcfargs</code></td>
<td>

<p>Optional list containing arguments passed to <code><a href="spatstat.explore.html#topic+pcf.ppp">pcf.ppp</a></code>
to control the smoothing in the estimation of the
pair correlation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm fits the Neyman-Scott Cluster point process model
with Variance Gamma kernel (Jalilian et al, 2013)
to a point pattern dataset
by the Method of Minimum Contrast, using the pair correlation function.
</p>
<p>The argument <code>X</code> can be either
</p>

<dl>
<dt>a point pattern:</dt><dd><p>An object of class <code>"ppp"</code>
representing a point pattern dataset. 
The pair correlation function of the point pattern will be computed
using <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>, and the method of minimum contrast
will be applied to this.
</p>
</dd>
<dt>a summary statistic:</dt><dd><p>An object of class <code>"fv"</code> containing
the values of a summary statistic, computed for a point pattern
dataset. The summary statistic should be the pair correlation function,
and this object should have been obtained by a call to
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code> or one of its relatives.
</p>
</dd>
</dl>

<p>The algorithm fits the Neyman-Scott Cluster point process
with Variance Gamma kernel to <code>X</code>,
by finding the parameters of the model
which give the closest match between the
theoretical pair correlation function of the model
and the observed pair correlation function.
For a more detailed explanation of the Method of Minimum Contrast,
see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The Neyman-Scott cluster point process with Variance Gamma
kernel is described in Jalilian et al (2013).
It is a cluster process formed by taking a 
pattern of parent points, generated according to a Poisson process
with intensity <code class="reqn">\kappa</code>, and around each parent point,
generating a random number of offspring points, such that the
number of offspring of each parent is a Poisson random variable with mean
<code class="reqn">\mu</code>, and the locations of the offspring points of one parent
have a common distribution described in Jalilian et al (2013).
</p>
<p>The shape of the kernel is determined by the dimensionless
index <code>nu</code>. This is the parameter
<code class="reqn">\nu^\prime = \alpha/2-1</code> appearing in
equation (12) on page 126 of Jalilian et al (2013).
In previous versions of spatstat instead of specifying <code>nu</code>
(called <code>nu.ker</code> at that time) the user could specify
<code>nu.pcf</code> which is the parameter <code class="reqn">\nu=\alpha-1</code>
appearing in equation (13), page 127 of Jalilian et al (2013).
These are related by <code>nu.pcf = 2 * nu.ker + 1</code>
and <code>nu.ker = (nu.pcf - 1)/2</code>. This syntax is still supported but
not recommended for consistency across the package. In that case
exactly one of <code>nu.ker</code> or <code>nu.pcf</code> must be specified.
</p>
<p>If the argument <code>lambda</code> is provided, then this is used
as the value of the point process intensity <code class="reqn">\lambda</code>.
Otherwise, if <code>X</code> is a
point pattern, then  <code class="reqn">\lambda</code>
will be estimated from <code>X</code>. 
If <code>X</code> is a summary statistic and <code>lambda</code> is missing,
then the intensity <code class="reqn">\lambda</code> cannot be estimated, and
the parameter <code class="reqn">\mu</code> will be returned as <code>NA</code>.
</p>
<p>The remaining arguments <code>rmin,rmax,q,p</code> control the
method of minimum contrast; see <code><a href="#topic+mincontrast">mincontrast</a></code>.
</p>
<p>The corresponding model can be simulated using <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>.
</p>
<p>The parameter <code>eta</code> appearing in <code>startpar</code> is equivalent to the
scale parameter <code>omega</code> used in  <code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code>.
</p>
<p>Homogeneous or inhomogeneous Neyman-Scott/VarGamma models can also be
fitted using the function <code><a href="#topic+kppm">kppm</a></code> and the fitted models
can be simulated using <code><a href="#topic+simulate.kppm">simulate.kppm</a></code>.
</p>
<p>The optimisation algorithm can be controlled through the
additional arguments <code>"..."</code> which are passed to the
optimisation function <code><a href="stats.html#topic+optim">optim</a></code>. For example,
to constrain the parameter values to a certain range,
use the argument <code>method="L-BFGS-B"</code> to select an optimisation
algorithm that respects box constraints, and use the arguments
<code>lower</code> and <code>upper</code> to specify (vectors of) minimum and
maximum values for each parameter.
</p>


<h3>Value</h3>

<p>An object of class <code>"minconfit"</code>. There are methods for printing
and plotting this object. It contains the following main components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Vector of fitted parameter values.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Function value table (object of class <code>"fv"</code>)
containing the observed values of the summary statistic
(<code>observed</code>) and the theoretical values of the summary
statistic computed from the fitted model parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Adapted for <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Jalilian, A., Guan, Y. and Waagepetersen, R. (2013)
Decomposition of variance for spatial Cox processes.
<em>Scandinavian Journal of Statistics</em> <b>40</b>, 119-137.
</p>
<p>Waagepetersen, R. (2007)
An estimating function approach to inference for
inhomogeneous Neyman-Scott processes.
<em>Biometrics</em> <b>63</b>, 252&ndash;258.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>,
<code><a href="#topic+vargamma.estK">vargamma.estK</a></code>,
<code><a href="#topic+lgcp.estpcf">lgcp.estpcf</a></code>,
<code><a href="#topic+thomas.estpcf">thomas.estpcf</a></code>,
<code><a href="#topic+cauchy.estpcf">cauchy.estpcf</a></code>,
<code><a href="#topic+mincontrast">mincontrast</a></code>,
<code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>,
<code><a href="#topic+pcfmodel">pcfmodel</a></code>.
</p>
<p><code><a href="spatstat.random.html#topic+rVarGamma">rVarGamma</a></code> to simulate the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    u &lt;- vargamma.estpcf(redwood)
    u
    plot(u, legendpos="topright")
</code></pre>

<hr>
<h2 id='vcov.kppm'>Variance-Covariance Matrix for a Fitted Cluster Point Process Model</h2><span id='topic+vcov.kppm'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the estimates of the
parameters of a fitted cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'kppm'
vcov(object, ...,
          what=c("vcov", "corr", "fisher"),
          fast = NULL, rmax = NULL, eps.rmax = 0.01,
          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.kppm_+3A_object">object</code></td>
<td>

<p>A fitted cluster point process model (an object of class
<code>"kppm"</code>.)
</p>
</td></tr>
<tr><td><code id="vcov.kppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="vcov.kppm_+3A_what">what</code></td>
<td>

<p>Character string (partially-matched)
that specifies what matrix is returned.
Options are <code>"vcov"</code> for the variance-covariance matrix,
<code>"corr"</code> for the correlation matrix, and
<code>"fisher"</code> for the Fisher information matrix.
</p>
</td></tr>
<tr><td><code id="vcov.kppm_+3A_fast">fast</code></td>
<td>

<p>Logical specifying whether tapering (using sparse matrices from
<span class="pkg">Matrix</span>) should be used to speed up calculations. Warning: This
is expected to underestimate the true asymptotic
variances/covariances.
</p>
</td></tr>  
<tr><td><code id="vcov.kppm_+3A_rmax">rmax</code></td>
<td>

<p>Optional. The dependence range. Not usually specified by the
user. Only used when <code>fast=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="vcov.kppm_+3A_eps.rmax">eps.rmax</code></td>
<td>

<p>Numeric. A small positive number which is used to determine <code>rmax</code>
from the tail behaviour of the pair correlation function when fast
option (<code>fast=TRUE</code>) is used. Namely
<code>rmax</code> is the smallest value of <code class="reqn">r</code>
at which <code class="reqn">(g(r)-1)/(g(0)-1)</code>
falls below <code>eps.rmax</code>.
Only used when <code>fast=TRUE</code>.
Ignored if <code>rmax</code> is provided.
</p>
</td></tr>
<tr><td><code id="vcov.kppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports
during very long calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the asymptotic variance-covariance
matrix of the estimates of the canonical (regression) parameters in the
cluster point process model <code>object</code>. It is a method for the 
generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p>The result is an <code>n * n</code> matrix where <code>n =
    length(coef(model))</code>.
</p>
<p>To calculate a confidence interval for a regression parameter,
use <code><a href="stats.html#topic+confint">confint</a></code> as shown in the examples.
</p>


<h3>Value</h3>

<p>A square matrix. 
</p>


<h3>Author(s)</h3>

<p>Abdollah Jalilian and Rasmus Waagepetersen.
Ported to <span class="pkg">spatstat</span> by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Waagepetersen, R. (2007)
Estimating functions for inhomogeneous spatial point processes
with incomplete covariate data.
<em>Biometrika</em> <b>95</b>, 351&ndash;363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kppm">kppm</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, 
<code><a href="#topic+vcov.ppm">vcov.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- kppm(redwood ~ x + y)
   vcov(fit)
   vcov(fit, what="corr")

   # confidence interval
   confint(fit)
   # cross-check the confidence interval by hand:
   sd &lt;- sqrt(diag(vcov(fit)))
   t(coef(fit) + 1.96 * outer(sd, c(lower=-1, upper=1)))
</code></pre>

<hr>
<h2 id='vcov.mppm'>Calculate Variance-Covariance Matrix for Fitted Multiple Point
Process Model</h2><span id='topic+vcov.mppm'></span>

<h3>Description</h3>

<p>Given a fitted multiple point process model, calculate the
variance-covariance matrix of the parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mppm'
vcov(object, ..., what="vcov", err="fatal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mppm_+3A_object">object</code></td>
<td>

<p>A multiple point process model (object of class <code>"mppm"</code>).
</p>
</td></tr>
<tr><td><code id="vcov.mppm_+3A_...">...</code></td>
<td>

<p>Arguments recognised by <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="vcov.mppm_+3A_what">what</code></td>
<td>

<p>Character string indicating which quantity should be calculated.
Options include <code>"vcov"</code> for the variance-covariance matrix,
<code>"corr"</code> for the correlation matrix, and <code>"fisher"</code>
for the Fisher information matrix.
</p>
</td></tr>
<tr><td><code id="vcov.mppm_+3A_err">err</code></td>
<td>

<p>Character string indicating what action to take if an error occurs.
Either <code>"fatal"</code>, <code>"warn"</code> or <code>"null"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p>The argument <code>object</code> should be a fitted multiple point process
model (object of class <code>"mppm"</code>) generated by <code><a href="#topic+mppm">mppm</a></code>.
</p>
<p>The variance-covariance matrix of the parameter estimates
is computed using asymptotic theory for maximum likelihood
(for Poisson processes) or estimating equations (for other Gibbs models).
</p>
<p>If <code>what="vcov"</code> (the default), the variance-covariance matrix
is returned. 
If <code>what="corr"</code>, the variance-covariance matrix is normalised
to yield a correlation matrix, and this is returned.
If <code>what="fisher"</code>, the Fisher information matrix is returned instead.
</p>
<p>In all three cases, the rows and columns of the matrix correspond
to the parameters (coefficients) in the same order as in
<code>coef{model}</code>.
</p>
<p>If errors or numerical problems occur, the
argument <code>err</code> determines what will happen. If
<code>err="fatal"</code> an error will occur. If <code>err="warn"</code>
a warning will be issued and <code>NA</code> will be returned.
If <code>err="null"</code>, no warning is issued, but <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>A numeric matrix (or <code>NA</code> or <code>NULL</code>).
</p>


<h3>Error messages</h3>

<p>An error message that reports
<em>system is computationally singular</em> indicates that the
determinant of the Fisher information matrix of one of the models
was either too large or too small for reliable numerical calculation.
See <code><a href="#topic+vcov.ppm">vcov.ppm</a></code> for suggestions on how to handle this.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Ida-Maria Sintorn and Leanne Bischoff.
Implemented by 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="#topic+vcov.ppm">vcov.ppm</a></code>,
<code><a href="#topic+mppm">mppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- mppm(Wat ~x, data=hyperframe(Wat=waterstriders))
   vcov(fit)
</code></pre>

<hr>
<h2 id='vcov.ppm'>Variance-Covariance Matrix for a Fitted Point Process Model</h2><span id='topic+vcov.ppm'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the estimates of the
parameters of a fitted point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ppm'
vcov(object, ...,
                    what = c("vcov", "corr", "fisher"),
                    verbose = TRUE,
                    fine=FALSE,
                    gam.action=c("warn", "fatal", "silent"),
                    matrix.action=c("warn", "fatal", "silent"),
                    logi.action=c("warn", "fatal", "silent"),
                    nacoef.action=c("warn", "fatal", "silent"),
                    hessian=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.ppm_+3A_object">object</code></td>
<td>
<p>A fitted point process model (an object of class <code>"ppm"</code>.)</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_what">what</code></td>
<td>
<p>Character string (partially-matched)
that specifies what matrix is returned.
Options are <code>"vcov"</code> for the variance-covariance matrix,
<code>"corr"</code> for the correlation matrix, and
<code>"fisher"</code> or <code>"Fisher"</code>
for the Fisher information matrix.
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_fine">fine</code></td>
<td>

<p>Logical value indicating whether to use a quick estimate
(<code>fine=FALSE</code>, the default) or a slower, more accurate
estimate (<code>fine=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a message will be printed
if various minor problems are encountered.
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_gam.action">gam.action</code></td>
<td>
<p>String indicating what to do if <code>object</code> was
fitted by <code>gam</code>. 
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_matrix.action">matrix.action</code></td>
<td>
<p>String indicating what to do if the matrix
is ill-conditioned (so that its inverse cannot be calculated).
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_logi.action">logi.action</code></td>
<td>
<p>String indicating what to do if <code>object</code> was
fitted via the logistic regression approximation using a
non-standard dummy point process.
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_nacoef.action">nacoef.action</code></td>
<td>

<p>String indicating what to do if some of the fitted coefficients
are <code>NA</code> (so that variance cannot be calculated).
</p>
</td></tr>
<tr><td><code id="vcov.ppm_+3A_hessian">hessian</code></td>
<td>

<p>Logical. Use the negative Hessian matrix
of the log pseudolikelihood instead of the Fisher information.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the asymptotic variance-covariance
matrix of the estimates of the canonical parameters in the
point process model <code>object</code>. It is a method for the 
generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code>object</code> should be an object of class <code>"ppm"</code>, typically
produced by <code><a href="#topic+ppm">ppm</a></code>.
</p>
<p>The canonical parameters of the fitted model <code>object</code>
are the quantities returned by <code>coef.ppm(object)</code>.
The function <code>vcov</code> calculates the variance-covariance matrix
for these parameters.
</p>
<p>The argument <code>what</code> provides three options:
</p>

<dl>
<dt><code>what="vcov"</code></dt><dd>
<p>return the variance-covariance matrix of the parameter estimates
</p>
</dd>
<dt><code>what="corr"</code></dt><dd>
<p>return the correlation matrix of the parameter estimates
</p>
</dd>
<dt><code>what="fisher"</code></dt><dd>
<p>return the observed Fisher information matrix.
</p>
</dd>
</dl>

<p>In all three cases, the result is a square matrix.
The rows and columns of the matrix correspond to the canonical
parameters given by <code><a href="#topic+coef.ppm">coef.ppm</a>(object)</code>. The row and column
names of the matrix are also identical to the names in
<code><a href="#topic+coef.ppm">coef.ppm</a>(object)</code>.
</p>
<p>For models fitted by the Berman-Turner approximation (Berman and Turner, 1992;
Baddeley and Turner, 2000) to the maximum pseudolikelihood (using the
default <code>method="mpl"</code> in the call to <code><a href="#topic+ppm">ppm</a></code>), the implementation works
as follows.
</p>

<ul>
<li>
<p>If the fitted model <code>object</code> is a Poisson process,
the calculations are based on standard asymptotic theory for the maximum
likelihood estimator (Kutoyants, 1998).
The observed Fisher information matrix of the fitted model
<code>object</code> is first computed, by
summing over the Berman-Turner quadrature points in the fitted model.
The asymptotic variance-covariance matrix is calculated as the
inverse of the
observed Fisher information. The correlation matrix is then obtained
by normalising.
</p>
</li>
<li>
<p>If the fitted model is not a Poisson process (i.e. it is some other
Gibbs point process) then the calculations are based on
Coeurjolly and Rubak (2012). A consistent estimator of the
variance-covariance matrix is computed by summing terms over all
pairs of data points. If required, the Fisher information is
calculated as the inverse of the variance-covariance matrix.
</p>
</li></ul>

<p>For models fitted by the Huang-Ogata method (<code>method="ho"</code> in
the call to <code><a href="#topic+ppm">ppm</a></code>), the implementation uses the 
Monte Carlo estimate of the Fisher information matrix that was
computed when the original model was fitted. 
</p>
<p>For models fitted by the logistic regression approximation to the
maximum pseudolikelihood (<code>method="logi"</code> in the call to
<code><a href="#topic+ppm">ppm</a></code>),
</p>

<ul>
<li><p> Calculations are based on Baddeley <em>et al.</em> (2013).
A consistent estimator of the variance-covariance matrix is
computed by summing terms over all pairs of data points.
If required, the Fisher information is calculated as the inverse of the
variance-covariance matrix.
</p>
</li>
<li><p> The calculations depend on
the type of dummy pattern used when the model was fitted:
</p>

<ul>
<li><p> currently only the dummy types
<code>"stratrand"</code> (the default), <code>"binomial"</code> and <code>"poisson"</code> as
generated by <code><a href="spatstat.geom.html#topic+quadscheme.logi">quadscheme.logi</a></code> are supported.
</p>
</li>
<li><p> For other dummy types the behavior depends on the argument
<code>logi.action</code>. If <code>logi.action="fatal"</code> an error is
produced. Otherwise, for dummy types
<code>"grid"</code> and <code>"transgrid"</code> the formulas for
<code>"stratrand"</code> are used which in many cases should be
conservative. For an arbitrary, user-specified dummy pattern (type
<code>"given"</code>), the formulas for <code>"poisson"</code> are used which in
many cases should be conservative. If <code>logi.action="warn"</code> a
warning is issued, otherwise the calculation proceeds without a
warning.
</p>
</li></ul>

</li>
<li><p> The result of the calculation is <b>random</b> (i.e. not
deterministic) when dummy type is <code>"stratrand"</code> (the default)
because some of the variance terms are estimated by random sampling.
This can be avoided by specifying
<code>dummytype='poisson'</code> or <code>dummytype='binomial'</code> in the 
call to <code><a href="#topic+ppm">ppm</a></code> when the model is fitted.
</p>
</li></ul>

<p>The argument <code>verbose</code> makes it possible to suppress some
diagnostic messages.
</p>
<p>The asymptotic theory is not correct if the model was fitted using
<code>gam</code> (by calling <code><a href="#topic+ppm">ppm</a></code> with <code>use.gam=TRUE</code>).
The argument <code>gam.action</code> determines what to do in this case.
If <code>gam.action="fatal"</code>, an error is generated.
If <code>gam.action="warn"</code>, a warning is issued and the calculation
proceeds using the incorrect theory for the parametric case, which is
probably a reasonable approximation in many applications.
If <code>gam.action="silent"</code>, the calculation proceeds without a
warning.
</p>
<p>If <code>hessian=TRUE</code> then the negative Hessian (second derivative)
matrix of the log pseudolikelihood, and its inverse, will be computed.
For non-Poisson models, this is not a valid estimate of variance,
but is useful for other calculations.
</p>
<p>Note that standard errors and 95% confidence intervals for
the coefficients can also be obtained using
<code>confint(object)</code> or <code>coef(summary(object))</code>.
</p>


<h3>Value</h3>

<p>A square matrix.
</p>


<h3>Error messages</h3>

<p>An error message that reports
<em>system is computationally singular</em> indicates that the
determinant of the Fisher information matrix was either too large 
or too small for reliable numerical calculation.
</p>
<p>If this message occurs, try repeating the calculation
using <code>fine=TRUE</code>. 
</p>
<p>Singularity can occur because of numerical overflow or
collinearity in the covariates. To check this, rescale the 
coordinates of the data points and refit the model. See the Examples.
</p>
<p>In a Gibbs model, a singular matrix may also occur if the
fitted model is a hard core process: this is a feature of the
variance estimator. 
</p>


<h3>Author(s)</h3>

<p>Original code for Poisson point process was written by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
New code for stationary Gibbs point processes was generously contributed by
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Jean-Francois Coeurjolly.
New code for generic Gibbs process written by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
New code for logistic method written by Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Coeurjolly, J.-F., Rubak, E. and Waagepetersen, R. (2014)
Logistic regression for spatial Gibbs point processes.
<em>Biometrika</em> <b>101</b> (2) 377&ndash;392.
</p>
<p>Coeurjolly, J.-F. and Rubak, E. (2013)
Fast covariance estimation for innovations
computed from a spatial Gibbs point process.
Scandinavian Journal of Statistics <b>40</b> 669&ndash;684.
</p>
<p>Kutoyants, Y.A. (1998) 
<b>Statistical Inference for Spatial Poisson Processes</b>,
Lecture Notes in Statistics 134. 
New York: Springer 1998. 
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code> for the generic,
</p>
<p><code><a href="#topic+ppm">ppm</a></code> for information about fitted models,
</p>
<p><code><a href="stats.html#topic+confint">confint</a></code> for confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- ppm(X ~ x + y)
  vcov(fit)
  vcov(fit, what="Fish")

  # example of singular system
  m &lt;- ppm(demopat ~polynom(x,y,2))
  
    try(v &lt;- vcov(m))
  
  # rescale x, y coordinates to range [0,1] x [0,1] approximately
  demopatScale &lt;- rescale(demopat, 10000)
  m &lt;- ppm(demopatScale ~ polynom(x,y,2))
  v &lt;- vcov(m)

  # Gibbs example
  fitS &lt;- ppm(swedishpines ~1, Strauss(9))
  coef(fitS)
  sqrt(diag(vcov(fitS)))
</code></pre>

<hr>
<h2 id='vcov.slrm'>Variance-Covariance Matrix for a Fitted Spatial Logistic Regression</h2><span id='topic+vcov.slrm'></span>

<h3>Description</h3>

<p>Returns the variance-covariance matrix of the estimates of the
parameters of a point process model that was fitted by
spatial logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'slrm'
vcov(object, ...,
         what=c("vcov", "corr", "fisher", "Fisher")) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.slrm_+3A_object">object</code></td>
<td>
<p>A fitted point process model of class <code>"slrm"</code>.</p>
</td></tr>
<tr><td><code id="vcov.slrm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="vcov.slrm_+3A_what">what</code></td>
<td>
<p>Character string (partially-matched)
that specifies what matrix is returned.
Options are <code>"vcov"</code> for the variance-covariance matrix,
<code>"corr"</code> for the correlation matrix, and
<code>"fisher"</code> or <code>"Fisher"</code> for the Fisher information matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the asymptotic variance-covariance
matrix of the estimates of the canonical parameters in the
point process model <code>object</code>. It is a method for the 
generic function <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code>object</code> should be an object of class <code>"slrm"</code>, typically
produced by <code><a href="#topic+slrm">slrm</a></code>. It represents a Poisson point process
model fitted by spatial logistic regression.
</p>
<p>The canonical parameters of the fitted model <code>object</code>
are the quantities returned by <code>coef.slrm(object)</code>.
The function <code>vcov</code> calculates the variance-covariance matrix
for these parameters.
</p>
<p>The argument <code>what</code> provides three options:
</p>

<dl>
<dt><code>what="vcov"</code></dt><dd>
<p>return the variance-covariance matrix of the parameter estimates
</p>
</dd>
<dt><code>what="corr"</code></dt><dd>
<p>return the correlation matrix of the parameter estimates
</p>
</dd>
<dt><code>what="fisher"</code></dt><dd>
<p>return the observed Fisher information matrix.
</p>
</dd>
</dl>

<p>In all three cases, the result is a square matrix.
The rows and columns of the matrix correspond to the canonical
parameters given by <code><a href="#topic+coef.slrm">coef.slrm</a>(object)</code>. The row and column
names of the matrix are also identical to the names in
<code><a href="#topic+coef.slrm">coef.slrm</a>(object)</code>.
</p>
<p>Note that standard errors and 95% confidence intervals for
the coefficients can also be obtained using
<code>confint(object)</code> or <code>coef(summary(object))</code>.
</p>
<p>Standard errors for the fitted intensity can be obtained
using <code><a href="#topic+predict.slrm">predict.slrm</a></code>.
</p>


<h3>Value</h3>

<p>A square matrix.
</p>


<h3>Error messages</h3>

<p>An error message that reports
<em>system is computationally singular</em> indicates that the
determinant of the Fisher information matrix was either too large 
or too small for reliable numerical calculation.
This can occur because of numerical overflow or
collinearity in the covariates. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> .
</p>


<h3>References</h3>

<p>Baddeley, A., Berman, M., Fisher, N.I., Hardegen, A., Milne, R.K.,
Schuhmacher, D., Shah, R. and Turner, R. (2010)
Spatial logistic regression and change-of-support
for spatial Poisson point processes.
<em>Electronic Journal of Statistics</em>
<b>4</b>, 1151&ndash;1201.
<code>DOI: 10.1214/10-EJS581</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code> for the generic,
</p>
<p><code><a href="#topic+slrm">slrm</a></code> for information about fitted models,
</p>
<p><code><a href="#topic+predict.slrm">predict.slrm</a></code> for other kinds of calculation about the model,
</p>
<p><code><a href="stats.html#topic+confint">confint</a></code> for confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoispp(42)
  fit &lt;- slrm(X ~ x + y)
  vcov(fit)
  vcov(fit, what="corr")
  vcov(fit, what="f")
</code></pre>

<hr>
<h2 id='Window.ppm'>Extract Window of Spatial Object</h2><span id='topic+Window.ppm'></span><span id='topic+Window.kppm'></span><span id='topic+Window.dppm'></span><span id='topic+Window.slrm'></span><span id='topic+Window.msr'></span>

<h3>Description</h3>

<p>Given a spatial object (such as a point pattern or pixel image)
in two dimensions, these functions extract the window
in which the object is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ppm'
Window(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'kppm'
Window(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'dppm'
Window(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'slrm'
Window(X, ..., from=c("points", "covariates"))

 ## S3 method for class 'msr'
Window(X, ...)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window.ppm_+3A_x">X</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
<tr><td><code id="Window.ppm_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Window.ppm_+3A_from">from</code></td>
<td>
<p>Character string. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code><a href="spatstat.geom.html#topic+Window">Window</a></code>
which extract the spatial window in which the object <code>X</code>
is defined. 
The argument <code>from</code> applies when <code>X</code> is a fitted 
two-dimensional point process model
(object of class <code>"ppm"</code>, <code>"kppm"</code>, <code>"slrm"</code> or <code>"dppm"</code>).
If <code>from="data"</code> (the default),
<code>Window</code> extracts the window of the original point
pattern data to which the model was fitted.
If <code>from="covariates"</code> then <code>Window</code> returns the
window in which the spatial covariates of the model were provided.
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code> (see <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+Window">Window</a></code>,
<code><a href="spatstat.geom.html#topic+Window.ppp">Window.ppp</a></code>,
<code><a href="spatstat.geom.html#topic+Window.psp">Window.psp</a></code>.
</p>
<p><code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- ppm(cells ~ 1)
   Window(A)
</code></pre>

<hr>
<h2 id='with.msr'>Evaluate Expression Involving Components of a Measure</h2><span id='topic+with.msr'></span>

<h3>Description</h3>

<p>An expression involving the names of components of a measure
is evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msr'
with(data, expr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.msr_+3A_data">data</code></td>
<td>

<p>A measure (object of class <code>"msr"</code>).
</p>
</td></tr>
<tr><td><code id="with.msr_+3A_expr">expr</code></td>
<td>

<p>An expression to be evaluated.
</p>
</td></tr>
<tr><td><code id="with.msr_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="base.html#topic+with">with</a></code> for the class <code>"msr"</code>.
The argument <code>data</code> should be an object of class <code>"msr"</code>
representing a measure (a function which assigns a value to each
subset of two-dimensional space).
</p>
<p>This function can be used to extract the components of the measure,
or to perform more complicated manipulations of the components.
</p>
<p>The argument <code>expr</code> should be an un-evaluated expression
in the <span class="rlang"><b>R</b></span> language. The expression may involve any of the variable
names listed below with their corresponding meanings. 
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>qlocations</code> </td><td style="text-align: left;"> (point pattern) all quadrature locations  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qweights</code> </td><td style="text-align: left;"> (numeric) all quadrature weights  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>density</code> </td><td style="text-align: left;"> (numeric) density value at each quadrature point  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>discrete</code> </td><td style="text-align: left;"> (numeric) discrete mass at each quadrature point  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>continuous</code> </td><td style="text-align: left;"> (numeric) increment of continuous component  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>increment</code> </td><td style="text-align: left;"> (numeric) increment of measure  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>is.atom</code> </td><td style="text-align: left;"> (logical) whether quadrature point is an atom  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>atoms</code> </td><td style="text-align: left;"> (point pattern) locations of atoms  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>atommass</code> </td><td style="text-align: left;"> (numeric) massess of atoms
  </td>
</tr>

</table>

<p>The measure is the sum of discrete and continuous components.
The discrete component assigns non-zero mass to several points called atoms.
The continuous component has a density which should be integrated
over a region to determine the value for that region.
</p>
<p>An object of class <code>"msr"</code> approximates the continuous component
by a sum over quadrature points. The quadrature points are chosen
so that they include the atoms of the measure. In the list above,
we have <code>increment = continuous + discrete</code>,
<code>continuous = density * qweights</code>,
<code>is.atom = (discrete &gt; 0)</code>,
<code>atoms = qlocations[is.atom]</code> and
<code>atommass = discrete[is.atom]</code>.
</p>


<h3>Value</h3>

<p>The result of evaluating the expression could be
an object of any kind.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msr">msr</a></code>,
<code><a href="#topic+split.msr">split.msr</a></code>,
<code><a href="#topic+measureContinuous">measureContinuous</a></code>, <code><a href="#topic+measurePositive">measurePositive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoispp(function(x,y) { exp(3+3*x) })
   fit &lt;- ppm(X, ~x+y)
   rp &lt;- residuals(fit, type="pearson")

   with(rp, atoms)
   with(rp, qlocations %mark% continuous)
</code></pre>

<hr>
<h2 id='zclustermodel'>
Cluster Point Process Model
</h2><span id='topic+zclustermodel'></span>

<h3>Description</h3>

<p>Experimental code. Creates an object representing a cluster point
process model. Typically used for theoretical calculations about
such a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zclustermodel(name = "Thomas", ..., mu, kappa, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zclustermodel_+3A_name">name</code></td>
<td>

<p>Name of the cluster process. One of
<code>"Thomas"</code>,
<code>"MatClust"</code>,
<code>"VarGamma"</code> or
<code>"Cauchy"</code>.
</p>
</td></tr>
<tr><td><code id="zclustermodel_+3A_...">...</code></td>
<td>

<p>Other arguments needed for the model.
</p>
</td></tr>
<tr><td><code id="zclustermodel_+3A_mu">mu</code></td>
<td>

<p>Mean cluster size. A single number, or a pixel image.
</p>
</td></tr>
<tr><td><code id="zclustermodel_+3A_kappa">kappa</code></td>
<td>

<p>Parent intensity. A single number.
</p>
</td></tr>
<tr><td><code id="zclustermodel_+3A_scale">scale</code></td>
<td>

<p>Cluster scale parameter of the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental.
</p>


<h3>Value</h3>

<p>Object of the experimental class <code>"zclustermodel"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.zclustermodel">methods.zclustermodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- zclustermodel("Thomas", kappa=10, mu=5, scale=0.1)
</code></pre>

<hr>
<h2 id='zgibbsmodel'>
Gibbs Model 
</h2><span id='topic+zgibbsmodel'></span>

<h3>Description</h3>

<p>Experimental code. Creates an object representing a Gibbs point
process model. Typically used for theoretical calculations about
such a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zgibbsmodel(beta = 1, interaction = NULL, icoef = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zgibbsmodel_+3A_beta">beta</code></td>
<td>

<p>First order trend term. A numeric value, numeric vector,
pixel image, function, or a list of such objects.
</p>
</td></tr>
<tr><td><code id="zgibbsmodel_+3A_interaction">interaction</code></td>
<td>

<p>Object of class <code>"interact"</code> specifying the interpoint
interaction structure, or <code>NULL</code> representing the Poisson process.
</p>
</td></tr>
<tr><td><code id="zgibbsmodel_+3A_icoef">icoef</code></td>
<td>

<p>Numeric vector of coefficients for the interpoint interaction.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental.
</p>


<h3>Value</h3>

<p>Object belonging to the experimental class <code>zgibbsmodel</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.zgibbsmodel">methods.zgibbsmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  m &lt;- zgibbsmodel(10, Strauss(0.1), -0.5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
