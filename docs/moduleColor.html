<!DOCTYPE html><html><head><title>Help for package moduleColor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {moduleColor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#moduleColor-package'>
<p>Basic Module Functions</p></a></li>
<li><a href='#checkSets'><p>Check structure and retrieve sizes of a group of datasets.</p></a></li>
<li><a href='#collectGarbage'><p>Iterative garbage collection.</p></a></li>
<li><a href='#consensusMEDissimilarity'><p> Consensus dissimilarity of module eigengenes.</p></a></li>
<li><a href='#consensusOrderMEs'><p> Put close eigenvectors next to each other in several sets.</p></a></li>
<li><a href='#fixDataStructure'><p>Put single-set data into a form useful for multiset calculations.</p></a></li>
<li><a href='#labels2colors'><p>Convert numerical labels to colors.</p></a></li>
<li><a href='#mergeCloseModules'><p>Merge close modules of gene expression data.</p></a></li>
<li><a href='#moduleColor.getMEprefix'><p>Get the prefix used to label module eigengenes.</p></a></li>
<li><a href='#moduleColor.revisionDate'><p>Get the last revision date of the package.</p></a></li>
<li><a href='#moduleColor.setMEprefix'><p>Set the prefix used to label module eigengenes.</p></a></li>
<li><a href='#moduleColor.version'><p>Get the version number of the package.</p></a></li>
<li><a href='#moduleEigengenes'><p>Calculate module eigengenes.</p></a></li>
<li><a href='#moduleNumber'><p>Fixed-height cut of a dendrogram.</p></a></li>
<li><a href='#multiSetMEs'><p>Calculate module eigengenes.</p></a></li>
<li><a href='#normalizeLabels'><p>Transform numerical labels into normal order.</p></a></li>
<li><a href='#orderMEs'><p>Put close eigenvectors next to each other</p></a></li>
<li><a href='#plotHclustColors'><p>Plot color rows corresponding to modules</p></a></li>
<li><a href='#removeGreyME'><p>Removes the grey eigengene from a given collection of eigengenes.</p></a></li>
<li><a href='#standardColors'><p>Colors this library uses for labeling modules.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Module Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Langfelder &lt;Peter.Langfelder@gmail.com&gt; and Steve Horvath &lt;SHorvath@mednet.ucla.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Langfelder &lt;Peter.Langfelder@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.3.0), stats, impute, grDevices, dynamicTreeCut</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for color labeling, calculation of eigengenes, merging of closely related modules.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/BranchCutting/">https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/BranchCutting/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-08 03:44:20 UTC; plangfelder</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-09 16:02:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='moduleColor-package'>
Basic Module Functions
</h2><span id='topic+moduleColor-package'></span><span id='topic+moduleColor'></span>

<h3>Description</h3>

<p>Methods for color labeling, calculation of eigengenes,
merging of closely related modules.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> moduleColor</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.08-3  </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-11-25</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R, stats, impute, grDevices, dynamicTreeCut</td>
</tr>
<tr>
 <td style="text-align: left;">
ZipData: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 2 or newer</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> 
http://www.genetics.ucla.edu/labs/horvath/CoexpressionNetwork/BranchCutting/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index:
</p>
<pre>
checkSets               Retrieve basic sizes of a group of datasets.
collectGarbage          Iterative garbage collection.
consensusMEDissimilarity
                        Consensus dissimilarity of module eigengenes.
consensusOrderMEs       Put close eigenvectors next to each other in
                        several sets.
fixDataStructure        Put single-set data into a form useful for
                        multiset calculations.
labels2colors           Convert numerical labels to colors.
mergeCloseModules       Merge close modules of gene expression data.
moduleColor-package     Basic module functions.
moduleColor.getMEprefix	Get the prefix used to label module eigengenes.
moduleColor.version	Returns the version number of the package.
moduleColor.revisionDate
			Returns the revision date of the package.
moduleEigengenes        Calculate module eigengenes.
moduleNumber            Fixed-height cut of a dendrogram.
multiSetMEs             Calculate module eigengenes.
normalizeLabels         Transform numerical labels into normal order.
orderMEs                Put close eigenvectors next to each other
plotHclustColors        Plot color bars corresponding to modules
removeGreyME		Remove the grey module eigengene from given eigengenes.
standardColors          Colors this library uses for labeling modules.
</pre>


<h3>Author(s)</h3>

<p>Peter Langfelder &lt;Peter.Langfelder@gmail.com&gt; and Steve Horvath
&lt;SHorvath@mednet.ucla.edu&gt;
</p>
<p>Maintainer: Peter Langfelder &lt;Peter.Langfelder@gmail.com&gt;
</p>

<hr>
<h2 id='checkSets'>Check structure and retrieve sizes of a group of datasets.  </h2><span id='topic+checkSets'></span>

<h3>Description</h3>

<p>Checks whether given sets have the correct format and retrieves dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSets(data, checkStructure = FALSE, useSets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkSets_+3A_data">data</code></td>
<td>
<p> A vector of lists; in each list there must be a component named <code>data</code> whose content
is a matrix or dataframe or array of dimension 2. </p>
</td></tr>
<tr><td><code id="checkSets_+3A_checkstructure">checkStructure</code></td>
<td>
<p>If <code>FALSE</code>, incorrect structure of <code>data</code> will trigger an error. If
<code>TRUE</code>, an appropriate flag (see output) will be set to indicate whether <code>data</code> has correct
structure.</p>
</td></tr>
<tr><td><code id="checkSets_+3A_usesets">useSets</code></td>
<td>
<p>Optional specification of entries of the vector <code>data</code> that are to be checked.
Defaults to all components. This may be useful when <code>data</code> only contains information for some
of the sets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multiset calculations, many quantities (such as expression data, traits, module eigengenes etc) are
presented by a common structure, a vector of lists (one list for each set) where each list has a
component <code>data</code> that contains the actual (expression, trait, eigengene) data for the corresponding
set in the form of a dataframe. This funtion checks whether <code>data</code> conforms to this convention and
retrieves some basic dimension information (see output).
</p>


<h3>Value</h3>

<p> A list with components
</p>
<table>
<tr><td><code>nSets</code></td>
<td>
<p>Number of sets (length of the vector <code>data</code>).</p>
</td></tr>
<tr><td><code>nGenes</code></td>
<td>
<p>Number of columns in the <code>data</code> components in the lists. This number must be the
same for all sets.</p>
</td></tr>
<tr><td><code>nSamples</code></td>
<td>
<p>A vector of length <code>nSets</code> giving the number of rows in the <code>data</code>
components.</p>
</td></tr>
<tr><td><code>structureOK</code></td>
<td>
<p>Only set if the argument <code>checkStructure</code> equals <code>TRUE</code>. 
The value is <code>TRUE</code> if the paramter <code>data</code> passes a few tests of its
structure, and <code>FALSE</code> otherwise. The tests are not exhaustive and are meant to catch obvious user
errors rather than be bulletproof.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='collectGarbage'>Iterative garbage collection. </h2><span id='topic+collectGarbage'></span>

<h3>Description</h3>

<p>Performs garbage collection until free memory idicators show no change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collectGarbage()
</code></pre>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p> Steve Horvath </p>

<hr>
<h2 id='consensusMEDissimilarity'> Consensus dissimilarity of module eigengenes. </h2><span id='topic+consensusMEDissimilarity'></span>

<h3>Description</h3>

<p>Calculates consensus dissimilarity <code>(1-cor)</code> of given module eigengenes relaized in several sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensusMEDissimilarity(MEs, useAbs = FALSE, useSets = NULL, method = "consensus")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensusMEDissimilarity_+3A_mes">MEs</code></td>
<td>
<p>Module eigengenes of the same modules in several sets. </p>
</td></tr>
<tr><td><code id="consensusMEDissimilarity_+3A_useabs">useAbs</code></td>
<td>
<p>Controls whether absolute value of correlation should be used instead of correlation in
the calculation of dissimilarity. </p>
</td></tr>
<tr><td><code id="consensusMEDissimilarity_+3A_usesets">useSets</code></td>
<td>
<p>If the consensus is to include only a selection of the given sets, this vector (or
scalar in the case of a single set) can be used to specify the selection. If <code>NULL</code>, all sets will
be used. </p>
</td></tr>
<tr><td><code id="consensusMEDissimilarity_+3A_method">method</code></td>
<td>
<p>A character string giving the method to use. Allowed values are (abbreviations of) 
<code>"consensus"</code> and <code>"majority"</code>. The consensus dissimilarity is calculated as the
minimum of given set dissimilarities for <code>"consensus"</code> and as the average for <code>"majority"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the
individual set dissimilarities of the given eigengenes in each set, then takes the (parallel) maximum or
average over all sets. For details on the structure of imput data, see <code><a href="#topic+checkSets">checkSets</a></code>. 
</p>


<h3>Value</h3>

<p>A dataframe containing the matrix of dissimilarities, with <code>names</code> and <code>rownames</code> set
appropriately.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+checkSets">checkSets</a></code></p>

<hr>
<h2 id='consensusOrderMEs'> Put close eigenvectors next to each other in several sets. </h2><span id='topic+consensusOrderMEs'></span>

<h3>Description</h3>

<p>Reorder given (eigen-)vectors such that similar ones (as measured by correlation) are next to each
other. This is a multi-set version of <code><a href="#topic+orderMEs">orderMEs</a></code>; the dissimilarity used can be of consensus
type (for each pair of eigenvectors the consensus dissimilarity is the maximum of individual set
dissimilarities over all sets) or of majority type (for each pair of eigenvectors the consensus
dissimilarity is the average of individual set dissimilarities over all sets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensusOrderMEs(MEs, useAbs = FALSE, useSets = NULL, 
                  greyLast = TRUE, 
                  greyName = paste(moduleColor.getMEprefix(), "grey", sep=""), 
                  method = "consensus")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensusOrderMEs_+3A_mes">MEs</code></td>
<td>
<p>Module eigengenes of several sets in a multi-set format (see <code><a href="#topic+checkSets">checkSets</a></code>). A
vector of lists, with each list corresponding to one dataset and the module eigengenes in the component
<code>data</code>, that is <code>MEs[[set]]$data[sample, module]</code> is the expression of the eigengene of module
<code>module</code> in sample <code>sample</code> in dataset <code>set</code>. The number of samples can be different
between the sets, but the modules must be the same. </p>
</td></tr> 
<tr><td><code id="consensusOrderMEs_+3A_useabs">useAbs</code></td>
<td>
<p>Controls whether vector similarity should be given by absolute value of correlation or
plain correlation.</p>
</td></tr>
<tr><td><code id="consensusOrderMEs_+3A_usesets">useSets</code></td>
<td>
<p>Allows the user to specify for which sets the eigengene ordering is to be performed.</p>
</td></tr>
<tr><td><code id="consensusOrderMEs_+3A_greylast">greyLast</code></td>
<td>
<p>Normally the color grey is reserved for unassigned genes; hence the grey module is not
a proper module and it is conventional to put it last. If this is not desired, set the parameter to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="consensusOrderMEs_+3A_greyname">greyName</code></td>
<td>
<p>Name of the grey module eigengene.</p>
</td></tr>
<tr><td><code id="consensusOrderMEs_+3A_method">method</code></td>
<td>
<p>A character string giving the method to be used calculating the consensus
dissimilarity. Allowed values are (abbreviations of) 
<code>"consensus"</code> and <code>"majority"</code>. The consensus dissimilarity is calculated as the
maximum of given set dissimilarities for <code>"consensus"</code> and as the average for <code>"majority"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordering module eigengenes is useful for plotting purposes. This function calculates the consensus
or majority
dissimilarity of given eigengenes over the sets specified by <code>useSets</code> (defaults to all sets).
A hierarchical dendrogram is calculated using the dissimilarity and the order given by the dendrogram is
used for the eigengenes in all other sets.
</p>


<h3>Value</h3>

<p>A vector of lists of the same type as <code>MEs</code> containing the re-ordered eigengenes.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code>, <code><a href="#topic+multiSetMEs">multiSetMEs</a></code>, <code><a href="#topic+orderMEs">orderMEs</a></code></p>

<hr>
<h2 id='fixDataStructure'>Put single-set data into a form useful for multiset calculations. </h2><span id='topic+fixDataStructure'></span>

<h3>Description</h3>

<p>Encapsulates single-set data in a wrapper that makes the data suitable for functions working on
multiset data collections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixDataStructure(data, verbose = 0, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixDataStructure_+3A_data">data</code></td>
<td>
<p> A dataframe, matrix or array with two dimensions to be encapsulated. </p>
</td></tr>
<tr><td><code id="fixDataStructure_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity. 0 is silent. </p>
</td></tr>
<tr><td><code id="fixDataStructure_+3A_indent">indent</code></td>
<td>
<p>Controls indentation of printed progress messages. 0 means no indentation, every unit
adds two spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multiset calculations, many quantities (such as expression data, traits, module eigengenes etc) are
presented by a common structure, a vector of lists (one list for each set) where each list has a
component <code>data</code> that contains the actual (expression, trait, eigengene) data for the corresponding
set in the form of a dataframe. This funtion creates a vector of lists of length 1 and fills the
component <code>data</code> with the content of parameter <code>data</code>.
</p>


<h3>Value</h3>

<p>As described above, input data in a format suitable for functions operating on multiset data
collections.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+checkSets">checkSets</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
singleSetData = matrix(rnorm(100), 10,10);
encapsData = fixDataStructure(singleSetData);
length(encapsData)
names(encapsData[[1]])
dim(encapsData[[1]]$data)
all.equal(encapsData[[1]]$data, singleSetData);

</code></pre>

<hr>
<h2 id='labels2colors'>Convert numerical labels to colors. </h2><span id='topic+labels2colors'></span>

<h3>Description</h3>

<p>Converts a vector or array of numerical labels into a corresponding vector or array of colors corresponding to the labels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labels2colors(labels, zeroIsGrey = TRUE, colorSeq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels2colors_+3A_labels">labels</code></td>
<td>
<p>Vector of non-negative integer labels.</p>
</td></tr>
<tr><td><code id="labels2colors_+3A_zeroisgrey">zeroIsGrey</code></td>
<td>
<p>If TRUE, labels 0 will be assigned color grey. Otherwise, labels below 1 will trigger
an error.</p>
</td></tr>
<tr><td><code id="labels2colors_+3A_colorseq">colorSeq</code></td>
<td>
<p>Color sequence corresponding to labels. If not given, a standard sequence will be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard sequence start with well-distinguishable colors, and after about 40 turns into a
quasi-random sampling of all colors available in R with the exception of all shades of grey (and gray).
</p>
<p>If the input <code>labels</code> have a dimension attribute, it is copied into the output, meaning the
dimensions of the returned value are the same as those of the input <code>labels</code>.
</p>


<h3>Value</h3>

<p>A vector or array of character strings of the same length or dimensions as <code>labels</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>labels = c(0:20);
labels2colors(labels);
</code></pre>

<hr>
<h2 id='mergeCloseModules'>Merge close modules of gene expression data.</h2><span id='topic+mergeCloseModules'></span>

<h3>Description</h3>

<p>Merges modules in gene expression networks that are too close as measured by the correlation of their
eigengenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCloseModules(exprData, colors, 
                  cutHeight = 0.2, 
                  MEs = NULL, 
                  impute = TRUE,
                  useAbs = FALSE, 
                  iterate = TRUE, 
                  relabel = FALSE, 
                  colorSeq = NULL, 
                  getNewMEs = TRUE, 
                  getNewUnassdME = TRUE,
                  useSets = NULL,
                  checkDataFormat = TRUE,
                  unassdColor = ifelse(is.numeric(colors), 0, "grey"),
                  trapErrors = FALSE,
                  verbose = 1, indent = 0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCloseModules_+3A_exprdata">exprData</code></td>
<td>
<p>Expression data, either a single data frame with rows corresponding to samples and
columns to genes, or in a multi-set format (see <code><a href="#topic+checkSets">checkSets</a></code>). See
<code>checkDataStructure</code> below.  </p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_colors">colors</code></td>
<td>
<p>A vector (numeric, character or a factor) giving module colors for genes. 
The method only makes sense when genes have the
same color label in all sets, hence a single vector. </p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_cutheight">cutHeight</code></td>
<td>
<p>Maximum dissimilarity (i.e., 1-correlation) that qualifies modules for merging.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_mes">MEs</code></td>
<td>
<p>If module eigengenes have been calculated before, the user can save some computational time
by inputting them. <code>MEs</code> should have the same format as <code>exprData</code>. 
If they are not given, they will be calculated.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_impute">impute</code></td>
<td>
<p>Should missing values be imputed in eigengene calculation? If imputation is disabled, the
presence of <code>NA</code> entries will cause the eigengene calculation to fail and eigengenes will be
replaced by their hubgene approximation. See <code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code> for more details.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_useabs">useAbs</code></td>
<td>
<p>Specifies whether absolute value of correlation or plain correlation (of module
eigengenes) should be used in calculating module dissimilarity.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_iterate">iterate</code></td>
<td>
<p>Controls whether the merging procedure should be repeated until there is no change. If
FALSE, only one iteration will be executed.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_relabel">relabel</code></td>
<td>
<p>Controls whether, after merging, color labels should be ordered by module size.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_colorseq">colorSeq</code></td>
<td>
<p>Color labels to be used for relabeling. Defaults to the standard color order used
in this package if <code>colors</code> are not numeric, and to integers starting from 1 if
<code>colors</code> is numeric.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_getnewmes">getNewMEs</code></td>
<td>
<p>Controls whether module eigengenes of merged modules should be calculated and
returned.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_getnewunassdme">getNewUnassdME</code></td>
<td>
<p>When doing module eigengene manipulations, the function does not normally
calculate the eigengene of the 'module' of unassigned ('grey') genes. Setting this option to
<code>TRUE</code> will force the calculation of the unassigned eigengene in the returned newMEs, but not
in the returned oldMEs.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_usesets">useSets</code></td>
<td>
<p>A vector of scalar allowing the user to specify which sets will be used to calculate the
consensus dissimilarity of module eigengenes. Defaults to all given sets. </p>
</td></tr> 
<tr><td><code id="mergeCloseModules_+3A_checkdataformat">checkDataFormat</code></td>
<td>
<p>If TRUE, the function will check <code>exprData</code> and <code>MEs</code> for correct
multi-set structure. If single set data is given, it will be converted into a format usable for the
function. If FALSE, incorrect structure of input data will trigger an error.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_unassdcolor">unassdColor</code></td>
<td>
<p>Specifies the string that labels unassigned genes. Module of this color will
not enter the module eigengene clustering and will not be merged with other modules.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_traperrors">trapErrors</code></td>
<td>
<p>Controls whether computational errors in calculating module eigengenes, their
dissimilarity, and merging trees should be trapped. If <code>TRUE</code>, errors will be trapped and the
function will return the input colors. If <code>FALSE</code>, errors will cause the function to stop.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity of printed progress messages. 0 means silent, up to (about) 5 the
verbosity gradually increases.</p>
</td></tr>
<tr><td><code id="mergeCloseModules_+3A_indent">indent</code></td>
<td>
<p>A single non-negative integer controlling indentation of printed messages. 0 means no
indentation, each unit above that adds two spaces. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the color labels for modules that are obtained from the input modules by merging
ones that are closely related. The relationships are quantified by correlations of module eigengenes; a
&ldquo;consensus&rdquo; measure is defined as the minimum over the corresponding relationship in each set. Once the
(dis-)similarity is calculated, average linkage hierarchical clustering of the module eigengenes is
performed, the dendrogram is cut at the height <code>cutHeight</code> and modules on each branch are merged.
The process is (optionally) repeated until no more modules are merged.
</p>
<p>If, for a particular module, the module eigengene calculation fails, a hubgene approximation will be
used. 
</p>
<p>The user should be aware that if a computational error occurs and <code>trapErrors==TRUE</code>, 
the returned list (see below) will not contain all of the components returned upon normal execution.
</p>


<h3>Value</h3>

<p>If no errors occurred, a list with components
</p>
<table>
<tr><td><code>colors</code></td>
<td>
<p>Color labels for the genes corresponding to merged modules. The function attempts to
mimic the mode of the input <code>colors</code>: if the input <code>colors</code> is numeric, character and
factor, respectively, so is the output. Note, however, that if the fnction performs relabeling, a
standard sequence of labels will be used: integers starting at 1 if the input <code>colors</code> is
numeric, and a sequence of color labels otherwise (see <code>colorSeq</code> above).</p>
</td></tr>
<tr><td><code>dendro</code></td>
<td>
<p>Hierarchical clustering dendrogram (average linkage) of the eigengenes of the most
recently computed tree. If <code>iterate</code> was set TRUE, this will be the dendrogram of the merged
modules, otherwise it will be the dendrogram of the original modules.</p>
</td></tr>
<tr><td><code>oldDendro</code></td>
<td>
<p>Hierarchical clustering dendrogram (average linkage) of the eigengenes of the original
modules.</p>
</td></tr>
<tr><td><code>cutHeight</code></td>
<td>
<p>The input cutHeight.</p>
</td></tr>
<tr><td><code>oldMEs</code></td>
<td>
<p>Module eigengenes of the original modules in the sets given by <code>useSets</code>.</p>
</td></tr>
<tr><td><code>newMEs</code></td>
<td>
<p>Module eigengenes of the merged modules in the sets given by <code>useSets</code>.</p>
</td></tr>
<tr><td><code>allOK</code></td>
<td>
<p>A boolean set to <code>TRUE</code>.</p>
</td></tr>
</table>
<p>If an error occurred and <code>trapErrors==TRUE</code>, the list only contains these components:
</p>
<table>
<tr><td><code>colors</code></td>
<td>
<p>A copy of the input colors.</p>
</td></tr>
<tr><td><code>allOK</code></td>
<td>
<p>a boolean set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='moduleColor.getMEprefix'>Get the prefix used to label module eigengenes.</h2><span id='topic+moduleColor.getMEprefix'></span>

<h3>Description</h3>

<p>Returns the currently used prefix used to label module eigengenes. 
When returning module eigengenes in a dataframe,
names of the corresponding columns will start with the given prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleColor.getMEprefix()
</code></pre>


<h3>Details</h3>

<p>Returns the prefix used to label module eigengenes. When returning module eigengenes in a dataframe,
names of the corresponding columns will consist of the corresponfing color label preceded by the
given prefix. For example, if the prefix is &quot;PC&quot; and the module is turquoise, the corresponding
module eigengene will be labeled &quot;PCturquoise&quot;. Most of old code assumes &quot;PC&quot;, but &quot;ME&quot; is more
instructive and used in some newer analyses.
</p>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moduleColor.setMEprefix">moduleColor.setMEprefix</a></code>, <code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code>
</p>

<hr>
<h2 id='moduleColor.revisionDate'>Get the last revision date of the package.</h2><span id='topic+moduleColor.revisionDate'></span>

<h3>Description</h3>

<p>Returns the last revision date of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleColor.revisionDate()
</code></pre>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='moduleColor.setMEprefix'>Set the prefix used to label module eigengenes.</h2><span id='topic+moduleColor.setMEprefix'></span>

<h3>Description</h3>

<p>Sets the prefix used to label module eigengenes. When returning module eigengenes in a dataframe,
names of the corresponding columns will start with the given prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleColor.setMEprefix(prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleColor.setMEprefix_+3A_prefix">prefix</code></td>
<td>
<p>A character string of length 2. Recommended values are &quot;PC&quot; (the default start-up value) and
&quot;ME&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sets the prefix used to label module eigengenes. When returning module eigengenes in a dataframe,
names of the corresponding columns will consist of the corresponfing color label preceded by the
given prefix. For example, if the prefix is &quot;PC&quot; and the module is turquoise, the corresponding
module eigengene will be labeled &quot;PCturquoise&quot;. Most of old code assumes &quot;PC&quot;, but &quot;ME&quot; is more
instructive and used in some newer analyses.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moduleColor.getMEprefix">moduleColor.getMEprefix</a></code>, <code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code>
</p>

<hr>
<h2 id='moduleColor.version'>Get the version number of the package.</h2><span id='topic+moduleColor.version'></span>

<h3>Description</h3>

<p>Returns the version number of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleColor.version()
</code></pre>


<h3>Value</h3>

<p>A character string.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='moduleEigengenes'>Calculate module eigengenes.</h2><span id='topic+moduleEigengenes'></span>

<h3>Description</h3>

<p>Calculates module eigengenes (1st principal component) of modules in a given single dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleEigengenes(expr, 
                 colors, 
                 impute = TRUE, 
                 nPC = 1, 
                 align = "along average", 
                 excludeGrey = FALSE, 
                 grey = ifelse(is.numeric(colors),  0, "grey"),
                 subHubs = TRUE,
                 trapErrors = FALSE, 
                 returnValidOnly = trapErrors, 
                 softPower = 6,
                 verbose = 0, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleEigengenes_+3A_expr">expr</code></td>
<td>
<p>Expression data for a single set in the form of a data frame where rows are samples and
columns are genes (probes).</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_colors">colors</code></td>
<td>
<p>A vector of the same length as the number of probes in <code>expr</code>, giving module color
for all probes (genes). Color <code>"grey"</code> is reserved for unassigned genes. </p>
</td></tr> 
<tr><td><code id="moduleEigengenes_+3A_impute">impute</code></td>
<td>
<p>If <code>TRUE</code>, expression data will be checked for the presence of <code>NA</code> entries and
if the latter are present, numerical data will be imputed, using function <code>impute.knn</code> and probes from
the same module as the missing datum. The function <code>impute.knn</code> uses a fixed random seed giving
repeatable results.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_npc">nPC</code></td>
<td>
<p>Number of principal components and variance explained entries to be calculated. Note
that only the first principal component is returned; the rest are used only for the calculation of
proportion of variance explained. The number of returned variance explained entries is
currently <code>min(nPC, 10)</code>. If given <code>nPC</code> is greater than 10, a warning is issued.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_align">align</code></td>
<td>
<p>Controls whether eigengenes, whose orientation is undetermined, should be aligned with
average expression (<code>align = "along average"</code>, the default) or left as they are (<code>align = ""</code>).
Any other value will trigger an error.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_excludegrey">excludeGrey</code></td>
<td>
<p>Should the improper module consisting of 'grey' genes be excluded from the
eigengenes?</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_grey">grey</code></td>
<td>
<p>Value of <code>colors</code> designating the improper module. Note that if <code>colors</code> is a
factor of numbers, the default value will be incorrect.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_subhubs">subHubs</code></td>
<td>
<p>Controls whether hub genes should be substituted for missing eigengenes. If
<code>TRUE</code>, each missing eigengene (i.e., eigengene whose calculation failed and the error
was trapped) will be replaced by a weighted average of the most connected hub genes in the
corresponding module. If this calculation fails, or if <code>subHubs==FALSE</code>, the value of
<code>trapErrors</code> will determine whether the offending module
will be removed or whether the function will issue an error and stop.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_traperrors">trapErrors</code></td>
<td>
<p>Controls handling of errors from that may arise when there are too many
<code>NA</code> entries in expression data. If <code>TRUE</code>, errors from calling these functions will be
trapped without abnormal exit. 
If <code>FALSE</code>, errors will cause the function to stop. Note, however, that <code>subHubs</code> takes
precedence in the sense that if <code>subHubs==TRUE</code> and <code>trapErrors==FALSE</code>, an error will be
issued only if both the principal component and the hubgene calculations have failed. </p>
</td></tr> 
<tr><td><code id="moduleEigengenes_+3A_returnvalidonly">returnValidOnly</code></td>
<td>
<p>Boolean. Controls whether the returned data frame of module eigengenes 
contains columns
corresponding only to modules whose eigengenes or hub genes could be calculated correctly 
(<code>TRUE</code>), or whether
the data frame should have columns for each of the input color labels (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_softpower">softPower</code></td>
<td>
<p>The power used in soft-thresholding the adjacency matrix. Only used when the
hubgene approximation is necessary because the principal component calculation failed. It must be
non-negative. The default
value should only be changed if there is a clear indication that it leads to incorrect results.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity of printed progress messages. 0 means silent, up to (about) 5 the
verbosity gradually increases.</p>
</td></tr>
<tr><td><code id="moduleEigengenes_+3A_indent">indent</code></td>
<td>
<p>A single non-negative integer controlling indentation of printed messages. 0 means no
indentation, each unit above that adds two spaces. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Module eigengene is defined as the first principal component of the expression matrix of the
corresponding module. The calculation may fail if the expression data has too many missing entries.
Handling of such errors is controlled by the arguments <code>subHubs</code> and 
<code>trapErrors</code>. 
If <code>subHubs==TRUE</code>, errors in principal component calculation will be trapped and a substitute
calculation of hubgenes will be attempted. If this fails as well, behaviour depends on
<code>trapErrors</code>: if <code>TRUE</code>, the offending 
module will be ignored and the return value will allow the user to remove the module from further
analysis; if <code>FALSE</code>, the function will stop. 
</p>
<p>From the user's point of view, setting <code>trapErrors=FALSE</code> ensures that if the function returns
normally, there will be a valid eigengene (principal component or hubgene) for each of the input
colors. If the user sets <code>trapErrors=TRUE</code>, all calculational (but not input) errors will be
trapped, but the user should check the output (see below) to make sure all modules have a valid
returned eigengene. 
</p>
<p>While the principal component calculation can fail even on relatively sound data 
(it does not take all that many &quot;well-placed&quot; <code>NA</code> to torpedo the
calculation), 
it takes many more irregularities in the data for the hubgene calculation to
fail. In fact such a failure signals there likely is something seriously wrong with the data.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>eigengenes</code></td>
<td>
<p>Module eigengenes in a dataframe, with each column corresponding to one eigengene.
The columns are named by the corresponding color with an <code>"ME"</code> prepended, e.g., <code>MEturquoise</code>
etc. If <code>returnValidOnly==FALSE</code>, module eigengenes whose calculation failed have 
all components set to <code>NA</code>.</p>
</td></tr>
<tr><td><code>averageExpr</code></td>
<td>
<p>If <code>align == "along average"</code>, a dataframe containing average normalized
expression in each module. The columns are named by the corresponding color with an <code>"AE"</code>
prepended, e.g., <code>AEturquoise</code> etc.</p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p>A dataframe in which each column corresponds to a module, with the component
<code>varExplained[PC, module]</code> giving the variance of module <code>module</code> explained by the principal
component no. <code>PC</code>. The calculation is exact irrespective of the number of computed principal
components. At most 10 variance explained values are recorded in this dataframe.</p>
</td></tr>
<tr><td><code>nPC</code></td>
<td>
<p>A copy of the input <code>nPC</code>.</p>
</td></tr> 
<tr><td><code>validMEs</code></td>
<td>
<p>A boolean vector. Each component (corresponding to the columns in <code>data</code>)
is <code>TRUE</code> if the corresponding eigengene is valid, and <code>FALSE</code>
if it is invalid. Valid eigengenes include both principal components and their hubgene
approximations.
When <code>returnValidOnly==FALSE</code>, by definition all returned eigengenes are valid and the
entries of <code>validMEs</code> are all <code>TRUE</code>. </p>
</td></tr>
<tr><td><code>validColors</code></td>
<td>
<p>A copy of the input colors with entries corresponding to invalid modules set to
<code>grey</code> if given, otherwise 0 if <code>colors</code> is numeric and &quot;grey&quot; otherwise.</p>
</td></tr>
<tr><td><code>allOK</code></td>
<td>
<p>Boolean flag signalling whether all eigengenes have been calculated correctly, either
as principal components or as the hubgene average approximation.</p>
</td></tr>
<tr><td><code>allPC</code></td>
<td>
<p>Boolean flag signalling whether all returned eigengenes are principal components.</p>
</td></tr>
<tr><td><code>isPC</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding eigengene is the first principal component and <code>FALSE</code> if it
is the hubgene approximation or is invalid.</p>
</td></tr>
<tr><td><code>isHub</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding eigengene is the hubgene approximation and <code>FALSE</code> if it
is the first principal component or is invalid.</p>
</td></tr>
<tr><td><code>validAEs</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding module average expression is valid.</p>
</td></tr>
<tr><td><code>allAEOK</code></td>
<td>
<p>Boolean flag signalling whether all returned module average expressions contain
valid data. Note that <code>returnValidOnly==TRUE</code> does not imply <code>allAEOK==TRUE</code>: 
some invalid average expressions may be
returned if their corresponding eigengenes have been calculated correctly.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Steve Horvath <a href="mailto:SHorvath@mednet.ucla.edu">SHorvath@mednet.ucla.edu</a>, Peter Langfelder
<a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a> </p>


<h3>References</h3>

 
<p>Zhang, B. and Horvath, S. (2005), &quot;A General Framework for Weighted Gene Co-Expression Network
Analysis&quot;, Statistical Applications in Genetics and Molecular Biology: Vol. 4: No. 1, Article 17</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>, <code><a href="impute.html#topic+impute.knn">impute.knn</a></code> </p>

<hr>
<h2 id='moduleNumber'>Fixed-height cut of a dendrogram.</h2><span id='topic+moduleNumber'></span>

<h3>Description</h3>

<p>Detects branches of on the input dendrogram by performing a fixed-height cut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moduleNumber(dendro, cutHeight = 0.9, minSize = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moduleNumber_+3A_dendro">dendro</code></td>
<td>
<p>a hierarchical clustering dendorgram such as one returned by <code><a href="stats.html#topic+hclust">hclust</a></code>.  </p>
</td></tr>
<tr><td><code id="moduleNumber_+3A_cutheight">cutHeight</code></td>
<td>
<p>Maximum joining heights that will be considered.  </p>
</td></tr>
<tr><td><code id="moduleNumber_+3A_minsize">minSize</code></td>
<td>
<p>Minimum cluster size.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All contiguous branches below the height <code>cutHeight</code> that contain at least <code>minSize</code> objects
are assigned unique positive numerical labels; all unassigned objects are assigned label 0.
</p>


<h3>Value</h3>

<p>A vector of numerical labels giving the assigment of each object.
</p>


<h3>Note</h3>

<p>The numerical labels may not be sequential. See <code><a href="#topic+normalizeLabels">normalizeLabels</a></code> for a way to put the
labels into a standard order.</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>, <code><a href="#topic+normalizeLabels">normalizeLabels</a></code>
</p>

<hr>
<h2 id='multiSetMEs'>Calculate module eigengenes. </h2><span id='topic+multiSetMEs'></span>

<h3>Description</h3>

<p>Calculates module eigengenes for several sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiSetMEs(exprData, 
            colors, 
            universalColors = NULL, 
            useSets = NULL, 
            useGenes = NULL,
            impute = TRUE, 
            nPC = 1, 
            align = "along average", 
            excludeGrey = FALSE,
            grey = ifelse(is.null(universalColors), ifelse(is.numeric(colors), 0, "grey"),
                          ifelse(is.numeric(universalColors), 0, "grey")),
            subHubs = TRUE,
            trapErrors = FALSE, 
            returnValidOnly = trapErrors,
            softPower = 6,
            verbose = 1, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiSetMEs_+3A_exprdata">exprData</code></td>
<td>
<p>Expression data in a multi-set format (see <code><a href="#topic+checkSets">checkSets</a></code>). A vector of lists,
with each list corresponding to one microarray dataset and expression data in the component <code>data</code>,
that is <code>expr[[set]]$data[sample, probe]</code> is the expression of probe <code>probe</code> in sample
<code>sample</code> in dataset <code>set</code>. The number of samples can be different between the sets, but the
probes must be the same. </p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_colors">colors</code></td>
<td>
<p>A matrix of dimensions (number of probes, number of sets) giving the module assignment of
each gene in each set. The color &quot;grey&quot; is interpreted as unassigned.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_universalcolors">universalColors</code></td>
<td>
<p>Alternative specification of module assignment. A single vector of length
(number of probes) giving the module assignment of each gene in all sets (that is the modules are common
to all sets). If given, takes precedence over <code>color</code>.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_usesets">useSets</code></td>
<td>
<p>If calculations are requested in (a) selected set(s) only, the set(s) can be specified
here. Defaults to all sets.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_usegenes">useGenes</code></td>
<td>
<p>Can be used to restrict calculation to a subset of genes (the same subset in all
sets). If given, <code>validColors</code> in the returned list will only contain colors for the genes
specified in <code>useGenes</code>.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_impute">impute</code></td>
<td>
<p>Logical. If <code>TRUE</code>, expression data will be checked for the presence of <code>NA</code>
entries and if the latter are present, numerical data will be imputed, using function <code>impute.knn</code>
and probes from the same module as the missing datum. The function <code>impute.knn</code> uses a fixed random
seed giving repeatable results.</p>
</td></tr> 
<tr><td><code id="multiSetMEs_+3A_npc">nPC</code></td>
<td>
<p>Number of principal components to be calculated. If only eigengenes are needed, it is best
to set it to 1 (default). If variance explained is needed as well, use value <code>NULL</code>. This will cause
all principal components to be computed, which is slower.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_align">align</code></td>
<td>
<p>Controls whether eigengenes, whose orientation is undetermined, should be aligned with
average expression (<code>align = "along average"</code>, the default) or left as they are (<code>align = ""</code>).
Any other value will trigger an error.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_excludegrey">excludeGrey</code></td>
<td>
<p>Should the improper module consisting of 'grey' genes be excluded from the
eigengenes?</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_grey">grey</code></td>
<td>
<p>Value of <code>colors</code> or <code>universalColors</code> (whichever applies)
designating the improper module. Note that if the appropriate colors argument is a
factor of numbers, the default value will be incorrect.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_subhubs">subHubs</code></td>
<td>
<p>Controls whether hub genes should be substituted for missing eigengenes. If
<code>TRUE</code>, each missing eigengene (i.e., eigengene whose calculation failed and the error
was trapped) will be replaced by a weighted average of the most connected hub genes in the
corresponding module. If this calculation fails, or if <code>subHubs==FALSE</code>, the value of
<code>trapErrors</code> will determine whether the offending module
will be removed or whether the function will issue an error and stop.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_traperrors">trapErrors</code></td>
<td>
<p>Controls handling of errors from that may arise when there are too many
<code>NA</code> entries in expression data. If <code>TRUE</code>, errors from calling these functions will be
trapped without abnormal exit.
If <code>FALSE</code>, errors will cause the function to stop. Note, however, that <code>subHubs</code> takes
precedence in the sense that if <code>subHubs==TRUE</code> and <code>trapErrors==FALSE</code>, an error will be
issued only if both the principal component and the hubgene calculations have failed. </p>
</td></tr> 
<tr><td><code id="multiSetMEs_+3A_returnvalidonly">returnValidOnly</code></td>
<td>
<p>Boolean. Controls whether the returned data frames of module eigengenes 
contain columns
corresponding only to modules whose eigengenes or hub genes could be calculated correctly in every
set (<code>TRUE</code>), or whether
the data frame should have columns for each of the input color labels (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_softpower">softPower</code></td>
<td>
<p>The power used in soft-thresholding the adjacency matrix. Only used when the
hubgene approximation is necessary because the principal component calculation failed. It must be
non-negative. The default
value should only be changed if there is a clear indication that it leads to incorrect results.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity of printed progress messages. 0 means silent, up to (about) 5 the
verbosity gradually increases.</p>
</td></tr>
<tr><td><code id="multiSetMEs_+3A_indent">indent</code></td>
<td>
<p>A single non-negative integer controlling indentation of printed messages. 0 means no
indentation, each unit above that adds two spaces. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code> for each set in <code>exprData</code>.
</p>
<p>Module eigengene is defined as the first principal component of the expression matrix of the
corresponding module. The calculation may fail if the expression data has too many missing entries.
Handling of such errors is controlled by the arguments <code>subHubs</code> and
<code>trapErrors</code>.
If <code>subHubs==TRUE</code>, errors in principal component calculation will be trapped and a substitute
calculation of hubgenes will be attempted. If this fails as well, behaviour depends on
<code>trapErrors</code>: if <code>TRUE</code>, the offending
module will be ignored and the return value will allow the user to remove the module from further
analysis; if <code>FALSE</code>, the function will stop.
If <code>universalColors</code> is given, any offending
module will be removed from all sets (see <code>validMEs</code> in return value below). 
</p>
<p>From the user's point of view, setting <code>trapErrors=FALSE</code> ensures that if the function returns
normally, there will be a valid eigengene (principal component or hubgene) for each of the input
colors. If the user sets <code>trapErrors=TRUE</code>, all calculational (but not input) errors will be
trapped, but the user should check the output (see below) to make sure all modules have a valid
returned eigengene.
</p>
<p>While the principal component calculation can fail even on relatively sound data
(it does not take all that many &quot;well-placed&quot; <code>NA</code> to torpedo the
calculation),
it takes many more irregularities in the data for the hubgene calculation to
fail. In fact such a failure signals there likely is something seriously wrong with the data.
</p>


<h3>Value</h3>

<p>A vector of lists similar in spirit to the input <code>exprData</code>. For each set there is a list with the
following components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>Module eigengenes in a data frame, with each column corresponding to one eigengene.
The columns are named by the corresponding color with an <code>"ME"</code> prepended, e.g., <code>MEturquoise</code>
etc. Note that, when <code>trapErrors == TRUE</code> and <code>returnValidOnly==FALSE</code>, 
this data frame also contains entries corresponding to 
removed modules, if any. (<code>validMEs</code> below indicates which eigengenes are valid and <code>allOK</code>
whether all module eigengens were successfully calculated.) </p>
</td></tr>
<tr><td><code>averageExpr</code></td>
<td>
<p>If <code>align == "along average"</code>, a dataframe containing average normalized
expression in each module. The columns are named by the corresponding color with an <code>"AE"</code>
prepended, e.g., <code>AEturquoise</code> etc.</p>
</td></tr>
<tr><td><code>varExplained</code></td>
<td>
<p>A dataframe in which each column corresponds to a module, with the component
<code>varExplained[PC, module]</code> giving the variance of module <code>module</code> explained by the principal
component no. <code>PC</code>. This is only accurate if all principal components have been computed (input
<code>nPC = NULL</code>). At most 5 principal components are recorded in this dataframe.</p>
</td></tr>
<tr><td><code>nPC</code></td>
<td>
<p>A copy of the input <code>nPC</code>.</p>
</td></tr>
<tr><td><code>validMEs</code></td>
<td>
<p>A boolean vector. Each component (corresponding to the columns in <code>data</code>)
is <code>TRUE</code> if the corresponding eigengene is valid, and <code>FALSE</code>
if it is invalid. Valid eigengenes include both principal components and their hubgene
approximations.
When <code>returnValidOnly==FALSE</code>, by definition all returned eigengenes are valid and the
entries of <code>validMEs</code> are all <code>TRUE</code>. </p>
</td></tr>
<tr><td><code>validColors</code></td>
<td>
<p>A copy of the input colors (<code>universalColors</code> if set, otherwise 
<code>colors[, set]</code>) with entries corresponding to invalid modules set to
<code>grey</code> if given, otherwise 0 if the appropriate input colors are numeric and &quot;grey&quot; otherwise.</p>
</td></tr>
<tr><td><code>allOK</code></td>
<td>
<p>Boolean flag signalling whether all eigengenes have been calculated correctly, either
as principal components or as the hubgene approximation. If <code>universalColors</code> is set, this flag
signals whether all eigengenes are valid in all sets.</p>
</td></tr>
<tr><td><code>allPC</code></td>
<td>
<p>Boolean flag signalling whether all returned eigengenes are principal components.
This flag (as well as the subsequent ones) is set independently for each set.</p>
</td></tr>
<tr><td><code>isPC</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding eigengene is the first principal component and <code>FALSE</code> if it
is the hubgene approximation or is invalid. </p>
</td></tr>
<tr><td><code>isHub</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding eigengene is the hubgene approximation and <code>FALSE</code> if it
is the first principal component or is invalid.</p>
</td></tr>
<tr><td><code>validAEs</code></td>
<td>
<p>Boolean vector. Each component (corresponding to the columns in <code>eigengenes</code>) is
<code>TRUE</code> if the corresponding module average expression is valid.</p>
</td></tr>
<tr><td><code>allAEOK</code></td>
<td>
<p>Boolean flag signalling whether all returned module average expressions contain
valid data. Note that <code>returnValidOnly==TRUE</code> does not imply <code>allAEOK==TRUE</code>: 
some invalid average expressions may be
returned if their corresponding eigengenes have been calculated correctly.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code></p>

<hr>
<h2 id='normalizeLabels'>Transform numerical labels into normal order. </h2><span id='topic+normalizeLabels'></span>

<h3>Description</h3>

<p>Transforms numerical labels into normal order, that is the largest group will be labeled 1, next
largest 2 etc. Label 0 is optionally preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeLabels(labels, keepZero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeLabels_+3A_labels">labels</code></td>
<td>
<p>Numerical labels.</p>
</td></tr>
<tr><td><code id="normalizeLabels_+3A_keepzero">keepZero</code></td>
<td>
<p>If <code>TRUE</code> (the default), labels 0 are preserved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as input, containing the normalized labels.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='orderMEs'>Put close eigenvectors next to each other</h2><span id='topic+orderMEs'></span>

<h3>Description</h3>

<p>Reorder given (eigen-)vectors such that similar ones (as measured by correlation) are next to each
other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderMEs(MEs, greyLast = TRUE, 
         greyName = paste(moduleColor.getMEprefix(), "grey", sep=""), 
         orderBy = 1, order = NULL, 
         useSets = NULL,  verbose = 0, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderMEs_+3A_mes">MEs</code></td>
<td>
<p>Module eigengenes in a multi-set format (see <code><a href="#topic+checkSets">checkSets</a></code>). A vector of lists,
with each list corresponding to one dataset and the module eigengenes in the component <code>data</code>,
that is <code>MEs[[set]]$data[sample, module]</code> is the expression of the eigengene of module <code>module</code>
in sample
<code>sample</code> in dataset <code>set</code>. The number of samples can be different between the sets, but the
modules must be the same. </p>
</td></tr>
<tr><td><code id="orderMEs_+3A_greylast">greyLast</code></td>
<td>
<p>Normally the color grey is reserved for unassigned genes; hence the grey module is not
a proper module and it is conventional to put it last. If this is not desired, set the parameter to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_greyname">greyName</code></td>
<td>
<p>Name of the grey module eigengene.</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_orderby">orderBy</code></td>
<td>
<p>Specifies the set by which the eigengenes are to be ordered (in all other sets as well).
Defaults to the first set in <code>useSets</code> (or the first set, if <code>useSets</code> is not given).</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_order">order</code></td>
<td>
<p>Allows the user to specify a custom ordering.</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_usesets">useSets</code></td>
<td>
<p>Allows the user to specify for which sets the eigengene ordering is to be performed.</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbostity of printed progress messages. 0 means silent, nonzero verbose.</p>
</td></tr>
<tr><td><code id="orderMEs_+3A_indent">indent</code></td>
<td>
<p>A single non-negative integer controling indentation of printed messages. 0 means no
indentation, each unit above zero adds two spaces. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordering module eigengenes is useful for plotting purposes. For this function the order can be
specified explicitly, or a set can be given in which the correlations of the eigengenes will determine
the order. For the latter, a hierarchical dendrogram is calculated and the order given by the dendrogram is
used for the eigengenes in all other sets.
</p>


<h3>Value</h3>

<p>A vector of lists of the same type as <code>MEs</code> containing the re-ordered eigengenes.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moduleEigengenes">moduleEigengenes</a></code>, <code><a href="#topic+multiSetMEs">multiSetMEs</a></code>, <code><a href="#topic+consensusOrderMEs">consensusOrderMEs</a></code></p>

<hr>
<h2 id='plotHclustColors'>Plot color rows corresponding to modules</h2><span id='topic+plotHclustColors'></span>

<h3>Description</h3>

<p>Plot color bars corresponding to modules, usually beneath a dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHclustColors(dendro, colors, rowLabels = NULL, cex.rowLabels = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHclustColors_+3A_dendro">dendro</code></td>
<td>
<p>A dendrogram such as returned by <code><a href="stats.html#topic+hclust">hclust</a></code>. </p>
</td></tr>
<tr><td><code id="plotHclustColors_+3A_colors">colors</code></td>
<td>
<p>Coloring of objects on the dendrogram. Either a vector (one color per object) or a
matrix (can also be an array or a data frame)
with each column giving one color per object. Each column will be plotted as a horizontal row of colors
under the dendrogram.</p>
</td></tr>
<tr><td><code id="plotHclustColors_+3A_rowlabels">rowLabels</code></td>
<td>
<p>Labels for the colorings given in <code>colors</code>. The labels will be printed to the
left of the color rows in the plot. If the argument is given, it must be a vector of length
equal to the number of columns in <code>colors</code>. If not given, <code>names(colors)</code>
will be used if available. If not, sequential numbers
starting from 1 will be used.</p>
</td></tr>
<tr><td><code id="plotHclustColors_+3A_cex.rowlabels">cex.rowLabels</code></td>
<td>
<p>Font size scale factor for the row labels. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotHclustColors_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed on to the plotting method (such as <code>main</code> for the main
title etc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is often useful to plot module assignment (by color) that was obtained by cutting a hierarchical
dendrogram, to visually check whether the obtained modules are meaningful, or which one of several
possible module assignments looks best. One way to do it to section the screen into two parts, plot the
dendrogram (via <code>plot(hclust)</code>) in the upper section and use this function to plot colors in the
order corresponding to the dendrogram in the lower section.
</p>


<h3>Value</h3>

<p> None.
</p>


<h3>Author(s)</h3>

<p>Steve Horvath <a href="mailto:SHorvath@mednet.ucla.edu">SHorvath@mednet.ucla.edu</a> and Peter Langfelder <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="dynamicTreeCut.html#topic+cutreeDynamic">cutreeDynamic</a></code> for module detection in a dendrogram.</p>

<hr>
<h2 id='removeGreyME'>Removes the grey eigengene from a given collection of eigengenes. </h2><span id='topic+removeGreyME'></span>

<h3>Description</h3>

<p>Given module eigengenes either in a single data frame or in a multi-set format, removes the grey
eigengenes from each set. If the grey eigengenes are not found, a warning is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeGreyME(MEs, greyMEName = paste(moduleColor.getMEprefix(), "grey", sep=""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeGreyME_+3A_mes">MEs</code></td>
<td>
<p>Module eigengenes, either in a single data frame (typicaly for a single set), or in a
multi-set format. See <code><a href="#topic+checkSets">checkSets</a></code> for a description of the multi-set format.</p>
</td></tr>
<tr><td><code id="removeGreyME_+3A_greymename">greyMEName</code></td>
<td>
<p>Name of the module eigengene (in each corresponding data frame) that corresponds to
the grey color. This will typically be &quot;PCgrey&quot; or &quot;MEgrey&quot;. If the module eigengenes were calculated
using standard functions in this library, the default should work.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Module eigengenes in the same format as input (either a single data frame or a vector of lists) with the
grey eigengene removed. 
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>

<hr>
<h2 id='standardColors'>Colors this library uses for labeling modules.</h2><span id='topic+standardColors'></span>

<h3>Description</h3>

<p>Returns the vector of color names in the order they are assigned by other functions in this library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardColors(n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardColors_+3A_n">n</code></td>
<td>
<p>Number of colors requested. If <code>NULL</code>, all (approx. 450) colors will be returned. Any
other invalid argument such as less than one or more than maximum (<code>length(standardColors())</code>) will
trigger an error. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of character color names of the requested length.
</p>


<h3>Author(s)</h3>

<p>Peter Langfelder, <a href="mailto:Peter.Langfelder@gmail.com">Peter.Langfelder@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>standardColors(10);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
