<!DOCTYPE html><html><head><title>Help for package waveslim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {waveslim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acvs.andel8'><p>Autocovariance and Autocorrelation Sequences for a Seasonal Persistent</p>
Process</a></li>
<li><a href='#afb'><p>Filter Banks for Dual-Tree Wavelet Transforms</p></a></li>
<li><a href='#ar1'><p>Simulated AR(1) Series</p></a></li>
<li><a href='#bandpass.var.spp'><p>Bandpass Variance for Long-Memory Processes</p></a></li>
<li><a href='#barbara'><p>Barbara Test Image</p></a></li>
<li><a href='#basis'><p>Produce Boolean Vector from Wavelet Basis Names</p></a></li>
<li><a href='#blocks'><p>A Piecewise-Constant Function</p></a></li>
<li><a href='#brick.wall'><p>Replace Boundary Wavelet Coefficients with Missing Values</p></a></li>
<li><a href='#convolve2D'><p>Fast Column-wise Convolution of a Matrix</p></a></li>
<li><a href='#cpi'><p>U.S. Consumer Price Index</p></a></li>
<li><a href='#cplxdual2D'><p>Dual-tree Complex 2D Discrete Wavelet Transform</p></a></li>
<li><a href='#cshift'><p>Miscellaneous Functions for Dual-Tree Wavelet Software</p></a></li>
<li><a href='#css.test'><p>Testing the Wavelet Packet Tree for White Noise</p></a></li>
<li><a href='#dau'><p>Digital Photograph of Ingrid Daubechies</p></a></li>
<li><a href='#denoise.dwt.2d'><p>Denoise an Image via the 2D Discrete Wavelet Transform</p></a></li>
<li><a href='#doppler'><p>Sinusoid with Changing Amplitude and Frequency</p></a></li>
<li><a href='#dpss.taper'><p>Calculating Thomson's Spectral Multitapers by Inverse Iteration</p></a></li>
<li><a href='#dualfilt1'><p>Kingsbury's Q-filters for the Dual-Tree Complex DWT</p></a></li>
<li><a href='#dualtree'><p>Dual-tree Complex Discrete Wavelet Transform</p></a></li>
<li><a href='#dwpt'><p>(Inverse) Discrete Wavelet Packet Transforms</p></a></li>
<li><a href='#dwpt.2d'><p>(Inverse) Discrete Wavelet Packet Transforms in Two Dimensions</p></a></li>
<li><a href='#dwpt.boot'><p>Bootstrap Time Series Using the DWPT</p></a></li>
<li><a href='#dwpt.sim'><p>Simulate Seasonal Persistent Processes Using the DWPT</p></a></li>
<li><a href='#dwt'><p>Discrete Wavelet Transform (DWT)</p></a></li>
<li><a href='#dwt.2d'><p>Two-Dimensional Discrete Wavelet Transform</p></a></li>
<li><a href='#dwt.3d'><p>Three Dimensional Separable Discrete Wavelet Transform</p></a></li>
<li><a href='#dwt.hilbert'><p>Discrete Hilbert Wavelet Transforms</p></a></li>
<li><a href='#exchange'><p>Exchange Rates Between the Deutsche Mark, Japanese Yen and U.S. Dollar</p></a></li>
<li><a href='#fdp.mle'><p>Wavelet-based Maximum Likelihood Estimation for a Fractional Difference</p>
Process</a></li>
<li><a href='#fdp.sdf'><p>Spectral Density Functions for Long-Memory Processes</p></a></li>
<li><a href='#find.adaptive.basis'><p>Determine an Orthonormal Basis for the Discrete Wavelet Packet Transform</p></a></li>
<li><a href='#FSfarras'><p>Farras nearly symmetric filters</p></a></li>
<li><a href='#heavisine'><p>Sine with Jumps at 0.3 and 0.72</p></a></li>
<li><a href='#hilbert.filter'><p>Select a Hilbert Wavelet Pair</p></a></li>
<li><a href='#hosking.sim'><p>Generate Stationary Gaussian Process Using Hosking's Method</p></a></li>
<li><a href='#ibm'><p>Daily IBM Stock Prices</p></a></li>
<li><a href='#japan'><p>Japanese Gross National Product</p></a></li>
<li><a href='#jumpsine'><p>Sine with Jumps at 0.625 and 0.875</p></a></li>
<li><a href='#kobe'><p>1995 Kobe Earthquake Data</p></a></li>
<li><a href='#linchirp'><p>Linear Chirp</p></a></li>
<li><a href='#manual.thresh'><p>Wavelet Shrinkage via Thresholding</p></a></li>
<li><a href='#mexm'><p>Mexican Money Supply</p></a></li>
<li><a href='#modhwt.coh'><p>Time-varying and Seasonal Analysis Using Hilbert Wavelet Pairs</p></a></li>
<li><a href='#modwt'><p>(Inverse) Maximal Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt.2d'><p>Two-Dimensional Maximal Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt.3d'><p>Three Dimensional Separable Maximal Ovelrap Discrete Wavelet Transform</p></a></li>
<li><a href='#mra'><p>Multiresolution Analysis of Time Series</p></a></li>
<li><a href='#mra.2d'><p>Multiresolution Analysis of an Image</p></a></li>
<li><a href='#mra.3d'><p>Three Dimensional Multiresolution Analysis</p></a></li>
<li><a href='#mult.loc'><p>Wavelet-based Testing and Locating for Variance Change Points</p></a></li>
<li><a href='#my.acf'><p>Autocovariance Functions via the Discrete Fourier Transform</p></a></li>
<li><a href='#nile'><p>Nile River Minima</p></a></li>
<li><a href='#ortho.basis'><p>Derive Orthonormal Basis from Wavelet Packet Tree</p></a></li>
<li><a href='#per'><p>Periodogram</p></a></li>
<li><a href='#phase.shift'><p>Phase Shift Wavelet Coefficients</p></a></li>
<li><a href='#phase.shift.hilbert'><p>Phase Shift for Hilbert Wavelet Coefficients</p></a></li>
<li><a href='#plot.dwt.2d'><p>Plot Two-dimensional Discrete Wavelet Transform</p></a></li>
<li><a href='#qmf'><p>Quadrature Mirror Filter</p></a></li>
<li><a href='#rotcumvar'><p>Rotated Cumulative Variance</p></a></li>
<li><a href='#shift.2d'><p>Circularly Shift Matrices from a 2D MODWT</p></a></li>
<li><a href='#sine.taper'><p>Computing Sinusoidal Data Tapers</p></a></li>
<li><a href='#spin.covariance'><p>Compute Wavelet Cross-Covariance Between Two Time Series</p></a></li>
<li><a href='#spp.mle'><p>Wavelet-based Maximum Likelihood Estimation for Seasonal Persistent</p>
Processes</a></li>
<li><a href='#spp.var'><p>Variance of a Seasonal Persistent Process</p></a></li>
<li><a href='#squared.gain'><p>Squared Gain Function of a Filter</p></a></li>
<li><a href='#stackPlot'><p>Stack Plot</p></a></li>
<li><a href='#testing.hov'><p>Testing for Homogeneity of Variance</p></a></li>
<li><a href='#tourism'><p>U.S. Tourism</p></a></li>
<li><a href='#unemploy'><p>U.S. Unemployment</p></a></li>
<li><a href='#up.sample'><p>Upsampling of a vector</p></a></li>
<li><a href='#wave.filter'><p>Select a Wavelet Filter</p></a></li>
<li><a href='#wave.variance'><p>Wavelet Analysis of Univariate/Bivariate Time Series</p></a></li>
<li><a href='#wave.variance.2d'><p>Wavelet Analysis of Images</p></a></li>
<li><a href='#wavelet.filter'><p>Higher-Order Wavelet Filters</p></a></li>
<li><a href='#xbox'><p>Image with Box and X</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Wavelet Routines for One-, Two-, and Three-Dimensional
Signal Processing</td>
</tr>
<tr>
<td>Author:</td>
<td>Brandon Whitcher</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brandon Whitcher &lt;bwhitcher@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.11.0), graphics, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fftw, covr</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic wavelet routines for time series (1D), image (2D) and array 
  (3D) analysis.  The code provided here is based on wavelet methodology 
  developed in Percival and Walden (2000); Gencay, Selcuk and Whitcher (2001); 
  the dual-tree complex wavelet transform (DTCWT) from Kingsbury (1999, 2001) as
  implemented by Selesnick; and Hilbert wavelet pairs (Selesnick 2001, 2002).  
  All figures in chapters 4-7 of GSW (2001) are reproducible using this package 
  and R code available at the book website(s) below.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://waveslim.blogspot.com">https://waveslim.blogspot.com</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-14 08:56:01 UTC; brandon</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-14 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acvs.andel8'>Autocovariance and Autocorrelation Sequences for a Seasonal Persistent
Process</h2><span id='topic+acvs.andel8'></span><span id='topic+acvs.andel9'></span><span id='topic+acvs.andel10'></span><span id='topic+acvs.andel11'></span>

<h3>Description</h3>

<p>The autocovariance and autocorrelation sequences from the time series model
in Figures 8, 9, 10, and 11 of Andel (1986).  They were obtained through
numeric integration of the spectral density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(acvs.andel8)

data(acvs.andel9)

data(acvs.andel10)

data(acvs.andel11)
</code></pre>


<h3>Format</h3>

<p>A data frame with 4096 rows and three columns: lag, autocovariance
sequence, autocorrelation sequence.
</p>


<h3>References</h3>

<p>Andel, J. (1986) Long memory time series models,
<em>Kypernetika</em>, <b>22</b>, No. 2, 105-123.
</p>

<hr>
<h2 id='afb'>Filter Banks for Dual-Tree Wavelet Transforms</h2><span id='topic+afb'></span><span id='topic+afb2D'></span><span id='topic+afb2D.A'></span><span id='topic+sfb'></span><span id='topic+sfb2D'></span><span id='topic+sfb2D.A'></span>

<h3>Description</h3>

<p>Analysis and synthesis filter banks used in dual-tree wavelet algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afb(x, af)

afb2D(x, af1, af2 = NULL)

afb2D.A(x, af, d)

sfb(lo, hi, sf)

sfb2D(lo, hi, sf1, sf2 = NULL)

sfb2D.A(lo, hi, sf, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afb_+3A_x">x</code></td>
<td>
<p>vector or matrix of observations</p>
</td></tr>
<tr><td><code id="afb_+3A_af">af</code></td>
<td>
<p>analysis filters.  First element of the list is the low-pass
filter, second element is the high-pass filter.</p>
</td></tr>
<tr><td><code id="afb_+3A_af1">af1</code>, <code id="afb_+3A_af2">af2</code></td>
<td>
<p>analysis filters for the first and second dimension of a 2D
array.</p>
</td></tr>
<tr><td><code id="afb_+3A_sf">sf</code></td>
<td>
<p>synthesis filters.  First element of the list is the low-pass
filter, second element is the high-pass filter.</p>
</td></tr>
<tr><td><code id="afb_+3A_sf1">sf1</code>, <code id="afb_+3A_sf2">sf2</code></td>
<td>
<p>synthesis filters for the first and second dimension of a 2D
array.</p>
</td></tr>
<tr><td><code id="afb_+3A_d">d</code></td>
<td>
<p>dimension of filtering (d = 1 or 2)</p>
</td></tr>
<tr><td><code id="afb_+3A_lo">lo</code></td>
<td>
<p>low-frequecy coefficients</p>
</td></tr>
<tr><td><code id="afb_+3A_hi">hi</code></td>
<td>
<p>high-frequency coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>afb2D.A</code> and <code>sfb2D.A</code> implement the convolutions,
either for analysis or synthesis, in one dimension only.  Thus, they are the
workhorses of <code>afb2D</code> and <code>sfb2D</code>.  The output for the analysis
filter bank along one dimension (<code>afb2D.A</code>) is a list with two elements
</p>
 <dl>
<dt>lo</dt><dd><p>low-pass subband</p>
</dd> <dt>hi</dt><dd><p>high-pass subband</p>
</dd> </dl>
<p> where
the dimension of analysis will be half its original length.  The output for
the synthesis filter bank along one dimension (<code>sfb2D.A</code>) will be the
output array, where the dimension of synthesis will be twice its original
length.
</p>


<h3>Value</h3>

<p>In one dimension the output for the analysis filter bank
(<code>afb</code>) is a list with two elements </p>
<table>
<tr><td><code>lo</code></td>
<td>
<p>Low frequecy output</p>
</td></tr>
<tr><td><code>hi</code></td>
<td>
<p>High frequency output</p>
</td></tr></table>
<p> and the output for the synthesis filter
bank (<code>sfb</code>) is the output signal.
</p>
<p>In two dimensions the output for the analysis filter bank (<code>afb2D</code>) is
a list with four elements </p>
<table>
<tr><td><code>lo</code></td>
<td>
<p>low-pass subband</p>
</td></tr> <tr><td><code>hi[[1]]</code></td>
<td>
<p>'lohi'
subband</p>
</td></tr> <tr><td><code>hi[[2]]</code></td>
<td>
<p>'hilo' subband</p>
</td></tr> <tr><td><code>hi[[3]]</code></td>
<td>
<p>'hihi' subband</p>
</td></tr></table>
<p> and
the output for the synthesis filter bank (<code>sfb2D</code>) is the output array.
</p>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## EXAMPLE: afb, sfb
af = farras()$af
sf = farras()$sf
x = rnorm(64)
x.afb = afb(x, af)
lo = x.afb$lo
hi = x.afb$hi
y = sfb(lo, hi, sf)
err = x - y
max(abs(err))

## EXAMPLE: afb2D, sfb2D
x = matrix(rnorm(32*64), 32, 64)
af = farras()$af
sf = farras()$sf
x.afb2D = afb2D(x, af, af)
lo = x.afb2D$lo
hi = x.afb2D$hi
y = sfb2D(lo, hi, sf, sf)
err = x - y
max(abs(err))

## Example: afb2D.A, sfb2D.A
x = matrix(rnorm(32*64), 32, 64)
af = farras()$af
sf = farras()$sf
x.afb2D.A = afb2D.A(x, af, 1)
lo = x.afb2D.A$lo
hi = x.afb2D.A$hi
y = sfb2D.A(lo, hi, sf, 1)
err = x - y
max(abs(err))
</code></pre>

<hr>
<h2 id='ar1'>Simulated AR(1) Series</h2><span id='topic+ar1'></span>

<h3>Description</h3>

<p>Simulated AR(1) series used in Gencay, Selcuk and Whitcher (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ar1)
</code></pre>


<h3>Format</h3>

<p>A vector containing 200 observations.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='bandpass.var.spp'>Bandpass Variance for Long-Memory Processes</h2><span id='topic+bandpass.var.spp'></span><span id='topic+bandpass.fdp'></span><span id='topic+bandpass.spp'></span><span id='topic+bandpass.spp2'></span>

<h3>Description</h3>

<p>Computes the band-pass variance for fractional difference (FD) or seasonal
persistent (SP) processes using numeric integration of their spectral
density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandpass.fdp(a, b, d)

bandpass.spp(a, b, d, fG)

bandpass.spp2(a, b, d1, f1, d2, f2)

bandpass.var.spp(delta, fG, J, Basis, Length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandpass.var.spp_+3A_fg">fG</code>, <code id="bandpass.var.spp_+3A_f1">f1</code>, <code id="bandpass.var.spp_+3A_f2">f2</code></td>
<td>
<p>Gegenbauer frequency.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_j">J</code></td>
<td>
<p>Depth of the wavelet transform.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_basis">Basis</code></td>
<td>
<p>Logical vector representing the adaptive basis.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_length">Length</code></td>
<td>
<p>Number of elements in Basis.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_a">a</code></td>
<td>
<p>Left-hand boundary for the definite integral.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_b">b</code></td>
<td>
<p>Right-hand boundary for the definite integral.</p>
</td></tr>
<tr><td><code id="bandpass.var.spp_+3A_d">d</code>, <code id="bandpass.var.spp_+3A_delta">delta</code>, <code id="bandpass.var.spp_+3A_d1">d1</code>, <code id="bandpass.var.spp_+3A_d2">d2</code></td>
<td>
<p>Fractional difference parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references.
</p>


<h3>Value</h3>

<p>Band-pass variance for the FD or SP process between <code class="reqn">a</code> and
<code class="reqn">b</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>McCoy, E. J., and A. T. Walden (1996) Wavelet analysis and
synthesis of stationary long-memory processes, <em>Journal for
Computational and Graphical Statistics</em>, <b>5</b>, No. 1, 26-56.
</p>
<p>Whitcher, B. (2001) Simulating Gaussian stationary processes with unbounded
spectra, <em>Journal for Computational and Graphical Statistics</em>,
<b>10</b>, No. 1, 112-134.
</p>

<hr>
<h2 id='barbara'>Barbara Test Image</h2><span id='topic+barbara'></span>

<h3>Description</h3>

<p>The Barbara image comes from Allen Gersho's lab at the University of
California, Santa Barbara.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(barbara)
</code></pre>


<h3>Format</h3>

<p>A 256 <code class="reqn">\times</code> 256 matrix.
</p>


<h3>Source</h3>

<p>Internet.
</p>

<hr>
<h2 id='basis'>Produce Boolean Vector from Wavelet Basis Names</h2><span id='topic+basis'></span>

<h3>Description</h3>

<p>Produce a vector of zeros and ones from a vector of basis names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(x, basis.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_+3A_x">x</code></td>
<td>
<p>Output from the discrete wavelet package transfrom (DWPT).</p>
</td></tr>
<tr><td><code id="basis_+3A_basis.names">basis.names</code></td>
<td>
<p>Vector of character strings that describe leaves on the
DWPT basis tree.  See the examples below for appropriate syntax.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>Vector of zeros and ones.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwpt">dwpt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(acvs.andel8)
## Not run: 
x &lt;- hosking.sim(1024, acvs.andel8[,2])
x.dwpt &lt;- dwpt(x, "la8", 7)
## Select orthonormal basis from wavelet packet tree
x.basis &lt;- basis(x.dwpt, c("w1.1","w2.1","w3.0","w4.3","w5.4","w6.10",
                           "w7.22","w7.23"))
for(i in 1:length(x.dwpt))
  x.dwpt[[i]] &lt;- x.basis[i] * x.dwpt[[i]]
## Resonstruct original series using selected orthonormal basis
y &lt;- idwpt(x.dwpt, x.basis)
par(mfrow=c(2,1), mar=c(5-1,4,4-1,2))
plot.ts(x, xlab="", ylab="", main="Original Series")
plot.ts(y, xlab="", ylab="", main="Reconstructed Series")

## End(Not run)

</code></pre>

<hr>
<h2 id='blocks'>A Piecewise-Constant Function</h2><span id='topic+blocks'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">blocks(x) = \sum_{j=1}^{11}(1 + {\rm sign}(x-p_j)) h_j / 2</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(blocks)
</code></pre>


<h3>Format</h3>

<p>A vector containing 512 observations.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='brick.wall'>Replace Boundary Wavelet Coefficients with Missing Values</h2><span id='topic+brick.wall'></span><span id='topic+dwpt.brick.wall'></span><span id='topic+brick.wall.2d'></span>

<h3>Description</h3>

<p>Sets the first <code class="reqn">n</code> wavelet coefficients to <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brick.wall(x, wf, method = "modwt")

dwpt.brick.wall(x, wf, n.levels, method = "modwpt")

brick.wall.2d(x, method = "modwt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brick.wall_+3A_x">x</code></td>
<td>
<p>DWT/MODWT/DWPT/MODWPT object</p>
</td></tr>
<tr><td><code id="brick.wall_+3A_wf">wf</code></td>
<td>
<p>Character string; name of wavelet filter</p>
</td></tr>
<tr><td><code id="brick.wall_+3A_method">method</code></td>
<td>
<p>Either <code><a href="#topic+dwt">dwt</a></code> or <code><a href="#topic+modwt">modwt</a></code> for
<code>brick.wall</code>, or either <code><a href="#topic+dwpt">dwpt</a></code> or <code><a href="#topic+modwpt">modwpt</a></code> for
<code>dwpt.brick.wall</code></p>
</td></tr>
<tr><td><code id="brick.wall_+3A_n.levels">n.levels</code></td>
<td>
<p>Specifies the depth of the decomposition. This must be a
number less than or equal to log(length(x),2).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fact that observed time series are finite causes boundary issues.  One
way to get around this is to simply remove any wavelet coefficient computed
involving the boundary.  This is done here by replacing boundary wavelet
coefficients with <code>NA</code>.
</p>


<h3>Value</h3>

<p>Same object as <code>x</code> only with some missing values.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Lindsay, R. W., D. B. Percival and D. A. Rothrock (1996). The
discrete wavelet transform and the scale anlaysis of the surface properties
of sea ice, <em>IEEE Transactions on Geoscience and Remote Sensing</em>,
<b>34</b>, No. 3, 771-787.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>

<hr>
<h2 id='convolve2D'>Fast Column-wise Convolution of a Matrix</h2><span id='topic+convolve2D'></span>

<h3>Description</h3>

<p>Use the Fast Fourier Transform to perform convolutions between a sequence
and each column of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolve2D(x, y, conj = TRUE, type = c("circular", "open"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve2D_+3A_x">x</code></td>
<td>
<p>MxN matrix.</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_y">y</code></td>
<td>
<p>numeric sequence of length N.</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_conj">conj</code></td>
<td>
<p>logical; if <code>TRUE</code>, take the complex <em>conjugate</em>
before back-transforming (default, and used for usual convolution).</p>
</td></tr>
<tr><td><code id="convolve2D_+3A_type">type</code></td>
<td>
<p>character; one of <code>circular</code>, <code>open</code> (beginning of
word is ok).  For <code>circular</code>, the two sequences are treated as
<em>circular</em>, i.e., periodic.
</p>
<p>For <code>open</code> and <code>filter</code>, the sequences are padded with zeros (from
left and right) first; <code>filter</code> returns the middle sub-vector of
<code>open</code>, namely, the result of running a weighted mean of <code>x</code> with
weights <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a corrupted version of <code>convolve</code> made by replacing <code>fft</code>
with <code>mvfft</code> in a few places.  It would be nice to submit this to the R
Developers for inclusion.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+convolve">convolve</a></code>
</p>

<hr>
<h2 id='cpi'>U.S. Consumer Price Index</h2><span id='topic+cpi'></span>

<h3>Description</h3>

<p>Monthly U.S. consumer price index from 1948:1 to 1999:12.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cpi)
</code></pre>


<h3>Format</h3>

<p>A vector containing 624 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='cplxdual2D'>Dual-tree Complex 2D Discrete Wavelet Transform</h2><span id='topic+cplxdual2D'></span><span id='topic+icplxdual2D'></span>

<h3>Description</h3>

<p>Dual-tree complex 2D discrete wavelet transform (DWT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplxdual2D(x, J, Faf, af)

icplxdual2D(w, J, Fsf, sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplxdual2D_+3A_x">x</code></td>
<td>
<p>2D array.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_j">J</code></td>
<td>
<p>number of stages.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_faf">Faf</code></td>
<td>
<p>first stage analysis filters for tree i.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_af">af</code></td>
<td>
<p>analysis filters for the remaining stages on tree i.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_w">w</code></td>
<td>
<p>wavelet coefficients.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_fsf">Fsf</code></td>
<td>
<p>last stage synthesis filters for tree i.</p>
</td></tr>
<tr><td><code id="cplxdual2D_+3A_sf">sf</code></td>
<td>
<p>synthesis filters for the preceeding stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the analysis of <code>x</code>, the output is </p>
<table>
<tr><td><code>w</code></td>
<td>
<p>wavelet
coefficients indexed by <code>[[j]][[i]][[d1]][[d2]]</code>, where
<code class="reqn">j=1,\ldots,J</code> (scale), <code class="reqn">i=1</code> (real part) or <code class="reqn">i=2</code> (imag part),
<code class="reqn">d1=1,2</code> and <code class="reqn">d2=1,2,3</code> (orientations).</p>
</td></tr></table>
<p> For the synthesis of
<code>w</code>, the output is </p>
<table>
<tr><td><code>y</code></td>
<td>
<p>output signal.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FSfarras">FSfarras</a></code>, <code><a href="#topic+farras">farras</a></code>, <code><a href="#topic+afb2D">afb2D</a></code>,
<code><a href="#topic+sfb2D">sfb2D</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## EXAMPLE: cplxdual2D
x = matrix(rnorm(32*32), 32, 32)
J = 5
Faf = FSfarras()$af
Fsf = FSfarras()$sf
af = dualfilt1()$af
sf = dualfilt1()$sf
w = cplxdual2D(x, J, Faf, af)
y = icplxdual2D(w, J, Fsf, sf)
err = x - y
max(abs(err))

## End(Not run)

</code></pre>

<hr>
<h2 id='cshift'>Miscellaneous Functions for Dual-Tree Wavelet Software</h2><span id='topic+cshift'></span><span id='topic+cshift2D'></span><span id='topic+pm'></span>

<h3>Description</h3>

<p>Miscellaneous functions for dual-tree wavelet software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cshift(x, m)

cshift2D(x, m)

pm(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cshift_+3A_x">x</code></td>
<td>
<p>N-point vector</p>
</td></tr>
<tr><td><code id="cshift_+3A_m">m</code></td>
<td>
<p>amount of shift</p>
</td></tr>
<tr><td><code id="cshift_+3A_a">a</code>, <code id="cshift_+3A_b">b</code></td>
<td>
<p>input parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>y</code></td>
<td>
<p>vector <code>x</code> will be shifed by <code>m</code> samples to the
left or matrix <code>x</code> will be shifed by <code>m</code> samples down.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>(a + b) / sqrt(2)</p>
</td></tr> <tr><td><code>v</code></td>
<td>
<p>(a - b) / sqrt(2)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>

<hr>
<h2 id='css.test'>Testing the Wavelet Packet Tree for White Noise</h2><span id='topic+css.test'></span><span id='topic+cpgram.test'></span><span id='topic+entropy.test'></span><span id='topic+portmanteau.test'></span>

<h3>Description</h3>

<p>A wavelet packet tree, from the discrete wavelet packet transform (DWPT), is
tested node-by-node for white noise.  This is the first step in selecting an
orthonormal basis for the DWPT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpgram.test(y, p = 0.05, taper = 0.1)

css.test(y)

entropy.test(y)

portmanteau.test(y, p = 0.05, type = "Box-Pierce")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="css.test_+3A_y">y</code></td>
<td>
<p>wavelet packet tree (from the DWPT)</p>
</td></tr>
<tr><td><code id="css.test_+3A_p">p</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="css.test_+3A_taper">taper</code></td>
<td>
<p>weight of cosine bell taper (<code>cpgram.test</code> only)</p>
</td></tr>
<tr><td><code id="css.test_+3A_type">type</code></td>
<td>
<p><code>"Box-Pierce"</code> and <code>other</code> recognized
(<code>portmanteau.test</code> only)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Top-down recursive testing of the wavelet packet tree is
</p>


<h3>Value</h3>

<p>Boolean vector of the same length as the number of nodes in the
wavelet packet tree.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Brockwell and Davis (1991) <em>Time Series: Theory and
Methods</em>, (2nd. edition), Springer-Verlag.
</p>
<p>Brown, Durbin and Evans (1975) Techniques for testing the constancy of
regression relationships over time, <em>Journal of the Royal Statistical
Society B</em>, <b>37</b>, 149-163.
</p>
<p>Percival, D. B., and A. T. Walden (1993) <em>Spectral Analysis for
Physical Applications: Multitaper and Conventional Univariate Techniques</em>,
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ortho.basis">ortho.basis</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mexm)
J &lt;- 6
wf &lt;- "la8"
mexm.dwpt &lt;- dwpt(mexm[-c(1:4)], wf, J)
## Not implemented yet
## plot.dwpt(x.dwpt, J)
mexm.dwpt.bw &lt;- dwpt.brick.wall(mexm.dwpt, wf, 6, method="dwpt")
mexm.tree &lt;- ortho.basis(portmanteau.test(mexm.dwpt.bw, p=0.025))
## Not implemented yet
## plot.basis(mexm.tree)

</code></pre>

<hr>
<h2 id='dau'>Digital Photograph of Ingrid Daubechies</h2><span id='topic+dau'></span>

<h3>Description</h3>

<p>A digital photograph of Ingrid Daubechies taken at the 1993 AMS winter
meetings in San Antonio, Texas.  The photograph was taken by David Donoho
with a Canon XapShot video still frame camera.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dau)
</code></pre>


<h3>Format</h3>

<p>A 256 <code class="reqn">\times</code> 256 matrix.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='denoise.dwt.2d'>Denoise an Image via the 2D Discrete Wavelet Transform</h2><span id='topic+denoise.dwt.2d'></span><span id='topic+denoise.modwt.2d'></span>

<h3>Description</h3>

<p>Perform simple de-noising of an image using the two-dimensional discrete
wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoise.dwt.2d(
  x,
  wf = "la8",
  J = 4,
  method = "universal",
  H = 0.5,
  noise.dir = 3,
  rule = "hard"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="denoise.dwt.2d_+3A_x">x</code></td>
<td>
<p>input matrix (image)</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_wf">wf</code></td>
<td>
<p>name of the wavelet filter to use in the decomposition</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_j">J</code></td>
<td>
<p>depth of the decomposition, must be a number less than or equal to
log(minM,N,2)</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_method">method</code></td>
<td>
<p>character string describing the threshold applied, only
<code>"universal"</code> and <code>"long-memory"</code> are currently implemented</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_h">H</code></td>
<td>
<p>self-similarity or Hurst parameter to indicate spectral scaling,
white noise is 0.5</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_noise.dir">noise.dir</code></td>
<td>
<p>number of directions to estimate background noise standard
deviation, the default is 3 which produces a unique estimate of the
background noise for each spatial direction</p>
</td></tr>
<tr><td><code id="denoise.dwt.2d_+3A_rule">rule</code></td>
<td>
<p>either a <code>"hard"</code> or <code>"soft"</code> thresholding rule may be
used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Thresholding">Thresholding</a></code>.
</p>


<h3>Value</h3>

<p>Image of the same dimension as the original but with high-freqency
fluctuations removed.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>See <code><a href="#topic+Thresholding">Thresholding</a></code> for references concerning
de-noising in one dimension.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Thresholding">Thresholding</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Xbox image
data(xbox)
n &lt;- nrow(xbox)
xbox.noise &lt;- xbox + matrix(rnorm(n*n, sd=.15), n, n)
par(mfrow=c(2,2), cex=.8, pty="s")
image(xbox.noise, col=rainbow(128), main="Original Image")
image(denoise.dwt.2d(xbox.noise, wf="haar"), col=rainbow(128),
      zlim=range(xbox.noise), main="Denoised image")
image(xbox.noise - denoise.dwt.2d(xbox.noise, wf="haar"), col=rainbow(128),
      zlim=range(xbox.noise), main="Residual image")

## Daubechies image
data(dau)
n &lt;- nrow(dau)
dau.noise &lt;- dau + matrix(rnorm(n*n, sd=10), n, n)
par(mfrow=c(2,2), cex=.8, pty="s")
image(dau.noise, col=rainbow(128), main="Original Image")
dau.denoise &lt;- denoise.modwt.2d(dau.noise, wf="d4", rule="soft")
image(dau.denoise, col=rainbow(128), zlim=range(dau.noise),
      main="Denoised image")
image(dau.noise - dau.denoise, col=rainbow(128), main="Residual image")

</code></pre>

<hr>
<h2 id='doppler'>Sinusoid with Changing Amplitude and Frequency</h2><span id='topic+doppler'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">doppler(x) = \sqrt{x(1 - x)} </code>
</p>
<p style="text-align: center;"><code class="reqn"> \sin\left(\frac{2.1\pi}{x+0.05}\right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(doppler)
</code></pre>


<h3>Format</h3>

<p>A vector containing 512 observations.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='dpss.taper'>Calculating Thomson's Spectral Multitapers by Inverse Iteration</h2><span id='topic+dpss.taper'></span>

<h3>Description</h3>

<p>The following function links the subroutines in &quot;bell-p-w.o&quot; to an R
function in order to compute discrete prolate spheroidal sequences (dpss).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpss.taper(n, k, nw = 4, nmax = 2^(ceiling(log(n, 2))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpss.taper_+3A_n">n</code></td>
<td>
<p>length of data taper(s)</p>
</td></tr>
<tr><td><code id="dpss.taper_+3A_k">k</code></td>
<td>
<p>number of data tapers; 1, 2, 3, ... (do not use 0!)</p>
</td></tr>
<tr><td><code id="dpss.taper_+3A_nw">nw</code></td>
<td>
<p>product of length and half-bandwidth parameter (w)</p>
</td></tr>
<tr><td><code id="dpss.taper_+3A_nmax">nmax</code></td>
<td>
<p>maximum possible taper length, necessary for FORTRAN code</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spectral estimation using a set of orthogonal tapers is becoming widely used
and appreciated in scientific research.  It produces direct spectral
estimates with more than 2 df at each Fourier frequency, resulting in
spectral estimators with reduced variance.  Computation of the orthogonal
tapers from the basic defining equation is difficult, however, due to the
instability of the calculations &ndash; the eigenproblem is very poorly
conditioned.  In this article the severe numerical instability problems are
illustrated and then a technique for stable calculation of the tapers &ndash;
namely, inverse iteration &ndash; is described. Each iteration involves the
solution of a matrix equation.  Because the matrix has Toeplitz form, the
Levinson recursions are used to rapidly solve the matrix equation.  FORTRAN
code for this method is available through the Statlib archive.  An
alternative stable method is also briefly reviewed.
</p>


<h3>Value</h3>

<table>
<tr><td><code>v</code></td>
<td>
<p>matrix of data tapers (cols = tapers)</p>
</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p>eigenvalue associated with each data taper</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>total
number of iterations performed</p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p>same as input</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>half-bandwidth parameter</p>
</td></tr> <tr><td><code>ifault</code></td>
<td>
<p>0 indicates success, see
documentation for &quot;bell-p-w&quot; for information on non-zero values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>B. Bell, D. B. Percival, and A. T. Walden (1993) Calculating
Thomson's spectral multitapers by inverse iteration, <em>Journal of
Computational and Graphical Statistics</em>, <b>2</b>, No. 1, 119-130.
</p>
<p>Percival, D. B. and A. T. Walden (1993) <em>Spectral Estimation for
Physical Applications: Multitaper and Conventional Univariate Techniques</em>,
Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sine.taper">sine.taper</a></code>.
</p>

<hr>
<h2 id='dualfilt1'>Kingsbury's Q-filters for the Dual-Tree Complex DWT</h2><span id='topic+dualfilt1'></span><span id='topic+AntonB'></span>

<h3>Description</h3>

<p>Kingsbury's Q-filters for the dual-tree complex DWT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dualfilt1()
</code></pre>


<h3>Details</h3>

<p>These cofficients are rounded to 8 decimal places.
</p>


<h3>Value</h3>

<table>
<tr><td><code>af</code></td>
<td>
<p>List (i=1,2) - analysis filters for tree i</p>
</td></tr> <tr><td><code>sf</code></td>
<td>
<p>List
(i=1,2) - synthesis filters for tree i</p>
</td></tr></table>
<p> Note: <code>af[[2]]</code> is the reverse
of <code>af[[1]]</code>.
</p>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>


<h3>References</h3>

<p>Kingsbury, N.G. (2000).  A dual-tree complex wavelet transform
with improved orthogonality and symmetry properties, <em>Proceedings of
the IEEE Int. Conf. on Image Proc.</em> (ICIP).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dualtree">dualtree</a></code>
</p>

<hr>
<h2 id='dualtree'>Dual-tree Complex Discrete Wavelet Transform</h2><span id='topic+dualtree'></span><span id='topic+idualtree'></span><span id='topic+dualtree2D'></span><span id='topic+idualtree2D'></span>

<h3>Description</h3>

<p>One- and two-dimensional dual-tree complex discrete wavelet transforms
developed by Kingsbury and Selesnick <em>et al.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dualtree(x, J, Faf, af)

idualtree(w, J, Fsf, sf)

dualtree2D(x, J, Faf, af)

idualtree2D(w, J, Fsf, sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dualtree_+3A_x">x</code></td>
<td>
<p>N-point vector or MxN matrix.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_j">J</code></td>
<td>
<p>number of stages.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_faf">Faf</code></td>
<td>
<p>analysis filters for the first stage.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_af">af</code></td>
<td>
<p>analysis filters for the remaining stages.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_w">w</code></td>
<td>
<p>DWT coefficients.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_fsf">Fsf</code></td>
<td>
<p>synthesis filters for the last stage.</p>
</td></tr>
<tr><td><code id="dualtree_+3A_sf">sf</code></td>
<td>
<p>synthesis filters for the preceeding stages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In one dimension <code class="reqn">N</code> is divisible by <code class="reqn">2^J</code> and
<code class="reqn">N\ge2^{J-1}\cdot\mbox{length}(\mbox{\code{af}})</code>.
</p>
<p>In two dimensions, these two conditions must hold for both <code class="reqn">M</code> and
<code class="reqn">N</code>.
</p>


<h3>Value</h3>

<p>For the analysis of <code>x</code>, the output is </p>
<table>
<tr><td><code>w</code></td>
<td>
<p>DWT
coefficients.  Each wavelet scale is a list containing the real and
imaginary parts.  The final scale (J+1) contains the low-pass filter
coefficients.</p>
</td></tr></table>
<p> For the synthesis of <code>w</code>, the output is </p>
<table>
<tr><td><code>y</code></td>
<td>
<p>output
signal</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FSfarras">FSfarras</a></code>, <code><a href="#topic+farras">farras</a></code>,
<code><a href="stats.html#topic+convolve">convolve</a></code>, <code><a href="#topic+cshift">cshift</a></code>, <code><a href="#topic+afb">afb</a></code>,
<code><a href="#topic+sfb">sfb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## EXAMPLE: dualtree
x = rnorm(512)
J = 4
Faf = FSfarras()$af
Fsf = FSfarras()$sf
af = dualfilt1()$af
sf = dualfilt1()$sf
w = dualtree(x, J, Faf, af)
y = idualtree(w, J, Fsf, sf)
err = x - y
max(abs(err))

## Example: dualtree2D
x = matrix(rnorm(64*64), 64, 64)
J = 3
Faf = FSfarras()$af
Fsf = FSfarras()$sf
af = dualfilt1()$af
sf = dualfilt1()$sf
w = dualtree2D(x, J, Faf, af)
y = idualtree2D(w, J, Fsf, sf)
err = x - y
max(abs(err))

## Display 2D wavelets of dualtree2D.m

J &lt;- 4
L &lt;- 3 * 2^(J+1)
N &lt;- L / 2^J
Faf &lt;- FSfarras()$af
Fsf &lt;- FSfarras()$sf
af &lt;- dualfilt1()$af
sf &lt;- dualfilt1()$sf
x &lt;- matrix(0, 2*L, 3*L)
w &lt;- dualtree2D(x, J, Faf, af)
w[[J]][[1]][[1]][N/2, N/2+0*N] &lt;- 1
w[[J]][[1]][[2]][N/2, N/2+1*N] &lt;- 1
w[[J]][[1]][[3]][N/2, N/2+2*N] &lt;- 1
w[[J]][[2]][[1]][N/2+N, N/2+0*N] &lt;- 1
w[[J]][[2]][[2]][N/2+N, N/2+1*N] &lt;- 1
w[[J]][[2]][[3]][N/2+N, N/2+2*N] &lt;- 1
y &lt;- idualtree2D(w, J, Fsf, sf)
image(t(y), col=grey(0:64/64), axes=FALSE)

</code></pre>

<hr>
<h2 id='dwpt'>(Inverse) Discrete Wavelet Packet Transforms</h2><span id='topic+dwpt'></span><span id='topic+idwpt'></span><span id='topic+modwpt'></span>

<h3>Description</h3>

<p>All possible filtering combinations (low- and high-pass) are performed to
decompose a vector or time series.  The resulting coefficients are
associated with a binary tree structure corresponding to a partitioning of
the frequency axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwpt(x, wf = "la8", n.levels = 4, boundary = "periodic")

idwpt(y, y.basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwpt_+3A_x">x</code></td>
<td>
<p>a vector or time series containing the data be to decomposed. This
must be a dyadic length vector (power of 2).</p>
</td></tr>
<tr><td><code id="dwpt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition. By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length L=8 (Daubechies, 1992), least asymmetric family.</p>
</td></tr>
<tr><td><code id="dwpt_+3A_n.levels">n.levels</code></td>
<td>
<p>Specifies the depth of the decomposition.This must be a
number less than or equal to
<code class="reqn">\log(\mbox{length}(x),2)</code>.</p>
</td></tr>
<tr><td><code id="dwpt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition. If
<code>boundary=="periodic"</code> the default, then the vector you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the vector beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="dwpt_+3A_y">y</code></td>
<td>
<p>Object of S3 class <code>dwpt</code>.</p>
</td></tr>
<tr><td><code id="dwpt_+3A_y.basis">y.basis</code></td>
<td>
<p>Vector of character strings that describe leaves on the DWPT 
basis tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements the one-dimensional DWPT using the pyramid algorithm
(Mallat, 1989).
</p>


<h3>Value</h3>

<p>Basically, a list with the following components 
</p>
<table>
<tr><td><code>w?.?</code></td>
<td>
<p>Wavelet coefficient vectors.  The first index is associated with 
the scale of the decomposition while the second is associated with the 
frequency partition within that level.</p>
</td></tr> 
<tr><td><code>wavelet</code></td>
<td>
<p>Name of the wavelet filter used.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal
decomposition: the wavelet representation, <em>IEEE Transactions on
Pattern Analysis and Machine Intelligence</em>, <b>11</b>(7), 674&ndash;693.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>
<p>Wickerhauser, M. V. (1994) <em>Adapted Wavelet Analysis from Theory to
Software</em>, A K Peters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>, <code><a href="#topic+modwpt">modwpt</a></code>, <code><a href="#topic+wave.filter">wave.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mexm)
J &lt;- 4
mexm.mra &lt;- mra(log(mexm), "mb8", J, "modwt", "reflection")
mexm.nomean &lt;- ts(
  apply(matrix(unlist(mexm.mra), ncol=J+1, byrow=FALSE)[,-(J+1)], 1, sum), 
  start=1957, freq=12)
mexm.dwpt &lt;- dwpt(mexm.nomean[-c(1:4)], "mb8", 7, "reflection")

</code></pre>

<hr>
<h2 id='dwpt.2d'>(Inverse) Discrete Wavelet Packet Transforms in Two Dimensions</h2><span id='topic+dwpt.2d'></span><span id='topic+idwpt.2d'></span>

<h3>Description</h3>

<p>All possible filtering combinations (low- and high-pass) are performed to
decompose a matrix or image.  The resulting coefficients are associated with
a quad-tree structure corresponding to a partitioning of the two-dimensional
frequency plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwpt.2d(x, wf = "la8", J = 4, boundary = "periodic")

idwpt.2d(y, y.basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwpt.2d_+3A_x">x</code></td>
<td>
<p>a matrix or image containing the data be to decomposed.  This
ojbect must be dyadic (power of 2) in length in each dimension.</p>
</td></tr>
<tr><td><code id="dwpt.2d_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length <code class="reqn">L=8</code> (Daubechies, 1992), least asymmetric
family.</p>
</td></tr>
<tr><td><code id="dwpt.2d_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a number
less than or equal to <code class="reqn">\log(\mbox{length}(x),2)</code>.</p>
</td></tr>
<tr><td><code id="dwpt.2d_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the default, then the vector you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the vector beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="dwpt.2d_+3A_y">y</code></td>
<td>
<p><code>dwpt.2d</code> object (list-based structure of matrices)</p>
</td></tr>
<tr><td><code id="dwpt.2d_+3A_y.basis">y.basis</code></td>
<td>
<p>Boolean vector, the same length as <code class="reqn">y</code>, where <code>TRUE</code>
means the basis tensor should be used in the reconstruction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements the two-dimensional DWPT using the pyramid algorithm of
Mallat (1989).
</p>


<h3>Value</h3>

<p>Basically, a list with the following components
</p>
<table>
<tr><td><code>w?.?-w?.?</code></td>
<td>
<p>Wavelet coefficient matrices (images).  The first index is
associated with the scale of the decomposition while the second is
associated with the frequency partition within that level.  The left and
right strings, separated by the dash &lsquo;-&rsquo;, correspond to the first <code class="reqn">(x)</code>
and second <code class="reqn">(y)</code> dimensions.</p>
</td></tr> <tr><td><code>wavelet</code></td>
<td>
<p>Name of the wavelet filter
used.</p>
</td></tr> <tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal
decomposition: the wavelet representation, <em>IEEE Transactions on
Pattern Analysis and Machine Intelligence</em>, <b>11</b>, No. 7, 674-693.
</p>
<p>Wickerhauser, M. V. (1994) <em>Adapted Wavelet Analysis from Theory to
Software</em>, A K Peters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt.2d">dwt.2d</a></code>, <code><a href="#topic+modwt.2d">modwt.2d</a></code>,
<code><a href="#topic+wave.filter">wave.filter</a></code>.
</p>

<hr>
<h2 id='dwpt.boot'>Bootstrap Time Series Using the DWPT</h2><span id='topic+dwpt.boot'></span>

<h3>Description</h3>

<p>An adaptive orthonormal basis is selected in order to perform the naive
bootstrap within nodes of the wavelet packet tree.  A bootstrap realization
of the time series is produce by applying the inverse DWPT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwpt.boot(y, wf, J = log(length(y), 2) - 1, p = 1e-04, frac = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwpt.boot_+3A_y">y</code></td>
<td>
<p>Not necessarily dyadic length time series.</p>
</td></tr>
<tr><td><code id="dwpt.boot_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  See
<code><a href="#topic+wave.filter">wave.filter</a></code> for those wavelet filters available.</p>
</td></tr>
<tr><td><code id="dwpt.boot_+3A_j">J</code></td>
<td>
<p>Depth of the discrete wavelet packet transform.</p>
</td></tr>
<tr><td><code id="dwpt.boot_+3A_p">p</code></td>
<td>
<p>Level of significance for the white noise testing procedure.</p>
</td></tr>
<tr><td><code id="dwpt.boot_+3A_frac">frac</code></td>
<td>
<p>Fraction of the time series that should be used in constructing
the likelihood function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A subroutines is used to select an adaptive orthonormal basis for the
piecewise-constant approximation to the underlying spectral density function
(SDF).  Once selected, sampling with replacement is performed within each
wavelet packet coefficient vector and the new collection of wavelet packet
coefficients are reconstructed into a bootstrap realization of the original
time series.
</p>


<h3>Value</h3>

<p>Time series of length $N$, where $N$ is the length of <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Percival, D.B., S. Sardy, A. Davision (2000) Wavestrapping Time
Series: Adaptive Wavelet-Based Bootstrapping, in B.J. Fitzgerald, R.L.
Smith, A.T. Walden, P.C. Young (Eds.)  <em>Nonlinear and Nonstationary
Signal Processing</em>, pp. 442-471.
</p>
<p>Whitcher, B. (2001) Simulating Gaussian Stationary Time Series with
Unbounded Spectra, <em>Journal of Computational and Graphical Statistics</em>,
<b>10</b>, No. 1, 112-134.
</p>
<p>Whitcher, B. (2004) Wavelet-Based Estimation for Seasonal Long-Memory
Processes, <em>Technometrics</em>, <b>46</b>, No. 2, 225-238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwpt.sim">dwpt.sim</a></code>, <code><a href="#topic+spp.mle">spp.mle</a></code>
</p>

<hr>
<h2 id='dwpt.sim'>Simulate Seasonal Persistent Processes Using the DWPT</h2><span id='topic+dwpt.sim'></span>

<h3>Description</h3>

<p>A seasonal persistent process may be characterized by a spectral density
function with an asymptote occuring at a particular frequency in
[0,1/2).  It's time domain representation was first
noted in passing by Hosking (1981).  Although an exact time-domain approach
to simulation is possible, this function utilizes the discrete wavelet
packet transform (DWPT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwpt.sim(N, wf, delta, fG, M = 2, adaptive = TRUE, epsilon = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwpt.sim_+3A_n">N</code></td>
<td>
<p>Length of time series to be generated.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_wf">wf</code></td>
<td>
<p>Character string for the wavelet filter.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_delta">delta</code></td>
<td>
<p>Long-memory parameter for the seasonal persistent process.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_fg">fG</code></td>
<td>
<p>Gegenbauer frequency.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_m">M</code></td>
<td>
<p>Actual length of simulated time series.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical; if <code>TRUE</code> the orthonormal basis used in the
DWPT is adapted to the ideal spectrum, otherwise the orthonormal basis is
performed to a maximum depth.</p>
</td></tr>
<tr><td><code id="dwpt.sim_+3A_epsilon">epsilon</code></td>
<td>
<p>Threshold for adaptive basis selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two subroutines are used, the first selects an adaptive orthonormal basis
for the true spectral density function (SDF) while the second computes the
bandpass variances associated with the chosen orthonormal basis and SDF.
Finally, when <code>M</code> &gt; <code>N</code> a uniform random variable is
generated in order to select a random piece of the simulated time series.
For more details see Whitcher (2001).
</p>


<h3>Value</h3>

<p>Time series of length <code>N</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Hosking, J. R. M. (1981) Fractional Differencing,
<em>Biometrika</em>, <b>68</b>, No. 1, 165-176.
</p>
<p>Whitcher, B. (2001) Simulating Gaussian Stationary Time Series with
Unbounded Spectra, <em>Journal of Computational and Graphical Statistics</em>,
<b>10</b>, No. 1, 112-134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hosking.sim">hosking.sim</a></code> for an exact time-domain method and
<code><a href="#topic+wave.filter">wave.filter</a></code> for a list of available wavelet filters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate monthly time series with annual oscillation
## library(ts) is required in order to access acf()
x &lt;- dwpt.sim(256, "mb16", .4, 1/12, M=4, epsilon=.001)
par(mfrow=c(2,1))
plot(x, type="l", xlab="Time")
acf(x, lag.max=128, ylim=c(-.6,1))
data(acvs.andel8)
lines(acvs.andel8$lag[1:128], acvs.andel8$acf[1:128], col=2)

</code></pre>

<hr>
<h2 id='dwt'>Discrete Wavelet Transform (DWT)</h2><span id='topic+dwt'></span><span id='topic+dwt.nondyadic'></span><span id='topic+idwt'></span>

<h3>Description</h3>

<p>This function performs a level <code class="reqn">J</code> decomposition of the input vector or
time series using the pyramid algorithm (Mallat 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt(x, wf = "la8", n.levels = 4, boundary = "periodic")

dwt.nondyadic(x)

idwt(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt_+3A_x">x</code></td>
<td>
<p>a vector or time series containing the data be to decomposed.  This
must be a dyadic length vector (power of 2).</p>
</td></tr>
<tr><td><code id="dwt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length L=8 (Daubechies, 1992), least asymmetric family.</p>
</td></tr>
<tr><td><code id="dwt_+3A_n.levels">n.levels</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a
number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="dwt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the default, then the vector you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the vector beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="dwt_+3A_y">y</code></td>
<td>
<p>An object of S3 class <code>dwt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements the one-dimensional DWT using the pyramid algorithm
(Mallat, 1989).  The actual transform is performed in C using pseudocode
from Percival and Walden (2001).  That means convolutions, not inner
products, are used to apply the wavelet filters.
</p>
<p>For a non-dyadic length vector or time series, <code>dwt.nondyadic</code> pads
with zeros, performs the orthonormal DWT on this dyadic length series and
then truncates the wavelet coefficient vectors appropriately.
</p>


<h3>Value</h3>

<p>Basically, a list with the following components 
</p>
<table>
<tr><td><code>d?</code></td>
<td>
<p>Wavelet coefficient vectors.</p>
</td></tr> 
<tr><td><code>s?</code></td>
<td>
<p>Scaling coefficient vector.</p>
</td></tr>
<tr><td><code>wavelet</code></td>
<td>
<p>Name of the wavelet filter used.</p>
</td></tr> 
<tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Daubechies, I. (1992) <em>Ten Lectures on Wavelets</em>, CBMS-NSF
Regional Conference Series in Applied Mathematics, SIAM: Philadelphia.
</p>
<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An Introduction to
Wavelets and Other Filtering Methods in Finance and Economics</em>, Academic
Press.
</p>
<p>Mallat, S. G. (1989) A theory for multiresolution signal decomposition: the
wavelet representation, <em>IEEE Transactions on Pattern Analysis and
Machine Intelligence</em>, <b>11</b>(7), 674&ndash;693.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modwt">modwt</a></code>, <code><a href="#topic+mra">mra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figures 4.17 and 4.18 in Gencay, Selcuk and Whitcher (2001).
data(ibm)     
ibm.returns &lt;- diff(log(ibm))
## Haar
ibmr.haar &lt;- dwt(ibm.returns, "haar")
names(ibmr.haar) &lt;- c("w1", "w2", "w3", "w4", "v4")
## plot partial Haar DWT for IBM data
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.returns, axes=FALSE, ylab="", main="(a)")
for(i in 1:4)
  plot.ts(up.sample(ibmr.haar[[i]], 2^i), type="h", axes=FALSE,
          ylab=names(ibmr.haar)[i])
plot.ts(up.sample(ibmr.haar$v4, 2^4), type="h", axes=FALSE,
        ylab=names(ibmr.haar)[5])
axis(side=1, at=seq(0,368,by=23), 
     labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))
## LA(8)
ibmr.la8 &lt;- dwt(ibm.returns, "la8")
names(ibmr.la8) &lt;- c("w1", "w2", "w3", "w4", "v4")
## must shift LA(8) coefficients
ibmr.la8$w1 &lt;- c(ibmr.la8$w1[-c(1:2)], ibmr.la8$w1[1:2])
ibmr.la8$w2 &lt;- c(ibmr.la8$w2[-c(1:2)], ibmr.la8$w2[1:2])
for(i in names(ibmr.la8)[3:4])
  ibmr.la8[[i]] &lt;- c(ibmr.la8[[i]][-c(1:3)], ibmr.la8[[i]][1:3])
ibmr.la8$v4 &lt;- c(ibmr.la8$v4[-c(1:2)], ibmr.la8$v4[1:2])
## plot partial LA(8) DWT for IBM data
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.returns, axes=FALSE, ylab="", main="(b)")
for(i in 1:4)
  plot.ts(up.sample(ibmr.la8[[i]], 2^i), type="h", axes=FALSE,
          ylab=names(ibmr.la8)[i])
plot.ts(up.sample(ibmr.la8$v4, 2^4), type="h", axes=FALSE,
        ylab=names(ibmr.la8)[5])
axis(side=1, at=seq(0,368,by=23), 
  labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))

</code></pre>

<hr>
<h2 id='dwt.2d'>Two-Dimensional Discrete Wavelet Transform</h2><span id='topic+dwt.2d'></span><span id='topic+idwt.2d'></span>

<h3>Description</h3>

<p>Performs a separable two-dimensional discrete wavelet transform (DWT) on a
matrix of dyadic dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.2d(x, wf, J = 4, boundary = "periodic")

idwt.2d(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.2d_+3A_x">x</code></td>
<td>
<p>input matrix (image)</p>
</td></tr>
<tr><td><code id="dwt.2d_+3A_wf">wf</code></td>
<td>
<p>name of the wavelet filter to use in the decomposition</p>
</td></tr>
<tr><td><code id="dwt.2d_+3A_j">J</code></td>
<td>
<p>depth of the decomposition, must be a number less than or equal to
log(minM,N,2)</p>
</td></tr>
<tr><td><code id="dwt.2d_+3A_boundary">boundary</code></td>
<td>
<p>only <code>"periodic"</code> is currently implemented</p>
</td></tr>
<tr><td><code id="dwt.2d_+3A_y">y</code></td>
<td>
<p>an object of class <code>dwt.2d</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references.
</p>


<h3>Value</h3>

<p>List structure containing the <code class="reqn">3J+1</code> sub-matrices from the
decomposition.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mallat, S. (1998) <em>A Wavelet Tour of Signal Processing</em>,
Academic Press.
</p>
<p>Vetterli, M. and J. Kovacevic (1995) <em>Wavelets and Subband Coding</em>,
Prentice Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modwt.2d">modwt.2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Xbox image
data(xbox)
xbox.dwt &lt;- dwt.2d(xbox, "haar", 3)
par(mfrow=c(1,1), pty="s")
plot.dwt.2d(xbox.dwt)
par(mfrow=c(2,2), pty="s")
image(1:dim(xbox)[1], 1:dim(xbox)[2], xbox, xlab="", ylab="",
      main="Original Image")
image(1:dim(xbox)[1], 1:dim(xbox)[2], idwt.2d(xbox.dwt), xlab="", ylab="",
      main="Wavelet Reconstruction")
image(1:dim(xbox)[1], 1:dim(xbox)[2], xbox - idwt.2d(xbox.dwt),
      xlab="", ylab="", main="Difference")

## Daubechies image
data(dau)
par(mfrow=c(1,1), pty="s")
image(dau, col=rainbow(128))
sum(dau^2)
dau.dwt &lt;- dwt.2d(dau, "d4", 3)
plot.dwt.2d(dau.dwt)
sum(plot.dwt.2d(dau.dwt, plot=FALSE)^2)

</code></pre>

<hr>
<h2 id='dwt.3d'>Three Dimensional Separable Discrete Wavelet Transform</h2><span id='topic+dwt.3d'></span><span id='topic+idwt.3d'></span>

<h3>Description</h3>

<p>Three-dimensional separable discrete wavelet transform (DWT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.3d(x, wf, J = 4, boundary = "periodic")

idwt.3d(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.3d_+3A_x">x</code></td>
<td>
<p>input array</p>
</td></tr>
<tr><td><code id="dwt.3d_+3A_wf">wf</code></td>
<td>
<p>name of the wavelet filter to use in the decomposition</p>
</td></tr>
<tr><td><code id="dwt.3d_+3A_j">J</code></td>
<td>
<p>depth of the decomposition, must be a number less than or equal to
log(minZ,Y,Z,2)</p>
</td></tr>
<tr><td><code id="dwt.3d_+3A_boundary">boundary</code></td>
<td>
<p>only <code>"periodic"</code> is currently implemented</p>
</td></tr>
<tr><td><code id="dwt.3d_+3A_y">y</code></td>
<td>
<p>an object of class <code>dwt.3d</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>

<hr>
<h2 id='dwt.hilbert'>Discrete Hilbert Wavelet Transforms</h2><span id='topic+dwt.hilbert'></span><span id='topic+dwt.hilbert.nondyadic'></span><span id='topic+idwt.hilbert'></span><span id='topic+modwt.hilbert'></span><span id='topic+imodwt.hilbert'></span><span id='topic+modwpt.hilbert'></span>

<h3>Description</h3>

<p>The discrete Hilbert wavelet transforms (DHWTs) for seasonal and
time-varying time series analysis.  Transforms include the usual orthogonal
(decimated), maximal-overlap (non-decimated) and maximal-overlap packet
transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt.hilbert(x, wf, n.levels = 4, boundary = "periodic", ...)

dwt.hilbert.nondyadic(x, ...)

idwt.hilbert(y)

modwt.hilbert(x, wf, n.levels = 4, boundary = "periodic", ...)

imodwt.hilbert(y)

modwpt.hilbert(x, wf, n.levels = 4, boundary = "periodic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwt.hilbert_+3A_x">x</code></td>
<td>
<p>Real-valued time series or vector of observations.</p>
</td></tr>
<tr><td><code id="dwt.hilbert_+3A_wf">wf</code></td>
<td>
<p>Hilbert wavelet pair</p>
</td></tr>
<tr><td><code id="dwt.hilbert_+3A_n.levels">n.levels</code></td>
<td>
<p>Number of levels (depth) of the wavelet transform.</p>
</td></tr>
<tr><td><code id="dwt.hilbert_+3A_boundary">boundary</code></td>
<td>
<p>Boundary treatment, currently only <code>periodic</code> and
<code>reflection</code>.</p>
</td></tr>
<tr><td><code id="dwt.hilbert_+3A_...">...</code></td>
<td>
<p>Additional parametes to be passed on.</p>
</td></tr>
<tr><td><code id="dwt.hilbert_+3A_y">y</code></td>
<td>
<p>An object of S3 class <code>dwt.hilbert</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hilbert wavelet transform object (list).
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Selesnick, I. (200X). <em>IEEE Signal Processing Magazine</em>
</p>
<p>Selesnick, I. (200X). <em>IEEE Transactions in Signal Processing</em>
</p>
<p>Whither, B. and P.F. Craigmile (2004). Multivariate Spectral Analysis Using
Hilbert Wavelet Pairs, <em>International Journal of Wavelets,
Multiresolution and Information Processing</em>, <b>2</b>(4), 567&ndash;587.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hilbert.filter">hilbert.filter</a></code>
</p>

<hr>
<h2 id='exchange'>Exchange Rates Between the Deutsche Mark, Japanese Yen and U.S. Dollar</h2><span id='topic+exchange'></span>

<h3>Description</h3>

<p>Monthly foreign exchange rates for the Deutsche Mark - U.S. Dollar (DEM-USD)
and Japanese Yen - U.S. Dollar (JPY-USD) starting in 1970.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exchange)
</code></pre>


<h3>Format</h3>

<p>A bivariate time series containing 348 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='fdp.mle'>Wavelet-based Maximum Likelihood Estimation for a Fractional Difference
Process</h2><span id='topic+fdp.mle'></span>

<h3>Description</h3>

<p>Parameter estimation for a fractional difference (long-memory, self-similar)
process is performed via maximum likelihood on the wavelet coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdp.mle(y, wf, J = log(length(y), 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdp.mle_+3A_y">y</code></td>
<td>
<p>Dyadic length time series.</p>
</td></tr>
<tr><td><code id="fdp.mle_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  See
<code><a href="#topic+wave.filter">wave.filter</a></code> for those wavelet filters available.</p>
</td></tr>
<tr><td><code id="fdp.mle_+3A_j">J</code></td>
<td>
<p>Depth of the discrete wavelet transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of the original time series is approximated
by its wavelet-based equivalent.  A Whittle-type likelihood is then
constructed where the sums of squared wavelet coefficients are compared to
bandpass filtered version of the true spectrum.  Minimization occurs only
for the fractional difference parameter <code class="reqn">d</code>, while variance is estimated
afterwards.
</p>


<h3>Value</h3>

<p>List containing the maximum likelihood estimates (MLEs) of <code class="reqn">d</code>
and <code class="reqn">\sigma^2</code>, along with the value of the likelihood for those
estimates.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>M. J. Jensen (2000) An alternative maximum likelihood estimator
of long-memory processes using compactly supported wavelets, <em>Journal
of Economic Dynamics and Control</em>, <b>24</b>, No. 3, 361-387.
</p>
<p>McCoy, E. J., and A. T. Walden (1996) Wavelet analysis and synthesis of
stationary long-memory processes, <em>Journal for Computational and
Graphical Statistics</em>, <b>5</b>, No. 1, 26-56.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figure 5.5 in Gencay, Selcuk and Whitcher (2001)
fdp.sdf &lt;- function(freq, d, sigma2=1)
  sigma2 / ((2*sin(pi * freq))^2)^d
dB &lt;- function(x) 10 * log10(x)
per &lt;- function(z) {
  n &lt;- length(z)
  (Mod(fft(z))**2/(2*pi*n))[1:(n %/% 2 + 1)]
}
data(ibm)     
ibm.returns &lt;- diff(log(ibm))
ibm.volatility &lt;- abs(ibm.returns)
ibm.vol.mle &lt;- fdp.mle(ibm.volatility, "d4", 4)
freq &lt;- 0:184/368
ibm.vol.per &lt;- 2 * pi * per(ibm.volatility)
ibm.vol.resid &lt;- ibm.vol.per/ fdp.sdf(freq, ibm.vol.mle$parameters[1])
par(mfrow=c(1,1), las=0, pty="m")
plot(freq, dB(ibm.vol.per), type="l", xlab="Frequency", ylab="Spectrum")
lines(freq, dB(fdp.sdf(freq, ibm.vol.mle$parameters[1],
                       ibm.vol.mle$parameters[2]/2)), col=2)

</code></pre>

<hr>
<h2 id='fdp.sdf'>Spectral Density Functions for Long-Memory Processes</h2><span id='topic+fdp.sdf'></span><span id='topic+spp.sdf'></span><span id='topic+spp2.sdf'></span><span id='topic+sfd.sdf'></span>

<h3>Description</h3>

<p>Draws the spectral density functions (SDFs) for standard long-memory
processes including fractional difference (FD), seasonal persistent (SP),
and seasonal fractional difference (SFD) processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdp.sdf(freq, d, sigma2 = 1)

spp.sdf(freq, d, fG, sigma2 = 1)

spp2.sdf(freq, d1, f1, d2, f2, sigma2 = 1)

sfd.sdf(freq, s, d, sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdp.sdf_+3A_freq">freq</code></td>
<td>
<p>vector of frequencies, normally from 0 to 0.5</p>
</td></tr>
<tr><td><code id="fdp.sdf_+3A_d">d</code>, <code id="fdp.sdf_+3A_d1">d1</code>, <code id="fdp.sdf_+3A_d2">d2</code></td>
<td>
<p>fractional difference parameter</p>
</td></tr>
<tr><td><code id="fdp.sdf_+3A_sigma2">sigma2</code></td>
<td>
<p>innovations variance</p>
</td></tr>
<tr><td><code id="fdp.sdf_+3A_fg">fG</code>, <code id="fdp.sdf_+3A_f1">f1</code>, <code id="fdp.sdf_+3A_f2">f2</code></td>
<td>
<p>Gegenbauer frequency</p>
</td></tr>
<tr><td><code id="fdp.sdf_+3A_s">s</code></td>
<td>
<p>seasonal parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The power spectrum from an FD, SP or SFD process.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdp.mle">fdp.mle</a></code>, <code><a href="#topic+spp.mle">spp.mle</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dB &lt;- function(x) 10 * log10(x)

fdp.main &lt;- expression(paste("FD", group("(",d==0.4,")")))
sfd.main &lt;- expression(paste("SFD", group("(",list(s==12, d==0.4),")")))
spp.main &lt;- expression(paste("SPP",
    group("(",list(delta==0.4, f[G]==1/12),")")))

freq &lt;- 0:512/1024

par(mfrow=c(2,2), mar=c(5-1,4,4-1,2), col.main="darkred")
plot(freq, dB(fdp.sdf(freq, .4)), type="l", xlab="frequency",
     ylab="spectrum (dB)", main=fdp.main)
plot(freq, dB(spp.sdf(freq, .4, 1/12)), type="l", xlab="frequency",
     ylab="spectrum (dB)", font.main=1, main=spp.main)
plot(freq, dB(sfd.sdf(freq, 12, .4)), type="l", xlab="frequency",
     ylab="spectrum (dB)", main=sfd.main)
</code></pre>

<hr>
<h2 id='find.adaptive.basis'>Determine an Orthonormal Basis for the Discrete Wavelet Packet Transform</h2><span id='topic+find.adaptive.basis'></span>

<h3>Description</h3>

<p>Subroutine for use in simulating seasonal persistent processes using the
discrete wavelet packet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.adaptive.basis(wf, J, fG, eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.adaptive.basis_+3A_wf">wf</code></td>
<td>
<p>Character string; name of the wavelet filter.</p>
</td></tr>
<tr><td><code id="find.adaptive.basis_+3A_j">J</code></td>
<td>
<p>Depth of the discrete wavelet packet transform.</p>
</td></tr>
<tr><td><code id="find.adaptive.basis_+3A_fg">fG</code></td>
<td>
<p>Gegenbauer frequency.</p>
</td></tr>
<tr><td><code id="find.adaptive.basis_+3A_eps">eps</code></td>
<td>
<p>Threshold for the squared gain function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The squared gain functions for a Daubechies (extremal phase or least
asymmetric) wavelet family are used in a filter cascade to compute the value
of the squared gain function for the wavelet packet filter at the
Gengenbauer frequency.  This is done for all nodes of the wavelet packet
table.
</p>
<p>The idea behind this subroutine is to approximate the relationship between
the discrete wavelet transform and long-memory processes, where the squared
gain function is zero at frequency zero for all levels of the DWT.
</p>


<h3>Value</h3>

<p>Boolean vector describing the orthonormal basis for the DWPT.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+dwpt.sim">dwpt.sim</a></code>.
</p>

<hr>
<h2 id='FSfarras'>Farras nearly symmetric filters</h2><span id='topic+FSfarras'></span><span id='topic+farras'></span>

<h3>Description</h3>

<p>Farras nearly symmetric filters for orthogonal 2-channel perfect
reconstruction filter bank and Farras filters organized for the dual-tree
complex DWT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FSfarras()
</code></pre>


<h3>Value</h3>

<table>
<tr><td><code>af</code></td>
<td>
<p>List (i=1,2) - analysis filters for tree i</p>
</td></tr> <tr><td><code>sf</code></td>
<td>
<p>List
(i=1,2) - synthesis filters for tree i</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matlab: S. Cai, K. Li and I. Selesnick; R port: B. Whitcher
</p>


<h3>References</h3>

<p>A. F. Abdelnour and I. W. Selesnick. &ldquo;Nearly symmetric
orthogonal wavelet bases&rdquo;, Proc. IEEE Int. Conf. Acoust., Speech, Signal
Processing (ICASSP), May 2001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+afb">afb</a></code>, <code><a href="#topic+dualtree">dualtree</a></code>, <code><a href="#topic+dualfilt1">dualfilt1</a></code>.
</p>

<hr>
<h2 id='heavisine'>Sine with Jumps at 0.3 and 0.72</h2><span id='topic+heavisine'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">heavisine(x) = 4\sin(4{\pi}x) - \mathrm{sign}(x-0.3) - </code>
</p>
<p style="text-align: center;"><code class="reqn">
\mathrm{sign}(0.72-x)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(heavisine)
</code></pre>


<h3>Format</h3>

<p>A vector containing 512 observations.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='hilbert.filter'>Select a Hilbert Wavelet Pair</h2><span id='topic+hilbert.filter'></span>

<h3>Description</h3>

<p>Converts name of Hilbert wavelet pair to filter coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hilbert.filter(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hilbert.filter_+3A_name">name</code></td>
<td>
<p>Character string of Hilbert wavelet pair, see acceptable names
below (e.g., <code>"k3l3"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple <code>switch</code> statement selects the appropriate HWP.  There are two
parameters that define a Hilbert wavelet pair using the notation of
Selesnick (2001,2002), <code class="reqn">K</code> and <code class="reqn">L</code>.  Currently, the only implemented
combinations <code class="reqn">(K,L)</code> are (3,3), (3,5), (4,2) and (4,4).
</p>


<h3>Value</h3>

<p>List containing the following items: </p>
<table>
<tr><td><code>L</code></td>
<td>
<p>length of the wavelet
filter</p>
</td></tr> <tr><td><code>h0</code>, <code>g0</code></td>
<td>
<p>low-pass filter coefficients</p>
</td></tr> <tr><td><code>h1</code>, <code>g1</code></td>
<td>
<p>high-pass
filter coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Selesnick, I.W. (2001). Hilbert transform pairs of wavelet
bases. <em>IEEE Signal Processing Letters</em> <b>8</b>(6), 170&ndash;173.
</p>
<p>Selesnick, I.W. (2002). The design of approximate Hilbert transform pairs
of wavelet bases. <em>IEEE Transactions on Signal Processing</em> 
<b>50</b>(5), 1144&ndash;1152.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wave.filter">wave.filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hilbert.filter("k3l3")
hilbert.filter("k3l5")
hilbert.filter("k4l2")
hilbert.filter("k4l4")

</code></pre>

<hr>
<h2 id='hosking.sim'>Generate Stationary Gaussian Process Using Hosking's Method</h2><span id='topic+hosking.sim'></span>

<h3>Description</h3>

<p>Uses exact time-domain method from Hosking (1984) to generate a simulated
time series from a specified autocovariance sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hosking.sim(n, acvs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hosking.sim_+3A_n">n</code></td>
<td>
<p>Length of series.</p>
</td></tr>
<tr><td><code id="hosking.sim_+3A_acvs">acvs</code></td>
<td>
<p>Autocovariance sequence of series with which to generate, must
be of length at least <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Length <code>n</code> time series from true autocovariance sequence
<code>acvs</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Hosking, J. R. M. (1984) Modeling persistence in hydrological
time series using fractional differencing, <em>Water Resources Research</em>,
<b>20</b>, No. 12, 1898-1908.
</p>
<p>Percival, D. B. (1992) Simulating Gaussian random processes with specified
spectra, <em>Computing Science and Statistics</em>, <b>22</b>, 534-538.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dB &lt;- function(x) 10 * log10(x)
per &lt;- function (z) {
  n &lt;- length(z)
  (Mod(fft(z))^2/(2 * pi * n))[1:(n%/%2 + 1)]
}
spp.sdf &lt;- function(freq, delta, omega)
  abs(2 * (cos(2*pi*freq) - cos(2*pi*omega)))^(-2*delta)
data(acvs.andel8)
n &lt;- 1024
## Not run: 
z &lt;- hosking.sim(n, acvs.andel8[,2])
per.z &lt;- 2 * pi * per(z)
par(mfrow=c(2,1), las=1)
plot.ts(z, ylab="", main="Realization of a Seasonal Long-Memory Process")
plot(0:(n/2)/n, dB(per.z), type="l", xlab="Frequency", ylab="dB",
     main="Periodogram")
lines(0:(n/2)/n, dB(spp.sdf(0:(n/2)/n, .4, 1/12)), col=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='ibm'>Daily IBM Stock Prices</h2><span id='topic+ibm'></span>

<h3>Description</h3>

<p>Daily IBM stock prices spanning May~17, 1961 to November~2, 1962.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ibm)
</code></pre>


<h3>Format</h3>

<p>A vector containing 369 observations.
</p>


<h3>Source</h3>

<p>Box, G. E.P. and Jenkins, G. M. (1976) <em>Time Series Analysis:
Forecasting and Control</em>, Holden Day, San Francisco, 2nd edition.
</p>

<hr>
<h2 id='japan'>Japanese Gross National Product</h2><span id='topic+japan'></span>

<h3>Description</h3>

<p>Quarterly Japanese gross national product from 1955:1 to 1996:4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(japan)
</code></pre>


<h3>Format</h3>

<p>A vector containing 169 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Hecq, A. (1998) Does seasonal adjustment induce common cycles?,
<em>Empirical Economics</em>, <b>59</b>, 289-297.
</p>

<hr>
<h2 id='jumpsine'>Sine with Jumps at 0.625 and 0.875</h2><span id='topic+jumpsine'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">jumpsine(x) = 10\left( \sin(4{\pi}x) +
I_{[0.625 &lt; x \leq 0.875]}\right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(jumpsine)
</code></pre>


<h3>Format</h3>

<p>A vector containing 512 observations.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='kobe'>1995 Kobe Earthquake Data</h2><span id='topic+kobe'></span>

<h3>Description</h3>

<p>Seismograph (vertical acceleration, nm/sq.sec) of the Kobe earthquake,
recorded at Tasmania University, HobarTRUE, Australia on 16 January 1995
beginning at 20:56:51 (GMTRUE) and continuing for 51 minutes at 1 second
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kobe)
</code></pre>


<h3>Format</h3>

<p>A vector containing 3048 observations.
</p>


<h3>Source</h3>

<p>Data management centre, Washington University.
</p>

<hr>
<h2 id='linchirp'>Linear Chirp</h2><span id='topic+linchirp'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">linchirp(x) = \sin(0.125 \pi n x^2)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(linchirp)
</code></pre>


<h3>Format</h3>

<p>A vector containing 512 observations.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

<hr>
<h2 id='manual.thresh'>Wavelet Shrinkage via Thresholding</h2><span id='topic+manual.thresh'></span><span id='topic+Thresholding'></span><span id='topic+da.thresh'></span><span id='topic+hybrid.thresh'></span><span id='topic+sure.thresh'></span><span id='topic+universal.thresh'></span><span id='topic+universal.thresh.modwt'></span><span id='topic+bishrink'></span><span id='topic+soft'></span>

<h3>Description</h3>

<p>Perform wavelet shrinkage using data-analytic, hybrid SURE, manual, SURE, or
universal thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>da.thresh(wc, alpha = .05, max.level = 4, verbose = FALSE, return.thresh = FALSE)

hybrid.thresh(wc, max.level = 4, verbose = FALSE, seed = 0)

manual.thresh(wc, max.level = 4, value, hard = TRUE)

sure.thresh(wc, max.level = 4, hard = TRUE)

universal.thresh(wc, max.level = 4, hard = TRUE)

universal.thresh.modwt(wc, max.level = 4, hard = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manual.thresh_+3A_wc">wc</code></td>
<td>
<p>wavelet coefficients</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_max.level">max.level</code></td>
<td>
<p>maximum level of coefficients to be affected by threshold</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_value">value</code></td>
<td>
<p>threshold value (only utilized in <code>manual.thresh</code>)</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_hard">hard</code></td>
<td>
<p>Boolean value, if <code>hard=F</code> then soft thresholding is used</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_alpha">alpha</code></td>
<td>
<p>level of the hypothesis tests</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_verbose">verbose</code></td>
<td>
<p>if <code>verbose=TRUE</code> then information is printed to the
screen</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_seed">seed</code></td>
<td>
<p>sets random seed (only utilized in <code>hybrid.thresh</code>)</p>
</td></tr>
<tr><td><code id="manual.thresh_+3A_return.thresh">return.thresh</code></td>
<td>
<p>if <code>return.thresh=TRUE</code> then the vector of
threshold values is returned, otherwise the surviving wavelet coefficients
are returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An extensive amount of literature has been written on wavelet shrinkage.
The functions here represent the most basic approaches to the problem of
nonparametric function estimation.  See the references for further
information.
</p>


<h3>Value</h3>

<p>The default output is a list structure, the same length as was
input, containing only those wavelet coefficients surviving the threshold.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher (some code taken from R. Todd Ogden)
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Ogden, R. T. (1996) <em>Essential Wavelets for Statistical Applications
and Data Analysis</em>, Birkhauser.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>
<p>Vidakovic, B. (1999) <em>Statistical Modeling by Wavelets</em>, John Wiley and
Sons.
</p>

<hr>
<h2 id='mexm'>Mexican Money Supply</h2><span id='topic+mexm'></span>

<h3>Description</h3>

<p>Percentage changes in monthly Mexican money supply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mexm)
</code></pre>


<h3>Format</h3>

<p>A vector containing 516 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='modhwt.coh'>Time-varying and Seasonal Analysis Using Hilbert Wavelet Pairs</h2><span id='topic+modhwt.coh'></span><span id='topic+modhwt.phase'></span><span id='topic+modhwt.coh.seasonal'></span><span id='topic+modhwt.phase.seasonal'></span>

<h3>Description</h3>

<p>Performs time-varying or seasonal coherence and phase anlaysis between two
time seris using the maximal-overlap discrete Hilbert wavelet transform
(MODHWT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modhwt.coh(x, y, f.length = 0)

modhwt.phase(x, y, f.length = 0)

modhwt.coh.seasonal(x, y, S = 10, season = 365)

modhwt.phase.seasonal(x, y, season = 365)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modhwt.coh_+3A_x">x</code></td>
<td>
<p>MODHWT object.</p>
</td></tr>
<tr><td><code id="modhwt.coh_+3A_y">y</code></td>
<td>
<p>MODHWT object.</p>
</td></tr>
<tr><td><code id="modhwt.coh_+3A_f.length">f.length</code></td>
<td>
<p>Length of the rectangular filter.</p>
</td></tr>
<tr><td><code id="modhwt.coh_+3A_s">S</code></td>
<td>
<p>Number of &quot;seasons&quot;.</p>
</td></tr>
<tr><td><code id="modhwt.coh_+3A_season">season</code></td>
<td>
<p>Length of the &quot;season&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of seasonally-varying spectral analysis (SVSA, Madden 1986) is
generalized using the MODWT and Hilbert wavelet pairs.  For the seasonal
case, <code class="reqn">S</code> seasons are used to produce a consistent estimate of the
coherence and phase.  For the non-seasonal case, a simple rectangular
(moving-average) filter is applied to the MODHWT coefficients in order to
produce consistent estimates.
</p>


<h3>Value</h3>

<p>Time-varying or seasonal coherence and phase between two time
series.  The coherence estimates are between zero and one, while the phase
estimates are between <code class="reqn">-\pi</code> and <code class="reqn">\pi</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Madden, R.A. (1986). Seasonal variation of the 40&ndash;50 day
oscillation in the tropics. <em>Journal of the Atmospheric Sciences</em>
<b>43</b>(24), 3138&ndash;3158.
</p>
<p>Whither, B. and P.F. Craigmile (2004). Multivariate Spectral Analysis Using
Hilbert Wavelet Pairs, <em>International Journal of Wavelets,
Multiresolution and Information Processing</em>, <b>2</b>(4), 567&ndash;587.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hilbert.filter">hilbert.filter</a></code>
</p>

<hr>
<h2 id='modwt'>(Inverse) Maximal Overlap Discrete Wavelet Transform</h2><span id='topic+modwt'></span><span id='topic+imodwt'></span>

<h3>Description</h3>

<p>This function performs a level <code class="reqn">J</code> decomposition of the input vector
using the non-decimated discrete wavelet transform. The inverse transform
performs the reconstruction of a vector or time series from its maximal
overlap discrete wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt(x, wf = "la8", n.levels = 4, boundary = "periodic")

imodwt(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt_+3A_x">x</code></td>
<td>
<p>a vector or time series containing the data be to decomposed.
There is <b>no</b> restriction on its length.</p>
</td></tr>
<tr><td><code id="modwt_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length L=8 (Daubechies, 1992), least asymmetric family.</p>
</td></tr>
<tr><td><code id="modwt_+3A_n.levels">n.levels</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a
number less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="modwt_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the defaulTRUE, then the vector you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the vector beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
<tr><td><code id="modwt_+3A_y">y</code></td>
<td>
<p>an object of class <code>"modwt"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code implements the one-dimensional non-decimated DWT using the pyramid
algorithm.  The actual transform is performed in C using pseudocode from
Percival and Walden (2001).  That means convolutions, not inner products,
are used to apply the wavelet filters.
</p>
<p>The MODWT goes by several names in the statistical and engineering
literature, such as, the &ldquo;stationary DWT&rdquo;, &ldquo;translation-invariant DWT&rdquo;,
and &ldquo;time-invariant DWT&rdquo;.
</p>
<p>The inverse MODWT implements the one-dimensional inverse transform using the
pyramid algorithm (Mallat, 1989).
</p>


<h3>Value</h3>

<p>Basically, a list with the following components 
</p>
<table>
<tr><td><code>d?</code></td>
<td>
<p>Wavelet coefficient vectors.</p>
</td></tr> 
<tr><td><code>s?</code></td>
<td>
<p>Scaling coefficient vector.</p>
</td></tr> 
<tr><td><code>wavelet</code></td>
<td>
<p>Name of the wavelet filter used.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Percival, D. B. and P. Guttorp (1994) Long-memory processes, the Allan
variance and wavelets, In <em>Wavelets and Geophysics</em>, pages 325-344,
Academic Press.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>, <code><a href="#topic+idwt">idwt</a></code>, <code><a href="#topic+mra">mra</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figure 4.23 in Gencay, Selcuk and Whitcher (2001)
data(ibm)     
ibm.returns &lt;- diff(log(ibm))
# Haar
ibmr.haar &lt;- modwt(ibm.returns, "haar")
names(ibmr.haar) &lt;- c("w1", "w2", "w3", "w4", "v4")
# LA(8)
ibmr.la8 &lt;- modwt(ibm.returns, "la8")
names(ibmr.la8) &lt;- c("w1", "w2", "w3", "w4", "v4")
# shift the MODWT vectors
ibmr.la8 &lt;- phase.shift(ibmr.la8, "la8")
## plot partial MODWT for IBM data
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.returns, axes=FALSE, ylab="", main="(a)")
for(i in 1:5)
  plot.ts(ibmr.haar[[i]], axes=FALSE, ylab=names(ibmr.haar)[i])
axis(side=1, at=seq(0,368,by=23), 
  labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.returns, axes=FALSE, ylab="", main="(b)")
for(i in 1:5)
  plot.ts(ibmr.la8[[i]], axes=FALSE, ylab=names(ibmr.la8)[i])
axis(side=1, at=seq(0,368,by=23), 
  labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))

</code></pre>

<hr>
<h2 id='modwt.2d'>Two-Dimensional Maximal Overlap Discrete Wavelet Transform</h2><span id='topic+modwt.2d'></span><span id='topic+imodwt.2d'></span>

<h3>Description</h3>

<p>Performs a separable two-dimensional maximal overlap discrete wavelet
transform (MODWT) on a matrix of arbitrary dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt.2d(x, wf, J = 4, boundary = "periodic")

imodwt.2d(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt.2d_+3A_x">x</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="modwt.2d_+3A_wf">wf</code></td>
<td>
<p>name of the wavelet filter to use in the decomposition</p>
</td></tr>
<tr><td><code id="modwt.2d_+3A_j">J</code></td>
<td>
<p>depth of the decomposition</p>
</td></tr>
<tr><td><code id="modwt.2d_+3A_boundary">boundary</code></td>
<td>
<p>only <code>"periodic"</code> is currently implemented</p>
</td></tr>
<tr><td><code id="modwt.2d_+3A_y">y</code></td>
<td>
<p>an object of class <code>dwt.2d</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references.
</p>


<h3>Value</h3>

<p>List structure containing the <code class="reqn">3J+1</code> sub-matrices from the
decomposition.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Liang, J. and T. W. Parks (1994) A two-dimensional translation
invariant wavelet representation and its applications, <em>Proceedings
ICIP-94</em>, Vol. 1, 66-70.
</p>
<p>Liang, J. and T. W. Parks (1994) Image coding using translation invariant
wavelet transforms with symmetric extensions, <em>IEEE Transactions on
Image Processing</em>, <b>7</b>, No. 5, 762-769.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt.2d">dwt.2d</a></code>, <code><a href="#topic+shift.2d">shift.2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Xbox image
data(xbox)
xbox.modwt &lt;- modwt.2d(xbox, "haar", 2)
## Level 1 decomposition
par(mfrow=c(2,2), pty="s")
image(xbox.modwt$LH1, col=rainbow(128), axes=FALSE, main="LH1")
image(xbox.modwt$HH1, col=rainbow(128), axes=FALSE, main="HH1")
frame()
image(xbox.modwt$HL1, col=rainbow(128), axes=FALSE, main="HL1")
## Level 2 decomposition
par(mfrow=c(2,2), pty="s")
image(xbox.modwt$LH2, col=rainbow(128), axes=FALSE, main="LH2")
image(xbox.modwt$HH2, col=rainbow(128), axes=FALSE, main="HH2")
image(xbox.modwt$LL2, col=rainbow(128), axes=FALSE, main="LL2")
image(xbox.modwt$HL2, col=rainbow(128), axes=FALSE, main="HL2")
sum((xbox - imodwt.2d(xbox.modwt))^2)

data(dau)
par(mfrow=c(1,1), pty="s")
image(dau, col=rainbow(128), axes=FALSE, main="Ingrid Daubechies")
sum(dau^2)
dau.modwt &lt;- modwt.2d(dau, "d4", 2)
## Level 1 decomposition
par(mfrow=c(2,2), pty="s")
image(dau.modwt$LH1, col=rainbow(128), axes=FALSE, main="LH1")
image(dau.modwt$HH1, col=rainbow(128), axes=FALSE, main="HH1")
frame()
image(dau.modwt$HL1, col=rainbow(128), axes=FALSE, main="HL1")
## Level 2 decomposition
par(mfrow=c(2,2), pty="s")
image(dau.modwt$LH2, col=rainbow(128), axes=FALSE, main="LH2")
image(dau.modwt$HH2, col=rainbow(128), axes=FALSE, main="HH2")
image(dau.modwt$LL2, col=rainbow(128), axes=FALSE, main="LL2")
image(dau.modwt$HL2, col=rainbow(128), axes=FALSE, main="HL2")
sum((dau - imodwt.2d(dau.modwt))^2)

</code></pre>

<hr>
<h2 id='modwt.3d'>Three Dimensional Separable Maximal Ovelrap Discrete Wavelet Transform</h2><span id='topic+modwt.3d'></span><span id='topic+imodwt.3d'></span>

<h3>Description</h3>

<p>Three-dimensional separable maximal overlap discrete wavelet transform
(MODWT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt.3d(x, wf, J = 4, boundary = "periodic")

imodwt.3d(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modwt.3d_+3A_x">x</code></td>
<td>
<p>input array</p>
</td></tr>
<tr><td><code id="modwt.3d_+3A_wf">wf</code></td>
<td>
<p>name of the wavelet filter to use in the decomposition</p>
</td></tr>
<tr><td><code id="modwt.3d_+3A_j">J</code></td>
<td>
<p>depth of the decomposition</p>
</td></tr>
<tr><td><code id="modwt.3d_+3A_boundary">boundary</code></td>
<td>
<p>only <code>"periodic"</code> is currently implemented</p>
</td></tr>
<tr><td><code id="modwt.3d_+3A_y">y</code></td>
<td>
<p>an object of class <code>modwt.3d</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>

<hr>
<h2 id='mra'>Multiresolution Analysis of Time Series</h2><span id='topic+mra'></span>

<h3>Description</h3>

<p>This function performs a level <code class="reqn">J</code> additive decomposition of the input
vector or time series using the pyramid algorithm (Mallat 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra(x, wf = "la8", J = 4, method = "modwt", boundary = "periodic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra_+3A_x">x</code></td>
<td>
<p>A vector or time series containing the data be to decomposed.  This
must be a dyadic length vector (power of 2) for <code>method="dwt"</code>.</p>
</td></tr>
<tr><td><code id="mra_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length L=8 least asymmetric family.</p>
</td></tr>
<tr><td><code id="mra_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a number
less than or equal to log(length(x), 2).</p>
</td></tr>
<tr><td><code id="mra_+3A_method">method</code></td>
<td>
<p>Either <code>"dwt"</code> or <code>"modwt"</code>.</p>
</td></tr>
<tr><td><code id="mra_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the default, then the vector you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the vector beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code implements a one-dimensional multiresolution analysis introduced
by Mallat (1989).  Either the DWT or MODWT may be used to compute the
multiresolution analysis, which is an additive decomposition of the original
time series.
</p>


<h3>Value</h3>

<p>Basically, a list with the following components </p>
<table>
<tr><td><code>D?</code></td>
<td>
<p>Wavelet
detail vectors.</p>
</td></tr> <tr><td><code>S?</code></td>
<td>
<p>Wavelet smooth vector.</p>
</td></tr> <tr><td><code>wavelet</code></td>
<td>
<p>Name of
the wavelet filter used.</p>
</td></tr> <tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Mallat, S. G. (1989) A theory for multiresolution signal decomposition: the
wavelet representation, <em>IEEE Transactions on Pattern Analysis and
Machine Intelligence</em>, <b>11</b>, No. 7, 674-693.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>, <code><a href="#topic+modwt">modwt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Easy check to see if it works...
x &lt;- rnorm(32)
x.mra &lt;- mra(x)
sum(x - apply(matrix(unlist(x.mra), nrow=32), 1, sum))^2

## Figure 4.19 in Gencay, Selcuk and Whitcher (2001)
data(ibm)     
ibm.returns &lt;- diff(log(ibm))
ibm.volatility &lt;- abs(ibm.returns)
## Haar
ibmv.haar &lt;- mra(ibm.volatility, "haar", 4, "dwt")
names(ibmv.haar) &lt;- c("d1", "d2", "d3", "d4", "s4")
## LA(8)
ibmv.la8 &lt;- mra(ibm.volatility, "la8", 4, "dwt")
names(ibmv.la8) &lt;- c("d1", "d2", "d3", "d4", "s4")
## plot multiresolution analysis of IBM data
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.volatility, axes=FALSE, ylab="", main="(a)")
for(i in 1:5)
  plot.ts(ibmv.haar[[i]], axes=FALSE, ylab=names(ibmv.haar)[i])
axis(side=1, at=seq(0,368,by=23), 
  labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))
par(mfcol=c(6,1), pty="m", mar=c(5-2,4,4-2,2))
plot.ts(ibm.volatility, axes=FALSE, ylab="", main="(b)")
for(i in 1:5)
  plot.ts(ibmv.la8[[i]], axes=FALSE, ylab=names(ibmv.la8)[i])
axis(side=1, at=seq(0,368,by=23), 
  labels=c(0,"",46,"",92,"",138,"",184,"",230,"",276,"",322,"",368))

</code></pre>

<hr>
<h2 id='mra.2d'>Multiresolution Analysis of an Image</h2><span id='topic+mra.2d'></span>

<h3>Description</h3>

<p>This function performs a level <code class="reqn">J</code> additive decomposition of the input
matrix or image using the pyramid algorithm (Mallat 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra.2d(x, wf = "la8", J = 4, method = "modwt", boundary = "periodic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra.2d_+3A_x">x</code></td>
<td>
<p>A matrix or image containing the data be to decomposed.  This must
be have dyadic length in both dimensions (but not necessarily the same) for
<code>method="dwt"</code>.</p>
</td></tr>
<tr><td><code id="mra.2d_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length L=8 least asymmetric family.</p>
</td></tr>
<tr><td><code id="mra.2d_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a number
less than or equal to log(length(x),2).</p>
</td></tr>
<tr><td><code id="mra.2d_+3A_method">method</code></td>
<td>
<p>Either <code>"dwt"</code> or <code>"modwt"</code>.</p>
</td></tr>
<tr><td><code id="mra.2d_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the default, then the matrix you decompose is
assumed to be periodic on its defined interval,<br /> if
<code>boundary=="reflection"</code>, the matrix beyond its boundaries is assumed
to be a symmetric reflection of itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code implements a two-dimensional multiresolution analysis by
performing the one-dimensional pyramid algorithm (Mallat 1989) on the rows
and columns of the input matrix.  Either the DWT or MODWT may be used to
compute the multiresolution analysis, which is an additive decomposition of
the original matrix (image).
</p>


<h3>Value</h3>

<p>Basically, a list with the following components </p>
<table>
<tr><td><code>LH?</code></td>
<td>
<p>Wavelet
detail image in the horizontal direction.</p>
</td></tr> <tr><td><code>HL?</code></td>
<td>
<p>Wavelet detail image
in the vertical direction.</p>
</td></tr> <tr><td><code>HH?</code></td>
<td>
<p>Wavelet detail image in the diagonal
direction.</p>
</td></tr> <tr><td><code>LLJ</code></td>
<td>
<p>Wavelet smooth image at the coarsest resolution.</p>
</td></tr>
<tr><td><code>J</code></td>
<td>
<p>Depth of the wavelet transform.</p>
</td></tr> <tr><td><code>wavelet</code></td>
<td>
<p>Name of the wavelet
filter used.</p>
</td></tr> <tr><td><code>boundary</code></td>
<td>
<p>How the boundaries were handled.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal
decomposition: the wavelet representation, <em>IEEE Transactions on
Pattern Analysis and Machine Intelligence</em>, <b>11</b>, No. 7, 674-693.
</p>
<p>Mallat, S. G. (1998) <em>A Wavelet Tour of Signal Processing</em>, Academic
Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt.2d">dwt.2d</a></code>, <code><a href="#topic+modwt.2d">modwt.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Easy check to see if it works...
## --------------------------------

x &lt;- matrix(rnorm(32*32), 32, 32)
# MODWT
x.mra &lt;- mra.2d(x, method="modwt")
x.mra.sum &lt;- x.mra[[1]]
for(j in 2:length(x.mra))
  x.mra.sum &lt;- x.mra.sum + x.mra[[j]]
sum((x - x.mra.sum)^2)

# DWT
x.mra &lt;- mra.2d(x, method="dwt")
x.mra.sum &lt;- x.mra[[1]]
for(j in 2:length(x.mra))
  x.mra.sum &lt;- x.mra.sum + x.mra[[j]]
sum((x - x.mra.sum)^2)

</code></pre>

<hr>
<h2 id='mra.3d'>Three Dimensional Multiresolution Analysis</h2><span id='topic+mra.3d'></span>

<h3>Description</h3>

<p>This function performs a level <code class="reqn">J</code> additive decomposition of the input
array using the pyramid algorithm (Mallat 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra.3d(x, wf = "la8", J = 4, method = "modwt", boundary = "periodic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra.3d_+3A_x">x</code></td>
<td>
<p>A three-dimensional array containing the data be to decomposed.
This must be have dyadic length in all three dimensions (but not necessarily
the same) for <code>method="dwt"</code>.</p>
</td></tr>
<tr><td><code id="mra.3d_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  By
default this is set to <code>"la8"</code>, the Daubechies orthonormal compactly
supported wavelet of length <code class="reqn">L=8</code> least asymmetric family.</p>
</td></tr>
<tr><td><code id="mra.3d_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a number
less than or equal to <code class="reqn">\log(\mbox{length}(x),2)</code>.</p>
</td></tr>
<tr><td><code id="mra.3d_+3A_method">method</code></td>
<td>
<p>Either <code>"dwt"</code> or <code>"modwt"</code>.</p>
</td></tr>
<tr><td><code id="mra.3d_+3A_boundary">boundary</code></td>
<td>
<p>Character string specifying the boundary condition.  If
<code>boundary=="periodic"</code> the default and only method implemented, then
the matrix you decompose is assumed to be periodic on its defined interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code implements a three-dimensional multiresolution analysis by
performing the one-dimensional pyramid algorithm (Mallat 1989) on each
dimension of the input array.  Either the DWT or MODWT may be used to
compute the multiresolution analysis, which is an additive decomposition of
the original array.
</p>


<h3>Value</h3>

<p>List structure containing the filter triplets associated with the
multiresolution analysis.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mallat, S. G. (1989) A theory for multiresolution signal
decomposition: the wavelet representation, <em>IEEE Transactions on
Pattern Analysis and Machine Intelligence</em>, <b>11</b>, No. 7, 674-693.
</p>
<p>Mallat, S. G. (1998) <em>A Wavelet Tour of Signal Processing</em>, Academic
Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt.3d">dwt.3d</a></code>, <code><a href="#topic+modwt.3d">modwt.3d</a></code>
</p>

<hr>
<h2 id='mult.loc'>Wavelet-based Testing and Locating for Variance Change Points</h2><span id='topic+mult.loc'></span>

<h3>Description</h3>

<p>This is the major subroutine for <code><a href="#topic+testing.hov">testing.hov</a></code>, providing the
workhorse algorithm to recursively test and locate multiple variance changes
in so-called long memory processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult.loc(dwt.list, modwt.list, wf, level, min.coef, debug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mult.loc_+3A_dwt.list">dwt.list</code></td>
<td>
<p>List of wavelet vector coefficients from the <code>dwt</code>.</p>
</td></tr>
<tr><td><code id="mult.loc_+3A_modwt.list">modwt.list</code></td>
<td>
<p>List of wavelet vector coefficients from the <code>modwt</code>.</p>
</td></tr>
<tr><td><code id="mult.loc_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="mult.loc_+3A_level">level</code></td>
<td>
<p>Specifies the depth of the decomposition.</p>
</td></tr>
<tr><td><code id="mult.loc_+3A_min.coef">min.coef</code></td>
<td>
<p>Minimum number of wavelet coefficients for testing purposes.</p>
</td></tr>
<tr><td><code id="mult.loc_+3A_debug">debug</code></td>
<td>
<p>Boolean variable: if set to <code>TRUE</code>, actions taken by the
algorithm are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see Section 9.6 of Percival and Walden (2000) or Section 7.3 in
Gencay, Selcuk and Whitcher (2001).
</p>


<h3>Value</h3>

<p>Matrix.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotcumvar">rotcumvar</a></code>, <code><a href="#topic+testing.hov">testing.hov</a></code>.
</p>

<hr>
<h2 id='my.acf'>Autocovariance Functions via the Discrete Fourier Transform</h2><span id='topic+my.acf'></span><span id='topic+my.ccf'></span>

<h3>Description</h3>

<p>Computes the autocovariance function (ACF) for a time series or the
cross-covariance function (CCF) between two time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.acf(x)

my.ccf(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my.acf_+3A_x">x</code>, <code id="my.acf_+3A_a">a</code>, <code id="my.acf_+3A_b">b</code></td>
<td>
<p>time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series is zero padded to twice its length before the discrete Fourier
transform is applied.  Only the values corresponding to nonnegative lags are
provided (for the ACF).
</p>


<h3>Value</h3>

<p>The autocovariance function for all nonnegative lags or the
cross-covariance function for all lags.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ibm)
ibm.returns &lt;- diff(log(ibm))
plot(1:length(ibm.returns) - 1, my.acf(ibm.returns), type="h",
     xlab="lag", ylab="ACVS", main="Autocovariance Sequence for IBM Returns")

</code></pre>

<hr>
<h2 id='nile'>Nile River Minima</h2><span id='topic+nile'></span>

<h3>Description</h3>

<p>Yearly minimal water levels of the Nile river for the years 622 to 1281,
measured at the Roda gauge near Cairo (Tousson, 1925, p. 366-385). The data
are listed in chronological sequence by row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nile)
</code></pre>


<h3>Format</h3>

<p>A length 663 vector.
</p>


<h3>Details</h3>

<p>The original Nile river data supplied by Beran only contained only 500
observations (622 to 1121).  However, the book claimed to have 660
observations (622 to 1281).  The remaining observations from the book were
added, by hand, but the series still only contained 653 observations (622 to
1264).
</p>
<p>Note, now the data consists of 663 observations (spanning the years
622-1284) as in original source (Toussoun, 1925).
</p>


<h3>Source</h3>

<p>Toussoun, O. (1925) M\'emoire sur l'Histoire du Nil, Volume 18 in
<em>M\'emoires a l'Institut d'Egypte</em>, pp. 366-404.
</p>


<h3>References</h3>

<p>Beran, J. (1994) <em>Statistics for Long-Memory Processes</em>,
Chapman Hall: Englewood, NJ.
</p>

<hr>
<h2 id='ortho.basis'>Derive Orthonormal Basis from Wavelet Packet Tree</h2><span id='topic+ortho.basis'></span>

<h3>Description</h3>

<p>An orthonormal basis for the discrete wavelet transform may be characterized
via a disjoint partitioning of the frequency axis that covers
<code class="reqn">[0,\frac{1}{2})</code>.  This subroutine produces an orthonormal
basis from a full wavelet packet tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.basis(xtree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho.basis_+3A_xtree">xtree</code></td>
<td>
<p>is a vector whose entries are associated with a wavelet packet
tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wavelet packet tree is a binary tree of Boolean variables.  Parent nodes
are removed if any of their children exist.
</p>


<h3>Value</h3>

<p>Boolean vector describing the orthonormal basis for the DWPT.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(japan)
J &lt;- 4
wf &lt;- "mb8"
japan.mra &lt;- mra(log(japan), wf, J, boundary="reflection")
japan.nomean &lt;-
  ts(apply(matrix(unlist(japan.mra[-(J+1)]), ncol=J, byrow=FALSE), 1, sum),
     start=1955, freq=4)
japan.nomean2 &lt;- ts(japan.nomean[42:169], start=1965.25, freq=4)
plot(japan.nomean2, type="l")
japan.dwpt &lt;- dwpt(japan.nomean2, wf, 6)
japan.basis &lt;-
  ortho.basis(portmanteau.test(japan.dwpt, p=0.01, type="other"))
# Not implemented yet
# par(mfrow=c(1,1))
# plot.basis(japan.basis)

</code></pre>

<hr>
<h2 id='per'>Periodogram</h2><span id='topic+per'></span>

<h3>Description</h3>

<p>Computation of the periodogram via the Fast Fourier Transform (FFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="per_+3A_z">z</code></td>
<td>
<p>time series</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Author: Jan Beran; modified: Martin Maechler, Date: Sep 1995.
</p>

<hr>
<h2 id='phase.shift'>Phase Shift Wavelet Coefficients</h2><span id='topic+phase.shift'></span><span id='topic+phase.shift.packet'></span>

<h3>Description</h3>

<p>Wavelet coefficients are circularly shifted by the amount of phase shift
induced by the wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.shift(z, wf, inv = FALSE)

phase.shift.packet(z, wf, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase.shift_+3A_z">z</code></td>
<td>
<p>DWT object</p>
</td></tr>
<tr><td><code id="phase.shift_+3A_wf">wf</code></td>
<td>
<p>character string; wavelet filter used in DWT</p>
</td></tr>
<tr><td><code id="phase.shift_+3A_inv">inv</code></td>
<td>
<p>Boolean variable; if <code>inv=TRUE</code> then the inverse phase shift
is applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The center-of-energy argument of Hess-Nielsen and Wickerhauser (1996) is
used to provide a flexible way to circularly shift wavelet coefficients
regardless of the wavelet filter used.  The results are not identical to
those used by Percival and Walden (2000), but are more flexible.
</p>
<p><code>phase.shift.packet</code> is not yet implemented fully.
</p>


<h3>Value</h3>

<p>DWT (DWPT) object with coefficients circularly shifted.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Hess-Nielsen, N. and M. V. Wickerhauser (1996) Wavelets and
time-frequency analysis, <em>Proceedings of the IEEE</em>, <b>84</b>, No. 4,
523-540.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>

<hr>
<h2 id='phase.shift.hilbert'>Phase Shift for Hilbert Wavelet Coefficients</h2><span id='topic+phase.shift.hilbert'></span><span id='topic+phase.shift.hilbert.packet'></span>

<h3>Description</h3>

<p>Wavelet coefficients are circularly shifted by the amount of phase shift
induced by the discrete Hilbert wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase.shift.hilbert(x, wf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase.shift.hilbert_+3A_x">x</code></td>
<td>
<p>Discete Hilbert wavelet transform (DHWT) object.</p>
</td></tr>
<tr><td><code id="phase.shift.hilbert_+3A_wf">wf</code></td>
<td>
<p>character string; Hilbert wavelet pair used in DHWT</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;center-of-energy&quot; argument of Hess-Nielsen and Wickerhauser (1996) is
used to provide a flexible way to circularly shift wavelet coefficients
regardless of the wavelet filter used.
</p>


<h3>Value</h3>

<p>DHWT (DHWPT) object with coefficients circularly shifted.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Hess-Nielsen, N. and M. V. Wickerhauser (1996) Wavelets and
time-frequency analysis, <em>Proceedings of the IEEE</em>, <b>84</b>, No. 4,
523-540.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phase.shift">phase.shift</a></code>
</p>

<hr>
<h2 id='plot.dwt.2d'>Plot Two-dimensional Discrete Wavelet Transform</h2><span id='topic+plot.dwt.2d'></span>

<h3>Description</h3>

<p>Organizes the wavelet coefficients from a 2D DWT into a single matrix and
plots it.  The coarser resolutions are nested within the lower-lefthand
corner of the image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dwt.2d'
plot(x, cex.axis = 1, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dwt.2d_+3A_x">x</code></td>
<td>
<p>input matrix (image)</p>
</td></tr>
<tr><td><code id="plot.dwt.2d_+3A_cex.axis">cex.axis</code></td>
<td>
<p><code>par</code> plotting parameter that controls the size of the
axis text</p>
</td></tr>
<tr><td><code id="plot.dwt.2d_+3A_plot">plot</code></td>
<td>
<p>if <code>plot = FALSE</code> then the matrix of wavelet coefficients
is returned, the default is <code>plot = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.dwt.2d_+3A_...">...</code></td>
<td>
<p>additional graphical parameters if necessary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wavelet coefficients from the DWT object (a list) are reorganized into a
single matrix of the same dimension as the original image and the result is
plotted.
</p>


<h3>Value</h3>

<p>Image plot.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt.2d">dwt.2d</a></code>.
</p>

<hr>
<h2 id='qmf'>Quadrature Mirror Filter</h2><span id='topic+qmf'></span>

<h3>Description</h3>

<p>Computes the quadrature mirror filter from a given filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qmf(g, low2high = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qmf_+3A_g">g</code></td>
<td>
<p>Filter coefficients.</p>
</td></tr>
<tr><td><code id="qmf_+3A_low2high">low2high</code></td>
<td>
<p>Logical, default is <code>TRUE</code> which means a low-pass
filter is input and a high-pass filter is output.  Setting <code>low2high=F</code>
performs the inverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>None.
</p>


<h3>Value</h3>

<p>Quadrature mirror filter.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Any basic signal processing text.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wave.filter">wave.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Haar wavelet filter
g &lt;- wave.filter("haar")$lpf
qmf(g)

</code></pre>

<hr>
<h2 id='rotcumvar'>Rotated Cumulative Variance</h2><span id='topic+rotcumvar'></span>

<h3>Description</h3>

<p>Provides the normalized cumulative sums of squares from a sequence of
coefficients with the diagonal line removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotcumvar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotcumvar_+3A_x">x</code></td>
<td>
<p>vector of coefficients to be cumulatively summed (missing values
excluded)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotated cumulative variance, when plotted, provides a qualitative way to
study the time dependence of the variance of a series.  If the variance is
stationary over time, then only small deviations from zero should be
present.  If on the other hand the variance is non-stationary, then large
departures may exist.  Formal hypothesis testing may be performed based on
boundary crossings of Brownian bridge processes.
</p>


<h3>Value</h3>

<p>Vector of coefficients that are the sumulative sum of squared input
coefficients.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>

<hr>
<h2 id='shift.2d'>Circularly Shift Matrices from a 2D MODWT</h2><span id='topic+shift.2d'></span>

<h3>Description</h3>

<p>Compute phase shifts for wavelet sub-matrices based on the &ldquo;center of
energy&rdquo; argument of Hess-Nielsen and Wickerhauser (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift.2d(z, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift.2d_+3A_z">z</code></td>
<td>
<p>Two-dimensional MODWT object</p>
</td></tr>
<tr><td><code id="shift.2d_+3A_inverse">inverse</code></td>
<td>
<p>Boolean value on whether to perform the forward or inverse
operation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;center of energy&quot; technique of Wickerhauser and Hess-Nielsen (1996) is
employed to find circular shifts for the wavelet sub-matrices such that the
coefficients are aligned with the original series.  This corresponds to
applying a (near) linear-phase filtering operation.
</p>


<h3>Value</h3>

<p>Two-dimensional MODWT object with circularly shifted coefficients.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Hess-Nielsen, N. and M. V. Wickerhauser (1996) Wavelets and
time-frequency analysis, <em>Proceedings of the IEEE</em>, <b>84</b>, No. 4,
523-540.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phase.shift">phase.shift</a></code>, <code><a href="#topic+modwt.2d">modwt.2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 512
G1 &lt;- G2 &lt;- dnorm(seq(-n/4, n/4, length=n))
G &lt;- 100 * zapsmall(outer(G1, G2))
G &lt;- modwt.2d(G, wf="la8", J=6)
k &lt;- 50
xr &lt;- yr &lt;- trunc(n/2) + (-k:k)
par(mfrow=c(3,3), mar=c(1,1,2,1), pty="s")
for (j in names(G)[1:9]) {
  image(G[[j]][xr,yr], col=rainbow(64), axes=FALSE, main=j)
}
Gs &lt;- shift.2d(G)
for (j in names(G)[1:9]) {
  image(Gs[[j]][xr,yr], col=rainbow(64), axes=FALSE, main=j)
}

</code></pre>

<hr>
<h2 id='sine.taper'>Computing Sinusoidal Data Tapers</h2><span id='topic+sine.taper'></span>

<h3>Description</h3>

<p>Computes sinusoidal data tapers directly from equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sine.taper(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sine.taper_+3A_n">n</code></td>
<td>
<p>length of data taper(s)</p>
</td></tr>
<tr><td><code id="sine.taper_+3A_k">k</code></td>
<td>
<p>number of data tapers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See reference.
</p>


<h3>Value</h3>

<p>A vector or matrix of data tapers (cols = tapers).
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Riedel, K. S. and A. Sidorenko (1995) Minimum bias multiple
taper spectral estimation, <em>IEEE Transactions on Signal Processing</em>,
<b>43</b>, 188-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpss.taper">dpss.taper</a></code>.
</p>

<hr>
<h2 id='spin.covariance'>Compute Wavelet Cross-Covariance Between Two Time Series</h2><span id='topic+spin.covariance'></span><span id='topic+spin.correlation'></span>

<h3>Description</h3>

<p>Computes wavelet cross-covariance or cross-correlation between two time
series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spin.covariance(x, y, lag.max = NA)

spin.correlation(x, y, lag.max = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin.covariance_+3A_x">x</code></td>
<td>
<p>first time series</p>
</td></tr>
<tr><td><code id="spin.covariance_+3A_y">y</code></td>
<td>
<p>second time series, same length as <code>x</code></p>
</td></tr>
<tr><td><code id="spin.covariance_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag to compute cross-covariance (correlation)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references.
</p>


<h3>Value</h3>

<p>List structure holding the wavelet cross-covariances (correlations)
according to scale.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Whitcher, B., P. Guttorp and D. B. Percival (2000) Wavelet analysis of
covariance with application to atmospheric time series, <em>Journal of
Geophysical Research</em>, <b>105</b>, No. D11, 14,941-14,962.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wave.covariance">wave.covariance</a></code>, <code><a href="#topic+wave.correlation">wave.correlation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figure 7.9 from Gencay, Selcuk and Whitcher (2001)
data(exchange)
returns &lt;- diff(log(exchange))
returns &lt;- ts(returns, start=1970, freq=12)
wf &lt;- "d4"
demusd.modwt &lt;- modwt(returns[,"DEM.USD"], wf, 8)
demusd.modwt.bw &lt;- brick.wall(demusd.modwt, wf)
jpyusd.modwt &lt;- modwt(returns[,"JPY.USD"], wf, 8)
jpyusd.modwt.bw &lt;- brick.wall(jpyusd.modwt, wf)
n &lt;- dim(returns)[1]
J &lt;- 6
lmax &lt;- 36
returns.cross.cor &lt;- NULL
for(i in 1:J) {
  blah &lt;- spin.correlation(demusd.modwt.bw[[i]], jpyusd.modwt.bw[[i]], lmax)
  returns.cross.cor &lt;- cbind(returns.cross.cor, blah)
}
returns.cross.cor &lt;- ts(as.matrix(returns.cross.cor), start=-36, freq=1)
dimnames(returns.cross.cor) &lt;- list(NULL, paste("Level", 1:J))
lags &lt;- length(-lmax:lmax)
lower.ci &lt;- tanh(atanh(returns.cross.cor) - qnorm(0.975) /
                 sqrt(matrix(trunc(n/2^(1:J)), nrow=lags, ncol=J, byrow=TRUE)
                      - 3))
upper.ci &lt;- tanh(atanh(returns.cross.cor) + qnorm(0.975) /
                 sqrt(matrix(trunc(n/2^(1:J)), nrow=lags, ncol=J, byrow=TRUE)
                      - 3))
par(mfrow=c(3,2), las=1, pty="m", mar=c(5,4,4,2)+.1)
for(i in J:1) {
  plot(returns.cross.cor[,i], ylim=c(-1,1), xaxt="n", xlab="Lag (months)",
       ylab="", main=dimnames(returns.cross.cor)[[2]][i])
  axis(side=1, at=seq(-36, 36, by=12))
  lines(lower.ci[,i], lty=1, col=2)
  lines(upper.ci[,i], lty=1, col=2)
  abline(h=0,v=0)
}

</code></pre>

<hr>
<h2 id='spp.mle'>Wavelet-based Maximum Likelihood Estimation for Seasonal Persistent
Processes</h2><span id='topic+spp.mle'></span><span id='topic+spp2.mle'></span>

<h3>Description</h3>

<p>Parameter estimation for a seasonal persistent (seasonal long-memory)
process is performed via maximum likelihood on the wavelet coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp.mle(y, wf, J = log(length(y), 2) - 1, p = 0.01, frac = 1)

spp2.mle(y, wf, J = log(length(y), 2) - 1, p = 0.01, dyadic = TRUE, frac = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp.mle_+3A_y">y</code></td>
<td>
<p>Not necessarily dyadic length time series.</p>
</td></tr>
<tr><td><code id="spp.mle_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.  See
<code><a href="#topic+wave.filter">wave.filter</a></code> for those wavelet filters available.</p>
</td></tr>
<tr><td><code id="spp.mle_+3A_j">J</code></td>
<td>
<p>Depth of the discrete wavelet packet transform.</p>
</td></tr>
<tr><td><code id="spp.mle_+3A_p">p</code></td>
<td>
<p>Level of significance for the white noise testing procedure.</p>
</td></tr>
<tr><td><code id="spp.mle_+3A_frac">frac</code></td>
<td>
<p>Fraction of the time series that should be used in constructing
the likelihood function.</p>
</td></tr>
<tr><td><code id="spp.mle_+3A_dyadic">dyadic</code></td>
<td>
<p>Logical parameter indicating whether or not the original time
series is dyadic in length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of the original time series is approximated
by its wavelet-based equivalent.  A Whittle-type likelihood is then
constructed where the sums of squared wavelet coefficients are compared to
bandpass filtered version of the true spectral density function.
Minimization occurs for the fractional difference parameter <code class="reqn">d</code> and the
Gegenbauer frequency <code class="reqn">f_G</code>, while the innovations variance is
subsequently estimated.
</p>


<h3>Value</h3>

<p>List containing the maximum likelihood estimates (MLEs) of
<code class="reqn">\delta</code>, <code class="reqn">f_G</code> and <code class="reqn">\sigma^2</code>, along with the value of the
likelihood for those estimates.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Whitcher, B. (2004) Wavelet-based estimation for seasonal
long-memory processes, <em>Technometrics</em>, <b>46</b>, No. 2, 225-238.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdp.mle">fdp.mle</a></code>
</p>

<hr>
<h2 id='spp.var'>Variance of a Seasonal Persistent Process</h2><span id='topic+spp.var'></span><span id='topic+Hypergeometric'></span>

<h3>Description</h3>

<p>Computes the variance of a seasonal persistent (SP) process using a
hypergeometric series expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spp.var(d, fG, sigma2 = 1)

Hypergeometric(a, b, c, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spp.var_+3A_d">d</code></td>
<td>
<p>Fractional difference parameter.</p>
</td></tr>
<tr><td><code id="spp.var_+3A_fg">fG</code></td>
<td>
<p>Gegenbauer frequency.</p>
</td></tr>
<tr><td><code id="spp.var_+3A_sigma2">sigma2</code></td>
<td>
<p>Innovations variance.</p>
</td></tr>
<tr><td><code id="spp.var_+3A_a">a</code>, <code id="spp.var_+3A_b">b</code>, <code id="spp.var_+3A_c">c</code>, <code id="spp.var_+3A_z">z</code></td>
<td>
<p>Parameters for the hypergeometric series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Lapsa (1997).  The subroutine to compute a hypergeometric series was
taken from <em>Numerical Recipes in C</em>.
</p>


<h3>Value</h3>

<p>The variance of an SP process.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Lapsa, P.M. (1997) Determination of Gegenbauer-type random
process models.  <em>Signal Processing</em> <b>63</b>, 73-90.
</p>
<p>Press, W.H., S.A. Teukolsky, W.T. Vetterling and B.P. Flannery (1992)
<em>Numerical Recipes in C</em>, 2nd edition, Cambridge University Press.
</p>

<hr>
<h2 id='squared.gain'>Squared Gain Function of a Filter</h2><span id='topic+squared.gain'></span>

<h3>Description</h3>

<p>Produces the modulus squared of the Fourier transform for a given filtering
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squared.gain(wf.name, filter.seq = "L", n = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squared.gain_+3A_wf.name">wf.name</code></td>
<td>
<p>Character string of wavelet filter.</p>
</td></tr>
<tr><td><code id="squared.gain_+3A_filter.seq">filter.seq</code></td>
<td>
<p>Character string of filter sequence.  <code>H</code> means
high-pass filtering and <code>L</code> means low-pass filtering.  Sequence is read
from right to left.</p>
</td></tr>
<tr><td><code id="squared.gain_+3A_n">n</code></td>
<td>
<p>Length of zero-padded filter.  Frequency resolution will be
<code>n</code>/2+1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>cascade</code> subroutine to compute the squared gain function from a
given filtering sequence.
</p>


<h3>Value</h3>

<p>Squared gain function.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wave.filter">wave.filter</a></code>, <code><a href="#topic+wavelet.filter">wavelet.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
par(mfrow=c(2,2))
f.seq &lt;- "H"
plot(0:256/512, squared.gain("d4", f.seq), type="l", ylim=c(0,2),
     xlab="frequency", ylab="L = 4", main="Level 1")
lines(0:256/512, squared.gain("fk4", f.seq), col=2)
lines(0:256/512, squared.gain("mb4", f.seq), col=3)
abline(v=c(1,2)/4, lty=2)
legend(-.02, 2, c("Daubechies", "Fejer-Korovkin", "Minimum-Bandwidth"),
       lty=1, col=1:3, bty="n", cex=1)
f.seq &lt;- "HL"
plot(0:256/512, squared.gain("d4", f.seq), type="l", ylim=c(0,4),
     xlab="frequency", ylab="", main="Level 2")
lines(0:256/512, squared.gain("fk4", f.seq), col=2)
lines(0:256/512, squared.gain("mb4", f.seq), col=3)
abline(v=c(1,2)/8, lty=2)
f.seq &lt;- "H"
plot(0:256/512, squared.gain("d8", f.seq), type="l", ylim=c(0,2),
     xlab="frequency", ylab="L = 8", main="")
lines(0:256/512, squared.gain("fk8", f.seq), col=2)
lines(0:256/512, squared.gain("mb8", f.seq), col=3)
abline(v=c(1,2)/4, lty=2)
f.seq &lt;- "HL"
plot(0:256/512, squared.gain("d8", f.seq), type="l", ylim=c(0,4),
     xlab="frequency", ylab="", main="")
lines(0:256/512, squared.gain("fk8", f.seq), col=2)
lines(0:256/512, squared.gain("mb8", f.seq), col=3)
abline(v=c(1,2)/8, lty=2)

</code></pre>

<hr>
<h2 id='stackPlot'>Stack Plot</h2><span id='topic+stackPlot'></span>

<h3>Description</h3>

<p>Stack plot of an object.  This function attempts to mimic a function called
<code>stack.plot</code> in S+WAVELETS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackPlot(
  x,
  plot.type = c("multiple", "single"),
  panel = lines,
  log = "",
  col = par("col"),
  bg = NA,
  pch = par("pch"),
  cex = par("cex"),
  lty = par("lty"),
  lwd = par("lwd"),
  ann = par("ann"),
  xlab = "Time",
  main = NULL,
  oma = c(6, 0, 5, 0),
  layout = NULL,
  same.scale = 1:dim(x)[2],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackPlot_+3A_x">x</code></td>
<td>
<p><code>ts</code> object</p>
</td></tr>
<tr><td><code id="stackPlot_+3A_plot.type">plot.type</code>, <code id="stackPlot_+3A_panel">panel</code>, <code id="stackPlot_+3A_log">log</code>, <code id="stackPlot_+3A_col">col</code>, <code id="stackPlot_+3A_bg">bg</code>, <code id="stackPlot_+3A_pch">pch</code>, <code id="stackPlot_+3A_cex">cex</code>, <code id="stackPlot_+3A_lty">lty</code>, <code id="stackPlot_+3A_lwd">lwd</code>, <code id="stackPlot_+3A_ann">ann</code>, <code id="stackPlot_+3A_xlab">xlab</code>, <code id="stackPlot_+3A_main">main</code>, <code id="stackPlot_+3A_oma">oma</code>, <code id="stackPlot_+3A_...">...</code></td>
<td>
<p>See
<code>plot.ts</code>.</p>
</td></tr>
<tr><td><code id="stackPlot_+3A_layout">layout</code></td>
<td>
<p>Doublet defining the dimension of the panel.  If not
specified, the dimensions are chosen automatically.</p>
</td></tr>
<tr><td><code id="stackPlot_+3A_same.scale">same.scale</code></td>
<td>
<p>Vector the same length as the number of series to be
plotted.  If not specified, all panels will have unique axes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a set of plots, one for each element (column) of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>

<hr>
<h2 id='testing.hov'>Testing for Homogeneity of Variance</h2><span id='topic+testing.hov'></span>

<h3>Description</h3>

<p>A recursive algorithm for detecting and locating multiple variance change
points in a sequence of random variables with long-range dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testing.hov(x, wf, J, min.coef = 128, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testing.hov_+3A_x">x</code></td>
<td>
<p>Sequence of observations from a (long memory) time series.</p>
</td></tr>
<tr><td><code id="testing.hov_+3A_wf">wf</code></td>
<td>
<p>Name of the wavelet filter to use in the decomposition.</p>
</td></tr>
<tr><td><code id="testing.hov_+3A_j">J</code></td>
<td>
<p>Specifies the depth of the decomposition.  This must be a number
less than or equal to <code class="reqn">\log(\mbox{length}(x),2)</code>.</p>
</td></tr>
<tr><td><code id="testing.hov_+3A_min.coef">min.coef</code></td>
<td>
<p>Minimum number of wavelet coefficients for testing purposes.
Empirical results suggest that 128 is a reasonable number in order to apply
asymptotic critical values.</p>
</td></tr>
<tr><td><code id="testing.hov_+3A_debug">debug</code></td>
<td>
<p>Boolean variable: if set to <code>TRUE</code>, actions taken by the
algorithm are printed to the screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details see Section 9.6 of Percival and Walden (2000) or Section 7.3 in
Gencay, Selcuk and Whitcher (2001).
</p>


<h3>Value</h3>

<p>Matrix whose columns include (1) the level of the wavelet transform
where the variance change occurs, (2) the value of the test statistic, (3)
the DWT coefficient where the change point is located, (4) the MODWT
coefficient where the change point is located.  Note, there is currently no
checking that the MODWT is contained within the associated support of the
DWT coefficient.  This could lead to incorrect estimates of the location of
the variance change.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwt">dwt</a></code>, <code><a href="#topic+modwt">modwt</a></code>, <code><a href="#topic+rotcumvar">rotcumvar</a></code>,
<code><a href="#topic+mult.loc">mult.loc</a></code>.
</p>

<hr>
<h2 id='tourism'>U.S. Tourism</h2><span id='topic+tourism'></span>

<h3>Description</h3>

<p>Quarterly U.S. tourism figures from 1960:1 to 1999:4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tourism)
</code></pre>


<h3>Format</h3>

<p>A vector containing 160 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='unemploy'>U.S. Unemployment</h2><span id='topic+unemploy'></span>

<h3>Description</h3>

<p>Monthly U.S. unemployment figures from 1948:1 to 1999:12.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(unemploy)
</code></pre>


<h3>Format</h3>

<p>A vector containing 624 observations.
</p>


<h3>Source</h3>

<p>Unknown.
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>

<hr>
<h2 id='up.sample'>Upsampling of a vector</h2><span id='topic+up.sample'></span>

<h3>Description</h3>

<p>Upsamples a given vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>up.sample(x, f, y = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="up.sample_+3A_x">x</code></td>
<td>
<p>vector of observations</p>
</td></tr>
<tr><td><code id="up.sample_+3A_f">f</code></td>
<td>
<p>frequency of upsampling; e.g, 2, 4, etc.</p>
</td></tr>
<tr><td><code id="up.sample_+3A_y">y</code></td>
<td>
<p>value to upsample with; e.g., NA, 0, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector twice its length.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Any basic signal processing text.
</p>

<hr>
<h2 id='wave.filter'>Select a Wavelet Filter</h2><span id='topic+wave.filter'></span>

<h3>Description</h3>

<p>Converts name of wavelet filter to filter coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.filter(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave.filter_+3A_name">name</code></td>
<td>
<p>Character string of wavelet filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple <code>switch</code> statement selects the appropriate filter.
</p>


<h3>Value</h3>

<p>List containing the following items: </p>
<table>
<tr><td><code>L</code></td>
<td>
<p>Length of the wavelet
filter.</p>
</td></tr> <tr><td><code>hpf</code></td>
<td>
<p>High-pass filter coefficients.</p>
</td></tr> <tr><td><code>lpf</code></td>
<td>
<p>Low-pass
filter coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Daubechies, I. (1992) <em>Ten Lectures on Wavelets</em>, CBMS-NSF
Regional Conference Series in Applied Mathematics, SIAM: Philadelphia.
</p>
<p>Doroslovacki (1998) On the least asymmetric wavelets, <em>IEEE
Transactions for Signal Processing</em>, <b>46</b>, No. 4, 1125-1130.
</p>
<p>Morris and Peravali (1999) Minimum-bandwidth discrete-time wavelets,
<em>Signal Processing</em>, <b>76</b>, No. 2, 181-193.
</p>
<p>Nielsen, M. (2000) On the Construction and Frequency Localization of
Orthogonal Quadrature Filters, <em>Journal of Approximation Theory</em>,
<b>108</b>, No. 1, 36-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wavelet.filter">wavelet.filter</a></code>, <code><a href="#topic+squared.gain">squared.gain</a></code>.
</p>

<hr>
<h2 id='wave.variance'>Wavelet Analysis of Univariate/Bivariate Time Series</h2><span id='topic+wave.variance'></span><span id='topic+wave.covariance'></span><span id='topic+wave.correlation'></span>

<h3>Description</h3>

<p>Produces an estimate of the multiscale variance, covariance or correlation
along with approximate confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.variance(x, type = "eta3", p = 0.025)

wave.covariance(x, y)

wave.correlation(x, y, N, p = 0.975)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave.variance_+3A_x">x</code></td>
<td>
<p>first time series</p>
</td></tr>
<tr><td><code id="wave.variance_+3A_type">type</code></td>
<td>
<p>character string describing confidence interval calculation;
valid methods are <code>gaussian</code>, <code>eta1</code>, <code>eta2</code>, <code>eta3</code>,
<code>nongaussian</code></p>
</td></tr>
<tr><td><code id="wave.variance_+3A_p">p</code></td>
<td>
<p>(one minus the) two-sided p-value for the confidence interval</p>
</td></tr>
<tr><td><code id="wave.variance_+3A_y">y</code></td>
<td>
<p>second time series</p>
</td></tr>
<tr><td><code id="wave.variance_+3A_n">N</code></td>
<td>
<p>length of time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time-independent wavelet variance is basically the average of the
squared wavelet coefficients across each scale.  As shown in Percival
(1995), the wavelet variance is a scale-by-scale decomposition of the
variance for a stationary process, and certain non-stationary processes.
</p>


<h3>Value</h3>

<p>Matrix with as many rows as levels in the wavelet transform object.
The first column provides the point estimate for the wavelet variance,
covariance, or correlation followed by the lower and upper bounds from the
confidence interval.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Gencay, R., F. Selcuk and B. Whitcher (2001) <em>An
Introduction to Wavelets and Other Filtering Methods in Finance and
Economics</em>, Academic Press.
</p>
<p>Percival, D. B. (1995) <em>Biometrika</em>, <b>82</b>, No. 3, 619-631.
</p>
<p>Percival, D. B. and A. T. Walden (2000) <em>Wavelet Methods for Time
Series Analysis</em>, Cambridge University Press.
</p>
<p>Whitcher, B., P. Guttorp and D. B. Percival (2000) Wavelet Analysis of
Covariance with Application to Atmospheric Time Series, <em>Journal of
Geophysical Research</em>, <b>105</b>, No. D11, 14,941-14,962.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figure 7.3 from Gencay, Selcuk and Whitcher (2001)
data(ar1)
ar1.modwt &lt;- modwt(ar1, "haar", 6)
ar1.modwt.bw &lt;- brick.wall(ar1.modwt, "haar")
ar1.modwt.var2 &lt;- wave.variance(ar1.modwt.bw, type="gaussian")
ar1.modwt.var &lt;- wave.variance(ar1.modwt.bw, type="nongaussian")
par(mfrow=c(1,1), las=1, mar=c(5,4,4,2)+.1)
matplot(2^(0:5), ar1.modwt.var2[-7,], type="b", log="xy",
        xaxt="n", ylim=c(.025, 6), pch="*LU", lty=1, col=c(1,4,4),
        xlab="Wavelet Scale", ylab="")
matlines(2^(0:5), as.matrix(ar1.modwt.var)[-7,2:3], type="b",
         pch="LU", lty=1, col=3)
axis(side=1, at=2^(0:5))
legend(1, 6, c("Wavelet variance", "Gaussian CI", "Non-Gaussian CI"),
       lty=1, col=c(1,4,3), bty="n")

## Figure 7.8 from Gencay, Selcuk and Whitcher (2001)
data(exchange)
returns &lt;- diff(log(as.matrix(exchange)))
returns &lt;- ts(returns, start=1970, freq=12)
wf &lt;- "d4"
J &lt;- 6
demusd.modwt &lt;- modwt(returns[,"DEM.USD"], wf, J)
demusd.modwt.bw &lt;- brick.wall(demusd.modwt, wf)
jpyusd.modwt &lt;- modwt(returns[,"JPY.USD"], wf, J)
jpyusd.modwt.bw &lt;- brick.wall(jpyusd.modwt, wf)
returns.modwt.cov &lt;- wave.covariance(demusd.modwt.bw, jpyusd.modwt.bw)
par(mfrow=c(1,1), las=0, mar=c(5,4,4,2)+.1)
matplot(2^(0:(J-1)), returns.modwt.cov[-(J+1),], type="b", log="x",
        pch="*LU", xaxt="n", lty=1, col=c(1,4,4), xlab="Wavelet Scale", 
        ylab="Wavelet Covariance")
axis(side=1, at=2^(0:7))
abline(h=0)

returns.modwt.cor &lt;- wave.correlation(demusd.modwt.bw, jpyusd.modwt.bw,
                                      N = dim(returns)[1])
par(mfrow=c(1,1), las=0, mar=c(5,4,4,2)+.1)
matplot(2^(0:(J-1)), returns.modwt.cor[-(J+1),], type="b", log="x",
        pch="*LU", xaxt="n", lty=1, col=c(1,4,4), xlab="Wavelet Scale", 
        ylab="Wavelet Correlation")
axis(side=1, at=2^(0:7))
abline(h=0)

</code></pre>

<hr>
<h2 id='wave.variance.2d'>Wavelet Analysis of Images</h2><span id='topic+wave.variance.2d'></span>

<h3>Description</h3>

<p>Produces an estimate of the multiscale variance with approximate 
confidence intervals using the 2D MODWT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave.variance.2d(x, p = 0.025)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wave.variance.2d_+3A_x">x</code></td>
<td>
<p>image</p>
</td></tr>
<tr><td><code id="wave.variance.2d_+3A_p">p</code></td>
<td>
<p>(one minus the) two-sided p-value for the confidence interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wavelet variance is basically the average of the squared wavelet 
coefficients across each scale and direction of an image. As shown 
in Mondal and Percival (2012), the wavelet variance is a 
scale-by-scale decomposition of the variance for a stationary spatial
process, and certain non-stationary spatial processes.
</p>


<h3>Value</h3>

<p>Data frame with 3J+1 rows.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Mondal, D. and D. B. Percival (2012). Wavelet variance 
analysis for random fields on a regular lattice. <em>IEEE 
Transactions on Image Processing</em> <b>21</b>, 537549.
</p>

<hr>
<h2 id='wavelet.filter'>Higher-Order Wavelet Filters</h2><span id='topic+wavelet.filter'></span>

<h3>Description</h3>

<p>Create a wavelet filter at arbitrary scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavelet.filter(wf.name, filter.seq = "L", n = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wavelet.filter_+3A_wf.name">wf.name</code></td>
<td>
<p>Character string of wavelet filter.</p>
</td></tr>
<tr><td><code id="wavelet.filter_+3A_filter.seq">filter.seq</code></td>
<td>
<p>Character string of filter sequence.  <code>H</code> means
high-pass filtering and <code>L</code> means low-pass filtering.  Sequence is read
from right to left.</p>
</td></tr>
<tr><td><code id="wavelet.filter_+3A_n">n</code></td>
<td>
<p>Length of zero-padded filter.  Frequency resolution will be
<code>n</code>/2+1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>cascade</code> subroutine to compute higher-order wavelet coefficient
vector from a given filtering sequence.
</p>


<h3>Value</h3>

<p>Vector of wavelet coefficients.
</p>


<h3>Author(s)</h3>

<p>B. Whitcher
</p>


<h3>References</h3>

<p>Bruce, A. and H.-Y. Gao (1996).  <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>
<p>Doroslovacki, M. L. (1998) On the least asymmetric wavelets, <em>IEEE
Transactions on Signal Processing</em>, <b>46</b>, No. 4, 1125-1130.
</p>
<p>Daubechies, I. (1992) <em>Ten Lectures on Wavelets</em>, CBMS-NSF Regional
Conference Series in Applied Mathematics, SIAM: Philadelphia.
</p>
<p>Morris and Peravali (1999) Minimum-bandwidth discrete-time wavelets,
<em>Signal Processing</em>, <b>76</b>, No. 2, 181-193.
</p>
<p>Nielsen, M. (2001) On the Construction and Frequency Localization of Finite
Orthogonal Quadrature Filters, <em>Journal of Approximation Theory</em>,
<b>108</b>, No. 1, 36-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+squared.gain">squared.gain</a></code>, <code><a href="#topic+wave.filter">wave.filter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Figure 4.14 in Gencay, Selcuk and Whitcher (2001)
par(mfrow=c(3,1), mar=c(5-2,4,4-1,2))
f.seq &lt;- "HLLLLL"
plot(c(rep(0,33), wavelet.filter("mb4", f.seq), rep(0,33)), type="l",
     xlab="", ylab="", main="D(4) in black, MB(4) in red")
lines(c(rep(0,33), wavelet.filter("d4", f.seq), rep(0,33)), col=2)
plot(c(rep(0,35), -wavelet.filter("mb8", f.seq), rep(0,35)), type="l",
     xlab="", ylab="", main="D(8) in black, -MB(8) in red")
lines(c(rep(0,35), wavelet.filter("d8", f.seq), rep(0,35)), col=2)
plot(c(rep(0,39), wavelet.filter("mb16", f.seq), rep(0,39)), type="l",
     xlab="", ylab="", main="D(16) in black, MB(16) in red")
lines(c(rep(0,39), wavelet.filter("d16", f.seq), rep(0,39)), col=2)

</code></pre>

<hr>
<h2 id='xbox'>Image with Box and X</h2><span id='topic+xbox'></span>

<h3>Description</h3>

<p style="text-align: center;"><code class="reqn">xbox(i,j) = I_{[i=n/4,\;3n/4,\;j;~ n/4 \leq j \leq 3n/4]} + </code>
</p>
<p style="text-align: center;"><code class="reqn"> I_{[n/4 \leq i \leq 3n/4;~
j=n/4,\;3n/4,\;i]}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>data(xbox)
</code></pre>


<h3>Format</h3>

<p>A 128 <code class="reqn">\times</code> 128 matrix.
</p>


<h3>Source</h3>

<p>S+WAVELETS.
</p>


<h3>References</h3>

<p>Bruce, A., and H.-Y. Gao (1996) <em>Applied Wavelet Analysis
with S-PLUS</em>, Springer: New York.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
