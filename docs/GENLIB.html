<!DOCTYPE html><html><head><title>Help for package GENLIB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GENLIB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Classes+20of+20basic+20handling+20of+20genealogy+20data'><p>Classes <code>"GLmultiVector"</code> <code>"GLmultiArray4"</code> <code>"GLmultiMatrix"</code> <code>"GLmultiNumber"</code></p></a></li>
<li><a href='#Classes+20of+20GLgroup+20handling'><p>Classes <code>"GLmultiPhiGroup"</code> <code>"GLmultiPhiGroupSingle"</code> <code>"GLmultiFGroup"</code> <code>"GLmultiFGroupSingle"</code> <code>"GLCGMatrixGroupSingle"</code></p></a></li>
<li><a href='#gen.branching'><p>Genealogy subset</p></a></li>
<li><a href='#gen.children'><p>Get id numbers of children</p></a></li>
<li><a href='#gen.climbPAR'><p>Internal function used by gen.findMRCA</p></a></li>
<li><a href='#gen.completeness'><p>Completeness</p></a></li>
<li><a href='#gen.completenessVar'><p>Variance of completeness index</p></a></li>
<li><a href='#gen.depth'><p>Genealogy depth</p></a></li>
<li><a href='#gen.f'><p>Inbreeding coefficient</p></a></li>
<li><a href='#gen.fCI'><p>Average inbreeding coefficient confidence interval</p></a></li>
<li><a href='#gen.find.Min.Distance.MRCA'><p>Finds the minimum distances between pairs of individuals given a set of ancestors.</p></a></li>
<li><a href='#gen.findDistance'><p>Minimum genetic distance between two individuals</p></a></li>
<li><a href='#gen.findFounders'><p>Find common founder ancestors</p></a></li>
<li><a href='#gen.findMRCA'><p>Finding most recent common ancestors, MRCAs</p></a></li>
<li><a href='#gen.founder'><p>Get founder id numbers</p></a></li>
<li><a href='#gen.gc'><p>Genetic contribution of ancestors</p></a></li>
<li><a href='#gen.genealogy'><p>Create object of class GLgen</p></a></li>
<li><a href='#gen.genout'><p>Create pedigree data</p></a></li>
<li><a href='#gen.getAncestorsPAR'><p>Internal function used by gen.findMRCA</p></a></li>
<li><a href='#gen.getFoundersPAR'><p>Internal function used by gen.findFounders</p></a></li>
<li><a href='#gen.graph'><p>Pedigree graphical tool</p></a></li>
<li><a href='#gen.half.founder'><p>Get half-founder id numbers</p></a></li>
<li><a href='#gen.implex'><p>Genealogical implex</p></a></li>
<li><a href='#gen.implexVar'><p>Variance of genealogical implex</p></a></li>
<li><a href='#gen.lineages'><p>Create object of class GLgen for maternal or paternal lineages</p></a></li>
<li><a href='#gen.max'><p>Maximum number of generations</p></a></li>
<li><a href='#gen.mean'><p>Mean number of generations</p></a></li>
<li><a href='#gen.meangendepth'><p>Expected Genealogical Depth</p></a></li>
<li><a href='#gen.meangendepthVar'><p>Variance of genealogical depth</p></a></li>
<li><a href='#gen.min'><p>Minimum number of generations</p></a></li>
<li><a href='#gen.nochildren'><p>Number of children</p></a></li>
<li><a href='#gen.noind'><p>Number of individuals</p></a></li>
<li><a href='#gen.nomen'><p>Number of men</p></a></li>
<li><a href='#gen.nowomen'><p>Number of women</p></a></li>
<li><a href='#gen.occ'><p>Ancestor occurences</p></a></li>
<li><a href='#gen.parent'><p>Get id numbers of parents</p></a></li>
<li><a href='#gen.phi'><p>Kinship coefficient</p></a></li>
<li><a href='#gen.phiCI'><p>Average kinship confidence interval</p></a></li>
<li><a href='#gen.phiMean'><p>Average kinship</p></a></li>
<li><a href='#gen.phiOver'><p>Kinship above threshold</p></a></li>
<li><a href='#gen.pro'><p>Get proband id numbers</p></a></li>
<li><a href='#gen.rec'><p>Ancestors coverage</p></a></li>
<li><a href='#gen.sibship'><p>Get id numbers of siblings</p></a></li>
<li><a href='#gen.simuHaplo'><p>Gene dropping simulations - haplotypes</p></a></li>
<li><a href='#gen.simuHaplo_convert'><p>Convert proband simulation results into sequence data given founder haplotypes</p></a></li>
<li><a href='#gen.simuHaplo_IBD_compare'><p>Compare proband haplotypes for IBD sharing</p></a></li>
<li><a href='#gen.simuHaplo_traceback'><p>Trace inheritance path for results from gene dropping simulation</p></a></li>
<li><a href='#gen.simuProb'><p>Gene dropping simulations - Probabilities</p></a></li>
<li><a href='#gen.simuSample'><p>Gene dropping simulations - Sample</p></a></li>
<li><a href='#gen.simuSampleFreq'><p>Gene dropping simulations - Frequencies</p></a></li>
<li><a href='#gen.simuSet'><p>Gene dropping simulations with specified transmission probabilities</p></a></li>
<li><a href='#genea140'><p>Genealogical information for 140 individuals from the Quebec Reference Sample</p></a></li>
<li><a href='#geneaJi'><p>Highly inbred pedigree</p></a></li>
<li><a href='#GLgen-class'><p>Class <code>"GLgen"</code></p></a></li>
<li><a href='#GLgroup-class'><p>Class <code>"GLgroup"</code></p></a></li>
<li><a href='#GLmultiList-class'><p>Class <code>"GLmultiList"</code></p></a></li>
<li><a href='#pop140'><p>Population of origin of the 140 Quebec samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genealogical Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Genealogical data analysis including descriptive statistics (e.g., kinship and inbreeding coefficients) and gene-dropping simulations. See: "GENLIB: an R package for the analysis of genealogical data" Gauvin et al. (2015) &lt;<a href="https://doi.org/10.1186%2Fs12859-015-0581-5">doi:10.1186/s12859-015-0581-5</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), Rcpp (&ge; 0.9.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>kinship2, methods, bootstrap, Matrix, lattice, quadprog,
foreach, parallel, doParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Louis Houde [aut],
  Jean-Francois Lefebvre [aut],
  Valery Roy-Lagace [aut],
  Sebastien Lemieux [aut],
  Michael J. Fromberger [ctb],
  Jarno van der Kolk [ctb],
  Mohan Rakesh [ctb],
  Marie-Helene Roy-Gagnon [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marie-Helene Roy-Gagnon &lt;r.genlib@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 09:03:06 UTC; Mohan</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-19 19:20:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='Classes+20of+20basic+20handling+20of+20genealogy+20data'>Classes <code>"GLmultiVector"</code> <code>"GLmultiArray4"</code> <code>"GLmultiMatrix"</code> <code>"GLmultiNumber"</code></h2><span id='topic+GLmultiVector-class'></span><span id='topic+GLmultiArray4-class'></span><span id='topic+GLmultiMatrix-class'></span><span id='topic+GLmultiNumber-class'></span><span id='topic++5B+3C-+2CGLmultiVector+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiVector+2CANY+2CANY+2CANY-method'></span><span id='topic+depth+2CGLmultiVector-method'></span><span id='topic+Dim+2CGLmultiVector-method'></span><span id='topic++5B+3C-+2CGLmultiArray4+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiArray4+2CANY+2CANY+2CANY-method'></span><span id='topic+depth+2CGLmultiArray4-method'></span><span id='topic+Dim+2CGLmultiArray4-method'></span><span id='topic++5B+3C-+2CGLmultiMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic+depth+2CGLmultiMatrix-method'></span><span id='topic+Dim+2CGLmultiMatrix-method'></span><span id='topic++5B+3C-+2CGLmultiNumber+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiNumber+2CANY+2CANY+2CANY-method'></span><span id='topic+depth+2CGLmultiNumber-method'></span><span id='topic+Dim+2CGLmultiNumber-method'></span>

<h3>Description</h3>

<p>Objects created to carry information mostly between invisible functions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("GLmultiVector", 'matrix', depth = 'integer')</code><br />
<code>new("GLmultiArray4", 'Array', depth = 'integer')</code><br />
<code>new("GLmultiMatrix", 'Array', depth = 'integer')</code><br />
<code>new("GLmultiNumber", 'numeric', depth = 'integer', .Names = 'character')</code>
</p>


<h3>Slots</h3>


<p>GLmultiVector
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"matrix"</code> </p>
</dd>
<dt><code>depth</code>:</dt><dd><p>Object of class <code>"integer"</code> </p>
</dd></dl>
<p><br />
GLmultiArray4, GLmultiMatrix
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"array"</code> </p>
</dd>
<dt><code>depth</code>:</dt><dd><p>Object of class <code>"integer"</code> </p>
</dd></dl>
<p><br />
GLmultiNumber
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>depth</code>:</dt><dd><p>Object of class <code>"integer"</code> ~~ </p>
</dd>
<dt><code>.Names</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+array-class">array</a>"</code>, by class &quot;matrix&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;matrix&quot;, distance 3.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;matrix&quot;, distance 4, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "GLmultiVector", i = "ANY", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "GLmultiVector", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>depth</dt><dd><p><code>signature(x = "GLmultiVector")</code>: ... </p>
</dd>
<dt>Dim</dt><dd><p><code>signature(object = "GLmultiVector")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("GLmultiVector")
showClass("GLmultiArray4")
showClass("GLmultiMatrix")
showClass("GLmultiNumber")
</code></pre>

<hr>
<h2 id='Classes+20of+20GLgroup+20handling'>Classes <code>"GLmultiPhiGroup"</code> <code>"GLmultiPhiGroupSingle"</code> <code>"GLmultiFGroup"</code> <code>"GLmultiFGroupSingle"</code> <code>"GLCGMatrixGroupSingle"</code> </h2><span id='topic+GLmultiPhiGroup-class'></span><span id='topic+GLmultiPhiGroupSingle-class'></span><span id='topic+GLmultiFGroup-class'></span><span id='topic+GLmultiFGroupSingle-class'></span><span id='topic+GLCGMatrixGroupSingle-class'></span><span id='topic++5B+3C-+2CGLCGMatrixGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLCGMatrixGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CGLmultiFGroup+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiFGroup+2CANY+2CANY+2CANY-method'></span><span id='topic+Dim+2CGLmultiFGroup-method'></span><span id='topic++5B+3C-+2CGLmultiFGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiFGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic+Dim+2CGLmultiFGroupSingle-method'></span><span id='topic++5B+3C-+2CGLmultiPhiGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiPhiGroupSingle+2CANY+2CANY+2CANY-method'></span><span id='topic+Dim+2CGLmultiPhiGroupSingle-method'></span><span id='topic++5B+3C-+2CGLmultiPhiGroup+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CGLmultiPhiGroup+2CANY+2CANY+2CANY-method'></span><span id='topic+Dim+2CGLmultiPhiGroup-method'></span>

<h3>Description</h3>

<p>Objects used to carry information mostly between invisible functions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <br />
<code>new("GLmultiPhiGroup", MatriceCG, group = 'GLgroup', grindex = 'list')</code> <br />
<code>new("GLmultiPhiGroupSingle", MatriceCG, group = 'GLgroup', grindex = 'list')</code> <br />
<code>new("GLmultiFGroup", MatriceCG, group = 'GLgroup', grindex = 'list')</code> <br />
<code>new("GLmultiFGroupSingle", MatriceCG, group = 'GLgroup', grindex = 'list')</code> <br />
<code>new("GLCGMatrixGroupSingle", MatriceCG, group = 'GLgroup', grindex = 'list')</code>
</p>


<h3>Slots</h3>


<p>GLCGMatrixGroupSingle, GLmultiFGroupSingle, GLmultiPhiGroupSingle
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"matrix"</code> </p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"GLgroup"</code> </p>
</dd>
<dt><code>grindex</code>:</dt><dd><p>Object of class <code>"list"</code> containing the indices of the probands of 'group' </p>
</dd>
</dl>
<p>GLmultiPhiGroup :
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"GLmultiMatrix"</code> </p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"GLgroup"</code> </p>
</dd>
<dt><code>grindex</code>:</dt><dd><p>Object of class <code>"list"</code> containing the indices of the probands of 'group' </p>
</dd>
</dl>
<p>GLmultiFGroup :
</p>
<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"GLmultiVector"</code> </p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"GLgroup"</code> </p>
</dd>
<dt><code>grindex</code>:</dt><dd><p>Object of class <code>"list"</code> containing the indices of the probands of 'group' </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+array-class">array</a>"</code>, by class &quot;matrix&quot;, distance 2.
Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;matrix&quot;, distance 3.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;matrix&quot;, distance 4, with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>[&lt;-</dt><dd><p><code>signature(x = "GLCGMatrixGroupSingle", i = "ANY", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "GLCGMatrixGroupSingle", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>group</dt><dd><p><code>signature(x = "GLCGMatrixGroupSingle")</code>: ... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("GLCGMatrixGroupSingle")
showClass("GLmultiFGroup")
showClass("GLmultiFGroupSingle")
showClass("GLmultiPhiGroupSingle")
showClass("GLmultiPhiGroup")
</code></pre>

<hr>
<h2 id='gen.branching'>Genealogy subset</h2><span id='topic+gen.branching'></span>

<h3>Description</h3>

<p>Creates an object of class GLgen from an existing GLgen object by selecting specified individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.branching( gen, pro = 0, ancestors = gen.founder(gen), bflag = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.branching_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.branching_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.branching_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Default includes all founders in the original GLgen object.</p>
</td></tr>
<tr><td><code id="gen.branching_+3A_bflag">bflag</code></td>
<td>
<p>If set to 0 (default and recommended), probands and founders are filtered to quicken the calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a GLgen object</p>


<h3>Note</h3>

<p>Note that if there are no links between some probands and ancestors, these ids will not be included.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.graph">gen.graph</a></code>
<code><a href="#topic+gen.lineages">gen.lineages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi)
genJi_part&lt;-gen.branching(genJi,pro=c(2,28)) 

# Plots of original genealogy and of the branched version
layout(matrix(1:2,c(1,2),byrow=TRUE))
gen.graph(genJi) 
mtext("Original", line=2, cex=1.2)
gen.graph(genJi_part) 
mtext("Branched tree\nfor individuals 2 and 28", line=1, cex=1.2)

</code></pre>

<hr>
<h2 id='gen.children'>Get id numbers of children</h2><span id='topic+gen.children'></span>

<h3>Description</h3>

<p>Returns the id numbers of the children of specified individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.children( gen, individuals, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.children_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.children_+3A_individuals">individuals</code></td>
<td>
<p>Vector of individual id numbers. Required.</p>
</td></tr>
<tr><td><code id="gen.children_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.pro">gen.pro</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.sibship">gen.sibship</a></code>
<code><a href="#topic+gen.parent">gen.parent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.children(genJi, individuals=14) 

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
children51052&lt;-gen.children(gen140,51052)
gen.graph(gen140, pro=c(children51052))
</code></pre>

<hr>
<h2 id='gen.climbPAR'>Internal function used by gen.findMRCA</h2><span id='topic+gen.climbPAR'></span>

<h3>Description</h3>

<p>gen.climbPAR is an internal function used by gen.findMRCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.climbPAR(gen, individuals, founder)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.climbPAR_+3A_gen">gen</code></td>
<td>
<p>The genealogy to consider.</p>
</td></tr>
<tr><td><code id="gen.climbPAR_+3A_individuals">individuals</code></td>
<td>
<p>probands to consider</p>
</td></tr>
<tr><td><code id="gen.climbPAR_+3A_founder">founder</code></td>
<td>
<p>the founder by which the distance is calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the founder ID and the distance.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.findMRCA">gen.findMRCA</a></code>
<code><a href="#topic+gen.getAncestorsPAR">gen.getAncestorsPAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.findMRCA(genJi, individuals=c(1,29), NbProcess = 1)
</code></pre>

<hr>
<h2 id='gen.completeness'>Completeness</h2><span id='topic+gen.completeness'></span>

<h3>Description</h3>

<p>Returns the completeness of the genealogical data for the specified probands</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.completeness( gen, pro="0", genNo=-1, type="MEAN", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.completeness_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.completeness_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.completeness_+3A_genno">genNo</code></td>
<td>
<p>Vector of generation numbers at which completeness should be calculated.
Default is -1, which calculates completeness at each generation.</p>
</td></tr>
<tr><td><code id="gen.completeness_+3A_type">type</code></td>
<td>
<p>If type=&quot;MEAN&quot; (default), mean completeness over all specified probands is calculated.
If type=&quot;IND&quot;, completeness is calculated for each specified proband.</p>
</td></tr>
<tr><td><code id="gen.completeness_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each generation at which the completeness is calculated as rows and one column when type is &quot;MEAN&quot;.
When type is &quot;IND&quot;, the number of columns equals the number of probands specified.</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.rec">gen.rec</a></code>
<code><a href="#topic+gen.occ">gen.occ</a></code>
<code><a href="#topic+gen.implex">gen.implex</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.completeness(genJi, type="IND")
# For the 4th generation
gen.completeness(genJi, type="IND", genNo=4)

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.completeness(gen140)

</code></pre>

<hr>
<h2 id='gen.completenessVar'>Variance of completeness index</h2><span id='topic+gen.completenessVar'></span>

<h3>Description</h3>

<p>Returns the variance of the completeness index across probands.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.completenessVar( gen, pro = "0", genNo = -1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.completenessVar_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.completenessVar_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.completenessVar_+3A_genno">genNo</code></td>
<td>
<p>Vector of generation numbers at which completeness should be calculated.
Default is -1, which calculates completeness at each generation.</p>
</td></tr>
<tr><td><code id="gen.completenessVar_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one column and each generation at which the variance is calculated as rows.</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.completeness(genJi, type="IND")
gen.completenessVar(genJi)
# For the 4th generation
gen.completenessVar(genJi, genNo=4)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.completeness(gen140)
gen.completenessVar(gen140)

</code></pre>

<hr>
<h2 id='gen.depth'>Genealogy depth</h2><span id='topic+gen.depth'></span>

<h3>Description</h3>

<p>Returns the number of generations in the genealogy from a GLgen object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.depth(gen)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.depth_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.min">gen.min</a></code>
<code><a href="#topic+gen.mean">gen.mean</a></code>
<code><a href="#topic+gen.min">gen.min</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.depth(genJi)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.depth(gen140)

</code></pre>

<hr>
<h2 id='gen.f'>Inbreeding coefficient</h2><span id='topic+gen.f'></span>

<h3>Description</h3>

<p>Returns the inbreeding coefficients of the specified probands</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.f( gen, pro, depthmin= (gen.depth(gen)-1), depthmax= (gen.depth(gen)-1))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.f_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.f_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included.</p>
</td></tr>
<tr><td><code id="gen.f_+3A_depthmin">depthmin</code></td>
<td>
<p>Minimum genealogical depth to consider in the calculation. Default is the whole genealogy.</p>
</td></tr>
<tr><td><code id="gen.f_+3A_depthmax">depthmax</code></td>
<td>
<p>Maximum genealogical depth to consider in the calculation. Default is the whole genealogy.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or GLmultiVector object depending on the number of generations treated.
GLmultiVector is an array of vectors, one for each depth. Array of size ('depthMax'-'depthMin'), vectors of size 'length(pro)'.
A vector of size 'length(pro)' is returned when ('depthMax'-'depthMin') equals 1.</p>


<h3>References</h3>

<p>Malecot G. (1948) Les mathematiques de l'heredite. Paris: Masson, p 65.
</p>
<p>Thompson EA. (1986) Pedigree Analysis in Human Genetics. Baltimore, MD, USA: Johns Hopkins University Press, p 25.
</p>
<p>Karigl G. (1981) A recursive algorithm for the calculation of identity coefficients. Ann Hum Genet 45:299-305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.phi">gen.phi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
f_values&lt;-gen.f(genJi)
f_values
f_allgen&lt;-gen.f(genJi, depthmin=1)  
f_allgen&lt;-unclass(f_allgen)

plot(1:7,f_allgen[1,],type="b",xlab="Generation",ylab="Inbreeding values",ylim=c(0,0.25),pch=0)
points(1:7,f_allgen[3,],  type="b", lty=12, pch=1)
legend("topright", legend=c("Individual 1", "Individual 29"),lty=c(1,12), pch=c(0,1))


data(genea140) 
gen140&lt;-gen.genealogy(genea140)
inbreeding_val&lt;-gen.f(gen140)
boxplot(inbreeding_val, horizontal=TRUE, xlab="Inbreeding values")

</code></pre>

<hr>
<h2 id='gen.fCI'>Average inbreeding coefficient confidence interval</h2><span id='topic+gen.fCI'></span>

<h3>Description</h3>

<p>Returns the confidence interval of the average inbreeding among specified individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.fCI(vectF, prob=c(0.025,0.05,0.95,0.975), b="5000", print.it=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.fCI_+3A_vectf">vectF</code></td>
<td>
<p>A vector of inbreeding coefficients obtained for example with gen.f. Required.</p>
</td></tr>
<tr><td><code id="gen.fCI_+3A_prob">prob</code></td>
<td>
<p>Confidence limits probabilities. Default is probs=c(0.025, 0.05, 0.95, 0.975).</p>
</td></tr>
<tr><td><code id="gen.fCI_+3A_b">b</code></td>
<td>
<p>Number of simulations used to calculate the confidence interval. Default is b=&quot;5000&quot;.</p>
</td></tr>
<tr><td><code id="gen.fCI_+3A_print.it">print.it</code></td>
<td>
<p>If print.it=FALSE (default), progression in the number of simulations performed is not displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a GLmultiVector object depending on the type of 'vectF' entered.
If 'vectF' is a GLmultiVector, an array of vectors (GLmultiVector), one for each depth, is returned.
Array of size ('depthMax'-'depthMin'), vectors of size 'length(probs)'.
If 'vectF' is a GLmultiVector, a vector of size 'length(probs)' is returned.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.f">gen.f</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen10 &lt;-gen.branching(gen140, pro=gen.pro(gen140)[c(1:10)])
fval&lt;-gen.f(gen10)
gen.fCI(fval)
</code></pre>

<hr>
<h2 id='gen.find.Min.Distance.MRCA'>Finds the minimum distances between pairs of individuals given a set of ancestors.</h2><span id='topic+gen.find.Min.Distance.MRCA'></span>

<h3>Description</h3>

<p>Returns the shortest distances (number of meioses) between pairs of probands given the matrix of MRCAs output by the gen.findMRCA function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.find.Min.Distance.MRCA(genMatrix, individuals="ALL", ancestors="ALL")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.find.Min.Distance.MRCA_+3A_genmatrix">genMatrix</code></td>
<td>
<p>Matrix of most recent common ancestors, MRCAs, obtained with gen.findMRCA. Required.</p>
</td></tr>
<tr><td><code id="gen.find.Min.Distance.MRCA_+3A_individuals">individuals</code></td>
<td>
<p>Vector of proband id numbers to include. All are included by default.</p>
</td></tr>
<tr><td><code id="gen.find.Min.Distance.MRCA_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of MRCA id numbers to include. All are included by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.findMRCA">gen.findMRCA</a></code>
<code><a href="#topic+gen.findDistance">gen.findDistance</a></code>
<code><a href="#topic+gen.findFounders">gen.findFounders</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
matMRCA&lt;-gen.findMRCA(genJi, individuals=c(1,29), NbProcess = 1)
gen.find.Min.Distance.MRCA(matMRCA)


# Increasing NbProcess will decrease execution time
data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
matMRCA&lt;-gen.findMRCA(gen140, individuals=c(409033,408728,408828), NbProcess = 1)
gen.find.Min.Distance.MRCA(matMRCA, individuals=c(409033,408728))

</code></pre>

<hr>
<h2 id='gen.findDistance'>Minimum genetic distance between two individuals</h2><span id='topic+gen.findDistance'></span>

<h3>Description</h3>

<p>Returns the minimum distance (number of meioses) between the specified individuals through one specified ancestor.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.findDistance(gen, individuals, ancestor)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.findDistance_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.findDistance_+3A_individuals">individuals</code></td>
<td>
<p>A vector of individual id numbers between which to calculate the distance. Required.</p>
</td></tr>
<tr><td><code id="gen.findDistance_+3A_ancestor">ancestor</code></td>
<td>
<p>A common ancestor to the specified individuals. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric value</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.findMRCA">gen.findMRCA</a></code>
<code><a href="#topic+gen.findFounders">gen.findFounders</a></code>
<code><a href="#topic+gen.find.Min.Distance.MRCA">gen.find.Min.Distance.MRCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.findDistance(genJi, individuals=c(1,29), ancestor=17)
gen.findDistance(genJi, individuals=c(1,29), ancestor=26)

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.findDistance(gen140, individuals=c(409033,408728), ancestor=38714)
gen.findDistance(gen140, individuals=c(408728,408828), ancestor=95080)



</code></pre>

<hr>
<h2 id='gen.findFounders'>Find common founder ancestors</h2><span id='topic+gen.findFounders'></span>

<h3>Description</h3>

<p>Returns all the ancestors that are founders for specified individuals in the genealogy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.findFounders(gen, individuals, NbProcess=parallel::detectCores()-1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.findFounders_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.findFounders_+3A_individuals">individuals</code></td>
<td>
<p>Vector of individual id numbers for which to find the founders. Required</p>
</td></tr>
<tr><td><code id="gen.findFounders_+3A_nbprocess">NbProcess</code></td>
<td>
<p>Number of processes to use when running this function. Default=parallel::detectCores()-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers</p>


<h3>Note</h3>

<p>Uses slave processes to make the search faster. Those slave processes launch the function gen.getFoundersMPI.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.findMRCA">gen.findMRCA</a></code>
<code><a href="#topic+gen.findDistance">gen.findDistance</a></code>
<code><a href="#topic+gen.find.Min.Distance.MRCA">gen.find.Min.Distance.MRCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.founder(genJi)
gen.findFounders(genJi, individuals=c(1,29), NbProcess = 1)

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen2&lt;-gen.branching(gen140,pro=c(409033,408728)) 
# 615 founders in genealogy of #409033 and #408728
all_founders&lt;-gen.founder(gen2) 
length(all_founders)


all_commonFounders&lt;-gen.findFounders(gen140, individuals=c(409033,408728), NbProcess = 1)
length(all_commonFounders) # 127 founders common to #409033 and #408728

</code></pre>

<hr>
<h2 id='gen.findMRCA'>Finding most recent common ancestors, MRCAs</h2><span id='topic+gen.findMRCA'></span>

<h3>Description</h3>

<p>Returns MRCAs of pairs of specified individuals and the distance (number of meioses) between individuals through the MRCAs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.findMRCA(gen, individuals, NbProcess=parallel::detectCores()-1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.findMRCA_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.findMRCA_+3A_individuals">individuals</code></td>
<td>
<p>Vector of individual id numbers for which to find the MRCAs. Required</p>
</td></tr>
<tr><td><code id="gen.findMRCA_+3A_nbprocess">NbProcess</code></td>
<td>
<p>Number of processes to use when running this function. Default=parallel::detectCores()-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a matrix</p>


<h3>Note</h3>

<p>This function uses the parallel programming functions of foreach, snow and doSNOW for launching several processes.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.findFounders">gen.findFounders</a></code>
<code><a href="#topic+gen.findDistance">gen.findDistance</a></code>
<code><a href="#topic+gen.find.Min.Distance.MRCA">gen.find.Min.Distance.MRCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi)
genJi&lt;-gen.genealogy(geneaJi)
gen.findMRCA(genJi, individuals=c(1,29), NbProcess = 1)


 # For a more complex example:
 data(genea140) 
 gen140&lt;-gen.genealogy(genea140) 
 all_commonFounders&lt;-gen.findFounders(gen140, individuals=c(409033,408728), NbProcess = 1)
 # 127 founders common to #409033 and #408728
 length(all_commonFounders)
 # 22 most recent common ancestors for #409033 and #408728
 MRCA_2ind&lt;-gen.findMRCA(gen140, individuals=c(409033,408728), NbProcess = 1)

</code></pre>

<hr>
<h2 id='gen.founder'>Get founder id numbers</h2><span id='topic+gen.founder'></span>

<h3>Description</h3>

<p>Returns the id numbers of the founders. Founders are defined as the individuals without parents in the genealogy (i.e., mother id=0, father id=0).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.founder( gen, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.founder_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.founder_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.pro">gen.pro</a></code>
<code><a href="#topic+gen.half.founder">gen.half.founder</a></code>
<code><a href="#topic+gen.parent">gen.parent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# There are 6 founders
gen.founder(genJi)

data(genea140) 
gen140&lt;-gen.genealogy(genea140)
founder140&lt;-gen.founder(gen140)  
# There are 7399 founders
length(founder140)

</code></pre>

<hr>
<h2 id='gen.gc'>Genetic contribution of ancestors</h2><span id='topic+gen.gc'></span>

<h3>Description</h3>

<p>Returns the genetic contribution of ancestors to the gene pool of sepcifiec probands</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.gc(gen, pro=0, ancestors=0, vctProb=c(0.5,0.5,0.5,0.5), typeCG="IND")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.gc_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.gc_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.gc_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Default is 0, which will select all individuals without parents.</p>
</td></tr>
<tr><td><code id="gen.gc_+3A_vctprob">vctProb</code></td>
<td>
<p>Vector of transmission probabilities. The first two values indicate the probabilities of transmission of a father to his son and daughter, respectively, and the following two values are the same for the mother. Default is vctProb=c(0.5,0.5,0.5,0.5).</p>
</td></tr>
<tr><td><code id="gen.gc_+3A_typecg">typeCG</code></td>
<td>
<p>IF typeCG=&quot;IND&quot; (default), the genetic contribution from each ancestor is calculated for each proband.
If typeCG=&quot;MEAN&quot;, the average (over all probands) genetic contributions of each ancestor is returned.
If typeCG=&quot;PRODUCT&quot;, the product (over all probands) of genetic contributions is returned for each ancestor.
If typeCG=&quot;TOTAL&quot;, the sum (over all probands) of genetic contributions is returned for each ancestor.
If typeCG=&quot;CUMUL&quot;, ancestors are ranked in decreasing order of total contribution and cumulative contribution is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with rows corresponding to probands and columns corrsponding to ancestors when typeCG=&quot;IND&quot;.
For the other typeCG values, rows are ancestors and there is one column containing mean, product, total or cumulative values.</p>


<h3>References</h3>

<p>Roberts DF. (1968) Genetic effects of population size reduction. Nature, 220, 1084-1088. 
</p>
<p>O'Brien E, Jorde LB, Ronnlof B, Fellman JO, Eriksson AW. (1988) Founder effect and genetic disease in Sottunga, Finland. American Journal of Physical Anthropology, 77, 335-346.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.rec">gen.rec</a></code>
<code><a href="#topic+gen.occ">gen.occ</a></code>
<code><a href="#topic+gen.implex">gen.implex</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
<code><a href="#topic+gen.completeness">gen.completeness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gc&lt;-gen.gc(genJi, pro=c(1,29), ancestors=c(3,6,10,12,14,16,18,20,26,28))
gc
gc_cum&lt;-gen.gc(genJi, pro=c(1,29), ancestors=c(3,6,10,12,14,16,18,20,26,28), type="CUMUL")
gc_cum

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gc&lt;-gen.gc(gen140, pro=c(454422,676521,677273,717537,717634,717709,868572), 
           ancestors=c(18305,18528,31114,18325))
gc
# Mother-daughter transmission only with probability=0.5
gc_MoLi&lt;-gen.gc(gen140, pro=c(217891,302718,409282,802424,409682,443151),
		ancestors=c(18321,218231,296200,39066,18679,442607),vctProb=c(0,0,0,0.5))
gc_MoLi
</code></pre>

<hr>
<h2 id='gen.genealogy'>Create object of class GLgen</h2><span id='topic+gen.genealogy'></span>

<h3>Description</h3>

<p>Creates an object of class GLgen that contains the ascending genealogies derived from input data in pedigree format</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.genealogy(ped, autoComplete=FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.genealogy_+3A_ped">ped</code></td>
<td>
<p>A matrix or data frame with the following columns: individual id, father id, mother id, sex. Required.
Individal id numbers must be numeric and unique.
If an individual does not have a father and/or mother, the father and/or mother id numbers must be set to 0.
Sex must be equal to M or 1 for males and F or 2 for females.
The sex column is optional for this function but necessary for some other functions using GLgen objects.</p>
</td></tr>
<tr><td><code id="gen.genealogy_+3A_autocomplete">autoComplete</code></td>
<td>
<p>If TRUE, any non-zero father and mother id numbers not appearing in the individual id column, 
will be added in the individual column as having no father or mother (both set to 0). Default to FALSE.</p>
</td></tr>
<tr><td><code id="gen.genealogy_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class GLgen.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.graph">gen.graph</a></code>
<code><a href="#topic+gen.genout">gen.genout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind&lt;-c(1,2,3,11:21,101:108,201:202)
father&lt;-c(11,15,15,102,0,102,0,103,103,103,105,105,107,107,0,202,0,202,202,0,202,0,0,0)
mother&lt;-c(12,14,14,101,0,101,0,104,104,104,106,106,108,108,0,201,0,201,201,0,201,0,0,0)
sex&lt;-c(1,2,2,1,2,1,2,1,2,1,2,2,2,1,2,1,1,2,1,2,1,2,2,1)
gen.df&lt;-data.frame(ind, father, mother, sex)  
gen.genealogy(gen.df)

data(geneaJi) 
geneaJi[1:5,]
genJi&lt;-gen.genealogy(geneaJi)
# Print basic information about the genealogy
genJi
</code></pre>

<hr>
<h2 id='gen.genout'>Create pedigree data</h2><span id='topic+gen.genout'></span>

<h3>Description</h3>

<p>Creates data frame in pedigree format from an object of class GLgen</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.genout( gen, sorted = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.genout_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.genout_+3A_sorted">sorted</code></td>
<td>
<p>If sorted=FALSE (default), individual id number are not sorted in output data. Id numbers for parents will be placed before their children ids.
If sorted=FALSE, individual id numbers will be sorted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data.frame containing the following:
<strong>ind</strong> 
<strong>father</strong> 
<strong>mother</strong> 
<strong>sex</strong> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.graph">gen.graph</a></code>
<code><a href="#topic+gen.branching">gen.branching</a></code>
<code><a href="#topic+gen.lineages">gen.lineages</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
# Original data is a data.frame
geneaJi[1:12,]

genJi&lt;-gen.genealogy(geneaJi) 
# As a genealogy object
genJi

# Genealogy as a data.frame
genJi_df&lt;-gen.genout(genJi)
genJi_df[1:12,]

# Maternal lineage
genJi_MaLi&lt;-gen.lineages(geneaJi, maternal = TRUE) 
# Maternal lineage as a data.frame
genJi_MaLi_df&lt;-gen.genout(genJi_MaLi)
genJi_MaLi_df
</code></pre>

<hr>
<h2 id='gen.getAncestorsPAR'>Internal function used by gen.findMRCA</h2><span id='topic+gen.getAncestorsPAR'></span>

<h3>Description</h3>

<p>gen.getAncestorsPAR is an internal function used by gen.findMRCA.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.getAncestorsPAR(gen, pro)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.getAncestorsPAR_+3A_gen">gen</code></td>
<td>
<p>The genealogy to consider.</p>
</td></tr>
<tr><td><code id="gen.getAncestorsPAR_+3A_pro">pro</code></td>
<td>
<p>probands to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of the founders identity.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.findMRCA">gen.findMRCA</a></code>
<code><a href="#topic+gen.climbPAR">gen.climbPAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.findMRCA(genJi, individuals=c(1,29), NbProcess = 1)
</code></pre>

<hr>
<h2 id='gen.getFoundersPAR'>Internal function used by gen.findFounders</h2><span id='topic+gen.getFoundersPAR'></span>

<h3>Description</h3>

<p>gen.getFoundersPAR is an internal function used by gen.findFounders.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.getFoundersPAR(gen, pro)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.getFoundersPAR_+3A_gen">gen</code></td>
<td>
<p>The genealogy to consider.</p>
</td></tr>
<tr><td><code id="gen.getFoundersPAR_+3A_pro">pro</code></td>
<td>
<p>probands to consider</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the founders identity.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.findFounders">gen.findFounders</a></code>
<code><a href="#topic+gen.findDistance">gen.findDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.founder(genJi, individuals=c(1,29))
gen.findFounders(genJi, individuals=c(1,29), NbProcess = 1)
</code></pre>

<hr>
<h2 id='gen.graph'>Pedigree graphical tool</h2><span id='topic+gen.graph'></span>

<h3>Description</h3>

<p>Function that plots pedigrees of GLgen objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.graph( gen, pro=gen.pro(gen), ancestors=gen.founder(gen), 
       indVarAffected=gen.genout(gen)$ind, varAffected=gen.genout(gen)$ind, cex="1",
       col="0", symbolsize="1", width="1", packed=FALSE, align=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.graph_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 'gen.pro(gen)', which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Default is 'gen.founder(gen)', which will select all individuals without parents.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_indvaraffected">indVarAffected</code></td>
<td>
<p>Vector of individuals id numbers used for labeling. Default is 'gen.genout(gen)$ind', which is all the individuals of the genealogy.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_varaffected">varAffected</code></td>
<td>
<p>Vector of individuals labels. Default is 'gen.genout(gen)$ind', meaning that the individuals labels are their ids.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_cex">cex</code></td>
<td>
<p>Controls text size (same as kinship2::plot.pedigree).  Default is 1.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_col">col</code></td>
<td>
<p>Color for each id (same as kinship2::plot.pedigree). Default is 0, which assigns the same color to everyone.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_symbolsize">symbolsize</code></td>
<td>
<p>Controls symbolsize (same as kinship2::plot.pedigree). Default is 1.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_width">width</code></td>
<td>
<p>For a packed pedigree, the minimum width allowed in the realignment of pedigrees (same as kinship2::plot.pedigree). Default is 1.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_packed">packed</code></td>
<td>
<p>If TRUE, uniform distance between all individuals at a given level (same as kinship2::plot.pedigree). Default is FALSE.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_align">align</code></td>
<td>
<p>Controls the extra effort spent trying to align children underneath parents, but without making the
pedigree too wide (same as kinship2::plot.pedigree). Default is TRUE.</p>
</td></tr>
<tr><td><code id="gen.graph_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to the kinship2::plot.pedigree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the same invisible list as that returned by kinship2::plot.pedigree, which contains the following:
<strong>plist</strong> list containing the information about the pedigree (n, id, pos, fam, spouse)
<strong>x</strong> x-axis position
<strong>y</strong> y-axis position
<strong>boxw</strong> box width
<strong>boxh</strong> box height
<strong>call</strong> the call made to plot.pedigree() (kinship2 package)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.genout">gen.genout</a></code>
<code><a href="#topic+gen.branching">gen.branching</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind&lt;-c(1,2,3,11:21,101:108,201:202)
father&lt;-c(11,15,15,102,0,102,0,103,103,0,105,105,107,107,0,202,0,202,202,0,202,0,0,0)
mother&lt;-c(12,14,14,101,0,101,0,104,104,0,106,106,108,108,0,201,0,201,201,0,201,0,0,0)
sex&lt;-c(1,2,2,1,2,1,2,1,2,1,2,2,2,1,2,1,1,2,1,2,1,2,2,1)
gen.df&lt;-data.frame(ind, father, mother, sex)  
genEx&lt;-gen.genealogy(gen.df)
gen.graph(genEx)

data(geneaJi) 
geneaJi[1:5,]
genJi&lt;-gen.genealogy(geneaJi)
gen.graph(genJi)
</code></pre>

<hr>
<h2 id='gen.half.founder'>Get half-founder id numbers</h2><span id='topic+gen.half.founder'></span>

<h3>Description</h3>

<p>Returns the id numbers of the half-founders. Half-founders are defined as the individuals with only one known parent in the genealogy (i.e., either mother id=0 or father id=0).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.half.founder( gen, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.half.founder_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.half.founder_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.pro">gen.pro</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.parent">gen.parent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# There are 2 half-founders
gen.half.founder(genJi)
</code></pre>

<hr>
<h2 id='gen.implex'>Genealogical implex</h2><span id='topic+gen.implex'></span>

<h3>Description</h3>

<p>Returns the genealogical implex index (a measure of pedigree collapsing) for the specified probands.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.implex( gen, pro = "0", genNo = -1, type = "MEAN", onlyNewAnc = FALSE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.implex_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.implex_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.implex_+3A_genno">genNo</code></td>
<td>
<p>Vector of generation numbers at which the implex should be calculated.
Default is -1, which calculates the implex at each generation.</p>
</td></tr>
<tr><td><code id="gen.implex_+3A_type">type</code></td>
<td>
<p>If type=&quot;MEAN&quot; (default), implex index values are averaged over all specified probands.
If type=&quot;IND&quot;, the implex index is calculated for all specified proband together.
If type=&quot;ALL&quot;, the implex index is calculated for each specified proband.</p>
</td></tr>
<tr><td><code id="gen.implex_+3A_onlynewanc">onlyNewAnc</code></td>
<td>
<p>If onlyNewAnc=FALSE (default), all ancestors will be considered.
If onlyNewAnc=TRUE, only new ancestors will be counted
(i.e., an ancestor is not counted again if it has already been counted in another generation).</p>
</td></tr>
<tr><td><code id="gen.implex_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each generation at which the completeness is calculated as rows and one column when type is &quot;MEAN&quot;.
When type is &quot;IND&quot;, the number of columns equals the number of probands specified.</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.occ">gen.occ</a></code>
<code><a href="#topic+gen.rec">gen.rec</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
<code><a href="#topic+gen.completeness">gen.completeness</a></code>
<code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.implex(genJi)
gen.implex(genJi, type="IND")
# For the 5th generation
gen.implex(genJi, type="IND", genNo=5) 


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.implex(gen140)
gen.implex(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572))
gen.implex(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572), type="IND")

</code></pre>

<hr>
<h2 id='gen.implexVar'>Variance of genealogical implex</h2><span id='topic+gen.implexVar'></span>

<h3>Description</h3>

<p>Returns the variance of the implex index across probands.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.implexVar( gen, pro = "0", onlyNewAnc = FALSE, genNo = -1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.implexVar_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.implexVar_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.implexVar_+3A_onlynewanc">onlyNewAnc</code></td>
<td>
<p>If onlyNewAnc=FALSE (default), all ancestors will be considered.
If onlyNewAnc=TRUE, only new ancestors will be counted
(i.e., an ancestor is not counted again if it has already been counted in another generation).</p>
</td></tr>
<tr><td><code id="gen.implexVar_+3A_genno">genNo</code></td>
<td>
<p>Vector of generation numbers at which the implex should be calculated.
Default is -1, which calculates the implex at each generation.</p>
</td></tr>
<tr><td><code id="gen.implexVar_+3A_...">...</code></td>
<td>
<p>Additionnal arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one column and each generation at which the variance is calculated as rows</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.implex(genJi, type="IND")
gen.implexVar(genJi)
# For the 5th generation
gen.implexVar(genJi, genNo=5)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.implex(gen140)
gen.implex(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572), type="IND")
gen.implexVar(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572), type="IND")

</code></pre>

<hr>
<h2 id='gen.lineages'>Create object of class GLgen for maternal or paternal lineages</h2><span id='topic+gen.lineages'></span>

<h3>Description</h3>

<p>Creates an object of class GLgen that contains maternal or paternal lineages selected from input data in pedigree format</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.lineages(ped, pro = "0", maternal = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.lineages_+3A_ped">ped</code></td>
<td>
<p>A matrix or data frame with the following columns: individual id, father id, mother id, sex. Required.
Individal id numbers must be numeric and unique.
If an individual does not have a father and/or mother, the father and/or mother id numbers must be set to 0.
All non-zero father and mother id numbers must also appear in the individual id column.
Sex must be equal to M or 1 for males and F or 2 for females.
The sex column is optional for this function but necessary for some other functions using GLgen objects.</p>
</td></tr>
<tr><td><code id="gen.lineages_+3A_pro">pro</code></td>
<td>
<p>Vector of individual id numbers for which lineages should be included. Optional.</p>
</td></tr>
<tr><td><code id="gen.lineages_+3A_maternal">maternal</code></td>
<td>
<p>If mat=TRUE (default), maternal lineages are selected. mat=FALSE returns paternal lineages.</p>
</td></tr>
<tr><td><code id="gen.lineages_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a GLgen object</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.graph">gen.graph</a></code>
<code><a href="#topic+gen.branching">gen.branching</a></code>
<code><a href="#topic+gen.genout">gen.genout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi &lt;- gen.genealogy(geneaJi)
genJi_MaLi&lt;-gen.lineages(geneaJi, maternal = TRUE) 
genJi_FaLi&lt;-gen.lineages(geneaJi, maternal = FALSE) 

# Plots of original genealogy and maternal and paternal lineages
layout(matrix(1:3,c(1,3),byrow=TRUE), widths =c(3,1,1), heights = 1)
gen.graph(genJi) 
mtext("Original", line=2)
gen.graph(genJi_MaLi) 
mtext("Maternal\nlineages", line=1)
gen.graph(genJi_FaLi) 
mtext("Paternal\nlineages", line=1)

</code></pre>

<hr>
<h2 id='gen.max'>Maximum number of generations</h2><span id='topic+gen.max'></span>

<h3>Description</h3>

<p>Returns the maximum number of generations between all probands and the individuals specified. Probands are defined as the individuals without children in the genealogy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.max( gen, individuals)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.max_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.max_+3A_individuals">individuals</code></td>
<td>
<p>A vector of ids specifying the individuals to include in the calculation. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.mean">gen.mean</a></code>
<code><a href="#topic+gen.min">gen.min</a></code>
<code><a href="#topic+gen.depth">gen.depth</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.min(genJi,c(17,26))
gen.mean(genJi,c(17,26))
gen.max(genJi,c(17,26))


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.min(gen140,c(18311,18430))
gen.mean(gen140,c(18311,18430))
gen.max(gen140,c(18311,18430))

</code></pre>

<hr>
<h2 id='gen.mean'>Mean number of generations</h2><span id='topic+gen.mean'></span>

<h3>Description</h3>

<p>Returns the average number of generations between all probands and the individuals specified. Probands are defined as the individuals without children in the genealogy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.mean( gen, individuals)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.mean_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.mean_+3A_individuals">individuals</code></td>
<td>
<p>A vector of ids specifying the individuals to include in the calculation. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric value</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.min">gen.min</a></code>
<code><a href="#topic+gen.max">gen.max</a></code>
<code><a href="#topic+gen.depth">gen.depth</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.min(genJi,c(17,26))
gen.mean(genJi,c(17,26))
gen.max(genJi,c(17,26))


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.min(gen140,c(18311,18430))
gen.mean(gen140,c(18311,18430))
gen.max(gen140,c(18311,18430))
</code></pre>

<hr>
<h2 id='gen.meangendepth'>Expected Genealogical Depth</h2><span id='topic+gen.meangendepth'></span>

<h3>Description</h3>

<p>Returns the expected genealogical depth.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.meangendepth( gen, pro = "0", type = "MEAN", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.meangendepth_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.meangendepth_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.meangendepth_+3A_type">type</code></td>
<td>
<p>If type=&quot;MEAN&quot; (default), mean genealogical depth over all specified probands is calculated.
If type=&quot;IND&quot;, mean genealogical depth is calculated for each specified proband.</p>
</td></tr>
<tr><td><code id="gen.meangendepth_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with only one numeric value when type is &quot;MEAN&quot;.
When type is &quot;IND&quot;, the number of rows equals the number of probands specified.</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>
<p>Kouladjian K. (1986) Une mesure d'entropie genealogique. Chicoutimi, SOREP, Document III-C-43.
</p>
<p>De Brakaeleer M, Bellis G. (1994) Genealogies et reconstitutions de familles en genetique humaine. Dossiers et Recherches, no 43, INED, Paris.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.occ">gen.occ</a></code>
<code><a href="#topic+gen.implex">gen.implex</a></code>
<code><a href="#topic+gen.rec">gen.rec</a></code>
<code><a href="#topic+gen.completeness">gen.completeness</a></code>
<code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.meangendepth(genJi)
gen.meangendepth(genJi, type="IND")


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.meangendepth(gen140)
gen.meangendepth(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572))
gen.meangendepth(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572), type="IND")

</code></pre>

<hr>
<h2 id='gen.meangendepthVar'>Variance of genealogical depth</h2><span id='topic+gen.meangendepthVar'></span>

<h3>Description</h3>

<p>Returns the variance of the genealogical depth</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.meangendepthVar( gen, pro = "0", type = "MEAN", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.meangendepthVar_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.meangendepthVar_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.meangendepthVar_+3A_type">type</code></td>
<td>
<p>If type=&quot;MEAN&quot; (default), the average of genealogical depth variances (over all probands) is returned.
If type=&quot;IND&quot;, the variance of the genealogical depth is calculated for each specified proband.</p>
</td></tr>
<tr><td><code id="gen.meangendepthVar_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with only one numeric value when type is &quot;MEAN&quot;.
When type is &quot;IND&quot;, the number of rows equals the number of probands specified.</p>


<h3>References</h3>

<p>Cazes P, Cazes MH. (1996) Comment mesurer la profondeur genealogique d'une ascendance? Population (French Ed) 51:117-140.
</p>
<p>Kouladjian K. (1986) Une mesure d'entropie genealogique. Chicoutimi, SOREP, Document III-C-43.
</p>
<p>De Brakaeleer M, Bellis G. (1994) Genealogies et reconstitutions de familles en genetique humaine. Dossiers et Recherches, no 43, INED, Paris.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.meangendepth(genJi, type="IND")
gen.meangendepthVar(genJi, type="IND")
gen.meangendepthVar(genJi, type="MEAN")

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.meangendepth(gen140)
probands &lt;- c(454422,676521,677273,717537,717634,717709,868572)
gen.meangendepth(gen140, pro=probands)
gen.meangendepthVar(gen140, pro=probands)
gen.meangendepthVar(gen140, pro=probands, type="MEAN")


gen.meangendepth(gen140, pro=probands, type="IND")
gen.meangendepthVar(gen140, pro=probands, type="IND")

</code></pre>

<hr>
<h2 id='gen.min'>Minimum number of generations</h2><span id='topic+gen.min'></span>

<h3>Description</h3>

<p>Returns the minimum number of generations between all probands and the individuals specified. Probands are defined as the individuals without children in the genealogy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.min( gen, individuals)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.min_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.min_+3A_individuals">individuals</code></td>
<td>
<p>A vector of ids specifying the individuals to include in the calculation. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.mean">gen.mean</a></code>
<code><a href="#topic+gen.max">gen.max</a></code>
<code><a href="#topic+gen.depth">gen.depth</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.min(genJi,c(17,26))
gen.mean(genJi,c(17,26))
gen.max(genJi,c(17,26))


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.min(gen140,c(18311,18430))
gen.mean(gen140,c(18311,18430))
gen.max(gen140,c(18311,18430))
</code></pre>

<hr>
<h2 id='gen.nochildren'>Number of children</h2><span id='topic+gen.nochildren'></span>

<h3>Description</h3>

<p>Returns the number of children for specified individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.nochildren( gen, individuals)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.nochildren_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.nochildren_+3A_individuals">individuals</code></td>
<td>
<p>A vector of ids of the individuals on each of whom the number of chidren is to be returned. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the number of children for each individual sepcified.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.nowomen">gen.nowomen</a></code>
<code><a href="#topic+gen.noind">gen.noind</a></code>
<code><a href="#topic+gen.nomen">gen.nomen</a></code>
<code><a href="#topic+gen.children">gen.children</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.children(genJi,14)
gen.nochildren(genJi,individuals=c(1,12,14,20))

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
children51052&lt;-gen.children(gen140,51052)
gen.nochildren(gen140,51052)
gen.graph(gen140, pro=children51052)
</code></pre>

<hr>
<h2 id='gen.noind'>Number of individuals</h2><span id='topic+gen.noind'></span>

<h3>Description</h3>

<p>Returns the number of individuals included in the genealogy</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.noind( gen)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.noind_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.nowomen">gen.nowomen</a></code>
<code><a href="#topic+gen.nochildren">gen.nochildren</a></code>
<code><a href="#topic+gen.nomen">gen.nomen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.noind(genJi)
</code></pre>

<hr>
<h2 id='gen.nomen'>Number of men</h2><span id='topic+gen.nomen'></span>

<h3>Description</h3>

<p>Returns the number of men included in the genealogy</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.nomen( gen)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.nomen_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.nowomen">gen.nowomen</a></code>
<code><a href="#topic+gen.nochildren">gen.nochildren</a></code>
<code><a href="#topic+gen.noind">gen.noind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.nomen(genJi)

</code></pre>

<hr>
<h2 id='gen.nowomen'>Number of women</h2><span id='topic+gen.nowomen'></span>

<h3>Description</h3>

<p>Returns the number of women included in the genealogy</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.nowomen( gen)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.nowomen_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.nomen">gen.nomen</a></code>
<code><a href="#topic+gen.nochildren">gen.nochildren</a></code>
<code><a href="#topic+gen.noind">gen.noind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.nowomen(genJi)

</code></pre>

<hr>
<h2 id='gen.occ'>Ancestor occurences</h2><span id='topic+gen.occ'></span>

<h3>Description</h3>

<p>Returns the number of times that the specified ancestors are present in the genalogies of the specified probands.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.occ( gen, pro = "0", ancestors = "0", typeOcc = "IND", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.occ_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.occ_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.occ_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Default is 0, which will select all individuals without parents.</p>
</td></tr>
<tr><td><code id="gen.occ_+3A_typeocc">typeOcc</code></td>
<td>
<p>If typeOcc=&quot;IND&quot; (default), the number of occurences for each proband will be returned.
If typeOcc=&quot;TOTAL&quot;, the sum of all occurences over all probands will be returned.</p>
</td></tr>
<tr><td><code id="gen.occ_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with number of lines equal to the number of ancestors included and the number of columns equal to the number of probands included if typeOcc=&quot;BRUT&quot; or only one column if typeOcc=&quot;TOTAL&quot;</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.rec">gen.rec</a></code>
<code><a href="#topic+gen.implex">gen.implex</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
<code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# Number of occurences of ancestors in the specified proband's genealogy
gen.occ(genJi, pro=c(1,29), ancestors=c(3,6,10,12,14,16,18,20,26,28))

data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.occ(gen140, pro=c(454422,676521,677273,717537,717634,717709,868572), 
        ancestors=c(18305,18528,31114,18325))

</code></pre>

<hr>
<h2 id='gen.parent'>Get id numbers of parents</h2><span id='topic+gen.parent'></span>

<h3>Description</h3>

<p>Returns the id numbers of the parents of specified individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.parent( gen, individuals, output = "FaMo", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.parent_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.parent_+3A_individuals">individuals</code></td>
<td>
<p>Vector of individual id numbers. Required.</p>
</td></tr>
<tr><td><code id="gen.parent_+3A_output">output</code></td>
<td>
<p>If output=&quot;FaMo&quot; (default) then both mothers and fathers are included. &quot;Mo&quot; outputs mothers only and &quot;Fa&quot;, fathers only.</p>
</td></tr>
<tr><td><code id="gen.parent_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing the following:
<strong>Fathers</strong> 
<strong>Mothers</strong> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.pro">gen.pro</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.children">gen.children</a></code>
<code><a href="#topic+gen.sibship">gen.sibship</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.parent(genJi, individuals=c(3,21,29)) 

</code></pre>

<hr>
<h2 id='gen.phi'>Kinship coefficient</h2><span id='topic+gen.phi'></span>

<h3>Description</h3>

<p>Returns the kinship coefficients between pairs of individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.phi(gen, pro, depthmin=(gen.depth(gen)-1), depthmax=(gen.depth(gen)-1), MT=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.phi_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.phi_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.phi_+3A_depthmin">depthmin</code></td>
<td>
<p>Minimum genealogical depth to consider in the calculation. Default is the whole genealogy.</p>
</td></tr>
<tr><td><code id="gen.phi_+3A_depthmax">depthmax</code></td>
<td>
<p>Maximum genealogical depth to consider in the calculation. Default is the whole genealogy.</p>
</td></tr>
<tr><td><code id="gen.phi_+3A_mt">MT</code></td>
<td>
<p>Allows parallel computing when set to TRUE. Default is MT=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a GLmultiMatrix object depending on the number of generations treated.
GLmultiMatrix is an array of matrices, one for each depth. Array of size ('depthMax'-'depthMin') and 
matrices of size 'length(pro)' * 'length(pro)'.
The matrix object, also of size 'length(pro)' * 'length(pro)', is returned when ('depthMax'-'depthMin') equals 1.</p>


<h3>References</h3>

<p>Malecot G. (1948) Les mathematiques de l'heredite. Paris: Masson, p 65.
</p>
<p>Thompson EA. (1986) Pedigree Analysis in Human Genetics. Baltimore, MD, USA: Johns Hopkins University Press, p 25.
</p>
<p>Karigl G. (1981) A recursive algorithm for the calculation of identity coefficients. Ann Hum Genet 45:299-305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.f">gen.f</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
kinship&lt;-gen.phi(genJi)
kinship

kinship_allgenerations&lt;-gen.phi(genJi, depthmin =1)
kinship_allgenerations
# 7th generations back in time is equivalent to considering all generations
kinship_allgenerations &lt;- unclass(kinship_allgenerations)
kinship_allgenerations[,,7]==kinship

kinship_allgenerations[1,2,]

# Plot of kinship varying according to number of generations considered
plot(1:7,kinship_allgenerations[1,2,], type="b", xlab="Generation", ylab="Kinship value", 
     ylim=c(0,0.6), pch=0)
points(1:7,kinship_allgenerations[1,3,], type="b", lty=12, pch=1)
legend("topright", legend=c("Individuals 1 and 2", "Individuals 2 and 29"),lty=c(1,12), pch=c(0,1))
</code></pre>

<hr>
<h2 id='gen.phiCI'>Average kinship confidence interval</h2><span id='topic+gen.phiCI'></span>

<h3>Description</h3>

<p>Returns the confidence interval of the average kinship among pairs of specified individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.phiCI(phiMatrix, prob=c(0.025,0.05,0.95,0.975), b=5000, print.it=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.phiCI_+3A_phimatrix">phiMatrix</code></td>
<td>
<p>A square matrix of kinship coefficients obtained for example with gen.phi, 
or an array of square matrices (GLmultiMatrix object) of kinship coefficients obtained with gen.phi. Required.</p>
</td></tr>
<tr><td><code id="gen.phiCI_+3A_prob">prob</code></td>
<td>
<p>Confidence limits probabilities. Default is probs=c(0.025, 0.05, 0.95, 0.975).</p>
</td></tr>
<tr><td><code id="gen.phiCI_+3A_b">b</code></td>
<td>
<p>Number of simulations used to calculate the confidence interval. Default is b=&quot;5000&quot;.</p>
</td></tr>
<tr><td><code id="gen.phiCI_+3A_print.it">print.it</code></td>
<td>
<p>If print.it=FALSE (default), progression in the number of simulations performed is not displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a GLmultiVector object depending on the type of 'phiMatrix' entered.
If 'phiMatrix' is a GLmultiMatrix, an array of vectors (GLmultiVector), one for each depth, is returned.
Array of size ('depthMax'-'depthMin'), vectors of size 'length(probs)'.
If 'phiMatrix' is a matrix, a vector of size 'length(probs)' is returned.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.phi">gen.phi</a></code>
<code><a href="#topic+gen.phiOver">gen.phiOver</a></code>
<code><a href="#topic+gen.phiMean">gen.phiMean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(genea140)
gen140&lt;-gen.genealogy(genea140)
ge07&lt;-gen.branching(gen140, pro=gen.pro(gen140)[c(1:7)])
phiMat&lt;-gen.phi(ge07)
gen.phiCI(phiMat)

</code></pre>

<hr>
<h2 id='gen.phiMean'>Average kinship</h2><span id='topic+gen.phiMean'></span>

<h3>Description</h3>

<p>Returns the average kinship among pairs of specified individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.phiMean( phiMatrix)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.phiMean_+3A_phimatrix">phiMatrix</code></td>
<td>
<p>A square matrix of kinship coefficients obtained for example with gen.phi. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric value</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.phi">gen.phi</a></code>
<code><a href="#topic+gen.phiOver">gen.phiOver</a></code>
<code><a href="#topic+gen.phiCI">gen.phiCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
kinship&lt;-gen.phi(genJi)
gen.phiMean(kinship)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
phi6subjects&lt;-gen.phi(gen140, pro=c(454422, 676521, 677273, 717537, 717634, 717709, 868572))
gen.phiMean(phi6subjects)

</code></pre>

<hr>
<h2 id='gen.phiOver'>Kinship above threshold</h2><span id='topic+gen.phiOver'></span>

<h3>Description</h3>

<p>Returns the pairs of individuals with kinship coefficient values greater than specified threshold.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.phiOver( phiMatrix, threshold)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.phiOver_+3A_phimatrix">phiMatrix</code></td>
<td>
<p>A square matrix of kinship coefficients obtained for example with gen.phi. Required.</p>
</td></tr>
<tr><td><code id="gen.phiOver_+3A_threshold">threshold</code></td>
<td>
<p>Threshold of kinship values to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the probands and their kinship.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.phi">gen.phi</a></code>
<code><a href="#topic+gen.phiMean">gen.phiMean</a></code>
<code><a href="#topic+gen.phiCI">gen.phiCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
kinship&lt;-gen.phi(genJi)
gen.phiOver(kinship, 0.1)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
phi9subj&lt;-gen.phi(gen140,pro=c(408758,408950,409082,409111,676521,717537,717634,717709,868572))
gen.phiOver(phi9subj,0.025)

</code></pre>

<hr>
<h2 id='gen.pro'>Get proband id numbers</h2><span id='topic+gen.pro'></span>

<h3>Description</h3>

<p>Returns the id numbers of the probands. Probands are defined as the individuals without children in the genealogy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.pro( gen, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.pro_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.pro_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.half.founder">gen.half.founder</a></code>
<code><a href="#topic+gen.parent">gen.parent</a></code>
<code><a href="#topic+gen.children">gen.children</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# There are 3 probands
gen.pro(genJi)


data(genea140) 
gen140&lt;-gen.genealogy(genea140)
gen.pro(gen140)
# There are 140 probands

</code></pre>

<hr>
<h2 id='gen.rec'>Ancestors coverage</h2><span id='topic+gen.rec'></span>

<h3>Description</h3>

<p>Returns the number of specified probands genealogically related to specified ancestors (i.e., ancestor occurs in the proband's genealogy).</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.rec( gen, pro = "0", ancestors = "0", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.rec_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.rec_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Default is 0, which will select all individuals without children.</p>
</td></tr>
<tr><td><code id="gen.rec_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Default is 0, which will select all individuals without parents.</p>
</td></tr>
<tr><td><code id="gen.rec_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with number of lines equal to the number of ancestors specified and one column.</p>


<h3>Note</h3>

<p>If an ancestor is also a proband, he/she will be counted in his/her coverage.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.occ">gen.occ</a></code>
<code><a href="#topic+gen.implex">gen.implex</a></code>
<code><a href="#topic+gen.meangendepth">gen.meangendepth</a></code>
<code><a href="#topic+gen.gc">gen.gc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# Number of probands which are descendants of an ancestor
gen.rec(genJi)


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
gen.rec(gen140, ancestors=c(18305, 18528, 31114, 18325))
</code></pre>

<hr>
<h2 id='gen.sibship'>Get id numbers of siblings</h2><span id='topic+gen.sibship'></span>

<h3>Description</h3>

<p>Returns the id numbers of the siblings of specified individuals.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.sibship( gen, individuals, halfSibling = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.sibship_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.sibship_+3A_individuals">individuals</code></td>
<td>
<p>Vector of individual id numbers. Required.</p>
</td></tr>
<tr><td><code id="gen.sibship_+3A_halfsibling">halfSibling</code></td>
<td>
<p>If halfSibling=TRUE (default) then ids of halfsiblings are also returned. halfSibling=FALSE returns only full sibling ids.</p>
</td></tr>
<tr><td><code id="gen.sibship_+3A_...">...</code></td>
<td>
<p>Option to pass additionnal arguments automaticaly between methods. Internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a vector of integer</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.pro">gen.pro</a></code>
<code><a href="#topic+gen.founder">gen.founder</a></code>
<code><a href="#topic+gen.children">gen.children</a></code>
<code><a href="#topic+gen.parent">gen.parent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.sibship(genJi, individuals=21,halfSibling=TRUE) 


data(genea140) 
gen140&lt;-gen.genealogy(genea140) 
sibs&lt;-gen.sibship(gen140,individuals=10174, halfSibling=FALSE)
gen.graph(gen140, pro=c(10174,sibs))

</code></pre>

<hr>
<h2 id='gen.simuHaplo'>Gene dropping simulations - haplotypes</h2><span id='topic+gen.simuHaplo'></span>

<h3>Description</h3>

<p>Gene dropping from founders to specified probands according to specified model of meioisis. Output .txt files will have simulated haplotypes, labelled w.r.t. the ancestor of origin</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuHaplo(gen, pro = NULL, ancestors = NULL, simulNo = 1, model
                        = 1, model_params, cM_len, BP_len, physical_map_Mo =
                        NULL, physical_map_Fa = NULL, seed = 0, all_nodes = 0,
                        outDir = getwd())</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuHaplo_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Will default to all probands in the provided genealogy.</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Will default to all ancestors of probands</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_simulno">simulNo</code></td>
<td>
<p>Number of simulations to run. Defaults to 1. Results from all simulations are contained in the same output text file</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_model">model</code></td>
<td>
<p>model=1 is Poisson model, model=2 is zero-truncated Poisson, model=3 is Gamma model</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_model_params">model_params</code></td>
<td>
<p>Numeric vector of length 2. Specifies sex-specific parameters for the model of meiosis. Should be in order of male, female</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_cm_len">cM_len</code></td>
<td>
<p>Length of chromosome (or subregion) to be simulated in centiMorgans. Integer vector of length 2, first element is cM length for males, second for females</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_bp_len">BP_len</code></td>
<td>
<p>Length of chromosome (or subregion) to be simulated in Base pairs. Single integer value (male and female chromosome have same BP length)</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_physical_map_mo">physical_map_Mo</code></td>
<td>
<p>Optional map for females (Mother) that specifies relationship between genetic length and physical length.
A dataframe with a column named &quot;BP&quot; and another named &quot;cM&quot;. The map is the linear piecewise function specified by the points.
The order of the pairs should be strictly ascending, the first row should be (0,0) and the last row should be (BP_len, cM_len)
If a map is not specified then genetic length is assumed to be constant along the physical length of the region</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_physical_map_fa">physical_map_Fa</code></td>
<td>
<p>Optional map for males, should be specified in the same way</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_seed">seed</code></td>
<td>
<p>integer seed for the random number generator (C++ std library Mersenne twister) for the simulation. Default is the system time</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_all_nodes">all_nodes</code></td>
<td>
<p>all_nodes=1 will generate Optional &quot;All_nodes_haplotypes.txt&quot; outpu file. Default is all_nodes=0.</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_+3A_outdir">outDir</code></td>
<td>
<p>The directory to write output files to. Default is the current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Will generate output files &quot;Proband_Haplotypes.txt&quot; and &quot;All_nodes_haplotypes.txt&quot; in the specified output directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuHaplo_traceback">gen.simuHaplo_traceback</a></code>
<code><a href="#topic+gen.simuHaplo_IBD_compare">gen.simuHaplo_IBD_compare</a></code>
<code><a href="#topic+gen.simuSampleFreq">gen.simuSampleFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gen_table &lt;- data.frame(ind=c(1,2,3,4,5,6,7),
                        mother=c(0,0,2,0,0,5,3),
                        father=c(0,0,1,0,0,4,6),
                        sex=c(1,2,2,1,2,1,1)
)

#convert the genealogy table into a GENLIB object
sample_gen&lt;-gen.genealogy(gen_table) 

gen.graph(sample_gen)
# Simulate the gene dropping from founders to probamds

gen.simuHaplo(sample_gen, simulNo=5, model = 1, model_params = c(1,1), cM_len=c(100,100),
                BP_len = 100000000, outDir=tempdir())

f&lt;-file(paste(tempdir(),"Proband_Haplotypes.txt",sep="/"),"r")
print(readLines(f,n=10))

</code></pre>

<hr>
<h2 id='gen.simuHaplo_convert'>Convert proband simulation results into sequence data given founder haplotypes</h2><span id='topic+gen.simuHaplo_convert'></span>

<h3>Description</h3>

<p>Convert the &quot;Proband_Haplotypes.txt&quot; output file produced by gen.simulHaplo into sequence data according to input sequence data for founders.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuHaplo_convert(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuHaplo_convert_+3A_dir">dir</code></td>
<td>
<p>path to the directory containing all the required input files. The function expects to find the &quot;Proband_Haplotypes.txt&quot; file,
a file named &quot;founders.hap&quot; which contains the sequence data for all founder chromosomes, and another file called &quot;founders.map&quot; which 
contains the BP position of all included markers in the specified founder sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://github.com/R-GENLIB/simuhaplo_functions">https://github.com/R-GENLIB/simuhaplo_functions</a> for examples on how to format the founder sequence input files.</p>


<h3>Value</h3>

<p>creates a new file in the specified directory &quot;Proband_Genotypes.txt&quot;</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuHaplo">gen.simuHaplo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#gen_table &lt;- data.frame(ind=c(1,2,3,4,5,6,7,8),
#                        mother=c(0,0,2,0,0,5,3,3),
#                        father=c(0,0,1,0,0,4,6,6),
#                        sex=c(1,2,2,1,2,1,1,2))

#convert the genealogy table into a GENLIB object
#sample_gen&lt;-gen.genealogy(gen_table) 


# Simulate the gene dropping from founders to probamds
#gen.simuHaplo(sample_gen, simulNo=5, model = 1, model_params = c(1,1), cM_len=c(100,100),
#                BP_len = 100000000, outDir=tempdir())

#after creating a "founders.map" and a "founders.hap" file in the same directory then can ran
#gen.simulHaplo_convert(dir=tempdir())
</code></pre>

<hr>
<h2 id='gen.simuHaplo_IBD_compare'>Compare proband haplotypes for IBD sharing</h2><span id='topic+gen.simuHaplo_IBD_compare'></span>

<h3>Description</h3>

<p>Analyze the simulated haplotypes produced by gen.simuHaplo and identify segments of IBD sharing between the diploid haplotypes of a pair of probands</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuHaplo_IBD_compare(proID_1, proID_2, BP_len, proband_haplotypes_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuHaplo_IBD_compare_+3A_proid_1">proID_1</code></td>
<td>
<p>integer ID of a proband</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_IBD_compare_+3A_proid_2">proID_2</code></td>
<td>
<p>integer ID of the second proband</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_IBD_compare_+3A_bp_len">BP_len</code></td>
<td>
<p>The chromosome BP length used in the simulation</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_IBD_compare_+3A_proband_haplotypes_path">proband_haplotypes_path</code></td>
<td>
<p>String that gives the location of the &quot;Proband_haplotypes.txt&quot; output file produced by gen.simuHaplo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe with the following columns: &quot;simulNo&quot;, &quot;n_seg&quot;, &quot;pIBD&quot;, &quot;mean_seg_len&quot;. Each row is a simulation wherein the pair of probands had some IBD sharing.
The &quot;simulNo&quot; columns gives the simulation number, &quot;n_seg&quot; is the number of non-contiguous segments shared between the pair (divide this value by 2 for an average value for the pair), 
&quot;pIBD&quot; is the percent of the simulated chromosome shared IBD between the pair, and &quot;mean_seg_len&quot; is the mean length of IBD segments.
Additionally, the function will print the exact location of each IBD segment to the R console. This can be toggled by disabling messages.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuHaplo">gen.simuHaplo</a></code>
<code><a href="#topic+gen.simuHaplo_traceback">gen.simuHaplo_traceback</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gen_table &lt;- data.frame(ind=c(1,2,3,4,5,6,7,8),
                        mother=c(0,0,2,0,0,5,3,3),
                        father=c(0,0,1,0,0,4,6,6),
                        sex=c(1,2,2,1,2,1,1,2)
)

#convert the genealogy table into a GENLIB object
sample_gen&lt;-gen.genealogy(gen_table) 

gen.graph(sample_gen)
# Simulate the gene dropping from founders to probamds

gen.simuHaplo(sample_gen, simulNo=5, model = 1, model_params = c(1,1), cM_len=c(100,100),
                BP_len = 100000000, outDir=tempdir())

IBD_compare &lt;- gen.simuHaplo_IBD_compare(7, 8, 100000000, 
                paste(tempdir(), "Proband_Haplotypes.txt", sep="/"))
</code></pre>

<hr>
<h2 id='gen.simuHaplo_traceback'>Trace inheritance path for results from gene dropping simulation</h2><span id='topic+gen.simuHaplo_traceback'></span>

<h3>Description</h3>

<p>Given the output of a gene dropping simulation using gen.simuHaplo, this function can trace the inheritance path of a proband segment back to the founder it is inherited from</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuHaplo_traceback(gen, proID, ancestorID, all_nodes_path, proband_haplotypes_path)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuHaplo_traceback_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_traceback_+3A_proid">proID</code></td>
<td>
<p>Integer ID of the proband to trace back from.</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_traceback_+3A_ancestorid">ancestorID</code></td>
<td>
<p>Integer ID of the founder, any segment in the proband haplotype inherited from this founder will be traced back</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_traceback_+3A_all_nodes_path">all_nodes_path</code></td>
<td>
<p>String of the path to the &quot;All_nodes_haplotypes.txt&quot; output file generated by gen.simulHaplo</p>
</td></tr>
<tr><td><code id="gen.simuHaplo_traceback_+3A_proband_haplotypes_path">proband_haplotypes_path</code></td>
<td>
<p>String of the path to the &quot;Proband_Haplotypes.txt&quot; output file generated by gen.simulHaplo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe with the following columns: &quot;simulNo&quot;, &quot;seg_length&quot;, &quot;path_no&quot;. For every simulation in the output files where the specified proband inherits
a segment from the specified founder. &quot;seg_length&quot; is the length of the inherited segment in BP. &quot;path_no&quot; is an integer that specifies the path of inheritance of the segment
Unique paths of inheritance are simply identified by the order they appear in the outputs file, and the full paths (ID of every individual along the path) are printed to the R console.
If this is not appearing check that messages are not disabled.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuHaplo">gen.simuHaplo</a></code>
<code><a href="#topic+gen.simuHaplo_IBD_compare">gen.simuHaplo_IBD_compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gen_table &lt;- data.frame(ind=c(1,2,3,4,5,6,7),
                        mother=c(0,0,2,0,0,5,3),
                        father=c(0,0,1,0,0,4,6),
                        sex=c(1,2,2,1,2,1,1)
)

#convert the genealogy table into a GENLIB object
sample_gen&lt;-gen.genealogy(gen_table) 

gen.graph(sample_gen)
# Simulate the gene dropping from founders to probamds

gen.simuHaplo(sample_gen, simulNo=5, model = 1, model_params = c(1,1), cM_len=c(100,100),
                BP_len = 100000000, all_nodes = 1, outDir=tempdir())

traceback &lt;-gen.simuHaplo_traceback(sample_gen, 7, 1,
                        paste(tempdir(), "All_nodes_haplotypes.txt", sep = "/"),
                        paste(tempdir(), "Proband_Haplotypes.txt", sep="/"))
</code></pre>

<hr>
<h2 id='gen.simuProb'>Gene dropping simulations - Probabilities</h2><span id='topic+gen.simuProb'></span>

<h3>Description</h3>

<p>Returns the probabilities that specified probands inherit disease alleles from ancestors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuProb(gen, pro, statePro, ancestors, stateAncestors, simulNo=5000, 
                    probRecomb=c(0,0), probSurvival=1.0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuProb_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_statepro">statePro</code></td>
<td>
<p>Required vector indicating, for each proband in pro, the probability to be calculated:
</p>
<p>0 = no disease allele is transmitted
</p>
<p>1 = 1 disease allele is transmitted
</p>
<p>2 = 2 disease alleles are transmitted
</p>
<p>3 = 1 or 2 disease alleles are transmitted</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_stateancestors">stateAncestors</code></td>
<td>
<p>Required vector indicating, for each ancestor in ancestors, the genotype state:
</p>
<p>0 = no disease allele present
</p>
<p>1 = 1 disease allele present
</p>
<p>2 = 2 disease alleles present</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_simulno">simulNo</code></td>
<td>
<p>Number of simulations to perform. Default is 5000.</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_probrecomb">probRecomb</code></td>
<td>
<p>Recombination probabilities for males and females. Default is no recombination.</p>
</td></tr>
<tr><td><code id="gen.simuProb_+3A_probsurvival">probSurvival</code></td>
<td>
<p>Survival probability for homozygotes. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>
<p>the joint probability of specified statePro for all probands,
</p>
<p>the probability of specified statePro for each proband,
</p>
<p>the probability that, 0, 1, ..., and all probands inherit the specified number of disease alleles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuSample">gen.simuSample</a></code>
<code><a href="#topic+gen.simuSet">gen.simuSet</a></code>
<code><a href="#topic+gen.simuSampleFreq">gen.simuSampleFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
# Probability that subjects 1 and 29 get 1 and 2 alleles from ancestors 20 and 25,
# that have themselves 2 and 1.
gen.simuProb(genJi, pro=c(1,29), statePro=c(1,2), ancestors=c(20,25), stateAncestors=c(2,1),
             simulNo=10000)
# Probability that subjects 1 and 29 get 1 segment from ancestors 25,
# knowing the segment has a male
# recombination rate of 0.02 and a female recombination rate of 0.04.
gen.simuProb(genJi, pro=c(1,29), statePro=c(1,1), ancestors=c(25), stateAncestors=c(1),
             simulNo=10000, probRecomb = c(0.02, 0.04))
# Probability that subjects 1 and 29 get 1 and 2 alleles from ancestors 20 and 25,
# that have themselves 2 and 1 and knowing that homozygous people have a survival rate
# of 0.50.
gen.simuProb(genJi, pro=c(1,29), statePro=c(1,2), ancestors=c(20,25), stateAncestors=c(2,1),
             simulNo=10000, probSurvival=0.5)

</code></pre>

<hr>
<h2 id='gen.simuSample'>Gene dropping simulations - Sample</h2><span id='topic+gen.simuSample'></span>

<h3>Description</h3>

<p>Returns the number of alleles transmitted to specified probands from ancestors</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuSample(gen, pro, ancestors, stateAncestors, simulNo = 5000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuSample_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSample_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSample_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSample_+3A_stateancestors">stateAncestors</code></td>
<td>
<p>Required vector indicating, for each ancestor in ancestors, the genotype state:
</p>
<p>0 = no disease allele present
</p>
<p>1 = 1 disease allele present
</p>
<p>2 = 2 disease alleles present</p>
</td></tr>
<tr><td><code id="gen.simuSample_+3A_simulno">simulNo</code></td>
<td>
<p>Number of simulations to perform. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with number of columns equal to the number of simulations and number of rows equal to the number of probands.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuProb">gen.simuProb</a></code>
<code><a href="#topic+gen.simuSet">gen.simuSet</a></code>
<code><a href="#topic+gen.simuSampleFreq">gen.simuSampleFreq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
simu_1000&lt;-gen.simuSample(genJi, pro=c(1,29), ancestors=c(20,25), stateAncestors=c(2,1),
                          simulNo=1000)
# Number of alleles received by probants
table(simu_1000)
# Number of alleles received by simulation
table(colSums(simu_1000))
# Number of alleles received by each probant
table(simu_1000[1,],simu_1000[2,])

data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
simu_5000&lt;-gen.simuSample(genJi, pro=c(1,29), ancestors=c(20,25), stateAncestors=c(2,1),
                          simulNo=5000)
# Number of alleles received by probants
table(simu_5000)
# Number of alleles received by simulation
table(colSums(simu_5000))
# Number of alleles received by each probant
table(simu_5000[1,],simu_5000[2,])

</code></pre>

<hr>
<h2 id='gen.simuSampleFreq'>Gene dropping simulations - Frequencies</h2><span id='topic+gen.simuSampleFreq'></span>

<h3>Description</h3>

<p>Returns the number of alleles transmitted to specified probands from ancestors</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuSampleFreq( gen, pro, ancestors, stateAncestors, simulNo = "5000")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuSampleFreq_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSampleFreq_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSampleFreq_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSampleFreq_+3A_stateancestors">stateAncestors</code></td>
<td>
<p>Required vector indicating, for each ancestor in ancestors, the genotype state:
</p>
<p>0 = no disease allele present
</p>
<p>1 = 1 disease allele present
</p>
<p>2 = 2 disease alleles present</p>
</td></tr>
<tr><td><code id="gen.simuSampleFreq_+3A_simulno">simulNo</code></td>
<td>
<p>Number of simulations to perform. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing for each row (one row per proband):
<strong>Alleles.transmitted.0</strong> 
<strong>Alleles.transmitted.1</strong> 
<strong>Alleles.transmitted.2</strong> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuProb">gen.simuProb</a></code>
<code><a href="#topic+gen.simuSet">gen.simuSet</a></code>
<code><a href="#topic+gen.simuSample">gen.simuSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
gen.simuSampleFreq(genJi, pro=c(1,29), ancestors=c(20,25),stateAncestors=c(2,1), simulNo = 1000)

</code></pre>

<hr>
<h2 id='gen.simuSet'>Gene dropping simulations with specified transmission probabilities</h2><span id='topic+gen.simuSet'></span>

<h3>Description</h3>

<p>Returns the number of alleles transmitted to specified probands from ancestors considering sepcified transmission probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.simuSet(gen, pro, ancestors, stateAncestors, 
                   probMatrix=matrix(c(
                                    c(1,0.5,0,0.5,0.25,0,0,0,0,1,1,1,1,0.75,0.5,1,0.5,0),
                                    c(1,0.5,0,0.5,0.25,0,0,0,0,1,1,1,1,0.75,0.5,1,0.5,0)),
                                     nrow=3, ncol=12),
                   simulNo = 5000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.simuSet_+3A_gen">gen</code></td>
<td>
<p>An object of class GLgen obtained with gen.genealogy, gen.lineages or gen.branching. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSet_+3A_pro">pro</code></td>
<td>
<p>Vector of proband id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSet_+3A_ancestors">ancestors</code></td>
<td>
<p>Vector of ancestors id numbers to be included. Required.</p>
</td></tr>
<tr><td><code id="gen.simuSet_+3A_stateancestors">stateAncestors</code></td>
<td>
<p>Required vector indicating, for each ancestor in ancestors, the genotype state:
</p>
<p>0 = no disease allele present
</p>
<p>1 = 1 disease allele present
</p>
<p>2 = 2 disease alleles present</p>
</td></tr>
<tr><td><code id="gen.simuSet_+3A_probmatrix">probMatrix</code></td>
<td>
<p>Matrix of transmission probabilities of 0, 1, or 2 disease alleles. Default is:
</p>
<p>[,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
</p>
<p>[1,]  1.0 0.50    0    1 1.00  1.0  1.0 0.50    0     1  1.00   1.0
</p>
<p>[2,]  0.5 0.25    0    1 0.75  0.5  0.5 0.25    0     1  0.75   0.5
</p>
<p>[3,]  0.0 0.00    0    1 0.50  0.0  0.0 0.00    0     1  0.50   0.0
</p>
<p>where rows are genotype states (0,1,2) for the father and columns are states for the mother (in blocks of 3).
</p>
<p>1st block (col 1-3) are the probabilities of transmitting 0 allele to a son.
</p>
<p>2nd block (col 4-6) are the probabilities of transmitting 1 allele to a son.
</p>
<p>3rd block (col 7-9) are the probabilities of transmitting 0 allele to a daughter.
</p>
<p>4th block (col 10-12) are the probabilities of transmitting 1 allele to a daughter.
</p>
</td></tr>
<tr><td><code id="gen.simuSet_+3A_simulno">simulNo</code></td>
<td>
<p>Number of simulations to perform. Default is 5000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with number of columns equal to the number of simulations and number of rows equal to the number of probands.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.genealogy">gen.genealogy</a></code>
<code><a href="#topic+gen.simuProb">gen.simuProb</a></code>
<code><a href="#topic+gen.simuSample">gen.simuSample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A case where only male subjects can receive alleles
data(geneaJi) 
genJi&lt;-gen.genealogy(geneaJi) 
onlyThroughMale&lt;-matrix(c(c(1,0.5,0,0.5,0.25,0,0,0,0,1,1,1,1,0.75,0.5,1,0.5,0), rep(1,18)), 
                        nrow=3, ncol=12) 
gen.graph(genJi, indVarAffected=c(28,27,25,17,12,8,4,1), varAffected=c(28,27,25,17,12,8,4,1))
simu_1000a&lt;-gen.simuSet(genJi, pro=c(1,28), ancestors=c(17,25), stateAncestors=c(1,1), 
                        simulNo = 1000,probMatrix=onlyThroughMale)
# Number of alleles received by probants
table(simu_1000a)
# Number of alleles received by all probants at each simulation
table(colSums(simu_1000a))
# Number of alleles received by each probant
table(simu_1000a[1,],simu_1000a[2,])

# A case where subjects are limited to one copy compared to what is normally expected
max1Allreceived&lt;-matrix(rep(c(1,0.5,0,0.5,0.25,0,0,0,0,1,1,1,1,1,1,1,1,1), 2) , nrow=3, ncol=12)  
gen.graph(genJi)
simu_1000b&lt;-gen.simuSet(genJi, pro=c(1,29), ancestors=25, stateAncestors=1, simulNo=10000,
                        probMatrix=max1Allreceived)
# Normal case matrix not changed
simu_1000original&lt;-gen.simuSet(genJi, pro=c(1,29), ancestors=25, stateAncestors=1, simulNo=10000)
# Number of alleles received by each probant
table(simu_1000b) 
table(simu_1000original) 
# Number of alleles received by all probants at each simulation
table(colSums(simu_1000b)) 
table(colSums(simu_1000original)) 
# Number of alleles received by each probant
table(simu_1000b[1,],simu_1000b[2,])
table(simu_1000original[1,],simu_1000original[2,]) 
</code></pre>

<hr>
<h2 id='genea140'>Genealogical information for 140 individuals from the Quebec Reference Sample</h2><span id='topic+genea140'></span>

<h3>Description</h3>

<p>A genealogical corpus made of 41523 individuals from the province of Quebec, Canada. A total of 140 individuals have been sampled in seven sub-populations, listed in pop140, and their genealogies were reconstructed as far back as possible using the BALSAC population register and the Early Quebec Population Register.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(genea140)</code></pre>


<h3>Format</h3>

<p>A data frame with 41523 observations on 11 variables.
</p>
<p>[,1] ind: An individual's ID number
</p>
<p>[,2] father: This indidividual's father ID number
</p>
<p>[,3] mother: This indidividual's mother ID number
</p>
<p>[,4] sex: Individual's sex coded 1/2 for male/female
</p>


<h3>Source</h3>

<p>Balsac</p>


<h3>References</h3>

<p>http://www.quebecgenpop.ca
</p>
<p>Roy-Gagnon, M.-H., Moreau, C., Bherer, C., St-Onge, P., Sinnett, D., Laprise, C., Vezina, H., Labuda, D. (2011). Genomic and genealogical investigation of the French Canadian founder population structure. Human Genetics, 129(5), 521-31. 
</p>

<hr>
<h2 id='geneaJi'>Highly inbred pedigree</h2><span id='topic+geneaJi'></span>

<h3>Description</h3>

<p>A modified version of a pedigree of two Jicaque Indians studied by Chapman &amp; Jacquard (1971).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geneaJi)</code></pre>


<h3>Format</h3>

<p>A data frame with 29 observations on 4 variables.
</p>
<p>[, 1] 	ind 	An individual's ID number
</p>
<p>[, 2] 	father 	This indidividual's father ID number
</p>
<p>[, 3] 	mother 	This indidividual's mother ID number
</p>
<p>[, 4] 	sex 	Individual's sex coded 1/2 for male/female
</p>


<h3>Source</h3>

<p>CHAPMAN &amp; JACQUART (1971)</p>


<h3>References</h3>

<p>Chapman, A.M., &amp; Jacquard, A. (1971). Un isolat d'Amerique centrale: Les indiens Jicaques du Honduras. Paris: Presses universitaires de France.
</p>

<hr>
<h2 id='GLgen-class'>Class <code>"GLgen"</code></h2><span id='topic+GLgen-class'></span><span id='topic+initialize+2CGLgen-method'></span><span id='topic+depth+2CGLgen-method'></span><span id='topic+length+2CGLgen-method'></span>

<h3>Description</h3>

<p>Object containing a genealogy.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>gen.genealogy('data.frame')</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GLgroup-class">GLgroup</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Data="integer",Date="character")</code>: ... </p>
</dd>
<dt>depth</dt><dd><p><code>signature(x = "GLgen")</code></p>
</dd></dl>
<p>Gives the depth of the genealogy.
</p>
<dl>
<dt>length</dt><dd><p><code>signature(x = "GLgen")</code></p>
</dd></dl>
<p>Gives the number of individuals in the genealogy.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GLgen")
</code></pre>

<hr>
<h2 id='GLgroup-class'>Class <code>"GLgroup"</code></h2><span id='topic+GLgroup-class'></span><span id='topic+initialize+2CGLgroup-method'></span><span id='topic++5B+2CGLgroup+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Object representing a set of proband in different groups.<br />
Each element of this list is a group named with the proband number.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GLgroup", 'list')</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GLgen-class">GLgen</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Data=list)</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(object = "GLgroup",ANY,ANY,ANY)</code>:... </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>showClass("GLgroup")
</code></pre>

<hr>
<h2 id='GLmultiList-class'>Class <code>"GLmultiList"</code></h2><span id='topic+GLmultiList-class'></span>

<h3>Description</h3>

<p>Objects created to carry information mostly between invisible functions.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("GLmultiList", 'Array')</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>liste</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GLmultiList&quot; in the signature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GLmultiList")
</code></pre>

<hr>
<h2 id='pop140'>Population of origin of the 140 Quebec samples</h2><span id='topic+pop140'></span>

<h3>Description</h3>

<p>The 140 individuals from the genealogical corpus from Quebec were sampled from 7 different populations from 5 regions; Quebec City, Montreal, Saguenay, North Shore, Gaspesia. In Gaspesia we find 3 different populations: French-Canadians, Acadians and Loyalists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pop140)</code></pre>


<h3>Format</h3>

<p>[, 1]  ind:  An individual's ID number
</p>
<p>[, 2]  pop:  This indidividual's population
</p>


<h3>Source</h3>

<p>Balsac</p>


<h3>References</h3>

<p>http://www.quebecgenpop.ca/home.html
</p>
<p>Roy-Gagnon, M.-H., Moreau, C., Bherer, C., St-Onge, P., Sinnett, D., Laprise, C., Vezina, H., Labuda, D. (2011). Genomic and genealogical investigation of the French Canadian founder population structure. Human Genetics, 129(5), 521-31.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
