<!DOCTYPE html><html lang="en"><head><title>Help for package scR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acc_sim'><p>Utility function to generate accuracy metrics, for use with <code>estimate_accuracy()</code></p></a></li>
<li><a href='#br'><p>Replication data for 'Predicting Recidivism'</p></a></li>
<li><a href='#estimate_accuracy'><p>Estimate sample complexity bounds for a binary classification algorithm using either simulated or user-supplied data.</p></a></li>
<li><a href='#gendata'><p>Simulate data with appropriate structure to be used in estimating sample complexity bounds</p></a></li>
<li><a href='#getpac'><p>Recalculate achieved sample complexity bounds given different parameter inputs</p></a></li>
<li><a href='#loss'><p>Utility function to define the least-squares loss function to be optimized for <code>simvcd()</code></p></a></li>
<li><a href='#plot_accuracy'><p>Represent simulated sample complexity bounds graphically</p></a></li>
<li><a href='#risk_bounds'><p>Utility function to generate data points for estimation of the VC Dimension of a user-specified binary classification algorithm given a specified sample size.</p></a></li>
<li><a href='#scb'><p>Calculate sample complexity bounds for a classifier given target accuracy</p></a></li>
<li><a href='#simvcd'><p>Estimate the Vapnik-Chervonenkis (VC) dimension of an arbitrary binary classification algorithm.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Estimate Vapnik-Chervonenkis Dimension and Sample Complexity</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a suite of tools for estimating the sample complexity of a chosen model through theoretical bounds and simulation. The package incorporates methods for estimating the Vapnik-Chervonenkis dimension (VCD) of a chosen algorithm, which can be used to estimate its sample complexity. Alternatively, we provide simulation methods to estimate sample complexity directly. For more details, see Carter, P &amp; Choi, D (2024). "Learning from Noise: Applying Sample Complexity for Political Science Research" &lt;<a href="https://doi.org/10.31219%2Fosf.io%2Fevrcj">doi:10.31219/osf.io/evrcj</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pjesscarter/scR">https://github.com/pjesscarter/scR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pjesscarter/scR/issues">https://github.com/pjesscarter/scR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, pbapply, caret, dplyr, tidyr, ggplot2, plotly</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-20 11:48:06 UTC; pjc504</td>
</tr>
<tr>
<td>Author:</td>
<td>Perry Carter <a href="https://orcid.org/0000-0002-4684-6533"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Dahyun Choi <a href="https://orcid.org/0000-0002-2628-1467"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Perry Carter &lt;pjc504@nyu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-23 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acc_sim'>Utility function to generate accuracy metrics, for use with <code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code></h2><span id='topic+acc_sim'></span>

<h3>Description</h3>

<p>Utility function to generate accuracy metrics, for use with <code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acc_sim(
  n,
  method,
  p,
  dat,
  model,
  eta,
  nsample,
  outcome,
  power,
  effect_size,
  powersims,
  alpha,
  split,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acc_sim_+3A_n">n</code></td>
<td>
<p>An integer giving the desired sample size for which the target function is to be calculated.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_method">method</code></td>
<td>
<p>An optional string stating the distribution from which data is to be generated. Default is i.i.d. uniform sampling. Currently also supports &quot;Class Imbalance&quot;. Can also take a function outputting a vector of probabilities if the user wishes to specify a custom distribution.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_p">p</code></td>
<td>
<p>If method is 'Class Imbalance', gives the degree of weight placed on the positive class.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_dat">dat</code></td>
<td>
<p>A rectangular <code>data.frame</code> or matrix-like object giving the full data from which samples are to be drawn. If left unspecified, <code><a href="#topic+gendata">gendata()</a></code> is called to produce synthetic data with an appropriate structure.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_model">model</code></td>
<td>
<p>A function giving the model to be estimated</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_eta">eta</code></td>
<td>
<p>A real number between 0 and 1 giving the probability of misclassification error in the training data.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_nsample">nsample</code></td>
<td>
<p>A positive integer giving the number of samples to be generated for each value of $n$. Larger values give more accurate results.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_outcome">outcome</code></td>
<td>
<p>A string giving the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_power">power</code></td>
<td>
<p>A logical indicating whether experimental power based on the predictions should also be reported</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_effect_size">effect_size</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, a real number indicating the scaled effect size the user would like to be able to detect.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_powersims">powersims</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, an integer indicating the number of simulations to be conducted at each step to calculate power.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_alpha">alpha</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, a real number between 0 and 1 indicating the probability of Type I error to be used for hypothesis testing. Default is 0.05.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_split">split</code></td>
<td>
<p>A logical indicating whether the data was passed as a single data frame or separately.</p>
</td></tr>
<tr><td><code id="acc_sim_+3A_...">...</code></td>
<td>
<p>Additional model parameters to be specified by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving performance metrics for the specified sample size.
</p>

<hr>
<h2 id='br'>Replication data for 'Predicting Recidivism'</h2><span id='topic+br'></span>

<h3>Description</h3>

<p>Replication data for 'Predicting Recidivism'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 7214 rows and 14 columns.
</p>


<h3>Author(s)</h3>

<p>Julia Dressel and Hany Farid
</p>


<h3>References</h3>

<p><a href="https://www.science.org/doi/full/10.1126/sciadv.aao5580">https://www.science.org/doi/full/10.1126/sciadv.aao5580</a>
</p>

<hr>
<h2 id='estimate_accuracy'>Estimate sample complexity bounds for a binary classification algorithm using either simulated or user-supplied data.</h2><span id='topic+estimate_accuracy'></span>

<h3>Description</h3>

<p>Estimate sample complexity bounds for a binary classification algorithm using either simulated or user-supplied data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_accuracy(
  formula,
  model,
  data = NULL,
  dim = NULL,
  maxn = NULL,
  upperlimit = NULL,
  nsample = 30,
  steps = 50,
  eta = 0.05,
  delta = 0.05,
  epsilon = 0.05,
  predictfn = NULL,
  power = FALSE,
  effect_size = NULL,
  powersims = NULL,
  alpha = 0.05,
  parallel = TRUE,
  coreoffset = 0,
  packages = list(),
  method = c("Uniform", "Class Imbalance"),
  p = NULL,
  minn = ifelse(is.null(data), (dim + 1), (ncol(data) + 1)),
  x = NULL,
  y = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_accuracy_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> that can be passed to the <code>model</code> argument to define the classification algorithm</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_model">model</code></td>
<td>
<p>A binary classification model supplied by the user. Must take arguments <code>formula</code> and <code>data</code></p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_data">data</code></td>
<td>
<p>Optional. A rectangular <code>data.frame</code> object giving the full data from which samples are to be drawn. If left unspecified, <code><a href="#topic+gendata">gendata()</a></code> is called to produce synthetic data with an appropriate structure.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_dim">dim</code></td>
<td>
<p>Required if <code>data</code> is unspecified. Gives the horizontal dimension of the data (number of predictor variables) to be generated.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_maxn">maxn</code></td>
<td>
<p>Required if <code>data</code> is unspecified. Gives the vertical dimension of the data (number of observations) to be generated.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_upperlimit">upperlimit</code></td>
<td>
<p>Optional. A positive integer giving the maximum sample size to be simulated, if data was supplied.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_nsample">nsample</code></td>
<td>
<p>A positive integer giving the number of samples to be generated for each value of $n$. Larger values give more accurate results.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_steps">steps</code></td>
<td>
<p>A positive integer giving the interval of values of $n$ for which simulations should be conducted. Larger values give more accurate results.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_eta">eta</code></td>
<td>
<p>A real number between 0 and 1 giving the probability of misclassification error in the training data.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_delta">delta</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum probability of observing an OOS error rate higher than <code>epsilon</code></p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_epsilon">epsilon</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum out-of-sample (OOS) error rate</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_predictfn">predictfn</code></td>
<td>
<p>An optional user-defined function giving a custom predict method. If also using a user-defined model, the <code>model</code> should output an object of class <code>"svrclass"</code> to avoid errors.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_power">power</code></td>
<td>
<p>A logical indicating whether experimental power based on the predictions should also be reported</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_effect_size">effect_size</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, a real number indicating the scaled effect size the user would like to be able to detect.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_powersims">powersims</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, an integer indicating the number of simulations to be conducted at each step to calculate power.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_alpha">alpha</code></td>
<td>
<p>If <code>power</code> is <code>TRUE</code>, a real number between 0 and 1 indicating the probability of Type I error to be used for hypothesis testing. Default is 0.05.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_parallel">parallel</code></td>
<td>
<p>Boolean indicating whether or not to use parallel processing.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_coreoffset">coreoffset</code></td>
<td>
<p>If <code>parallel</code> is true, a positive integer indicating the number of free threads to be kept unused. Should not be larger than the number of CPU cores.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_packages">packages</code></td>
<td>
<p>A list of packages that need to be loaded in order to run <code>model</code>.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_method">method</code></td>
<td>
<p>An optional string stating the distribution from which data is to be generated. Default is i.i.d. uniform sampling. Can also take a function outputting a vector of probabilities if the user wishes to specify a custom distribution.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_p">p</code></td>
<td>
<p>If method is 'Class Imbalance', gives the degree of weight placed on the positive class.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_minn">minn</code></td>
<td>
<p>Optional argument to set a different minimum n than the dimension of the algorithm. Useful with e.g. regularized regression models such as elastic net.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_x">x</code></td>
<td>
<p>Optional argument for methods that take separate predictor and outcome data. Specifies a matrix-like object containing predictors. Note that if used, the x and y objects are bound together columnwise; this must be handled in the user-supplied helper function.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_y">y</code></td>
<td>
<p>Optional argument for methods that take separate predictor and outcome data. Specifies a vector-like object containing outcome values. Note that if used, the x and y objects are bound together columnwise; this must be handled in the user-supplied helper function.</p>
</td></tr>
<tr><td><code id="estimate_accuracy_+3A_...">...</code></td>
<td>
<p>Additional arguments that need to be passed to <code>model</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing two named elements. <code>Raw</code> gives the exact output of the simulations, while <code>Summary</code> gives a table of accuracy metrics, including the achieved levels of <code class="reqn">\epsilon</code> and <code class="reqn">\delta</code> given the specified values. Alternative values can be calculated using <code><a href="#topic+getpac">getpac()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_accuracy">plot_accuracy()</a></code>, to represent simulations visually, <code><a href="#topic+getpac">getpac()</a></code>, to calculate summaries for alternate values of <code class="reqn">\epsilon</code> and <code class="reqn">\delta</code> without conducting a new simulation, and <code><a href="#topic+gendata">gendata()</a></code>, to generated synthetic datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}

library(parallel)
  results &lt;- estimate_accuracy(two_year_recid ~
    race + sex + age + juv_fel_count + juv_misd_count + priors_count +
    charge_degree..misd.fel.,mylogit,br,
    predictfn = mypred,
    nsample=10,
    steps=1000,
    coreoffset = (detectCores() -2)
  )

</code></pre>

<hr>
<h2 id='gendata'>Simulate data with appropriate structure to be used in estimating sample complexity bounds</h2><span id='topic+gendata'></span>

<h3>Description</h3>

<p>Simulate data with appropriate structure to be used in estimating sample complexity bounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendata(model, dim, maxn, predictfn = NULL, varnames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gendata_+3A_model">model</code></td>
<td>
<p>A binary classification model supplied by the user. Must take arguments <code>formula</code> and <code>data</code></p>
</td></tr>
<tr><td><code id="gendata_+3A_dim">dim</code></td>
<td>
<p>Gives the horizontal dimension of the data (number of predictor variables) to be generated.</p>
</td></tr>
<tr><td><code id="gendata_+3A_maxn">maxn</code></td>
<td>
<p>Gives the vertical dimension of the data (number of observations) to be generated.</p>
</td></tr>
<tr><td><code id="gendata_+3A_predictfn">predictfn</code></td>
<td>
<p>An optional user-defined function giving a custom predict method. If also using a user-defined model, the <code>model</code> should output an object of class <code>"svrclass"</code> to avoid errors.</p>
</td></tr>
<tr><td><code id="gendata_+3A_varnames">varnames</code></td>
<td>
<p>An optional character vector giving the names of variables to be used for the generated data</p>
</td></tr>
<tr><td><code id="gendata_+3A_...">...</code></td>
<td>
<p>Additional arguments that need to be passed to <code>model</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the simulated data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code>, to estimate sample complexity bounds given the generated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}
formula &lt;- two_year_recid ~
  race + sex + age + juv_fel_count +
  juv_misd_count + priors_count + charge_degree..misd.fel.
dat &lt;- gendata(mylogit,7,7214,mypred,all.vars(formula))

library(parallel)
results &lt;- estimate_accuracy(formula,mylogit,dat,predictfn = mypred,
    nsample=10,
    steps=10,
    coreoffset = (detectCores() -2))

</code></pre>

<hr>
<h2 id='getpac'>Recalculate achieved sample complexity bounds given different parameter inputs</h2><span id='topic+getpac'></span>

<h3>Description</h3>

<p>Recalculate achieved sample complexity bounds given different parameter inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpac(table, epsilon = 0.05, delta = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getpac_+3A_table">table</code></td>
<td>
<p>A list containing an element named <code>Raw</code>. Should always be used with the output of <code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code></p>
</td></tr>
<tr><td><code id="getpac_+3A_epsilon">epsilon</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum out-of-sample (OOS) error rate</p>
</td></tr>
<tr><td><code id="getpac_+3A_delta">delta</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum probability of observing an OOS error rate higher than <code>epsilon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing two named elements. <code>Raw</code> gives the exact output of the simulations, while <code>Summary</code> gives a table of accuracy metrics, including the achieved levels of <code class="reqn">\epsilon</code> and <code class="reqn">\delta</code> given the specified values. Alternative values can be calculated using <code><a href="#topic+getpac">getpac()</a></code> again.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_accuracy">plot_accuracy()</a></code>, to represent simulations visually, <code><a href="#topic+getpac">getpac()</a></code>, to calculate summaries for alternate values of <code class="reqn">\epsilon</code> and <code class="reqn">\delta</code> without conducting a new simulation, and <code><a href="#topic+gendata">gendata()</a></code>, to generated synthetic datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}

library(parallel)
results &lt;- estimate_accuracy(two_year_recid ~ race +
    sex + age + juv_fel_count + juv_misd_count + priors_count +
    charge_degree..misd.fel.,mylogit,br,predictfn = mypred,
    nsample=10,
    steps=1000,
    coreoffset = (detectCores() -2))
resultsalt &lt;- getpac(results,epsilon=0.5,delta=0.3)
print(resultsalt$Summary)

</code></pre>

<hr>
<h2 id='loss'>Utility function to define the least-squares loss function to be optimized for <code><a href="#topic+simvcd">simvcd()</a></code></h2><span id='topic+loss'></span>

<h3>Description</h3>

<p>Utility function to define the least-squares loss function to be optimized for <code><a href="#topic+simvcd">simvcd()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss(h, ngrid, xi, a = 0.16, a1 = 1.2, a11 = 0.14927)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loss_+3A_h">h</code></td>
<td>
<p>A positive real number giving the current guess at VC dimension</p>
</td></tr>
<tr><td><code id="loss_+3A_ngrid">ngrid</code></td>
<td>
<p>Vector of sample sizes for which the bounding function is estimated.</p>
</td></tr>
<tr><td><code id="loss_+3A_xi">xi</code></td>
<td>
<p>Vector of estimated values of the bounding function, usually obtained from <code><a href="#topic+risk_bounds">risk_bounds()</a></code></p>
</td></tr>
<tr><td><code id="loss_+3A_a">a</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
<tr><td><code id="loss_+3A_a1">a1</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
<tr><td><code id="loss_+3A_a11">a11</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the estimated value of the MSE given the current guess.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simvcd">simvcd()</a></code>, the user-facing function for simulating VC dimension and <code><a href="#topic+risk_bounds">risk_bounds()</a></code> to generate estimates for xi.
</p>

<hr>
<h2 id='plot_accuracy'>Represent simulated sample complexity bounds graphically</h2><span id='topic+plot_accuracy'></span>

<h3>Description</h3>

<p>Represent simulated sample complexity bounds graphically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_accuracy(
  table,
  metrics = c("Accuracy", "Precision", "Recall", "Fscore", "Delta", "Epsilon", "Power"),
  plottype = c("ggplot", "plotly"),
  letters = c("greek", "latin")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_accuracy_+3A_table">table</code></td>
<td>
<p>A list containing an element named <code>Raw</code>. Should always be used with the output of <code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code></p>
</td></tr>
<tr><td><code id="plot_accuracy_+3A_metrics">metrics</code></td>
<td>
<p>A character vector containing the metrics to display in the plot. Can be any of &quot;Accuracy&quot;, &quot;Precision&quot;, &quot;Recall&quot;, &quot;Fscore&quot;, &quot;delta&quot;, &quot;epsilon&quot;</p>
</td></tr>
<tr><td><code id="plot_accuracy_+3A_plottype">plottype</code></td>
<td>
<p>A string giving the graphics package to be used to generate the plot. Can be one of &quot;ggplot&quot; or &quot;plotly&quot;</p>
</td></tr>
<tr><td><code id="plot_accuracy_+3A_letters">letters</code></td>
<td>
<p>A string determining whether delta and epsilon should be given as greek letters in the plot legend. Defaults to Greek lettering but available in case of rendering issues.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <a href="ggplot2.html#topic+ggplot">ggplot</a> or <a href="plotly.html#topic+plot_ly">plot_ly</a> plot object, depending on the chosen option of <code>plottype</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_accuracy">estimate_accuracy()</a></code>, to generate estimated sample complexity bounds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}

library(parallel)
results &lt;- estimate_accuracy(two_year_recid ~ race + sex + age +
      juv_fel_count + juv_misd_count + priors_count +
      charge_degree..misd.fel.,mylogit,br,predictfn = mypred,
    nsample=10,
    steps=1000,
    coreoffset = (detectCores() -2))

fig &lt;- plot_accuracy(results,letters="latin")
fig

</code></pre>

<hr>
<h2 id='risk_bounds'>Utility function to generate data points for estimation of the VC Dimension of a user-specified binary classification algorithm given a specified sample size.</h2><span id='topic+risk_bounds'></span>

<h3>Description</h3>

<p>Utility function to generate data points for estimation of the VC Dimension of a user-specified binary classification algorithm given a specified sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risk_bounds(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="risk_bounds_+3A_x">x</code></td>
<td>
<p>An integer giving the desired sample size for which the target function is to be approximated.</p>
</td></tr>
<tr><td><code id="risk_bounds_+3A_...">...</code></td>
<td>
<p>Additional model parameters to be specified by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the estimated value of Xi(n), the bounding function
</p>

<hr>
<h2 id='scb'>Calculate sample complexity bounds for a classifier given target accuracy</h2><span id='topic+scb'></span>

<h3>Description</h3>

<p>Calculate sample complexity bounds for a classifier given target accuracy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scb(vcd = NULL, epsilon = NULL, delta = NULL, eta = NULL, theor = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scb_+3A_vcd">vcd</code></td>
<td>
<p>The Vapnik-Chervonenkis dimension (VCD) of the chosen classifier. If <code>theor</code> is <code>FALSE</code>, this can be left unspecified and <code><a href="#topic+simvcd">simvcd()</a></code> will be called to estimate the VCD</p>
</td></tr>
<tr><td><code id="scb_+3A_epsilon">epsilon</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum out-of-sample (OOS) error rate</p>
</td></tr>
<tr><td><code id="scb_+3A_delta">delta</code></td>
<td>
<p>A real number between 0 and 1 giving the targeted maximum probability of observing an OOS error rate higher than <code>epsilon</code></p>
</td></tr>
<tr><td><code id="scb_+3A_eta">eta</code></td>
<td>
<p>A real number between 0 and 1 giving the probability of misclassification error in the training data.</p>
</td></tr>
<tr><td><code id="scb_+3A_theor">theor</code></td>
<td>
<p>A Boolean indicating whether the theoretical VCD is to be used. If <code>FALSE</code>, it will instead be estimated using <code><a href="#topic+simvcd">simvcd()</a></code></p>
</td></tr>
<tr><td><code id="scb_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+simvcd">simvcd()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the sample complexity bound for the specified parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simvcd">simvcd()</a></code>, to calculate VCD for a chosen model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}
library(parallel)
scb(epsilon=0.05,delta=0.05,eta=0.05,theor=FALSE,
model=mylogit,dim=7,m=10,k=10,maxn=50,predictfn = mypred,
    coreoffset = (detectCores() -2))
vcd &lt;- 7
scb(vcd,epsilon=0.05,delta=0.05,eta=0.05)
</code></pre>

<hr>
<h2 id='simvcd'>Estimate the Vapnik-Chervonenkis (VC) dimension of an arbitrary binary classification algorithm.</h2><span id='topic+simvcd'></span>

<h3>Description</h3>

<p>Estimate the Vapnik-Chervonenkis (VC) dimension of an arbitrary binary classification algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simvcd(
  model,
  dim,
  packages = list(),
  m = 1000,
  k = 1000,
  maxn = 5000,
  parallel = TRUE,
  coreoffset = 0,
  predictfn = NULL,
  a = 0.16,
  a1 = 1.2,
  a11 = 0.14927,
  minn = (dim + 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simvcd_+3A_model">model</code></td>
<td>
<p>A binary classification model supplied by the user. Must take arguments <code>formula</code> and <code>data</code></p>
</td></tr>
<tr><td><code id="simvcd_+3A_dim">dim</code></td>
<td>
<p>A positive integer giving dimension (number of input features) of the model.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_packages">packages</code></td>
<td>
<p>A <code>list</code> of strings giving the names of packages to be loaded in order to estimate the model.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_m">m</code></td>
<td>
<p>A positive integer giving the number of simulations to be performed at each design point (sample size value). Higher values give more accurate results but increase computation time.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_k">k</code></td>
<td>
<p>A positive integer giving the number of design points (sample size values) for which the bounding function is to be estimated. Higher values give more accurate results but increase computation time.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_maxn">maxn</code></td>
<td>
<p>Gives the vertical dimension of the data (number of observations) to be generated.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_parallel">parallel</code></td>
<td>
<p>Boolean indicating whether or not to use parallel processing.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_coreoffset">coreoffset</code></td>
<td>
<p>If <code>parallel</code> is true, a positive integer indicating the number of free threads to be kept unused. Should not be larger than the number of CPU cores.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_predictfn">predictfn</code></td>
<td>
<p>An optional user-defined function giving a custom predict method. If also using a user-defined model, the <code>model</code> should output an object of class <code>"svrclass"</code> to avoid errors.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_a">a</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_a1">a1</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_a11">a11</code></td>
<td>
<p>Scaling coefficient for the bounding function. Defaults to the value given by Vapnik, Levin and Le Cun 1994.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_minn">minn</code></td>
<td>
<p>Optional argument to set a different minimum n than the dimension of the algorithm. Useful with e.g. regularized regression models such as elastic net.</p>
</td></tr>
<tr><td><code id="simvcd_+3A_...">...</code></td>
<td>
<p>Additional arguments that need to be passed to <code>model</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number giving the estimated value of the VC dimension of the supplied model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scb">scb()</a></code>, to calculate sample complexity bounds given estimated VCD.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mylogit &lt;- function(formula, data){
m &lt;- structure(
  glm(formula=formula,data=data,family=binomial(link="logit")),
  class=c("svrclass","glm")  #IMPORTANT - must use the class svrclass to work correctly
)
return(m)
}
mypred &lt;- function(m,newdata){
out &lt;- predict.glm(m,newdata,type="response")
out &lt;- factor(ifelse(out&gt;0.5,1,0),levels=c("0","1"))
#Important - must specify levels to account for possibility of all
#observations being classified into the same class in smaller samples
return(out)
}
library(parallel)
vcd &lt;- simvcd(model=mylogit,dim=7,m=10,k=10,maxn=50,predictfn = mypred,
    coreoffset = (detectCores() -2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
