<!DOCTYPE html><html><head><title>Help for package mgwrsar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mgwrsar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bandwidths_mgwrsar'><p>bandwidths_mgwrsar</p></a></li>
<li><a href='#find_TP'><p>Search of a suitable set of target points.</p>
find_TP is a wrapper function that identifies  a set of target points based on spatial smoothed OLS residuals.</a></li>
<li><a href='#INST_C'><p>INST_C</p>
to be documented</a></li>
<li><a href='#int_prems'><p>int_prems</p>
to be documented</a></li>
<li><a href='#kernel_matW'><p>kernel_matW</p>
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.</a></li>
<li><a href='#MGWRSAR'><p>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</p></a></li>
<li><a href='#mgwrsar_bootstrap_test'><p>A bootstrap test for Betas for mgwrsar class model.</p></a></li>
<li><a href='#mgwrsar_bootstrap_test_all'><p>A bootstrap test for testing nullity of all Betas for mgwrsar class model,</p></a></li>
<li><a href='#multiscale_gwr'><p>multiscale_gwr</p>
This function adapts the multiscale Geographically Weighted Regression (GWR) methodology
proposed by Fotheringam et al. in 2017, employing a backward fitting procedure within
the MGWRSAR subroutines. The consecutive bandwidth optimizations are performed by
minimizing the corrected Akaike criteria.</a></li>
<li><a href='#multiscale_gwr.cv'><p>multiscale_gwr.cv</p>
to be documented (experimental)</a></li>
<li><a href='#mydata'><p>mydata is a simulated data set of a mgwrsar model</p></a></li>
<li><a href='#normW'><p>normW</p>
row normalization of dgCMatrix</a></li>
<li><a href='#PhWY_C'><p>PhWY_C</p>
to be documented</a></li>
<li><a href='#plot_effect'><p>plot_effect</p>
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.</a></li>
<li><a href='#plot_mgwrsar'><p>plot_mgwrsar plots the value of local paramaters of a mgwrsar models using a leaflet map.</p></a></li>
<li><a href='#predict_mgwrsar'><p>mgwrsar Model Predictions</p>
predict_mgwrsar is a function for computing predictions of a mgwrsar models. It uses Best Linear Unbiased Predictor for mgwrsar models with spatial autocorrelation.</a></li>
<li><a href='#Proj_C'><p>Proj_C</p>
to be documented</a></li>
<li><a href='#QRcpp2_C'><p>QRcpp2_C</p>
to be documented</a></li>
<li><a href='#simu_multiscale'><p>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</p></a></li>
<li><a href='#Sl_C'><p>Sl_C</p>
to be documented</a></li>
<li><a href='#summary_Matrix'><p>summary_Matrix</p>
to be documented</a></li>
<li><a href='#summary_mgwrsar'><p>Print a summary of mgwrsar models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>GWR and MGWR with Spatial Autocorrelation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Ghislain Geniaux and Davide Martinetti</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ghislain Geniaux &lt;ghislain.geniaux@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for computing (Mixed) Geographically Weighted Regression with spatial autocorrelation, Geniaux and Martinetti (2017) &lt;<a href="https://doi.org/10.1016%2Fj.regsciurbeco.2017.04.001">doi:10.1016/j.regsciurbeco.2017.04.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp, sp, leaflet, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, sf, knitr, spgwr, methods, doParallel, foreach,
htmltools, nabor, mapview, microbenchmark, rlang, dplyr,
gridExtra, grid, mboost, mgcv, caret</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 13:14:49 UTC; geniaux</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bandwidths_mgwrsar'>bandwidths_mgwrsar</h2><span id='topic+bandwidths_mgwrsar'></span>

<h3>Description</h3>

<p>Select optimal kernel and bandwidth from a list of models, kernels and bandwidth candidates.
a bandwidth value for each of the chosen models and kernel types using a leave-one-out cross validation criteria.
A cross validated criteria is also used for selecting the best kernel type for a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidths_mgwrsar(formula, data,coords,
fixed_vars='Intercept',Models='GWR',candidates_Kernels='bisq',
control=list(),control_search=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidths_mgwrsar_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_data">data</code></td>
<td>
<p>a dataframe or a spatial dataframe (sp package).</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_coords">coords</code></td>
<td>
<p>a dataframe or a matrix with coordinates, not required if data is a spatial dataframe, default NULL.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>a vector with the names of spatially constant coefficient. For mixed model, if NULL, the default
#' is set to 'Intercept'.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_models">Models</code></td>
<td>
<p>character containing the type of model: Possible values are &quot;OLS&quot;,
&quot;SAR&quot;, &quot;GWR&quot; (default), &quot;MGWR&quot; , &quot;MGWRSAR_0_0_kv&quot;,&quot;MGWRSAR_1_0_kv&quot;,
&quot;MGWRSAR_0_kc_kv&quot;, &quot;MGWRSAR_1_kc_kv&quot;, &quot;MGWRSAR_1_kc_0&quot;.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_candidates_kernels">candidates_Kernels</code></td>
<td>
<p>a vector with the names of kernel type.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_control">control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper - see MGWRSAR help.</p>
</td></tr>
<tr><td><code id="bandwidths_mgwrsar_+3A_control_search">control_search</code></td>
<td>
<p>list of extra control arguments for bandwidth/kernel search - see details below.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>search_W</dt><dd><p>if TRUE select an optimal spatial weight matrix using a moment estimator, default FALSE.</p>
</dd>
<dt>kernels_w</dt><dd><p>if search_W is TRUE, kernels_w is a vector of candidated kernels types, default NULL.</p>
</dd>
<dt>lower_c</dt><dd><p>lower bound for bandwidth search (default, the approximate first decile of distances).</p>
</dd>
<dt>upper_c</dt><dd><p>upper bound for bandwidth search  (default, the approximate last decile of distances).</p>
</dd>
<dt>lower_d</dt><dd><p>lower bound for discrete kernels, default 2*k+1.</p>
</dd>
<dt>lower_dW</dt><dd><p>ower bound for discrete kernels for finding optimal spatial weight matrix, default 2.</p>
</dd>
<dt>lower_cW</dt><dd><p>lower bound for  bandwidth search for finding optimal spatial
weight matrix  (default approximate 0.005 quantile of distances).</p>
</dd>
</dl>



<h3>Value</h3>

<p>bandwiths_MGWRSAR returns a list with:
</p>

<dl>
<dt>config_model</dt><dd><p>a vector with information about model, optimal kernel and
bandwidth for local regression, and optimal kernel and bandwith for spatial weight matrix W.</p>
</dd>
<dt>SSR</dt><dd><p>The sum of square residuals.</p>
</dd>
<dt>CV</dt><dd><p>The CV criteria.</p>
</dd>
<dt>model</dt><dd><p>objects of class mgwrsar estimated using config_model</p>
</dd>
</dl>



<h3>References</h3>

<p>Geniaux, G. and Martinetti, D. (2017). A new method for dealing simultaneously with spatial autocorrelation and spatial heterogeneity in regression models. Regional Science and Urban Economics. (https://doi.org/10.1016/j.regsciurbeco.2017.04.001)
</p>
<p>McMillen, D. and Soppelsa, M. E. (2015). A conditionally parametric probit model of
microdata land use in chicago. Journal of Regional Science, 55(3):391-415.
</p>
<p>Loader, C. (1999). Local regression and likelihood, volume 47. Springer New York.
</p>
<p>Franke, R. and Nielson, G. (1980). Smooth interpolation of large sets of scattered data.
International journal for numerical methods in engineering, 15(11):1691-1704.
</p>


<h3>See Also</h3>

<p>MGWRSAR, summary_mgwrsar, plot_mgwrsar, predict_mgwrsar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mgwrsar)
## loading data example
data(mydata)
coords=as.matrix(mydata[,c("x","y")])
mytab&lt;-bandwidths_mgwrsar(formula = 'Y_gwr~X1+X2+X3', data = mydata,coords=coords,
fixed_vars=c('Intercept','X1'),Models=c('GWR','MGWR'),candidates_Kernels=c('bisq','gauss'),
control=list(NN=300,adaptive=TRUE),control_search=list())

names(mytab)
names(mytab[['GWR_bisq_adaptive']])

mytab[['GWR_bisq_adaptive']]$config_model
mytab[['GWR_bisq_adaptive']]$CV
summary(mytab[['GWR_bisq_adaptive']]$model$Betav)

mybestmodel=mytab[['GWR_gauss_adaptive']]$model
plot_mgwrsar(mybestmodel,type='B_coef',var='X2')

</code></pre>

<hr>
<h2 id='find_TP'>Search of a suitable set of target points.
find_TP is a wrapper function that identifies  a set of target points based on spatial smoothed OLS residuals.</h2><span id='topic+find_TP'></span>

<h3>Description</h3>

<p>Search of a suitable set of target points.
find_TP is a wrapper function that identifies  a set of target points based on spatial smoothed OLS residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_TP(formula, data,coords,K,kWtp=16,Wtp=NULL,type='residuals',
model_residuals=NULL,verbose=0,prev_TP=NULL,nTP=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_TP_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="find_TP_+3A_data">data</code></td>
<td>
<p>a dataframe or a spatial dataframe (SP package)</p>
</td></tr>
<tr><td><code id="find_TP_+3A_coords">coords</code></td>
<td>
<p>a dataframe or a matrix with coordinates, not required if data is a spatial dataframe</p>
</td></tr>
<tr><td><code id="find_TP_+3A_k">K</code></td>
<td>
<p>the minimum number of first neighbors with lower (resp.higer) absolute value of the smoothed residuals.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_kwtp">kWtp</code></td>
<td>
<p>the number of first neighbors for computing  the smoothed residuals, default 16.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_wtp">Wtp</code></td>
<td>
<p>a precomputed matrix of weights, default NULL.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_type">type</code></td>
<td>
<p>method for choosing TP, could be 'residuals', 'equidistantGrid','random',  default 'residuals'</p>
</td></tr>
<tr><td><code id="find_TP_+3A_model_residuals">model_residuals</code></td>
<td>
<p>(optional) a vector of residuals.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_verbose">verbose</code></td>
<td>
<p>verbose mode, default FALSE.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_prev_tp">prev_TP</code></td>
<td>
<p>index of already used TP (version length(K)&gt;1), default NULL.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_ntp">nTP</code></td>
<td>
<p>numbeer of target points for random choice of target points, default NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>find_TP is a wrapper function that identifies a set of target points, based on spatial smoothed residuals by default.
If no vector of residuals are provided, OLS residuals are computed.
The function first computes the smooth of model residuals using a Sheppard's kernel with kWtp neighbors (default 16).
Then it identifies local maxima (resp. minima) that fits the requirement of having at least K neighbors with lower (resp.higer) absolute value of the smoothed residuals. As K increases the number of target points decreases.
</p>


<h3>Value</h3>

<p>find_TP returns an index vector of Target Points set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 TP=find_TP(formula = 'Y_gwr~X1+X2+X3', data =mydata,coords=coords,K=6,type='residuals')
 # only 60 targets points are used
 length(TP)

 model_GWR_tp&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata,coords=coords,
 fixed_vars=NULL,kernels=c('gauss'),  H=0.03, Model = 'GWR',
 control=list(SE=TRUE,TP=TP,kWtp=12))
 summary(model_GWR_tp$Betav)
 
</code></pre>

<hr>
<h2 id='INST_C'>INST_C
to be documented</h2><span id='topic+INST_C'></span>

<h3>Description</h3>

<p>INST_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INST_C(XX, WW, withlambda, llambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INST_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_withlambda">withlambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_llambda">llambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='int_prems'>int_prems
to be documented</h2><span id='topic+int_prems'></span>

<h3>Description</h3>

<p>int_prems
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prems(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_prems_+3A_x">X</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='kernel_matW'>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.</h2><span id='topic+kernel_matW'></span>

<h3>Description</h3>

<p>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_matW(H,kernels,coord_i,coord_j=NULL,NN,ncolX=1,
Type='GD',adaptive=FALSE,diagnull=TRUE,rowNorm=TRUE,noisland=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_matW_+3A_h">H</code></td>
<td>
<p>A vector of bandwidths</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_kernels">kernels</code></td>
<td>
<p>A vector of kernel types</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_coord_i">coord_i</code></td>
<td>
<p>A matrix with  variables used in kernel (reference)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_coord_j">coord_j</code></td>
<td>
<p>A matrix with  variables used in kernel (neighbors), default NULL (if NULL coord_j=coord_i)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_nn">NN</code></td>
<td>
<p>Number of spatial Neighbours for kernels computations</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_ncolx">ncolX</code></td>
<td>
<p>control parameter</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_type">Type</code></td>
<td>
<p>Type of Genelarized kernel product ('GD' only spatial,'GDC'
spatial + a categorical variable,'GDX' spatial + a continuous variable,
'GDT' spatial + a time index, and other combinations 'GDXXC','GDTX',...)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_adaptive">adaptive</code></td>
<td>
<p>A vector of boolean to choose adaptive version for each kernel</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_diagnull">diagnull</code></td>
<td>
<p>Zero on diagonal, default FALSE</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_rownorm">rowNorm</code></td>
<td>
<p>A boolean, row normalization of weights, default TRUE</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_noisland">noisland</code></td>
<td>
<p>A boolean to avoid isle with no neighbours for non adaptive kernel, default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse Matrix of weights (dgCMatrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix) of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coord_i=coords,NN=4,adaptive=TRUE,diagnull=TRUE,rowNorm=TRUE)

</code></pre>

<hr>
<h2 id='MGWRSAR'>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</h2><span id='topic+MGWRSAR'></span>

<h3>Description</h3>

<p>MGWRSAR is is a wrapper function for estimating linear and local linear models
with spatial autocorrelation (SAR models with spatially varying coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGWRSAR(formula,data,coords,fixed_vars=NULL,kernels,H,
Model='GWR',control=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGWRSAR_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_data">data</code></td>
<td>
<p>a dataframe or a spatial dataframe (sp package).</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates, not
required if data is a spatial dataframe.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>a vector with the names of spatiallay constant coefficient for
mixed model. All other variables present in formula are supposed to be spatially
varying. If empty or NULL (default), all variables in formula are supposed to be
spatially varying.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;), epanechnikov (&quot;epane&quot;), gaussian
(&quot;gauss&quot;)) .</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_h">H</code></td>
<td>
<p>vector containing the bandwidth parameters for the kernel functions.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_model">Model</code></td>
<td>
<p>character containing the type of model: Possible values are &quot;OLS&quot;,
&quot;SAR&quot;, &quot;GWR&quot; (default), &quot;MGWR&quot; , &quot;MGWRSAR_0_0_kv&quot;,&quot;MGWRSAR_1_0_kv&quot;,
&quot;MGWRSAR_0_kc_kv&quot;, &quot;MGWRSAR_1_kc_kv&quot;, &quot;MGWRSAR_1_kc_0&quot;. See Details for more
explanation.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_control">control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper - see Details below</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Z</dt><dd><p> a matrix of variables for genralized kernel product, default NULL.</p>
</dd>
<dt>W</dt><dd><p> a row-standardized spatial weight matrix for Spatial Aurocorrelation, default NULL.</p>
</dd>
<dt>type</dt><dd><p> verbose mode, default FALSE.</p>
</dd>
<dt>adaptive</dt><dd><p>A vector of boolean to choose adaptive version for each kernel.</p>
</dd>
<dt>kernel_w</dt><dd><p> the type of kernel for computing W, default NULL.</p>
</dd>
<dt>h_w</dt><dd><p> the bandwidth value for computing W, default 0.</p>
</dd>
<dt>Method</dt><dd><p> estimation technique for computing the models with Spatial Dependence. '2SLS' or 'B2SLS', default '2SLS'.</p>
</dd>
<dt>TP</dt><dd><p> A vector of target points, default NULL.</p>
</dd>
<dt>doMC</dt><dd><p>Parallel computation, default FALSE</p>
</dd>
<dt>ncore</dt><dd><p>number of CPU core for parallel computation, default 1</p>
</dd>
<dt>isgcv</dt><dd><p> computing LOOCV criteria (for example for selecting optimal bandwidth), default FALSE.</p>
</dd>
<dt>isfgcv</dt><dd><p> if TRUE, simplify the computation of CV criteria (remove or not i
when using local instruments for model with lambda spatially varying), default TRUE.</p>
</dd>
<dt>maxknn</dt><dd><p> when n &gt;NmaxDist, only the maxknn first neighbours are used for distance compution, default 500.</p>
</dd>
<dt>NmaxDist</dt><dd><p> when n &gt;NmaxDist only the maxknn first neighbours are used for distance compution, default 5000</p>
</dd>
<dt>verbose</dt><dd><p> verbose mode, default FALSE.</p>
</dd>
</dl>



<h3>Value</h3>

<p>MGWRSAR returns an object of class mgwrsar with at least the following components:
</p>

<dl>
<dt>Betav</dt><dd><p> matrix of coefficients of dim(n,kv) x kv.</p>
</dd>
<dt>Betac</dt><dd><p> vector of coefficients of length kc.</p>
</dd>
<dt>Model</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>Y</dt><dd><p> The dependent variable.</p>
</dd>
<dt>XC</dt><dd><p> The explanatory variables with constant coefficients.</p>
</dd>
<dt>XV</dt><dd><p> The explanatory variables with varying coefficients.</p>
</dd>
<dt>X</dt><dd><p> The explanatory variables.</p>
</dd>
<dt>W</dt><dd><p> The spatial weight matrix for spatial dependence.</p>
</dd>
<dt>isgcv</dt><dd><p> if gcv has been computed.</p>
</dd>
<dt>edf</dt><dd><p> The estimated degrees of freedom.</p>
</dd>
<dt>formula</dt><dd><p>The formula.</p>
</dd>
<dt>data</dt><dd><p> The dataframe used for computation.</p>
</dd>
<dt>Method</dt><dd><p> The type of model.</p>
</dd>
<dt>coords</dt><dd><p> The spatial coordinates of observations.</p>
</dd>
<dt>H</dt><dd><p> The bandwidth vector.</p>
</dd>
<dt>fixed_vars</dt><dd><p> The names of constant coefficients.</p>
</dd>
<dt>kernels</dt><dd><p> The kernel vector.</p>
</dd>
<dt>SSR</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>residuals</dt><dd><p> The vector of residuals.</p>
</dd>
<dt>fit</dt><dd><p> the vector of fitted values.</p>
</dd>
<dt>sev</dt><dd><p> local standard error of parameters.</p>
</dd>
<dt>get_ts</dt><dd><p>Boolean, if trace of hat matrix Tr(S) should be stored.</p>
</dd>
<dt>NN</dt><dd><p> Maximum number of neighbors for weights computation</p>
</dd>
</dl>

<p>MGWRSAR is is a wrapper function for estimating linear and local linear model
with spatial autocorrelation that  allows to estimate the following models :
<code class="reqn">y=\beta_c X_c+\,\epsilon_i</code> (OLS)
</p>
<p><code class="reqn">y=\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (GWR)
</p>
<p><code class="reqn">y=\beta_c X_c+\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (MGWR)
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(0,k,0))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,0,k))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,k_c,k_v))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i) Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(1,k,0))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,0,k))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_cX_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,k_c,k_v))
</p>
<p>When model imply spatial autocorrelation, a row normalized spatial weight matrix must be provided.
2SLS and Best 2SLS method can be used.
When model imply local regression, a bandwidth and a kernel type must be provided. Optimal bandwidth can be estimated
using bandwidths_mgwrsar function.
When model imply mixed local regression, the names of stationary covariates must be provided.
</p>
<p>#' In addition to the ability of considering spatial autocorrelation in GWR/MGWR like models,
MGWRSAR function introduces several useful technics for estimating local regression with space coordinates:
</p>

<ul>
<li><p>it uses RCCP and RCCPeigen code that speed up computation and allows parallel computing via doMC package;
</p>
</li>
<li><p>it allows to drop out variables with not enough local variance in local regression, which allows to consider dummies in GWR/MGWR framework without trouble.
</p>
</li>
<li><p>it allows to drop out local outliers in local regression.
</p>
</li>
<li><p>it allows to consider additional variable for kernel, including  time (asymetric kernel) and categorical variables (see Li and Racine 2010). Experimental version.
</p>
</li></ul>



<h3>References</h3>

<p>Geniaux, G. and Martinetti, D. (2017). A new method for dealing simultaneously with spatial autocorrelation and spatial heterogeneity in regression models. Regional Science and Urban Economics. (https://doi.org/10.1016/j.regsciurbeco.2017.04.001)
</p>
<p>McMillen, D. and Soppelsa, M. E. (2015). A conditionally parametric probit model of
microdata land use in chicago. Journal of Regional Science, 55(3):391-415.
</p>
<p>Loader, C. (1999). Local regression and likelihood, volume 47. springer New York.
</p>
<p>Franke, R. and Nielson, G. (1980). Smooth interpolation of large sets of scattered data.
International journal for numerical methods in engineering, 15(11):1691-1704.
</p>


<h3>See Also</h3>

<p>bandwidths_mgwrsar, summary_mgwrsar, plot_mgwrsar, predict_mgwrsar, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coord_i=coords,NN=4,adaptive=TRUE,
 diagnull=TRUE,rowNorm=TRUE)
 mgwrsar_0_kc_kv&lt;-MGWRSAR(formula = 'Y_mgwrsar_0_kc_kv~X1+X2+X3', data = mydata,
 coords=coords, fixed_vars='X2',kernels=c('gauss'),H=20, Model = 'MGWRSAR_0_kc_kv',
 control=list(SE=FALSE,adaptive=TRUE,W=W))
 summary_mgwrsar(mgwrsar_0_kc_kv)

</code></pre>

<hr>
<h2 id='mgwrsar_bootstrap_test'>A bootstrap test for Betas for mgwrsar class model.</h2><span id='topic+mgwrsar_bootstrap_test'></span>

<h3>Description</h3>

<p>A bootstrap test for Betas for mgwrsar class model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgwrsar_bootstrap_test(x0,x1,B=100,domc=FALSE,ncore=1,
type='standard',eps='H1',df='H1',focal='median',D=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_x0">x0</code></td>
<td>
<p>The H0 mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_x1">x1</code></td>
<td>
<p>The H1 mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_b">B</code></td>
<td>
<p>number of bootstrap repetitions, default 100</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_domc">domc</code></td>
<td>
<p>If TRUE, doParallel parallelization</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_ncore">ncore</code></td>
<td>
<p>number of cores</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_type">type</code></td>
<td>
<p>type of bootstap : 'wild','Rademacher','spatial' or 'standard' (default)</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_eps">eps</code></td>
<td>
<p>Hypothesis under wich residuals are simulated,  'H0' or 'H1' (default)</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_df">df</code></td>
<td>
<p>Hypothesis under wich degree of freedom is estimated.</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_focal">focal</code></td>
<td>
<p>see sample_stat help</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_d">D</code></td>
<td>
<p>A matrix of distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the statictics test and a p ratio.
</p>


<h3>See Also</h3>

<p>mgwrsar_bootstrap_test_all
</p>

<hr>
<h2 id='mgwrsar_bootstrap_test_all'>A bootstrap test for testing nullity of all Betas for mgwrsar class model,</h2><span id='topic+mgwrsar_bootstrap_test_all'></span>

<h3>Description</h3>

<p>A bootstrap test for testing nullity of all Betas for mgwrsar class model,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgwrsar_bootstrap_test_all(model,B=100,domc=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_model">model</code></td>
<td>
<p>A mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications, default 100</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_domc">domc</code></td>
<td>
<p>If TRUE, doMC parallelization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with statistical test values and p ratios
</p>


<h3>See Also</h3>

<p>mgwrsar_bootstrap_test
</p>

<hr>
<h2 id='multiscale_gwr'>multiscale_gwr
This function adapts the multiscale Geographically Weighted Regression (GWR) methodology
proposed by Fotheringam et al. in 2017, employing a backward fitting procedure within
the MGWRSAR subroutines. The consecutive bandwidth optimizations are performed by
minimizing the corrected Akaike criteria.</h2><span id='topic+multiscale_gwr'></span>

<h3>Description</h3>

<p>multiscale_gwr
This function adapts the multiscale Geographically Weighted Regression (GWR) methodology
proposed by Fotheringam et al. in 2017, employing a backward fitting procedure within
the MGWRSAR subroutines. The consecutive bandwidth optimizations are performed by
minimizing the corrected Akaike criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale_gwr(formula,data,coords,Model = 'GWR',kernels='bisq',
control=list(SE=FALSE,adaptive=TRUE,NN=800,isgcv=FALSE),init='GWR',maxiter=100,
nstable=6,crit=0.000001,doMC=FALSE,ncore=1,HF=NULL,H0=NULL,model=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiscale_gwr_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_model">Model</code></td>
<td>
<p>The type of model: Possible values are &quot;GWR&quot; (default),
and &quot;MGWRSAR_1_0_kv&quot;. See Details for more explanation.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;), epanechnikov (&quot;epane&quot;),
gaussian(&quot;gauss&quot;)).</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_control">control</code></td>
<td>
<p>a list of extra control arguments, see MGWRSAR help.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_init">init</code></td>
<td>
<p>starting model (lm or GWR)</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in the back-fitting procedure.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_nstable">nstable</code></td>
<td>
<p>required number of consecutive unchanged optimal bandwidth (by covariate)
before leaving optimisation of bandwidth size, default 3.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_crit">crit</code></td>
<td>
<p>value to terminate the back-fitting iterations (ratio of change in RMSE)</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_domc">doMC</code></td>
<td>
<p>A boolean for Parallel computation, default FALSE.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_ncore">ncore</code></td>
<td>
<p>number of CPU cores for parallel computation, default 1.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_hf">HF</code></td>
<td>
<p>if available, a vector containing the optimal bandwidth parameters for each
covariate, default NULL.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_h0">H0</code></td>
<td>
<p>A bandwidth value for the starting GWR model, default NULL.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_model">model</code></td>
<td>
<p>A previous model estimated using multiscale_gwr function, default NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class mgwrsar with at least the following components:
</p>

<dl>
<dt>Betav</dt><dd><p> matrix of coefficients of dim(n,kv) x kv.</p>
</dd>
<dt>Betac</dt><dd><p> vector of coefficients of length kc.</p>
</dd>
<dt>Model</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>Y</dt><dd><p> The dependent variable.</p>
</dd>
<dt>XC</dt><dd><p> The explanatory variables with constant coefficients.</p>
</dd>
<dt>XV</dt><dd><p> The explanatory variables with varying coefficients.</p>
</dd>
<dt>X</dt><dd><p> The explanatory variables.</p>
</dd>
<dt>W</dt><dd><p> The spatial weight matrix for spatial dependence.</p>
</dd>
<dt>isgcv</dt><dd><p> if gcv has been computed.</p>
</dd>
<dt>edf</dt><dd><p> The estimated degrees of freedom.</p>
</dd>
<dt>formula</dt><dd><p>The formula.</p>
</dd>
<dt>data</dt><dd><p> The dataframe used for computation.</p>
</dd>
<dt>Method</dt><dd><p> The type of model.</p>
</dd>
<dt>coords</dt><dd><p> The spatial coordinates of observations.</p>
</dd>
<dt>H</dt><dd><p> A vector of bandwidths.</p>
</dd>
<dt>fixed_vars</dt><dd><p> The names of constant coefficients.</p>
</dd>
<dt>kernels</dt><dd><p> The kernel vector.</p>
</dd>
<dt>SSR</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>residuals</dt><dd><p> The vector of residuals.</p>
</dd>
<dt>fit</dt><dd><p> the vector of fitted values.</p>
</dd>
<dt>sev</dt><dd><p> local standard error of parameters.</p>
</dd>
<dt>get_ts</dt><dd><p>Boolean, if trace of hat matrix Tr(S) should be stored.</p>
</dd>
<dt>NN</dt><dd><p> Maximum number of neighbors for weights computation</p>
</dd>
</dl>



<h3>See Also</h3>

<p>tds_mgwr, bandwidths_mgwrsar, summary_mgwrsar, plot_mgwrsar, predict_mgwrsar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mgwrsar)
mysimu&lt;-simu_multiscale(n=1000)
mydata=mysimu$mydata
coords=mysimu$coords
model_multiscale&lt;-multiscale_gwr(formula=as.formula('Y~X1+X2+X3'),data=mydata,
coords=coords,Model = 'GWR',kernels='bisq',control=list(SE=FALSE,
adaptive=TRUE,NN=900,isgcv=FALSE),init='GWR',nstable=6,crit=0.000001)
summary_mgwrsar(model_multiscale)

</code></pre>

<hr>
<h2 id='multiscale_gwr.cv'>multiscale_gwr.cv
to be documented (experimental)</h2><span id='topic+multiscale_gwr.cv'></span>

<h3>Description</h3>

<p>multiscale_gwr.cv
to be documented (experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale_gwr.cv(dataName, argDataName="data", target='Y', K=5, regFun, par_model,
par_model2=NULL,regFun2=NULL, predFun, args_predNames, extra_args_pred=NULL,
namesXtraArgs2Split=NULL,myseed=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiscale_gwr.cv_+3A_dataname">dataName</code></td>
<td>
<p>character, name of the data</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_argdataname">argDataName</code></td>
<td>
<p>character, generic name to use as data name.</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_target">target</code></td>
<td>
<p>character, name of variable to explain</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_k">K</code></td>
<td>
<p>integer, number of folds for cross validation</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_regfun">regFun</code></td>
<td>
<p>character, name of the estimation function</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_par_model">par_model</code></td>
<td>
<p>named list with the arguments for the estimation function</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_par_model2">par_model2</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_regfun2">regFun2</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_predfun">predFun</code></td>
<td>
<p>character, name of the prediction function</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_args_prednames">args_predNames</code></td>
<td>
<p>named list with the arguments for the prediction function</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_extra_args_pred">extra_args_pred</code></td>
<td>
<p>named list with extra arguments for non generic prediction function</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_namesxtraargs2split">namesXtraArgs2Split</code></td>
<td>
<p>character, names of the objects in extra_args_pred that need to be split for cross validation.</p>
</td></tr>
<tr><td><code id="multiscale_gwr.cv_+3A_myseed">myseed</code></td>
<td>
<p>seed for random number.</p>
</td></tr>
</table>

<hr>
<h2 id='mydata'>mydata is a simulated data set of a mgwrsar model</h2><span id='topic+mydata'></span>

<h3>Description</h3>

<p>mydata is a simulated data set of a mgwrsar model
</p>


<h3>Author(s)</h3>

<p>Ghislain Geniaux and Davide Martinetti <a href="mailto:ghislain.geniaux@inra.fr">ghislain.geniaux@inra.fr</a>
</p>


<h3>References</h3>

<p><a href="https://www.sciencedirect.com/science/article/pii/S0166046216302381">https://www.sciencedirect.com/science/article/pii/S0166046216302381</a>
</p>

<hr>
<h2 id='normW'>normW
row normalization of dgCMatrix</h2><span id='topic+normW'></span>

<h3>Description</h3>

<p>normW
row normalization of dgCMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normW(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normW_+3A_w">W</code></td>
<td>
<p>A dgCMatrix class matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row normalized dgCMatrix
</p>

<hr>
<h2 id='PhWY_C'>PhWY_C
to be documented</h2><span id='topic+PhWY_C'></span>

<h3>Description</h3>

<p>PhWY_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhWY_C(YY, XX, WW, Wi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PhWY_C_+3A_yy">YY</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_wi">Wi</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='plot_effect'>plot_effect
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.</h2><span id='topic+plot_effect'></span>

<h3>Description</h3>

<p>plot_effect
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_effect(model,sampling=TRUE,nsample=2000,nsample_max=5000,title='')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_effect_+3A_model">model</code></td>
<td>
<p>a model of mgwrsar class with some spatially varying coefficients.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_sampling">sampling</code></td>
<td>
<p>Bolean, if nrow(model$Betav)&gt; nsample_max a sample of size nsample is randomly selected, default TRUE.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_nsample">nsample</code></td>
<td>
<p>integer,  size of the sample if sampling is TRUE, default 2000.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_nsample_max">nsample_max</code></td>
<td>
<p>integer, size max to engage sampling if sampling is TRUE, default 5000.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_title">title</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 8 nearest neighbors with 0 in diagonal
 model_GWR0&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata,coords=coords,
 fixed_vars=NULL,kernels=c('gauss'),H=0.13, Model = 'GWR',control=list(SE=TRUE))
 plot_effect(model_GWR0)

</code></pre>

<hr>
<h2 id='plot_mgwrsar'>plot_mgwrsar plots the value of local paramaters of a mgwrsar models using a leaflet map.</h2><span id='topic+plot_mgwrsar'></span>

<h3>Description</h3>

<p>plot_mgwrsar plots the value of local paramaters of a mgwrsar models using a leaflet map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mgwrsar(model,type='coef',var=NULL,crs=NULL,mypalette= "RdYlGn",opacity=0.5
,fopacity=0.5,nbins=8,radius=500,mytile='Stamen.TonerBackground',myzoom=8,
myresolution=150,LayersControl=TRUE,myzoomControl=TRUE,mytile2=NULL,ScaleBar=NULL,
ScaleBarOptions=list(maxWidth = 200, metric = TRUE,imperial = FALSE,
updateWhenIdle = TRUE),MyLegendTitle=NULL,lopacity=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mgwrsar_+3A_model">model</code></td>
<td>
<p>a mgwsar model.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_type">type</code></td>
<td>
<p>default 'coef', for plotting the value of the coefficients. Local t-Student could also be plot using 't_coef', residuals using 'residuals' and fitted using 'fitted'.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_var">var</code></td>
<td>
<p>Names of variable to plot.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_crs">crs</code></td>
<td>
<p>A CRS projection.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_mypalette">mypalette</code></td>
<td>
<p>A leaflet palette.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_opacity">opacity</code></td>
<td>
<p>Opacity of border color.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_fopacity">fopacity</code></td>
<td>
<p>Opacity of fill color.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_nbins">nbins</code></td>
<td>
<p>nbins.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_radius">radius</code></td>
<td>
<p>radius of circle for plot of points.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_mytile">mytile</code></td>
<td>
<p>tile 1.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_myzoom">myzoom</code></td>
<td>
<p>level of zoom for tile 1.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_myresolution">myresolution</code></td>
<td>
<p>resolution for tile 1.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_layerscontrol">LayersControl</code></td>
<td>
<p>layers contols.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_myzoomcontrol">myzoomControl</code></td>
<td>
<p>zoem control.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_mytile2">mytile2</code></td>
<td>
<p>tile 2.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_scalebar">ScaleBar</code></td>
<td>
<p>ScaleBar.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_scalebaroptions">ScaleBarOptions</code></td>
<td>
<p>options for ScaleBar.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_mylegendtitle">MyLegendTitle</code></td>
<td>
<p>Legend title.</p>
</td></tr>
<tr><td><code id="plot_mgwrsar_+3A_lopacity">lopacity</code></td>
<td>
<p>opacity for legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Interactive Web Maps with local parameters plot and Open Street Map layer.
</p>


<h3>See Also</h3>

<p>MGWRSAR, bandwidths_mgwrsar, summary_mgwrsar, predict_mgwrsar, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 4 nearest neighbors with 0 in diagonal
 model_GWR0&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata,coords=coords,
 fixed_vars=NULL,kernels=c('gauss'),H=0.13, Model='GWR',control=list(SE=TRUE))
 summary_mgwrsar(model_GWR0)
 plot_mgwrsar(model_GWR0,type='B_coef',var='X2')
 plot_mgwrsar(model_GWR0,type='t_coef',var='X2')

</code></pre>

<hr>
<h2 id='predict_mgwrsar'>mgwrsar Model Predictions
predict_mgwrsar is a function for computing predictions of a mgwrsar models. It uses Best Linear Unbiased Predictor for mgwrsar models with spatial autocorrelation.</h2><span id='topic+predict_mgwrsar'></span>

<h3>Description</h3>

<p>mgwrsar Model Predictions
predict_mgwrsar is a function for computing predictions of a mgwrsar models. It uses Best Linear Unbiased Predictor for mgwrsar models with spatial autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_mgwrsar(model, newdata, newdata_coords, W = NULL, type = "BPN",
h_w = 100,kernel_w = "rectangle",maxobs=4000,beta_proj=FALSE,
method_pred='TP', k_extra = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_mgwrsar_+3A_model">model</code></td>
<td>
<p>a model of mgwrsar class.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_newdata">newdata</code></td>
<td>
<p>a matrix or data.frame of new data.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_newdata_coords">newdata_coords</code></td>
<td>
<p>a matrix of new coordinates, and eventually other variables if a General Kernel Product is used.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_w">W</code></td>
<td>
<p>the spatial weight matrix for models with  spatial autocorrelation.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_type">type</code></td>
<td>
<p>Type for BLUP estimator, default &quot;BPN&quot;. If NULL use predictions without spatial bias correction.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_h_w">h_w</code></td>
<td>
<p>A bandwidth value for the spatial weight matrix</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_kernel_w">kernel_w</code></td>
<td>
<p>kernel type for the spatial weight matrix. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;),
epanechnikov (&quot;epane&quot;), gaussian (&quot;gauss&quot;)) .</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_maxobs">maxobs</code></td>
<td>
<p>maximum number of observations for exact calculation of solve(I- rho*W), default maxobs=4000.</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_beta_proj">beta_proj</code></td>
<td>
<p>A boolean, if TRUE the function then return a two elements list(Y_predicted,Beta_proj_out)</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_method_pred">method_pred</code></td>
<td>
<p>If method_pred = 'TP' (default) prediction is done by recomputing a MGWRSAR model
with new-data as target points, else if method_pred in ('tWtp_model','model','sheppard') a matrix
for projecting estimated betas is used (see details).</p>
</td></tr>
<tr><td><code id="predict_mgwrsar_+3A_k_extra">k_extra</code></td>
<td>
<p>number of neighboors for local parameter extrapolation if sheppard kernel is used, default 8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if method_pred ='tWtp_model',  the weighting matrix for prediction is
based on the expected weights of outsample data if they were had been added to
insample data to estimate the corresponding MGWRSAR (see Geniaux 2022 for
further detail), if method_pred ='sheppard'a sheppard kernel with k_extra neighbours (default 8) is used and if method_pred='kernel_model' the same kernel
and number of neighbors as for computing the MGWRSAR model is used.
</p>


<h3>Value</h3>

<p>A vector of predictions if beta_proj is FALSE or a list with a vector named Y_predicted and a matrix named Beta_proj_out.
</p>


<h3>See Also</h3>

<p>MGWRSAR, bandwidths_mgwrsar, summary_mgwrsar, plot_mgwrsar, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mgwrsar)
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
length_out=800
index_in=sample(1:1000,length_out)
index_out=(1:1000)[-index_in]

model_GWR_insample&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata[index_in,],
coords=coords[index_in,],fixed_vars=NULL,kernels=c ('gauss'),H=8, Model = 'GWR',
control=list(adaptive=TRUE))
summary_mgwrsar(model_GWR_insample)

newdata=mydata[index_out,]
newdata_coords=coords[index_out,]
newdata$Y_mgwrsar_1_0_kv=0

Y_pred=predict_mgwrsar(model_GWR_insample, newdata=newdata,
newdata_coords=newdata_coords)
head(Y_pred)
head(mydata$Y_gwr[index_out])
sqrt(mean((mydata$Y_gwr[index_out]-Y_pred)^2)) # RMSE

</code></pre>

<hr>
<h2 id='Proj_C'>Proj_C
to be documented</h2><span id='topic+Proj_C'></span>

<h3>Description</h3>

<p>Proj_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Proj_C(HH, XX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Proj_C_+3A_hh">HH</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Proj_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='QRcpp2_C'>QRcpp2_C
to be documented</h2><span id='topic+QRcpp2_C'></span>

<h3>Description</h3>

<p>QRcpp2_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QRcpp2_C(AA, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QRcpp2_C_+3A_aa">AA</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="QRcpp2_C_+3A_bb">bb</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="QRcpp2_C_+3A_cc">cc</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='simu_multiscale'>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</h2><span id='topic+simu_multiscale'></span>

<h3>Description</h3>

<p>The simu_multiscale function is designed for simulating a spatially varying
coefficient DGP (Data Generating Process) based on formulations proposed by
Fotheringam et al. (2017), Gao et al. (2021), or Geniaux (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_multiscale(n=1000,myseed=1,type='GG2024',b0_constant=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_multiscale_+3A_n">n</code></td>
<td>
<p>An integer number of observations.</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_myseed">myseed</code></td>
<td>
<p>An integer seed used for the simulation.</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_type">type</code></td>
<td>
<p>Type of DGP used 'FT2017', 'Gao2021' or 'GG2024', default 'GG2024'.</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_b0_constant">b0_constant</code></td>
<td>
<p>A boolean parameter indicating whether the intercept term
should be spatially varying (TRUE) or not (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with simulated data ('mydata') and coords ('coords')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 library(ggplot2)
 library(gridExtra)
 library(grid)
 simu=simu_multiscale(1000)
 mydata=simu$mydata
 coords=simu$coords
 p1&lt;-ggplot(mydata,aes(x,y,col=Beta1))+geom_point() +scale_color_viridis_c()
 p2&lt;-ggplot(mydata,aes(x,y,col=Beta2))+geom_point() +scale_color_viridis_c()
 p3&lt;-ggplot(mydata,aes(x,y,col=Beta3))+geom_point() +scale_color_viridis_c()
 p4&lt;-ggplot(mydata,aes(x,y,col=Beta4))+geom_point() +scale_color_viridis_c()
 grid.arrange(p1,p2,p3,p4,nrow=2,ncol=2, top = textGrob("DGP Geniaux (2024)"
 ,gp=gpar(fontsize=20,font=3)))

</code></pre>

<hr>
<h2 id='Sl_C'>Sl_C
to be documented</h2><span id='topic+Sl_C'></span>

<h3>Description</h3>

<p>Sl_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sl_C(llambda, WW, iinv, aapprox)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sl_C_+3A_llambda">llambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_iinv">iinv</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_aapprox">aapprox</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='summary_Matrix'>summary_Matrix
to be documented</h2><span id='topic+summary_Matrix'></span>

<h3>Description</h3>

<p>summary_Matrix
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_Matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_Matrix_+3A_object">object</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="summary_Matrix_+3A_...">...</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='summary_mgwrsar'>Print a summary of mgwrsar models</h2><span id='topic+summary_mgwrsar'></span>

<h3>Description</h3>

<p>Print a summary of mgwrsar models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_mgwrsar(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_mgwrsar_+3A_model">model</code></td>
<td>
<p>a model of class mgwrsar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary of mgwrsar models
</p>


<h3>See Also</h3>

<p>MGWRSAR, bandwidths_mgwrsar, plot_mgwrsar, predict_mgwrsar, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coord_i=coords,NN=4,adaptive=TRUE,
 diagnull=TRUE,rowNorm=TRUE)
 mgwrsar_0_kc_kv&lt;-MGWRSAR(formula = 'Y_mgwrsar_0_kc_kv~X1+X2+X3', data = mydata,
 coords=coords, fixed_vars='X2',kernels=c('gauss'),H=20, Model = 'MGWRSAR_0_kc_kv',
 control=list(SE=FALSE,adaptive=TRUE,W=W))
 summary_mgwrsar(mgwrsar_0_kc_kv)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
