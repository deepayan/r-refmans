<!DOCTYPE html><html lang="en"><head><title>Help for package mgwrsar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mgwrsar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#atds_gwr'><p>atds_gwr Top-Down Scaling approach of GWR</p></a></li>
<li><a href='#coef+2Cmgwrsar-method'><p>coef for mgwrsar model</p></a></li>
<li><a href='#find_TP'><p>Search of a suitable set of target points.</p>
find_TP is a wrapper function that identifies  a set of target points
based on spatial smoothed OLS residuals.</a></li>
<li><a href='#fitted+2Cmgwrsar-method'><p>fitted for mgwrsar model</p></a></li>
<li><a href='#golden_search_bandwidth'><p>golden_search_bandwidth</p>
to be documented</a></li>
<li><a href='#INST_C'><p>INST_C</p>
to be documented</a></li>
<li><a href='#int_prems'><p>int_prems</p>
to be documented</a></li>
<li><a href='#kernel_matW'><p>kernel_matW</p>
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.</a></li>
<li><a href='#MGWRSAR'><p>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</p></a></li>
<li><a href='#mgwrsar_bootstrap_test'><p>A bootstrap test for Betas for mgwrsar class model.</p></a></li>
<li><a href='#mgwrsar_bootstrap_test_all'><p>A bootstrap test for testing nullity of all Betas for mgwrsar class model,</p></a></li>
<li><a href='#mgwrsar-class'><p>Class of mgwrsar Model.</p></a></li>
<li><a href='#modc'><p>modc is a set of models to correct approximation of hat matrix trace</p></a></li>
<li><a href='#multiscale_gwr'><p>multiscale_gwr</p>
This function adapts the multiscale Geographically Weighted Regression (GWR)
methodology proposed by Fotheringam et al. in 2017, employing a backward
fitting procedure within the MGWRSAR subroutines. The consecutive bandwidth
optimizations are performed by minimizing the corrected Akaike criteria.</a></li>
<li><a href='#mydata'><p>mydata is a simulated data set of a mgwrsar model</p></a></li>
<li><a href='#mydatasf'><p>mydataf is a Simple Feature object with real estate data in south of France.</p></a></li>
<li><a href='#normW'><p>normW</p>
row normalization of dgCMatrix</a></li>
<li><a href='#PhWY_C'><p>PhWY_C</p>
to be documented</a></li>
<li><a href='#plot_effect'><p>plot_effect</p>
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.</a></li>
<li><a href='#plot+2Cmgwrsar+2Cmissing-method'><p>Plot method for mgwrsar model</p></a></li>
<li><a href='#predict+2Cmgwrsar-method'><p>predict method for mgwrsar model</p></a></li>
<li><a href='#Proj_C'><p>Proj_C</p>
to be documented</a></li>
<li><a href='#QRcpp2_C'><p>QRcpp2_C</p>
to be documented</a></li>
<li><a href='#residuals+2Cmgwrsar-method'><p>residuals for mgwrsar model</p></a></li>
<li><a href='#simu_multiscale'><p>Estimation of linear and local linear model with spatial</p>
autocorrelation model (mgwrsar).</a></li>
<li><a href='#Sl_C'><p>Sl_C</p>
to be documented</a></li>
<li><a href='#summary_Matrix'><p>summary_Matrix</p>
to be documented</a></li>
<li><a href='#summary+2Cmgwrsar-method'><p>summary for mgwrsar model</p></a></li>
<li><a href='#tds_mgwr'><p>Top-Down Scaling approach of multiscale GWR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>GWR, Mixed GWR and Multiscale GWR with Spatial Autocorrelation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ghislain Geniaux &lt;ghislain.geniaux@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for computing (Mixed and Multiscale) Geographically Weighted Regression with spatial autocorrelation, Geniaux and Martinetti (2017) &lt;<a href="https://doi.org/10.1016%2Fj.regsciurbeco.2017.04.001">doi:10.1016/j.regsciurbeco.2017.04.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Rcpp, sp, leaflet, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, sf, knitr, methods, doParallel, foreach, htmltools,
nabor, mapview, microbenchmark, rlang, dplyr, gridExtra, grid,
mboost, mgcv, caret, stringr, SMUT</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-20 11:26:46 UTC; geniaux</td>
</tr>
<tr>
<td>Author:</td>
<td>Ghislain Geniaux [aut, cre],
  Davide Martinetti [aut],
  CÃ©sar Martinez [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-20 12:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='atds_gwr'>atds_gwr Top-Down Scaling approach of GWR</h2><span id='topic+atds_gwr'></span>

<h3>Description</h3>

<p>This function performs a Geographically Weighted Regression (GWR) using
a top-down scaling approach, adjusting GWR coefficients with a progressively
decreasing bandwidth as long as the AICc criterion improves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atds_gwr(formula,data,coords,kernels='triangle',fixed_vars=NULL,
control_tds=list(nns=30),control=list(adaptive=TRUE,verbose=FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atds_gwr_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_data">data</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
triangle (&quot;triangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;), epanechnikov (&quot;epane&quot;).</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>a vector with the names of spatiallay constant
coefficient for mixed model. All other variables present in formula
are supposed to be spatially varying. If empty or NULL (default),
all variables in formula are supposed to be spatially varying.</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_control_tds">control_tds</code></td>
<td>
<p>list of extra control arguments for tds_mgwr model - see tds_gwr Help</p>
</td></tr>
<tr><td><code id="atds_gwr_+3A_control">control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper - see MGWRSAR Help</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>tds_mgwr, gwr_multiscale, MGWRSAR, bandwidths_mgwrsar, summary_mgwrsar.
</p>

<hr>
<h2 id='coef+2Cmgwrsar-method'>coef for mgwrsar model</h2><span id='topic+coef+2Cmgwrsar-method'></span>

<h3>Description</h3>

<p>coef for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef+2B2Cmgwrsar-method_+3A_object">object</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="coef+2B2Cmgwrsar-method_+3A_...">...</code></td>
<td>
<p>coef parameters forwarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with a matrix of varying coefficients and a vector or non varying coefficients.
</p>

<hr>
<h2 id='find_TP'>Search of a suitable set of target points.
find_TP is a wrapper function that identifies  a set of target points
based on spatial smoothed OLS residuals.</h2><span id='topic+find_TP'></span>

<h3>Description</h3>

<p>Search of a suitable set of target points.
find_TP is a wrapper function that identifies  a set of target points
based on spatial smoothed OLS residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_TP(formula, data,coords,kt,ks=16,Wtp=NULL,type='residuals',
model_residuals=NULL,verbose=0,prev_TP=NULL,nTP=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_TP_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="find_TP_+3A_data">data</code></td>
<td>
<p>a dataframe or a spatial dataframe (SP package)</p>
</td></tr>
<tr><td><code id="find_TP_+3A_coords">coords</code></td>
<td>
<p>a dataframe or a matrix with coordinates, not required if
data is a spatial dataframe</p>
</td></tr>
<tr><td><code id="find_TP_+3A_kt">kt</code></td>
<td>
<p>the minimum number of first neighbors with lower (resp.higer)
absolute value of the smoothed residuals.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_ks">ks</code></td>
<td>
<p>the number of first neighbors for computing  the smoothed
residuals, default 16.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_wtp">Wtp</code></td>
<td>
<p>a precomputed matrix of weights, default NULL.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_type">type</code></td>
<td>
<p>method for choosing TP, could be 'residuals', '
kdtree','random',  default 'residuals'</p>
</td></tr>
<tr><td><code id="find_TP_+3A_model_residuals">model_residuals</code></td>
<td>
<p>(optional) a vector of residuals.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_verbose">verbose</code></td>
<td>
<p>verbose mode, default FALSE.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_prev_tp">prev_TP</code></td>
<td>
<p>index of already used TP (version length(kt)&gt;1),
default NULL.</p>
</td></tr>
<tr><td><code id="find_TP_+3A_ntp">nTP</code></td>
<td>
<p>numbeer of target points for random choice of target points,
default NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>find_TP is a wrapper function that identifies a set of target
points, based on spatial smoothed residuals by default.
If no vector of residuals are provided, OLS residuals are computed.
The function first computes the smooth of model residuals using a
Shepard's kernel with ks neighbors (default 16).
Then it identifies local maxima (resp. minima) that fits the requirement
of having at least kt neighbors with lower (resp.higer) absolute value
of the smoothed residuals. As kt increases the number of target points
decreases.
</p>


<h3>Value</h3>

<p>find_TP returns an index vector of Target Points set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 TP=find_TP(formula = 'Y_gwr~X1+X2+X3', data =mydata,coords=coords,kt=6,
 type='residuals')
 # only 60 targets points are used
 length(TP)

 model_GWR_tp&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata,
 coords=coords, fixed_vars=NULL,kernels=c('gauss'),  H=0.03, Model = 'GWR',
 control=list(SE=TRUE,TP=TP,ks=12))
 summary(model_GWR_tp@Betav)
 
</code></pre>

<hr>
<h2 id='fitted+2Cmgwrsar-method'>fitted for mgwrsar model</h2><span id='topic+fitted+2Cmgwrsar-method'></span>

<h3>Description</h3>

<p>fitted for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted+2B2Cmgwrsar-method_+3A_object">object</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="fitted+2B2Cmgwrsar-method_+3A_...">...</code></td>
<td>
<p>fitted parameters forwarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fitted values.
</p>

<hr>
<h2 id='golden_search_bandwidth'>golden_search_bandwidth
to be documented</h2><span id='topic+golden_search_bandwidth'></span>

<h3>Description</h3>

<p>golden_search_bandwidth
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>golden_search_bandwidth(formula,H2=NULL,data, coords, fixed_vars,
kernels, Model, control,lower.bound, upper.bound,tolerance=0.000001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="golden_search_bandwidth_+3A_formula">formula</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_h2">H2</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_data">data</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_coords">coords</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_kernels">kernels</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_model">Model</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_control">control</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_lower.bound">lower.bound</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_upper.bound">upper.bound</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="golden_search_bandwidth_+3A_tolerance">tolerance</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list(minimum=res,objective=objective,model=model).
</p>

<hr>
<h2 id='INST_C'>INST_C
to be documented</h2><span id='topic+INST_C'></span>

<h3>Description</h3>

<p>INST_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INST_C(XX, WW, withlambda, llambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="INST_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_withlambda">withlambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="INST_C_+3A_llambda">llambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='int_prems'>int_prems
to be documented</h2><span id='topic+int_prems'></span>

<h3>Description</h3>

<p>int_prems
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_prems(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int_prems_+3A_x">X</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='kernel_matW'>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.</h2><span id='topic+kernel_matW'></span>

<h3>Description</h3>

<p>kernel_matW
A function that returns a sparse weight matrix based computed with a specified
kernel (gauss,bisq,tcub,epane,rectangle,triangle) considering coordinates
provides in S and a given bandwidth. If NN&lt;nrow(S) only NN firts neighbours are considered.
If Type!='GD' then S should have additional columns and several
kernels and bandwidths should be be specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_matW(H,kernels,coords,NN,TP=NULL,Type='GD',adaptive=FALSE,
diagnull=TRUE,alpha=1,theta=1,dists=NULL,indexG=NULL,extrapol=FALSE,QP=NULL,K=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_matW_+3A_h">H</code></td>
<td>
<p>A vector of bandwidths</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_kernels">kernels</code></td>
<td>
<p>A vector of kernel types</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_coords">coords</code></td>
<td>
<p>A matrix with  variables used in kernel (reference)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_nn">NN</code></td>
<td>
<p>Number of spatial Neighbours for kernels computations</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_tp">TP</code></td>
<td>
<p>A vector with index of target points</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_type">Type</code></td>
<td>
<p>Type of Genelarized kernel product ('GD' only spatial,'GDC'
spatial + a categorical variable,'GDX' spatial + a continuous variable,
'GDT' spatial + a time index, and other combinations 'GDXXC','GDTX',...)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_adaptive">adaptive</code></td>
<td>
<p>A vector of boolean to choose adaptive version for each kernel</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_diagnull">diagnull</code></td>
<td>
<p>Zero on diagonal, default FALSE</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_alpha">alpha</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_theta">theta</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_dists">dists</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_indexg">indexG</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_extrapol">extrapol</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_qp">QP</code></td>
<td>
<p>A matrix with  variables used in kernel (neighbors), default NULL (if NULL coord_j=coord_i)</p>
</td></tr>
<tr><td><code id="kernel_matW_+3A_k">K</code></td>
<td>
<p>TO BE DOCUMENTED</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse Matrix of weights (dgCMatrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix) of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coords=coords,NN=4,adaptive=TRUE,diagnull=TRUE)

</code></pre>

<hr>
<h2 id='MGWRSAR'>Estimation of linear and local linear model with spatial autocorrelation model (mgwrsar).</h2><span id='topic+MGWRSAR'></span>

<h3>Description</h3>

<p>MGWRSAR is is a wrapper function for estimating linear and local linear models
with spatial autocorrelation (SAR models with spatially varying coefficients).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGWRSAR(formula, data, coords, fixed_vars = NULL, kernels, H,
Model = "GWR", control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MGWRSAR_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_data">data</code></td>
<td>
<p>a dataframe or a spatial dataframe (sp package).</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates, not
required if data is a spatial dataframe.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>a vector with the names of spatiallay constant coefficient for
mixed model. All other variables present in formula are supposed to be spatially
varying. If empty or NULL (default), all variables in formula are supposed to be
spatially varying.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;), epanechnikov (&quot;epane&quot;), gaussian
(&quot;gauss&quot;)) .</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_h">H</code></td>
<td>
<p>vector containing the bandwidth parameters for the kernel functions.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_model">Model</code></td>
<td>
<p>character containing the type of model: Possible values are &quot;OLS&quot;,
&quot;SAR&quot;, &quot;GWR&quot; (default), &quot;MGWR&quot; , &quot;MGWRSAR_0_0_kv&quot;,&quot;MGWRSAR_1_0_kv&quot;,
&quot;MGWRSAR_0_kc_kv&quot;, &quot;MGWRSAR_1_kc_kv&quot;, &quot;MGWRSAR_1_kc_0&quot;. See Details for more
explanation.</p>
</td></tr>
<tr><td><code id="MGWRSAR_+3A_control">control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper - see Details below</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Z</dt><dd><p>A matrix of variables for genralized kernel product, default NULL.</p>
</dd>
<dt>W</dt><dd><p>A row-standardized spatial weight matrix for Spatial
Aurocorrelation, default NULL.</p>
</dd>
<dt>type</dt><dd><p>Verbose mode, default FALSE.</p>
</dd>
<dt>adaptive</dt><dd><p>A vector of boolean to choose adaptive version for
each kernel.</p>
</dd>
<dt>kernel_w</dt><dd><p>The type of kernel for computing W, default NULL.</p>
</dd>
<dt>h_w</dt><dd><p>The bandwidth value for computing W, default 0.</p>
</dd>
<dt>Method</dt><dd><p>Estimation method for computing the models with Spatial
Dependence. '2SLS' or 'B2SLS', default '2SLS'.</p>
</dd>
<dt>TP</dt><dd><p>Avector of target points, default NULL.</p>
</dd>
<dt>doMC</dt><dd><p>Parallel computation, default FALSE. If TRUE and
control_tds$doMC is also TRUE, then control$doMC is set to FALSE.</p>
</dd>
<dt>ncore</dt><dd><p>Number of CPU core for parallel computation, default 1</p>
</dd>
<dt>isgcv</dt><dd><p>If TRUE, compute a LOOCV criteria, default FALSE.</p>
</dd>
<dt>isfgcv</dt><dd><p>If TRUE, simplify the computation of CV criteria
(remove or not i when using local instruments for model with lambda
spatially varying), default TRUE.</p>
</dd>
<dt>maxknn</dt><dd><p>When n &gt;NmaxDist, only the maxknn first neighbours are used
for distance compution, default 500.</p>
</dd>
<dt>NmaxDist</dt><dd><p>When n &gt;NmaxDist only the maxknn first neighbours are used
for distance compution, default 5000</p>
</dd>
<dt>verbose</dt><dd><p>Verbose mode, default FALSE.</p>
</dd>
</dl>



<h3>Value</h3>

<p>MGWRSAR returns an object of class mgwrsar with at least the following components:
</p>

<dl>
<dt>Betav</dt><dd><p> matrix of coefficients of dim(n,kv) x kv.</p>
</dd>
<dt>Betac</dt><dd><p> vector of coefficients of length kc.</p>
</dd>
<dt>Model</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>Y</dt><dd><p> The dependent variable.</p>
</dd>
<dt>XC</dt><dd><p> The explanatory variables with constant coefficients.</p>
</dd>
<dt>XV</dt><dd><p> The explanatory variables with varying coefficients.</p>
</dd>
<dt>X</dt><dd><p> The explanatory variables.</p>
</dd>
<dt>W</dt><dd><p> The spatial weight matrix for spatial dependence.</p>
</dd>
<dt>isgcv</dt><dd><p> if gcv has been computed.</p>
</dd>
<dt>edf</dt><dd><p> The estimated degrees of freedom.</p>
</dd>
<dt>formula</dt><dd><p>The formula.</p>
</dd>
<dt>data</dt><dd><p> The dataframe used for computation.</p>
</dd>
<dt>Method</dt><dd><p> The type of model.</p>
</dd>
<dt>coords</dt><dd><p> The spatial coordinates of observations.</p>
</dd>
<dt>H</dt><dd><p> The bandwidth vector.</p>
</dd>
<dt>fixed_vars</dt><dd><p>The names of constant coefficients.</p>
</dd>
<dt>kernels</dt><dd><p> The kernel vector.</p>
</dd>
<dt>SSR</dt><dd><p> The sum of square residuals.</p>
</dd>
<dt>residuals</dt><dd><p> The vector of residuals.</p>
</dd>
<dt>fit</dt><dd><p> the vector of fitted values.</p>
</dd>
<dt>sev</dt><dd><p> local standard error of parameters.</p>
</dd>
<dt>get_ts</dt><dd><p>Boolean, if trace of hat matrix Tr(S) should be stored.</p>
</dd>
<dt>NN</dt><dd><p> Maximum number of neighbors for weights computation</p>
</dd>
</dl>

<p>MGWRSAR is is a wrapper function for estimating linear and local linear model
with spatial autocorrelation that  allows to estimate the following models :
<code class="reqn">y=\beta_c X_c+\,\epsilon_i</code> (OLS)
</p>
<p><code class="reqn">y=\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (GWR)
</p>
<p><code class="reqn">y=\beta_c X_c+\beta_v(u_i,v_i) X_v+\,\epsilon_i</code> (MGWR)
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(0,k,0))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,0,k))
</p>
<p><code class="reqn">y=\lambda Wy+\beta_c X_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(0,k_c,k_v))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i) Wy+\beta_c X_c+\,\epsilon_i</code> (MGWR-SAR(1,k,0))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,0,k))
</p>
<p><code class="reqn">y=\lambda(u_i,v_i)Wy+\beta_cX_c+\beta_v(u_i,v_i)X_v+\,\epsilon_i</code> (MGWR-SAR(1,k_c,k_v))
</p>
<p>When model imply spatial autocorrelation, a row normalized spatial weight matrix must be provided.
2SLS and Best 2SLS method can be used.
When model imply local regression, a bandwidth and a kernel type must be provided. Optimal bandwidth can be estimated
using bandwidths_mgwrsar function.
When model imply mixed local regression, the names of stationary covariates must be provided.
</p>
<p>#' In addition to the ability of considering spatial autocorrelation in GWR/MGWR like models,
MGWRSAR function introduces several useful technics for estimating local regression with space coordinates:
</p>

<ul>
<li><p>it uses RCCP and RCCPeigen code that speed up computation and allows parallel computing via doMC package;
</p>
</li>
<li><p>it allows to drop out variables with not enough local variance in local regression, which allows to consider dummies in GWR/MGWR framework without trouble.
</p>
</li>
<li><p>it allows to drop out local outliers in local regression.
</p>
</li>
<li><p>it allows to consider additional variable for kernel, including  time (asymetric kernel) and categorical variables (see Li and Racine 2010). Experimental version.
</p>
</li></ul>



<h3>References</h3>

<p>Geniaux, G. and Martinetti, D. (2017). A new method for dealing simultaneously with spatial autocorrelation and spatial heterogeneity in regression models. Regional Science and Urban Economics. (https://doi.org/10.1016/j.regsciurbeco.2017.04.001)
</p>
<p>McMillen, D. and Soppelsa, M. E. (2015). A conditionally parametric probit model of
microdata land use in chicago. Journal of Regional Science, 55(3):391-415.
</p>
<p>Loader, C. (1999). Local regression and likelihood, volume 47. springer New York.
</p>
<p>Franke, R. and Nielson, G. (1980). Smooth interpolation of large sets of scattered data.
International journal for numerical methods in engineering, 15(11):1691-1704.
</p>


<h3>See Also</h3>

<p>bandwidths_mgwrsar, summary, plot, predict, kernel_matW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 4 nearest neighbors with 0 in diagonal
 W=kernel_matW(H=4,kernels='rectangle',coords=coords,NN=4,adaptive=TRUE,
 diagnull=TRUE)
 mgwrsar_0_kc_kv&lt;-MGWRSAR(formula = 'Y_mgwrsar_0_kc_kv~X1+X2+X3', data = mydata,
 coords=coords, fixed_vars='X2',kernels=c('gauss'),H=20, Model = 'MGWRSAR_0_kc_kv',
 control=list(SE=FALSE,adaptive=TRUE,W=W))
 summary(mgwrsar_0_kc_kv)

</code></pre>

<hr>
<h2 id='mgwrsar_bootstrap_test'>A bootstrap test for Betas for mgwrsar class model.</h2><span id='topic+mgwrsar_bootstrap_test'></span>

<h3>Description</h3>

<p>A bootstrap test for Betas for mgwrsar class model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgwrsar_bootstrap_test(x0,x1,B=100,doMC=FALSE,ncore=1,type='standard'
,eps='H1',df='H1',focal='median',D=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgwrsar_bootstrap_test_+3A_x0">x0</code></td>
<td>
<p>The H0 mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_x1">x1</code></td>
<td>
<p>The H1 mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_b">B</code></td>
<td>
<p>number of bootstrap repetitions, default 100</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_domc">doMC</code></td>
<td>
<p>If TRUE, doParallel parallelization</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_ncore">ncore</code></td>
<td>
<p>number of cores</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_type">type</code></td>
<td>
<p>type of bootstap : 'wild','Rademacher','spatial' or 'standard' (default)</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_eps">eps</code></td>
<td>
<p>Hypothesis under wich residuals are simulated,  'H0' or 'H1' (default)</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_df">df</code></td>
<td>
<p>Hypothesis under wich degree of freedom is estimated.</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_focal">focal</code></td>
<td>
<p>see sample_stat help</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_+3A_d">D</code></td>
<td>
<p>A matrix of distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the statictics test and a p ratio.
</p>


<h3>See Also</h3>

<p>mgwrsar_bootstrap_test_all
</p>

<hr>
<h2 id='mgwrsar_bootstrap_test_all'>A bootstrap test for testing nullity of all Betas for mgwrsar class model,</h2><span id='topic+mgwrsar_bootstrap_test_all'></span>

<h3>Description</h3>

<p>A bootstrap test for testing nullity of all Betas for mgwrsar class model,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgwrsar_bootstrap_test_all(model,B=100,doMC=FALSE,ncore=1,
type='standard')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_model">model</code></td>
<td>
<p>A mgwrsar model</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications, default 100</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_domc">doMC</code></td>
<td>
<p>If TRUE, doMC parallelization</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_ncore">ncore</code></td>
<td>
<p>number of cores.</p>
</td></tr>
<tr><td><code id="mgwrsar_bootstrap_test_all_+3A_type">type</code></td>
<td>
<p>type of boostrap ('spatial','wild','random')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with statistical test values and p ratios
</p>


<h3>See Also</h3>

<p>mgwrsar_bootstrap_test
</p>

<hr>
<h2 id='mgwrsar-class'>Class of mgwrsar Model.</h2><span id='topic+mgwrsar-class'></span>

<h3>Description</h3>

<p>Class of mgwrsar Model.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Betav</code></dt><dd><p>matrix, the estimated varying coefficients, dim(n,kv).</p>
</dd>
<dt><code>Betac</code></dt><dd><p>numeric, the estimated constant coefficients, length kc.</p>
</dd>
<dt><code>Model</code></dt><dd><p>character, The type of model.</p>
</dd>
<dt><code>fixed_vars</code></dt><dd><p>character, a vector with name of constant covarariate.</p>
</dd>
<dt><code>Y</code></dt><dd><p>numeric, the dependent variable.</p>
</dd>
<dt><code>XC</code></dt><dd><p>matrix, the explanatory variables with constant coefficients.</p>
</dd>
<dt><code>XV</code></dt><dd><p>matrix, the explanatory variables with varying coefficients.</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix, the explanatory variables.</p>
</dd>
<dt><code>W</code></dt><dd><p>SparseMatrix, the spatial weight matrix for spatial dependence.</p>
</dd>
<dt><code>isgcv</code></dt><dd><p>logical, if gcv has been computed.</p>
</dd>
<dt><code>edf</code></dt><dd><p>numeric, the estimated degrees of freedom.</p>
</dd>
<dt><code>formula</code></dt><dd><p><code>formula</code></p>
</dd>
<dt><code>data</code></dt><dd><p>dataframe, The dataframe used for computation.</p>
</dd>
<dt><code>Method</code></dt><dd><p>character, the estimation technique for computing the models with Spatial Dependence. '2SLS' or 'B2SLS', default '2SLS'.</p>
</dd>
<dt><code>coords</code></dt><dd><p>matrix, the spatial coordinates of observations.</p>
</dd>
<dt><code>H</code></dt><dd><p>numeric, the bandwidth vector.</p>
</dd>
<dt><code>H2</code></dt><dd><p>numeric, the time bandwidth vector.</p>
</dd>
<dt><code>kernels</code></dt><dd><p>character, the type of kernel.</p>
</dd>
<dt><code>adaptive</code></dt><dd><p>logical, adaptive kernel.</p>
</dd>
<dt><code>Type</code></dt><dd><p>character, the type of General Kernel Product.</p>
</dd>
<dt><code>TP</code></dt><dd><p>numeric, index of target points.</p>
</dd>
<dt><code>SSRtp</code></dt><dd><p>numeric, the sum of square residuals for TP.</p>
</dd>
<dt><code>SSR</code></dt><dd><p>numeric, the sum of square residuals.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>numeric, the vector of residuals.</p>
</dd>
<dt><code>fit</code></dt><dd><p>numeric, the vector of fitted values.</p>
</dd>
<dt><code>pred</code></dt><dd><p>numeric, the vector of predicted values.</p>
</dd>
<dt><code>sev</code></dt><dd><p>matrix, local standard error of varying coefficients.</p>
</dd>
<dt><code>se</code></dt><dd><p>numeric, standard error of constant coefficients.</p>
</dd>
<dt><code>tS</code></dt><dd><p>numeric, Trace(S).</p>
</dd>
<dt><code>Shat,</code></dt><dd><p>hat matrix</p>
</dd>
<dt><code>R_k,</code></dt><dd><p>list of hat matrix by var</p>
</dd>
<dt><code>h_w</code></dt><dd><p>numeric, the bandwidth value for computing W, default 0.</p>
</dd>
<dt><code>kernel_w</code></dt><dd><p>the type of kernel for computing W, default NULL.</p>
</dd>
<dt><code>RMSE</code></dt><dd><p>numeric, Root Mean Square Error for Target Points.</p>
</dd>
<dt><code>RMSEtp</code></dt><dd><p>numeric, Root Mean Square Error for all Points.</p>
</dd>
<dt><code>CV</code></dt><dd><p>numeric, Leave One Out CV.</p>
</dd>
<dt><code>AIC</code></dt><dd><p>numeric,  Akaike Criteria.</p>
</dd>
<dt><code>AICc</code></dt><dd><p>numeric, Corrected Akaike Criteria.</p>
</dd>
<dt><code>AICctp</code></dt><dd><p>numeric, Corrected Akaike Criteria for TP</p>
</dd>
<dt><code>BIC</code></dt><dd><p>numeric, Bayesian Information Criteria.</p>
</dd>
<dt><code>R2</code></dt><dd><p>numeric, R2.</p>
</dd>
<dt><code>R2_adj</code></dt><dd><p>numeric, adjusted R2.</p>
</dd>
<dt><code>get_ts</code></dt><dd><p>logical, if trace of hat matrix Tr(S) should be stored.</p>
</dd>
<dt><code>NN</code></dt><dd><p>numeric, the maximum number of neighbors for weights computation</p>
</dd>
<dt><code>doMC</code></dt><dd><p>logical, parallel computation.</p>
</dd>
<dt><code>ncore</code></dt><dd><p>numeric, number of cores.</p>
</dd>
<dt><code>mycall</code></dt><dd><p>a call, the call of the model.</p>
</dd>
<dt><code>ctime</code></dt><dd><p>numeric, the computing times in seconds.</p>
</dd>
<dt><code>HRMSE</code></dt><dd><p>matrix, RMSE log.</p>
</dd>
<dt><code>HBETA</code></dt><dd><p>list, estimated BETA at each iteration.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>numeric, value of loglik.</p>
</dd>
<dt><code>G</code></dt><dd><p>list, list of neighboring index and distances (knn object from nabor package).</p>
</dd>
<dt><code>V</code></dt><dd><p>numeric, neighbors sequence for TDS.</p>
</dd>
<dt><code>Vt</code></dt><dd><p>numeric, neighbors sequence for TDS.</p>
</dd>
<dt><code>Z</code></dt><dd><p>numeric, time for GDT kernel type</p>
</dd>
<dt><code>TS</code></dt><dd><p>numeric, Diagonal of Hat Matrix</p>
</dd>
<dt><code>alpha</code></dt><dd><p>numeric, ratio for GDT kernels</p>
</dd>
<dt><code>theta</code></dt><dd><p>numeric, ratio for GDT kernels</p>
</dd>
</dl>

<hr>
<h2 id='modc'>modc is a set of models to correct approximation of hat matrix trace</h2><span id='topic+modc'></span>

<h3>Description</h3>

<p>modc is a set of models to correct approximation of hat matrix trace
</p>


<h3>Author(s)</h3>

<p>Ghislain Geniaux and Davide Martinetti <a href="mailto:ghislain.geniaux@inra.fr">ghislain.geniaux@inra.fr</a>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.regsciurbeco.2017.04.001">doi:10.1016/j.regsciurbeco.2017.04.001</a>
</p>

<hr>
<h2 id='multiscale_gwr'>multiscale_gwr
This function adapts the multiscale Geographically Weighted Regression (GWR)
methodology proposed by Fotheringam et al. in 2017, employing a backward
fitting procedure within the MGWRSAR subroutines. The consecutive bandwidth
optimizations are performed by minimizing the corrected Akaike criteria.</h2><span id='topic+multiscale_gwr'></span>

<h3>Description</h3>

<p>multiscale_gwr
This function adapts the multiscale Geographically Weighted Regression (GWR)
methodology proposed by Fotheringam et al. in 2017, employing a backward
fitting procedure within the MGWRSAR subroutines. The consecutive bandwidth
optimizations are performed by minimizing the corrected Akaike criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale_gwr(formula,data,coords,kernels='bisq',init='GWR',
maxiter=20,nstable=6,tolerance=0.000001,doMC=FALSE,ncore=1,HF=NULL,
H0=NULL,H2=NULL,Model=NULL,model=NULL,get_AICg=FALSE,verbose=FALSE,
control=list(SE=FALSE,adaptive=TRUE,NN=800,isgcv=FALSE,family=gaussian()))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale_gwr_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_data">data</code></td>
<td>
<p>A dataframe.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;), epanechnikov (&quot;epane&quot;)</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_init">init</code></td>
<td>
<p>starting model (lm or GWR)</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in the back-fitting procedure.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_nstable">nstable</code></td>
<td>
<p>required number of consecutive unchanged optimal bandwidth (by covariate) before leaving optimisation of bandwidth size, default 3.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_tolerance">tolerance</code></td>
<td>
<p>value to terminate the back-fitting iterations (ratio of change in RMSE)</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_domc">doMC</code></td>
<td>
<p>A boolean for Parallel computation, default FALSE.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_ncore">ncore</code></td>
<td>
<p>number of CPU cores for parallel computation, default 1.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_hf">HF</code></td>
<td>
<p>if available, a vector containing the optimal bandwidth parameters for each
covariate, default NULL.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_h0">H0</code></td>
<td>
<p>A bandwidth value for the starting GWR model, default NULL.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_h2">H2</code></td>
<td>
<p>A bandwidth temporal value for the starting GWR model, default NULL.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_model">Model</code></td>
<td>
<p>Type of Model.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_model">model</code></td>
<td>
<p>A previous model estimated using multiscale_gwr function, default NULL</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_get_aicg">get_AICg</code></td>
<td>
<p>Boolean, should Global AICc be estimated.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, verbose mode.</p>
</td></tr>
<tr><td><code id="multiscale_gwr_+3A_control">control</code></td>
<td>
<p>a list of extra control arguments, see MGWRSAR help.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return an object of class mgwrsar
</p>

<hr>
<h2 id='mydata'>mydata is a simulated data set of a mgwrsar model</h2><span id='topic+mydata'></span>

<h3>Description</h3>

<p>mydata is a simulated data set of a mgwrsar model
</p>


<h3>Format</h3>

<p>A data frames with 1000 rows 22 variables and a matrix of coordinates with two columns
</p>


<h3>Author(s)</h3>

<p>Ghislain Geniaux and Davide Martinetti <a href="mailto:ghislain.geniaux@inrae.fr">ghislain.geniaux@inrae.fr</a>
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1016/j.regsciurbeco.2017.04.001">doi:10.1016/j.regsciurbeco.2017.04.001</a>
</p>

<hr>
<h2 id='mydatasf'>mydataf is a Simple Feature object with real estate data in south of France.</h2><span id='topic+mydatasf'></span>

<h3>Description</h3>

<p>mydataf is a Simple Feature object with real estate data in south of France.
</p>


<h3>Format</h3>

<p>A sf object with 1403 rows, 5 columns
</p>


<h3>Author(s)</h3>

<p>Ghislain Geniaux <a href="mailto:ghislain.geniaux@inrea.fr">ghislain.geniaux@inrea.fr</a>
</p>


<h3>References</h3>

<p><a href="https://www.data.gouv.fr/fr/datasets/demandes-de-valeurs-foncieres/">https://www.data.gouv.fr/fr/datasets/demandes-de-valeurs-foncieres/</a>
</p>

<hr>
<h2 id='normW'>normW
row normalization of dgCMatrix</h2><span id='topic+normW'></span>

<h3>Description</h3>

<p>normW
row normalization of dgCMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normW(W)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normW_+3A_w">W</code></td>
<td>
<p>A dgCMatrix class matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row normalized dgCMatrix
</p>

<hr>
<h2 id='PhWY_C'>PhWY_C
to be documented</h2><span id='topic+PhWY_C'></span>

<h3>Description</h3>

<p>PhWY_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhWY_C(YY, XX, WW, Wi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhWY_C_+3A_yy">YY</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="PhWY_C_+3A_wi">Wi</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='plot_effect'>plot_effect
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.</h2><span id='topic+plot_effect'></span>

<h3>Description</h3>

<p>plot_effect
plot_effect is a function that plots the effect of a variable X_k with spatially varying coefficient, i.e X_k * Beta_k(u_i,v_i) for comparing the magnitude of effects of between variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_effect(model,sampling=TRUE,nsample=2000,nsample_max=5000,title='')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_effect_+3A_model">model</code></td>
<td>
<p>a model of mgwrsar class with some spatially varying coefficients.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_sampling">sampling</code></td>
<td>
<p>Bolean, if nrow(model@Betav)&gt; nsample_max a sample of size nsample is randomly selected, default TRUE.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_nsample">nsample</code></td>
<td>
<p>integer,  size of the sample if sampling is TRUE, default 2000.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_nsample_max">nsample_max</code></td>
<td>
<p>integer, size max to engage sampling if sampling is TRUE, default 5000.</p>
</td></tr>
<tr><td><code id="plot_effect_+3A_title">title</code></td>
<td>
<p>a title for the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 ## loading data example
 data(mydata)
 coords=as.matrix(mydata[,c("x","y")])
 ## Creating a spatial weight matrix (sparce dgCMatrix)
 ## of 8 nearest neighbors with 0 in diagonal
 model_GWR0&lt;-MGWRSAR(formula = 'Y_gwr~X1+X2+X3', data = mydata,coords=coords,
 fixed_vars=NULL,kernels=c('gauss'),H=0.13, Model = 'GWR',control=list(SE=TRUE))
 plot_effect(model_GWR0)

</code></pre>

<hr>
<h2 id='plot+2Cmgwrsar+2Cmissing-method'>Plot method for mgwrsar model</h2><span id='topic+plot+2Cmgwrsar+2Cmissing-method'></span><span id='topic+plot.mgwrsar'></span>

<h3>Description</h3>

<p>Plot method for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar,missing'
plot(
  x,
  y,
  type = "coef",
  var = NULL,
  crs = NULL,
  mypalette = "RdYlGn",
  opacity = 0.5,
  fopacity = 0.5,
  nbins = 8,
  radius = 500,
  mytile = "Stadia.StamenTonerBackground",
  myzoom = 8,
  myresolution = 150,
  LayersControl = TRUE,
  myzoomControl = TRUE,
  mytile2 = NULL,
  ScaleBar = NULL,
  ScaleBarOptions = list(maxWidth = 200, metric = TRUE, imperial = FALSE, updateWhenIdle
    = TRUE),
  MyLegendTitle = NULL,
  lopacity = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_type">type</code></td>
<td>
<p>default 'coef', for plotting the value of the coefficients. Local t-Student could also be plot using 't_coef', residuals using 'residuals' and fitted using 'fitted'.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_var">var</code></td>
<td>
<p>Names of variable to plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_crs">crs</code></td>
<td>
<p>A CRS projection.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_mypalette">mypalette</code></td>
<td>
<p>A leaflet palette.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_opacity">opacity</code></td>
<td>
<p>Opacity of border color.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_fopacity">fopacity</code></td>
<td>
<p>Opacity of fill color.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_nbins">nbins</code></td>
<td>
<p>nbins.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_radius">radius</code></td>
<td>
<p>radius of circle for plot of points.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_mytile">mytile</code></td>
<td>
<p>tile 1.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_myzoom">myzoom</code></td>
<td>
<p>level of zoom for tile 1.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_myresolution">myresolution</code></td>
<td>
<p>resolution for tile 1.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_layerscontrol">LayersControl</code></td>
<td>
<p>layers contols.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_myzoomcontrol">myzoomControl</code></td>
<td>
<p>zoem control.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_mytile2">mytile2</code></td>
<td>
<p>tile 2.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_scalebar">ScaleBar</code></td>
<td>
<p>ScaleBar.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_scalebaroptions">ScaleBarOptions</code></td>
<td>
<p>options for ScaleBar.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_mylegendtitle">MyLegendTitle</code></td>
<td>
<p>Legend title.</p>
</td></tr>
<tr><td><code id="plot+2B2Cmgwrsar+2B2Cmissing-method_+3A_lopacity">lopacity</code></td>
<td>
<p>opacity for legend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Interactive Web Maps with local parameters plot and Open Street Map layer.
</p>

<hr>
<h2 id='predict+2Cmgwrsar-method'>predict method for mgwrsar model</h2><span id='topic+predict+2Cmgwrsar-method'></span>

<h3>Description</h3>

<p>predict method for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar'
predict(
  object,
  newdata,
  newdata_coords,
  W = NULL,
  type = "BPN",
  h_w = 100,
  kernel_w = "rectangle",
  maxobs = 4000,
  beta_proj = FALSE,
  method_pred = "TP",
  k_extra = 8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_object">object</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_newdata">newdata</code></td>
<td>
<p>a matrix or data.frame of new data.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_newdata_coords">newdata_coords</code></td>
<td>
<p>a matrix of new coordinates, and eventually other variables if a General Kernel Product is used.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_w">W</code></td>
<td>
<p>the spatial weight matrix for models with  spatial autocorrelation.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_type">type</code></td>
<td>
<p>Type for BLUP estimator, default &quot;BPN&quot;. If NULL use predictions without spatial bias correction.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_h_w">h_w</code></td>
<td>
<p>A bandwidth value for the spatial weight matrix</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_kernel_w">kernel_w</code></td>
<td>
<p>kernel type for the spatial weight matrix. Possible types:
rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;), tricube (&quot;tcub&quot;),
epanechnikov (&quot;epane&quot;), gaussian (&quot;gauss&quot;)) .</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_maxobs">maxobs</code></td>
<td>
<p>maximum number of observations for exact calculation of solve(I- rho*W), default maxobs=4000.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_beta_proj">beta_proj</code></td>
<td>
<p>A boolean, if TRUE the function then return a two elements list(Y_predicted,Beta_proj_out)</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_method_pred">method_pred</code></td>
<td>
<p>If method_pred = 'TP' (default) prediction is done by recomputing a MGWRSAR model
with new-data as target points, else if method_pred in ('tWtp_model','model','shepard') a matrix
for projecting estimated betas is used (see details).</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_k_extra">k_extra</code></td>
<td>
<p>number of neighboors for local parameter extrapolation if shepard kernel is used, default 8.</p>
</td></tr>
<tr><td><code id="predict+2B2Cmgwrsar-method_+3A_...">...</code></td>
<td>
<p>predict parameters forwarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if method_pred ='tWtp_model',  the weighting matrix for prediction is
based on the expected weights of outsample data if they were had been added to
insample data to estimate the corresponding MGWRSAR (see Geniaux 2022 for
further detail), if method_pred ='shepard'a shepard kernel with k_extra neighbours (default 8) is used and if method_pred='kernel_model' the same kernel
and number of neighbors as for computing the MGWRSAR model is used.
</p>


<h3>Value</h3>

<p>A vector of predictions if beta_proj is FALSE or a list with a vector named Y_predicted and a matrix named Beta_proj_out.
</p>
<p>A vector of predictions.
</p>

<hr>
<h2 id='Proj_C'>Proj_C
to be documented</h2><span id='topic+Proj_C'></span>

<h3>Description</h3>

<p>Proj_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Proj_C(HH, XX)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Proj_C_+3A_hh">HH</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Proj_C_+3A_xx">XX</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='QRcpp2_C'>QRcpp2_C
to be documented</h2><span id='topic+QRcpp2_C'></span>

<h3>Description</h3>

<p>QRcpp2_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QRcpp2_C(AA, bb, cc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QRcpp2_C_+3A_aa">AA</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="QRcpp2_C_+3A_bb">bb</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="QRcpp2_C_+3A_cc">cc</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='residuals+2Cmgwrsar-method'>residuals for mgwrsar model</h2><span id='topic+residuals+2Cmgwrsar-method'></span>

<h3>Description</h3>

<p>residuals for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals+2B2Cmgwrsar-method_+3A_object">object</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="residuals+2B2Cmgwrsar-method_+3A_...">...</code></td>
<td>
<p>residuals parameters forwarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals.
</p>

<hr>
<h2 id='simu_multiscale'>Estimation of linear and local linear model with spatial
autocorrelation model (mgwrsar).</h2><span id='topic+simu_multiscale'></span>

<h3>Description</h3>

<p>The simu_multiscale function is designed for simulating a spatially varying
coefficient DGP (Data Generating Process) based on formulations proposed by
Fotheringam et al. (2017), Gao et al. (2021), or Geniaux (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_multiscale(n=1000,myseed=1,type='GG2024',constant=NULL,
nuls=NULL,config_beta='default',config_snr=0.7,config_eps='normal',
ratiotime=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simu_multiscale_+3A_n">n</code></td>
<td>
<p>An integer number of observations</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_myseed">myseed</code></td>
<td>
<p>An integer seed used for the simulation.</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_type">type</code></td>
<td>
<p>Type of DGP used 'FT2017', 'Gao2021' or 'GG2024', default 'GG2024'.</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_constant">constant</code></td>
<td>
<p>A boolean parameter indicating whether the intercept term
should be spatially varying (TRUE) or not (FALSE).</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_nuls">nuls</code></td>
<td>
<p>A vector of null parameters, default NULL</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_config_beta">config_beta</code></td>
<td>
<p>name of the type of spatial pattern of Beta coefficients</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_config_snr">config_snr</code></td>
<td>
<p>a value of signal noise ratio</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_config_eps">config_eps</code></td>
<td>
<p>name of the distribution of error ('normal','unif' or 'Chi2')</p>
</td></tr>
<tr><td><code id="simu_multiscale_+3A_ratiotime">ratiotime</code></td>
<td>
<p>multiplicating factor, for spacetime DGP.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with simulated data ('mydata') and coords ('coords')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 library(mgwrsar)
 library(ggplot2)
 library(gridExtra)
 library(grid)
 simu=simu_multiscale(1000)
 mydata=simu$mydata
 coords=simu$coords
 p1&lt;-ggplot(mydata,aes(x,y,col=Beta1))+geom_point() +scale_color_viridis_c()
 p2&lt;-ggplot(mydata,aes(x,y,col=Beta2))+geom_point() +scale_color_viridis_c()
 p3&lt;-ggplot(mydata,aes(x,y,col=Beta3))+geom_point() +scale_color_viridis_c()
 p4&lt;-ggplot(mydata,aes(x,y,col=Beta4))+geom_point() +scale_color_viridis_c()
 grid.arrange(p1,p2,p3,p4,nrow=2,ncol=2, top = textGrob("DGP Geniaux (2024)"
 ,gp=gpar(fontsize=20,font=3)))

</code></pre>

<hr>
<h2 id='Sl_C'>Sl_C
to be documented</h2><span id='topic+Sl_C'></span>

<h3>Description</h3>

<p>Sl_C
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sl_C(llambda, WW, iinv, aapprox)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sl_C_+3A_llambda">llambda</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_ww">WW</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_iinv">iinv</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="Sl_C_+3A_aapprox">aapprox</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='summary_Matrix'>summary_Matrix
to be documented</h2><span id='topic+summary_Matrix'></span>

<h3>Description</h3>

<p>summary_Matrix
to be documented
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_Matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_Matrix_+3A_object">object</code></td>
<td>
<p>to be documented</p>
</td></tr>
<tr><td><code id="summary_Matrix_+3A_...">...</code></td>
<td>
<p>to be documented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>to be documented
</p>

<hr>
<h2 id='summary+2Cmgwrsar-method'>summary for mgwrsar model</h2><span id='topic+summary+2Cmgwrsar-method'></span>

<h3>Description</h3>

<p>summary for mgwrsar model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mgwrsar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary+2B2Cmgwrsar-method_+3A_object">object</code></td>
<td>
<p>A model of class <code><a href="#topic+mgwrsar-class">mgwrsar-class</a></code>.</p>
</td></tr>
<tr><td><code id="summary+2B2Cmgwrsar-method_+3A_...">...</code></td>
<td>
<p>summary parameters forwarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary object.
</p>

<hr>
<h2 id='tds_mgwr'>Top-Down Scaling approach of multiscale GWR</h2><span id='topic+tds_mgwr'></span>

<h3>Description</h3>

<p>This function performs a multiscale Geographically Weighted Regression
(GWR) using a top-down scaling approach, adjusting GWR coefficients with
a progressively decreasing bandwidth as long as the AICc criterion improves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tds_mgwr(formula,data,coords,Model='tds_mgwr',kernels='triangle',
fixed_vars=NULL,H2=NULL,control_tds=list(nns=30,get_AIC=FALSE),
control=list(adaptive=TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tds_mgwr_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_data">data</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_coords">coords</code></td>
<td>
<p>default NULL, a dataframe or a matrix with coordinates</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_model">Model</code></td>
<td>
<p>character containing the type of model: Possible values are
&quot;tds_mgwr&quot; and &quot;atds_mgwr&quot;, See Details for more explanation.</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_kernels">kernels</code></td>
<td>
<p>A vector containing the kernel types. Possible types:
triangle (&quot;triangle&quot;), rectangle (&quot;rectangle&quot;), bisquare (&quot;bisq&quot;),
tricube (&quot;tcub&quot;), gaussian (&quot;gauss&quot;), epanechnikov (&quot;epane&quot;).</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_fixed_vars">fixed_vars</code></td>
<td>
<p>a vector with the names of spatiallay constant
coefficient for mixed model. All other variables present in formula
are supposed to be spatially varying. If empty or NULL (default),
all variables in formula are supposed to be spatially varying.</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_h2">H2</code></td>
<td>
<p>A scalar or vector of time bandwidths.</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_control_tds">control_tds</code></td>
<td>
<p>list of extra control arguments for tds_mgwr models</p>
</td></tr>
<tr><td><code id="tds_mgwr_+3A_control">control</code></td>
<td>
<p>list of extra control arguments for MGWRSAR wrapper</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>nns</dt><dd><p>Length of the sequence of decreasing bandwidth. Should be
between 20 and 100, default 30</p>
</dd>
<dt>get_AIC</dt><dd><p>Boolean, if the Global AICc using Yu et al 2019 should be
computed. Required if the second stage 'atds_mgwr' has to be estimated.
default FALSE</p>
</dd>
<dt>init_model</dt><dd><p>Starting model, 'GWR' or 'OLS', 'default OLS'.</p>
</dd>
<dt>model_stage1</dt><dd><p>If model='tds_mgwr', model_stage1 can be used as a
starting model (either a GWR model or a preious tds_mgwr model).
For model='atds_mgwr, the user can specified an tds_mgwr
model already computed with get_AIC=TRUE. default NULL.</p>
</dd>
<dt>doMC</dt><dd><p>Parallel computation, default FALSE.</p>
</dd>
<dt>ncore</dt><dd><p>number of CPU core for parallel computation, default 1</p>
</dd>
<dt>tol</dt><dd><p>Tolerance for stopping criteria, default 0.0001</p>
</dd>
<dt>nrounds</dt><dd><p>Number of nrounds for 'atds_mgwr' model. Default 3.</p>
</dd>
<dt>verbose</dt><dd><p>verbose mode, default FALSE.</p>
</dd>
<dt>V</dt><dd><p>A vector of decreasing bandwidths given by the user, default NULL</p>
</dd>
<dt>first_nn</dt><dd><p>The value of the highest bandwidth for the sequence of
decreasing bandwidth, default NULL.</p>
</dd>
<dt>minv</dt><dd><p>The value of the smallest bandwidth for the sequence of
decreasing bandwidth, default number of covariates + 2 . </p>
</dd>
<dt>H</dt><dd><p>A vector of bandwidth, default NULL</p>
</dd>
</dl>


<dl>
<dt>Z</dt><dd><p>A matrix of variables for genralized kernel product, default NULL.</p>
</dd>
<dt>W</dt><dd><p>A row-standardized spatial weight matrix for Spatial
Aurocorrelation, default NULL.</p>
</dd>
<dt>type</dt><dd><p>Verbose mode, default FALSE.</p>
</dd>
<dt>adaptive</dt><dd><p>A vector of boolean to choose adaptive version for
each kernel.</p>
</dd>
<dt>kernel_w</dt><dd><p>The type of kernel for computing W, default NULL.</p>
</dd>
<dt>h_w</dt><dd><p>The bandwidth value for computing W, default 0.</p>
</dd>
<dt>Method</dt><dd><p>Estimation method for computing the models with Spatial
Dependence. '2SLS' or 'B2SLS', default '2SLS'.</p>
</dd>
<dt>TP</dt><dd><p>Avector of target points, default NULL.</p>
</dd>
<dt>doMC</dt><dd><p>Parallel computation, default FALSE. If TRUE and
control_tds$doMC is also TRUE, then control$doMC is set to FALSE.</p>
</dd>
<dt>ncore</dt><dd><p>Number of CPU core for parallel computation, default 1</p>
</dd>
<dt>isgcv</dt><dd><p>If TRUE, compute a LOOCV criteria, default FALSE.</p>
</dd>
<dt>isfgcv</dt><dd><p>If TRUE, simplify the computation of CV criteria
(remove or not i when using local instruments for model with lambda
spatially varying), default TRUE.</p>
</dd>
<dt>maxknn</dt><dd><p>When n &gt;NmaxDist, only the maxknn first neighbours are used
for distance compution, default 500.</p>
</dd>
<dt>NmaxDist</dt><dd><p>When n &gt;NmaxDist only the maxknn first neighbours are used
for distance compution, default 5000</p>
</dd>
<dt>verbose</dt><dd><p>Verbose mode, default FALSE.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>gwr_multiscale, MGWRSAR, bandwidths_mgwrsar, summary_mgwrsar.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
