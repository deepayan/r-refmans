<!DOCTYPE html><html><head><title>Help for package ROCSI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ROCSI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AUC'><p>AUC</p></a></li>
<li><a href='#beta2theta'><p>beta2theta</p></a></li>
<li><a href='#C.index'><p>C.index</p></a></li>
<li><a href='#cvfolds0'><p>cvfolds0</p></a></li>
<li><a href='#data.gen'><p>data.gen</p></a></li>
<li><a href='#grad.sub'><p>grad.sub</p></a></li>
<li><a href='#gradsqr'><p>gradsqr</p></a></li>
<li><a href='#hessAUC'><p>hessAUC</p></a></li>
<li><a href='#hessAUC.sub'><p>hessAUC.sub</p></a></li>
<li><a href='#HIC'><p>HIC</p></a></li>
<li><a href='#MClogit'><p>MClogit</p></a></li>
<li><a href='#pair.diff'><p>pair.diff</p></a></li>
<li><a href='#pair.diff.surv'><p>pair.diff.surv</p></a></li>
<li><a href='#ROCSI'><p>ROCSI</p></a></li>
<li><a href='#theta2beta'><p>theta2beta</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Receiver Operating Characteristic Based Signature Identification</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Optimal linear combination predictive signatures for maximizing the area between two Receiver Operating Characteristic (ROC) curves (treatment vs. control).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-23 22:41:30 UTC; huangxx13</td>
</tr>
<tr>
<td>Author:</td>
<td>Xin Huang [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xin Huang &lt;xin.huang@abbvie.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-24 09:12:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='AUC'>AUC</h2><span id='topic+AUC'></span>

<h3>Description</h3>

<p>Empirical AUC estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AUC(outcome, predict)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AUC_+3A_outcome">outcome</code></td>
<td>
<p>binary outcome (1: desired outcome; 0: otherwise)</p>
</td></tr>
<tr><td><code id="AUC_+3A_predict">predict</code></td>
<td>
<p>prediction score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for AUC when input is X and Y.
</p>


<h3>Value</h3>

<p>a numeric value of empirical estimation of area under the ROC curves
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='beta2theta'>beta2theta</h2><span id='topic+beta2theta'></span>

<h3>Description</h3>

<p>Function to translate beta into theta, the n-sphere constrain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta2theta(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta2theta_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to translate beta into theta, the n-sphere constrain
</p>


<h3>Value</h3>

<p>a numeric vector for theta (dimension-1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='C.index'>C.index</h2><span id='topic+C.index'></span>

<h3>Description</h3>

<p>Empirical c-index estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C.index(yvar, score, censorvar, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C.index_+3A_yvar">yvar</code></td>
<td>
<p>column name for observed time</p>
</td></tr>
<tr><td><code id="C.index_+3A_score">score</code></td>
<td>
<p>column name for marker value</p>
</td></tr>
<tr><td><code id="C.index_+3A_censorvar">censorvar</code></td>
<td>
<p>column name for censor (1 is event, 0 is censored)</p>
</td></tr>
<tr><td><code id="C.index_+3A_data">data</code></td>
<td>
<p>input data matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for c-index when input is X and Y.
</p>


<h3>Value</h3>

<p>a numeric value of empirical estimation of c-index
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='cvfolds0'>cvfolds0</h2><span id='topic+cvfolds0'></span>

<h3>Description</h3>

<p>internal function for generating CV fold index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvfolds0(X, Y, idx, nfolds = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvfolds0_+3A_x">X</code></td>
<td>
<p>marker matrix for non-responders</p>
</td></tr>
<tr><td><code id="cvfolds0_+3A_y">Y</code></td>
<td>
<p>marker matrix for responders</p>
</td></tr>
<tr><td><code id="cvfolds0_+3A_idx">idx</code></td>
<td>
<p>m*n by 2 matrix for row index of marker matrix, first column is row index in X; second column is for Y</p>
</td></tr>
<tr><td><code id="cvfolds0_+3A_nfolds">nfolds</code></td>
<td>
<p>the cross-validation folds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for generate CV fold index
</p>


<h3>Value</h3>

<p>a vector containing CV fold index for each row in Z
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='data.gen'>data.gen</h2><span id='topic+data.gen'></span>

<h3>Description</h3>

<p>Function for simulated data generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.gen(
  n,
  k,
  prevalence = sqrt(0.5),
  prog.eff = 1,
  sig2,
  y.sig2,
  rho,
  rhos.bt.real,
  a.constent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen_+3A_n">n</code></td>
<td>
<p>Total sample size</p>
</td></tr>
<tr><td><code id="data.gen_+3A_k">k</code></td>
<td>
<p>Number of markers</p>
</td></tr>
<tr><td><code id="data.gen_+3A_prevalence">prevalence</code></td>
<td>
<p>prevalence of predictive biomarkers with values above the cutoff</p>
</td></tr>
<tr><td><code id="data.gen_+3A_prog.eff">prog.eff</code></td>
<td>
<p>effect size <code class="reqn">beta</code> for prognostic biomarker</p>
</td></tr>
<tr><td><code id="data.gen_+3A_sig2">sig2</code></td>
<td>
<p>standard deviation of each marker</p>
</td></tr>
<tr><td><code id="data.gen_+3A_y.sig2">y.sig2</code></td>
<td>
<p>Standard Deviation of the error term in the linear component</p>
</td></tr>
<tr><td><code id="data.gen_+3A_rho">rho</code></td>
<td>
<p>rho*sig2 is the entries for covariance matrix between pairs of different k markers</p>
</td></tr>
<tr><td><code id="data.gen_+3A_rhos.bt.real">rhos.bt.real</code></td>
<td>
<p>correlation between each prognostic and predictive markers</p>
</td></tr>
<tr><td><code id="data.gen_+3A_a.constent">a.constent</code></td>
<td>
<p>a constant is set such that there is no overall treatment effect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for simulated data generation
</p>


<h3>Value</h3>

<p>A list of simulated clinical trial data with heterogeneous prognostic and predictive biomarkers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500
k &lt;- 10
prevalence &lt;- sqrt(0.5)
rho&lt;-0.2
sig2 &lt;- 2
rhos.bt.real &lt;- c(0, rep(0.1, (k-3)))*sig2
y.sig2 &lt;- 1
prog.eff &lt;- 0.5
effect.size &lt;- 1
a.constent &lt;- effect.size/(2*(1-prevalence))
ObsData &lt;- data.gen(n=n, k=k, prevalence=prevalence, prog.eff=prog.eff,
                    sig2=sig2, y.sig2=y.sig2, rho=rho,
                    rhos.bt.real=rhos.bt.real, a.constent=a.constent)
</code></pre>

<hr>
<h2 id='grad.sub'>grad.sub</h2><span id='topic+grad.sub'></span>

<h3>Description</h3>

<p>Internal function of grad_square in the GCV
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad.sub(z, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grad.sub_+3A_z">z</code></td>
<td>
<p>(m x n) x p data matrix as prepared for ROCSI</p>
</td></tr>
<tr><td><code id="grad.sub_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function of grad_square in the GCV
</p>


<h3>Value</h3>

<p>grad_square in the GCV
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='gradsqr'>gradsqr</h2><span id='topic+gradsqr'></span>

<h3>Description</h3>

<p>Internal function for HIC calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradsqr(beta, Z0, index, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradsqr_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
<tr><td><code id="gradsqr_+3A_z0">Z0</code></td>
<td>
<p>(m x n) x p Z matrix as prepared for ROCSI</p>
</td></tr>
<tr><td><code id="gradsqr_+3A_index">index</code></td>
<td>
<p>m*n by 2 matrix  for the subindex for the pair difference in Z</p>
</td></tr>
<tr><td><code id="gradsqr_+3A_w">w</code></td>
<td>
<p>a vector of weights Z (can be used for inverse probability weighting for missing data, default is 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function for HIC calculation
</p>


<h3>Value</h3>

<p>gradient square for the GCV.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='hessAUC'>hessAUC</h2><span id='topic+hessAUC'></span>

<h3>Description</h3>

<p>function for Hessian matrix of AUC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessAUC(beta, Z, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessAUC_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
<tr><td><code id="hessAUC_+3A_z">Z</code></td>
<td>
<p>(m x n) x p data matrix as prepared for ROCSI</p>
</td></tr>
<tr><td><code id="hessAUC_+3A_w">w</code></td>
<td>
<p>a vector of weights Z (can be used for inverse probability weighting for missing data, default is 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function for Hessian matrix of AUC
</p>


<h3>Value</h3>

<p>Hessian matrix of AUC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='hessAUC.sub'>hessAUC.sub</h2><span id='topic+hessAUC.sub'></span>

<h3>Description</h3>

<p>Internal function for hessAUC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessAUC.sub(z, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessAUC.sub_+3A_z">z</code></td>
<td>
<p>(m x n) x p data matrix as prepared for ROCSI</p>
</td></tr>
<tr><td><code id="hessAUC.sub_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function for hessAUC
</p>


<h3>Value</h3>

<p>Hessian matrix components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='HIC'>HIC</h2><span id='topic+HIC'></span>

<h3>Description</h3>

<p>function for HIC calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HIC(beta, Z, index, w = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HIC_+3A_beta">beta</code></td>
<td>
<p>estimates of coefficient beta</p>
</td></tr>
<tr><td><code id="HIC_+3A_z">Z</code></td>
<td>
<p>matrix prepared for ROCSI</p>
</td></tr>
<tr><td><code id="HIC_+3A_index">index</code></td>
<td>
<p>m*n by 2 matrix  for the subindex for the pair difference in Z</p>
</td></tr>
<tr><td><code id="HIC_+3A_w">w</code></td>
<td>
<p>a vector of weights Z (can be used for inverse probability weighting for missing data, default is 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for HIC calculation
</p>


<h3>Value</h3>

<p>A numeric value with corresponding HIC
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='MClogit'>MClogit</h2><span id='topic+MClogit'></span>

<h3>Description</h3>

<p>function for modified covariate methods based on glmnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MClogit(
  dataset,
  yvar,
  xvars,
  trtvar,
  cvar = NULL,
  nfolds = 5,
  type = "binary",
  newx = NULL,
  bestsub = "lambda.1se",
  type.measure = "auc"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MClogit_+3A_dataset">dataset</code></td>
<td>
<p>data matrix for training dataset</p>
</td></tr>
<tr><td><code id="MClogit_+3A_yvar">yvar</code></td>
<td>
<p>column name for outcome</p>
</td></tr>
<tr><td><code id="MClogit_+3A_xvars">xvars</code></td>
<td>
<p>a string vector of column names for input markers</p>
</td></tr>
<tr><td><code id="MClogit_+3A_trtvar">trtvar</code></td>
<td>
<p>column name for treatment (the column should contain binary code with 1 being treatment and 0 being control)</p>
</td></tr>
<tr><td><code id="MClogit_+3A_cvar">cvar</code></td>
<td>
<p>column name for censor (the column should contain binary code with 1 being event and 0 being censored)</p>
</td></tr>
<tr><td><code id="MClogit_+3A_nfolds">nfolds</code></td>
<td>
<p>n fold CV used for cv.glmnet</p>
</td></tr>
<tr><td><code id="MClogit_+3A_type">type</code></td>
<td>
<p>outcome type (&quot;binary&quot; for binary outcome and &quot;survival&quot; for time-to-event outcome)</p>
</td></tr>
<tr><td><code id="MClogit_+3A_newx">newx</code></td>
<td>
<p>data matrix for testing dataset X</p>
</td></tr>
<tr><td><code id="MClogit_+3A_bestsub">bestsub</code></td>
<td>
<p>criteria for best lambda, used by glmnet</p>
</td></tr>
<tr><td><code id="MClogit_+3A_type.measure">type.measure</code></td>
<td>
<p>type of measure used by glmnet</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function for ROCSI
</p>


<h3>Value</h3>

<p>A list with ROCSI output
</p>

<dl>
<dt>x.logit</dt><dd><p>final beta estimated from MClogit</p>
</dd>
<dt>predScore</dt><dd><p>a data.frame of testing data and its predictive signature scores (based on beta.aABC) for each subjects</p>
</dd>
<dt>abc</dt><dd><p>ABC in testing dataset based on optimal beta</p>
</dd>
<dt>fit.cv</dt><dd><p>the fitted glmnet object</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
k &lt;- 5
prevalence &lt;- sqrt(0.5)
rho&lt;-0.2
sig2 &lt;- 2
rhos.bt.real &lt;- c(0, rep(0.1, (k-3)))*sig2
y.sig2 &lt;- 1
yvar="y.binary"
xvars=paste("x", c(1:k), sep="")
trtvar="treatment"
prog.eff &lt;- 0.5
effect.size &lt;- 1
a.constent &lt;- effect.size/(2*(1-prevalence))
ObsData &lt;- data.gen(n=n, k=k, prevalence=prevalence, prog.eff=prog.eff,
                    sig2=sig2, y.sig2=y.sig2, rho=rho,
                    rhos.bt.real=rhos.bt.real, a.constent=a.constent)
TestData &lt;- data.gen(n=n, k=k, prevalence=prevalence, prog.eff=prog.eff,
                     sig2=sig2, y.sig2=y.sig2, rho=rho,
                     rhos.bt.real=rhos.bt.real, a.constent=a.constent)
bst.mod &lt;- MClogit(dataset=ObsData$data, yvar=yvar, xvars=xvars,
trtvar=trtvar, nfolds = 5, newx=TestData$data,
type="binary", bestsub="lambda.1se")
bst.mod$abc
bst.mod$x.logit[-1,1]
</code></pre>

<hr>
<h2 id='pair.diff'>pair.diff</h2><span id='topic+pair.diff'></span>

<h3>Description</h3>

<p>internal function for generating Z matrix (binary endpoint)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.diff(X, Y, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.diff_+3A_x">X</code></td>
<td>
<p>marker matrix for non-responders</p>
</td></tr>
<tr><td><code id="pair.diff_+3A_y">Y</code></td>
<td>
<p>marker matrix for responders</p>
</td></tr>
<tr><td><code id="pair.diff_+3A_a">A</code></td>
<td>
<p>Treatment arm indicator (1 is treatment, 0 is control)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for generate Z matrix for binary endpoint
</p>


<h3>Value</h3>

<p>A list of prepared data input for ROCSI
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='pair.diff.surv'>pair.diff.surv</h2><span id='topic+pair.diff.surv'></span>

<h3>Description</h3>

<p>internal function for generating Z matrix (time-to-event endpoint)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.diff.surv(X, Y, A, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.diff.surv_+3A_x">X</code></td>
<td>
<p>marker matrix</p>
</td></tr>
<tr><td><code id="pair.diff.surv_+3A_y">Y</code></td>
<td>
<p>a vector for observed time</p>
</td></tr>
<tr><td><code id="pair.diff.surv_+3A_a">A</code></td>
<td>
<p>a vector for Treatment arm indicator (1 is treatment, 0 is control)</p>
</td></tr>
<tr><td><code id="pair.diff.surv_+3A_c">C</code></td>
<td>
<p>a vector for censor (1 is event, 0 is censored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function for generate Z matrix for time-to-event endpoint
</p>


<h3>Value</h3>

<p>A list of prepared data input for ROCSI
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

<hr>
<h2 id='ROCSI'>ROCSI</h2><span id='topic+ROCSI'></span>

<h3>Description</h3>

<p>function for ROCSI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCSI(
  Dtrain,
  Dtest = NULL,
  yvar,
  xvars,
  trtvar,
  cvar = NULL,
  nfolds = 5,
  type = "binary"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ROCSI_+3A_dtrain">Dtrain</code></td>
<td>
<p>data matrix for training dataset</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_dtest">Dtest</code></td>
<td>
<p>optional data matrix for testing dataset</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_yvar">yvar</code></td>
<td>
<p>column name for outcome</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_xvars">xvars</code></td>
<td>
<p>a string vector of column names for input markers</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_trtvar">trtvar</code></td>
<td>
<p>column name for treatment (the column should contain binary code with 1 being treatment and 0 being control)</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_cvar">cvar</code></td>
<td>
<p>column name for censor (the column should contain binary code with 1 being event and 0 being censored)</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_nfolds">nfolds</code></td>
<td>
<p>n fold CV used for cv.glmnet</p>
</td></tr>
<tr><td><code id="ROCSI_+3A_type">type</code></td>
<td>
<p>outcome type (&quot;binary&quot; for binary outcome and &quot;survival&quot; for time-to-event outcome)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function for ROCSI
</p>


<h3>Value</h3>

<p>A list with ROCSI output
</p>

<dl>
<dt>beta.aABC</dt><dd><p>final beta estimated from ROCSI based on <code class="reqn">ABC^{(acv)}</code></p>
</dd>
<dt>beta.1se</dt><dd><p>final beta estimated from lambda.1se based on nfold CV</p>
</dd>
<dt>lambda.aABC</dt><dd><p>optimal lambda selected by optimizing <code class="reqn">ABC^{(acv)}</code></p>
</dd>
<dt>fit.cv</dt><dd><p>fitted cv.glmnet model</p>
</dd>
<dt>log</dt><dd><p>log matrix of all lambdas and ABCs</p>
</dd>
<dt>abc.test</dt><dd><p>ABC in testing dataset based on optimal beta</p>
</dd>
<dt>abc.test1se</dt><dd><p>ABC in testing dataset based on 1se beta</p>
</dd>
<dt>predScore</dt><dd><p>a data.frame of testing data and its predictive signature scores (based on beta.aABC) for each subjects</p>
</dd>
<dt>predScore.1se</dt><dd><p>a data.frame of testing data and its predictive signature scores (based on beta.1se) for each subjects</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
k &lt;- 5
prevalence &lt;- sqrt(0.5)
rho&lt;-0.2
sig2 &lt;- 2
rhos.bt.real &lt;- c(0, rep(0.1, (k-3)))*sig2
y.sig2 &lt;- 1
yvar="y.binary"
xvars=paste("x", c(1:k), sep="")
trtvar="treatment"
prog.eff &lt;- 0.5
effect.size &lt;- 1
a.constent &lt;- effect.size/(2*(1-prevalence))
ObsData &lt;- data.gen(n=n, k=k, prevalence=prevalence, prog.eff=prog.eff,
                    sig2=sig2, y.sig2=y.sig2, rho=rho,
                    rhos.bt.real=rhos.bt.real, a.constent=a.constent)
TestData &lt;- data.gen(n=n, k=k, prevalence=prevalence, prog.eff=prog.eff,
                     sig2=sig2, y.sig2=y.sig2, rho=rho,
                     rhos.bt.real=rhos.bt.real, a.constent=a.constent)
bst.aabc &lt;- ROCSI(Dtrain=ObsData$data, Dtest = TestData$data, yvar=yvar,
xvars=xvars, trtvar=trtvar, cvar=NULL, nfolds=5, type="binary")
bst.aabc$beta.aABC
bst.aabc$log
bst.aabc$abc.test
bst.aabc$beta.1se
bst.aabc$abc.test1se
</code></pre>

<hr>
<h2 id='theta2beta'>theta2beta</h2><span id='topic+theta2beta'></span>

<h3>Description</h3>

<p>Function to translate theta into beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2beta(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta2beta_+3A_theta">theta</code></td>
<td>
<p>n-sphere coordination</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to translate beta into theta, the n-sphere constrain
</p>


<h3>Value</h3>

<p>a numeric vector for beta (dimension+1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no run
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
