<!DOCTYPE html><html lang="en"><head><title>Help for package sommer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sommer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A.mat'>
<p>Additive relationship matrix</p></a></li>
<li><a href='#add.diallel.vars'><p>add.diallel.vars</p></a></li>
<li><a href='#adiag1'><p>Binds arrays corner-to-corner</p></a></li>
<li><a href='#AI'><p>Average Information Algorithm</p></a></li>
<li><a href='#anova.mmec'><p>anova form a GLMM fitted with mmec</p></a></li>
<li><a href='#anova.mmer'><p>anova form a GLMM fitted with mmer</p></a></li>
<li><a href='#AR1'>
<p>Autocorrelation matrix of order 1.</p></a></li>
<li><a href='#ARMA'>
<p>Autocorrelation Moving average.</p></a></li>
<li><a href='#atc'><p>atc covariance structure</p></a></li>
<li><a href='#atcg1234'>
<p>Letter to number converter</p></a></li>
<li><a href='#atcg1234BackTransform'>
<p>Letter to number converter</p></a></li>
<li><a href='#atr'><p>atr covariance structure</p></a></li>
<li><a href='#bathy.colors'><p>Generate a sequence of colors for plotting bathymetric data.</p></a></li>
<li><a href='#bbasis'><p>Function for creating B-spline basis functions (Eilers &amp; Marx, 2010)</p></a></li>
<li><a href='#bivariateRun'><p>bivariateRun functionality</p></a></li>
<li><a href='#build.HMM'>
<p>Build a hybrid marker matrix using parental genotypes from inbred individuals</p></a></li>
<li><a href='#coef.mmec'><p>coef form a GLMM fitted with mmec</p></a></li>
<li><a href='#coef.mmer'><p>coef form a GLMM fitted with mmer</p></a></li>
<li><a href='#corImputation'><p>Imputing a matrix using correlations</p></a></li>
<li><a href='#covc'><p>covariance between random effects</p></a></li>
<li><a href='#CS'>
<p>Compound symmetry matrix</p></a></li>
<li><a href='#csc'><p>customized covariance structure</p></a></li>
<li><a href='#csr'><p>customized covariance structure</p></a></li>
<li><a href='#D.mat'>
<p>Dominance relationship matrix</p></a></li>
<li><a href='#dfToMatrix'><p>data frame to matrix</p></a></li>
<li><a href='#dsc'><p>diagonal covariance structure</p></a></li>
<li><a href='#dsr'><p>diagonal covariance structure</p></a></li>
<li><a href='#DT_augment'>
<p>DT_augment design example.</p></a></li>
<li><a href='#DT_btdata'>
<p>Blue Tit Data for a Quantitative Genetic Experiment</p></a></li>
<li><a href='#DT_cornhybrids'>
<p>Corn crosses and markers</p></a></li>
<li><a href='#DT_cpdata'>
<p>Genotypic and Phenotypic data for a CP population</p></a></li>
<li><a href='#DT_example'>
<p>Broad sense heritability calculation.</p></a></li>
<li><a href='#DT_expdesigns'>
<p>Data for different experimental designs</p></a></li>
<li><a href='#DT_fulldiallel'>
<p>Full diallel data for corn hybrids</p></a></li>
<li><a href='#DT_gryphon'>
<p>Gryphon data from the Journal of Animal Ecology</p></a></li>
<li><a href='#DT_h2'>
<p>Broad sense heritability calculation.</p></a></li>
<li><a href='#DT_halfdiallel'>
<p>half diallel data for corn hybrids</p></a></li>
<li><a href='#DT_ige'>
<p>Data to fit indirect genetic effects.</p></a></li>
<li><a href='#DT_legendre'>
<p>Simulated data for random regression</p></a></li>
<li><a href='#DT_mohring'>
<p>Full diallel data for corn hybrids</p></a></li>
<li><a href='#DT_polyploid'>
<p>Genotypic and Phenotypic data for a potato polyploid population</p></a></li>
<li><a href='#DT_rice'><p>Rice lines dataset</p></a></li>
<li><a href='#DT_sleepstudy'>
<p>Reaction times in a sleep deprivation study</p></a></li>
<li><a href='#DT_technow'>
<p>Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)</p></a></li>
<li><a href='#DT_wheat'><p>wheat lines dataset</p></a></li>
<li><a href='#DT_yatesoats'>
<p>Yield of oats in a split-block experiment</p></a></li>
<li><a href='#E.mat'>
<p>Epistatic relationship matrix</p></a></li>
<li><a href='#EM'><p>Expectation Maximization Algorithm</p></a></li>
<li><a href='#fcm'><p>fixed effect constraint indication matrix</p></a></li>
<li><a href='#fitted.mmec'><p>fitted form a LMM fitted with mmec</p></a></li>
<li><a href='#fitted.mmer'><p>fitted form a LMM fitted with mmer</p></a></li>
<li><a href='#fixm'><p>fixed indication matrix</p></a></li>
<li><a href='#gvsr'><p>general variance structure specification</p></a></li>
<li><a href='#GWAS'>
<p>Genome wide association study analysis</p>
</p></a></li>
<li><a href='#H'><p>Two-way id by features table</p></a></li>
<li><a href='#H.mat'>
<p>Combined relationship matrix H</p></a></li>
<li><a href='#imputev'><p>Imputing a numeric or character vector</p></a></li>
<li><a href='#isc'><p>identity covariance structure</p></a></li>
<li><a href='#jet.colors'><p>Generate a sequence of colors alog the jet colormap.</p></a></li>
<li><a href='#LD.decay'><p>Calculation of linkage disequilibrium decay</p></a></li>
<li><a href='#leg'><p>Legendre polynomial matrix</p></a></li>
<li><a href='#list2usmat'><p>list or vector to unstructured matrix</p></a></li>
<li><a href='#logspace'><p>Decreasing logarithmic trend</p></a></li>
<li><a href='#manhattan'><p>Creating a manhattan plot</p></a></li>
<li><a href='#map.plot'><p>Creating a genetic map plot</p></a></li>
<li><a href='#MEMMA'><p>Multivariate Efficient Mixed Model Association Algorithm</p></a></li>
<li><a href='#mmec'>
<p><strong>m</strong>ixed <strong>m</strong>odel <strong>e</strong>quations for <strong>c</strong> coefficients</p>
</p></a></li>
<li><a href='#mmer'>
<p><strong>m</strong>ixed <strong>m</strong>odel <strong>e</strong>quations for <strong>r</strong> records</p>
</p></a></li>
<li><a href='#neMarker'><p>Effective population size based on marker matrix</p></a></li>
<li><a href='#overlay'><p>Overlay Matrix</p></a></li>
<li><a href='#plot.mmec'><p>plot form a LMM plot with mmec</p></a></li>
<li><a href='#plot.mmer'><p>plot form a LMM plot with mmer</p></a></li>
<li><a href='#pmonitor'><p>plot the change of VC across iterations</p></a></li>
<li><a href='#predict.mmec'><p>Predict form of a LMM fitted with mmec</p></a></li>
<li><a href='#predict.mmer'><p>Predict form of a LMM fitted with mmer</p></a></li>
<li><a href='#propMissing'><p>Proportion of missing data</p></a></li>
<li><a href='#r2'>
<p>Reliability</p></a></li>
<li><a href='#randef'><p>extracting random effects</p></a></li>
<li><a href='#redmm'><p>Reduced Model Matrix</p></a></li>
<li><a href='#residuals.mmec'><p>Residuals form a GLMM fitted with mmec</p></a></li>
<li><a href='#residuals.mmer'><p>Residuals form a GLMM fitted with mmer</p></a></li>
<li><a href='#rrc'><p>reduced rank covariance structure</p></a></li>
<li><a href='#simGECorMat'>
<p>Create a GE correlation matrix for simulation purposes.</p></a></li>
<li><a href='#sommer-package'>
<p><strong>So</strong>lving <strong>M</strong>ixed <strong>M</strong>odel <strong>E</strong>quations in <strong>R</strong></p>
<br />
</p>
<p><img src="../help/figures/mai.png" height="10%" alt="Figure: mai.png" /></p>
</p></a></li>
<li><a href='#spl2Da'>
<p>Two-dimensional penalised tensor-product of marginal B-Spline basis.</p></a></li>
<li><a href='#spl2Db'>
<p>Two-dimensional penalised tensor-product of marginal B-Spline basis.</p></a></li>
<li><a href='#spl2Dc'>
<p>Two-dimensional penalised tensor-product of marginal B-Spline basis.</p></a></li>
<li><a href='#spl2Dmats'><p>Get Tensor Product Spline Mixed Model Incidence Matrices</p></a></li>
<li><a href='#stackTrait'><p>Stacking traits in a dataset</p></a></li>
<li><a href='#summary.mmec'><p>summary form a GLMM fitted with mmec</p></a></li>
<li><a href='#summary.mmer'><p>summary form a GLMM fitted with mmer</p></a></li>
<li><a href='#tps'><p>Get Tensor Product Spline Mixed Model Incidence Matrices</p></a></li>
<li><a href='#tpsmmbwrapper'><p>Get Tensor Product Spline Mixed Model Incidence Matrices</p></a></li>
<li><a href='#transformConstraints'><p>transformConstraints</p></a></li>
<li><a href='#transp'><p>Creating color with transparency</p></a></li>
<li><a href='#unsm'><p>unstructured indication matrix</p></a></li>
<li><a href='#usc'><p>unstructured covariance structure</p></a></li>
<li><a href='#usr'><p>unstructured covariance structure</p></a></li>
<li><a href='#vpredict'><p>vpredict form of a LMM fitted with mmer</p></a></li>
<li><a href='#vs'><p>variance structure specification</p></a></li>
<li><a href='#vsc'><p>variance structure specification</p></a></li>
<li><a href='#vsr'><p>variance structure specification</p></a></li>
<li><a href='#wald.test'><p>Wald Test for Model Coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Solving Mixed Model Equations in R</td>
</tr>
<tr>
<td>Version:</td>
<td>4.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanny Covarrubias-Pazaran &lt;cova_ruber@live.com.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Structural multivariate-univariate linear mixed model solver for estimation of multiple random effects with unknown variance-covariance structures (e.g., heterogeneous and unstructured) and known covariance among levels of random effects (e.g., pedigree and genomic relationship matrices) (Covarrubias-Pazaran, 2016 &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0156744">doi:10.1371/journal.pone.0156744</a>&gt;; Maier et al., 2015 &lt;<a href="https://doi.org/10.1016%2Fj.ajhg.2014.12.006">doi:10.1016/j.ajhg.2014.12.006</a>&gt;; Jensen et al., 1997). REML estimates can be obtained using the Direct-Inversion Newton-Raphson and Direct-Inversion Average Information algorithms for the problems r x r (r being the number of records) or using the Henderson-based average information algorithm for the problem c x c (c being the number of coefficients to estimate). Spatial models can also be fitted using the two-dimensional spline functionality available.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix (&ge; 1.1.1), methods, stats, MASS, crayon</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.19)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/covaruber/sommer/issues">https://github.com/covaruber/sommer/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/covaruber/sommer">https://github.com/covaruber/sommer</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, plyr, parallel, orthopolynom, RSpectra,
lattice, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-03 18:36:10 UTC; giovannycovarrubias</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanny Covarrubias-Pazaran
    <a href="https://orcid.org/0000-0002-7194-3837"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-03 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='A.mat'>
Additive relationship matrix
</h2><span id='topic+A.mat'></span>

<h3>Description</h3>

<p>Calculates the realized additive relationship matrix. Currently is the C++ implementation of van Raden (2008). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A.mat(X,min.MAF=0,return.imputed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A.mat_+3A_x">X</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> lines and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are allowed.
</p>
</td></tr>
<tr><td><code id="A.mat_+3A_min.maf">min.MAF</code></td>
<td>

<p>Minimum minor allele frequency. The A matrix is not sensitive to rare alleles, so by default only monomorphic markers are removed.
</p>
</td></tr>
<tr><td><code id="A.mat_+3A_return.imputed">return.imputed</code></td>
<td>

<p>When TRUE, the imputed marker matrix is returned.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vanraden method: the marker matrix is centered by subtracting column means <code class="reqn">M= X - ms</code> where ms is the coumn means. Then <code class="reqn">A=M M'/c</code>, where <code class="reqn">c = \sum_k{d_k}/k</code>, the mean value of the diagonal values of the <code class="reqn">M M'</code> portion.
</p>


<h3>Value</h3>

<p>If return.imputed = FALSE, the <code class="reqn">n \times n</code> additive relationship matrix is returned.
</p>
<p>If return.imputed = TRUE, the function returns a list containing
</p>

<dl>
<dt>$A</dt><dd><p>the A matrix</p>
</dd>
<dt>$X</dt><dd><p>the imputed marker matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Endelman, J.B., and J.-L. Jannink. 2012. Shrinkage estimation of the realized relationship matrix. G3:Genes, Genomes, Genetics. 2:1405-1413. doi: 10.1534/g3.112.004259
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### random population of 200 lines with 1000 markers
####=========================================####
X &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  X[i,] &lt;- ifelse(runif(1000)&lt;0.5,-1,1)
}

A &lt;- A.mat(X)

####=========================================####
#### take a look at the Genomic relationship matrix 
#### (just a small part)
####=========================================####
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# hv &lt;- heatmap(A[1:15,1:15], col = colfunc(100),Colv = "Rowv")
# str(hv)
</code></pre>

<hr>
<h2 id='add.diallel.vars'>add.diallel.vars</h2><span id='topic+add.diallel.vars'></span>

<h3>Description</h3>

<p>'add.diallel.vars' adds 4 columns to the provided diallel dataset. Specifically, the user provides a dataset with indicator variables for who is the male and female parent and the function returns the same dataset with 4 new dummy variables to allow the model fit of diallel models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  add.diallel.vars(df, par1="Par1", par2="Par2",sep.cross="-")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.diallel.vars_+3A_df">df</code></td>
<td>
<p>a dataset with the two indicator variables for who is the male and female parent.</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_par1">par1</code></td>
<td>
<p>the name of the column indicating who is the first parent (e.g. male).</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_par2">par2</code></td>
<td>
<p>the name of the column indicating who is the second parent (e.g. female).</p>
</td></tr>
<tr><td><code id="add.diallel.vars_+3A_sep.cross">sep.cross</code></td>
<td>
<p>the character that should be used when creating the column for cross.id. A simple paste of the columns par1 and par2.</p>
</td></tr>
</table>


<h3>Value</h3>


<p>A new data set with the following 4 new dummy variables to allow the fit of complex diallel models:
</p>
<dl>
<dt>is.cross</dt><dd><p>returns a 0 if is a self and a 1 for a cross.</p>
</dd>
<dt>is.self</dt><dd><p>returns a 0 if is a cross and a 1 is is a self.</p>
</dd>
<dt>cross.type</dt><dd><p>returns a -1 for a direct cross, a 0 for a self and a 1 for a reciprocal cross.</p>
</dd>
<dt>cross.id</dt><dd><p>returns a column psting the par1 and par2 columns.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code>, the <code><a href="#topic+overlay">overlay</a></code> function and the <code><a href="#topic+DT_mohring">DT_mohring</a></code> example. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the
#### examples are silenced with one '#' mark,
#### remove them and run the examples
####=========================================####
data(DT_mohring)
DT &lt;- DT_mohring
head(DT)
DT2 &lt;- add.diallel.vars(DT,par1="Par1", par2="Par2")
head(DT2)
## see ?DT_mohring for an example on how to use the data to fit diallel models.

</code></pre>

<hr>
<h2 id='adiag1'>Binds arrays corner-to-corner</h2><span id='topic+adiag1'></span>

<h3>Description</h3>

<p>Array generalization of blockdiag()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adiag1(... , pad=as.integer(0), do.dimnames=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adiag1_+3A_...">...</code></td>
<td>
<p>Arrays to be binded together</p>
</td></tr>
<tr><td><code id="adiag1_+3A_pad">pad</code></td>
<td>
<p>Value to pad array with; note default keeps integer status
of arrays</p>
</td></tr>
<tr><td><code id="adiag1_+3A_do.dimnames">do.dimnames</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
dimnames if possible.  Set to <code>FALSE</code> if performance is an
issue</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Binds any number of arrays together, corner-to-corner.  Because the
function is associative provided pad is of length 1, this page
discusses the two array case.
</p>
<p>If <code>x=adiag1(a,b)</code> and <code>dim(a)=c(a_1,...,a_d)</code>,
<code>dim(b)=c(b_1,...,b_d)</code>; then <code>all(dim(x)==dim(a)+dim(b))</code> and
<code>x[1:a_1,...,1:a_d]=a</code> and
<code>x[(a_1+1):(a_1+b_1),...,(a_d+1):(a_d+b_d)]=b</code>.
</p>
<p>Dimnames are preserved, if both arrays have non-null dimnames, and
<code>do.dimnames</code> is <code>TRUE</code>.
</p>
<p>Argument pad is usually a length-one vector, but any vector is
acceptable; standard recycling is used.  Be aware that the output array
(of dimension <code>dim(a)+dim(b)</code>) is filled with (copies of)
<code>pad</code> <em>before</em> <code>a</code> and <code>b</code> are copied.  This can be
confusing.
</p>


<h3>Value</h3>

<p>Returns an array of dimensions <code>dim(a)+dim(b)</code> as described above.
</p>


<h3>Note</h3>

<p>In <code>adiag1(a,b)</code>, if <code>a</code> is a length-one vector, it is coerced
to an array of dimensions <code>rep(1,length(dim(b)))</code>; likewise
<code>b</code>.  If both <code>a</code> and <code>b</code> are length-one vectors, return
<code>diag(c(a,b))</code>.
</p>
<p>If <code>a</code> and <code>b</code> are arrays, function <code>adiag1()</code> requires
<code>length(dim(a))==length(dim(b))</code> (the function does not guess which
dimensions have been dropped; see examples section).  In particular,
note that vectors are not coerced except if of length one.
</p>
<p><code>adiag1()</code> is used when padding magic hypercubes in the context
of evaluating subarray sums.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf with some additions by Robin Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'> a &lt;- array( 1,c(2,2))
 b &lt;- array(-1,c(2,2))
 adiag1(a,b)

 ## dropped dimensions can count:

 b2 &lt;- b1 &lt;- b
 dim(a) &lt;- c(2,1,2)
 dim(b1) &lt;- c(2,2,1)
 dim(b2) &lt;- c(1,2,2)

 dim(adiag1(a,b1))
 dim(adiag1(a,b2))

## dimnames are preserved if not null:

a &lt;- matrix(1,2,2,dimnames=list(col=c("red","blue"),size=c("big","small"))) 
b &lt;- 8
dim(b) &lt;- c(1,1)
dimnames(b) &lt;- list(col=c("green"),size=c("tiny"))
adiag1(a,b)   #dimnames preserved
adiag1(a,8)   #dimnames lost because second argument has none.

## non scalar values for pad can be confusing:
q &lt;- matrix(0,3,3)
adiag1(q,q,pad=1:4)

## following example should make the pattern clear:
adiag1(q,q,pad=1:36)


# Now, a use for arrays with dimensions of zero extent:
z &lt;- array(dim=c(0,3))
colnames(z) &lt;- c("foo","bar","baz")

adiag1(a,z)        # Observe how this has
                  # added no (ie zero) rows to "a" but
                  # three extra columns filled with the pad value

adiag1(a,t(z))
adiag1(z,t(z))     # just the pad value

</code></pre>

<hr>
<h2 id='AI'>Average Information Algorithm</h2><span id='topic+AI'></span>

<h3>Description</h3>

<p>Univariate version of the average information (AI) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AI(X=NULL,Z=NULL, Zind=NULL, Ai=NULL,y=NULL,S=NULL, H=NULL,
    nIters=80, tolParConvLL=1e-4, tolParConvNorm=.05, tolParInv=1e-6, theta=NULL, 
    thetaC=NULL, thetaF=NULL, addScaleParam=NULL,
    weightInfEMv=NULL, weightInfMat=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AI_+3A_x">X</code></td>
<td>
<p>an incidence matrix for fixed effects.</p>
</td></tr>
<tr><td><code id="AI_+3A_z">Z</code></td>
<td>
<p>Z is a list of lists each element contains the Z matrices required for the covariance structure specified for a random effect.</p>
</td></tr>
<tr><td><code id="AI_+3A_zind">Zind</code></td>
<td>
<p>vector specifying to which random effect each Z matrix belongs to. </p>
</td></tr>
<tr><td><code id="AI_+3A_ai">Ai</code></td>
<td>
<p>is a list with the inverses of the relationship matrix for each random effect.</p>
</td></tr>
<tr><td><code id="AI_+3A_y">y</code></td>
<td>
<p>is the response variable</p>
</td></tr>
<tr><td><code id="AI_+3A_s">S</code></td>
<td>
<p>is the list of residual matrices.</p>
</td></tr>
<tr><td><code id="AI_+3A_h">H</code></td>
<td>
<p>is the matrix of weights. This will be squared via the cholesky decomposition and apply to the residual matrices.</p>
</td></tr>
<tr><td><code id="AI_+3A_niters">nIters</code></td>
<td>
<p>number of REML iterations .</p>
</td></tr>
<tr><td><code id="AI_+3A_tolparconvll">tolParConvLL</code></td>
<td>
<p>rule for stoping the optimization problem, difference in log-likelihood between the current and past iteration.</p>
</td></tr>
<tr><td><code id="AI_+3A_tolparconvnorm">tolParConvNorm</code></td>
<td>
<p>rule for stoping the optimization problem, difference in norms.</p>
</td></tr>
<tr><td><code id="AI_+3A_tolparinv">tolParInv</code></td>
<td>
<p>value to add to the diagonals of a matrix that cannot be inverted because is not positive-definite.</p>
</td></tr>
<tr><td><code id="AI_+3A_theta">theta</code></td>
<td>
<p> is the initial values for the vc (matrices should be symmetric).</p>
</td></tr>
<tr><td><code id="AI_+3A_thetac">thetaC</code></td>
<td>
<p> is the constraints for vc: 1 positive, 2 unconstrained, 3 fixed.</p>
</td></tr>
<tr><td><code id="AI_+3A_thetaf">thetaF</code></td>
<td>
<p> is the dataframe indicating the fixed constraints as x times another vc, rows indicate the variance components, columns the scale parameters (other VC plus additional ones preferred).</p>
</td></tr>
<tr><td><code id="AI_+3A_addscaleparam">addScaleParam</code></td>
<td>
<p> any additional scale parameter to be included when applying constraints in thetaF.</p>
</td></tr>
<tr><td><code id="AI_+3A_weightinfemv">weightInfEMv</code></td>
<td>
<p> is the vector to be put in a diagonal matrix (a list with as many matrices as iterations) representing the weight assigned to the EM information matrix.</p>
</td></tr>
<tr><td><code id="AI_+3A_weightinfmat">weightInfMat</code></td>
<td>
<p> is a vector of weights to the information matrix for the operation delta = I- * dLu/dLx # unstructured models may require less weight to the information matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is based on Jensen, Madsen and Thompson (1997) 
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>

<dl>
<dt>res</dt><dd><p> a list of different outputs</p>
</dd>
</dl>



<h3>References</h3>

<p>Jensen, J., Mantysaari, E. A., Madsen, P., and Thompson, R. (1997). Residual maximum likelihood estimation of (co) variance components in multivariate mixed linear models using average information. Journal of the Indian Society of Agricultural Statistics, 49, 215-236.
</p>
<p>Covarrubias-Pazaran G. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744   
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

data("DT_example")
DT &lt;- DT_example
K &lt;- A_example
#### look at the data and fit the model
head(DT)

zz &lt;- with(DT, vsr(dsr(Env),Name))

Z &lt;- c(list(model.matrix(~Name-1, data=DT)),zz$Z)

Zind &lt;- c(1,2,2,2)

A &lt;- list(diag(41), diag(41))#rep(list(diag(41)),4)

Ai &lt;- lapply(A, function(x){solve(x)})

theta &lt;- list(
  matrix(10,1,1),
  diag(10,3,3),
  diag(10,3,3)
);theta

thetaC &lt;- list(
  matrix(1,1,1),
  diag(1,3,3),
  diag(1,3,3)
);thetaC

X &lt;- model.matrix(~Env, data=DT)

y &lt;- as.matrix(DT$Yield)

DTx &lt;- DT; DTx$units &lt;- as.factor(1:nrow(DTx))
ss &lt;- with(DTx, vsr(dsr(Env),units) )

S &lt;- ss$Z 

H &lt;- diag(length(y))

addScaleParam &lt;- 0
nn &lt;- unlist(lapply(thetaC, function(x){length(which(x &gt; 0))}))
nn2 &lt;- sum(nn[1:max(Zind)])
ff &lt;- diag(nn2)
thetaF &lt;- cbind(ff,matrix(0,nn2,1))

## apply the function
weightInfMat=rep(1,40); # weights for the information matrix
weightInfEMv=c(seq(.9,.1,-.1),rep(0,36)); # weights for the EM information matrix

# expr = res3&lt;-AI(X=X,Z=Z, Zind=Zind,
#                 Ai=Ai,y=y,
#                 S=S,
#                 H=H, 
#                 nIters=20, tolParConvLL=1e-5,
#                 tolParConvNorm=0.05,
#                 tolParInv=1e-6,theta=theta,
#                 thetaC=thetaC,thetaF=thetaF,
#                 addScaleParam=addScaleParam, weightInfEMv = weightInfEMv,
#                 weightInfMat = weightInfMat
#                 
# )
# # compare results
# res3$monitor


</code></pre>

<hr>
<h2 id='anova.mmec'>anova form a GLMM fitted with mmec</h2><span id='topic+anova.mmec'></span>

<h3>Description</h3>

<p><code>anova</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
anova(object, object2=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.mmec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="anova.mmec_+3A_object2">object2</code></td>
<td>
<p>an object of class <code>"mmec"</code>, if NULL the program will provide regular sum of squares results.</p>
</td></tr>
<tr><td><code id="anova.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of anova
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>

<hr>
<h2 id='anova.mmer'>anova form a GLMM fitted with mmer</h2><span id='topic+anova.mmer'></span>

<h3>Description</h3>

<p><code>anova</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
anova(object, object2=NULL, type=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.mmer_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="anova.mmer_+3A_object2">object2</code></td>
<td>
<p>an object of class <code>"mmer"</code>, if NULL the program will provide regular sum of squares results.</p>
</td></tr>
<tr><td><code id="anova.mmer_+3A_type">type</code></td>
<td>
<p>anova type, I or II</p>
</td></tr>
<tr><td><code id="anova.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of anova
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>

<hr>
<h2 id='AR1'>
Autocorrelation matrix of order 1.
</h2><span id='topic+AR1'></span>

<h3>Description</h3>

<p>Creates an autocorrelation matrix of order one with parameters specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR1(x,rho=0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AR1_+3A_x">x</code></td>
<td>
<p>vector of the variable to define the factor levels for the AR1 covariance structure.</p>
</td></tr>
<tr><td><code id="AR1_+3A_rho">rho</code></td>
<td>
<p>rho value for the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specially useful for constructing covariance structures for rows and ranges to capture better the spatial variation trends in the field. The rho value is assumed fixed and values of the variance component will be optimized through REML.
</p>


<h3>Value</h3>

<p>If everything is defined correctly the function returns:
</p>

<dl>
<dt>$nn</dt><dd><p>the correlation matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
R1 &lt;- AR1(x,rho=.25)
image(R1)
</code></pre>

<hr>
<h2 id='ARMA'>
Autocorrelation Moving average.
</h2><span id='topic+ARMA'></span>

<h3>Description</h3>

<p>Creates an ARMA matrix of order one with parameters specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMA(x, rho=0.25, lambda=0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMA_+3A_x">x</code></td>
<td>
<p>vector of the variable to define the factor levels for the ARMA covariance structure.</p>
</td></tr>
<tr><td><code id="ARMA_+3A_rho">rho</code></td>
<td>
<p>rho value for the matrix.</p>
</td></tr>
<tr><td><code id="ARMA_+3A_lambda">lambda</code></td>
<td>
<p>dimensions of the square matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specially useful for constructing covariance structures for rows and ranges to capture better the spatial variation trends in the field. The rho value is assumed fixed and values of the variance component will be optimized through REML.
</p>


<h3>Value</h3>

<p>If everything is defined correctly the function returns:
</p>

<dl>
<dt>$nn</dt><dd><p>the correlation matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
R1 &lt;- ARMA(x,rho=.25,lambda=0.2)
image(R1)
</code></pre>

<hr>
<h2 id='atc'>atc covariance structure</h2><span id='topic+atc'></span>

<h3>Description</h3>

<p><code>atc</code> creates a diagonal covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmec">mmec</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  atc(x, levs, thetaC, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atc_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="atc_+3A_levs">levs</code></td>
<td>
<p>levels of the random effect to use for building the incidence matrices.</p>
</td></tr>
<tr><td><code id="atc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional symmetric matrix for constraints in the variance-covariance components. The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define how the variance-covariance components should be estimated:
</p>
<p>0: component will not be estimated
</p>
<p>1: component will be estimated and constrained to be positive
</p>
<p>2: component will be estimated and unconstrained
</p>
<p>3: component will be fixed to the value provided in the theta argument
</p>
</td></tr>
<tr><td><code id="atc_+3A_theta">theta</code></td>
<td>
<p>an optional symmetric matrix for initial values of the variance-covariance components. The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values will be calculated as:
</p>
<p>theta* = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm))
</p>
<p>where mm is the incidence matrix for the factor 'x'. The values provided should be scaled by the variance of the response variable.
</p>
<p>theta = theta*/var(y)
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>atc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver. </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
atc(x, c("1","2"))
## how to use the theta and thetaC arguments:
# data(DT_example)
# DT &lt;- DT_example
# theta &lt;- diag(2)*2; theta # initial VCs
# thetaC &lt;- diag(2)*3; thetaC # fixed VCs
# ans1 &lt;- mmec(Yield~Env,
#              random= ~ vsc( atc(Env, levs=c("CA.2013", "CA.2011"),
#                             theta = theta,thetaC = thetaC),isc(Name) ),
#              rcov= ~ units, nIters = 1,
#              data=DT)
# summary(ans1)$varcomp

</code></pre>

<hr>
<h2 id='atcg1234'>
Letter to number converter
</h2><span id='topic+atcg1234'></span>

<h3>Description</h3>

<p>This function was designed to help users to transform their data in letter format to numeric format. Details in the format are not complex, just a dataframe with markers in columns and individuals in rows. Only markers, NO extra columns of plant names etc (names of plants can be stored as rownames). The function expects a matrix of only polymorphic markers, please make sure you clean your data before using this function. The apply function can help you identify and separate monomorphic from polymorphic markers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atcg1234(data, ploidy=2, format="ATCG", maf=0, multi=TRUE, 
        silent=FALSE, by.allele=FALSE, imp=TRUE, ref.alleles=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atcg1234_+3A_data">data</code></td>
<td>
<p>a dataframe with markers in columns and individuals in rows. Preferable the rownames are the ID of the plants so you don't lose track of what is what.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_ploidy">ploidy</code></td>
<td>
<p>a numeric value indicating the ploidy level of the specie. The default is 2 which means diploid.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_format">format</code></td>
<td>
<p>one of the two possible values allowed by the program &quot;ATCG&quot;, which means your calls are in base-pair-letter code, i.e. &quot;AT&quot; in a diploid call, &quot;AATT&quot; tetraploid etc (just example). Therefore possible codes can be &quot;A&quot;, &quot;T&quot;, &quot;C&quot;, &quot;G&quot;, &quot;-&quot; (deletion), &quot;+&quot; (insertion). Alternatively &quot;AB&quot; format can be used as well. Commonly this depends from the genotyping technologies used, such as GBS or microarrays. In addition, we have enabled also the use of single-letter code used by Cornell, i.e. A=AA, C=CC, T=TT, G=GG, R=AG, Y=CT, S=CG, W=AT, K=GT, M=AC. In the case of GBS code please make sure that you set the N codes to regular NAs handled by R. The &quot;ATCG&quot; format also works for the bi-allelic marker codes from join map such as &quot;lm&quot;, &quot;ll&quot;,&quot;nn&quot;, &quot;np&quot;,&quot;hh&quot;,&quot;hk&quot;,&quot;kk&quot;</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_maf">maf</code></td>
<td>
<p>minor allele frequency used to filter the SNP markers, the default is zero which means all markers are returned in numeric format.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_multi">multi</code></td>
<td>
<p>a TRUE/FALSE statement indicating if the function should get rid of the markers with more than 2 alleles. If FALSE, which indicates that if markers with multiple alleles are found, the alternate and reference alleles will be the first 2 alleles found. This could be risky since some alleles will be masked, i.e. AA AG AT would take only A and G as reference and alternate alleles, converting to numeric format 2 1 1, giving the same effect to AG and AT which could be a wrong assumption. The default is TRUE, removes markers with more than two alleles. </p>
</td></tr>
<tr><td><code id="atcg1234_+3A_silent">silent</code></td>
<td>
<p>a TRUE/FALSE value indicating if a progress bar should be drawn for each step of the conversion. The default is silent=FALSE, which means that we want progress bar to be drawn.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_by.allele">by.allele</code></td>
<td>
<p>a TRUE/FALSE value indicating if the program should transform the data in a zero/one matrix of presence/absense per allele. For example, a marker with 3 alleles A,T,C in a diploid organism will yield 6 possible configurations; AA, AT, AC, TT, TC, CC. Therefore, the program would create 3 columns for this marker indicating the presence/absence of each allele for each genotype. </p>
</td></tr>
<tr><td><code id="atcg1234_+3A_imp">imp</code></td>
<td>
<p>a TRUE/FALSE value indicating if the function should impute the missing data using the median for each marker. If FALSE, then the program will not impute.</p>
</td></tr>
<tr><td><code id="atcg1234_+3A_ref.alleles">ref.alleles</code></td>
<td>
<p>a matrix with reference alleles to be used for the conversion. The matrix should have as many columns as markers with reference alleles and with 2 rows, being the first row the alternate allele (Alt) and the second row the reference allele (Ref). Rownames should be &quot;Alt&quot; and &quot;Ref&quot; respectively. If not provided the program will decide the reference allele.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$data</dt><dd><p> a new dataframe of markers in numeric format with markers in columns and individuals in rows.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_polyploid)
genotypes &lt;- GT_polyploid
genotypes[1:5,1:5] # look the original format

####=================================================####
#### convert markers to numeric format polyploid potatoes
####=================================================####
# numo &lt;- atcg1234(data=genotypes, ploidy=4)
# numo$M[1:5,1:5]

####=================================================####
#### convert markers to numeric format diploid rice lines
#### single letter code for inbred lines from GBS pipeline
#### A=AA, T=TT, C=CC, G=GG 
####=================================================####
# data(DT_rice)
# X &lt;- GT_rice; X[1:5,1:5]; dim(X)
# numo2 &lt;- atcg1234(data=X, ploidy=2)
# numo2$M[1:5,1:5]
</code></pre>

<hr>
<h2 id='atcg1234BackTransform'>
Letter to number converter
</h2><span id='topic+atcg1234BackTransform'></span>

<h3>Description</h3>

<p>This function was designed to help users back transform the numeric marker matrices from the function atcg1234 into letters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atcg1234BackTransform(marks, refs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atcg1234BackTransform_+3A_marks">marks</code></td>
<td>
<p>a centered marker matrix coming from atcg1234.</p>
</td></tr>
<tr><td><code id="atcg1234BackTransform_+3A_refs">refs</code></td>
<td>
<p>a 2 x m matrix for m markers (columns) and 2 rows where the reference and alternate alleles for each marker are indicated.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>markers</dt><dd><p> a new marker matrix leter coded according to the reference allele matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_polyploid)
genotypes &lt;- GT_polyploid
genotypes[1:5,1:5] # look the original format

# ####=================================================####
# #### convert markers to numeric format polyploid potatoes
# ####=================================================####
# numo &lt;- atcg1234(data=genotypes, ploidy=4)
# numo$M[1:5,1:5]
# numob &lt;- atcg1234BackTransform(marks =  numo$M, refs =  numo$ref.alleles)
# numob[1:4,1:4]
# 
# ####=================================================####
# #### convert markers to numeric format diploid rice lines
# #### single letter code for inbred lines from GBS pipeline
# #### A=AA, T=TT, C=CC, G=GG
# ####=================================================####
# data(DT_rice)
# X &lt;- GT_rice; X[1:5,1:5]; dim(X)
# numo2 &lt;- atcg1234(data=X, ploidy=2)
# numo2$M[1:5,1:5]
# Xb &lt;- atcg1234BackTransform(marks= numo2$M, refs= numo2$ref.alleles)
# Xb[1:4,1:4]


</code></pre>

<hr>
<h2 id='atr'>atr covariance structure</h2><span id='topic+atr'></span>

<h3>Description</h3>

<p><code>atr</code> creates a diagonal covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmer">mmer</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  atr(x, levs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atr_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="atr_+3A_levs">levs</code></td>
<td>
<p>levels of the random effect to use for building the incidence matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>atr</code> in the <code><a href="#topic+mmer">mmer</a></code> solver. </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
atr(x)
atr(x, c("1","2"))
</code></pre>

<hr>
<h2 id='bathy.colors'>Generate a sequence of colors for plotting bathymetric data.</h2><span id='topic+bathy.colors'></span>

<h3>Description</h3>

<p><code>bathy.colors(n)</code> generates a sequence of <code class="reqn">n</code>
colors along a linear scale from light grey to pure blue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bathy.colors(n, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bathy.colors_+3A_n">n</code></td>
<td>
<p>The number of colors to return.</p>
</td></tr>
<tr><td><code id="bathy.colors_+3A_alpha">alpha</code></td>
<td>
<p>Alpha values to be passed to <code>rgb()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of blue scale colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# Plot a colorbar using bathy.colors
image(matrix(seq(100), 100), col=bathy.colors(100))
}
</code></pre>

<hr>
<h2 id='bbasis'>Function for creating B-spline basis functions (Eilers &amp; Marx, 2010)</h2><span id='topic+bbasis'></span>

<h3>Description</h3>

<p>Construct a B-spline basis of degree <code>deg</code>
with <code>ndx-</code>1 equally-spaced internal knots (<code>ndx</code> segments) on range [<code>x1</code>,<code>xr</code>].
Code copied from Eilers &amp; Marx 2010, WIR: Comp Stat 2, 637-653.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbasis(x, xl, xr, ndx, deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bbasis_+3A_x">x</code></td>
<td>
<p>A vector. Data values for spline.</p>
</td></tr>
<tr><td><code id="bbasis_+3A_xl">xl</code></td>
<td>
<p>A numeric value. Lower bound for data (lower external knot).</p>
</td></tr>
<tr><td><code id="bbasis_+3A_xr">xr</code></td>
<td>
<p>A numeric value. Upper bound for data (upper external knot).</p>
</td></tr>
<tr><td><code id="bbasis_+3A_ndx">ndx</code></td>
<td>
<p>A numeric value. Number of divisions for x range
(equal to number of segments = number of internal knots + 1)</p>
</td></tr>
<tr><td><code id="bbasis_+3A_deg">deg</code></td>
<td>
<p>A numeric value. Degree of the polynomial spline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not yet amended to coerce values that should be zero to zero!
</p>


<h3>Value</h3>

<p>A matrix with columns holding the P-spline for each value of x.
Matrix has <code>ndx+deg</code> columns and <code>length(x)</code> rows.
</p>

<hr>
<h2 id='bivariateRun'>bivariateRun functionality</h2><span id='topic+bivariateRun'></span>

<h3>Description</h3>

<p>Sometimes multi-trait models can present many singularities making the model hard to estimate with many traits. One of the most effective strategies is to estimate all possible variance and covariances splitting in multiple bivariate models. This function takes a model that has t traits and splits the model in as many bivariate models as needed to estimate all the variance and covariances to provide the initial values for the model with all traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bivariateRun(model, n.core)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bivariateRun_+3A_model">model</code></td>
<td>
<p>a model fitted with the mmer function with argument return.param=TRUE.</p>
</td></tr>
<tr><td><code id="bivariateRun_+3A_n.core">n.core</code></td>
<td>
<p>number of cores to use in the mclapply function to parallelize the models to be run to avoid increase in computational time. Please keep in mind that this is only available in Linux and macOS systems. Please check the details in the <code><a href="parallel.html#topic+mclapply">mclapply</a></code> documentation of the parallel package.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$sigmas</dt><dd><p>the list with the variance covariance parameters for all traits together.</p>
</dd>
<dt>$sigmascor</dt><dd><p>the list with the correlation for the variance components for all traits together.</p>
</dd>
<dt>$model</dt><dd><p>the results from the bivariate models.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 1
# #### simple example with univariate models
# ####=========================================####
# ####=========================================####
# data("DT_cpdata")
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix
# A &lt;- A.mat(GT)
# #### look at the data and fit the model
# head(DT)
# ans.m &lt;- mmer(cbind(Yield,color,FruitAver, Firmness)~1,
#                random=~ vsr(id, Gu=A, Gtc=unsm(4))
#                + vsr(Rowf,Gtc=diag(4))
#                + vsr(Colf,Gtc=diag(4)), na.method.Y="include",
#                rcov=~ vsr(units,Gtc=unsm(4)), return.param = TRUE,
#                data=DT)
# 
# # define the number of cores (number of bivariate models) as (nt*(nt-1))/2 
# nt=4
# (nt*(nt-1))/2
# res &lt;- bivariateRun(ans.m,n.core = 6)
# # now use the variance componets to fit a join model
# mm &lt;- transformConstraints(ans.m[[8]],3)
# 
# ans.m.final &lt;- mmer(cbind(Yield,color,FruitAver, Firmness)~1,
#               random=~ vsr(id, Gu=A, Gtc=unsm(4))
#               + vsr(Rowf,Gtc=diag(4))
#               + vsr(Colf,Gtc=diag(4)), na.method.Y="include",
#               rcov=~ vsr(units,Gtc=unsm(4)), 
#               init = res$sigmas_scaled, constraints = mm,
#               data=DT, iters=1)
# 
# summary(ans.m.final)

</code></pre>

<hr>
<h2 id='build.HMM'>
Build a hybrid marker matrix using parental genotypes from inbred individuals
</h2><span id='topic+build.HMM'></span>

<h3>Description</h3>

<p>Uses the 2 marker matrices from both sets of inbred or partially inbred parents and creates all possible combinations unless the user specifies which hybrid genotypes to build (custom.hyb argument). It returns the additive and dominance marker matrices (-1,0,1; homo,het,homo in additive and 0,1,0; homo,het,homo for dominance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.HMM(M1,M2, custom.hyb=NULL, return.combos.only=FALSE,separator=":")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build.HMM_+3A_m1">M1</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> inbreds and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are not allowed.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_m2">M2</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> inbreds and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are not allowed.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_custom.hyb">custom.hyb</code></td>
<td>

<p>A data frame with columns 'Var1' 'Var2', 'hybrid' which specifies which hybrids should be built using the M1 and M2 matrices provided.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_return.combos.only">return.combos.only</code></td>
<td>

<p>A TRUE/FALSE statement inicating if the function should skip building the geotype matrix for hybrids and only return the data frame with all possible combinations to be build. In case the user wants to subset the hybrids before building the marker matrix.
</p>
</td></tr>
<tr><td><code id="build.HMM_+3A_separator">separator</code></td>
<td>

<p>Any desired character to be used when pasting the male and female columns to assign the name to the hybrids.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It returns the marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo) and dominance (0,1,0; homo,het,homo). This function is deviced for building marker matrices for hybrids coming from inbreds. If the parents are close to inbred &gt;F5 you can try deleting the heterozygote calls (0's) and imputing those cells with the most common genotype (1 or -1). The expectation is that for mostly inbred individuals this may not change drastically the result but will make the results more interpretable. For non-inbred parents (F1 to F3) the cross of an F1 x F1 has many possibilities and is not the intention of this function to build genotypes for heterzygote x heterozygote crosses.
</p>


<h3>Value</h3>

<p>It returns the marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo) and dominance (0,1,0; homo,het,homo).
</p>

<dl>
<dt>$HMM.add</dt><dd><p>marker matrix for hybrids coded as additive (-1,0,1; homo,het,homo)</p>
</dd>
<dt>$HMM.dom</dt><dd><p>marker matrix for hybrids coded as dominance (0,1,0; homo,het,homo)</p>
</dd>
<dt>$data.used</dt><dd><p>the data frame used to build the hybrid genotypes</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Nishio M and Satoh M. 2014. Including Dominance Effects in the Genomic BLUP Method for Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792
</p>
<p>Su G, Christensen OF, Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code>&ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### use Technow data as example
####=========================================####
data(DT_technow)
DT &lt;- DT_technow
Md &lt;- (Md_technow * 2) - 1
Mf &lt;- (Mf_technow * 2) - 1


## first get all possible hybrids
res1 &lt;- build.HMM(Md, Mf, 
                  return.combos.only = TRUE)
head(res1$data.used)

## build the marker matrix for the first 50 hybrids
res2 &lt;- build.HMM(Md, Mf,
                 custom.hyb = res1$data.used[1:50,]
                 )
res2$HMM.add[1:5,1:5]
res2$HMM.dom[1:5,1:5]

## now you can use the A.mat(), D.mat() and E.mat() functions
# M &lt;- res2$HMM.add
# A &lt;- A.mat(M)
# D &lt;- D.mat(M)

</code></pre>

<hr>
<h2 id='coef.mmec'>coef form a GLMM fitted with mmec</h2><span id='topic+coef.mmec'></span>

<h3>Description</h3>

<p><code>coef</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.mmec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="coef.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coef
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+mmec">mmec</a></code> </p>

<hr>
<h2 id='coef.mmer'>coef form a GLMM fitted with mmer</h2><span id='topic+coef.mmer'></span>

<h3>Description</h3>

<p><code>coef</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.mmer_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="coef.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of coef
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+mmer">mmer</a></code> </p>

<hr>
<h2 id='corImputation'>Imputing a matrix using correlations</h2><span id='topic+corImputation'></span>

<h3>Description</h3>

<p>corImputation imputes missing data based on the correlation that exists between row levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  corImputation(wide, Gu=NULL, nearest=10, roundR=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corImputation_+3A_wide">wide</code></td>
<td>
<p>numeric matrix with individuals in rows and time variable in columns (e.g., environments, genetic markers, etc.).</p>
</td></tr>
<tr><td><code id="corImputation_+3A_gu">Gu</code></td>
<td>
<p>optional correlation matrix between the individuals or row levels. If NULL it will be computed as the correlation of t(wide).</p>
</td></tr>
<tr><td><code id="corImputation_+3A_nearest">nearest</code></td>
<td>
<p>integer value describing how many nearest neighbours (the ones showing the highest correlation) should be used to average and return the imputed value.</p>
</td></tr>
<tr><td><code id="corImputation_+3A_roundr">roundR</code></td>
<td>
<p>a TRUE/FALSE statement describing if the average result should be rounded or not. This may be specifically useful for categorical data in the form of numbers (e.g., -1,0,1).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the imputed matrix and the original matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####################################
### imputing genotype data example
####################################
# data(DT_cpdata)
# X &lt;- GT_cpdata
# # add missing data
# v &lt;- sample(1:length(X), 500)
# Xna &lt;- X
# Xna[v]&lt;- NA
# ## impute (can take some time)
# Y &lt;- corImputation(wide=Xna, Gu=NULL, nearest=20, roundR=TRUE) 
# cm &lt;- table(Y$imputed[v],X[v])
# ## calculate accuracy
# sum(diag(cm))/length(v)
####################################
### imputing phenotypic data example
####################################
# data(DT_h2)
# X &lt;- reshape(DT_h2[,c("Name","Env","y")], direction = "wide", idvar = "Name",
#                 timevar = "Env", v.names = "y", sep= "_")
# rownames(X) &lt;- X$Name
# X &lt;- as.matrix(X[,-1])
# head(X)
# # add missing data
# v &lt;- sample(1:length(X), 50)
# Xna &lt;- X
# Xna[v]&lt;- NA
# ## impute
# Y &lt;- corImputation(wide=Xna, Gu=NULL, nearest=20, roundR=TRUE)
# plot(y=Y$imputed[v],x=X[v], xlab="true",ylab="predicted")
# cor(Y$imputed[v],X[v], use = "complete.obs")


</code></pre>

<hr>
<h2 id='covc'>covariance between random effects</h2><span id='topic+covc'></span>

<h3>Description</h3>

<p><code>covc</code> merges the incidence matrices and covariance matrices of two random effects to fit an unstructured model between 2 different random effects to be fitted with the <code><a href="#topic+mmec">mmec</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  covc(ran1, ran2, thetaC=NULL, theta=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covc_+3A_ran1">ran1</code></td>
<td>
<p>the random call of the first random effect.</p>
</td></tr>
<tr><td><code id="covc_+3A_ran2">ran2</code></td>
<td>
<p>the random call of the first random effect.</p>
</td></tr>
<tr><td><code id="covc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional matrix for constraints in the variance components.</p>
</td></tr>
<tr><td><code id="covc_+3A_theta">theta</code></td>
<td>
<p>an optional symmetric matrix for initial values of the variance-covariance components. When providing customized values, these values should be scaled with respect to the original variance. For example, to provide an initial value of 1 to a given variance component, theta would be built as:
</p>
<p>theta = matrix( 1 / var(response) ) 
</p>
<p>The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values will be calculated as:
</p>
<p>theta = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm))
</p>
<p>where mm is the incidence matrix for the factor 'x'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation aims to fit models where covariance between random variables is expected to exist. For example, indirect genetic effects.
</p>


<h3>Value</h3>


<dl>
<dt>$Z</dt><dd><p> a incidence matrix Z* = Z Gamma which is the original incidence matrix for the timevar multiplied by the loadings.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>
<p>Bijma, P. (2014). The quantitative genetics of indirect genetic effects: a selective review of modelling issues. Heredity, 112(1), 61-69.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>covc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_ige)
DT &lt;- DT_ige
covRes &lt;- with(DT, covc( vsc(isc(focal)) , vsc(isc(neighbour)) ) )
str(covRes)
# look at DT_ige help page to see how to fit an actual model

</code></pre>

<hr>
<h2 id='CS'>
Compound symmetry matrix
</h2><span id='topic+CS'></span>

<h3>Description</h3>

<p>Creates a compound symmetry matrix with parameters specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CS(x, rho=0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CS_+3A_x">x</code></td>
<td>
<p>vector of the variable to define the factor levels for the ARMA covariance structure.</p>
</td></tr>
<tr><td><code id="CS_+3A_rho">rho</code></td>
<td>
<p>rho value for the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specially useful for constructing covariance structures for rows and ranges to capture better the spatial variation trends in the field. The rho value is assumed fixed and values of the variance component will be optimized through REML.
</p>


<h3>Value</h3>

<p>If everything is defined correctly the function returns:
</p>

<dl>
<dt>$nn</dt><dd><p>the correlation matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:4
R1 &lt;- CS(x,rho=.25)
image(R1)
</code></pre>

<hr>
<h2 id='csc'>customized covariance structure</h2><span id='topic+csc'></span>

<h3>Description</h3>

<p><code>csc</code> creates a customized covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmec">mmec</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  csc(x, mm, thetaC, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csc_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="csc_+3A_mm">mm</code></td>
<td>
<p>customized variance-covariance structure for the levels of the random effect.</p>
</td></tr>
<tr><td><code id="csc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional symmetric matrix for constraints in the variance-covariance components. The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define how the variance-covariance components should be estimated:
</p>
<p>0: component will not be estimated
</p>
<p>1: component will be estimated and constrained to be positive
</p>
<p>2: component will be estimated and unconstrained
</p>
<p>3: component will be fixed to the value provided in the theta argument
</p>
</td></tr>
<tr><td><code id="csc_+3A_theta">theta</code></td>
<td>
<p>an optional symmetric matrix for initial values of the variance-covariance components. When providing customized values, these values should be scaled with respect to the original variance. For example, to provide an initial value of 1 to a given variance component, theta would be built as:
</p>
<p>theta = matrix( 1 / var(response) ) 
</p>
<p>The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values will be calculated as:
</p>
<p>theta = diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm))
</p>
<p>where mm is the incidence matrix for the factor 'x'.
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>csc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
csc(x,matrix(1,5,5))
</code></pre>

<hr>
<h2 id='csr'>customized covariance structure</h2><span id='topic+csr'></span>

<h3>Description</h3>

<p><code>csr</code> creates a customized covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmer">mmer</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  csr(x, mm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csr_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="csr_+3A_mm">mm</code></td>
<td>
<p>customized variance-covariance structure for the levels of the random effect.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>csr</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
csr(x,matrix(1,5,5))
</code></pre>

<hr>
<h2 id='D.mat'>
Dominance relationship matrix
</h2><span id='topic+D.mat'></span>

<h3>Description</h3>

<p>C++ implementation of the dominance matrix. Calculates the realized dominance relationship matrix. Can help to increase the prediction accuracy when 2 conditions are met; 1) The trait has intermediate to high heritability, 2) The population contains a big number of individuals that are half or full sibs (HS &amp; FS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.mat(X,nishio=TRUE,min.MAF=0,return.imputed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D.mat_+3A_x">X</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> lines and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are allowed.
</p>
</td></tr>
<tr><td><code id="D.mat_+3A_nishio">nishio</code></td>
<td>

<p>If TRUE Nishio ans Satoh. (2014), otherwise Su et al. (2012). See references.
</p>
</td></tr>
<tr><td><code id="D.mat_+3A_min.maf">min.MAF</code></td>
<td>

<p>Minimum minor allele frequency. The D matrix is not sensitive to rare alleles, so by default only monomorphic markers are removed.
</p>
</td></tr>
<tr><td><code id="D.mat_+3A_return.imputed">return.imputed</code></td>
<td>

<p>When TRUE, the imputed marker matrix is returned.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additive marker coefficients will be used to compute dominance coefficients as: Xd = 1-abs(X) for diploids.
</p>
<p>For nishio method: the marker matrix is centered by subtracting column means <code class="reqn">M= Xd - ms</code> where ms is the column means. Then <code class="reqn">A=M M'/c</code>, where <code class="reqn">c = 2 \sum_k {p_k (1-p_k)}</code>.
</p>
<p>For su method: the marker matrix is normalized by subtracting row means <code class="reqn">M= Xd - 2pq</code> where 2pq is the product of allele frequencies times 2. Then <code class="reqn">A=M M'/c</code>, where <code class="reqn">c = 2 \sum_k {2pq_k (1-2pq_k)}</code>.
</p>


<h3>Value</h3>

<p>If return.imputed = FALSE, the <code class="reqn">n \times n</code> additive relationship matrix is returned.
</p>
<p>If return.imputed = TRUE, the function returns a list containing
</p>

<dl>
<dt>$D</dt><dd><p>the D matrix</p>
</dd>
<dt>$imputed</dt><dd><p>the imputed marker matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Nishio M and Satoh M. 2014. Including Dominance Effects in the Genomic BLUP Method for Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792
</p>
<p>Su G, Christensen OF, Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### EXAMPLE 1
####=========================================####
####random population of 200 lines with 1000 markers
X &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  X[i,] &lt;- sample(c(-1,0,0,1), size=1000, replace=TRUE)
}

D &lt;- D.mat(X)

</code></pre>

<hr>
<h2 id='dfToMatrix'>data frame to matrix</h2><span id='topic+dfToMatrix'></span>

<h3>Description</h3>

<p>This function takes a matrix that is in data frame format and transforms it into a matrix. Other packages that allows you to obtain an additive relationship matrix from a pedigree is the 'pedigreemm' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dfToMatrix(x, row="Row",column="Column",
             value="Ainverse", returnInverse=FALSE, 
             bend=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfToMatrix_+3A_x">x</code></td>
<td>
<p>ginv element, output from the Ainverse function.</p>
</td></tr>
<tr><td><code id="dfToMatrix_+3A_row">row</code></td>
<td>
<p>name of the column in x that indicates the row in the original relationship matrix.</p>
</td></tr>
<tr><td><code id="dfToMatrix_+3A_column">column</code></td>
<td>
<p>name of the column in x that indicates the column in the original relationship matrix.</p>
</td></tr>
<tr><td><code id="dfToMatrix_+3A_value">value</code></td>
<td>
<p>name of the column in x that indicates the value for a given row and column in the original relationship matrix.</p>
</td></tr>
<tr><td><code id="dfToMatrix_+3A_returninverse">returnInverse</code></td>
<td>
<p>a TRUE/FALSE value indicating if the inverse of the x matrix should be computed once the data frame x is converted into a matrix.</p>
</td></tr>
<tr><td><code id="dfToMatrix_+3A_bend">bend</code></td>
<td>
<p>a numeric value to add to the diagonal matrix in case matrix is singular for inversion.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>K</code></td>
<td>
<p> pedigree transformed in a relationship matrix.</p>
</td></tr>
<tr><td><code>Kinv</code></td>
<td>
<p> inverse of the pedigree transformed in a relationship matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Matrix)
m &lt;- matrix(1:9,3,3)
m &lt;- tcrossprod(m)

mdf &lt;- as.data.frame(as.table(m))
mdf

dfToMatrix(mdf, row = "Var1", column = "Var2", 
            value = "Freq",returnInverse=FALSE )


</code></pre>

<hr>
<h2 id='dsc'>diagonal covariance structure</h2><span id='topic+dsc'></span>

<h3>Description</h3>

<p><code>dsc</code> creates a diagonal covariance structure for the levels of the random effect  to be used with the <code><a href="#topic+mmec">mmec</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dsc(x, thetaC=NULL, theta=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsc_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="dsc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional symmetric matrix for constraints in the variance-covariance components. The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define how the variance-covariance components should be estimated:
</p>
<p>0: component will not be estimated
</p>
<p>1: component will be estimated and constrained to be positive
</p>
<p>2: component will be estimated and unconstrained
</p>
<p>3: component will be fixed to the value provided in the theta argument
</p>
</td></tr>
<tr><td><code id="dsc_+3A_theta">theta</code></td>
<td>
<p>an optional symmetric matrix for initial values of the variance-covariance components. When providing customized values, these values should be scaled with respect to the original variance. For example, to provide an initial value of 1 to a given variance component, theta would be built as:
</p>
<p>theta = matrix( 1 / var(response) )
</p>
<p>The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values will be calculated as:
</p>
<p>diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm))
</p>
<p>where mm is the incidence matrix for the factor 'x'.
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>See the function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>dsc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
dsc(x)
## how to use the theta and thetaC arguments:
# data(DT_example)
# DT &lt;- DT_example
# theta &lt;- diag(3)*2; theta # initial VCs
# thetaC &lt;- diag(3)*3; thetaC # fixed VCs
# ans1 &lt;- mmec(Yield~Env,
#              random= ~ vsc( dsc(Env,theta = theta,thetaC = thetaC),isc(Name) ),
#              rcov= ~ units,
#              data=DT)
# summary(ans1)$varcomp

</code></pre>

<hr>
<h2 id='dsr'>diagonal covariance structure</h2><span id='topic+dsr'></span>

<h3>Description</h3>

<p><code>dsr</code> creates a diagonal covariance structure for the levels of the random effect  to be used with the <code><a href="#topic+mmer">mmer</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dsr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsr_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>See the function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>dsr</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
dsr(x)
</code></pre>

<hr>
<h2 id='DT_augment'>
DT_augment design example.
</h2><span id='topic+DT_augment'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for one trait evaluated in the experimental design known as augmented design. This model allows to obtain BLUPs for genotypes that are unreplicated by dividing the field in blocks and replicating 'check genotypes' in the blocks and unreplicated genotypes randomly within the blocks. The presence of check genotypes (usually cultivars) allows the adjustment of unreplicated genotypes.
</p>
<p>The column 'Plot' indicates the number of plot in the field
The column 'Entry' is a numeric value for each entry
The colum 'Genotype' is the name of the individual
The column 'Block' is the replicate or big block
The column TSW is the response variable
The column check is an indicator column for checks (0) and non-checks (1)
The column Check.Gen is an indicator column for checks (89,90,91) and non-checks (999)
</p>
<p>The dataset has 3 unique checks (Ross=89, MF183=90, Starlight=91) and 50 entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_augment")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_augment&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># ###=========================================####
# ### AUGMENTED DESIGN EXAMPLE
# ###=========================================####
# data(DT_augment)
# DT &lt;- DT_augment
# head(DT)
# ####=========================================####
# #### fit the mixed model and check summary
# ####=========================================####
# mix1 &lt;- mmer(TSW ~ Check.Gen,
#              random = ~ Block + Genotype:Check,
#              data=DT)
# summary(mix1)$varcomp
# 
# mix2 &lt;- mmec(TSW ~ Check.Gen,
#              random = ~ Block + Genotype:Check,
#              data=DT)
# summary(mix2)$varcomp

</code></pre>

<hr>
<h2 id='DT_btdata'>
Blue Tit Data for a Quantitative Genetic Experiment
</h2><span id='topic+DT_btdata'></span>

<h3>Description</h3>

<p>a data frame with 828 rows and 7 columns, with variables tarsus length (tarsus) and colour (back) measured on 828 individuals (animal). The mother of each is also recorded (dam) together with the foster nest (fosternest) in which the chicks were reared. The date on which the first egg in each nest hatched (hatchdate) is recorded together with the sex (sex) of the individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_btdata")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_btdata&quot;
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ####=========================================####
# #### For CRAN time limitations most lines in the 
# #### examples are silenced with one '#' mark, 
# #### remove them and run the examples
# ####=========================================####
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 1
# #### simple example
# ####=========================================####
# ####=========================================####
# data(DT_btdata)
# DT &lt;- DT_btdata
# head(DT)
# mix4 &lt;- mmer(tarsus ~ sex,
#              random = ~ dam + fosternest,
#              rcov=~units,
#              data = DT)
# summary(mix4)$varcomp
# 
# mix5 &lt;- mmec(tarsus ~ sex,
#              random = ~ dam + fosternest,
#              rcov=~units,
#              data = DT)
# summary(mix5)$varcomp
# 
# ####=========================================####
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 2
# #### more complex multivariate model
# ####=========================================####
# ####=========================================####
# data(DT_btdata)
# DT &lt;- DT_btdata
# mix3 &lt;- mmer(cbind(tarsus, back) ~ sex,
#                 random = ~ vsr(dam) + vsr(fosternest),
#                 rcov= ~ vsr(units, Gtc=diag(2)),
#                 data = DT)
# summary(mix3)
# #### calculate the genetic correlation
# cov2cor(mix3$sigma$`u:dam`)
# cov2cor(mix3$sigma$`u:fosternest`)

</code></pre>

<hr>
<h2 id='DT_cornhybrids'>
Corn crosses and markers
</h2><span id='topic+DT_cornhybrids'></span><span id='topic+DTi_cornhybrids'></span><span id='topic+GT_cornhybrids'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for plant height and grain yield for 100 out of 400 possible hybrids originated from 40 inbred lines belonging to 2 heterotic groups, 20 lines in each, 1600 rows exist for the 400 possible hybrids evaluated in 4 locations but only 100 crosses have phenotypic information.  The purpose of this data is to show how to predict the other 300 crosses.
</p>
<p>The data contains 3 elements. The first is the phenotypic data and the parent information for each cross evaluated in the 4 locations. 1200 rows should have missing data but the 100 crosses performed were chosen to be able to estimate the GCA and SCA effects of everything.
</p>
<p>The second element of the data set is the phenotypic data and other relevant information for the 40.
</p>
<p>The third element is the genomic relationship matrix for the 40 inbred lines originated from 511 SNP markers and calculated using the A.mat function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_cornhybrids")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_cornhybrids&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a corn study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ####=========================================####
# #### For CRAN time limitations most lines in the 
# #### examples are silenced with one '#' mark, 
# #### remove them and run the examples using
# #### command + shift + C |OR| control + shift + C
# ####=========================================####
# 
# data(DT_cornhybrids)
# DT &lt;- DT_cornhybrids
# DTi &lt;- DTi_cornhybrids
# GT &lt;- GT_cornhybrids
# hybrid2 &lt;- DT # extract cross data
# A &lt;- GT
# K1 &lt;- A[levels(hybrid2$GCA1), levels(hybrid2$GCA1)]; dim(K1)
# K2 &lt;- A[levels(hybrid2$GCA2), levels(hybrid2$GCA2)]; dim(K2)
# S &lt;- kronecker(K1, K2) ; dim(S)
# rownames(S) &lt;- colnames(S) &lt;- levels(hybrid2$SCA)
# 
# ans &lt;- mmer(Yield ~ Location,
#              random = ~ vsr(GCA1,Gu=K1) + vsr(GCA2,Gu=K2), # + vsr(SCA,Gu=S),
#              rcov=~units,
#              data=hybrid2)
# summary(ans)$varcomp
# 
# ## mmec uses the inverse of the relationship matrix
# K1i &lt;- as(solve(K1 + diag(1e-4,ncol(K1),ncol(K1))), Class="dgCMatrix")
# K2i &lt;- as(solve(K2 + diag(1e-4,ncol(K2),ncol(K2))), Class="dgCMatrix")
# Si &lt;- as(solve(S + diag(1e-4,ncol(S),ncol(S))), Class="dgCMatrix")
# ans2 &lt;- mmec(Yield ~ Location,
#             random = ~ vsc(isc(GCA1),Gu=K1i) + vsc(isc(GCA2),Gu=K2i), # + vsc(isc(SCA),Gu=Si),
#             rcov=~units,
#             data=hybrid2)
# summary(ans2)$varcomp


</code></pre>

<hr>
<h2 id='DT_cpdata'>
Genotypic and Phenotypic data for a CP population
</h2><span id='topic+DT_cpdata'></span><span id='topic+GT_cpdata'></span><span id='topic+MP_cpdata'></span>

<h3>Description</h3>

<p>A CP population or F1 cross is the designation for a cross between 2 highly heterozygote individuals; i.e. humans, fruit crops, bredding populations in recurrent selection.
</p>
<p>This dataset contains phenotpic data for 363 siblings for an F1 cross. These are averages over 2 environments evaluated for 4 traits; color, yield, fruit average weight, and firmness. The columns in the CPgeno file are the markers whereas the rows are the individuals. The CPpheno data frame contains the measurements for the 363 siblings, and as mentioned before are averages over 2 environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_cpdata")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_cpdata&quot;
</p>


<h3>Source</h3>

<p>This data was simulated for fruit breeding applications.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ####=========================================####
# #### For CRAN time limitations most lines in the
# #### examples are silenced with one '#' mark,
# #### remove them and run the examples using
# #### command + shift + C |OR| control + shift + C
# ####=========================================####
#
# data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix
# A &lt;- A.mat(GT) # additive relationship matrix
# #### look at the data and fit the model
# head(DT)
# mix1 &lt;- mmer(Yield~1,
#               random=~vsr(id,Gu=A)
#                       + Rowf + Colf,
#               rcov=~units,
#               data=DT)
# summary(mix1)$varcomp
#
# ## mmec uses the inverse of the relationship matrix
# Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
# mix2 &lt;- mmec(Yield~1,
#              random=~vsc(isc(id),Gu=Ai)
#              + Rowf + Colf,
#              rcov=~units,
#              data=DT)
# summary(mix2)$varcomp
#
# vg &lt;- summary(mix2)$varcomp[1,1] # genetic variance
# G &lt;- A*vg # genetic variance-covariance
# Ci &lt;- mix2$Ci # coefficient matrix
# ind &lt;- as.vector(mix2$partitions$`vsc(isc(id), Gu = Ai)`)
# ind &lt;- seq(ind[1],ind[2])
# Ctt &lt;- Ci[ind,ind] # portion of Ci for genotypes
# R2 &lt;- (G - Ctt)/G # reliability matrix
# mean(diag(R2)) # average reliability of the trial
#
# ####====================####
# #### multivariate model ####
# ####     2 traits       ####
# ####====================####
# #### be patient take some time
# ans.m &lt;- mmer(cbind(Yield,color)~1,
#                random=~ vsr(id, Gu=A)
#                + vsr(Rowf,Gtc=diag(2))
#                + vsr(Colf,Gtc=diag(2)),
#                rcov=~ vsr(units),
#                data=DT)
# cov2cor(ans.m$sigma$`u:id`)

</code></pre>

<hr>
<h2 id='DT_example'>
Broad sense heritability calculation.
</h2><span id='topic+DT_example'></span><span id='topic+A_example'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 41 potato lines evaluated in 3 environments in an RCBD design. The phenotypic trait is tuber quality and we show how to obtain an estimate of DT_example for the trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_example")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_example&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
####=========================================####
#### EXAMPLES
#### Different models with sommer
####=========================================####

data(DT_example)
DT &lt;- DT_example
A &lt;- A_example
head(DT)

####=========================================####
#### Univariate homogeneous variance models  ####
####=========================================####

## Compound simmetry (CS) model
ans1 &lt;- mmer(Yield~Env,
             random= ~ Name + Env:Name,
             rcov= ~ units,
             data=DT)
summary(ans1)$varcomp

ans1b &lt;- mmec(Yield~Env,
             random= ~ Name + Env:Name,
             rcov= ~ units,
             data=DT)
summary(ans1b)$varcomp

# ####===========================================####
# #### Univariate heterogeneous variance models  ####
# ####===========================================####
# 
# ## Compound simmetry (CS) + Diagonal (DIAG) model
# ans2 &lt;- mmer(Yield~Env,
#              random= ~Name + vsr(dsr(Env),Name),
#              rcov= ~ vsr(dsr(Env),units),
#              data=DT)
# summary(ans2)
# 
# DT=DT[with(DT, order(Env)), ]
# ans2b &lt;- mmec(Yield~Env,
#              random= ~Name + vsc(dsc(Env),isc(Name)) +
#                       vsc(atc(Env, c("CA.2011") ),isc(Block)) ,
#              rcov= ~ vsc(dsc(Env),isc(units)),
#              data=DT)
# summary(ans2b)
# 
# ####==========================================####
# #### Multivariate homogeneous variance models ####
# ####==========================================####
# 
# ## Multivariate Compound simmetry (CS) model
# DT$EnvName &lt;- paste(DT$Env,DT$Name)
# ans4 &lt;- mmer(cbind(Yield, Weight) ~ Env,
#               random= ~ vsr(Name) + vsr(EnvName),
#               rcov= ~ vsr(units),
#               data=DT)
# summary(ans4)

</code></pre>

<hr>
<h2 id='DT_expdesigns'>
Data for different experimental designs
</h2><span id='topic+DT_expdesigns'></span>

<h3>Description</h3>

<p>The following data is a list containing data frames for different type of experimental designs relevant in plant breeding:
</p>
<p>1) Augmented designs (2 examples)
</p>
<p>2) Incomplete block designs (1 example)
</p>
<p>3) Split plot design (2 examples)
</p>
<p>4) Latin square designs (1 example)
</p>
<p>5) North Carolina designs I,II and III
</p>
<p>How to fit each is shown at the Examples section. This may help you get introduced to experimental designs relevant to plant breeding. Good luck.
</p>


<h3>Format</h3>

<p>Different based on the design.
</p>


<h3>Source</h3>

<p>Datasets and more detail about them can be found in the agricolae package. Here we just show the datasets and how to analyze them using the <code><a href="#topic+sommer">sommer</a></code> package.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# #### =================================== ####
# #### ===== Augmented Block Design 1 ==== ####
# #### =================================== ####
# data(DT_expdesigns)
# DT &lt;- DT_expdesigns
# names(DT)
# data1 &lt;- DT$au1
# head(data1)
# ## response variable: "yield"
# ## check indicator: "entryc" ('nc' for all unreplicated, but personal.name for checks)
# ## blocking factor: "block"
# ## treatments, personal names for replicated and non-replicated: "trt"
# ## check no check indicator: "new"
# mix1 &lt;- mmer(yield~entryc,
#              random=~block+trt,
#              rcov=~units, tolpar = 1e-6,
#              data=data1)
# summary(mix1)$varcomp
# 
# mix1b &lt;- mmec(yield~entryc,
#              random=~block+trt,
#              rcov=~units, tolParConv = 1e-6,
#              data=data1)
# summary(mix1b)$varcomp

</code></pre>

<hr>
<h2 id='DT_fulldiallel'>
Full diallel data for corn hybrids
</h2><span id='topic+DT_fulldiallel'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 36 winter bean hybrids, coming from a full diallel design and evaluated for 9 traits. The column male and female origin columns are included as well. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_fulldiallel")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_fulldiallel&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a winter bean study and originally included in the agridat package.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the
#### examples are silenced with one '#' mark,
#### remove them and run the examples
####=========================================####
data(DT_fulldiallel)
DT &lt;- DT_fulldiallel
head(DT)
mix &lt;- mmer(stems~1, random=~female+male, data=DT)
summary(mix)

mixb &lt;- mmec(stems~1, random=~female+male, data=DT)
summary(mixb)$varcomp

####=========================================####
####=========================================####
#### Multivariate model example
####=========================================####
####=========================================####

data(DT_fulldiallel)
DT &lt;- DT_fulldiallel
head(DT)

mix &lt;- mmer(cbind(stems,pods,seeds)~1,
             random=~vsr(female) + vsr(male),
             rcov=~vsr(units),
             data=DT)
summary(mix)
#### genetic variance covariance
cov2cor(mix$sigma$`u:female`)
cov2cor(mix$sigma$`u:male`)
cov2cor(mix$sigma$`u:units`)

</code></pre>

<hr>
<h2 id='DT_gryphon'>
Gryphon data from the Journal of Animal Ecology
</h2><span id='topic+DT_gryphon'></span><span id='topic+A_gryphon'></span><span id='topic+P_gryphon'></span>

<h3>Description</h3>

<p>This is a dataset that was included in the Journal of animal ecology by Wilson et al. (2010; see references) to help users understand how to use mixed models with animal datasets with pedigree data. 
</p>
<p>The dataset contains 3 elements:
</p>
<p>gryphon; variables indicating the animal, the mother of the animal, sex of the animal, and two quantitative traits named 'BWT' and 'TARSUS'.
</p>
<p>pedi; dataset with 2 columns indicating the sire and the dam of the animals contained in the gryphon dataset.
</p>
<p>A; additive relationship matrix formed using the 'getA()' function used over the pedi dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_gryphon")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_gryphon&quot;
</p>


<h3>Source</h3>

<p>This data comes from the Journal of Animal Ecology. Please, if using this data cite Wilson et al. publication. If using our mixed model solver please cite Covarrubias' publication.
</p>


<h3>References</h3>

<p>Wilson AJ, et al. (2010) An ecologist's guide to the animal model. Journal of Animal Ecology 79(1): 13-26.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
# data(DT_gryphon)
# DT &lt;- DT_gryphon
# A &lt;- A_gryphon
# P &lt;- P_gryphon
# #### look at the data
# head(DT)
# #### fit the model with no fixed effects (intercept only)
# mix1 &lt;- mmer(BWT~1,
#              random=~vsr(ANIMAL,Gu=A),
#              rcov=~units,
#              data=DT)
# summary(mix1)$varcomp
# 
# ## mmec uses the inverse of the relationship matrix
# Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
# mix1b &lt;- mmec(BWT~1,
#              random=~vsc(isc(ANIMAL),Gu=Ai),
#              rcov=~units, tolParConv = 1e-5,
#              data=DT)
# summary(mix1b)$varcomp
# 
# #### fit the multivariate model with no fixed effects (intercept only)
# mix2 &lt;- mmer(cbind(BWT,TARSUS)~1,
#              random=~vsr(ANIMAL,Gu=A),
#              rcov=~vsr(units),
#              na.method.Y = "include2",
#              data=DT)
# summary(mix2)
# cov2cor(mix2$sigma$`u:ANIMAL`)
# cov2cor(mix2$sigma$`u:units`)

</code></pre>

<hr>
<h2 id='DT_h2'>
Broad sense heritability calculation.
</h2><span id='topic+DT_h2'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 41 potato lines evaluated in 5 locations across 3 years in an RCBD design. The phenotypic trait is tuber quality and we show how to obtain an estimate of DT_h2 for the trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_h2")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_h2&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a potato study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
data(DT_h2)
DT &lt;- DT_h2
head(DT)
####=========================================####
#### fit the mixed model (very heavy model)
####=========================================####
# ans1 &lt;- mmer(y~Env,
#               random=~vsr(dsr(Env),Name) + vsr(dsr(Env),Block),
#               rcov=~vsr(dsr(Env),units),
#               data=DT)
# summary(ans1)$varcomp
# 
# DT=DT[with(DT, order(Env)), ]
# ans1b &lt;- mmec(y~Env,
#              random=~vsc(dsc(Env),isc(Name)) + vsc(dsc(Env),isc(Block)),
#              rcov=~vsc(dsc(Env),isc(units)),
#              data=DT)
# summary(ans1b)$varcomp

</code></pre>

<hr>
<h2 id='DT_halfdiallel'>
half diallel data for corn hybrids
</h2><span id='topic+DT_halfdiallel'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 21 corn hybrids, with 2 technical repetitions, coming from a half diallel design and evaluated for sugar content. The column geno indicates the hybrid and male and female origin columns are included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_halfdiallel")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_halfdiallel&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a corn study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

data("DT_halfdiallel")
DT &lt;- DT_halfdiallel
head(DT)
DT$femalef &lt;- as.factor(DT$female)
DT$malef &lt;- as.factor(DT$male)
DT$genof &lt;- as.factor(DT$geno)

A &lt;- diag(7); colnames(A) &lt;- rownames(A) &lt;- 1:7;A # if you want to provide a covariance matrix
#### model using overlay
modh &lt;- mmer(sugar~1, 
             random=~vsr(overlay(femalef,malef, sparse = FALSE), Gu=A) 
             + genof,
             data=DT)
summary(modh)$varcomp

Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
modhb &lt;- mmec(sugar~1, 
             random=~vsc(isc(overlay(femalef,malef, sparse = TRUE)), Gu=Ai) 
             + genof,
             data=DT)
summary(modhb)$varcomp


</code></pre>

<hr>
<h2 id='DT_ige'>
Data to fit indirect genetic effects.
</h2><span id='topic+DT_ige'></span><span id='topic+A_ige'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 98 individuals where they are measured with the purpose of identifying the effect of the neighbour in a focal individual. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_ige")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_ige&quot;
</p>


<h3>Source</h3>

<p>This data was masked from a shared study.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
####=========================================####
#### EXAMPLES
#### Different models with sommer
####=========================================####

data(DT_ige)
DT &lt;- DT_ige
# # Indirect genetic effects model without covariance between DGE and IGE
# modIGE &lt;- mmec(trait ~ block, dateWarning = FALSE,
#                random = ~ focal + neighbour,
#                rcov = ~ units, nIters=100,
#               data = DT)
# summary(modIGE)$varcomp
# pmonitor(modIGE)
# 
# # Indirect genetic effects model with covariance between DGE and IGE using relationship matrices
# modIGE &lt;- mmec(trait ~ block, dateWarning = FALSE,
#                random = ~ covc( vsc(isc(focal)), vsc(isc(neighbour)) ),
#                rcov = ~ units, nIters=100,
#               data = DT)
# summary(modIGE)$varcomp
# pmonitor(modIGE)
# 
# # form relationship matrix
# Ai &lt;- as( solve(A_ige + diag(1e-5, nrow(A_ige),nrow(A_ige) )), Class="dgCMatrix")
# # Indirect genetic effects model with covariance between DGE and IGE using relationship matrices
# modIGE &lt;- mmec(trait ~ block, dateWarning = FALSE,
#                random = ~ covc( vsc(isc(focal), Gu=Ai), vsc(isc(neighbour), Gu=Ai) ),
#                rcov = ~ units, nIters=100,
#               data = DT)
# summary(modIGE)$varcomp
# pmonitor(modIGE)


</code></pre>

<hr>
<h2 id='DT_legendre'>
Simulated data for random regression
</h2><span id='topic+DT_legendre'></span>

<h3>Description</h3>

<p>A data frame with 4 columns; SUBJECT, X, Xf and Y to show how to use the Legendre polynomials in the mmer function using a numeric variable X and a response variable Y. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_legendre")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_legendre&quot;
</p>


<h3>Source</h3>

<p>This data was simulated for fruit breeding applications.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
# you need to install the orthopolynom library to do random regression models
# library(orthopolynom)
# data(DT_legendre)
# DT &lt;- DT_legendre
# mRR2&lt;-mmer(Y~ 1 + Xf
#            , random=~ vsr(usr(leg(X,1)),SUBJECT)
#            , rcov=~vsr(units)
#            , data=DT)
# summary(mRR2)$varcomp
# 
# mRR2b&lt;-mmec(Y~ 1 + Xf
#            , random=~ vsc(usc(leg(X,1)),isc(SUBJECT))
#            , rcov=~vsc(isc(units))
#            , data=DT)
# summary(mRR2b)$varcomp

</code></pre>

<hr>
<h2 id='DT_mohring'>
Full diallel data for corn hybrids
</h2><span id='topic+DT_mohring'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 36 winter bean hybrids, coming from a full diallel design and evaluated for 9 traits. The column male and female origin columns are included as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_mohring")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_mohring&quot;
</p>


<h3>Source</h3>

<p>This data was generated by a winter bean study and originally included in the agridat package.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ####=========================================####
# #### For CRAN time limitations most lines in the
# #### examples are silenced with one '#' mark,
# #### remove them and run the examples
# ####=========================================####
# data(DT_mohring)
# DT &lt;- DT_mohring
# head(DT)
# DT2 &lt;- add.diallel.vars(DT,par1="Par1", par2="Par2")
# head(DT2)
# # is.cross denotes a hybrid (1)
# # is.self denotes an inbred (1)
# # cross.type denotes one way (-1, e.g. AxB) and reciprocal (1, e.g., BxA) and no cross (0)
# # cross.id denotes the name of the cross (same name for direct &amp; reciprocal)
#
# # GRIFFING MODEL 2 with reciprocal effects ###########################
# mod1h &lt;- mmer(Ftime ~ 1, data=DT2,
#               random = ~ Block
#               # GCA male &amp; female overlayed
#               + overlay(Par1, Par2)
#               # SCA effects (includes cross and selfs)
#               + cross.id
#               # SCAR reciprocal effects (remaining variance in crosses; 
#               # if zero there's no reciprocal effects)
#               + cross.id:cross.type)
# summary(mod1h)$varcomp
#
# mod1hb &lt;- mmec(Ftime ~ 1, data=DT2,
#                random = ~ Block
#                # GCA male &amp; female overlayed
#                + vsc(isc(overlay(Par1, Par2)))
#                # SCA effects (includes cross and selfs)
#                + cross.id
#                # SCAR reciprocal effects (remaining variance in crosses; 
#                # if zero there's no reciprocal effects)
#                + vsc(dsc(cross.type), isc(cross.id)) )
# summary(mod1hb)$varcomp
#
# ##                                    VarComp VarCompSE   Zratio
# ## Block.Ftime-Ftime                  0.00000   9.32181 0.000000
# ## overlay(Par1, Par2).Ftime-Ftime 1276.73089 750.17269 1.701916
# ## cross.id.Ftime-Ftime            1110.99090 330.16921 3.364914
# ## cross.id:cross.type.Ftime-Ftime   66.02295  49.26876 1.340057
# ## units.Ftime-Ftime                418.47949  74.56442 5.612321
# ##
# # GRIFFING MODEL 2, no reciprocal effects ##############################
# mod1h &lt;- mmer(Ftime ~ Block + is.cross, data=DT2,
#               random = ~
#                # GCA effect for all (hybrids and inbreds)
#                 overlay(Par1, Par2)
#               # GCA effect (calculated only in hybrids; remaining variance)
#               + overlay(Par1, Par2):is.cross
#               # SCA effect (calculated in hybrids only)
#               + cross.id:is.cross)
# summary(mod1h)$varcomp
#
# mod1h &lt;- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 50,
#               random = ~
#                 # GCA effects for all (hybrids and inbreds)
#                 vsc(isc(overlay(Par1, Par2)))
#               # GCA effect (calculated only in hybrids; remaining variance)
#               + vsc(isc(is.cross),isc(overlay(Par1, Par2)))
#               # SCA effect (calculated in hybrids only)
#               + vsc(isc(is.cross), isc(cross.id))
#               )
# summary(mod1h)$varcomp
#
# ##                                           VarComp  VarCompSE   Zratio
# ## overlay(Par1, Par2).Ftime-Ftime          2304.1781 1261.63193 1.826347
# ## overlay(Par1, Par2):is.cross.Ftime-Ftime  613.6040  402.74347 1.523560
# ## cross.id:is.cross.Ftime-Ftime             340.7030  148.56225 2.293335
# ## units.Ftime-Ftime                         501.6275   74.36075 6.745864
# ##
# # GRIFFING MODEL 3, no reciprocal effects ###############################
# mod1h &lt;- mmer(Ftime ~ Block + is.cross, data=DT2,
#               random = ~
#                 # GCAC (only for hybrids)
#                 overlay(Par1, Par2):is.cross
#               # male GCA (only for inbreds)
#               + Par1:is.self
#               # SCA (for hybrids only)
#               + cross.id:is.cross)
# summary(mod1h)$varcomp
#
# mod1h &lt;- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 100,
#               random = ~
#                 # GCAC (only for hybrids)
#                 vsc(isc(is.cross),isc(overlay(Par1, Par2)))
#               # male GCA (only for inbreds)
#               + vsc(isc(is.self),isc(Par1))
#               # SCA (for hybrids only)
#               + vsc(isc(is.cross), isc(cross.id))
#               )
# summary(mod1h)$varcomp
# ##                                           VarComp  VarCompSE   Zratio
# ## overlay(Par1, Par2):is.cross.Ftime-Ftime  927.7895  537.91218 1.724797
# ## Par1:is.self.Ftime-Ftime                 9960.9247 5456.58188 1.825488
# ## cross.id:is.cross.Ftime-Ftime             341.4567  148.53667 2.298804
# ## units.Ftime-Ftime                         498.5974   73.92066 6.745035
# ##
# # GRIFFING MODEL 2, with reciprocal effects #############################
# # In Mohring: mixed model 3 reduced
# mod1h &lt;- mmer(Ftime ~ Block + is.cross, data=DT2,
#               random = ~
#                 # GCAC (for hybrids only)
#                 overlay(Par1, Par2):is.cross
#               # male GCA (for selfs only)
#               + Par1:is.self
#               # SCA (for hybrids only)
#               + cross.id:is.cross
#               # SCAR reciprocal effects (remaning SCA variance)
#               + cross.id:cross.type)
# summary(mod1h)$varcomp
#
# mod1h &lt;- mmec(Ftime ~ Block + is.cross, data=DT2, nIters = 100,
#               random = ~
#                 # GCAC (for hybrids only)
#                 vsc(isc(is.cross),isc(overlay(Par1, Par2)))
#               # male GCA (for selfs only)
#               + vsc(isc(is.self),isc(Par1))
#               # SCA (for hybrids only)
#               + vsc(isc(is.cross), isc(cross.id))
#               # SCAR reciprocal effects (remaning SCA variance)
#               + vsc(isc(cross.type), isc(cross.id))
#               )
# summary(mod1h)$varcomp
#
# ##                                             VarComp  VarCompSE   Zratio
# ## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.78742  537.89981 1.724833
# ## Par1:is.self.Ftime-Ftime                 10001.78854 5456.47578 1.833013
# ## cross.id:is.cross.Ftime-Ftime              361.89712  148.54264 2.436318
# ## cross.id:cross.type.Ftime-Ftime             66.43695   49.24492 1.349113
# ## units.Ftime-Ftime                          416.82960   74.27202 5.612203
# ##
# # GRIFFING MODEL 3, with RGCA + RSCA ####################################
# # In Mohring: mixed model 3
# mod1h &lt;- mmer(Ftime ~ Block + is.cross, data=DT2,
#               random = ~
#                 # GCAC (for hybrids only)
#                 overlay(Par1,Par2):is.cross
#               # RGCA: exclude selfs (to identify reciprocal GCA effects)
#               + overlay(Par1,Par2):cross.type
#               # male GCA (for selfs only)
#               + Par1:is.self
#               # SCA (for hybrids only)
#               + cross.id:is.cross
#               # SCAR: exclude selfs (if zero there's no reciprocal SCA effects)
#               + cross.id:cross.type)
# summary(mod1h)$varcomp
#
# mod1h &lt;- mmec(Ftime ~ Block + is.cross, data=DT2,nIters = 100,
#               random = ~
#                 # GCAC (for hybrids only)
#                 vsc(isc(is.cross),isc(overlay(Par1, Par2)))
#               # RGCA: exclude selfs (to identify reciprocal GCA effects)
#               + vsc(isc(cross.type),isc(overlay(Par1, Par2)))
#               # male GCA (for selfs only)
#               + vsc(isc(is.self),isc(Par1))
#               # SCA (for hybrids only)
#               + vsc(isc(is.cross), isc(cross.id))
#               # SCAR: exclude selfs (if zero there's no reciprocal SCA effects)
#               + vsc(isc(cross.type), isc(cross.id))
#               )
# summary(mod1h)$varcomp
#
# ##                                            VarComp  VarCompSE    Zratio
# ## overlay(Par1, Par2):is.cross.Ftime-Ftime   927.7843  537.88164 1.7248857
# ## Par1:is.self.Ftime-Ftime                 10001.7570 5456.30125 1.8330654
# ## cross.id:is.cross.Ftime-Ftime              361.8958  148.53670 2.4364068
# ## overlay(Par1, Par2):cross.type.Ftime-Ftime  17.9799   19.92428 0.9024114
# ## cross.id:cross.type.Ftime-Ftime             30.9519   46.43908 0.6665054
# ## units.Ftime-Ftime                         416.09922  447.2101 0.93043333



</code></pre>

<hr>
<h2 id='DT_polyploid'>
Genotypic and Phenotypic data for a potato polyploid population
</h2><span id='topic+DT_polyploid'></span><span id='topic+GT_polyploid'></span><span id='topic+MP_polyploid'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 18 traits measured in 187 individuals from a potato diversity panel. In addition contains genotypic data for 221 individuals genotyped with 3522 SNP markers. Please if using this data for your own research make sure you cite Rosyara's (2015) publication (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_polyploid")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_polyploid&quot;
</p>


<h3>Source</h3>

<p>This data was extracted from Rosyara (2016).
</p>


<h3>References</h3>

<p>If using this data for your own research please cite:
</p>
<p>Rosyara Umesh R., Walter S. De Jong, David S. Douches, Jeffrey B. Endelman. Software for genome-wide association studies in autopolyploids and its application to potato. The Plant Genome 2015.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####

data(DT_polyploid)
# DT &lt;- DT_polyploid
# GT &lt;- GT_polyploid
# MP &lt;- MP_polyploid
# ####=========================================####
# ####### convert markers to numeric format
# ####=========================================####
# numo &lt;- atcg1234(data=GT, ploidy=4);
# numo$M[1:5,1:5];
# numo$ref.allele[,1:5]
# 
# ###=========================================####
# ###### plants with both genotypes and phenotypes
# ###=========================================####
# common &lt;- intersect(DT$Name,rownames(numo$M))
# 
# ###=========================================####
# ### get the markers and phenotypes for such inds
# ###=========================================####
# marks &lt;- numo$M[common,]; marks[1:5,1:5]
# DT2 &lt;- DT[match(common,DT$Name),];
# DT2 &lt;- as.data.frame(DT2)
# DT2[1:5,]
# 
# ###=========================================####
# ###### Additive relationship matrix, specify ploidy
# ###=========================================####
# A &lt;- A.mat(marks)
# D &lt;- D.mat(marks)
# ###=========================================####
# ### run as mixed model
# ###=========================================####
# ans &lt;- mmer(tuber_shape~1,
#             random=~vsr(Name, Gu=A),
#             data=DT2)
# summary(ans)$varcomp
# 
# Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
# ansb &lt;- mmec(tuber_shape~1,
#             random=~vsc(isc(Name), Gu=Ai),
#             data=DT2)
# summary(ansb)$varcomp
# 

</code></pre>

<hr>
<h2 id='DT_rice'>Rice lines dataset</h2><span id='topic+DT_rice'></span><span id='topic+GT_rice'></span><span id='topic+GTn_rice'></span>

<h3>Description</h3>

<p>Information from a collection of 413 rice lines.  The DT_rice data set is from 
Rice Diversity Org. Program. The lines are genotyped with 36,901 SNP markers and phenotyped for more than 30 traits. This data set was included in the package to play with it. If using it for your research make sure you cite the original publication from Zhao et al.(2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(DT_rice)
</code></pre>


<h3>Format</h3>

<p>RicePheno contains the phenotypes
RiceGeno contains genotypes letter code
RiceGenoN contains the genotypes in numerical code using atcg1234 converter function
</p>


<h3>Source</h3>

<p>Rice Diversity Organization
http://www.ricediversity.org/data/index.cfm.
</p>


<h3>References</h3>

<p>Keyan Zhao, Chih-Wei Tung, Georgia C. Eizenga, Mark H. Wright, M. Liakat Ali, Adam H. Price, Gareth J. Norton, M. Rafiqul Islam, Andy Reynolds, Jason Mezey, Anna M. McClung, Carlos D. Bustamante &amp; Susan R. McCouch (2011). Genome-wide association mapping reveals a rich genetic architecture of complex traits in Oryza sativa. Nat Comm 2:467 DOI: 10.1038/ncomms1467, Published Online 13 Sep 2011.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
data(DT_rice)
# DT &lt;- DT_rice
# GT &lt;- GT_rice
# GTn &lt;- GTn_rice
# head(DT)
# M &lt;- atcg1234(GT)
# A &lt;- A.mat(M$M)
# mix &lt;- mmer(Protein.content~1,
#             random = ~vsr(geno, Gu=A) + geno,
#             rcov=~units,
#             data=DT)
# summary(mix)$varcomp
# 
# Ai &lt;- as(solve(A + diag(1e-6,ncol(A),ncol(A))), Class="dgCMatrix")
# mixb &lt;- mmec(Protein.content~1,
#             random = ~vsc(isc(geno), Gu=Ai) + geno,
#             rcov=~units,
#             data=DT)
# summary(mixb)$varcomp
</code></pre>

<hr>
<h2 id='DT_sleepstudy'>
Reaction times in a sleep deprivation study
</h2><span id='topic+DT_sleepstudy'></span>

<h3>Description</h3>

<p>The average reaction time per day for subjects in a sleep deprivation study. On day 0 the subjects had their normal amount of sleep. Starting that night they were restricted to 3 hours of sleep per night. The observations represent the average reaction time on a series of tests given each day to each subject. Data from sleepstudy to see how lme4 models can be translated in sommer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_sleepstudy")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_sleepstudy&quot;
</p>


<h3>Source</h3>

<p>These data are from the study described in Belenky et al. (2003), for the sleep deprived group and for the first 10 days of the study, up to the recovery period.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Gregory Belenky et al. (2003) Patterns of performance degradation and restoration during sleep restrictions and subsequent recovery: a sleep dose-response study. Journal of Sleep Research 12, 1-12.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the
#### examples are silenced with one '#' mark,
#### remove them and run the examples
####=========================================####
# library(lme4)
data(DT_sleepstudy)
DT &lt;- DT_sleepstudy
head(DT)
##################################
## lme4
# fm1 &lt;- lmer(Reaction ~ Days + (1 | Subject), data=DT)
# vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))
## sommer
fm2 &lt;- mmer(Reaction ~ Days,
            random= ~ Subject, 
            data=DT, tolParInv = 1e-6, verbose = FALSE)
summary(fm2)$varcomp

##################################
## lme4
# fm1 &lt;- lmer(Reaction ~ Days + (Days || Subject), data=DT)
# vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))
## sommer
fm2 &lt;- mmer(Reaction ~ Days,
            random= ~ Subject + vsr(Days, Subject), 
            data=DT, tolParInv = 1e-6, verbose = FALSE)
summary(fm2)$varcomp

##################################
## lme4
# fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), data=DT)
# vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))
## sommer
## no equivalence in sommer to find the correlation between the 2 vc
## this is the most similar which is equivalent to (intercept || slope)
fm2 &lt;- mmer(Reaction ~ Days,
            random= ~ Subject + vsr(Days, Subject), 
            data=DT, tolParInv = 1e-6, verbose = FALSE)
summary(fm2)$varcomp

##################################
## lme4
# fm1 &lt;- lmer(Reaction ~ Days + (0 + Days | Subject), data=DT)
# vc &lt;- VarCorr(fm1); print(vc,comp=c("Variance"))
## sommer
fm2 &lt;- mmer(Reaction ~ Days,
            random= ~ vsr(Days, Subject), 
            data=DT, tolParInv = 1e-6, verbose = FALSE)
summary(fm2)$varcomp

</code></pre>

<hr>
<h2 id='DT_technow'>
Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)
</h2><span id='topic+DT_technow'></span><span id='topic+Ad_technow'></span><span id='topic+Af_technow'></span><span id='topic+Md_technow'></span><span id='topic+Mf_technow'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 2 traits measured in 1254 single cross hybrids coming from the cross of Flint x Dent heterotic groups. In addition contains the genotipic data (35,478 markers) for each of the 123 Dent lines and 86 Flint lines. The purpose of this data is to demosntrate the prediction of unrealized crosses (9324 unrealized crosses, 1254 evaluated, total 10578 single crosses). We have added the additive relationship matrix (A) but can be easily obtained using the A.mat function on the marker data. Please if using this data for your own research cite Technow et al. (2014) publication (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_technow")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_technow&quot;
</p>


<h3>Source</h3>

<p>This data was extracted from Technow et al. (2014).
</p>


<h3>References</h3>

<p>If using this data for your own research please cite:
</p>
<p>Technow et al. 2014. Genome properties and prospects of genomic predictions of hybrid performance in a Breeding program of maize. Genetics 197:1343-1355.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
data(DT_technow)
DT &lt;- DT_technow
Md &lt;- Md_technow
Mf &lt;- Mf_technow
# Md &lt;- (Md*2) - 1
# Mf &lt;- (Mf*2) - 1
# Ad &lt;- A.mat(Md)
# Af &lt;- A.mat(Mf)
# ###=========================================####
# ###=========================================####
# ans2 &lt;- mmer(GY~1,
#              random=~vsr(dent,Gu=Ad) + vsr(flint,Gu=Af),
#              rcov=~units,
#              data=DT)
# summary(ans2)$varcomp
# 
# Adi &lt;- as(solve(Ad + diag(1e-4,ncol(Ad),ncol(Ad))), Class="dgCMatrix")
# Afi &lt;- as(solve(Af + diag(1e-4,ncol(Af),ncol(Af))), Class="dgCMatrix")
# ans2b &lt;- mmec(GY~1,
#              random=~vsc(isc(dent),Gu=Adi) + vsc(isc(flint),Gu=Afi),
#              rcov=~units,
#              data=DT)
# summary(ans2b)$varcomp
# ####=========================================####
# #### multivariate overlayed model
# ####=========================================####
# M &lt;- rbind(Md,Mf)
# A &lt;- A.mat(M)
# ans3 &lt;- mmer(cbind(GY,GM)~1,
#              random=~vsr(overlay(dent,flint),Gu=A),
#              rcov=~vsr(units,Gtc=diag(2)),
#              data=DT)
# summary(ans2)
# cov2cor(ans3$sigma[[1]])

</code></pre>

<hr>
<h2 id='DT_wheat'>wheat lines dataset</h2><span id='topic+DT_wheat'></span><span id='topic+GT_wheat'></span>

<h3>Description</h3>

<p>Information from a collection of 599 historical CIMMYT wheat lines.  The wheat data set is from 
CIMMYT's Global Wheat Program. Historically, this program has conducted numerous international 
trials across a wide variety of wheat-producing environments. The environments represented in 
these trials were grouped into four basic target sets of environments comprising four 
main agroclimatic regions previously defined and widely used by CIMMYT's Global Wheat Breeding Program. 
The phenotypic trait considered here was the average grain yield (GY) of the 599 wheat lines evaluated 
in each of these four mega-environments. 
</p>
<p>A pedigree tracing back many generations was available, and the Browse application of 
the International Crop Information System (ICIS), as described in  (McLaren <em>et al.</em> 2000, 2005) was used 
for deriving the relationship matrix A among the 599 lines; it accounts for selection and inbreeding.
</p>
<p>Wheat lines were recently genotyped using 1447 Diversity Array Technology (DArT) generated by 
Triticarte Pty. Ltd. (Canberra, Australia; http://www.triticarte.com.au). The DArT markers 
may take on two values, denoted by their presence or absence. Markers with a minor allele frequency 
lower than 0.05 were removed, and missing genotypes were imputed with samples from the marginal 
distribution of marker genotypes, that is, <code class="reqn">x_{ij}=Bernoulli(\hat p_j)</code>, where  <code class="reqn">\hat p_j</code>  
is the estimated allele frequency computed from the non-missing genotypes. The number of DArT 
MMs after edition was 1279.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(DT_wheat)
</code></pre>


<h3>Format</h3>

<p>Matrix Y contains the average grain yield, column 1: Grain yield for environment 1 and so on. 
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>McLaren, C. G., L. Ramos, C. Lopez, and W. Eusebio. 2000. &ldquo;Applications of the geneaology manegment system.&rdquo; 
In <em>International Crop Information System. Technical  Development Manual, version VI</em>, edited by McLaren, C. G., J.W. White 
and P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT and IRRI. 
</p>
<p>McLaren, C. G., R. Bruskiewich, A.M. Portugal, and A.B. Cosico. 2005. The International Rice Information System. 
A platform for meta-analysis of rice crop data. <em>Plant Physiology</em> <b>139</b>: 637-642.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
# data(DT_wheat)
# DT &lt;- DT_wheat
# GT &lt;- GT_wheat
# DTlong &lt;- data.frame(pheno=as.vector(DT), 
#                      env=sort(rep(1:4,nrow(DT))), 
#                      id=rep(rownames(DT),4))
# DT &lt;- as.data.frame(DT);colnames(DT) &lt;- paste0("x",1:4);DT$line &lt;- rownames(DT);
# rownames(GT) &lt;- DT$line
# K &lt;- A.mat(GT) # additive relationship matrix
# K[1:4,1:4]
# ###=========================================####
# ###=========================================####
# ### using formula based 'mmer'
# ###=========================================####
# ###=========================================####
# head(DT)
# #### univariate
# mix0 &lt;- mmer(x1~1,
#              random = ~vsr(line,Gu=K),
#              rcov=~units,
#              data=DT)
# summary(mix0)$varcomp
# 
# Ki &lt;- as(solve(K + diag(1e-4,ncol(K),ncol(K))), Class="dgCMatrix")
# mix0b &lt;- mmec(x1~1,
#              random = ~vsc(isc(line),Gu=Ki),
#              rcov=~units,
#              data=DT)
# summary(mix0b)$varcomp


</code></pre>

<hr>
<h2 id='DT_yatesoats'>
Yield of oats in a split-block experiment
</h2><span id='topic+DT_yatesoats'></span>

<h3>Description</h3>

<p>The yield of oats from a split-plot field trial using three varieties
and four levels of manurial treatment. The experiment was laid out in
6 blocks of 3 main plots, each split into 4 sub-plots. The varieties
were applied to the main plots and the manurial (nitrogen) treatments
to the sub-plots.
</p>


<h3>Format</h3>


<dl>
<dt><code>block</code></dt><dd><p>block factor with 6 levels</p>
</dd>
<dt><code>nitro</code></dt><dd><p>nitrogen treatment in hundredweight per acre</p>
</dd>
<dt><code>Variety</code></dt><dd><p>genotype factor, 3 levels</p>
</dd>
<dt><code>yield</code></dt><dd><p>yield in 1/4 lbs per sub-plot, each 1/80 acre.</p>
</dd>
<dt><code>row</code></dt><dd><p>row location</p>
</dd>
<dt><code>column</code></dt><dd><p>column location</p>
</dd>
</dl>



<h3>Source</h3>

<p>Yates, Frank (1935) Complex experiments,
<em>Journal of the Royal Statistical Society Suppl</em>. 2, 181&ndash;247.
</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S</em>. Fourth edition. Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### ========================== ###
### ========================== ###
data(DT_yatesoats)
DT &lt;- DT_yatesoats
head(DT)
# m3 &lt;- mmer(fixed=Y ~ V + N + V:N,
#            random = ~ B + B:MP,
#            rcov=~units,
#            data = DT)
# summary(m3)$varcomp
# 
# m3b &lt;- mmec(fixed=Y ~ V + N + V:N,
#            random = ~ B + B:MP,
#            rcov=~units,
#            data = DT)
# summary(m3b)$varcomp
</code></pre>

<hr>
<h2 id='E.mat'>
Epistatic relationship matrix
</h2><span id='topic+E.mat'></span>

<h3>Description</h3>

<p>Calculates the realized epistatic relationship matrix of second order (additive x additive, additive x dominance, or dominance x dominance) using hadamard products with the C++ Armadillo library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E.mat(X,nishio=TRUE,type="A#A",min.MAF=0.02)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="E.mat_+3A_x">X</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> lines and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are allowed.
</p>
</td></tr>
<tr><td><code id="E.mat_+3A_nishio">nishio</code></td>
<td>

<p>If TRUE Nishio ans Satoh. (2014), otherwise Su et al. (2012) (see Details in the D.mat help page).
</p>
</td></tr>
<tr><td><code id="E.mat_+3A_type">type</code></td>
<td>

<p>An argument specifying the type of epistatic relationship matrix desired. The default is the second order epistasis (additive x additive) type=&quot;A#A&quot;. Other options are additive x dominant (type=&quot;A#D&quot;), or dominant by dominant (type=&quot;D#D&quot;).  
</p>
</td></tr>
<tr><td><code id="E.mat_+3A_min.maf">min.MAF</code></td>
<td>

<p>Minimum minor allele frequency. The A matrix is not sensitive to rare alleles, so by default only monomorphic markers are removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>it is computed as the Hadamard product of the epistatic relationship matrix; E=A#A, E=A#D, E=D#D. 
</p>


<h3>Value</h3>

<p>The epistatic relationship matrix is returned.
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Endelman, J.B., and J.-L. Jannink. 2012. Shrinkage estimation of the realized relationship matrix. G3:Genes, Genomes, Genetics. 2:1405-1413. doi: 10.1534/g3.112.004259
</p>
<p>Nishio M and Satoh M. 2014. Including Dominance Effects in the Genomic BLUP Method for Genomic Evaluation. Plos One 9(1), doi:10.1371/journal.pone.0085792
</p>
<p>Su G, Christensen OF, Ostersen T, Henryon M, Lund MS. 2012. Estimating Additive and Non-Additive Genetic Variances and Predicting Genetic Merits Using Genome-Wide Dense Single Nucleotide Polymorphism Markers. PLoS ONE 7(9): e45293. doi:10.1371/journal.pone.0045293
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
####random population of 200 lines with 1000 markers
####=========================================####
X &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  X[i,] &lt;- sample(c(-1,0,0,1), size=1000, replace=TRUE)
}

E &lt;- E.mat(X, type="A#A") 
# if heterozygote markers are present can be used "A#D" or "D#D"
</code></pre>

<hr>
<h2 id='EM'>Expectation Maximization Algorithm</h2><span id='topic+EM'></span>

<h3>Description</h3>

<p>Univariate version of the expectation maximization (EM) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM(y,X=NULL,ZETA=NULL,R=NULL,iters=30,draw=TRUE,silent=FALSE, 
   constraint=TRUE, init=NULL, forced=NULL, tolpar = 1e-04, 
   tolparinv = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_+3A_y">y</code></td>
<td>
<p>a numeric vector for the response variable</p>
</td></tr>
<tr><td><code id="EM_+3A_x">X</code></td>
<td>
<p>an incidence matrix for fixed effects.</p>
</td></tr>
<tr><td><code id="EM_+3A_zeta">ZETA</code></td>
<td>
<p>an incidence matrix for random effects. This can be for one or more random effects. This NEEDS TO BE PROVIDED AS A LIST STRUCTURE. For example Z=list(list(Z=Z1, K=K1), list(Z=Z2, K=K2), list(Z=Z3, K=K3)) makes a 2 level list for 3 random effects. The general idea is that each random effect with or without its variance-covariance structure is a list, i.e. list(Z=Z1, K=K1) where Z is the incidence matrix and K the var-cov matrix. When moving to more than one random effect we need to make several lists that need to be inside another list. What we call a 2-level list, i.e. list(Z=Z1, K=K1) and list(Z=Z2, K=K2) would need to be put in the form; list(list(Z=Z1, K=K1),list(Z=Z1, K=K1)), which as can be seen, is a list of lists (2-level list). </p>
</td></tr>
<tr><td><code id="EM_+3A_r">R</code></td>
<td>
<p>a list of matrices for residuals, i.e. for longitudinal data. if not passed is assumed an identity matrix.</p>
</td></tr>
<tr><td><code id="EM_+3A_draw">draw</code></td>
<td>
<p>a TRUE/FALSE value indicating if a plot of updated values for the variance components and the likelihood should be drawn or not. The default is TRUE. COMPUTATION TIME IS SMALLER IF YOU DON'T PLOT SETTING draw=FALSE</p>
</td></tr>
<tr><td><code id="EM_+3A_silent">silent</code></td>
<td>
<p>a TRUE/FALSE value indicating if the function should draw the progress bar or iterations performed while working or should not be displayed.</p>
</td></tr>
<tr><td><code id="EM_+3A_iters">iters</code></td>
<td>
<p>a scalar value indicating how many iterations have to be performed if the EM is performed. There is no rule of tumb for the number of iterations. The default value is 100 iterations or EM steps.</p>
</td></tr>
<tr><td><code id="EM_+3A_constraint">constraint</code></td>
<td>
<p>a TRUE/FALSE value indicating if the program should use the boundary constraint when one or more variance component is close to the zero boundary. The default is TRUE but needs to be used carefully. It works ideally when few variance components are close to the boundary but when there are too many variance components close to zero we highly recommend setting this parameter to FALSE since is more likely to get the right value of the variance components in this way.</p>
</td></tr>
<tr><td><code id="EM_+3A_init">init</code></td>
<td>
<p>vector of initial values for the variance components. By default this is NULL and variance components are estimated by the method selected, but in case the user want to provide initial values this argument is functional.</p>
</td></tr>
<tr><td><code id="EM_+3A_forced">forced</code></td>
<td>
<p>a vector of numeric values for variance components including error if the user wants to force the values of the variance components. On the meantime only works for forcing all of them and not a subset of them. The default is NULL, meaning that variance components will be estimated by REML/ML.</p>
</td></tr>
<tr><td><code id="EM_+3A_tolpar">tolpar</code></td>
<td>
<p>tolerance parameter for convergence in the models.</p>
</td></tr>
<tr><td><code id="EM_+3A_tolparinv">tolparinv</code></td>
<td>
<p>tolerance parameter for matrix inversion in the models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is based on Searle (1993) and Bernanrdo (2010). This handles models of the form:
</p>
<p>y = Xb + Zu + e
</p>
<p>b ~ N[b.hat, 0]  ............zero variance because is a fixed term
</p>
<p>u ~ N[0, K*sigma(u)]  .......where: K*sigma(u) = G
</p>
<p>e ~ N[0, I*sigma(e)]  .......where: I*sigma(e) = R
</p>
<p>y ~ N[Xb, var(Zu+e)]   ......where;
</p>
<p>var(y) = var(Zu+e) = ZGZ+R = V which is the phenotypic variance
</p>
<p>.
</p>
<p>The function allows the user to specify the incidence matrices with their respective variance-covariance matrix in a 2 level list structure. For example imagine a mixed model with the following design:
</p>
<p>.
</p>
<p>fixed = only intercept....................................b ~ N[b.hat, 0]
</p>
<p>random = GCA1 + GCA2 + SCA.................u ~ N[0, G]       
</p>
<p>.
</p>
<p>where G is:
</p>
<p>.
</p>
<p>|K*sigma(gca1).....................0..........................0.........|
</p>
<p>|.............0.............S*sigma(gca2).....................0.........| = G
|.............0....................0......................W*sigma(sca)..|
</p>
<p>.
</p>
<p>The function is based on useing initial values for variance components, i.e.:
</p>
<p>.
</p>
<p>var(e) &lt;- 100      
var(u1) &lt;- 100      with incidence matrix Z1
var(u2) &lt;- 100      with incidence matrix Z2
var(u3) &lt;- 100      with incidence matrix Z3
</p>
<p>.
</p>
<p>and estimates the lambda(vx) values in the mixed model equations (MME) developed by Henderson (1975), i.e. consider the 3 random effects stated above, the MME are:
</p>
<p>.
</p>
<p>|...............X'*R*X...............X'*R*Z1.............X'*R*Z2...................X'*R*Z3 ..............|   |...X'Ry...|
</p>
<p>|.............Z1'*R*X.........Z1'*R*Z1+K1*v1.....Z1'*R*Z2..................Z1'*R*Z3.............|   |...Z1'Ry...| 
|.............Z2'*R*X.............Z2'*R*Z1.............Z2'*R*Z2+K2*v2......Z2'*R*Z3.............|   |...Z2'Ry...|
</p>
<p>|.............Z3'*R*X.............Z3'*R*Z1.............Z3'*R*Z2.............Z3'*R*Z3+K3*v3......|   |...Z3'Ry...|
.
..............................................................C.inv...................................................................RHS
</p>
<p>.
</p>
<p>where &quot;*&quot;&quot; is a matrix product, R is the inverse of the var-cov matrix for the errors, Z1, Z2, Z3 are incidence matrices for random effects, X is the incidence matrix for fixed effects, K1,K2, K3 are the var-cov matrices for random effects and v1,v2,v3 are the estimates of variance components.
.
The algorithm can be summarized in the next steps:
.
1) provide initial values for the variance components
2) estimate the coefficient matrix from MME known as &quot;C&quot;
3) solve the mixed equations as theta = RHS * C.inv 
4) obtain new estimates of fixed (b's) and random effects (u's) called theta
5) update values for variance components according to formulas
6) steps are repeated for a number of iterations specified by the user, ideally is enough when no more variations in the estimates is found, in several problems that could take thousands of iterations, whereas in other 10 iterations could be enough.
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>

<dl>
<dt>$var.com</dt><dd><p> a vector with the values of the variance components estimated</p>
</dd>
<dt>$V.inv</dt><dd><p> a matrix with the inverse of the phenotypic variance V = ZGZ+R, V^-1</p>
</dd>
<dt>$u.hat</dt><dd><p> a vector with BLUPs for random effects</p>
</dd>
<dt>$Var.u.hat</dt><dd><p> a vector with variances for BLUPs</p>
</dd>
<dt>$PEV.u.hat</dt><dd><p> a vector with predicted error variance for BLUPs</p>
</dd>
<dt>$beta.hat</dt><dd><p> a vector for BLUEs of fixed effects</p>
</dd>
<dt>$Var.beta.hat</dt><dd><p> a vector with variances for BLUEs</p>
</dd>
<dt>$X</dt><dd><p> incidence matrix for fixed effects</p>
</dd>
<dt>$Z</dt><dd><p> incidence matrix for random effects, if not passed is assumed to be a diagonal matrix</p>
</dd>
<dt>$K</dt><dd><p> the var-cov matrix for the random effect fitted in Z</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Bernardo Rex. 2010. Breeding for quantitative traits in plants. Second edition. Stemma Press. 390 pp.
Searle. 1993. Applying the EM algorithm to calculating ML and REML estimates of variance components. Paper invited for the 1993 American Statistical Association Meeting, San Francisco.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

# ## Import phenotypic data on inbred performance
# ## Full data
# data("DT_cornhybrids")
# hybrid2 &lt;- DT_cornhybrids # extract cross data
# A &lt;- GT_cornhybrids # extract the var-cov K
# ############################################
# ############################################
# ## breeding values with 3 variance components
# ############################################
# ############################################
# y &lt;- hybrid2$Yield
# X1 &lt;- model.matrix(~ Location, data = hybrid2);dim(X1)
# Z1 &lt;- model.matrix(~ GCA1 -1, data = hybrid2);dim(Z1)
# Z2 &lt;- model.matrix(~ GCA2 -1, data = hybrid2);dim(Z2)
# Z3 &lt;- model.matrix(~ SCA -1, data = hybrid2);dim(Z3)
# 
# K1 &lt;- A[levels(hybrid2$GCA1), levels(hybrid2$GCA1)]; dim(K1)
# ## Realized IBS relationships for set of parents 1
# K2 &lt;- A[levels(hybrid2$GCA2), levels(hybrid2$GCA2)]; dim(K2)
# ## Realized IBS relationships for set of parents 2
# S &lt;- kronecker(K1, K2) ; dim(S)
# ## Realized IBS relationships for cross (as the Kronecker product of K1 and K2)
# rownames(S) &lt;- colnames(S) &lt;- levels(hybrid2$SCA)
# 
# ETA &lt;- list(list(Z=Z1, K=K1), list(Z=Z2, K=K2))#, list(Z=Z3, K=S))
# ans &lt;- EM(y=y, ZETA=ETA, iters=50)
# ans$var.comp
# 
# # compare with NR method
# mix1 &lt;- mmer(Yield~1, random=~vs(GCA1,Gu=K1)+vs(GCA2,Gu=K2), data=hybrid2)
# summary(mix1)$varcomp
# 


</code></pre>

<hr>
<h2 id='fcm'>fixed effect constraint indication matrix</h2><span id='topic+fcm'></span>

<h3>Description</h3>

<p><code>fcm</code> creates a matrix with the correct number of columns to specify a constraint in the fixed effects using the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fcm(x, reps=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcm_+3A_x">x</code></td>
<td>
<p>vector of 1's and 0's corresponding to the traits for which this fixed effect should be fitted. For example, for a trivariate model if the fixed effect &quot;x&quot; wants to be fitted only for trait 1 and 2 but not for the 3rd trait then you would use fcm(c(1,1,0)) in the Gtc argument of the vsr() function.</p>
</td></tr>
<tr><td><code id="fcm_+3A_reps">reps</code></td>
<td>
<p>integer specifying the number of times the matrix should be repeated in a list format to provide easily the constraints in complex models that use the ds(), us() or cs() structures.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a matrix or a list of matrices with the constraints to be provided in the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>fcm</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>fcm(c(1,1,0))
fcm(c(0,1,1))
fcm(c(1,1,1))

fcm(c(1,1,1),2)

# ## model with Env estimated for both traits
# data(DT_example)
# DT &lt;- DT_example
# A &lt;- A_example
# ans4 &lt;- mmer(cbind(Yield, Weight) ~ Env,
#               random= ~ vsr(Name) + vsr(Env:Name),
#               rcov= ~ vsr(units),
#               data=DT)
# summary(ans4)$betas
# ## model with Env only estimated for Yield
# ans4b &lt;- mmer(cbind(Yield, Weight) ~ vsr(Env, Gtc=fcm(c(1,0))),
#              random= ~ vsr(Name) + vsr(Env:Name),
#              rcov= ~ vsr(units),
#              data=DT)
# summary(ans4b)$betas

</code></pre>

<hr>
<h2 id='fitted.mmec'>fitted form a LMM fitted with mmec</h2><span id='topic+fitted.mmec'></span>

<h3>Description</h3>

<p><code>fitted</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.mmec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="fitted.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the mmec function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of fitted values of the form y.hat = Xb + Zu including all terms of the model.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix
# A &lt;- A.mat(GT) # additive relationship matrix
# #### look at the data and fit the model
# head(DT)
# mix1 &lt;- mmer(Yield~1,
#               random=~vsr(id,Gu=A)
#                       + Rowf + Colf + spl2Da(Row,Col),
#               rcov=~units,
#               data=DT)
# 
# ff=fitted(mix1)
# 
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# lattice::wireframe(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted,  
#           aspect=c(61/87,0.4), drape=TRUE,# col.regions = colfunc,
#           light.source=c(10,0,10))
# lattice::levelplot(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted, col.regions = colfunc)

</code></pre>

<hr>
<h2 id='fitted.mmer'>fitted form a LMM fitted with mmer</h2><span id='topic+fitted.mmer'></span>

<h3>Description</h3>

<p><code>fitted</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.mmer_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="fitted.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the mmer function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of fitted values of the form y.hat = Xb + Zu including all terms of the model.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix
# A &lt;- A.mat(GT) # additive relationship matrix
# #### look at the data and fit the model
# head(DT)
# mix1 &lt;- mmer(Yield~1,
#               random=~vsr(id,Gu=A)
#                       + Rowf + Colf + spl2Da(Row,Col),
#               rcov=~units,
#               data=DT)
# 
# ff=fitted(mix1)
# 
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# lattice::wireframe(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted,  
#           aspect=c(61/87,0.4), drape=TRUE,# col.regions = colfunc,
#           light.source=c(10,0,10))
# lattice::levelplot(`u:Row.fitted`~Row*Col, data=ff$dataWithFitted, col.regions = colfunc)

</code></pre>

<hr>
<h2 id='fixm'>fixed indication matrix</h2><span id='topic+fixm'></span>

<h3>Description</h3>

<p><code>fixm</code> creates a square matrix with 3's in the diagnals and off-diagonals to quickly specify a fixed constraint in the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fixm(x, reps=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixm_+3A_x">x</code></td>
<td>
<p>integer specifying the number of traits to be fitted for a given random effect.</p>
</td></tr>
<tr><td><code id="fixm_+3A_reps">reps</code></td>
<td>
<p>integer specifying the number of times the matrix should be repeated in a list format to provide easily the constraints in complex models that use the ds(), us() or cs() structures.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a matrix or a list of matrices with the constraints to be provided in the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>fixm</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>fixm(4)
fixm(4,2)
</code></pre>

<hr>
<h2 id='gvsr'>general variance structure specification</h2><span id='topic+gvsr'></span>

<h3>Description</h3>

<p><code>gvsr</code> function to build general variance-covariance structures for combination of random effects to be fitted in the <code><a href="#topic+mmer">mmer</a></code> solver. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gvsr(..., Gu=NULL, Guc=NULL, Gti=NULL, Gtc=NULL, form=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gvsr_+3A_...">...</code></td>
<td>
<p>names of the random effects (variables in the dataset) to be used to create a general variance structure. For example, for 2 random effects (variables); mom and progeny, a model specified as:
</p>
<p><code>gvsr(mom, progeny)</code>
</p>
<p>will create a variance structure of the form:
</p>
<p><code>| sigma2.m   sigma.pm |</code>
</p>
<p><code>| sigma.pm   sigma2.p |</code>
</p>
<p>where not only variance components for each random effect will be estimated but also the covariance component between the 2 random effects is estimated. The user can also provide a numeric vector or matrix to be considered the design matrix for the ith random effect. More than two random effects can be provided.
</p>
</td></tr>
<tr><td><code id="gvsr_+3A_gu">Gu</code></td>
<td>
<p>list of matrices with the known variance-covariance values for the levels of the different random effects provided in the &quot;...&quot; argument (i.e. relationship matrix among individuals or any other known covariance matrix). If NULL, then an identity matrix is assumed. For example, a model with 2 random effects with covariance structure should be provided as:
</p>
<p><code>gvsr(mom, progeny, Gu=list(Am,Ap))</code>
</p>
<p>where <code>Am</code> and <code>Ap</code> are the relationship matrices for the random effects for mom and progeny respectively.
</p>
</td></tr>
<tr><td><code id="gvsr_+3A_guc">Guc</code></td>
<td>
<p>matrix with the constraints for the u random effects. This is used to specify which variance and covariance parameters between the 1 to 1 combinations of random effects should be estimated. For example, for 2 random effects the expected variance-covariance matrix expected to be estimated (when the default Guc=NULL) is and unstructured model:
</p>
<p><code>| sigma2.m   sigma.pm |</code>
</p>
<p><code>| sigma.pm   sigma2.p |</code>
</p>
<p>but the user can constrain which parameters should be estimated. Providing:
</p>
<p><code>Guc=diag(2)</code>     would fit:
</p>
<p><code>| sigma2.m  ...0... |</code>
</p>
<p><code>| ...0...  sigma2.p |</code>
</p>
</td></tr>
<tr><td><code id="gvsr_+3A_gti">Gti</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) with initial values of the variance-covariance components for the random effect specified in the .... argument. If the value is NULL the program will provide the initial values.</p>
</td></tr>
<tr><td><code id="gvsr_+3A_gtc">Gtc</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) of constraints for the variance-covariance components for the random effect specified in the ... argument according to the following rules:
</p>
<p><code>0: not to be estimated</code>
</p>
<p><code>1: estimated and constrained to be positive (i.e. variance component)</code>
</p>
<p><code>2: estimated and unconstrained (can be negative or positive, i.e. covariance component)</code>
</p>
<p><code>3: not to be estimated but fixed (value has to be provided in the Gti argument)</code>
</p>
<p>In the multi-response scenario if the user doesn't specify this argument the default is to build an unstructured matrix (using the <code><a href="#topic+unsm">unsm</a></code>() function). This argument needs to be used wisely since some covariance among responses may not make sense. Useful functions to specify constraints are; <code><a href="base.html#topic+diag">diag</a></code>(), <code><a href="#topic+unsm">unsm</a></code>(), <code><a href="#topic+fixm">fixm</a></code>().
</p>
</td></tr>
<tr><td><code id="gvsr_+3A_form">form</code></td>
<td>
<p>an additional structure to specify a kronecker product on top of the general covariance structure defined in the ... argument.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a list with all neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures to be estimated and constraints) to be used in the mmer solver.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Covarrubias-Pazaran G (2018) Software update: Moving the R package sommer to
multivariate mixed models for genome-assisted prediction. doi:
https://doi.org/10.1101/354639
</p>


<h3>See Also</h3>

<p>The core function of the package: <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_ige)
DT &lt;- DT_ige
Af &lt;- A_ige
An &lt;- A_ige
### Direct genetic effects model
# modDGE &lt;- mmer(trait ~ block,
#                random = ~ focal,
#                rcov = ~ units, 
#                data = DT)
# summary(modDGE)$varcomp
# 
### Indirect genetic effects model without covariance between DGE and IGE
# modDGE &lt;- mmer(trait ~ block,
#                random = ~focal + neighbour,
#                rcov = ~ units, 
#                data = DT)
# summary(modDGE)$varcomp
# 
### Indirect genetic effects model with covariance between DGE and IGE
# modIGE &lt;- mmer(trait ~ block,
#               random = ~ gvsr(focal, neighbour),
#               rcov = ~ units, iters=4, 
#               data = DT)
# summary(modIGE)$varcomp
#
### Indirect genetic effects model with covariance between DGE and IGE using relatioship matrices
# modIGEb &lt;- mmer(trait ~ block,
#                random = ~ gvsr(focal, neighbour, Gu=list(Af,An)),
#                rcov = ~ units, 
#                data = DT)
# summary(modIGEb)$varcomp
 

</code></pre>

<hr>
<h2 id='GWAS'>
Genome wide association study analysis
</h2><span id='topic+GWAS'></span>

<h3>Description</h3>

<p>Fits a multivariate/univariate linear mixed model GWAS by likelihood methods (REML), see the Details section below. It uses the <code><a href="#topic+mmer">mmer</a></code> function and its core coded in C++ using the Armadillo library to optimize dense matrix operations common in the derect-inversion algorithms. After the model fit extracts the inverse of the phenotypic variance matrix to perform the association test for the &quot;p&quot; markers. Please check the Details section (Model enabled) if you have any issue with making the function run.
</p>
<p>The package also provides functions to estimate additive (<code><a href="#topic+A.mat">A.mat</a></code>), dominance (<code><a href="#topic+D.mat">D.mat</a></code>), epistatic (<code><a href="#topic+E.mat">E.mat</a></code>) and single step (<code><a href="#topic+H.mat">H.mat</a></code>) relationship matrices to model known covariances among genotypes typical in plant and animal breeding problems. Other functions to build known covariance structures among levels of random effects are autoregresive (<code><a href="#topic+AR1">AR1</a></code>), compound symmetry (<code><a href="#topic+CS">CS</a></code>) and autoregressive moving average (<code><a href="#topic+ARMA">ARMA</a></code>) where the user needs to fix the correlation value for such models (this is different to estimating unknown covariance structures). Additionally, overlayed models can be implemented as well (<code><a href="#topic+overlay">overlay</a></code> function). Spatial modeling can be done through the two dimensional splines (<code><a href="#topic+spl2Da">spl2Da</a></code> and <code><a href="#topic+spl2Db">spl2Db</a></code>). Random regression models can also be fitted through the (<code><a href="#topic+leg">leg</a></code>) function (orthopolynom package installation is needed for using the leg function).
</p>
<p>The sommer package is updated on CRAN every 3-months due to CRAN policies but you can find the latest source at https://github.com/covaruber/sommer . This can be easily installed typing the following in the R console:
</p>
<p>library(devtools)
</p>
<p>install_github(&quot;covaruber/sommer&quot;)
</p>
<p>This is recommended since bugs fixes will be immediately available in the GitHub source. <strong>For tutorials</strong> on how to perform different analysis with sommer please look at the vignettes by typing in the terminal:
</p>
<p><strong>vignette(&quot;v1.sommer.quick.start&quot;)</strong> 
</p>
<p><strong>vignette(&quot;v2.sommer.changes.and.faqs&quot;)</strong>
</p>
<p><strong>vignette(&quot;v3.sommer.qg&quot;)</strong>
</p>
<p><strong>vignette(&quot;v4.sommer.gxe&quot;)</strong>
</p>
<p>or visit <strong>https://covaruber.github.io</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
GWAS(fixed, random, rcov, data, weights, W,
    nIters=20, tolParConvLL = 1e-03, tolParInv = 1e-06, 
    init=NULL, constraints=NULL,method="NR", 
    getPEV=TRUE,naMethodX="exclude",
    naMethodY="exclude",returnParam=FALSE, 
    dateWarning=TRUE,date.warning=TRUE,verbose=FALSE,
    stepWeight=NULL, emWeight=NULL,
    M=NULL, gTerm=NULL, n.PC = 0, min.MAF = 0.05, 
    P3D = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GWAS_+3A_fixed">fixed</code></td>
<td>
<p>A formula specifying the <strong>response variable(s)</strong> <strong>and fixed effects</strong>, i.e:
</p>
<p><em>response ~ covariate</em> for univariate models
</p>
<p><em>cbind(response.i,response.j) ~ covariate</em> for multivariate models
</p>
<p>The <code><a href="#topic+fcm">fcm</a>()</code> function can be used to constrain fixed effects in multi-response models.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_random">random</code></td>
<td>
<p>a formula specifying the name of the <strong>random effects</strong>, i.e. <em>random= ~ genotype + year</em>.
</p>
<p>Useful functions can be used to fit heterogeneous variances and other special models (<em>see 'Special Functions' in the Details section for more information</em>):
</p>
<p><code><a href="#topic+vsr">vsr</a>(...,Gu,Gt,Gtc)</code> is the main function to specify variance models and special structures for random effects. On the ... argument you provide the unknown variance-covariance structures (i.e. usr,dsr,at,csr) and the random effect where such covariance structure will be used (the random effect of interest). Gu is used to provide known covariance matrices among the levels of the random effect, Gt initial values and Gtc for constraints. Auxiliar functions for building the variance models are:
</p>
<p>** <code><a href="#topic+dsr">dsr</a>(x)</code>, <code><a href="#topic+usr">usr</a>(x)</code>, <code><a href="#topic+csr">csr</a>(x)</code> and <code><a href="#topic+atr">atr</a>(x,levs)</code> can be used to specify unknown diagonal, unstructured and customized unstructured and diagonal covariance structures to be estimated by REML.
</p>
<p>** <code><a href="#topic+unsm">unsm</a>(x)</code>, <code><a href="#topic+fixm">fixm</a>(x)</code> and <code><a href="base.html#topic+diag">diag</a>(x)</code> can be used to build easily matrices to specify constraints in the Gtc argument of the <code><a href="#topic+vsr">vsr</a>()</code> function.
</p>
<p>** <code><a href="#topic+overlay">overlay</a>()</code>, <code><a href="#topic+spl2Da">spl2Da</a>()</code>, <code><a href="#topic+spl2Db">spl2Db</a>()</code>, and <code><a href="#topic+leg">leg</a>()</code> functions can be used to specify overlayed of design matrices of random effects, two dimensional spline and random regression models within the <code><a href="#topic+vsr">vsr</a>()</code> function.
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_rcov">rcov</code></td>
<td>
<p>a formula specifying the name of the <strong>error term</strong>, i.e. <em>rcov= ~ units</em>.
</p>
<p>The functions that can be used to fit heterogeneous residual variances are the same used on the random term but the random effect is always &quot;units&quot;, i.e. <em>rcov=~vsr(dsr(Location),units)</em>
</p>
</td></tr>
<tr><td><code id="GWAS_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables specified in the formulas for response, fixed, and random effects.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_weights">weights</code></td>
<td>
<p>name of the covariate for weights. To be used for the product R = Wsi*R*Wsi, where * is the matrix product, Wsi is the square root of the inverse of W and R is the residual matrix.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_w">W</code></td>
<td>
<p>Alternatively, instead of providing a vector of weights the user can specify an entire W matrix (e.g., when covariances exist). To be used first to produce Wis = solve(chol(W)), and then calculate R = Wsi*R*Wsi.t(), where * is the matrix product, and R is the residual matrix. Only one of the arguments weights or W should be used. If both are indicated W will be given the preference.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_niters">nIters</code></td>
<td>
<p>Maximum number of iterations allowed.  Default value is 15.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_tolparconvll">tolParConvLL</code></td>
<td>
<p>Convergence criteria.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_tolparinv">tolParInv</code></td>
<td>
<p>tolerance parameter for matrix inverse used when singularities are encountered.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_init">init</code></td>
<td>
<p>initial values for the variance components. By default this is NULL and variance components are estimated by the method selected, but in case the user want to provide initial values for ALL var-cov components this argument is functional. It has to be provided as a list or an array, where each list element is one variance component and if multitrait model is pursued each element of the list is a matrix of variance covariance components among traits. Initial values can also be provided in the Gt argument of the <a href="#topic+vsr">vsr</a> function.Is highly encouraged to use the Gt and Gtc arguments of the <a href="#topic+vsr">vsr</a> function instead of this argument</p>
</td></tr>
<tr><td><code id="GWAS_+3A_constraints">constraints</code></td>
<td>
<p>when initial values are provided these have to be accompanied by their constraints. See the <a href="#topic+vsr">vsr</a> function for more details on the constraints. Is highly encouraged to use the Gt and Gtc arguments of the <a href="#topic+vsr">vsr</a> function instead of this argument.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_method">method</code></td>
<td>
<p>this refers to the method or algorithm to be used for estimating variance components. Direct-inversion Newton-Raphson <strong>NR</strong> and Average Information <strong>AI</strong> (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2015).</p>
</td></tr>
<tr><td><code id="GWAS_+3A_getpev">getPEV</code></td>
<td>
<p>a TRUE/FALSE value indicating if the program should return the predicted error variance and variance for random effects. This option is provided since this can take a long time for certain models where p &gt; n by a big extent.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_namethodx">naMethodX</code></td>
<td>
<p>one of the two possible values; &quot;include&quot; or &quot;exclude&quot;. If &quot;include&quot; is selected then the function will impute the X matrices for fixed effects with the median value. If &quot;exclude&quot; is selected it will get rid of all rows with missing values for the X (fixed) covariates. The default is &quot;exclude&quot;. The &quot;include&quot; option should be used carefully.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_namethody">naMethodY</code></td>
<td>
<p>one of the three possible values; &quot;include&quot;, &quot;include2&quot; or &quot;exclude&quot;. If &quot;include&quot; is selected then the function will impute the response variables with the median value. The difference between &quot;include&quot; and &quot;include2&quot; is only available in the multitrait models when the imputation can happen for the entire matrix of responses or only for complete cases (&quot;include2&quot;). If &quot;exclude&quot; is selected it will get rid of rows in responses where missing values are present for the estimation of variance components. The default is &quot;exclude&quot;.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_returnparam">returnParam</code></td>
<td>
<p>a TRUE/FALSE value to indicate if the program should return the parameters used for modeling without fitting the model.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_datewarning">dateWarning</code></td>
<td>
<p>a TRUE/FALSE value to indicate if the program should warn you when is time to update the sommer package.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_date.warning">date.warning</code></td>
<td>
<p>a TRUE/FALSE value to indicate if the program should warn you when is time to update the sommer package.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_verbose">verbose</code></td>
<td>
<p>a TRUE/FALSE value to indicate if the program should return the progress of the iterative algorithm.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_stepweight">stepWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating the weight used to multiply the update (delta) for variance components at each iteration. If NULL the 1st iteration will be multiplied by 0.5, the 2nd by 0.7, and the rest by 0.9. This argument can help to avoid that variance components go outside the parameter space in the initial iterations which doesn't happen very often with the NR method but it can be detected by looking at the behavior of the likelihood. In that case you may want to give a smaller weight to the initial 8-10 iterations.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_emweight">emWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating with values between 0 and 1 the weight assigned to the EM information matrix. And the values 1 - emWeight will be applied to the NR/AI information matrix to produce a joint information matrix. If NULL weights for EM information matrix are zero and 1 for the NR/AI information matrix.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_m">M</code></td>
<td>
<p>The marker matrix containing the marker scores for each level of the random effect selected in the gTerm argument, coded as numeric based on the number of reference alleles in the genotype call, e.g. (-1,0,1) = (aa,Aa,AA), levels in diploid individuals. Individuals in rows and markers in columns. No additional columns should be provided, is a purely numerical matrix. Similar logic applies to polyploid individuals, e.g. (-3,-2,-1,0,1,2,3) = (aaaa,aaaA,aaAA,Aaaa,AAaa,AAAa,AAAA). </p>
</td></tr>
<tr><td><code id="GWAS_+3A_gterm">gTerm</code></td>
<td>
<p>a character vector indicating the random effect linked to the marker matrix M (i.e. the genetic term) in the model. The random effect selected should have the same number of levels than the number of rows of M. When fitting only a random effect without a special covariance structure (e.g., dsr, usr, etc.) you will need to add the call 'u:' to the name of the random effect given the behavior of the naming rules of the solver when having a simple random effect without covariance structure. </p>
</td></tr>
<tr><td><code id="GWAS_+3A_n.pc">n.PC</code></td>
<td>
<p>Number of principal components to include as fixed effects. Default is 0 (equals K model).</p>
</td></tr>
<tr><td><code id="GWAS_+3A_min.maf">min.MAF</code></td>
<td>
<p>Specifies the minimum minor allele frequency (MAF). If a marker has a MAF less than min.MAF, it is assigned a zero score.</p>
</td></tr>
<tr><td><code id="GWAS_+3A_p3d">P3D</code></td>
<td>
<p>When P3D=TRUE, variance components are estimated by REML only once, without any markers in the model and then a for loop for hypothesis testing is performed. When P3D=FALSE, variance components are estimated by REML for each marker separately. The latter can be quite time consuming. As many models will be run as number of marker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Citation</strong>
</p>
<p>Type <em>citation(&quot;sommer&quot;)</em> to know how to cite the sommer package in your publications. 
</p>
<p><strong>Models Enabled</strong>
</p>
<p>For details about the models enabled and more information about the covariance structures please check the help page of the package (<code><a href="#topic+sommer">sommer</a></code>). In general the GWAS model implemented in sommer to obtain marker effect is a generalized linear model of the form:
</p>
<p>b = (X'V-X)X'V-y
</p>
<p>with X = ZMi
</p>
<p>where:
b is the marker effect (dimensions 1 x mt)
y is the response variable (univariate or multivariate) (dimensions 1 x nt)
V- is the inverse of the phenotypic variance matrix (dimensions nt x nt)
Z is the incidence matrix for the random effect selected (gTerm argument) to perform the GWAS (dimensions nt x ut)
Mi is the ith column of the marker matrix (M argument) (dimensions u x m)
</p>
<p>for t traits, n observations, m markers and u levels of the random effect. Depending if P3D is TRUE or FALSE the V- matrix will be calculated once and used for all marker tests (P3D=TRUE) or estimated through REML for each marker (P3D=FALSE).
</p>
<p><strong>Special Functions</strong>
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+atr">atr</a>(x,levels),y)</code>   
</p>
<p>can be used to specify heterogeneous variance for the &quot;y&quot;&quot; factor covariate at specific levels of the factor covariate &quot;x&quot;, i.e. <em>random=~vsr(at(Location,c(&quot;A&quot;,&quot;B&quot;)),ID)</em> fits a variance component for ID at levels A and B of the factor covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+dsr">dsr</a>(x),y)</code>   
</p>
<p>can be used to specify a diagonal covariance structure for the &quot;y&quot;&quot; covariate for all levels of the factor covariate &quot;x&quot;, i.e. <em>random=~vsr(dsr(Location,ID)</em>  fits a variance component for ID at all levels of the factor covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+usr">usr</a>(x),y)</code>   
</p>
<p>can be used to specify an unstructured covariance structure for the &quot;y&quot;&quot; covariate for all levels of the factor covariate &quot;x&quot;, i.e. <em>random=~vsr(usr(Location),ID)</em>  fits variance and covariance components for ID at all levels of the factor covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+overlay">overlay</a>(...,rlist=NULL,prefix=NULL))</code>   
</p>
<p>can be used to specify overlay of design matrices between consecutive random effects specified, i.e. <em>random=~overlay(male,female)</em> overlays (overlaps) the incidence matrices for the male and female random effects to obtain a single variance component for both effects. The 'rlist' argument is a list with each element being a numeric value that multiplies the incidence matrix to be overlayed. See <code><a href="#topic+overlay">overlay</a></code> for details.Can be combined with vsr().
</p>
<p><code><a href="#topic+spl2Da">spl2Da</a>(x.coord, y.coord, at.var, at.levels))</code>
</p>
<p>can be used to fit a 2-dimensional spline (i.e. spatial modeling) using coordinates <code>x.coord</code> and <code>y.coord</code> (in numeric class) assuming a single variance component. The 2D spline can be fitted at specific levels using the <code>at</code> and <code>at.levels</code> arguments. For example <em>random=~spl2Da(x.coord=Row,y.coord=Range,at.var=FIELD)</em>.
</p>
<p><code><a href="#topic+spl2Db">spl2Db</a>(x.coord, y.coord, at.var, at.levels))</code>
</p>
<p>can be used to fit a 2-dimensional spline (i.e. spatial modeling) using coordinates <code>x.coord</code> and <code>y.coord</code> (in numeric class) assuming multiple variance components. The 2D spline can be fitted at specific levels using the <code>at</code> and <code>at.levels</code> arguments. For example <em>random=~spl2Db(x.coord=Row,y.coord=Range,at.var=FIELD)</em>.
</p>
<p>For a short tutorial on how to use this special functions you can look at the vignettes by typing in the terminal:
</p>
<p><em>vignette('sommer.start')</em>
</p>
<p><strong>Bug report and contact</strong>
</p>
<p>If you have any technical questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com. 
</p>
<p>If you have any bug report please go to https://github.com/covaruber/sommer or send me an email to address it asap.
</p>
<p><strong>Example Datasets</strong>
</p>
<p>The package has been equiped with several datasets to learn how to use the sommer package: 
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code> and <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> datasets have examples to fit half and full diallel designs. 
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses 
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects. 
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids. 
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p><strong>Additional Functions</strong>
</p>
<p>Other functions such as <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+randef">randef</a></code> (notice here is randef not ranef), <code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="base.html#topic+plot">plot</a></code> applicable to typical linear models can also be applied to models fitted using the GWAS-type of functions. 
</p>
<p>Additional functions for genetic analysis have been included such as build a genotypic hybrid marker matrix (<code><a href="#topic+build.HMM">build.HMM</a></code>), plot of genetic maps (<code><a href="#topic+map.plot">map.plot</a></code>), creation of manhattan plots (<code><a href="#topic+manhattan">manhattan</a></code>). If you need to use pedigree you need to convert your pedigree into a relationship matrix (i.e. use the <code>getA</code> function from the pedigreemm package). 
</p>
<p>Useful functions for analyzing field trials are included such as the <code>spl2Da</code> and <code>spl2Db</code>.
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>
<table role = "presentation">
<tr><td><code>Vi</code></td>
<td>
<p>the inverse of the phenotypic variance matrix V^- = (ZGZ+R)^-1</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a list with the values of the variance-covariance components with one list element for each random effect.</p>
</td></tr>
<tr><td><code>sigma_scaled</code></td>
<td>
<p>a list with the values of the scaled variance-covariance components with one list element for each random effect.</p>
</td></tr>
<tr><td><code>sigmaSE</code></td>
<td>
<p>Hessian matrix containing the variance-covariance for the variance components. SE's can be obtained taking the square root of the diagonal values of the Hessian.</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>a data frame for trait BLUEs (fixed effects).</p>
</td></tr>
<tr><td><code>VarBeta</code></td>
<td>
<p>a variance-covariance matrix for trait BLUEs</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>a list (one element for each random effect) with a data frame for trait BLUPs.</p>
</td></tr>
<tr><td><code>VarU</code></td>
<td>
<p>a list (one element for each random effect) with the variance-covariance matrix for trait BLUPs.</p>
</td></tr>
<tr><td><code>PevU</code></td>
<td>
<p>a list (one element for each random effect) with the predicted error variance matrix for trait BLUPs.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values y.hat=XB</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residual values e = Y - XB</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a TRUE/FALSE statement indicating if the model converged.</p>
</td></tr>
<tr><td><code>monitor</code></td>
<td>
<p>The values of log-likelihood and variance-covariance components across iterations during the REML estimation.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> marker scores (-log_(10)p) for the traits</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method for extimation of variance components specified by the user.</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>
<p>contraints used in the mixed models for the random effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744   
</p>
<p>Covarrubias-Pazaran G. 2018. Software update: Moving the R package sommer to multivariate mixed models for genome-assisted prediction. doi: https://doi.org/10.1101/354639
</p>
<p>Bernardo Rex. 2010. Breeding for quantitative traits in plants. Second edition. Stemma Press. 390 pp.
</p>
<p>Gilmour et al. 1995. Average Information REML: An efficient algorithm for variance parameter estimation in linear mixed models. Biometrics 51(4):1440-1450.
</p>
<p>Kang et al. 2008. Efficient control of population structure in model organism association mapping. Genetics 178:1709-1723.
</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient two-dimensional smoothing with P-spline ANOVA mixed models and nested bases. Computational Statistics and Data Analysis, 61, 22 - 37.
</p>
<p>Lee et al. 2015. MTG2: An efficient algorithm for multivariate linear mixed model analysis based on genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201.
</p>
<p>Maier et al. 2015. Joint analysis of psychiatric disorders increases accuracy of risk prediction for schizophrenia, bipolar disorder, and major depressive disorder. Am J Hum Genet; 96(2):283-294.
</p>
<p>Rodriguez-Alvarez, Maria Xose, et al. Correcting for spatial heterogeneity in plant breeding experiments with P-splines. Spatial Statistics 23 (2018): 52-71.
</p>
<p>Searle. 1993. Applying the EM algorithm to calculating ML and REML estimates of variance components. Paper invited for the 1993 American Statistical Association Meeting, San Francisco.
</p>
<p>Yu et al. 2006. A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Genetics 38:203-208.
</p>
<p>Tunnicliffe W. 1989. On the use of marginal likelihood in time series model estimation. JRSS 51(1):15-27.
</p>
<p>Zhang et al. 2010. Mixed linear model approach adapted for genome-wide association studies. Nat. Genet. 42:355-360.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using
#### command + shift + C |OR| control + shift + C
####=========================================####
#####========================================####
##### potato example
#####========================================####
# 
# data(DT_polyploid)
# DT &lt;- DT_polyploid
# GT &lt;- GT_polyploid
# MP &lt;- MP_polyploid
# ####=========================================####
# ####### convert markers to numeric format
# ####=========================================####
# numo &lt;- atcg1234(data=GT, ploidy=4);
# numo$M[1:5,1:5];
# numo$ref.allele[,1:5]
# 
# ###=========================================####
# ###### plants with both genotypes and phenotypes
# ###=========================================####
# common &lt;- intersect(DT$Name,rownames(numo$M))
# 
# ###=========================================####
# ### get the markers and phenotypes for such inds
# ###=========================================####
# marks &lt;- numo$M[common,]; marks[1:5,1:5]
# DT2 &lt;- DT[match(common,DT$Name),];
# DT2 &lt;- as.data.frame(DT2)
# DT2[1:5,]
# 
# ###=========================================####
# ###### Additive relationship matrix, specify ploidy
# ###=========================================####
# A &lt;- A.mat(marks)
# ###=========================================####
# ### run it as GWAS model
# ###=========================================####
# ans2 &lt;- GWAS(tuber_shape~1,
#              random=~vsr(Name,Gu=A),
#              rcov=~units,
#              gTerm = "u:Name",
#              M=marks, data=DT2)
# plot(ans2$scores[,1])
</code></pre>

<hr>
<h2 id='H'>Two-way id by features table</h2><span id='topic+H'></span>

<h3>Description</h3>

<p><code>H</code> creates a two way id by features table that can be used as the H argument in the <code><a href="#topic+rrc">rrc</a></code> function that extracts latent covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  H(timevar=NULL, idvar=NULL, response=NULL, Gu=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H_+3A_timevar">timevar</code></td>
<td>
<p>vector of the dataset containing the variable to be used to form columns in the wide table.</p>
</td></tr>
<tr><td><code id="H_+3A_idvar">idvar</code></td>
<td>
<p>vector of the dataset containing the variable to be used to form rows in the wide table.</p>
</td></tr>
<tr><td><code id="H_+3A_response">response</code></td>
<td>
<p>vector of the dataset containing the response variable to be used to fill the cells of the wide table.</p>
</td></tr>
<tr><td><code id="H_+3A_gu">Gu</code></td>
<td>
<p>an optional covariance matrix (<strong>not the inverse</strong>) between levels of the idvar in case a sparse (unbalanced) design between timevar and idvar exist.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just an aggregate, reshape and imputation of a long format table to a wide format table.
</p>


<h3>Value</h3>


<dl>
<dt>$H</dt><dd><p> two way table of id by features effects.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>H</code> in the <code><a href="#topic+rrc">rrc</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data(DT_h2)
# DT &lt;- DT_h2
# DT=DT[with(DT, order(Env)), ]
# H0 &lt;- with(DT, H(Env, Name, y) )
# Z &lt;- with(DT, rrc(Env, H0, 2))


</code></pre>

<hr>
<h2 id='H.mat'>
Combined relationship matrix H
</h2><span id='topic+H.mat'></span>

<h3>Description</h3>

<p>Given a matrix A and a matrix G returns a H matrix with the C++ Armadillo library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H.mat(A, G, tau = 1, omega = 1, tolparinv=1e-6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="H.mat_+3A_a">A</code></td>
<td>

<p>Additive relationship matrix based on pedigree.
</p>
</td></tr>
<tr><td><code id="H.mat_+3A_g">G</code></td>
<td>

<p>Additive relationship matrix based on marker data.  
</p>
</td></tr>
<tr><td><code id="H.mat_+3A_tau">tau</code></td>
<td>

<p>As described by Martini et al. (2018).
</p>
</td></tr>
<tr><td><code id="H.mat_+3A_omega">omega</code></td>
<td>

<p>As described by Martini et al. (2018). 
</p>
</td></tr>
<tr><td><code id="H.mat_+3A_tolparinv">tolparinv</code></td>
<td>

<p>Tolerance parameter for matrix inverse used when singularities are encountered in the estimation procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references 
</p>


<h3>Value</h3>

<p>H Matrix with the relationship between the individuals based on pedigree and corrected by molecular information
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Martini, J. W., Schrauf, M. F., Garcia-Baccino, C. A., Pimentel, E. C., Munilla, S., Rogberg-Munoz, A., ... &amp; Simianer, H. (2018). The effect of the H-1 scaling factors tau and omega on the structure of H in the single-step procedure. Genetics Selection Evolution, 50(1), 16.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
####random population of 200 lines with 1000 markers
####=========================================####
M &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  M[i,] &lt;- sample(c(-1,0,0,1), size=1000, replace=TRUE)
}
rownames(M) &lt;- 1:nrow(M)
v &lt;- sample(1:nrow(M),100)
M2 &lt;- M[v,]

A &lt;- A.mat(M) # assume this is a pedigree-based matrix for the sake of example
G &lt;- A.mat(M2)

H &lt;- H.mat(A,G)
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# hv &lt;- heatmap(H[1:15,1:15], col = colfunc(100),Colv = "Rowv")
</code></pre>

<hr>
<h2 id='imputev'>Imputing a numeric or character vector</h2><span id='topic+imputev'></span>

<h3>Description</h3>

<p>This function is a very simple function to impute a numeric or character vector with the mean or median value of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputev(x, method="median")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputev_+3A_x">x</code></td>
<td>
<p>a numeric or character vector.</p>
</td></tr>
<tr><td><code id="imputev_+3A_method">method</code></td>
<td>
<p>the method to choose between mean or median.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$x</dt><dd><p>a numeric or character vector imputed with the method selected.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### generate your mickey mouse -log10(p-values)
####=========================================####
set.seed(1253)
x &lt;- rnorm(100)
x[sample(1:100,10)] &lt;- NA
imputev(x)
</code></pre>

<hr>
<h2 id='isc'>identity covariance structure</h2><span id='topic+isc'></span>

<h3>Description</h3>

<p><code>isc</code> creates an identity covariance structure for the levels of the random effect  to be used with the <code><a href="#topic+mmec">mmec</a></code> solver. Any random effect with a special covariance structure should end with an isc() structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isc(x, thetaC=NULL, theta=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isc_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="isc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional 1 x 1 matrix for constraints in the variance-covariance components. The values in the matrix define how the variance-covariance components should be estimated:
</p>
<p>0: component will not be estimated
</p>
<p>1: component will be estimated and constrained to be positive (default)
</p>
<p>2: component will be estimated and unconstrained
</p>
<p>3: component will be fixed to the value provided in the theta argument
</p>
</td></tr>
<tr><td><code id="isc_+3A_theta">theta</code></td>
<td>
<p>an optional 1 x 1 matrix for initial values of the variance-covariance component. When providing customized values, these values should be scaled with respect to the original variance. For example, to provide an initial value of 1 to a given variance component, theta would be built as:
</p>
<p>theta = matrix( 1 / var(response) )
</p>
<p>The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values (theta) will be 0.15
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>See the function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>isc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
isc(x)

# data(DT_example)
# ans1 &lt;- mmec(Yield~Env,
#              random= ~ vsc( isc( Name ) ),
#              data=DT_example)
# summary(ans1)$varcomp

</code></pre>

<hr>
<h2 id='jet.colors'>Generate a sequence of colors alog the jet colormap.</h2><span id='topic+jet.colors'></span>

<h3>Description</h3>

<p><code>jet.colors(n)</code> generates a sequence of <code class="reqn">n</code>
colors from dark blue to cyan to yellow to dark red. It
is similar to the default color schemes in Python's
matplotlib or MATLAB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  jet.colors(n, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jet.colors_+3A_n">n</code></td>
<td>
<p>The number of colors to return.</p>
</td></tr>
<tr><td><code id="jet.colors_+3A_alpha">alpha</code></td>
<td>
<p>The transparency value of the colors. See
<code>?rgb</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors along the jet colorramp.
</p>


<h3>See Also</h3>

<p>The core function of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>{
# Plot a colorbar with jet.colors
image(matrix(seq(100), 100), col=jet.colors(100))
}
</code></pre>

<hr>
<h2 id='LD.decay'>Calculation of linkage disequilibrium decay</h2><span id='topic+LD.decay'></span>

<h3>Description</h3>

<p>This function calculates the LD decay based on a marker matrix and a map with distances between markers in cM or base pairs.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD.decay(markers,map,silent=FALSE,unlinked=FALSE,gamma=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LD.decay_+3A_markers">markers</code></td>
<td>
<p>a numeric matrix of markers (columns) by individuals (rows) in -1, 0, 1 format.</p>
</td></tr>
<tr><td><code id="LD.decay_+3A_map">map</code></td>
<td>
<p>a data frame with 3 columns &quot;Locus&quot; (name of markers), &quot;LG&quot; (linkage group or chromosome), and &quot;Position&quot; (in cM or base pairs). </p>
</td></tr>
<tr><td><code id="LD.decay_+3A_silent">silent</code></td>
<td>
<p>a TRUE/FALSE value statement indicating if the program should or should not display the progress bar. silent=TRUE means that will not be displayed.</p>
</td></tr>
<tr><td><code id="LD.decay_+3A_unlinked">unlinked</code></td>
<td>
<p>a TRUE/FALSE value statement indicating if the program should or should not calculate the alpha(see next argument) percentile of interchromosomal LD.</p>
</td></tr>
<tr><td><code id="LD.decay_+3A_gamma">gamma</code></td>
<td>
<p>a percentile value for LD breakage to be used in the calculation of interchromosomal LD extent.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$resp</dt><dd><p> a list with 3 elements; &quot;by.LG&quot;, &quot;all.LG&quot;, &quot;LDM&quot;. The first element (by.LG) is a list with as many elements as chromosomes where each contains a matrix with 3 columns, the distance, the r2 value, and the p-value associated to the chi-square test for disequilibrium. The second element (all.LG) has a big matrix with distance, r2 values and p-values, for each point from all chromosomes in a single data.frame. The third element (LDM) is the matrix of linkage disequilibrium between pairs of markers.
</p>
<p>If unlinked is selected the program should return the gamma percentile interchromosomal LD (r2) for each chromosome and average.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Laido, Giovanni, et al. Linkage disequilibrium and genome-wide association mapping in tetraploid wheat (Triticum turgidum L.). PloS one 9.4 (2014): e95211.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples using 
#### command + shift + C |OR| control + shift + C
####=========================================####
data(DT_cpdata)
#### get the marker matrix
CPgeno &lt;- GT_cpdata; CPgeno[1:5,1:5]
#### get the map
mapCP &lt;- MP_cpdata; head(mapCP)
names(mapCP) &lt;- c("Locus","Position","LG")
#### with example purposes we only do 3 chromosomes
mapCP &lt;- mapCP[which(mapCP$LG &lt;= 3),]
#### run the function
# res &lt;- LD.decay(CPgeno, mapCP)
# names(res)
#### subset only markers with significant LD
# res$all.LG &lt;- res$all.LG[which(res$all.LG$p &lt; .001),]
#### plot the LD decay
# with(res$all.LG, plot(r2~d,col=transp("cadetblue"),
#                     xlim=c(0,55), ylim=c(0,1), 
#                     pch=20,cex=0.5,yaxt="n",
#                     xaxt="n",ylab=expression(r^2),
#                     xlab="Distance in cM")
#                     )
# axis(1, at=seq(0,55,5), labels=seq(0,55,5))
# axis(2,at=seq(0,1,.1), labels=seq(0,1,.1), las=1)

#### if you want to add the loess regression lines
#### this could take a long time!!!
# mod &lt;- loess(r2 ~ d, data=res$all.LG)
# par(new=T)
# lilo &lt;- predict(mod,data.frame(d=1:55))
# plot(lilo, bty="n", xaxt="n", yaxt="n", col="green", 
#      type="l", ylim=c(0,1),ylab="",xlab="",lwd=2)
# res3 &lt;- LD.decay(markers=CPgeno, map=mapCP, 
#                 unlinked = TRUE,gamma = .95)
# abline(h=res3$all.LG, col="red")
</code></pre>

<hr>
<h2 id='leg'>Legendre polynomial matrix</h2><span id='topic+leg'></span>

<h3>Description</h3>

<p>Legendre polynomials of order 'n' are created given a vector 'x' and normalized to lay between values u and v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  leg(x,n=1,u=-1,v=1, intercept=TRUE, intercept1=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leg_+3A_x">x</code></td>
<td>
<p>numeric vector to be used for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_n">n</code></td>
<td>
<p>order of the Legendre polynomials.</p>
</td></tr>
<tr><td><code id="leg_+3A_u">u</code></td>
<td>
<p>lower bound for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_v">v</code></td>
<td>
<p>upper bound for the polynomial.</p>
</td></tr>
<tr><td><code id="leg_+3A_intercept">intercept</code></td>
<td>
<p>a TRUE/FALSE value indicating if the intercept should be included.</p>
</td></tr>
<tr><td><code id="leg_+3A_intercept1">intercept1</code></td>
<td>
<p>a TRUE/FALSE value indicating if the intercept should have value 1 (is multiplied by sqrt(2)).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> an Legendre polynomial matrix of order n.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(rep(1:3,100))
# you need to install the orthopolynom library
# leg(x, n=1)
# leg(x, n=2)

# see dataset data(DT_legendre) for a random regression modeling example

</code></pre>

<hr>
<h2 id='list2usmat'>list or vector to unstructured matrix</h2><span id='topic+list2usmat'></span>

<h3>Description</h3>

<p><code>list2usmat</code> creates an unstructured square matrix taking a vector or list to fill the diagonal and upper triangular with the values provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  list2usmat(sigmaL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list2usmat_+3A_sigmal">sigmaL</code></td>
<td>
<p>vector or list of values to put on the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a matrix with the values provided.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>list2usmat</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>list2usmat(as.list(1:3))
list2usmat(as.list(1:10))
</code></pre>

<hr>
<h2 id='logspace'>Decreasing logarithmic trend</h2><span id='topic+logspace'></span>

<h3>Description</h3>

<p>logspace creates a vector with decreasing logaritmic trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logspace(n, start, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logspace_+3A_n">n</code></td>
<td>
<p>number of values to generate.</p>
</td></tr>
<tr><td><code id="logspace_+3A_start">start</code></td>
<td>
<p>initial value.</p>
</td></tr>
<tr><td><code id="logspace_+3A_end">end</code></td>
<td>
<p>last value.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a vector of length n with logarithmic decrease trend.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
logspace(5, 1, .05)

</code></pre>

<hr>
<h2 id='manhattan'>Creating a manhattan plot</h2><span id='topic+manhattan'></span>

<h3>Description</h3>

<p>This function was designed to create a manhattan plot using a data frame with columns &quot;Chrom&quot; (Chromosome),  &quot;Position&quot; and &quot;p.val&quot; (significance for the test).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan(map, col=NULL, fdr.level=0.05, show.fdr=TRUE, PVCN=NULL, ylim=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manhattan_+3A_map">map</code></td>
<td>
<p>the data frame with 3 columns with names; &quot;Chrom&quot; (Chromosome),  &quot;Position&quot; and &quot;p.val&quot; (significance for the test).</p>
</td></tr>
<tr><td><code id="manhattan_+3A_col">col</code></td>
<td>
<p>colors prefered by the user to be used in the manhattan plot. The default is NULL which will use the red-blue palette.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_fdr.level">fdr.level</code></td>
<td>
<p>false discovery rate to be drawn in the plot.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_show.fdr">show.fdr</code></td>
<td>
<p>a TRUE/FALSE value indicating if the FDR value should be shown in the manhattan plot or not. By default is TRUE meaning that will be displayed.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_pvcn">PVCN</code></td>
<td>
<p>In case the user wants to provide the name of the column that should be treated as the &quot;p.val&quot; column expected by the program in the 'map' argument.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_ylim">ylim</code></td>
<td>
<p>the y axis limits for the manhattan plot if the user wants to customize it. By default the plot will reflect the minimum and maximum values found.</p>
</td></tr>
<tr><td><code id="manhattan_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the plot function such as pch, cex, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return:
</p>

<dl>
<dt>$plot.data</dt><dd><p> a manhattan plot</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#random population of 200 lines with 1000 markers
M &lt;- matrix(rep(0,200*1000),1000,200)
for (i in 1:200) {
  M[,i] &lt;- ifelse(runif(1000)&lt;0.5,-1,1)
}
colnames(M) &lt;- 1:200
set.seed(1234)
pp &lt;- abs(rnorm(500,0,3));pp[23:34] &lt;- abs(rnorm(12,0,20))
geno &lt;- data.frame(Locus=paste("m",1:500, sep="."),Chrom=sort(rep(c(1:5),100)),
                   Position=rep(seq(1,100,1),5),
                   p.val=pp, check.names=FALSE)
geno$Locus &lt;- as.character(geno$Locus)
## look at the data, 5LGs, 100 markers in each
## -log(p.val) value for simulated trait
head(geno)
tail(geno)
manhattan(geno)

</code></pre>

<hr>
<h2 id='map.plot'>Creating a genetic map plot</h2><span id='topic+map.plot'></span>

<h3>Description</h3>

<p>This function was designed to create a genetic map plot using a data frame indicating the Linkage Group (LG), Position and marker names (Locus). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.plot(data, trait = NULL, trait.scale = "same", 
        col.chr = NULL, col.trait = NULL, type = "hist", cex = 0.4,
        lwd = 1, cex.axis = 0.4, cex.trait=0.8, jump = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map.plot_+3A_data">data</code></td>
<td>
<p>the data frame with 3 columns with names; Locus, LG and Position</p>
</td></tr>
<tr><td><code id="map.plot_+3A_trait">trait</code></td>
<td>
<p>if something wants to be plotted next the linkage groups the user must indicate the name of the column containing the values to be ploted, i.e. p-values, LOD scores, X2 segregation distortion values, etc.</p>
</td></tr>
<tr><td><code id="map.plot_+3A_trait.scale">trait.scale</code></td>
<td>
<p>is trait is not NULL, this is a character value indicating if the y axis limits for the trait plotted next to the chromosomes should be the same or different for each linkage group. The default value is &quot;same&quot;, which means that the same y axis limit is conserved across linkage groups. For giving an individual y axis limit for each linkage group write &quot;diff&quot;.</p>
</td></tr>
<tr><td><code id="map.plot_+3A_col.chr">col.chr</code></td>
<td>
<p>a vector with color names for the chromosomes. If NULL they will be drawn in gray-black scale.</p>
</td></tr>
<tr><td><code id="map.plot_+3A_col.trait">col.trait</code></td>
<td>
<p>a vector with color names for the dots, lines or histogram for the trait plotted next to the LG's</p>
</td></tr>
<tr><td><code id="map.plot_+3A_type">type</code></td>
<td>
<p>a character value indicating if the trait should be plotted as scatterplot 'dot', histogram 'hist', line 'line' next to the chromosomes.</p>
</td></tr>
<tr><td><code id="map.plot_+3A_cex">cex</code></td>
<td>
<p>the cex value determining the size of the cM position labels in the LGs</p>
</td></tr>
<tr><td><code id="map.plot_+3A_lwd">lwd</code></td>
<td>
<p>the width of the lines in the plot</p>
</td></tr>
<tr><td><code id="map.plot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>the cex value for sizing the labels of LGs and traits plotted (top labels)</p>
</td></tr>
<tr><td><code id="map.plot_+3A_cex.trait">cex.trait</code></td>
<td>
<p>the cex value for sizing the dots or lines of the trait plotted</p>
</td></tr>
<tr><td><code id="map.plot_+3A_jump">jump</code></td>
<td>
<p>a scalar value indicating how often should be drawn a number next to the LG indicating the position. The default is 5 which means every 5 cM a label will be drawn, i.e. 0,5,10,15,... cM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return:
</p>

<dl>
<dt>$plot.data</dt><dd><p> a plot with the LGs and the information used to create a plot</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#random population of 200 lines with 1000 markers
M &lt;- matrix(rep(0,200*1000),1000,200)
for (i in 1:200) {
  M[,i] &lt;- ifelse(runif(1000)&lt;0.5,-1,1)
}
colnames(M) &lt;- 1:200
set.seed(1234)
geno &lt;- data.frame(Locus=paste("m",1:500, sep="."),LG=sort(rep(c(1:5),100)),
                   Position=rep(seq(1,100,1),5),
                   X2=rnorm(500,10,4), check.names=FALSE)
geno$Locus &lt;- as.character(geno$Locus)
## look at the data, 5LGs, 100 markers in each
## X2 value for segregation distortion simulated
head(geno)
tail(geno)
table(geno$LG) # 5 LGs, 100 marks
map.plot(geno, trait="X2", type="line")
map.plot(geno, trait="X2", type="hist")
map.plot(geno, trait="X2", type="dot")

# data("DT_cpdata")
# MP &lt;- MP_cpdata
# colnames(MP)[3] &lt;- c("LG")
# head(MP)
# map.plot(MP, type="line", cex=0.6)

</code></pre>

<hr>
<h2 id='MEMMA'>Multivariate Efficient Mixed Model Association Algorithm</h2><span id='topic+MEMMA'></span>

<h3>Description</h3>

<p>This function is used internally in the function <code><a href="#topic+mmer">mmer</a></code> when multiple responses are selected for a single variance component other than the error. It uses the efficient mixed model association (MEMMA) algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEMMA(Y, X=NULL, ZETA=NULL, tolpar = 1e-06, tolparinv = 1e-06, check.model=TRUE,
      silent=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MEMMA_+3A_y">Y</code></td>
<td>
<p>a numeric vector for the response variable</p>
</td></tr>
<tr><td><code id="MEMMA_+3A_x">X</code></td>
<td>
<p>an incidence matrix for fixed effects.</p>
</td></tr>
<tr><td><code id="MEMMA_+3A_zeta">ZETA</code></td>
<td>
<p>an incidence matrix for random effects. This can be for one or more random effects. This NEEDS TO BE PROVIDED AS A LIST STRUCTURE. For example Z=list(list(Z=Z1, K=K1), list(Z=Z2, K=K2), list(Z=Z3, K=K3)) makes a 2 level list for 3 random effects. The general idea is that each random effect with or without its variance-covariance structure is a list, i.e. list(Z=Z1, K=K1) where Z is the incidence matrix and K the var-cov matrix. When moving to more than one random effect we need to make several lists that need to be inside another list. What we call a 2-level list, i.e. list(Z=Z1, K=K1) and list(Z=Z2, K=K2) would need to be put in the form; list(list(Z=Z1, K=K1),list(Z=Z1, K=K1)), which as can be seen, is a list of lists (2-level list). </p>
</td></tr>
<tr><td><code id="MEMMA_+3A_tolpar">tolpar</code></td>
<td>
<p>tolerance parameter for convergence</p>
</td></tr>
<tr><td><code id="MEMMA_+3A_tolparinv">tolparinv</code></td>
<td>
<p>tolerance parameter for matrix inverse</p>
</td></tr>
<tr><td><code id="MEMMA_+3A_check.model">check.model</code></td>
<td>
<p>a TRUE/FALSE value indicating if list structure provided by the user is correct to fix it. The default is TRUE but is turned off to FALSE within the mmer function which would imply a double check.</p>
</td></tr>
<tr><td><code id="MEMMA_+3A_silent">silent</code></td>
<td>
<p>a TRUE/FALSE value indicating if the function should draw the progress bar or iterations performed while working or should not be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>.
</p>
<p>The likelihood function optimized in this algorithm is:
</p>
<p>.
</p>
<p>logL = (n - p) * log(sum(eta^2/(lambda + delta)) + sum(log(lambda + delta))
</p>
<p>.
</p>
<p>where: 
(n-p)  refers to the degrees of freedom
lambda are the eigenvalues mentioned by Kang et al.(2008) 
delta is the REML estimator of the ridge parameter
</p>
<p>.
</p>
<p>The algorithm can be summarized in the next steps:
</p>
<p>.
</p>
<p>1) provide initial value for the ridge parameter
</p>
<p>2) estimate S = I - X(X'X)-X'
</p>
<p>3) obtain the phenotypic variance V = ZKZ' + delta.prov*I 
</p>
<p>4) perform an eigen decomposition of SVS 
</p>
<p>5) create &quot;lambda&quot;&quot; as the eigenvalues of SVS and &quot;U&quot;&quot; as the eigenvectors
</p>
<p>6) estimate eta=U'y 
</p>
<p>7) optimize the likelihood shown above providing &quot;eta&quot;, &quot;lambdas&quot; and optimize with respect to &quot;delta&quot; which is the ridge parameter and contains Ve/Vu
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>

<dl>
<dt>$Vu</dt><dd><p> a scalar value for the variance component estimated</p>
</dd>
<dt>$Ve</dt><dd><p> a scalar value for the error variance estimated</p>
</dd>
<dt>$V.inv</dt><dd><p> a matrix with the inverse of the phenotypic variance V = ZGZ+R, V^-1</p>
</dd>
<dt>$u.hat</dt><dd><p> a vector with BLUPs for random effects</p>
</dd>
<dt>$Var.u.hat</dt><dd><p> a vector with variances for BLUPs</p>
</dd>
<dt>$PEV.u.hat</dt><dd><p> a vector with predicted error variance for BLUPs</p>
</dd>
<dt>$beta.hat</dt><dd><p> a vector for BLUEs of fixed effects</p>
</dd>
<dt>$Var.beta.hat</dt><dd><p> a vector with variances for BLUEs</p>
</dd>
<dt>$X</dt><dd><p> incidence matrix for fixed effects, if not passed is assumed to only include the intercept</p>
</dd>
<dt>$Z</dt><dd><p> incidence matrix for random effects, if not passed is assumed to be a diagonal matrix</p>
</dd>
<dt>$K</dt><dd><p> the var-cov matrix for the random effect fitted in Z</p>
</dd>
<dt>$ll</dt><dd><p> the log-likelihood value for obtained when optimizing the likelihood function when using ML or REML</p>
</dd>
</dl>



<h3>References</h3>

<p>Kang et al. 2008. Efficient control of population structure in model organism association mapping. Genetics 178:1709-1723.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
# data(CPdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# ### look at the data
# head(DT)
# GT[1:5,1:5]
# ## fit a model including additive and dominance effects
# Y &lt;- DT[,c("color","Yield")]
# Za &lt;- diag(dim(Y)[1])
# A &lt;- A.mat(GT) # additive relationship matrix
# ####================####
# #### ADDITIVE MODEL ####
# ####================####
# ETA.A &lt;- list(add=list(Z=Za,K=A))
# #ans.A &lt;- MEMMA(Y=Y, ZETA=ETA.A)
# #ans.A$var.comp
</code></pre>

<hr>
<h2 id='mmec'>
<strong>m</strong>ixed <strong>m</strong>odel <strong>e</strong>quations for <strong>c</strong> coefficients
</h2><span id='topic+mmec'></span>

<h3>Description</h3>

<p>The <code>mmec</code> function uses the Henderson mixed model equations and the Average Information algorithm coded in C++ using the Armadillo library to optimize matrix operations common in problems with sparse data (e.g., genotype by environment models). This algorithm is <strong>intended to be used for problems of the type r &gt; c (more records in the data than coefficients to estimate)</strong>. For problems with of the type c &gt; r (more coefficients to estimate than records available), the direct inversion algorithms are faster and we recommend to shift to the use of the <code><a href="#topic+mmer">mmer</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mmec(fixed, random, rcov, data, W, nIters=25, tolParConvLL = 1e-03,
     tolParConvNorm = 1e-04, tolParInv = 1e-06, naMethodX="exclude",
     naMethodY="exclude", returnParam=FALSE, dateWarning=TRUE,
     verbose=TRUE,addScaleParam=NULL, stepWeight=NULL, emWeight=NULL,
     contrasts=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmec_+3A_fixed">fixed</code></td>
<td>
<p>A formula specifying the <strong>response variable(s)</strong> <strong>and fixed effects</strong>, i.e:
</p>
<p><em>response ~ covariate</em>
</p>
</td></tr>
<tr><td><code id="mmec_+3A_random">random</code></td>
<td>
<p>A formula specifying the name of the <strong>random effects</strong>, e.g., <em>random= ~ genotype + year</em>.
</p>
<p>Useful functions can be used to fit heterogeneous variances and other special models (<em>see 'Special Functions' in the Details section for more information</em>):
</p>
<p><code><a href="#topic+vsc">vsc</a>(...,Gu)</code> is the main function to specify variance models and special structures for random effects. On the ... argument you provide the unknown variance-covariance structures (e.g., usc,dsc,at,csc) and the random effect where such covariance structure will be used (the random effect of interest). Gu is used to provide known covariance matrices among the levels of the random effect. Auxiliar functions for building the variance models are:
</p>
<p>** <code><a href="#topic+dsc">dsc</a>(x)</code>, <code><a href="#topic+usc">usc</a>(x)</code>, <code><a href="#topic+rrc">rrc</a>(x,y,z)</code> , <code><a href="#topic+isc">isc</a>(x)</code>,<code><a href="#topic+csc">csc</a>(x)</code>, and <code><a href="#topic+atc">atc</a>(x,levs)</code> can be used to specify unknown diagonal, unstructured, reduced-rank, identity, and customized unstructured and diagonal covariance structures respectively to be estimated by REML.
</p>
<p>** <code><a href="#topic+unsm">unsm</a>(x)</code>, <code><a href="#topic+fixm">fixm</a>(x)</code> and <code><a href="base.html#topic+diag">diag</a>(x)</code> can be used to build easily matrices to specify constraints in the Gtc argument of the <code><a href="#topic+vsc">vsc</a>()</code> function.
</p>
<p>** <code><a href="#topic+overlay">overlay</a>()</code>, <code><a href="#topic+spl2Dc">spl2Dc</a>()</code>, and <code><a href="#topic+leg">leg</a>()</code>, <code><a href="#topic+redmm">redmm</a>()</code> functions can be used to specify overlayed of design matrices of random effects, two dimensional spline, random regression, and dimensionality-reduction models within the <code><a href="#topic+vsc">vsc</a>()</code> function.
</p>
</td></tr>
<tr><td><code id="mmec_+3A_rcov">rcov</code></td>
<td>
<p>A formula specifying the name of the <strong>error term</strong>, e.g., <em>rcov= ~ units</em>.
</p>
<p>Special heterogeneous and special variance models and constraints for the residual part are the same used on the random term but the name of the random effect is always &quot;units&quot; which can be thought as a column with as many levels as rows in the data, e.g., <em>rcov=~vsc(dsc(covariate),isc(units))</em>
</p>
<p>When fitting structures at the level of residuals please make sure that your data is sorted based on the factors defining the structure. For example, for <em>rcov= ~ vsc(dsc(xx), isc(units))</em> sort the datatset by the variable xx.
</p>
</td></tr>
<tr><td><code id="mmec_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables specified in the formulas for response, fixed, and random effects.</p>
</td></tr>
<tr><td><code id="mmec_+3A_w">W</code></td>
<td>
<p>Weights matrix (e.g., when covariance among plots exist). Internally W is squared and inverted as Wsi = solve(chol(W)), then the residual matrix is calculated as R = Wsi*O*Wsi.t(), where * is the matrix product, and O is the original residual matrix.</p>
</td></tr>
<tr><td><code id="mmec_+3A_niters">nIters</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="mmec_+3A_tolparconvll">tolParConvLL</code></td>
<td>
<p>Convergence criteria based in the change of log-likelihood between iteration i and i-1.</p>
</td></tr>
<tr><td><code id="mmec_+3A_tolparconvnorm">tolParConvNorm</code></td>
<td>
<p>Convergence criteria based in the norm proposed by Jensen, Madsen and Thompson (1997):
</p>
<p>e1 = || InfMatInv.diag()/sqrt(N) * dLu ||
</p>
<p>where InfMatInv.diag() is the diagonal of the inverse of the information matrix, N is the total number of variance components, and dLu is the vector of first derivatives.
</p>
</td></tr>
<tr><td><code id="mmec_+3A_tolparinv">tolParInv</code></td>
<td>
<p>Tolerance parameter for matrix inverse used when singularities are encountered in the estimation procedure.</p>
</td></tr>
<tr><td><code id="mmec_+3A_namethodx">naMethodX</code></td>
<td>
<p>One of the two possible values; &quot;include&quot; or &quot;exclude&quot;. If &quot;include&quot; is selected then the function will impute the X matrices for fixed effects with the median value. If &quot;exclude&quot; is selected it will get rid of all rows with missing values for the X (fixed) covariates. The default is &quot;exclude&quot;. The &quot;include&quot; option should be used carefully.</p>
</td></tr>
<tr><td><code id="mmec_+3A_namethody">naMethodY</code></td>
<td>
<p>One of the three possible values; &quot;include&quot;, &quot;include2&quot; or &quot;exclude&quot; (default) to treat the observations in response variable to be used in the estimation of variance components. The first option &quot;include&quot; will impute the response variables for all rows with the median value, whereas &quot;include2&quot; imputes the responses only for rows where there is observation(s) for at least one of the responses (only available in the multi-response models). If &quot;exclude&quot; is selected (default) it will get rid of rows in response(s) where missing values are present for at least one of the responses.</p>
</td></tr>
<tr><td><code id="mmec_+3A_returnparam">returnParam</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should return the parameters to be used for fitting the model instead of fitting the model.</p>
</td></tr>
<tr><td><code id="mmec_+3A_datewarning">dateWarning</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should warn you when is time to update the sommer package.</p>
</td></tr>
<tr><td><code id="mmec_+3A_verbose">verbose</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should return the progress of the iterative algorithm.</p>
</td></tr>
<tr><td><code id="mmec_+3A_addscaleparam">addScaleParam</code></td>
<td>
<p>additional scale parameters for the thetaF matrix.</p>
</td></tr>
<tr><td><code id="mmec_+3A_stepweight">stepWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating the weight used to multiply the update (delta) for variance components at each iteration. If NULL the 1st iteration will be multiplied by 0.5, the 2nd by 0.7, and the rest by 0.9. This argument can help to avoid that variance components go outside the parameter space in the initial iterations which happens very often with the AI method but it can be detected by looking at the behavior of the likelihood. In that case you may want to give a smaller weight.</p>
</td></tr>
<tr><td><code id="mmec_+3A_emweight">emWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating with values between 0 and 1 the weight assigned to the EM information matrix. And the values 1 - emWeight will be applied to the AI information matrix to produce a joint information matrix. By default the function gives a weight to the EM algorithm of a logarithmic decrease rate using the following code <code>logspace(nIters,1,0.05)</code>. </p>
</td></tr>
<tr><td><code id="mmec_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of model.matrix.default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of this function requires a good understanding of mixed models. Please review the 'sommer.quick.start' vignette and pay attention to details like format of your random and fixed variables (e.g. character and factor variables have different properties when returning BLUEs or BLUPs, please see the 'sommer.changes.and.faqs' vignette).
</p>
<p><strong>For tutorials</strong> on how to perform different analysis with sommer please look at the vignettes by typing in the terminal:
</p>
<p>vignette(&quot;v1.sommer.quick.start&quot;)
</p>
<p>vignette(&quot;v2.sommer.changes.and.faqs&quot;)
</p>
<p>vignette(&quot;v3.sommer.qg&quot;)
</p>
<p>vignette(&quot;v4.sommer.gxe&quot;)
</p>
<p><strong>Citation</strong>
</p>
<p>Type <em>citation(&quot;sommer&quot;)</em> to know how to cite the sommer package in your publications.
</p>
<p><strong>Special variance structures</strong>
</p>
<p><code><a href="#topic+vsc">vsc</a>(<a href="#topic+atc">atc</a>(x,levels),isc(y))</code>
</p>
<p>can be used to specify heterogeneous variance for the &quot;y&quot; covariate at specific levels of the covariate &quot;x&quot;, e.g., <em>random=~vsc(at(Location,c(&quot;A&quot;,&quot;B&quot;)),isc(ID))</em> fits a variance component for ID at levels A and B of the covariate Location.
</p>
<p><code><a href="#topic+vsc">vsc</a>(<a href="#topic+dsc">dsc</a>(x),isc(y))</code>
</p>
<p>can be used to specify a diagonal covariance structure for the &quot;y&quot; covariate for all levels of the covariate &quot;x&quot;, e.g., <em>random=~vsc(dsc(Location),isc(ID))</em>  fits a variance component for ID at all levels of the covariate Location.
</p>
<p><code><a href="#topic+vsc">vsc</a>(<a href="#topic+usc">usc</a>(x),isc(y))</code>
</p>
<p>can be used to specify an unstructured covariance structure for the &quot;y&quot; covariate for all levels of the  covariate &quot;x&quot;, e.g., <em>random=~vsc(usc(Location),isc(ID))</em>  fits variance and covariance components for ID at all levels of the covariate Location.
</p>
<p><code><a href="#topic+vsc">vsc</a>(<a href="#topic+usc">usc</a>(<a href="#topic+rrc">rrc</a>(x,y,z,nPC)),isc(y))</code>
</p>
<p>can be used to specify an unstructured covariance structure for the &quot;y&quot; effect for all levels of the  covariate &quot;x&quot;, and a response variable &quot;z&quot;, e.g., <em>random=~vsc(rrc(Location,ID,response, nPC=2),isc(ID))</em>  fits a reduced-rank factor analytic covariance for ID at 2 principal components of the covariate Location.
</p>
<p><code><a href="#topic+vsc">vsc</a>(isc(<a href="#topic+overlay">overlay</a>(...,rlist=NULL,prefix=NULL)))</code>
</p>
<p>can be used to specify overlay of design matrices between consecutive random effects specified, e.g., <em>random=~vsc(isc(overlay(male,female)))</em> overlays (overlaps) the incidence matrices for the male and female random effects to obtain a single variance component for both effects. The 'rlist' argument is a list with each element being a numeric value that multiplies the incidence matrix to be overlayed. See <code><a href="#topic+overlay">overlay</a></code> for details.Can be combined with vsc().
</p>
<p><code><a href="#topic+vsc">vsc</a>(isc(<a href="#topic+redmm">redmm</a>(x,M,nPC)))</code>
</p>
<p>can be used to create a reduced model matrix of an effect (x) assumed to be a linear function of some feature matrix (M), e.g., <em>random=~vsc(isc(redmm(x,M)))</em> creates an incidence matrix from a very large set of features (M) that belong to the levels of x to create a reduced model matrix. See <code><a href="#topic+redmm">redmm</a></code> for details.Can be combined with vsc().
</p>
<p><code><a href="#topic+vsc">vsc</a>(<a href="#topic+leg">leg</a>(x,n),isc(y))</code>
</p>
<p>can be used to fit a random regression model using a numerical variable <code>x</code> that marks the trayectory for the random effect <code>y</code>. The leg function can be combined with the special functions <code>dsc</code>, <code>usc</code> <code>at</code> and <code>csc</code>. For example <em>random=~vsc(leg(x,1),isc(y))</em> or <em>random=~vsc(usc(leg(x,1)),isc(y))</em>.
</p>
<p><code><a href="#topic+spl2Dc">spl2Dc</a>(x.coord, y.coord, at.var, at.levels))</code>
</p>
<p>can be used to fit a 2-dimensional spline (e.g., spatial modeling) using coordinates <code>x.coord</code> and <code>y.coord</code> (in numeric class) assuming multiple variance components. The 2D spline can be fitted at specific levels using the <code>at.var</code> and <code>at.levels</code> arguments. For example <em>random=~spl2Dc(x.coord=Row,y.coord=Range,at.var=FIELD)</em>.
</p>
<p><strong>Covariance between random effects</strong>
</p>
<p><code><a href="#topic+covc">covc</a>( <a href="#topic+vsc">vsc</a>(<a href="#topic+isc">isc</a>(ran1)), <a href="#topic+vsc">vsc</a>(<a href="#topic+isc">isc</a>(ran2)) )</code>
</p>
<p>can be used to specify covariance between two different random effects, e.g., <em>random=~covc( vsc(isc(x1)), vsc(isc(x2)) )</em> where two random effects in their own vsc() structure are encapsulated. Only applies for simple random effects.
</p>
<p><strong>S3 methods</strong>
</p>
<p>S3 methods are available for some parameter extraction such as <code><a href="#topic+fitted.mmec">fitted.mmec</a></code>, <code><a href="#topic+residuals.mmec">residuals.mmec</a></code>, <code><a href="#topic+summary.mmec">summary.mmec</a></code>, <code><a href="#topic+randef">randef</a></code>, <code><a href="#topic+coef.mmec">coef.mmec</a></code>, <code><a href="#topic+anova.mmec">anova.mmec</a></code>, <code><a href="#topic+plot.mmec">plot.mmec</a></code>, and <code><a href="#topic+predict.mmec">predict.mmec</a></code> to obtain adjusted means. In addition, the <code><a href="#topic+vpredict">vpredict</a></code> function (replacement of the pin function) can be used to estimate standard errors for linear combinations of variance components (e.g., ratios like h2). The <code><a href="#topic+r2">r2</a></code> function calculates reliability. 
</p>
<p><strong>Additional Functions</strong>
</p>
<p>Additional functions for genetic analysis have been included such as relationship matrix building (<code><a href="#topic+A.mat">A.mat</a></code>, <code><a href="#topic+D.mat">D.mat</a></code>, <code><a href="#topic+E.mat">E.mat</a></code>, <code><a href="#topic+H.mat">H.mat</a></code>),  build a genotypic hybrid marker matrix (<code><a href="#topic+build.HMM">build.HMM</a></code>), plot of genetic maps (<code><a href="#topic+map.plot">map.plot</a></code>), and manhattan plots (<code><a href="#topic+manhattan">manhattan</a></code>). If you need to build a pedigree-based relationship matrix use the <code>getA</code> function from the pedigreemm package.
</p>
<p><strong>Bug report and contact</strong>
</p>
<p>If you have any technical questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com
</p>
<p>If you have any bug report please go to https://github.com/covaruber/sommer or send me an email to address it asap, just make sure you have read the vignettes carefully before sending your question.
</p>
<p><strong>Example Datasets</strong>
</p>
<p>The package has been equiped with several datasets to learn how to use the sommer package:
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code>, <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> and <code><a href="#topic+DT_mohring">DT_mohring</a></code> datasets have examples to fit half and full diallel designs.
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects.
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids.
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p>* <code><a href="#topic+DT_legendre">DT_legendre</a></code> simulated dataset for random regression model.
</p>
<p>* <code><a href="#topic+DT_sleepstudy">DT_sleepstudy</a></code> dataset to know how to translate lme4 models to sommer models.
</p>
<p>* <code><a href="#topic+DT_ige">DT_ige</a></code> dataset to show how to fit indirect genetic effect models.
</p>
<p><strong>Models Enabled</strong>
</p>
<p>For details about the models enabled and more information about the covariance structures please check the help page of the package (<code><a href="#topic+sommer">sommer</a></code>).
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>
<table role = "presentation">
<tr><td><code>llik</code></td>
<td>
<p>the vector of log-likelihoods across iterations</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the coeficient matrix extended by the response vector y] </p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the column binded matrix W = [X Z y] </p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the vector of fixed effect.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the vector of random effect.</p>
</td></tr>
<tr><td><code>bu</code></td>
<td>
<p>the vector of fixed and random effects together.</p>
</td></tr>
<tr><td><code>Ci</code></td>
<td>
<p>the inverse of the coefficient matrix.</p>
</td></tr>
<tr><td><code>avInf</code></td>
<td>
<p>The matrix of second derivatives of the likelihood with respect to the i.j th variance-covariance component.</p>
</td></tr>
<tr><td><code>monitor</code></td>
<td>
<p>The values of the variance-covariance components across iterations during the REML estimation.</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>
<p>The vector of constraints.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a TRUE/FALSE statement indicating if the model converged.</p>
</td></tr>
<tr><td><code>partitions</code></td>
<td>
<p>a list where each element contains a matrix indicating where each random effect starts and ends.</p>
</td></tr>
<tr><td><code>percDelta</code></td>
<td>
<p>the matrix of percentage change in deltas (see tolParConvNorm argument).</p>
</td></tr>
<tr><td><code>normMonitor</code></td>
<td>
<p>the matrix of the three norms calculated (see tolParConvNorm argument).</p>
</td></tr>
<tr><td><code>toBoundary</code></td>
<td>
<p>the matrix of variance components that were forced to the boundary across iterations.</p>
</td></tr>
<tr><td><code>Cchol</code></td>
<td>
<p>the Cholesky decomposition of the coefficient matrix.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a list of estimated variance covariance matrices. Each element of the list corresponds to the different random and residual components</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the vector form of the variance-covariance parameters.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the dataset used in the model fitting.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector.</p>
</td></tr>
<tr><td><code>partitionsX</code></td>
<td>
<p>a list where each element contains a matrix indicating where each fixed effect starts and ends.</p>
</td></tr>
<tr><td><code>uList</code></td>
<td>
<p>a list containing the BLUPs in data frame format where rows are levels of the random effects and column the different factors at which the random effect is fitted. This is specially useful for diagonal and unstructured models.</p>
</td></tr>
<tr><td><code>uPevList</code></td>
<td>
<p>a list containing the BLUPs in data frame format where rows are levels of the random effects and column the different factors at which the random effect is fitted. This is specially useful for diagonal and unstructured models.</p>
</td></tr>
<tr><td><code>Dtable</code></td>
<td>
<p>the table to be used for the predict function to help the program recognize the factors available.</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>the fixed, random and residual formulas from the mmec model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Coded by Christelle Fernandez Camacho &amp; Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Jensen, J., Mantysaari, E. A., Madsen, P., and Thompson, R. (1997). Residual maximum likelihood estimation of (co) variance components in multivariate mixed linear models using average information. Journal of the Indian Society of Agricultural Statistics, 49, 215-236.
</p>
<p>Covarrubias-Pazaran G. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744
</p>
<p>Gilmour et al. 1995. Average Information REML: An efficient algorithm for variance parameter estimation in linear mixed models. Biometrics 51(4):1440-1450.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the
#### examples are silenced with one '#' mark,
#### remove them and run the examples
####=========================================####

####=========================================####
#### EXAMPLES
#### Different models with sommer
####=========================================####

data(DT_example)
DT &lt;- DT_example
head(DT)

####=========================================####
#### Univariate homogeneous variance models  ####
####=========================================####

## Compound simmetry (CS) model
ans1 &lt;- mmec(Yield~Env,
             random= ~ Name + Env:Name,
             rcov= ~ units,
             data=DT)
summary(ans1)

# ####===========================================####
# #### Univariate heterogeneous variance models  ####
# ####===========================================####
# DT=DT[with(DT, order(Env)), ]
# ## Compound simmetry (CS) + Diagonal (DIAG) model
# ans2 &lt;- mmec(Yield~Env,
#              random= ~Name + vsc(dsc(Env),isc(Name)),
#              rcov= ~ vsc(dsc(Env),isc(units)),
#              data=DT)
# summary(ans2)
# 
# ####===========================================####
# ####  Univariate unstructured variance models  ####
# ####===========================================####
# 
# ans3 &lt;- mmec(Yield~Env,
#              random=~ vsc(usc(Env),isc(Name)),
#              rcov=~vsc(dsc(Env),isc(units)),
#              data=DT)
# summary(ans3)

</code></pre>

<hr>
<h2 id='mmer'>
<strong>m</strong>ixed <strong>m</strong>odel <strong>e</strong>quations for <strong>r</strong> records
</h2><span id='topic+mmer'></span>

<h3>Description</h3>

<p>The mmer function uses the Direct-Inversion Newton-Raphson or Average Information coded in C++ using the Armadillo library to optimize dense matrix operations common in genomic selection models. These algorithms are <strong>intended to be used for problems of the type c &gt; r (more coefficients to estimate than records in the dataset) and/or dense matrices</strong>. For problems with sparse data, or problems of the type r &gt; c (more records in the dataset than coefficients to estimate), the MME-based algorithm in the <code><a href="#topic+mmec">mmec</a></code> function is faster and we recommend to shift to use that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mmer(fixed, random, rcov, data, weights, W, nIters=20, tolParConvLL = 1e-03, 
     tolParInv = 1e-06, init=NULL, constraints=NULL,method="NR", getPEV=TRUE,
     naMethodX="exclude", naMethodY="exclude",returnParam=FALSE, 
     dateWarning=TRUE,date.warning=TRUE,verbose=TRUE, reshapeOutput=TRUE, stepWeight=NULL,
     emWeight=NULL, contrasts=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmer_+3A_fixed">fixed</code></td>
<td>
<p>A formula specifying the <strong>response variable(s)</strong> <strong>and fixed effects</strong>, e.g.:
</p>
<p><em>response ~ covariate</em> for univariate models
</p>
<p><em>cbind(response.i,response.j) ~ covariate</em> for multivariate models
</p>
<p>The <code><a href="#topic+fcm">fcm</a>()</code> function can be used to constrain fixed effects in multi-response models.
</p>
</td></tr>
<tr><td><code id="mmer_+3A_random">random</code></td>
<td>
<p>A formula specifying the name of the <strong>random effects</strong>, e.g. <em>random= ~ genotype + year</em>.
</p>
<p>Useful functions can be used to fit heterogeneous variances and other special models (<em>see 'Special Functions' in the Details section for more information</em>):
</p>
<p><code><a href="#topic+vsr">vsr</a>(...,Gu,Gti,Gtc)</code> is the main function to specify variance models and special structures for random effects. On the ... argument you provide the unknown variance-covariance structures (e.g., usr,dsr,atr,csr) and the random effect where such covariance structure will be used (the random effect of interest). Gu is used to provide known covariance matrices among the levels of the random effect, Gti initial values and Gtc for constraints. Auxiliar functions for building the variance models are:
</p>
<p>** <code><a href="#topic+dsr">dsr</a>(x)</code>, <code><a href="#topic+usr">usr</a>(x)</code>, <code><a href="#topic+csr">csr</a>(x)</code> and <code><a href="#topic+atr">atr</a>(x,levs)</code> can be used to specify unknown diagonal, unstructured and customized unstructured and diagonal covariance structures to be estimated by REML.
</p>
<p>** <code><a href="#topic+unsm">unsm</a>(x)</code>, <code><a href="#topic+fixm">fixm</a>(x)</code> and <code><a href="base.html#topic+diag">diag</a>(x)</code> can be used to build easily matrices to specify constraints in the Gtc argument of the <code><a href="#topic+vsr">vsr</a>()</code> function.
</p>
<p>** <code><a href="#topic+overlay">overlay</a>()</code>, <code><a href="#topic+spl2Da">spl2Da</a>()</code>, <code><a href="#topic+spl2Db">spl2Db</a>()</code>, and <code><a href="#topic+leg">leg</a>()</code> functions can be used to specify overlayed of design matrices of random effects, two dimensional spline and random regression models within the <code><a href="#topic+vsr">vsr</a>()</code> function.
</p>
<p><code><a href="#topic+gvsr">gvsr</a>(...,Gu,Guc,Gti,Gtc)</code> is an alternative function to specify general variance structures between different random effects. An special case in the indirect genetic effect models. Is similar to the vsr function but in the ... argument the different random effects are provided.
</p>
</td></tr>
<tr><td><code id="mmer_+3A_rcov">rcov</code></td>
<td>
<p>A formula specifying the name of the <strong>error term</strong>, e.g., <em>rcov= ~ units</em>.
</p>
<p>Special heterogeneous and special variance models and constraints for the residual part are the same used on the random term but the name of the random effect is always &quot;units&quot; which can be thought as a column with as many levels as rows in the data, e.g., <em>rcov=~vsr(dsr(covariate),units)</em>
</p>
</td></tr>
<tr><td><code id="mmer_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables specified in the formulas for response, fixed, and random effects.</p>
</td></tr>
<tr><td><code id="mmer_+3A_weights">weights</code></td>
<td>
<p>Name of the covariate for weights. To be used for the product R = Wsi*R*Wsi, where * is the matrix product, Wsi is the square root of the inverse of W and R is the residual matrix.</p>
</td></tr>
<tr><td><code id="mmer_+3A_w">W</code></td>
<td>
<p>Alternatively, instead of providing a vector of weights the user can specify an entire W matrix (e.g., when covariances exist). To be used first to produce Wis = solve(chol(W)), and then calculate R = Wsi*R*Wsi.t(), where * is the matrix product, and R is the residual matrix. Only one of the arguments weights or W should be used. If both are indicated W will be given the preference.</p>
</td></tr>
<tr><td><code id="mmer_+3A_niters">nIters</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="mmer_+3A_tolparconvll">tolParConvLL</code></td>
<td>
<p>Convergence criteria for the change in log-likelihood.</p>
</td></tr>
<tr><td><code id="mmer_+3A_tolparinv">tolParInv</code></td>
<td>
<p>Tolerance parameter for matrix inverse used when singularities are encountered in the estimation procedure.</p>
</td></tr>
<tr><td><code id="mmer_+3A_init">init</code></td>
<td>
<p>Initial values for the variance components. By default this is NULL and initial values for the variance components are provided by the algorithm, but in case the user want to provide initial values for ALL var-cov components this argument is functional. It has to be provided as a list, where each list element corresponds to one random effect (1x1 matrix) and if multitrait model is pursued each element of the list is a matrix of variance covariance components among traits for such random effect. Initial values can also be provided in the Gti argument of the <a href="#topic+vsr">vsr</a> function. Is highly encouraged to use the Gti and Gtc arguments of the <a href="#topic+vsr">vsr</a> function instead of this argument, but these argument can be used to provide all initial values at once</p>
</td></tr>
<tr><td><code id="mmer_+3A_constraints">constraints</code></td>
<td>
<p>When initial values are provided these have to be accompanied by their constraints. See the <a href="#topic+vsr">vsr</a> function for more details on the constraints. Is highly encouraged to use the Gti and Gtc arguments of the <a href="#topic+vsr">vsr</a> function instead of this argument but these argument can be used to provide all constraints at once.</p>
</td></tr>
<tr><td><code id="mmer_+3A_method">method</code></td>
<td>
<p>This refers to the method or algorithm to be used for estimating variance components. Direct-inversion Newton-Raphson <strong>NR</strong> and Average Information <strong>AI</strong> (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2015).</p>
</td></tr>
<tr><td><code id="mmer_+3A_getpev">getPEV</code></td>
<td>
<p>A TRUE/FALSE value indicating if the program should return the predicted error variance and variance for random effects. This option is provided since this can take a long time for certain models where p is &gt; n by a big extent.</p>
</td></tr>
<tr><td><code id="mmer_+3A_namethodx">naMethodX</code></td>
<td>
<p>One of the two possible values; &quot;include&quot; or &quot;exclude&quot;. If &quot;include&quot; is selected then the function will impute the X matrices for fixed effects with the median value. If &quot;exclude&quot; is selected it will get rid of all rows with missing values for the X (fixed) covariates. The default is &quot;exclude&quot;. The &quot;include&quot; option should be used carefully.</p>
</td></tr>
<tr><td><code id="mmer_+3A_namethody">naMethodY</code></td>
<td>
<p>One of the three possible values; &quot;include&quot;, &quot;include2&quot; or &quot;exclude&quot; (default) to treat the observations in response variable to be used in the estimation of variance components. The first option &quot;include&quot; will impute the response variables for all rows with the median value, whereas &quot;include2&quot; imputes the responses only for rows where there is observation(s) for at least one of the responses (only available in the multi-response models). If &quot;exclude&quot; is selected (default) it will get rid of rows in response(s) where missing values are present for at least one of the responses.</p>
</td></tr>
<tr><td><code id="mmer_+3A_returnparam">returnParam</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should return the parameters to be used for fitting the model instead of fitting the model.</p>
</td></tr>
<tr><td><code id="mmer_+3A_datewarning">dateWarning</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should warn you when is time to update the sommer package.</p>
</td></tr>
<tr><td><code id="mmer_+3A_date.warning">date.warning</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should warn you when is time to update the sommer package. This argument will be removed soon, just left for backcompatibility.</p>
</td></tr>
<tr><td><code id="mmer_+3A_verbose">verbose</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the program should return the progress of the iterative algorithm.</p>
</td></tr>
<tr><td><code id="mmer_+3A_reshapeoutput">reshapeOutput</code></td>
<td>
<p>A TRUE/FALSE value to indicate if the output should be reshaped to be easier to interpret for the user, some information is missing from the multivariate models for an easy interpretation.</p>
</td></tr>
<tr><td><code id="mmer_+3A_stepweight">stepWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating the weight used to multiply the update (delta) for variance components at each iteration. If NULL the 1st iteration will be multiplied by 0.5, the 2nd by 0.7, and the rest by 0.9. This argument can help to avoid that variance components go outside the parameter space in the initial iterations which doesn't happen very often with the NR method but it can be detected by looking at the behavior of the likelihood. In that case you may want to give a smaller weight to the initial 8-10 iterations.</p>
</td></tr>
<tr><td><code id="mmer_+3A_emweight">emWeight</code></td>
<td>
<p>A vector of values (of length equal to the number of iterations) indicating with values between 0 and 1 the weight assigned to the EM information matrix. And the values 1 - emWeight will be applied to the NR/AI information matrix to produce a joint information matrix.</p>
</td></tr>
<tr><td><code id="mmer_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the contrasts.arg of model.matrix.default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of this function requires a good understanding of mixed models. Please review the 'sommer.quick.start' vignette and pay attention to details like format of your random and fixed variables (e.g. character and factor variables have different properties when returning BLUEs or BLUPs, please see the 'sommer.changes.and.faqs' vignette). 
</p>
<p><strong>For tutorials</strong> on how to perform different analysis with sommer please look at the vignettes by typing in the terminal:
</p>
<p>vignette(&quot;v1.sommer.quick.start&quot;)
</p>
<p>vignette(&quot;v2.sommer.changes.and.faqs&quot;)
</p>
<p>vignette(&quot;v3.sommer.qg&quot;)
</p>
<p>vignette(&quot;v4.sommer.gxe&quot;)
</p>
<p><strong>Citation</strong>
</p>
<p>Type <em>citation(&quot;sommer&quot;)</em> to know how to cite the sommer package in your publications. 
</p>
<p><strong>Special variance structures</strong>
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+atr">atr</a>(x,levels),y)</code>   
</p>
<p>can be used to specify heterogeneous variance for the &quot;y&quot; covariate at specific levels of the covariate &quot;x&quot;, e.g., <em>random=~vsr(at(Location,c(&quot;A&quot;,&quot;B&quot;)),ID)</em> fits a variance component for ID at levels A and B of the covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+dsr">dsr</a>(x),y)</code>   
</p>
<p>can be used to specify a diagonal covariance structure for the &quot;y&quot; covariate for all levels of the covariate &quot;x&quot;, e.g., <em>random=~vsr(dsr(Location),ID)</em>  fits a variance component for ID at all levels of the covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+usr">usr</a>(x),y)</code>   
</p>
<p>can be used to specify an unstructured covariance structure for the &quot;y&quot; covariate for all levels of the  covariate &quot;x&quot;, e.g., <em>random=~vsr(usr(Location),ID)</em>  fits variance and covariance components for ID at all levels of the covariate Location.
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+overlay">overlay</a>(...,rlist=NULL,prefix=NULL))</code>   
</p>
<p>can be used to specify overlay of design matrices between consecutive random effects specified, e.g., <em>random=~vsr(overlay(male,female))</em> overlays (overlaps) the incidence matrices for the male and female random effects to obtain a single variance component for both effects. The 'rlist' argument is a list with each element being a numeric value that multiplies the incidence matrix to be overlayed. See <code><a href="#topic+overlay">overlay</a></code> for details.Can be combined with vsr().
</p>
<p><code><a href="#topic+vsr">vsr</a>(<a href="#topic+leg">leg</a>(x,n),y)</code>
</p>
<p>can be used to fit a random regression model using a numerical variable <code>x</code> that marks the trayectory for the random effect <code>y</code>. The leg function can be combined with the special functions <code>dsr</code>, <code>usr</code> <code>at</code> and <code>csr</code>. For example <em>random=~vsr(leg(x,1),y)</em> or <em>random=~vsr(usr(leg(x,1)),y)</em>.
</p>
<p><code><a href="#topic+vsr">vsr</a>(x,Gtc=<a href="#topic+fcm">fcm</a>(v))</code>
</p>
<p>can be used to constrain fixed effects in the multi-response mixed models. This is a vector that specifies if the fixed effect is to be estimated for such trait. For example <em>fixed=cbind(response.i, response.j)~vsr(Rowf, Gtc=fcm(c(1,0)))</em> means that the fixed effect Rowf should only be estimated for the first response and the second should only have the intercept.
</p>
<p><code><a href="#topic+gvsr">gvsr</a>(x,y)</code>  
</p>
<p>can be used to fit variance and covariance parameters between two or more random effects. For example, indirect genetic effect models.
</p>
<p><code><a href="#topic+spl2Da">spl2Da</a>(x.coord, y.coord, at.var, at.levels))</code>
</p>
<p>can be used to fit a 2-dimensional spline (e.g., spatial modeling) using coordinates <code>x.coord</code> and <code>y.coord</code> (in numeric class) assuming a single variance component. The 2D spline can be fitted at specific levels using the <code>at.var</code> and <code>at.levels</code> arguments. For example <em>random=~spl2Da(x.coord=Row,y.coord=Range,at.var=FIELD)</em>.
</p>
<p><code><a href="#topic+spl2Db">spl2Db</a>(x.coord, y.coord, at.var, at.levels))</code>
</p>
<p>can be used to fit a 2-dimensional spline (e.g., spatial modeling) using coordinates <code>x.coord</code> and <code>y.coord</code> (in numeric class) assuming multiple variance components. The 2D spline can be fitted at specific levels using the <code>at.var</code> and <code>at.levels</code> arguments. For example <em>random=~spl2Db(x.coord=Row,y.coord=Range,at.var=FIELD)</em>.
</p>
<p><strong>S3 methods</strong>
</p>
<p>S3 methods are available for some parameter extraction such as <code><a href="#topic+fitted.mmer">fitted.mmer</a></code>, <code><a href="#topic+residuals.mmer">residuals.mmer</a></code>, <code><a href="#topic+summary.mmer">summary.mmer</a></code>, <code><a href="#topic+randef">randef</a></code>, <code><a href="#topic+coef.mmer">coef.mmer</a></code>, <code><a href="#topic+anova.mmer">anova.mmer</a></code>, <code><a href="#topic+plot.mmer">plot.mmer</a></code>, and <code><a href="#topic+predict.mmer">predict.mmer</a></code> to obtain adjusted means. In addition, the <code><a href="#topic+vpredict">vpredict</a></code> function (replacement of the pin function) can be used to estimate standard errors for linear combinations of variance components (e.g., ratios like h2). 
</p>
<p><strong>Additional Functions</strong>
</p>
<p>Additional functions for genetic analysis have been included such as relationship matrix building (<code><a href="#topic+A.mat">A.mat</a></code>, <code><a href="#topic+D.mat">D.mat</a></code>, <code><a href="#topic+E.mat">E.mat</a></code>, <code><a href="#topic+H.mat">H.mat</a></code>), build a genotypic hybrid marker matrix (<code><a href="#topic+build.HMM">build.HMM</a></code>), plot of genetic maps (<code><a href="#topic+map.plot">map.plot</a></code>), and manhattan plots (<code><a href="#topic+manhattan">manhattan</a></code>). If you need to build a pedigree-based relationship matrix use the <code>getA</code> function from the pedigreemm package. 
</p>
<p><strong>Bug report and contact</strong>
</p>
<p>If you have any technical questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com 
</p>
<p>If you have any bug report please go to https://github.com/covaruber/sommer or send me an email to address it asap, just make sure you have read the vignettes carefully before sending your question.
</p>
<p><strong>Example Datasets</strong>
</p>
<p>The package has been equiped with several datasets to learn how to use the sommer package: 
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code>, <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> and <code><a href="#topic+DT_mohring">DT_mohring</a></code> datasets have examples to fit half and full diallel designs. 
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses 
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects. 
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids. 
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p>* <code><a href="#topic+DT_legendre">DT_legendre</a></code> simulated dataset for random regression model.
</p>
<p>* <code><a href="#topic+DT_sleepstudy">DT_sleepstudy</a></code> dataset to know how to translate lme4 models to sommer models.
</p>
<p>* <code><a href="#topic+DT_ige">DT_ige</a></code> dataset to show how to fit indirect genetic effect models.
</p>
<p><strong>Models Enabled</strong>
</p>
<p>For details about the models enabled and more information about the covariance structures please check the help page of the package (<code><a href="#topic+sommer">sommer</a></code>).
</p>


<h3>Value</h3>

<p>If all parameters are correctly indicated the program will return a list with the following information:
</p>
<table role = "presentation">
<tr><td><code>Vi</code></td>
<td>
<p>the inverse of the phenotypic variance matrix V^- = (ZGZ+R)^-1</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>the projection matrix  Vi - [Vi*(X*Vi*X)^-*Vi] </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a list with the values of the variance-covariance components with one list element for each random effect.</p>
</td></tr>
<tr><td><code>sigma_scaled</code></td>
<td>
<p>a list with the values of the scaled variance-covariance components with one list element for each random effect.</p>
</td></tr>
<tr><td><code>sigmaSE</code></td>
<td>
<p>Hessian matrix containing the variance-covariance for the variance components. SE's can be obtained taking the square root of the diagonal values of the Hessian.</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>a data frame for trait BLUEs (fixed effects).</p>
</td></tr>
<tr><td><code>VarBeta</code></td>
<td>
<p>a variance-covariance matrix for trait BLUEs</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>a list (one element for each random effect) with a data frame for trait BLUPs.</p>
</td></tr>
<tr><td><code>VarU</code></td>
<td>
<p>a list (one element for each random effect) with the variance-covariance matrix for trait BLUPs.</p>
</td></tr>
<tr><td><code>PevU</code></td>
<td>
<p>a list (one element for each random effect) with the predicted error variance matrix for trait BLUPs.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> Fitted values y.hat=XB</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Residual values e = Y - XB</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a TRUE/FALSE statement indicating if the model converged.</p>
</td></tr>
<tr><td><code>monitor</code></td>
<td>
<p>The values of log-likelihood and variance-covariance components across iterations during the REML estimation.</p>
</td></tr>
<tr><td><code>percChange</code></td>
<td>
<p>The percent change of variance components across iterations. There should be one column less than the number of iterations. Calculated as percChange = ((x_i/x_i-1) - 1) * 100 where i is the ith iteration.</p>
</td></tr>
<tr><td><code>dL</code></td>
<td>
<p>The vector of first derivatives of the likelihood with respect to the ith variance-covariance component.</p>
</td></tr>
<tr><td><code>dL2</code></td>
<td>
<p>The matrix of second derivatives of the likelihood with respect to the i.j th variance-covariance component.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method for extimation of variance components specified by the user.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Formula for fixed, random and rcov used.</p>
</td></tr>
<tr><td><code>constraints</code></td>
<td>
<p>contraints used in the mixed models for the random effects.</p>
</td></tr>
<tr><td><code>constraintsF</code></td>
<td>
<p>contraints used in the mixed models for the fixed effects.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The dataset used in the model after removing missing records for the response variable.</p>
</td></tr>
<tr><td><code>dataOriginal</code></td>
<td>
<p>The original dataset used in the model.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The name of terms for responses, fixed, random and residual effects in the model.</p>
</td></tr>
<tr><td><code>termsN</code></td>
<td>
<p>The number of effects associated to fixed, random and residual effects in the model.</p>
</td></tr>
<tr><td><code>sigmaVector</code></td>
<td>
<p>a vectorized version of the sigma element (variance-covariance components) to match easily the standard errors of the var-cov components stored in the element sigmaSE.</p>
</td></tr>
<tr><td><code>reshapeOutput</code></td>
<td>
<p>The value provided to the mmer function for the argument with the same name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 2016, 11(6): doi:10.1371/journal.pone.0156744   
</p>
<p>Covarrubias-Pazaran G. 2018. Software update: Moving the R package sommer to multivariate mixed models for genome-assisted prediction. doi: https://doi.org/10.1101/354639
</p>
<p>Bernardo Rex. 2010. Breeding for quantitative traits in plants. Second edition. Stemma Press. 390 pp.
</p>
<p>Gilmour et al. 1995. Average Information REML: An efficient algorithm for variance parameter estimation in linear mixed models. Biometrics 51(4):1440-1450.
</p>
<p>Kang et al. 2008. Efficient control of population structure in model organism association mapping. Genetics 178:1709-1723.
</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient two-dimensional smoothing with P-spline ANOVA mixed models and nested bases. Computational Statistics and Data Analysis, 61, 22 - 37.
</p>
<p>Lee et al. 2015. MTG2: An efficient algorithm for multivariate linear mixed model analysis based on genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201.
</p>
<p>Maier et al. 2015. Joint analysis of psychiatric disorders increases accuracy of risk prediction for schizophrenia, bipolar disorder, and major depressive disorder. Am J Hum Genet; 96(2):283-294.
</p>
<p>Rodriguez-Alvarez, Maria Xose, et al. Correcting for spatial heterogeneity in plant breeding experiments with P-splines. Spatial Statistics 23 (2018): 52-71.
</p>
<p>Searle. 1993. Applying the EM algorithm to calculating ML and REML estimates of variance components. Paper invited for the 1993 American Statistical Association Meeting, San Francisco.
</p>
<p>Yu et al. 2006. A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Genetics 38:203-208.
</p>
<p>Tunnicliffe W. 1989. On the use of marginal likelihood in time series model estimation. JRSS 51(1):15-27.
</p>
<p>Zhang et al. 2010. Mixed linear model approach adapted for genome-wide association studies. Nat. Genet. 42:355-360.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

####=========================================####
#### EXAMPLES
#### Different models with sommer
####=========================================####

data(DT_example)
DT &lt;- DT_example
head(DT)

####=========================================####
#### Univariate homogeneous variance models  ####
####=========================================####

## Compound simmetry (CS) model
ans1 &lt;- mmer(Yield~Env,
             random= ~ Name + Env:Name,
             rcov= ~ units,
             data=DT)
summary(ans1)

####===========================================####
#### Univariate heterogeneous variance models  ####
####===========================================####

## Compound simmetry (CS) + Diagonal (DIAG) model
ans2 &lt;- mmer(Yield~Env,
             random= ~Name + vsr(dsr(Env),Name),
             rcov= ~ vsr(dsr(Env),units),
             data=DT)
summary(ans2)

####===========================================####
####  Univariate unstructured variance models  ####
####===========================================####

ans3 &lt;- mmer(Yield~Env,
             random=~ vsr(usr(Env),Name),
             rcov=~vsr(dsr(Env),units), 
             data=DT)
summary(ans3)

# ####==========================================####
# #### Multivariate homogeneous variance models ####
# ####==========================================####
# 
# ## Multivariate Compound simmetry (CS) model
# DT$EnvName &lt;- paste(DT$Env,DT$Name)
# ans4 &lt;- mmer(cbind(Yield, Weight) ~ Env,
#               random= ~ vsr(Name, Gtc = unsm(2)) + vsr(EnvName,Gtc = unsm(2)),
#               rcov= ~ vsr(units, Gtc = unsm(2)),
#               data=DT)
# summary(ans4)
# 
# ####=============================================####
# #### Multivariate heterogeneous variance models  ####
# ####=============================================####
# 
# ## Multivariate Compound simmetry (CS) + Diagonal (DIAG) model
# ans5 &lt;- mmer(cbind(Yield, Weight) ~ Env,
#               random= ~ vsr(Name, Gtc = unsm(2)) + vsr(dsr(Env),Name, Gtc = unsm(2)),
#               rcov= ~ vsr(dsr(Env),units, Gtc = unsm(2)),
#               data=DT)
# summary(ans5)
# 
# ####===========================================####
# #### Multivariate unstructured variance models ####
# ####===========================================####
# 
# ans6 &lt;- mmer(cbind(Yield, Weight) ~ Env,
#               random= ~ vsr(usr(Env),Name, Gtc = unsm(2)),
#               rcov= ~ vsr(dsr(Env),units, Gtc = unsm(2)),
#               data=DT)
# summary(ans6)
# 
# ####=========================================####
# ####=========================================####
# #### EXAMPLE SET 2
# #### 2 variance components
# #### one random effect with variance covariance structure
# ####=========================================####
# ####=========================================####
# 
# data("DT_cpdata")
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# head(DT)
# GT[1:4,1:4]
# #### create the variance-covariance matrix
# A &lt;- A.mat(GT)
# #### look at the data and fit the model
# mix1 &lt;- mmer(Yield~1,
#              random=~vsr(id, Gu=A) + Rowf,
#              rcov=~units,
#              data=DT)
# summary(mix1)$varcomp
# #### calculate heritability
# vpredict(mix1, h1 ~ V1/(V1+V3) )
# #### multi trait example
# mix2 &lt;- mmer(cbind(Yield,color)~1,
#               random = ~ vsr(id, Gu=A, Gtc = unsm(2)) + # unstructured at trait level
#                             vsr(Rowf, Gtc=diag(2)) + # diagonal structure at trait level
#                                 vsr(Colf, Gtc=diag(2)), # diagonal structure at trait level
#               rcov = ~ vsr(units, Gtc = unsm(2)), # unstructured at trait level
#               data=DT)
# summary(mix2)
# 
# ####=========================================####
# #### EXAMPLE SET 3
# #### comparison with lmer, install 'lme4' 
# #### and run the code below
# ####=========================================####
# 
# #### lmer cannot use var-cov matrices so we will not 
# #### use them in this comparison example
# 
# library(lme4)
# library(sommer)
# data("DT_cornhybrids")
# DT &lt;- DT_cornhybrids
# DTi &lt;- DTi_cornhybrids
# GT &lt;- GT_cornhybrids
# 
# fm1 &lt;- lmer(Yield ~ Location + (1|GCA1) + (1|GCA2) + (1|SCA),
#             data=DT )
# out &lt;- mmer(Yield ~ Location,
#              random = ~ GCA1 + GCA2 + SCA,
#              rcov = ~ units,
#              data=DT)
# summary(fm1)
# summary(out)
# ### same BLUPs for GCA1, GCA2, SCA than lme4
# plot(out$U$GCA1$Yield, ranef(fm1)$GCA1[,1])
# plot(out$U$GCA2$Yield, ranef(fm1)$GCA2[,1])
# vv=which(abs(out$U$SCA$Yield) &gt; 0)
# plot(out$U$SCA$Yield[vv], ranef(fm1)$SCA[,1])
# 
# ### a more complex model specifying which locations
# head(DT)
# out2 &lt;- mmer(Yield ~ Location,
#               random = ~ vsr(atr(Location,c("3","4")),GCA2) +
#                          vsr(atr(Location,c("3","4")),SCA),
#               rcov = ~ vsr(dsr(Location),units),
#               data=DT)
# summary(out2)


</code></pre>

<hr>
<h2 id='neMarker'>Effective population size based on marker matrix</h2><span id='topic+neMarker'></span>

<h3>Description</h3>

<p>'neMarker' uses a marker matrix to approximate the effective population size (Ne) by discovering how many individuals are needed to sample all possible alleles in a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  neMarker(M, neExplore=NULL, maxMarker=1000, nSamples=5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neMarker_+3A_m">M</code></td>
<td>
<p>marker matrix coded in a numerical faashion (any allele dosage is fine).</p>
</td></tr>
<tr><td><code id="neMarker_+3A_neexplore">neExplore</code></td>
<td>
<p>a vector of numbers with the effective population sizes to be explored.</p>
</td></tr>
<tr><td><code id="neMarker_+3A_maxmarker">maxMarker</code></td>
<td>
<p>maximum number of markers to use for the analysis.</p>
</td></tr>
<tr><td><code id="neMarker_+3A_nsamples">nSamples</code></td>
<td>
<p>number of individuals to sample for the Ne calculation.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> A vector with allele coverage based on different number of individuals  </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Not based on any theory published yet but in a solid intuition on what is really important for a breeding program when we ask what is the effective population size
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

# data(DT_cpdata) # Madison cranberries
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# M &lt;- GT
# # run the function
# ne &lt;- neMarker(M, neExplore = seq(2,30,2), nSamples = 10)
# ################
# data(DT_technow) # maize
# M &lt;- Md_technow # dent
# M &lt;- (M*2) - 1
# M &lt;- M + 1
# # run the function
# ne &lt;- neMarker(M, neExplore = seq(5,100,5), nSamples = 10)
# ##
# M &lt;- Mf_technow # flint
# M &lt;- (M*2) - 1
# M &lt;- M + 1
# # run the function
# ne &lt;- neMarker(M, neExplore = seq(5,100,5), nSamples = 10)
# ################
# data(DT_wheat) # cimmyt wheat
# M &lt;- GT_wheat + 1
# # run the function
# ne &lt;- neMarker(M, neExplore = seq(5,60,5), nSamples = 10)
# ###############
# data(DT_rice) # Zhao rice
# M &lt;- atcg1234(GT_rice)$M
# # run the function
# ne &lt;- neMarker(M,  neExplore = seq(10,100,10), nSamples = 10)
# ###############
# data(DT_polyploid) # endelman potatoes
# M &lt;- atcg1234(data=GT_polyploid, ploidy=4)$M
# # run the function
# ne &lt;- neMarker(M,  neExplore = seq(10,100,10), nSamples = 10)
# 
# library(ggplot2) #For making plots
# ggplot(ne,aes(x=Ne,y=allelesCovered))+
#   geom_ribbon(aes(x=Ne,ymin=allelesCovered-allelesCoveredSe,
#                   ymax=allelesCovered+allelesCoveredSe),
#                   alpha=0.2,linetype=0)+
#   geom_line(linewidth=1)+
#   guides(alpha=FALSE)+
#   theme_bw()+ 
#   scale_x_continuous("Individual number")+
#   scale_y_continuous("Allele coverage")  + 
#                geom_hline(yintercept = 0.95) + 
#                geom_hline(yintercept = 0.975)

</code></pre>

<hr>
<h2 id='overlay'>Overlay Matrix</h2><span id='topic+overlay'></span>

<h3>Description</h3>

<p>'overlay' adds r times the design matrix for model term t to the existing design matrix. Specifically, if the model up to this point has p effects and t has a effects, the a columns of the design matrix for t are multiplied by the scalar r (default value 1.0). This can be used to force a correlation of 1 between two terms as in a diallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  overlay(..., rlist=NULL, prefix=NULL, sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlay_+3A_...">...</code></td>
<td>
<p>as many vectors as desired to overlay.</p>
</td></tr>
<tr><td><code id="overlay_+3A_rlist">rlist</code></td>
<td>
<p>a list of scalar values indicating the times that each incidence matrix overlayed should be multiplied by. By default r=1.</p>
</td></tr>
<tr><td><code id="overlay_+3A_prefix">prefix</code></td>
<td>
<p>a character name to be added before the column names of the final overlay matrix. This may be useful if you have entries with names starting with numbers which programs such as asreml doesn't like, or for posterior extraction of parameters, that way 'grep'ing is easier.</p>
</td></tr>
<tr><td><code id="overlay_+3A_sparse">sparse</code></td>
<td>
<p>a TRUE/FALSE statement specifying if the matrices should be built as sparse or regular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> an incidence matrix with as many columns levels in the vectors provided to build the incidence matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Fikret Isik. 2009. Analysis of Diallel Mating Designs. North Carolina State University, Raleigh, USA.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> and a function for creating dummy variables for diallel models named <code><a href="#topic+add.diallel.vars">add.diallel.vars</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
data("DT_halfdiallel")
DT &lt;- DT_halfdiallel
head(DT)
DT$femalef &lt;- as.factor(DT$female)
DT$malef &lt;- as.factor(DT$male)
DT$genof &lt;- as.factor(DT$geno)

with(DT, overlay(femalef,malef, sparse = TRUE))
with(DT, overlay(femalef,malef, sparse = FALSE))

</code></pre>

<hr>
<h2 id='plot.mmec'>plot form a LMM plot with mmec</h2><span id='topic+plot.mmec'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
plot(x,stnd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mmec_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="plot.mmec_+3A_stnd">stnd</code></td>
<td>
<p>argument for ploting the residuals to know if they should be standarized.</p>
</td></tr>
<tr><td><code id="plot.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias <a href="mailto:covarrubiasp@wisc.edu">covarrubiasp@wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_yatesoats)
DT &lt;- DT_yatesoats
head(DT)
m3 &lt;- mmec(fixed=Y ~ V + N + V:N,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)
plot(m3)
</code></pre>

<hr>
<h2 id='plot.mmer'>plot form a LMM plot with mmer</h2><span id='topic+plot.mmer'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
plot(x,stnd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mmer_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="plot.mmer_+3A_stnd">stnd</code></td>
<td>
<p>argument for ploting the residuals to know if they should be standarized.</p>
</td></tr>
<tr><td><code id="plot.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias <a href="mailto:covarrubiasp@wisc.edu">covarrubiasp@wisc.edu</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_yatesoats)
DT &lt;- DT_yatesoats
head(DT)
m3 &lt;- mmer(fixed=Y ~ V + N + V:N,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)
plot(m3)
</code></pre>

<hr>
<h2 id='pmonitor'>plot the change of VC across iterations</h2><span id='topic+pmonitor'></span>

<h3>Description</h3>

<p><code>plot</code> for monitoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmonitor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmonitor_+3A_object">object</code></td>
<td>
<p>model object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="pmonitor_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DT_yatesoats)
DT &lt;- DT_yatesoats
head(DT)
m3 &lt;- mmec(fixed=Y ~ V + N + V:N,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)
pmonitor(m3)
</code></pre>

<hr>
<h2 id='predict.mmec'>Predict form of a LMM fitted with mmec</h2><span id='topic+predict.mmec'></span>

<h3>Description</h3>

<p><code>predict</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
predict(object, Dtable=NULL, D, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mmec_+3A_object">object</code></td>
<td>
<p>a mixed model of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="predict.mmec_+3A_dtable">Dtable</code></td>
<td>
<p>a table specifying the terms to be included or averaged.
</p>
<p>An &quot;include&quot; term means that the model matrices for that fixed or random effect is filled with 1's for the positions where column names and row names match.
</p>
<p>An &quot;include and average&quot; term means that the model matrices for that fixed or random effect is filled with 1/#1's in that row.
</p>
<p>An &quot;average&quot; term alone means that all rows for such fixed or random effect will be filled with 1/#levels in the effect.
</p>
<p>If a term is not considered &quot;include&quot; or &quot;average&quot; is then totally ignored in the BLUP and SE calculation. 
</p>
<p>The default rule to invoke when the user doesn't provide the Dtable is to include and average all terms that match the argument D.
</p>
</td></tr>
<tr><td><code id="predict.mmec_+3A_d">D</code></td>
<td>
<p>a character string specifying the variable used to extract levels for the rows of the D matrix and its construction. Alternatively, the D matrix (of class dgCMatrix) specifying the matrix to be used for the predictions directly.</p>
</td></tr>
<tr><td><code id="predict.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to produce predictions specifying those variables that define the margins of the hypertable to be predicted (argument D). Predictions are obtained for each combination of values of the specified variables that is present in the data set used to fit the model. See vignettes for more details. 
</p>
<p>For predicted values the pertinent design matrices X and Z together with BLUEs (b) and BLUPs (u) are multiplied and added together.
</p>
<p>predicted.value equal Xb + Zu.1 + ... + Zu.n
</p>
<p>For computing standard errors for predictions the parts of the coefficient matrix:
</p>
<p>C11 equal (X.t() V.inv() X).inv()
</p>
<p>C12 equal 0 - [(X.t() V.inv() X).inv() X.t() V.inv() G Z] 
</p>
<p>C22 equal PEV equal G - [Z.t() G[V.inv() - (V.inv() X X.t() V.inv() X V.inv() X)]G Z.t()]
</p>
<p>In practive C equals ( W.t() V.inv() W ).inv()
</p>
<p>when both fixed and random effects are present in the inclusion set. If only fixed and random effects are included, only the respective terms from the SE for fixed or random effects are calculated.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pvals</code></td>
<td>
<p>the table of predictions according to the specified arguments.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance covariance for the predictions.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>the model matrix for predictions as defined in Welham et al.(2004).</p>
</td></tr>
<tr><td><code>Dtable</code></td>
<td>
<p>the table specifying the terms to include and terms to be averaged.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran</p>


<h3>References</h3>

<p>Welham, S., Cullis, B., Gogel, B., Gilmour, A., and Thompson, R. (2004). Prediction in linear mixed models. Australian and New Zealand Journal of Statistics, 46, 325 - 347.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_yatesoats)
DT &lt;- DT_yatesoats
m3 &lt;- mmec(fixed=Y ~ V + N + V:N ,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)

#############################
## predict means for nitrogen
#############################
Dt &lt;- m3$Dtable; Dt
# first fixed effect just average
Dt[1,"average"] = TRUE
# second fixed effect include
Dt[2,"include"] = TRUE
# third fixed effect include and average
Dt[3,"include"] = TRUE
Dt[3,"average"] = TRUE
Dt

pp=predict(object=m3, Dtable=Dt, D="N")
pp$pvals

#############################
## predict means for variety
#############################

Dt &lt;- m3$Dtable; Dt
# first fixed effect include
Dt[1,"include"] = TRUE
# second fixed effect just average
Dt[2,"average"] = TRUE
# third fixed effect include and average
Dt[3,"include"] = TRUE
Dt[3,"average"] = TRUE
Dt

pp=predict(object=m3, Dtable=Dt, D="V")
pp$pvals

#############################
## predict means for nitrogen:variety
#############################
# prediction matrix D based on (equivalent to classify in asreml)
Dt &lt;- m3$Dtable; Dt
# first fixed effect include and average
Dt[1,"include"] = TRUE
Dt[1,"average"] = TRUE
# second fixed effect include and average
Dt[2,"include"] = TRUE
Dt[2,"average"] = TRUE
# third fixed effect include and average
Dt[3,"include"] = TRUE
Dt[3,"average"] = TRUE
Dt

pp=predict(object=m3, Dtable=Dt, D="N:V")
pp$pvals

</code></pre>

<hr>
<h2 id='predict.mmer'>Predict form of a LMM fitted with mmer</h2><span id='topic+predict.mmer'></span>

<h3>Description</h3>

<p><code>predict</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
predict(object, Dtable=NULL, D, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mmer_+3A_object">object</code></td>
<td>
<p>a mixed model of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="predict.mmer_+3A_dtable">Dtable</code></td>
<td>
<p>a table specifying the terms to be included or averaged.
</p>
<p>An &quot;include&quot; term means that the model matrices for that fixed or random effect is filled with 1's for the positions where column names and row names match.
</p>
<p>An &quot;include and average&quot; term means that the model matrices for that fixed or random effect is filled with 1/#1's in that row.
</p>
<p>An &quot;average&quot; term alone means that all rows for such fixed or random effect will be filled with 1/#levels in the effect.
</p>
<p>If a term is not considered &quot;include&quot; or &quot;average&quot; is then totally ignored in the BLUP and SE calculation.
</p>
<p>The default rule to invoke when the user doesn't provide the Dtable is to include and average all terms that match the argument D.
</p>
</td></tr>
<tr><td><code id="predict.mmer_+3A_d">D</code></td>
<td>
<p>a character string specifying the variable used to extract levels for the rows of the D matrix and its construction. Alternatively, the D matrix (of class dgCMatrix) specifying the matrix to be used for the predictions directly.</p>
</td></tr>
<tr><td><code id="predict.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to produce predictions specifying those variables that define the margins of the hypertable to be predicted (argument D). Predictions are obtained for each combination of values of the specified variables that is present in the data set used to fit the model. See vignettes for more details.
</p>
<p>For predicted values the pertinent design matrices X and Z together with BLUEs (b) and BLUPs (u) are multiplied and added together.
</p>
<p>predicted.value equal Xb + Zu.1 + ... + Zu.n
</p>
<p>For computing standard errors for predictions the parts of the coefficient matrix:
</p>
<p>C11 equal (X.t() V.inv() X).inv()
</p>
<p>C12 equal 0 - [(X.t() V.inv() X).inv() X.t() V.inv() G Z]
</p>
<p>C22 equal PEV equal G - [Z.t() G[V.inv() - (V.inv() X X.t() V.inv() X V.inv() X)]G Z.t()]
</p>
<p>In practive C equals ( W.t() V.inv() W ).inv()
</p>
<p>when both fixed and random effects are present in the inclusion set. If only fixed and random effects are included, only the respective terms from the SE for fixed or random effects are calculated.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pvals</code></td>
<td>
<p>the table of predictions according to the specified arguments.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance covariance for the predictions.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>the model matrix for predictions as defined in Welham et al.(2004).</p>
</td></tr>
<tr><td><code>Dtable</code></td>
<td>
<p>the table specifying the terms to include and terms to be averaged.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>References</h3>

<p>Welham, S., Cullis, B., Gogel, B., Gilmour, A., and Thompson, R. (2004). Prediction in linear mixed models. Australian and New Zealand Journal of Statistics, 46, 325 - 347.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_yatesoats)
DT &lt;- DT_yatesoats
m3 &lt;- mmer(fixed=Y ~ V + N + V:N ,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)

#############################
## predict means for nitrogen
#############################
pp=predict(object=m3, D="N")
pp$pvals

#############################
## predict means for variety
#############################
pp=predict(object=m3, D="V")
pp$pvals




</code></pre>

<hr>
<h2 id='propMissing'>Proportion of missing data</h2><span id='topic+propMissing'></span>

<h3>Description</h3>

<p><code>propMissing</code> quick calculation of the proportion of missing data in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  propMissing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="propMissing_+3A_x">x</code></td>
<td>
<p>vector of observations.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a numeric value with the proportion of missing data.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>See the function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>propMissing</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10, NA)
propMissing(x)
</code></pre>

<hr>
<h2 id='r2'>
Reliability
</h2><span id='topic+r2'></span>

<h3>Description</h3>

<p>Calculates the reliability of BLUPs in a sommer model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r2(object, object2=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r2_+3A_object">object</code></td>
<td>

<p>Model fitted with the mmec function.
</p>
</td></tr>
<tr><td><code id="r2_+3A_object2">object2</code></td>
<td>

<p>An optional model identical to object in the first argument but fitted with the argument returnParam set to TRUE to access the relationship matrices from the fitted model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reliability method calculated is the classical animal model: R2=(G-PEV)/G
</p>


<h3>Value</h3>


<dl>
<dt>result</dt><dd><p>a list with as many elements as random effects fitted containing reliabilities for individual BLUPs.</p>
</dd>
</dl>



<h3>References</h3>

<p>Mrode, R. A. (2014). Linear models for the prediction of animal breeding values. Cabi.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmec">mmec</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>####=========================================####
#### Example population
####=========================================####
data(DT_example)
DT &lt;- DT_example
head(DT)
ans1 &lt;- mmec(Yield~Env,
             random= ~ Name + Env:Name,
             rcov= ~ units,
             data=DT)
rel=r2(ans1)
</code></pre>

<hr>
<h2 id='randef'>extracting random effects</h2><span id='topic+randef'></span>

<h3>Description</h3>

<p>This function is extracts the random effects from a mixed model fitted by mmer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randef(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randef_+3A_object">object</code></td>
<td>
<p>an mmer object</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$randef</dt><dd><p> a list structure with the random effects or BLUPs.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># randef(model)
</code></pre>

<hr>
<h2 id='redmm'>Reduced Model Matrix</h2><span id='topic+redmm'></span>

<h3>Description</h3>

<p>'redmm' reduces a model matrix by performing a singular value decomposition or Cholesky on an incidence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  redmm(x, M = NULL, Lam=NULL, nPC=50, cholD=FALSE, returnLam=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redmm_+3A_x">x</code></td>
<td>
<p>as vector with values to form a model matrix or the complete incidence matrix itself for an effect of interest.</p>
</td></tr>
<tr><td><code id="redmm_+3A_m">M</code></td>
<td>
<p>an optional matrix of features explaining the levels of x. If not provided is assumed that the entire incidence matrix has been provided in x. But if provided, the decomposition occurs in the matrix M. </p>
</td></tr>
<tr><td><code id="redmm_+3A_lam">Lam</code></td>
<td>
<p>a matrix of loadings in case is already available to avoid recomputing it.</p>
</td></tr>
<tr><td><code id="redmm_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to keep from the matrix of loadings to form the model matrix.</p>
</td></tr>
<tr><td><code id="redmm_+3A_chold">cholD</code></td>
<td>
<p>should a Cholesky or a Singular value decomposition should be used. The default is the SVD.</p>
</td></tr>
<tr><td><code id="redmm_+3A_returnlam">returnLam</code></td>
<td>
<p>should the function return the loading matrix in addition to the incidence matrix. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> A list with 3 elements:
</p>
<p>1) The model matrix to be used in the mixed modeling.
</p>
<p>2) The reduced matrix of loadings (nPC columns).
</p>
<p>3) The full matrix of loadings.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmec">mmec</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

data(DT_technow)
DT &lt;- DT_technow
Md &lt;- Md_technow

M &lt;- tcrossprod(Md)
xx = with(DT, redmm(x=dent, M=M, nPC=10))

# ans &lt;- mmec(GY~1,
#             # new model matrix instead of dent
#             random=~vsc(isc(xx$Z)),
#             rcov=~units,
#             data=DT)
# summary(ans)$varcomp
# u = xx$Lam * ans$uList[[1]] # change * for matrix product

</code></pre>

<hr>
<h2 id='residuals.mmec'>Residuals form a GLMM fitted with mmec</h2><span id='topic+residuals.mmec'></span>

<h3>Description</h3>

<p><code>residuals</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.mmec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="residuals.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals of the form e = y - Xb - Zu, the so called conditional residuals.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>

<hr>
<h2 id='residuals.mmer'>Residuals form a GLMM fitted with mmer</h2><span id='topic+residuals.mmer'></span>

<h3>Description</h3>

<p><code>residuals</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.mmer_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="residuals.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of residuals of the form e = y - Xb - Zu, the so called conditional residuals.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>

<hr>
<h2 id='rrc'>reduced rank covariance structure</h2><span id='topic+rrc'></span>

<h3>Description</h3>

<p><code>rrc</code> creates a reduced rank factor analytic covariance structure by selecting the n vectors of the L matrix of the Cholesky decomposition or the U vectors of the SVD decomposition (loadings or latent covariates) to create a new incidence matrix of latent covariates that can be used with the <code><a href="#topic+mmec">mmec</a></code> solver to fit random regressions on the latent covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rrc(x=NULL, H=NULL, nPC=2, returnGamma=FALSE, cholD=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrc_+3A_x">x</code></td>
<td>
<p>vector of the dataset containing the variable to be used to form the incidence matrix.</p>
</td></tr>
<tr><td><code id="rrc_+3A_h">H</code></td>
<td>
<p>two-way table of identifiers (rows; e.g., genotypes) by features (columns; e.g., environments) effects. Row names and column names are required. No missing data is allowed.</p>
</td></tr>
<tr><td><code id="rrc_+3A_npc">nPC</code></td>
<td>
<p>number of principal components to keep from the loadings matrix.</p>
</td></tr>
<tr><td><code id="rrc_+3A_returngamma">returnGamma</code></td>
<td>
<p>a TRUE/FALSE argument specifying if the function should return the matrix of loadings used to build the incidence matrix for the model. The default is FALSE so it returns only the incidence matrix.</p>
</td></tr>
<tr><td><code id="rrc_+3A_chold">cholD</code></td>
<td>
<p>a TRUE/FALSE argument specifying if the Cholesky decomposition should be calculated or the singular value decomposition should be used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of a version of the reduced rank factor analytic models uses the so-called principal component (PC) models (Meyer, 2009) which assumes specific effects (psi) are equal to 0. The model is as follows:
</p>
<p>y = Xb + Zu + e
</p>
<p>where the variance of u ~ MVN(0, Sigma)
</p>
<p>Sigma = (Gamma_t Gamma) + Psi
</p>
<p><strong>Extended factor analytic model</strong>:
</p>
<p>y = Xb + Z(I Gamma)c + Zs + e = Xb + Z*c + Zs + e
</p>
<p>where <code>y</code> is the response variable, <code>X</code> and <code>Z</code> are incidence matrices for fixed and random effects respectively, <code>I</code> is a diagonal matrix, <code>Gamma</code> are the factor loadings for <code>c</code> common factor scores, and <code>s</code> are the specific effects, <code>e</code> is the vector of residuals.   
</p>
<p><strong>Reduced rank model:</strong>
</p>
<p>y = Xb + Z(I Gamma)c + e = Xb + Z*c + e
</p>
<p>which is equal to the one above but assumes specific effects = 0. 
</p>
<p><strong>The algorithm in rrc is the following:</strong>
</p>
<p>1) uses a wide-format table of timevar (m columns) by idvar (q rows) named H to form the initial variance-covariance matrix (Sigma) which is calculated as Sigma = H'H of dimensions m x m (column dimensions, e.g., environments x environments). 
</p>
<p>2) The Sigma matrix is then center and scaled. 
</p>
<p>3) A Cholesky (L matrix) or SVD decomposition (U D V') is performed in the Sigma matrix.
</p>
<p>4) n vectors from L (when Cholesky is used) or U sqrt(D) (when SVD is used) are kept to form Gamma. Gamma = L[,1:nPc] or Gamma = U[,1:nPC]. These are the so-called loadings (L for all loadings, Gamma for the subset of loadings).
</p>
<p>4) Gamma is used to form a new incidence matrix as Z* = Z Gamma
</p>
<p>5) This matrix is later used for the REML machinery to be used with the usc (unstructured) or dsc (diagonal) structures to estimate variance components and factor scores. The resulting BLUPs from the mixed model are the optimized factor scores. Pretty much as a random regression over latent covariates.
</p>
<p>This implementation does not update the loadings (latent covariates) during the REML process, only estimates the REML factor scores for fixed loadings. This is different to other software (e.g., asreml) where the loadings are updated during the REML process as well. 
</p>
<p>BLUPs for genotypes in all locations can be recovered as:
</p>
<p>u = Gamma * u_scores
</p>
<p>The resulting loadings (Gamma) and factor scores can be thought as an equivalent to the classical factor analysis.
</p>


<h3>Value</h3>


<dl>
<dt>$Z</dt><dd><p> a incidence matrix Z* = Z Gamma which is the original incidence matrix for the timevar multiplied by the loadings.</p>
</dd>
<dt>$Gamma</dt><dd><p> a matrix of loadings or latent covariates.</p>
</dd>
<dt>$Sigma</dt><dd><p> the covariance matrix used to calculate Gamma.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>
<p>Meyer K (2009) Factor analytic models for genotype by environment type problems and structured covariance matrices. Genetics Selection Evolution, 41:21
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>rrc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_h2)
DT &lt;- DT_h2
DT=DT[with(DT, order(Env)), ]
head(DT)
indNames &lt;- na.omit(unique(DT$Name))
A &lt;- diag(length(indNames))
rownames(A) &lt;- colnames(A) &lt;- indNames


  
# fit diagonal model first to produce H matrix
ansDG &lt;- mmec(y~Env,
              random=~ vsc(dsc(Env), isc(Name)),
              rcov=~units, nIters = 100,
              # we recommend giving more EM iterations at the beggining
              emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),
              data=DT)

H0 &lt;- ansDG$uList$`vsc(dsc(Env), isc(Name))` # GxE table

# reduced rank model
ansFA &lt;- mmec(y~Env,
              random=~vsc( usc(rrc(Env, H = H0, nPC = 3)) , isc(Name)) + # rr
                vsc(dsc(Env), isc(Name)), # diag
              rcov=~units,
              # we recommend giving more iterations to these models
              nIters = 100,
              # we recommend giving more EM iterations at the beggining
              emWeight = c(rep(1,10),logspace(10,1,.05), rep(.05,80)),
              data=DT)

vcFA &lt;- ansFA$theta[[1]]
vcDG &lt;- ansFA$theta[[2]]

loadings=with(DT, rrc(Env, nPC = 3, H = H0, returnGamma = TRUE) )$Gamma
scores &lt;- ansFA$uList[[1]]

vcUS &lt;- loadings %*% vcFA %*% t(loadings)
G &lt;- vcUS + vcDG
# colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
# hv &lt;- heatmap(cov2cor(G), col = colfunc(100), symm = TRUE)

uFA &lt;- scores %*% t(loadings)
uDG &lt;- ansFA$uList[[2]]
u &lt;- uFA + uDG
  



</code></pre>

<hr>
<h2 id='simGECorMat'>
Create a GE correlation matrix for simulation purposes. 
</h2><span id='topic+simGECorMat'></span>

<h3>Description</h3>

<p>Makes a simple correlation matrix based on the number of environments and megaenvironments desired. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGECorMat(nEnv,nMegaEnv,mu=0.7, v=0.2, mu2=0, v2=0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simGECorMat_+3A_nenv">nEnv</code></td>
<td>

<p>Number of environments to simulate. Needs to be divisible by the nMegaEnv argument.
</p>
</td></tr>
<tr><td><code id="simGECorMat_+3A_nmegaenv">nMegaEnv</code></td>
<td>

<p>Number of megaenvironments to simulate.
</p>
</td></tr>
<tr><td><code id="simGECorMat_+3A_mu">mu</code></td>
<td>

<p>Mean value of the genetic correlation within megaenvironments.
</p>
</td></tr>
<tr><td><code id="simGECorMat_+3A_v">v</code></td>
<td>

<p>variance in the genetic correlation within megaenvironments.
</p>
</td></tr>
<tr><td><code id="simGECorMat_+3A_mu2">mu2</code></td>
<td>

<p>Mean value of the genetic correlation between megaenvironments.
</p>
</td></tr>
<tr><td><code id="simGECorMat_+3A_v2">v2</code></td>
<td>

<p>variance in the genetic correlation between megaenvironments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple simulation of a correlation matrix for environments and megaenvironments.
</p>


<h3>Value</h3>

<p>G the correlation matrix
</p>

<dl>
<dt>$G</dt><dd><p>the correlation matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>simGECorMat(9,3)
</code></pre>

<hr>
<h2 id='sommer-package'>
<strong>So</strong>lving <strong>M</strong>ixed <strong>M</strong>odel <strong>E</strong>quations in <strong>R</strong>
<br />
<img src="../help/figures/mai.png" height="10%" alt="Figure: mai.png" />
</h2><span id='topic+sommer'></span>

<h3>Description</h3>

<p>Sommer is a structural multivariate-univariate linear mixed model solver for multiple random effects allowing the specification and/or estimation of variance covariance structures. REML estimates can be obtained using two major methods
</p>
<p>Direct-Inversion (Newton-Raphson and Average Information) &gt;&gt; <code><a href="#topic+mmer">mmer</a></code> function
</p>
<p>Henderson's mixed model equations (Average Information) &gt;&gt; <code><a href="#topic+mmec">mmec</a></code> function
</p>
<p>The algorithms are coded in C++ using the Armadillo library to optimize dense matrix operations common in genomic models. Sommer was designed to include complex covariance structures, e.g., unstructured, reduced-rank, diagonal. And also to model relationships between levels of a random effect, e.g., additive, dominance and epistatic relationship structures.  
</p>
<p>The <code><a href="#topic+mmer">mmer</a></code> function can deal well with small and medium-size data sets (&lt; 10,000 observations/records for average computers given the computational burden carried by the direct-inversion algorithms) since it works in the c &gt; r problem and inverts an r x r matrix (being r the number of records and c the number of coefficients). On the other hand, the <code><a href="#topic+mmec">mmec</a></code> function can deal with greater number of records (r&gt;250K) as long as the number of coefficients to estimate is &lt; 10,000 coefficients (c) since it works in the r &gt; c problem and inverts a c x c matrix (being c the number of coefficients). The <code><a href="#topic+predict.mmer">predict.mmer</a></code> and <code><a href="#topic+predict.mmec">predict.mmec</a></code> functions can be used to obtain adjusted means. This package returns variance-covariance components, BLUPs, BLUEs, residuals, fitted values, variances-covariances for fixed and random effects, etc.
</p>


<h3>Functions for genetic analysis</h3>

<p>The package provides kernels to estimate additive (<code><a href="#topic+A.mat">A.mat</a></code>), dominance (<code><a href="#topic+D.mat">D.mat</a></code>), epistatic (<code><a href="#topic+E.mat">E.mat</a></code>), single-step (<code><a href="#topic+H.mat">H.mat</a></code>) relationship matrices for diploid and polyploid organisms. It also provides flexibility to fit other genetic models such as full and half diallel models and random regression models.
</p>
<p>A good converter from letter code to numeric format is implemented in the function <code><a href="#topic+atcg1234">atcg1234</a></code>, which supports higher ploidy levels than diploid. Additional functions for genetic analysis have been included such as build a genotypic hybrid marker matrix (<code><a href="#topic+build.HMM">build.HMM</a></code>), plot of genetic maps (<code><a href="#topic+map.plot">map.plot</a></code>), creation of manhattan plots (<code><a href="#topic+manhattan">manhattan</a></code>). If you need to use pedigree you need to convert your pedigree into a relationship matrix (use the 'getA' function from the pedigreemm package).
</p>


<h3>Functions for statistical analysis and S3 methods</h3>

<p>The <code><a href="#topic+vpredict">vpredict</a></code> function can be used to estimate standard errors for linear combinations of variance components (e.g. ratios like h2). The <code><a href="#topic+r2">r2</a></code> function calculates reliability. S3 methods are available for some parameter extraction such as:
</p>
<p>+ <code><a href="#topic+predict.mmer">predict.mmer</a></code>, <code><a href="#topic+predict.mmec">predict.mmec</a></code>,
</p>
<p>+ <code><a href="#topic+fitted.mmer">fitted.mmer</a></code>, <code><a href="#topic+fitted.mmec">fitted.mmec</a></code>, 
</p>
<p>+ <code><a href="#topic+residuals.mmer">residuals.mmer</a></code>,  <code><a href="#topic+residuals.mmec">residuals.mmec</a></code>, 
</p>
<p>+ <code><a href="#topic+summary.mmer">summary.mmer</a></code>,  <code><a href="#topic+summary.mmec">summary.mmec</a></code>, 
</p>
<p>+ <code><a href="#topic+coef.mmer">coef.mmer</a></code>, <code><a href="#topic+coef.mmec">coef.mmec</a></code>, 
</p>
<p>+ <code><a href="#topic+anova.mmer">anova.mmer</a></code>, <code><a href="#topic+anova.mmec">anova.mmec</a></code>, 
</p>
<p>+ <code><a href="#topic+plot.mmer">plot.mmer</a></code>, <code><a href="#topic+plot.mmec">plot.mmec</a></code>.
</p>


<h3>Functions for trial analysis</h3>

<p>Recently, spatial modeling has been added added to sommer using the two-dimensional spline (<code><a href="#topic+spl2Da">spl2Da</a></code> and <code><a href="#topic+spl2Db">spl2Db</a></code> for <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+spl2Dc">spl2Dc</a></code> for <code><a href="#topic+mmec">mmec</a></code> ) functions.
</p>


<h3>Keeping sommer updated</h3>

<p>The sommer package is updated on CRAN every 4-months due to CRAN policies but you can find the latest source at https://github.com/covaruber/sommer. This can be easily installed typing the following in the R console:
</p>
<p>library(devtools)
</p>
<p>install_github(&quot;covaruber/sommer&quot;)
</p>
<p>This is recommended if you reported a bug, was fixed and was immediately pushed to GitHub but not in CRAN until the next update.
</p>


<h3>Tutorials</h3>

<p><strong>For tutorials</strong> on how to perform different analysis with sommer please look at the vignettes by typing in the terminal:
</p>
<p><strong>vignette(&quot;v1.sommer.quick.start&quot;)</strong> 
</p>
<p><strong>vignette(&quot;v2.sommer.changes.and.faqs&quot;)</strong>
</p>
<p><strong>vignette(&quot;v3.sommer.qg&quot;)</strong>
</p>
<p><strong>vignette(&quot;v4.sommer.gxe&quot;)</strong>
</p>
<p>or visit <strong>https://covaruber.github.io</strong>
</p>


<h3>Getting started</h3>

<p>The package has been equiped with several datasets to learn how to use the sommer package (and almost to learn all sort of quantitative genetic analysis): 
</p>
<p>* <code><a href="#topic+DT_halfdiallel">DT_halfdiallel</a></code>, <code><a href="#topic+DT_fulldiallel">DT_fulldiallel</a></code> and <code><a href="#topic+DT_mohring">DT_mohring</a></code> datasets have examples to fit half and full diallel designs. 
</p>
<p>* <code><a href="#topic+DT_h2">DT_h2</a></code> to calculate heritability
</p>
<p>* <code><a href="#topic+DT_cornhybrids">DT_cornhybrids</a></code> and <code><a href="#topic+DT_technow">DT_technow</a></code> datasets to perform genomic prediction in hybrid single crosses 
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to do genomic prediction in single crosses in species displaying only additive effects.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to fit genomic prediction models within a biparental population coming from 2 highly heterozygous parents including additive, dominance and epistatic effects. 
</p>
<p>* <code><a href="#topic+DT_polyploid">DT_polyploid</a></code> to fit genomic prediction and GWAS analysis in polyploids. 
</p>
<p>* <code><a href="#topic+DT_gryphon">DT_gryphon</a></code> data contains an example of an animal model including pedigree information.
</p>
<p>* <code><a href="#topic+DT_btdata">DT_btdata</a></code> dataset contains an animal (birds) model.
</p>
<p>* <code><a href="#topic+DT_legendre">DT_legendre</a></code> simulated dataset for random regression model.
</p>
<p>* <code><a href="#topic+DT_sleepstudy">DT_sleepstudy</a></code> dataset to know how to translate lme4 models to sommer models.
</p>


<h3>Differences of sommer &gt;= 4.1.7 with previous versions</h3>

<p>Since version 4.1.7 I have introduced the mme-based average information function 'mmec' which is much faster when dealing with the r &gt; c problem (more records than coefficients to estimate). This introduces its own covariance structure functons such as vsc(), usc(), dsc(), atc(), csc(). Please give it a try, although is in early phase of development.
</p>


<h3>Differences of sommer &gt;= 3.7.0 with previous versions</h3>

<p>Since version 3.7 I have completly redefined the specification of the variance-covariance structures to provide more flexibility to the user. This has particularly helped the residual covariance structures and the easier combination of custom random effects and overlay models. I think that although this will bring some uncomfortable situations at the beggining, in the long term this will help users to fit better models. In esence, I have abandoned the asreml formulation (not the structures available) given it's limitations to combine some of the sommer structures but all covariance structures can now be fitted using the 'vsr' functions. 
</p>


<h3>Differences of sommer &gt;= 3.0.0 with previous versions</h3>

<p>Since version 3.0 I have decided to focus in developing the multivariate solver and for doing this I have decided to remove the M argument (for GWAS analysis) from the mmer function and move it to it's own function <code><a href="#topic+GWAS">GWAS</a></code>.
</p>
<p>Before the mmer solver had implemented the usr(trait), diag(trait), at(trait) asreml formulation for multivariate models that allow to specify the structure of the trait in multivariate models. Therefore the MVM argument was no longer needed. After version 3.7 now the multi-trait structures can be specified in the <code>Gt</code> and <code>Gtc</code> arguments of the <code><a href="#topic+vsr">vsr</a></code> function.
</p>
<p>The Average Information algorithm had been removed in the past from the package because of its instability to deal with very complex models without good initial values. Now after 3.7 I have brought it back after I noticed that starting with NR the first three iterations gives enough flexibility to the AI algorithm.
</p>
<p>Keep in mind that sommer uses direct inversion (DI) algorithm which can be very slow for datasets with many observations (big 'n'). The package is focused in problems of the type p &gt; n (more random effect(s) levels than observations) and models with dense covariance structures. For example, for experiment with dense covariance structures with low-replication (i.e. 2000 records from 1000 individuals replicated  twice with a covariance structure of 1000x1000) sommer will be faster than MME-based software. Also for genomic problems with large number of random effect levels, i.e. 300 individuals (n) with 100,000 genetic markers (p). On the other hand, for highly replicated trials with small covariance structures or n &gt; p (i.e. 2000 records from 200 individuals replicated 10 times with covariance structure of 200x200) asreml or other MME-based algorithms will be much faster and I recommend you to use that software.
</p>


<h3>Models Enabled</h3>

<p>The core of the package are the <code><a href="#topic+mmer">mmer</a></code> and <code><a href="#topic+mmec">mmec</a></code> (formula-based) functions which solve the mixed model equations. The functions are an interface to call the 'NR' Direct-Inversion Newton-Raphson, 'AI' Direct-Inversion Average Information or the mme-based Average Information (Tunnicliffe 1989; Gilmour et al. 1995; Lee et al. 2016). Since version 2.0 sommer can handle multivariate models. Following Maier et al. (2015), the multivariate (and by extension the univariate) mixed model implemented has the form:
</p>
<p><img src="../help/figures/form1.png" height="10%" alt="Figure: form1.png" />
</p>
<p>where y_i is a vector of trait phenotypes, <code class="reqn">\beta_i</code> is a vector of fixed effects, u_i is a vector of random effects for individuals and e_i are residuals for trait i (i = 1,..., t). The random effects (u_1 ... u_i and e_i) are assumed to be normally distributed with mean zero. X and Z are incidence matrices for fixed and random effects respectively. The distribution of the multivariate response and the phenotypic variance covariance (V) are:
</p>
<p><img src="../help/figures/form2.png" height="10%" alt="Figure: form2.png" />
</p>
<p>where K is the relationship or covariance matrix for the kth random effect (u=1,...,k), and R=I is an identity matrix for the residual term. The terms <code class="reqn">\sigma^2_{g_{i}}</code> and <code class="reqn">\sigma^2_{\epsilon_{i}}</code> denote the genetic (or any of the kth random terms) and residual variance of trait i, respectively and <code class="reqn">\sigma_{g_{_{ij}}}</code> and <code class="reqn">\sigma_{\epsilon_{_{ij}}}</code> the genetic (or any of the kth random terms) and residual covariance between traits i and j (i=1,...,t, and j=1,...,t). The algorithm implemented optimizes the log likelihood:
</p>
<p><img src="../help/figures/form3.png" height="10%" alt="Figure: form3.png" />
</p>
<p>where || is the determinant of a matrix. And the REML estimates are updated using a Newton optimization algorithm of the form:
</p>
<p><img src="../help/figures/form4.png" height="10%" alt="Figure: form4.png" />
</p>
<p>Where, theta is the vector of variance components for random effects and covariance components among traits, H^-1 is the inverse of the Hessian matrix of second derivatives for the kth cycle, dL/dsigma^2_i is the vector of first derivatives of the likelihood with respect to the variance-covariance components. The Eigen decomposition of the relationship matrix proposed by Lee and Van Der Werf (2016) was included in the Newton-Raphson algorithm to improve time efficiency. Additionally, the popular vpredict function to estimate standard errors for linear combinations of variance components (i.e. heritabilities and genetic correlations) was added to the package as well.
</p>


<h3>GWAS Models</h3>

<p>The GWAS models in the sommer package are enabled by using the M argument in the functions <code><a href="#topic+GWAS">GWAS</a></code>, which is expected to be a numeric marker matrix. Markers are treated as fixed effects according to the model proposed by Yu et al. (2006) for diploids, and Rosyara et al. (2016) (for polyploids). The matrices X and M are both fixed effects, but they are separated by 2 different arguments to distinguish factors such as environmental and design factors for the argument &quot;X&quot; and markers with &quot;M&quot;.
</p>
<p>The genome-wide association analysis is based on the mixed model:
</p>
<p style="text-align: center;"><code class="reqn">y = X \beta + Z g + M \tau + e</code>
</p>

<p>where <code class="reqn">\beta</code> is a vector of fixed effects that can model both environmental factors and population structure.  
The variable <code class="reqn">g</code> models the genetic background of each line as a random effect with <code class="reqn">Var[g] = K \sigma^2</code>.  
The variable <code class="reqn">\tau</code> models the additive SNP effect as a fixed effect.  The residual variance is <code class="reqn">Var[\varepsilon] = I \sigma_e^2</code>
</p>
<p>When principal components are included (P+K model), the loadings are determined from an eigenvalue decomposition of the K matrix and are used in the fixed effect part.
</p>
<p>The argument &quot;P3D&quot; introduced by Zhang et al. (2010) can be used with the P3D argument.  When P3D=FALSE, this function is equivalent to AI/NR with REML where the variance components are estimated for each SNP or marker tested (Kang et al. 2008).  When P3D=TRUE, it is equivalent to NR (Kang et al. 2010) where the assumption is that variance components for all SNP/markers are the same and therefore the variance components are estimated only once (and markers are tested in a WLS framework being the the weight matrix (M) the inverse of the phenotypic variance matrix (V)).  Therefore, P3D=TRUE option is faster but can underestimate significance compared to P3D=FALSE.
</p>
<p>Multivariate GWAS are based in Covarrubias-Pazaran et al. (2018, In preparation), which adjusts betas for all response variables and then does the regular GWAS with such adjusted betas or marker effects.
</p>
<p>For extra details about the methods please read the canonical papers listed in the References section.
</p>


<h3>Bug report and contact</h3>

<p>If you have any questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com
</p>
<p>I'll be glad to help or answer any question. I have spent a valuable amount of time developing this package. Please cite this package in your publication. Type 'citation(&quot;sommer&quot;)' to know how to cite it.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G. 2016. Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Covarrubias-Pazaran G. 2018. Software update: Moving the R package sommer to multivariate mixed models for genome-assisted prediction. doi: https://doi.org/10.1101/354639
</p>
<p>Bernardo Rex. 2010. Breeding for quantitative traits in plants. Second edition. Stemma Press. 390 pp.
</p>
<p>Gilmour et al. 1995. Average Information REML: An efficient algorithm for variance parameter estimation in linear mixed models. Biometrics 51(4):1440-1450.
</p>
<p>Henderson C.R. 1975. Best Linear Unbiased Estimation and Prediction under a Selection Model. Biometrics vol. 31(2):423-447.
</p>
<p>Kang et al. 2008. Efficient control of population structure in model organism association mapping. Genetics 178:1709-1723.
</p>
<p>Lee et al. 2015. MTG2: An efficient algorithm for multivariate linear mixed model analysis based on genomic information. Cold Spring Harbor. doi: http://dx.doi.org/10.1101/027201.
</p>
<p>Maier et al. 2015. Joint analysis of psychiatric disorders increases accuracy of risk prediction for schizophrenia, bipolar disorder, and major depressive disorder. Am J Hum Genet; 96(2):283-294.
</p>
<p>Searle. 1993. Applying the EM algorithm to calculating ML and REML estimates of variance components. Paper invited for the 1993 American Statistical Association Meeting, San Francisco.
</p>
<p>Yu et al. 2006. A unified mixed-model method for association mapping that accounts for multiple levels of relatedness. Genetics 38:203-208.
</p>
<p>Tunnicliffe W. 1989. On the use of marginal likelihood in time series model estimation. JRSS 51(1):15-27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####

####=========================================####
#### EXAMPLES
#### Different models with sommer
####=========================================####

data(DT_example)

# DT &lt;- DT_example
# DT=DT[with(DT, order(Env)), ]
# head(DT)
# 
# ####=========================================####
# #### Univariate homogeneous variance models  ####
# ####=========================================####
# 
# ## Compound simmetry (CS) model
# ans1 &lt;- mmer(Yield~Env,
#              random= ~ Name + Env:Name,
#              rcov= ~ units,
#              data=DT)
# summary(ans1)
# 
# ans2 &lt;- mmec(Yield~Env,
#              random= ~ Name + Env:Name,
#              rcov= ~ units,
#              data=DT)
# summary(ans2)
# 
# ####===========================================####
# #### Univariate heterogeneous variance models  ####
# ####===========================================####
# ## Compound simmetry (CS) + Diagonal (DIAG) model
# ans3 &lt;- mmer(Yield~Env,
#              random= ~Name + vsr(dsr(Env),Name),
#              rcov= ~ vsr(dsr(Env),units),
#              data=DT)
# summary(ans3)
# 
# ans4 &lt;- mmec(Yield~Env,
#              random= ~Name + vsc(dsc(Env),isc(Name)),
#              rcov= ~ vsc(dsc(Env),isc(units)),
#              data=DT)
# summary(ans4)

</code></pre>

<hr>
<h2 id='spl2Da'>
Two-dimensional penalised tensor-product of marginal B-Spline basis.
</h2><span id='topic+spl2Da'></span>

<h3>Description</h3>

<p>Auxiliary function used for modelling the spatial or environmental effect as a two-dimensional penalised tensor-product (isotropic approach) based on Lee et al. (2013) and Rodriguez-Alvarez et al. (2018). This is a modified wrapper of some portions of the SpATS package to build a single incidence matrix containing all the columns from tensor products of the x and y coordinates and it fits such matrix as a single random effect. Then the heterogeneous covariances structure capabilities of sommer can be used to enhance the model fit. You may be interested in reading and citing not only sommer but also Wageningen publications if using this 2D spline methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl2Da(x.coord,y.coord,at.var=NULL,at.levels=NULL, type="PSANOVA", 
      nsegments = c(10,10), penaltyord = c(2,2), degree = c(3,3), 
      nestorder = c(1,1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spl2Da_+3A_x.coord">x.coord</code></td>
<td>
<p>vector of coordinates on the x-axis direction (i.e. row) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_y.coord">y.coord</code></td>
<td>
<p>vector of coordinates on the y-axis direction (i.e. range or column) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_at.var">at.var</code></td>
<td>
<p>vector of indication variable where heterogeneous variance is required (e.g., a different spl2D for each field).</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_at.levels">at.levels</code></td>
<td>
<p>character vector with the names of the leves for the at term that should be used, if missing all levels are used.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_type">type</code></td>
<td>
<p>one of the two methods &quot;PSANOVA&quot; or &quot;SAP&quot;. See details below.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_nsegments">nsegments</code></td>
<td>
<p>numerical vector of length 2 containing the number of segments for each marginal (strictly <code>nsegments</code> - 1 is the number of internal knots in the domain of the covariate). Atomic values are also valid, being recycled. Default set to 10.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_penaltyord">penaltyord</code></td>
<td>
<p>numerical vector of length 2 containing the penalty order for each marginal. Atomic values are also valid, being recycled. Default set to 2 (second order). Currently, only second order penalties are allowed.</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_degree">degree</code></td>
<td>
<p>numerical vector of length 2 containing the order of the polynomial of the B-spline basis for each marginal. Atomic values are also valid, being recycled. Default set to 3 (cubic B-splines).</p>
</td></tr>
<tr><td><code id="spl2Da_+3A_nestorder">nestorder</code></td>
<td>
<p>numerical vector of length 2 containing the divisor of the number of segments (<code>nsegments</code>) to be used for the construction of the nested B-spline basis for the smooth-by-smooth interaction component. In this case, the nested B-spline basis will be constructed assuming a total of <code>nsegments</code>/<code>nestorder</code> segments. Default set to 1, which implies that nested basis are not used. See <code>SAP</code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The following documentation is taken from the SpATS package. Please refer to this package and associated publications if you are interested in going deeper on this technique:</strong>
</p>
<p>Within the P-spline framework, anisotropic low-rank tensor-product smoothers have become the general approach for modelling multidimensional surfaces (Eilers and Marx 2003; Wood 2006). In the original SpATS package, was proposed to model the spatial or environmental effect by means of the tensor-product of B-splines basis functions. In other words, was proposed to model the spatial trend as a smooth bivariate surface jointly defined over the the spatial coordinates. Accordingly, the current function has been designed to allow the user to specify the spatial coordinates that the spatial trend is a function of. There is no restriction about how the spatial coordinates shall be specified: these can be the longitude and latitude of the position of the plot on the field or the column and row numbers. The only restriction is that the variables defining the spatial coordinates should be numeric (in contrast to factors).
</p>
<p>As far as estimation is concerned, we have used in this package the equivalence between P-splines and linear mixed models (Currie and Durban, 2002). Under this approach, the smoothing parameters are expressed as the ratio between variance components. Moreover, the smooth components are decomposed in two parts: one which is not penalised (and treated as fixed) and one with is penalised (and treated as random). For the two-dimensional case, the mixed model representation leads also to a very interesting decomposition of the penalised part of the bivariate surface in three different components (Lee and Durban, 2011): (a) a component that contains the smooth main effect (smooth trend)	along one of the covariates that the surface is a function of (as, e.g, the x-spatial coordinate or column position of the plot in the field), (b) a component that contains the smooth main effect (smooth trend) along the other covariate (i.e., the y-spatial coordinate or row position); and (c) a smooth interaction component (sum of the linear-by-smooth interaction components and the smooth-by-smooth interaction component). 
</p>
<p>The original implementation of SpATS assumes two different smoothing parameters, i.e., one for each covariate in the smooth component. Accordingly, the same smoothing parameters are used for both, the main effects and the smooth interaction. However, this approach can be extended to deal with the ANOVA-type decomposition presented in Lee and Durban (2011). In their approach, four different smoothing parameters are considered for the smooth surface, that are in concordance with the aforementioned decomposition: (a) two smoothing parameter, one for each of the main effects; and (b) two smoothing parameter for the smooth interaction component.
</p>
<p>It should be noted that, the computational burden associated with the estimation of the two-dimensional tensor-product smoother might be prohibitive if the dimension of the marginal bases is large. In these cases, Lee et al. (2013) propose to reduce the computational cost by using nested bases. The idea is to reduce the dimension of the marginal bases (and therefore the associated number of parameters to be estimated), but only for the smooth-by-smooth interaction component. As pointed out by the authors, this simplification can be justified by the fact that the main effects would in fact explain most of the structure (or spatial trend) presented in the data, and so a less rich representation of the smooth-by-smooth interaction component could be needed. In order to ensure that the reduced bivariate surface is in fact nested to the model including only the main effects, Lee et al. (2013) show that the number of segments used for the nested basis should be a divisor of the number of segments used in the original basis (<code>nsegments</code> argument). In the present function, the divisor of the number of segments is specified through the argument <code>nestorder</code>. For a more detailed review on this topic, see Lee (2010) and Lee et al. (2013). The &quot;PSANOVA&quot; approach represents an alternative method. In this case, the smooth bivariate surface (or spatial trend) is decomposed in five different components each of them depending on a single smoothing parameter (see Lee et al., 2013).
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>As mentioned at the beginning, the piece of documentation stated above was taken completely from the SpATS package in order to provide a deeper explanation. In practice, sommer uses some pieces of code from SpATS to build the design matrix containing all the columns from tensor products of the x and y coordinates and it fits such matrix as a single random effect. As a result the same variance component is assumed for the linear, linear by linear, linear by spline, and spline by spline interactions. This results in a less flexible approach than the one proposed by Rodriguez-Alvarez et al. (2018) but still makes a pretty good job to model the spatial variation. Use under your own risk.
</p>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.A., and Eilers, P.H.C. (2018). SpATS: Spatial Analysis of Field Trials with Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS.
</p>
<p>Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: the SAP algorthm. Statistics and Computing 25.5: 941-957.
</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient two-dimensional smoothing with P-spline ANOVA mixed models and nested bases. Computational Statistics and Data Analysis, 61, 22 - 37.
</p>
<p>Gilmour, A.R., Cullis, B.R., and Verbyla, A.P. (1997). Accounting for Natural and Extraneous Variation in the Analysis of Field Experiments. Journal of Agricultural, Biological, and Environmental Statistics, 2, 269 - 293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code>, <code><a href="#topic+spl2Db">spl2Db</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ============================ ##
## example to use spl2Da() 
## ============================ ## 
data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# A &lt;- A.mat(GT)
# mix &lt;- mmer(Yield~1,
#             random=~vsr(id, Gu=A) +
#               vsr(Rowf) +
#               vsr(Colf) +
#               spl2Da(Row,Col),
#             rcov=~units,
#             data=DT)
# summary(mix)$varcomp
## ============================ ##
## mimic 2 fields
## ============================ ## 
# aa &lt;- DT; bb &lt;- DT
# aa$FIELD &lt;- "A";bb$FIELD &lt;- "B"
# set.seed(1234)
# aa$Yield &lt;- aa$Yield + rnorm(length(aa$Yield),0,4)
# DT2 &lt;- rbind(aa,bb)
# head(DT2)
# A &lt;- A.mat(GT)
# mix &lt;- mmer(Yield~1,
#             random=~vsr(dsr(FIELD),id, Gu=A) +
#               vsr(dsr(FIELD),Rowf) +
#               vsr(dsr(FIELD),Colf) +
#                 spl2Da(Row,Col,at.var=FIELD),
#             rcov=~vsr(dsr(FIELD),units),
#             data=DT2)
</code></pre>

<hr>
<h2 id='spl2Db'>
Two-dimensional penalised tensor-product of marginal B-Spline basis.
</h2><span id='topic+spl2Db'></span>

<h3>Description</h3>

<p>Auxiliary function used for modelling the spatial or environmental effect as a two-dimensional penalised tensor-product (isotropic approach) based on Lee et al. (2013) and Rodriguez-Alvarez et al. (2018). <code>spl2Db</code> gets Tensor-Product P-Spline Mixed Model Incidence Matrices
for use with <code>sommer</code> and its main function <code>mmer</code>. We thank Sue Welham for making the TPSbits package available to the community. If you're using this function for your research please cite her TPSbits package :) this is mostly a wrapper of her tpsmmb function to enable the use in sommer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl2Db(x.coord,y.coord,at.var=NULL,at.levels=NULL,nsegments = c(10,10), 
       degree = c(3,3), penaltyord = c(2,2), nestorder = c(1,1),
       minbound=NULL, maxbound=NULL, method="Lee", what="bits")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spl2Db_+3A_x.coord">x.coord</code></td>
<td>
<p>vector of coordinates on the x-axis direction (i.e. row) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_y.coord">y.coord</code></td>
<td>
<p>vector of coordinates on the y-axis direction (i.e. range or column) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_at.var">at.var</code></td>
<td>
<p>vector of indication variable where heterogeneous variance is required (e.g., a different spl2D for each field).</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_at.levels">at.levels</code></td>
<td>
<p>character vector with the names of the leves for the at term that should be used, if missing all levels are used.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_nsegments">nsegments</code></td>
<td>
<p>numerical vector of length 2 containing the number of segments for each marginal (strictly <code>nsegments</code> - 1 is the number of internal knots in the domain of the covariate). Atomic values are also valid, being recycled. Default set to 10.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_degree">degree</code></td>
<td>
<p>numerical vector of length 2 containing the order of the polynomial of the B-spline basis for each marginal. Atomic values are also valid, being recycled. Default set to 3 (cubic B-splines).</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_penaltyord">penaltyord</code></td>
<td>
<p>numerical vector of length 2 containing the penalty order for each marginal. Atomic values are also valid, being recycled. Default set to 2 (second order). Currently, only second order penalties are allowed.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_nestorder">nestorder</code></td>
<td>
<p>numerical vector of length 2 containing the divisor of the number of segments (<code>nsegments</code>) to be used for the construction of the nested B-spline basis for the smooth-by-smooth interaction component. In this case, the nested B-spline basis will be constructed assuming a total of <code>nsegments</code>/<code>nestorder</code> segments. Default set to 1, which implies that nested basis are not used. See <code>SAP</code> for more details.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_minbound">minbound</code></td>
<td>
<p>A list of length 2. The lower bound to be used for column and row dimensions respectively; default calculated as the minimum value for each dimension.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_maxbound">maxbound</code></td>
<td>
<p>A list of length 2. The upper bound to be used for column and row dimensions respectively; default calculated as the maximum value for each dimension.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_method">method</code></td>
<td>
<p>A string. Method for forming the penalty; default=&quot;Lee&quot; ie the penalty from Lee, Durban &amp; Eilers (2013, CSDA 61, 22-37). The alternative method is &quot;Wood&quot; ie. the method from Wood et al (2012, Stat Comp 23, 341-360). This option is a research tool and requires further investigation.</p>
</td></tr>
<tr><td><code id="spl2Db_+3A_what">what</code></td>
<td>
<p>one of two values; 'base' or 'bits' to return:
</p>
<p>base = matrix for columns cbind(TP.col,TP.row,TP.C.n,TP.R.n,TP.CR.n). To be used in the fixed part.
</p>
<p>bits = matrices for the tensor products. To be used in the random part.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The following documentation is taken from the SpATS package. Please refer to this package and associated publications if you are interested in going deeper on this technique:</strong>
</p>
<p>Within the P-spline framework, anisotropic low-rank tensor-product smoothers have become the general approach for modelling multidimensional surfaces (Eilers and Marx 2003; Wood 2006). In the original SpATS package, was proposed to model the spatial or environmental effect by means of the tensor-product of B-splines basis functions. In other words, was proposed to model the spatial trend as a smooth bivariate surface jointly defined over the the spatial coordinates. Accordingly, the current function has been designed to allow the user to specify the spatial coordinates that the spatial trend is a function of. There is no restriction about how the spatial coordinates shall be specified: these can be the longitude and latitude of the position of the plot on the field or the column and row numbers. The only restriction is that the variables defining the spatial coordinates should be numeric (in contrast to factors).
</p>
<p>As far as estimation is concerned, we have used in this package the equivalence between P-splines and linear mixed models (Currie and Durban, 2002). Under this approach, the smoothing parameters are expressed as the ratio between variance components. Moreover, the smooth components are decomposed in two parts: one which is not penalised (and treated as fixed) and one with is penalised (and treated as random). For the two-dimensional case, the mixed model representation leads also to a very interesting decomposition of the penalised part of the bivariate surface in three different components (Lee and Durban, 2011): (a) a component that contains the smooth main effect (smooth trend)	along one of the covariates that the surface is a function of (as, e.g, the x-spatial coordinate or column position of the plot in the field), (b) a component that contains the smooth main effect (smooth trend) along the other covariate (i.e., the y-spatial coordinate or row position); and (c) a smooth interaction component (sum of the linear-by-smooth interaction components and the smooth-by-smooth interaction component). 
</p>
<p>The default implementation assumes two different smoothing parameters, i.e., one for each covariate in the smooth component. Accordingly, the same smoothing parameters are used for both, the main effects and the smooth interaction. However, this approach can be extended to deal with the ANOVA-type decomposition presented in Lee and Durban (2011). In their approach, four different smoothing parameters are considered for the smooth surface, that are in concordance with the aforementioned decomposition: (a) two smoothing parameter, one for each of the main effects; and (b) two smoothing parameter for the smooth interaction component. 
</p>
<p>It should be noted that, the computational burden associated with the estimation of the two-dimensional tensor-product smoother might be prohibitive if the dimension of the marginal bases is large. In these cases, Lee et al. (2013) propose to reduce the computational cost by using nested bases. The idea is to reduce the dimension of the marginal bases (and therefore the associated number of parameters to be estimated), but only for the smooth-by-smooth interaction component. As pointed out by the authors, this simplification can be justified by the fact that the main effects would in fact explain most of the structure (or spatial trend) presented in the data, and so a less rich representation of the smooth-by-smooth interaction component could be needed. In order to ensure that the reduced bivariate surface is in fact nested to the model including only the main effects, Lee et al. (2013) show that the number of segments used for the nested basis should be a divisor of the number of segments used in the original basis (<code>nsegments</code> argument). In the present function, the divisor of the number of segments is specified through the argument <code>nestorder</code>. For a more detailed review on this topic, see Lee (2010) and Lee et al. (2013). The &quot;PSANOVA&quot; approach represents an alternative method. In this case, the smooth bivariate surface (or spatial trend) is decomposed in five different components each of them depending on a single smoothing parameter (see Lee et al., 2013).
</p>


<h3>Value</h3>

<p>List of length 7 elements:
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:(diff.c) = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:(diff.r) = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:((diff.c*diff.r)) = interaction between the
two X parts for use in fixed model. The first variate is
a constant term which should be omitted from the model when the constant
(1) is present. If all elements are
included in the model then the constant term should be omitted,
eg. <code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>fR</code> = Xr1:Zc
</p>
</li>
<li> <p><code>fC</code> = Xr2:Zc
</p>
</li>
<li> <p><code>fR.C</code> = Zr:Xc1
</p>
</li>
<li> <p><code>R.fC</code> = Zr:Xc2 
</p>
</li>
<li> <p><code>fR.fC</code> = Zc:Zr
</p>
</li>
<li> <p><code>all</code> = Xr1:Zc | Xr2:Zc | Zr:Xc1 | Zr:Xc2 | Zc:Zr
</p>
</li></ol>



<h3>References</h3>

<p>Sue Welham (2021). TPSbits: Creates Structures to Enable Fitting and Examination of 2D Tensor-Product Splines using ASReml-R. R package version 1.0.0.
</p>
<p>Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.A., and Eilers, P.H.C. (2018). SpATS: Spatial Analysis of Field Trials with Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS.
</p>
<p>Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: the SAP algorthm. Statistics and Computing 25.5: 941-957.
</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient two-dimensional smoothing with P-spline ANOVA mixed models and nested bases. Computational Statistics and Data Analysis, 61, 22 - 37.
</p>
<p>Gilmour, A.R., Cullis, B.R., and Verbyla, A.P. (1997). Accounting for Natural and Extraneous Variation in the Analysis of Field Experiments. Journal of Agricultural, Biological, and Environmental Statistics, 2, 269 - 293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmer">mmer</a></code>, <code><a href="#topic+spl2Da">spl2Da</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ============================ ##
## example to use spl2Db() 
## ============================ ## 
data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# A &lt;- A.mat(GT)
# mix &lt;- mmer(Yield~1,
#             random=~vsr(id, Gu=A) +
#               vsr(Rowf) +
#               vsr(Colf) +
#               spl2Db(Row,Col),
#             rcov=~units,
#             data=DT)
# summary(mix)$varcomp
## ============================ ##
## mimic 2 fields
## ============================ ## 
# aa &lt;- DT; bb &lt;- DT
# aa$FIELD &lt;- "A";bb$FIELD &lt;- "B"
# set.seed(1234)
# aa$Yield &lt;- aa$Yield + rnorm(length(aa$Yield),0,4)
# DT2 &lt;- rbind(aa,bb)
# head(DT2)
# A &lt;- A.mat(GT)
# mix &lt;- mmer(Yield~1,
#             random=~vsr(dsr(FIELD),id, Gu=A) +
#               vsr(dsr(FIELD),Rowf) +
#               vsr(dsr(FIELD),Colf) +
#                 spl2Db(Row,Col,at.var=FIELD),
#             rcov=~vsr(dsr(FIELD),units),
#             data=DT2)
</code></pre>

<hr>
<h2 id='spl2Dc'>
Two-dimensional penalised tensor-product of marginal B-Spline basis.
</h2><span id='topic+spl2Dc'></span>

<h3>Description</h3>

<p>Auxiliary function used for modelling the spatial or environmental effect as a two-dimensional penalised tensor-product (isotropic approach) based on Lee et al. (2013) and Rodriguez-Alvarez et al. (2018). This is a modified wrapper of some portions of the SpATS package to build a single incidence matrix containing all the columns from tensor products of the x and y coordinates and it fits such matrix as a single random effect. Then the heterogeneous covariances structure capabilities of sommec can be used to enhance the model fit. You may be interested in reading and citing not only sommec but also Wageningen publications if using this 2D spline methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl2Dc(x.coord,y.coord,at.var=NULL,at.levels=NULL, type="PSANOVA", 
      nsegments = c(10,10), penaltyord = c(2,2), degree = c(3,3), 
      nestorder = c(1,1), thetaC=NULL, theta=NULL, sp=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spl2Dc_+3A_x.coord">x.coord</code></td>
<td>
<p>vector of coordinates on the x-axis direction (i.e. row) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_y.coord">y.coord</code></td>
<td>
<p>vector of coordinates on the y-axis direction (i.e. range or column) to use in the 2 dimensional spline.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_at.var">at.var</code></td>
<td>
<p>vector of indication variable where heterogeneous variance is required (e.g., a different spl2D for each field).</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_at.levels">at.levels</code></td>
<td>
<p>character vector with the names of the leves for the at term that should be used, if missing all levels are used.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_type">type</code></td>
<td>
<p>one of the two methods &quot;PSANOVA&quot; or &quot;SAP&quot;. See details below.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_nsegments">nsegments</code></td>
<td>
<p>numerical vector of length 2 containing the number of segments for each marginal (strictly <code>nsegments</code> - 1 is the number of internal knots in the domain of the covariate). Atomic values are also valid, being recycled. Default set to 10.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_penaltyord">penaltyord</code></td>
<td>
<p>numerical vector of length 2 containing the penalty order for each marginal. Atomic values are also valid, being recycled. Default set to 2 (second order). Currently, only second order penalties are allowed.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_degree">degree</code></td>
<td>
<p>numerical vector of length 2 containing the order of the polynomial of the B-spline basis for each marginal. Atomic values are also valid, being recycled. Default set to 3 (cubic B-splines).</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_nestorder">nestorder</code></td>
<td>
<p>numerical vector of length 2 containing the divisor of the number of segments (<code>nsegments</code>) to be used for the construction of the nested B-spline basis for the smooth-by-smooth interaction component. In this case, the nested B-spline basis will be constructed assuming a total of <code>nsegments</code>/<code>nestorder</code> segments. Default set to 1, which implies that nested basis are not used. See <code>SAP</code> for more details.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional matrix for constraints in the variance components.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_theta">theta</code></td>
<td>
<p>an optional matrix for initial values of the variance components.</p>
</td></tr>
<tr><td><code id="spl2Dc_+3A_sp">sp</code></td>
<td>
<p>a TRUE/FALSE statement to indicate if the VC from this structure should be multiplied by the scale parameter added in the mmec function through the addScaleParam argument in the <code>mmec</code> function .</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>The following documentation is taken from the SpATS package. Please refer to this package and associated publications if you are interested in going deeper on this technique:</strong>
</p>
<p>Within the P-spline framework, anisotropic low-rank tensor-product smoothers have become the general approach for modelling multidimensional surfaces (Eilers and Marx 2003; Wood 2006). In the original SpATS package, was proposed to model the spatial or environmental effect by means of the tensor-product of B-splines basis functions. In other words, was proposed to model the spatial trend as a smooth bivariate surface jointly defined over the the spatial coordinates. Accordingly, the current function has been designed to allow the user to specify the spatial coordinates that the spatial trend is a function of. There is no restriction about how the spatial coordinates shall be specified: these can be the longitude and latitude of the position of the plot on the field or the column and row numbers. The only restriction is that the variables defining the spatial coordinates should be numeric (in contrast to factors).
</p>
<p>As far as estimation is concerned, we have used in this package the equivalence between P-splines and linear mixed models (Currie and Durban, 2002). Under this approach, the smoothing parameters are expressed as the ratio between variance components. Moreover, the smooth components are decomposed in two parts: one which is not penalised (and treated as fixed) and one with is penalised (and treated as random). For the two-dimensional case, the mixed model representation leads also to a very interesting decomposition of the penalised part of the bivariate surface in three different components (Lee and Durban, 2011): (a) a component that contains the smooth main effect (smooth trend)	along one of the covariates that the surface is a function of (as, e.g, the x-spatial coordinate or column position of the plot in the field), (b) a component that contains the smooth main effect (smooth trend) along the other covariate (i.e., the y-spatial coordinate or row position); and (c) a smooth interaction component (sum of the linear-by-smooth interaction components and the smooth-by-smooth interaction component). 
</p>
<p>The original implementation of SpATS assumes two different smoothing parameters, i.e., one for each covariate in the smooth component. Accordingly, the same smoothing parameters are used for both, the main effects and the smooth interaction. However, this approach can be extended to deal with the ANOVA-type decomposition presented in Lee and Durban (2011). In their approach, four different smoothing parameters are considered for the smooth surface, that are in concordance with the aforementioned decomposition: (a) two smoothing parameter, one for each of the main effects; and (b) two smoothing parameter for the smooth interaction component.
</p>
<p>It should be noted that, the computational burden associated with the estimation of the two-dimensional tensor-product smoother might be prohibitive if the dimension of the marginal bases is large. In these cases, Lee et al. (2013) propose to reduce the computational cost by using nested bases. The idea is to reduce the dimension of the marginal bases (and therefore the associated number of parameters to be estimated), but only for the smooth-by-smooth interaction component. As pointed out by the authors, this simplification can be justified by the fact that the main effects would in fact explain most of the structure (or spatial trend) presented in the data, and so a less rich representation of the smooth-by-smooth interaction component could be needed. In order to ensure that the reduced bivariate surface is in fact nested to the model including only the main effects, Lee et al. (2013) show that the number of segments used for the nested basis should be a divisor of the number of segments used in the original basis (<code>nsegments</code> argument). In the present function, the divisor of the number of segments is specified through the argument <code>nestorder</code>. For a more detailed review on this topic, see Lee (2010) and Lee et al. (2013). The &quot;PSANOVA&quot; approach represents an alternative method. In this case, the smooth bivariate surface (or spatial trend) is decomposed in five different components each of them depending on a single smoothing parameter (see Lee et al., 2013).
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>As mentioned at the beginning, the piece of documentation stated above was taken completely from the SpATS package in order to provide a deeper explanation. In practice, sommec uses some pieces of code from SpATS to build the design matrix containing all the columns from tensor products of the x and y coordinates and it fits such matrix as a single random effect. As a result the same variance component is assumed for the linear, linear by linear, linear by spline, and spline by spline interactions. This results in a less flexible approach than the one proposed by Rodriguez-Alvarez et al. (2018) but still makes a pretty good job to model the spatial variation. Use under your own risk.
</p>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X, Boer, M.P., van Eeuwijk, F.A., and Eilers, P.H.C. (2018). SpATS: Spatial Analysis of Field Trials with Splines. R package version 1.0-9. https://CRAN.R-project.org/package=SpATS.
</p>
<p>Rodriguez-Alvarez, M.X., et al. (2015) Fast smoothng parameter separaton n multdmensonal generalzed P-splnes: the SAP algorthm. Statistics and Computing 25.5: 941-957.
</p>
<p>Lee, D.-J., Durban, M., and Eilers, P.H.C. (2013). Efficient two-dimensional smoothing with P-spline ANOVA mixed models and nested bases. Computational Statistics and Data Analysis, 61, 22 - 37.
</p>
<p>Gilmour, A.R., Cullis, B.R., and Verbyla, A.P. (1997). Accounting for Natural and Extraneous Variation in the Analysis of Field Experiments. Journal of Agricultural, Biological, and Environmental Statistics, 2, 269 - 293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mmec">mmec</a></code>, <code><a href="#topic+spl2Db">spl2Db</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ============================ ##
## example to use spl2Dc() 
## ============================ ## 
data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# A &lt;- A.mat(GT)
# Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
# mix &lt;- mmec(Yield~1,
#             random=~vsc(isc(id), Gu=Ai) +
#               Rowf + Colf +
#               spl2Dc(Row,Col),
#             rcov=~units,
#             data=DT)
# summary(mix)$varcomp
## ============================ ##
## mimic 2 fields
## ============================ ## 
# aa &lt;- DT; bb &lt;- DT
# aa$FIELD &lt;- "A";bb$FIELD &lt;- "B"
# set.seed(1234)
# aa$Yield &lt;- aa$Yield + rnorm(length(aa$Yield),0,4)
# DT2 &lt;- rbind(aa,bb)
# head(DT2)
# mix &lt;- mmec(Yield~1,
#             random=~vsc(dsc(FIELD),isc(id), Gu=Ai) +
#               vsc(dsc(FIELD),isc(Rowf)) +
#               vsc(dsc(FIELD),isc(Colf)) +
#                 spl2Dc(Row,Col,at.var=FIELD),
#             rcov=~vsc(dsc(FIELD),isc(units)),
#             data=DT2)

</code></pre>

<hr>
<h2 id='spl2Dmats'>Get Tensor Product Spline Mixed Model Incidence Matrices</h2><span id='topic+spl2Dmats'></span>

<h3>Description</h3>

<p><code>spl2Dmats</code> gets Tensor-Product P-Spline Mixed Model Incidence Matrices
for use with <code>sommer</code> and its main function <code>mmer</code>. We thank Sue Welham for making the TPSbits package available to the community. If you're using this function for your research please cite her TPSbits package :) this is mostly a wrapper of her tpsmmb function to enable the use in sommer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spl2Dmats(
  x.coord.name,
  y.coord.name,
  data,
  at.name,
  at.levels, 
  nsegments=NULL,
  minbound=NULL,
  maxbound=NULL,
  degree = c(3, 3),
  penaltyord = c(2,2), 
  nestorder = c(1,1),
  method = "Lee"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spl2Dmats_+3A_x.coord.name">x.coord.name</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding column locations.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_y.coord.name">y.coord.name</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding row locations.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_data">data</code></td>
<td>
<p>A dataframe. Holds the dataset to be used for fitting.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_at.name">at.name</code></td>
<td>
<p>name of a variable defining if the 2D spline matrices should be created at different units (e.g., at different environments).</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_at.levels">at.levels</code></td>
<td>
<p>a vector of names indicating which levels of the at.name variable should be used for fitting the 2D spline function.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_nsegments">nsegments</code></td>
<td>
<p>A list of length 2. Number of segments to split column and
row ranges into, respectively (= number of internal knots + 1). If only
one number is specified, that value is used in both dimensions. If not
specified, (number of unique values - 1) is used in each dimension;
for a grid layout (equal spacing) this gives a knot at each data value.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_minbound">minbound</code></td>
<td>
<p>A list of length 2. The lower bound to be used for column
and row dimensions respectively; default calculated as the minimum value
for each dimension.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_maxbound">maxbound</code></td>
<td>
<p>A list of length 2. The upper bound to be used for column
and row dimensions respectively; default calculated as the maximum value
for each dimension.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_degree">degree</code></td>
<td>
<p>A list of length 2. The degree of polynomial spline to be used
for column and row dimensions respectively; default=3.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_penaltyord">penaltyord</code></td>
<td>
<p>A list of length 2. The order of differencing for column
and row dimensions, respectively; default=2.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_nestorder">nestorder</code></td>
<td>
<p>A list of length 2. The order of nesting for column and row
dimensions, respectively; default=1 (no nesting). A value of 2 generates
a spline with half the number of segments in that dimension, etc. The
number of segments in each direction must be a multiple of the order
of nesting.</p>
</td></tr>
<tr><td><code id="spl2Dmats_+3A_method">method</code></td>
<td>
<p>A string. Method for forming the  penalty; default=<code>"Lee"</code>
ie the penalty from Lee, Durban &amp; Eilers (2013, CSDA 61, 22-37). The
alternative method is <code>"Wood"</code> ie. the method from Wood et al (2012,
Stat Comp 23, 341-360).
This option is a research tool and requires further investigation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 7 elements:
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:(diff.c) = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:(diff.r) = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:((diff.c*diff.r)) = interaction between the
two X parts for use in fixed model. The first variate is
a constant term which should be omitted from the model when the constant
(1) is present. If all elements are
included in the model then the constant term should be omitted,
eg. <code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>fR</code> = Xr1:Zc
</p>
</li>
<li> <p><code>fC</code> = Xr2:Zc
</p>
</li>
<li> <p><code>fR.C</code> = Zr:Xc1
</p>
</li>
<li> <p><code>R.fC</code> = Zr:Xc2 
</p>
</li>
<li> <p><code>fR.fC</code> = Zc:Zr
</p>
</li>
<li> <p><code>all</code> = Xr1:Zc | Xr2:Zc | Zr:Xc1 | Zr:Xc2 | Zc:Zr
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
data("DT_cpdata")
DT &lt;- DT_cpdata
GT &lt;- GT_cpdata
MP &lt;- MP_cpdata
#### create the variance-covariance matrix
A &lt;- A.mat(GT) # additive relationship matrix

M &lt;- spl2Dmats(x.coord.name = "Col", y.coord.name = "Row", data=DT, nseg =c(14,21))
head(M$data)
# m1g &lt;- mmer(Yield~1+TP.CR.2+TP.CR.3+TP.CR.4,
#             random=~Rowf+Colf+vsr(M$fC)+vsr(M$fR)+
#               vsr(M$fC.R)+vsr(M$C.fR)+vsr(M$fC.fR)+
#               vsr(id,Gu=A),
#             data=M$data, tolpar = 1e-6,
#             iters=30)
# 
# summary(m1g)$varcomp

</code></pre>

<hr>
<h2 id='stackTrait'>Stacking traits in a dataset</h2><span id='topic+stackTrait'></span>

<h3>Description</h3>

<p><code>stackTrait</code> creates a dataset stacking traits in the long format to be used with the <code><a href="#topic+mmec">mmec</a></code> solver for multi-trait models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stackTrait(data, traits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackTrait_+3A_data">data</code></td>
<td>
<p>a data frame with traits in wide format.</p>
</td></tr>
<tr><td><code id="stackTrait_+3A_traits">traits</code></td>
<td>
<p>variable names corresponding to the traits that should be in the long format.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a data frame with traits in long format.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>stackTrait</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example
head(DT)

DT2 &lt;- stackTrait(DT, traits = c("Yield","Weight"))
head(DT2)

</code></pre>

<hr>
<h2 id='summary.mmec'>summary form a GLMM fitted with mmec</h2><span id='topic+summary.mmec'></span><span id='topic+print.summary.mmec'></span><span id='topic+print.mmec'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"mmec"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mmec_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmec"</code></p>
</td></tr>
<tr><td><code id="summary.mmec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of summary
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+mmec">mmec</a></code></p>

<hr>
<h2 id='summary.mmer'>summary form a GLMM fitted with mmer</h2><span id='topic+summary.mmer'></span><span id='topic+print.summary.mmer'></span><span id='topic+print.mmer'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"mmer"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mmer'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mmer_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mmer"</code></p>
</td></tr>
<tr><td><code id="summary.mmer_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of summary
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>

<hr>
<h2 id='tps'>Get Tensor Product Spline Mixed Model Incidence Matrices</h2><span id='topic+tps'></span>

<h3>Description</h3>

<p><code>tps</code> is a wrapper of tpsmmb function from the TPSbits package to avoid version dependencies but if you're using this function for your research please cite the TPSbits package. This function is internally used by the <code>spl2Dmatrices</code> function to get Tensor-Product P-Spline Mixed Model Bits
(design matrices) for use with <code>sommer</code> and its main function <code>mmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tps(
  columncoordinates,
  rowcoordinates,
  nsegments=NULL,
  minbound=NULL,
  maxbound=NULL,
  degree = c(3, 3),
  penaltyord = c(2, 2),
  nestorder = c(1, 1),
  asreml = "grp",
  eigenvalues = "include",
  method = "Lee",
  stub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tps_+3A_columncoordinates">columncoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding column locations.</p>
</td></tr>
<tr><td><code id="tps_+3A_rowcoordinates">rowcoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding row locations.</p>
</td></tr>
<tr><td><code id="tps_+3A_nsegments">nsegments</code></td>
<td>
<p>A list of length 2. Number of segments to split column and
row ranges into, respectively (= number of internal knots + 1). If only
one number is specified, that value is used in both dimensions. If not
specified, (number of unique values - 1) is used in each dimension;
for a grid layout (equal spacing) this gives a knot at each data value.</p>
</td></tr>
<tr><td><code id="tps_+3A_minbound">minbound</code></td>
<td>
<p>A list of length 2. The lower bound to be used for column
and row dimensions respectively; default calculated as the minimum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tps_+3A_maxbound">maxbound</code></td>
<td>
<p>A list of length 2. The upper bound to be used for column
and row dimensions respectively; default calculated as the maximum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tps_+3A_degree">degree</code></td>
<td>
<p>A list of length 2. The degree of polynomial spline to be used
for column and row dimensions respectively; default=3.</p>
</td></tr>
<tr><td><code id="tps_+3A_penaltyord">penaltyord</code></td>
<td>
<p>A list of length 2. The order of differencing for column
and row dimensions, respectively; default=2.</p>
</td></tr>
<tr><td><code id="tps_+3A_nestorder">nestorder</code></td>
<td>
<p>A list of length 2. The order of nesting for column and row
dimensions, respectively; default=1 (no nesting). A value of 2 generates
a spline with half the number of segments in that dimension, etc. The
number of segments in each direction must be a multiple of the order
of nesting.</p>
</td></tr>
<tr><td><code id="tps_+3A_asreml">asreml</code></td>
<td>
<p>A string. Indicates the types of structures to be generated
for use in asreml models; default <code>"mbf"</code>. The
appropriate eigenvalue scaling is included within the Z matrices unless
setting <code>scaling="none"</code> is used, and then the scaling factors are
supplied separately in the returned object.
</p>

<ul>
<li> <p><code>asreml="mbf"</code> indicates the function should put the
spline design matrices into structures for use with <code>"mbf"</code>;
</p>
</li>
<li> <p><code>asreml="grp"</code> indicates the function should add the
composite spline design matrices (eg. for second-order differencing,
matrices Xr1:Zc, Xr2:Zc, Zr:Xc1, Zr:Xc2 and Zc:Zr) into the data frame
and provide a group list structure for each term;
</p>
</li>
<li> <p><code>asreml="sepgrp"</code> indicates the function should generate the
individual X and Z spline design matrices separately (ie. Xc, Xr, Zc and
Zr), plus the smooth x smooth interaction term as a whole (ie. Zc:Zr),
and provide a group list structure for each term.
</p>
</li>
<li> <p><code>asreml="own"</code> indicates the function should generate the
composite matrix ( Xr:Zc | Zr:Xc | Zc:Zr ) as a single set of columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tps_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>A string. Indicates whether eigenvalues should be
included within the Z design matrices <code>eigenvalues="include"</code>, or
whether this scaling should be omitted (<code>eigenvalues="omit"</code>);
default <code>eigenvalues="include"</code>. If the eigenvalue scaling is
omitted from the Z design matrices, then it should instead be included in
the model as a variance structure to obtain the correct TPspline model.</p>
</td></tr>
<tr><td><code id="tps_+3A_method">method</code></td>
<td>
<p>A string. Method for forming the  penalty; default=<code>"Lee"</code>
ie the penalty from Lee, Durban &amp; Eilers (2013, CSDA 61, 22-37). The
alternative method is <code>"Wood"</code> ie. the method from Wood et al (2012,
Stat Comp 23, 341-360).
This option is a research tool and requires further investigation.</p>
</td></tr>
<tr><td><code id="tps_+3A_stub">stub</code></td>
<td>
<p>A string. Stub to be attached to names in the <code>mbf</code> list to
avoid over-writing structures and general confusion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 7, 8 or 9 (according to the <code>asreml</code> and
<code>eigenvalues</code> parameter settings).
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:(diff.c) = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:(diff.r) = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:((diff.c*diff.r)) = interaction between the
two X parts for use in fixed model. The first variate is
a constant term which should be omitted from the model when the constant
(1) is present. If all elements are
included in the model then the constant term should be omitted,
eg. <code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>mbflist</code> = list that can be used in call to asreml (so long as Z
matrix data frames extracted with right names, eg BcZ&lt;stub&gt;.df)
</p>
</li>
<li> <p><code>BcZ.df</code> = mbf data frame mapping onto smooth part of column
spline, last column (labelled <code>TP.col</code>) gives column index
</p>
</li>
<li> <p><code>BrZ.df</code> = mbf data frame mapping onto smooth part of row spline,
last column (labelled <code>TP.row</code>) gives row index
</p>
</li>
<li> <p><code>BcrZ.df</code> = mbf data frame mapping onto smooth x smooth term, last
column (labelled <code>TP.CxR</code>) maps onto col x row combined index
</p>
</li>
<li> <p><code>dim</code> = list structure, holding dimension values relating to the
model:
</p>

<ol>
<li> <p><code>"diff.c"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbc"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbcn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
<li> <p><code>"diff.r"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbr"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbrn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li></ol>

</li>
<li> <p><code>trace</code> = list of trace values for ZGZ' for the random TPspline
terms, where Z is the design matrix and G
is the known diagonal variance matrix derived from eigenvalues. This can
be used to rescale the spline design matrix (or equivalently variance
components).
</p>
</li>
<li> <p><code>grp</code> = list structure, only added for settings
<code>asreml="grp"</code>,  <code>asreml="sepgrp"</code> or <code>asreml="own"</code>.
For <code>asreml="grp"</code>, provides column indexes for each of the 5
random components of the 2D splines.
For <code>asreml="sepgrp"</code>, provides column indexes for each of the X and
Z component matrices for the 1D splines, plus the composite smooth x
smooth interaction term. For <code>asreml="own"</code>, provides column indexes
for the composite random model.
Dimensions of the components can be derived from the values in the
<code>dim</code> item.  The Z terms are scaled by the associated
eigenvalues when <code>eigenvalues="include"</code>, but not when
<code>eigenvalues="omit"</code>.
</p>
</li>
<li> <p><code>eigen</code> = list structure, only added for option setting
<code>eigenvalues="omit"</code>. Holds the diagonal elements of the inverse
variance matrix for the terms Xc:Zr (called <code>diagr</code>), Zc:Xr
(called <code>diagc</code>) and Zc:Zr (called <code>diagcr</code>).
</p>
</li></ol>


<hr>
<h2 id='tpsmmbwrapper'>Get Tensor Product Spline Mixed Model Incidence Matrices</h2><span id='topic+tpsmmbwrapper'></span>

<h3>Description</h3>

<p><code>tpsmmbwrapper</code> is a wrapper of tpsmmb function from the TPSbits package to avoid version dependencies but if you're using this function for your research please cite the TPSbits package. This function is internally used by the <code>spl2Dmatrices</code> function to get Tensor-Product P-Spline Mixed Model Bits
(design matrices) for use with <code>sommer</code> and its main function <code>mmer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpsmmbwrapper(
  columncoordinates,
  rowcoordinates,
  data,
  nsegments=NULL,
  minbound=NULL,
  maxbound=NULL,
  degree = c(3, 3),
  penaltyord = c(2, 2),
  nestorder = c(1, 1),
  asreml = "mbf",
  eigenvalues = "include",
  method = "Lee",
  stub = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tpsmmbwrapper_+3A_columncoordinates">columncoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding column locations.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_rowcoordinates">rowcoordinates</code></td>
<td>
<p>A string. Gives the name of <code>data</code> element
holding row locations.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_data">data</code></td>
<td>
<p>A dataframe. Holds the dataset to be used for fitting.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_nsegments">nsegments</code></td>
<td>
<p>A list of length 2. Number of segments to split column and
row ranges into, respectively (= number of internal knots + 1). If only
one number is specified, that value is used in both dimensions. If not
specified, (number of unique values - 1) is used in each dimension;
for a grid layout (equal spacing) this gives a knot at each data value.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_minbound">minbound</code></td>
<td>
<p>A list of length 2. The lower bound to be used for column
and row dimensions respectively; default calculated as the minimum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_maxbound">maxbound</code></td>
<td>
<p>A list of length 2. The upper bound to be used for column
and row dimensions respectively; default calculated as the maximum value
for each dimension.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_degree">degree</code></td>
<td>
<p>A list of length 2. The degree of polynomial spline to be used
for column and row dimensions respectively; default=3.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_penaltyord">penaltyord</code></td>
<td>
<p>A list of length 2. The order of differencing for column
and row dimensions, respectively; default=2.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_nestorder">nestorder</code></td>
<td>
<p>A list of length 2. The order of nesting for column and row
dimensions, respectively; default=1 (no nesting). A value of 2 generates
a spline with half the number of segments in that dimension, etc. The
number of segments in each direction must be a multiple of the order
of nesting.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_asreml">asreml</code></td>
<td>
<p>A string. Indicates the types of structures to be generated
for use in asreml models; default <code>"mbf"</code>. The
appropriate eigenvalue scaling is included within the Z matrices unless
setting <code>scaling="none"</code> is used, and then the scaling factors are
supplied separately in the returned object.
</p>

<ul>
<li> <p><code>asreml="mbf"</code> indicates the function should put the
spline design matrices into structures for use with <code>"mbf"</code>;
</p>
</li>
<li> <p><code>asreml="grp"</code> indicates the function should add the
composite spline design matrices (eg. for second-order differencing,
matrices Xr1:Zc, Xr2:Zc, Zr:Xc1, Zr:Xc2 and Zc:Zr) into the data frame
and provide a group list structure for each term;
</p>
</li>
<li> <p><code>asreml="sepgrp"</code> indicates the function should generate the
individual X and Z spline design matrices separately (ie. Xc, Xr, Zc and
Zr), plus the smooth x smooth interaction term as a whole (ie. Zc:Zr),
and provide a group list structure for each term.
</p>
</li>
<li> <p><code>asreml="own"</code> indicates the function should generate the
composite matrix ( Xr:Zc | Zr:Xc | Zc:Zr ) as a single set of columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_eigenvalues">eigenvalues</code></td>
<td>
<p>A string. Indicates whether eigenvalues should be
included within the Z design matrices <code>eigenvalues="include"</code>, or
whether this scaling should be omitted (<code>eigenvalues="omit"</code>);
default <code>eigenvalues="include"</code>. If the eigenvalue scaling is
omitted from the Z design matrices, then it should instead be included in
the model as a variance structure to obtain the correct TPspline model.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_method">method</code></td>
<td>
<p>A string. Method for forming the  penalty; default=<code>"Lee"</code>
ie the penalty from Lee, Durban &amp; Eilers (2013, CSDA 61, 22-37). The
alternative method is <code>"Wood"</code> ie. the method from Wood et al (2012,
Stat Comp 23, 341-360).
This option is a research tool and requires further investigation.</p>
</td></tr>
<tr><td><code id="tpsmmbwrapper_+3A_stub">stub</code></td>
<td>
<p>A string. Stub to be attached to names in the <code>mbf</code> list to
avoid over-writing structures and general confusion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 7, 8 or 9 (according to the <code>asreml</code> and
<code>eigenvalues</code> parameter settings).
</p>

<ol>
<li> <p><code>data</code> = the input data frame augmented with structures required
to fit tensor product splines in <code>asreml-R</code>. This data frame can be used
to fit the TPS model.
</p>
<p>Added columns:
</p>

<ul>
<li> <p><code>TP.col</code>, <code>TP.row</code> = column and row coordinates
</p>
</li>
<li> <p><code>TP.CxR</code> = combined index for use with smooth x smooth term
</p>
</li>
<li> <p><code>TP.C.n</code> for n=1:(diff.c) = X parts of column spline for use
in random model (where diff.c is the order of column differencing)
</p>
</li>
<li> <p><code>TP.R.n</code> for n=1:(diff.r) = X parts of row spline for use in
random model (where diff.r is the order of row differencing)
</p>
</li>
<li> <p><code>TP.CR.n</code> for n=1:((diff.c*diff.r)) = interaction between the
two X parts for use in fixed model. The first variate is
a constant term which should be omitted from the model when the constant
(1) is present. If all elements are
included in the model then the constant term should be omitted,
eg. <code>y ~ -1 + TP.CR.1 + TP.CR.2 + TP.CR.3 + TP.CR.4 + other terms...</code>
</p>
</li>
<li><p> when <code>asreml="grp"</code> or <code>"sepgrp"</code>, the spline basis
functions are also added into the data frame. Column numbers for each
term are given in the <code>grp</code> list structure.
</p>
</li></ul>

</li>
<li> <p><code>mbflist</code> = list that can be used in call to asreml (so long as Z
matrix data frames extracted with right names, eg BcZ&lt;stub&gt;.df)
</p>
</li>
<li> <p><code>BcZ.df</code> = mbf data frame mapping onto smooth part of column
spline, last column (labelled <code>TP.col</code>) gives column index
</p>
</li>
<li> <p><code>BrZ.df</code> = mbf data frame mapping onto smooth part of row spline,
last column (labelled <code>TP.row</code>) gives row index
</p>
</li>
<li> <p><code>BcrZ.df</code> = mbf data frame mapping onto smooth x smooth term, last
column (labelled <code>TP.CxR</code>) maps onto col x row combined index
</p>
</li>
<li> <p><code>dim</code> = list structure, holding dimension values relating to the
model:
</p>

<ol>
<li> <p><code>"diff.c"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbc"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbcn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li>
<li> <p><code>"diff.r"</code> = order of differencing used in column dimension
</p>
</li>
<li> <p><code>"nbr"</code> = number of random basis functions in column dimension
</p>
</li>
<li> <p><code>"nbrn"</code> = number of nested random basis functions in column dimension
used in smooth x smooth term
</p>
</li></ol>

</li>
<li> <p><code>trace</code> = list of trace values for ZGZ' for the random TPspline
terms, where Z is the design matrix and G
is the known diagonal variance matrix derived from eigenvalues. This can
be used to rescale the spline design matrix (or equivalently variance
components).
</p>
</li>
<li> <p><code>grp</code> = list structure, only added for settings
<code>asreml="grp"</code>,  <code>asreml="sepgrp"</code> or <code>asreml="own"</code>.
For <code>asreml="grp"</code>, provides column indexes for each of the 5
random components of the 2D splines.
For <code>asreml="sepgrp"</code>, provides column indexes for each of the X and
Z component matrices for the 1D splines, plus the composite smooth x
smooth interaction term. For <code>asreml="own"</code>, provides column indexes
for the composite random model.
Dimensions of the components can be derived from the values in the
<code>dim</code> item.  The Z terms are scaled by the associated
eigenvalues when <code>eigenvalues="include"</code>, but not when
<code>eigenvalues="omit"</code>.
</p>
</li>
<li> <p><code>eigen</code> = list structure, only added for option setting
<code>eigenvalues="omit"</code>. Holds the diagonal elements of the inverse
variance matrix for the terms Xc:Zr (called <code>diagr</code>), Zc:Xr
(called <code>diagc</code>) and Zc:Zr (called <code>diagcr</code>).
</p>
</li></ol>


<hr>
<h2 id='transformConstraints'>transformConstraints</h2><span id='topic+transformConstraints'></span>

<h3>Description</h3>

<p><code>transformConstraints</code> takes a list of matrices with constraints and transforms all the non-zero values to the value desired. The purpose of this function is to make easy the transformation of initial constraints to a fixed-constraint list to be provided to a mixed model fitted with the mmer function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transformConstraints(list0,value=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transformConstraints_+3A_list0">list0</code></td>
<td>
<p>a list of matrices with constraints according to the rules specified in the vsr function (0: not to be estimated, 1: positive, 2:unconstrained, 3:fixed).</p>
</td></tr>
<tr><td><code id="transformConstraints_+3A_value">value</code></td>
<td>
<p>value to be used to replace all the non-zero values in the constraint matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the modified constraint matrices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>transformConstraints</code> in the <code><a href="#topic+mmer">mmer</a></code> solver. </p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- list(unsm(4), diag(4)))
transformConstraints(a, value=3)
</code></pre>

<hr>
<h2 id='transp'>Creating color with transparency</h2><span id='topic+transp'></span>

<h3>Description</h3>

<p>This function takes a color and returns the same with a certain alpha grade transparency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transp(col, alpha=0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transp_+3A_col">col</code></td>
<td>
<p>Color to be used for transparency</p>
</td></tr>
<tr><td><code id="transp_+3A_alpha">alpha</code></td>
<td>
<p>Grade of transparency desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No major details.
</p>


<h3>Value</h3>

<p>If arguments are correctly specified the function returns:
</p>

<dl>
<dt>$res</dt><dd><p> A new color with certain grade of transparency</p>
</dd>
</dl>



<h3>References</h3>

<p>Robert J. Henry. 2013. Molecular Markers in Plants. Wiley-Blackwell. ISBN 978-0-470-95951-0.
</p>
<p>Ben Hui Liu. 1998. Statistical Genomics. CRC Press LLC. ISBN 0-8493-3166-8.
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+mmer">mmer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>transp("red", alpha=0.5)
</code></pre>

<hr>
<h2 id='unsm'>unstructured indication matrix</h2><span id='topic+unsm'></span>

<h3>Description</h3>

<p><code>unsm</code> creates a square matrix with ones in the diagonals and 2's in the off-diagonals to quickly specify an unstructured constraint in the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  unsm(x, reps=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unsm_+3A_x">x</code></td>
<td>
<p>integer specifying the number of traits to be fitted for a given random effect.</p>
</td></tr>
<tr><td><code id="unsm_+3A_reps">reps</code></td>
<td>
<p>integer specifying the number of times the matrix should be repeated in a list format to provide easily the constraints in complex models that use the ds(), us() or cs() structures.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a matrix or a list of matrices with the constraints to be provided in the Gtc argument of the <code><a href="#topic+vsr">vsr</a></code> function.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>unsm</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>unsm(3)
unsm(3,2)
</code></pre>

<hr>
<h2 id='usc'>unstructured covariance structure</h2><span id='topic+usc'></span>

<h3>Description</h3>

<p><code>usc</code> creates an unstructured covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmec">mmec</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  usc(x, thetaC, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usc_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
<tr><td><code id="usc_+3A_thetac">thetaC</code></td>
<td>
<p>an optional symmetric matrix for constraints in the variance-covariance components. The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define how the variance-covariance components should be estimated:
</p>
<p>0: component will not be estimated
</p>
<p>1: component will be estimated and constrained to be positive
</p>
<p>2: component will be estimated and unconstrained
</p>
<p>3: component will be fixed to the value provided in the theta argument
</p>
</td></tr>
<tr><td><code id="usc_+3A_theta">theta</code></td>
<td>
<p>an optional symmetric matrix for initial values of the variance-covariance components. When providing customized values, these values should be scaled with respect to the original variance. For example, to provide an initial value of 1 to a given variance component, theta would be built as:
</p>
<p>theta = matrix( 1 / var(response) )
</p>
<p>The symmetric matrix should have as many rows and columns as the number of levels in the factor 'x'. The values in the matrix define the initial values of the variance-covariance components that will be subject to the constraints provided in thetaC. If not provided, initial values will be calculated as:
</p>
<p>diag(ncol(mm))*.05 + matrix(.1,ncol(mm),ncol(mm))
</p>
<p>where mm is the incidence matrix for the factor 'x'.
</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsc">vsc</a></code> to know how to use <code>usc</code> in the <code><a href="#topic+mmec">mmec</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
usc(x)
## how to use the theta and thetaC arguments:
# data(DT_example)
# DT &lt;- DT_example
# theta &lt;- matrix(9:1,3,3); 
# theta[lower.tri(theta)] &lt;- t(theta)[lower.tri(theta)] 
# theta # initial VCs
# thetaC &lt;- fixm(3); thetaC # fixed VCs
# ans1 &lt;- mmec(Yield~Env,
#              random= ~ vsc( usc(Env,theta = theta,thetaC = thetaC),isc(Name) ),
#              rcov= ~ units, nIters = 1,
#              data=DT)
# summary(ans1)$varcomp

</code></pre>

<hr>
<h2 id='usr'>unstructured covariance structure</h2><span id='topic+usr'></span>

<h3>Description</h3>

<p><code>usr</code> creates an unstructured covariance structure for specific levels of the random effect to be used with the <code><a href="#topic+mmer">mmer</a></code> solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  usr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usr_+3A_x">x</code></td>
<td>
<p>vector of observations for the random effect.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p> a list with the provided vector and the variance covariance structure expected for the levels of the random effect.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+vsr">vsr</a></code> to know how to use <code>usr</code> in the <code><a href="#topic+mmer">mmer</a></code> solver.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.factor(c(1:5,1:5,1:5));x
usr(x)
</code></pre>

<hr>
<h2 id='vpredict'>vpredict form of a LMM fitted with mmer</h2><span id='topic+vpredict'></span><span id='topic+vpredict.mmer'></span>

<h3>Description</h3>

<p><code>vpredict</code> method for class <code>"mmer"</code>.
</p>
<p>Post-analysis procedure to calculate linear combinations of variance components. Its intended use is when the variance components are either simple variances or are variances and covariances in an unstructured matrix. The functions covered are linear combinations of the variance components (for example, phenotypic variance), a ratio of two components (for example, heritabilities) and the correlation based on three components (for example, genetic correlation). 
</p>
<p>The calculations are based on the estimated variance parameters and their variance matrix as represented by the inverse of the Fisher or Average information matrix. Note that this matrix has zero values for fixed variance parameters including those near the parameter space boundary.
</p>
<p>The transform is specified with a formula. On the left side of the formula is a name for the transformation. On the right side of the formula is a transformation specified with shortcut names like 'V1', 'V2', etc.  The easiest way to identify these shortcut names is to use 'summary(object)$varcomp'. The rows of this object can referred to with shortcuts 'V1', 'V2', etc.  See the example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
vpredict(object, transform)
## S3 method for class 'mmer'
vpredict(object, transform)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vpredict_+3A_object">object</code></td>
<td>
<p>a model fitted with the mmer function.</p>
</td></tr>
<tr><td><code id="vpredict_+3A_transform">transform</code></td>
<td>
<p>a formula to calculate the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method (e.g., Lynch and Walsh 1998, Appendix 1; Ver Hoef 2012) uses
a Taylor series expansion to approximate the moments of a function of
parameters. Here, a second-order Taylor series expansion is implemented to
approximate the standard error for a function of (co)variance parameters.
Partial first derivatives of the function are calculated by algorithmic
differentiation with <code><a href="stats.html#topic+deriv">deriv</a></code>.
</p>
<p>Though <code>vpredict</code> can calculate standard errors for non-linear functions
of (co)variance parameters from a fitted <code>mmer</code> model, it is limited
to non-linear functions constructed by mathematical operations such as the
arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>^</code>,
and single-variable functions such as  <code>exp</code> and <code>log</code>. See 
<code><a href="stats.html#topic+deriv">deriv</a></code> for more information.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dd</code></td>
<td>
<p>the parameter and its standard error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Lynch, M. and B. Walsh 1998. Genetics and Analysis of Quantitative Traits. Sinauer Associates, Inc., Sunderland, MA, USA.
</p>
<p>Ver Hoef, J.M. 2012. Who invented the delta method? The American Statistician 66:124-127. DOI: 10.1080/00031305.2012.687494
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vpredict">vpredict</a></code>, <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
####=========================================####
####=========================================####
#### EXAMPLE 1
#### simple example with univariate models
####=========================================####
####=========================================####
# data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix 
# A &lt;- A.mat(GT)
# #### look at the data and fit the model
# head(DT)
# mix1 &lt;- mmer(Yield~1,
#               random=~vsr(id,Gu=A), 
#               data=DT)
# summary(mix1)$varcomp
# #### run the vpredict function
# vpredict(mix1, h2 ~ V1 / ( V1 + V2 ) )
# 
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 2
# #### simple example with multivariate models
# ####=========================================####
# ####=========================================####
# data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# #### create the variance-covariance matrix 
# A &lt;- A.mat(GT)
# #### look at the data and fit the model
# head(DT)
# mix2 &lt;- mmer(cbind(Yield,color)~1,
#                random=~vsr(id,Gu=A, Gt=unsm(2)), 
#                rcov=~vsr(units, Gt=unsm(2)),
#               data=DT)
# summary(mix2)$varcomp
# ## genetic correlation
# vpredict(mix2, gen.cor ~ V2 / sqrt(V1*V3))
# 
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 3
# #### more complex multivariate model
# ####=========================================####
# ####=========================================####
# data(DT_btdata)
# DT &lt;- DT_btdata
# mix3 &lt;- mmer(cbind(tarsus, back) ~ sex,
#                random = ~ vsr(dam, Gtc=unsm(2)) + vsr(fosternest,Gtc=diag(2)),
#                rcov=~vsr(units,Gtc=unsm(2)),
#                data = DT)
# summary(mix3)$varcomp
# #### calculate the genetic correlation
# vpredict(mix3, gen.cor ~ V2 / sqrt(V1*V3))
# 
# ####=========================================####
# ####=========================================####
# #### EXAMPLE 4
# #### going back to simple examples
# ####=========================================####
# ####=========================================####
# data(DT_btdata)
# DT &lt;- DT_btdata
# mix4 &lt;- mmer(tarsus ~ sex, random = ~ dam + fosternest,
#                data = DT) 
# summary(mix4)$varcomp
# #### calculate the ratio and its SE
# vpredict(mix4, dam.prop ~ V1 / ( V1 + V2 + V3 ) )


</code></pre>

<hr>
<h2 id='vs'>variance structure specification</h2><span id='topic+vs'></span>

<h3>Description</h3>

<p><code>vs</code> is the main function to build the variance-covariance structure for the random effects to be fitted in the <code><a href="#topic+mmer">mmer</a></code> solver. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vs(..., Gu=NULL, Gti=NULL, Gtc=NULL, reorderGu=TRUE, buildGu=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vs_+3A_...">...</code></td>
<td>
<p>variance structure to be specified following the logic desired in the internal kronecker product. For example, if user wants to define a diagonal variance structure for the random effect 'genotypes'(g) with respect to a random effect 'environments'(e), this is:
</p>
<p><code>var(g) = G.e @ I.g</code>
</p>
<p>being <code>G.e</code>  a matrix containing the variance covariance components for g (genotypes) in each level of e (environments), <code>I.g</code> is the covariance among levels of g (genotypes; i.e. relationship matrix), and @ is the kronecker product. This would be specified in the mmer solver as:
</p>
<p><code>random=~vs(dsr(e),g)</code>
</p>
<p>One strength of sommer is the ability to specify very complex structures with as many kronecker products as desired. For example:
</p>
<p><code>var(g) = G.e @ G.f @ G.h @ I.g</code>
</p>
<p>is equivalent to
</p>
<p><code>random=~vs(e,f,h,g)</code>
</p>
<p>where different covariance structures can be applied to the levels of <code>e,f,h</code> (i.e. <code><a href="#topic+dsr">dsr</a></code>, <code><a href="#topic+usr">usr</a></code>, <code><a href="#topic+csr">csr</a></code>, <code><a href="#topic+atr">atr</a></code> or a combination of these). For more examples please see the vignettes 'sommer.start' available in the package.</p>
</td></tr>
<tr><td><code id="vs_+3A_gu">Gu</code></td>
<td>
<p>matrix with the known variance-covariance values for the levels of the u.th random effect (i.e. relationship matrix among individuals or any other known covariance matrix). If <code>NULL</code>, then an identity matrix is assumed. The Gu matrix can have more levels than the ones present in the random effect linked to it but not the other way around. Otherwise, an error message of missing level in Gu will be returned.</p>
</td></tr>
<tr><td><code id="vs_+3A_gti">Gti</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) with initial values of the variance-covariance components for the random effect specified in the .... argument. If <code>NULL</code> the program will provide the initial values. The values need to be scaled, see Details section.</p>
</td></tr>
<tr><td><code id="vs_+3A_gtc">Gtc</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) of constraints for the variance-covariance components for the random effect specified in the ... argument according to the following rules:
</p>
<p><code>0: not to be estimated</code>
</p>
<p><code>1: estimated and constrained to be positive (i.e. variance component)</code>
</p>
<p><code>2: estimated and unconstrained (can be negative or positive, i.e. covariance component)</code>
</p>
<p><code>3: not to be estimated but fixed (value has to be provided in the Gti argument)</code>
</p>
<p>In the multi-response scenario if the user doesn't specify this argument the default is to build an unstructured matrix (using the <code><a href="#topic+unsm">unsm</a></code>() function). This argument needs to be used wisely since some covariance among responses may not make sense. Useful functions to specify constraints are; <code><a href="base.html#topic+diag">diag</a></code>(), <code><a href="#topic+unsm">unsm</a></code>(), <code><a href="#topic+fixm">fixm</a></code>().
</p>
</td></tr>
<tr><td><code id="vs_+3A_reordergu">reorderGu</code></td>
<td>
<p>a <code>TRUE/FALSE</code> statement if the Gu matrix should be reordered based on the names of the design matrix of the random effect or passed with the custom order of the user. This may be important when fitting covariance components in a customized fashion. Only for advanced users.</p>
</td></tr>
<tr><td><code id="vs_+3A_buildgu">buildGu</code></td>
<td>
<p>a <code>TRUE/FALSE</code> statement to indicate if the Gu matrix should be built in R when the value for the argument <code>Gu=NULL</code>. Repeat, only when when the value for the argument <code>Gu</code> is equal to <code>NULL</code>. In some cases when the incidence matrix is wide (e.g. rrBLUP models) the covariance structure is a huge p x p matrix that can be avoided when performing matrix operations. By setting this argument to <code>FALSE</code> it allows to skip forming this covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When providing initial values in the <code>Gti</code> argument the user has to provide scaled variance component values. The user can provide values from a previous model by accessing the <code>sigma_scaled</code> output from an <code>mmer</code> model or if an specific value is desired the user can obtain the scaled value as:
</p>
<p><code>m = x/var(y)</code>
</p>
<p>where <code>x</code> is the desired initial value and <code>y</code> is the response variable. You can find an example in the <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a list with all neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures to be estimated and constraints) to be used in the mmer solver.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Covarrubias-Pazaran G (2018) Software update: Moving the R package sommer to
multivariate mixed models for genome-assisted prediction. doi:
https://doi.org/10.1101/354639
</p>


<h3>See Also</h3>

<p>The core function of the package: <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Please use the function vsr() for mmer() and vsc() for mmec.

</code></pre>

<hr>
<h2 id='vsc'>variance structure specification</h2><span id='topic+vsc'></span>

<h3>Description</h3>

<p><code>vsc</code> is the main function to build the variance-covariance structure for the random effects to be fitted in the <code><a href="#topic+mmec">mmec</a></code> solver. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vsc(..., Gu=NULL, buildGu=TRUE, meN=1, meTheta=NULL, meThetaC=NULL, 
      sp=FALSE, isFixed=FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vsc_+3A_...">...</code></td>
<td>
<p>variance structure to be specified following the logic desired in the internal kronecker product. For example, if user wants to define a diagonal variance structure for the random effect 'genotypes'(g) with respect to a random effect 'environments'(e), this is:
</p>
<p><code>var(g) = G.e @ I.g</code>
</p>
<p>being <code>G.e</code>  a matrix containing the variance covariance components for g (genotypes) in each level of e (environments), <code>I.g</code> is the covariance among levels of g (genotypes; i.e. relationship matrix), and @ is the kronecker product. This would be specified in the mmec solver as:
</p>
<p><code>random=~vsc(dsc(e),g)</code>
</p>
<p>One strength of sommer is the ability to specify very complex structures with as many kronecker products as desired. For example:
</p>
<p><code>var(g) = G.e @ G.f @ G.h @ I.g</code>
</p>
<p>is equivalent to
</p>
<p><code>random=~vsc(e,f,h,g)</code>
</p>
<p>where different covariance structures can be applied to the levels of <code>e,f,h</code> (i.e. <code><a href="#topic+dsc">dsc</a></code>, <code><a href="#topic+usc">usc</a></code>, <code><a href="#topic+csc">csc</a></code>, <code><a href="#topic+atr">atr</a></code> or a combination of these). For more examples please see the vignettes 'sommer.start' available in the package.</p>
</td></tr>
<tr><td><code id="vsc_+3A_gu">Gu</code></td>
<td>
<p>matrix with the inverse of a known variance-covariance values for the levels of the u.th random effect (e.g., the inverse of a relationship matrix among individuals or any other known inverse covariance matrix). If <code>NULL</code>, then an identity matrix is assumed. The Gu matrix can have more levels than the ones present in the random effect linked to it but not the other way around. Otherwise, an error message of missing level in Gu will be returned.</p>
</td></tr>
<tr><td><code id="vsc_+3A_buildgu">buildGu</code></td>
<td>
<p>a <code>TRUE/FALSE</code> statement to indicate if the Gu matrix should be built in R when the value for the argument <code>Gu=NULL</code>. Repeat, only when when the value for the argument <code>Gu</code> is equal to <code>NULL</code>. In some cases when the incidence matrix is wide (e.g. rrBLUP models) the covariance structure is a huge p x p matrix that can be avoided when performing matrix operations. By setting this argument to <code>FALSE</code> it allows to skip forming this covariance matrix.</p>
</td></tr>
<tr><td><code id="vsc_+3A_men">meN</code></td>
<td>
<p>number of main effects in the variance structure. Is always counted from last to first.</p>
</td></tr>
<tr><td><code id="vsc_+3A_metheta">meTheta</code></td>
<td>
<p>variance covariance matrix between the main effects desired. Just to be modified if the number of main effects is greater of 1 (e.g., indirect genetic effects).</p>
</td></tr>
<tr><td><code id="vsc_+3A_methetac">meThetaC</code></td>
<td>
<p>constraints for the variance covariance matrix between the main effects desired. Just to be modified if the number of main effects is greater of 1 (e.g., indirect genetic effects).</p>
</td></tr>
<tr><td><code id="vsc_+3A_sp">sp</code></td>
<td>
<p>a TRUE/FALSE statement to indicate if the VC from this structure should be multiplied by the scale parameter added in the mmec function through the addScaleParam argument in the <code>mmec</code> function .</p>
</td></tr>
<tr><td><code id="vsc_+3A_isfixed">isFixed</code></td>
<td>
<p>a TRUE/FALSE statement to indicate if the vsc function is being used in the fixed part of the model. When TRUE, the function only returns the model matrix to avoid any error messages associated to returning all elements for a random effect. FALSE is the default since it is assumed to be used for a variance structure in a random effect.</p>
</td></tr>
<tr><td><code id="vsc_+3A_verbose">verbose</code></td>
<td>
<p>a TRUE/FALSE statement to indicate if messages should be printed when special situations accur. For example, adding unphenotyped individuals to the incidence matrices when present in the relationship  matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>...
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a list with all neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures to be estimated and constraints) to be used in the mmec solver.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744
</p>
<p>Covarrubias-Pazaran G (2018) Software update: Moving the R package sommer to
multivariate mixed models for genome-assisted prediction. doi:
https://doi.org/10.1101/354639
</p>


<h3>See Also</h3>

<p>The core function of the package: <code><a href="#topic+mmec">mmec</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
DT=DT[with(DT, order(Env)), ]
A &lt;- A_example

x &lt;- as.character(unique(DT$Name))
DT &lt;- droplevels(DT[which(!is.na(match(DT$Name, x[1:5]))),])
## ============================ ##
## example without structure
## ============================ ##
isc(DT$Name)
mix &lt;- mmec(Yield~Env,
            random= ~ vsc(isc(Name)),
            rcov=~ units,
            nIters=3,
            data=DT)

## ============================ ##
## example to without structure but
## using covariance among levels in the
## random effect Name
## ============================ ##
Ai &lt;- as(solve(A + diag(1e-4,ncol(A),ncol(A))), Class="dgCMatrix")
mix &lt;- mmec(Yield~Env,
            random= ~ vsc(isc(Name), Gu=Ai),
            rcov=~ units,
            nIters=3,
            data=DT)
summary(mix)$varcomp
## ============================ ##
## example to use dsc() structure (DIAGONAL)
## ============================ ##
dsc(DT$Year)
mix &lt;- mmec(Yield~Env,
            random= ~ vsc(dsc(Year),isc(Name)),
            rcov=~ vsc(dsc(Year),isc(units)),
            nIters=3,
            data=DT)
summary(mix)$varcomp
## ============================ ##
## example to use atc() structure (level-specific)
## ============================ ##
# unique(DT$Year)
# mix &lt;- mmec(Yield~Env,
#             random= ~ vsc(atc(Year,c("2011","2012")),isc(Name)),
#             rcov=~ vsc(dsc(Year),isc(units)),
#             data=DT)
## ============================ ##
## example to use usc() structure (UNSTRUCTURED)
## ============================ ##
usc(DT$Year)
mix &lt;- mmec(Yield~Env,
            random= ~ vsc(usc(Year),isc(Name)),
            rcov=~ vsc(dsc(Year),isc(units)),
            nIters = 3,
            data=DT)
## ============================ ##
## example using structure in fixed effect
## (notice the isFixed argument)
## ============================ ##
mix &lt;- mmec(Yield~ vsc(atc(Env,"CA.2011"), isc(Name), isFixed = TRUE),
            rcov=~ units,
            nIters=3,
            data=DT)

</code></pre>

<hr>
<h2 id='vsr'>variance structure specification</h2><span id='topic+vsr'></span>

<h3>Description</h3>

<p><code>vsr</code> is the main function to build the variance-covariance structure for the random effects to be fitted in the <code><a href="#topic+mmer">mmer</a></code> solver. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vsr(..., Gu=NULL, Gti=NULL, Gtc=NULL, reorderGu=TRUE, buildGu=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vsr_+3A_...">...</code></td>
<td>
<p>variance structure to be specified following the logic desired in the internal kronecker product. For example, if user wants to define a diagonal variance structure for the random effect 'genotypes'(g) with respect to a random effect 'environments'(e), this is:
</p>
<p><code>var(g) = G.e @ I.g</code>
</p>
<p>being <code>G.e</code>  a matrix containing the variance covariance components for g (genotypes) in each level of e (environments), <code>I.g</code> is the covariance among levels of g (genotypes; i.e. relationship matrix), and @ is the kronecker product. This would be specified in the mmer solver as:
</p>
<p><code>random=~vsr(dsr(e),g)</code>
</p>
<p>One strength of sommer is the ability to specify very complex structures with as many kronecker products as desired. For example:
</p>
<p><code>var(g) = G.e @ G.f @ G.h @ I.g</code>
</p>
<p>is equivalent to
</p>
<p><code>random=~vsr(e,f,h,g)</code>
</p>
<p>where different covariance structures can be applied to the levels of <code>e,f,h</code> (i.e. <code><a href="#topic+dsr">dsr</a></code>, <code><a href="#topic+usr">usr</a></code>, <code><a href="#topic+csr">csr</a></code>, <code><a href="#topic+atr">atr</a></code> or a combination of these). For more examples please see the vignettes 'sommer.start' available in the package.</p>
</td></tr>
<tr><td><code id="vsr_+3A_gu">Gu</code></td>
<td>
<p>matrix with the known variance-covariance values for the levels of the u.th random effect (i.e. relationship matrix among individuals or any other known covariance matrix). If <code>NULL</code>, then an identity matrix is assumed. The Gu matrix can have more levels than the ones present in the random effect linked to it but not the other way around. Otherwise, an error message of missing level in Gu will be returned.</p>
</td></tr>
<tr><td><code id="vsr_+3A_gti">Gti</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) with initial values of the variance-covariance components for the random effect specified in the .... argument. If <code>NULL</code> the program will provide the initial values. The values need to be scaled, see Details section.</p>
</td></tr>
<tr><td><code id="vsr_+3A_gtc">Gtc</code></td>
<td>
<p>matrix with dimensions t x t (t equal to number of traits) of constraints for the variance-covariance components for the random effect specified in the ... argument according to the following rules:
</p>
<p><code>0: not to be estimated</code>
</p>
<p><code>1: estimated and constrained to be positive (i.e. variance component)</code>
</p>
<p><code>2: estimated and unconstrained (can be negative or positive, i.e. covariance component)</code>
</p>
<p><code>3: not to be estimated but fixed (value has to be provided in the Gti argument)</code>
</p>
<p>In the multi-response scenario if the user doesn't specify this argument the default is to build an unstructured matrix (using the <code><a href="#topic+unsm">unsm</a></code>() function). This argument needs to be used wisely since some covariance among responses may not make sense. Useful functions to specify constraints are; <code><a href="base.html#topic+diag">diag</a></code>(), <code><a href="#topic+unsm">unsm</a></code>(), <code><a href="#topic+fixm">fixm</a></code>().
</p>
</td></tr>
<tr><td><code id="vsr_+3A_reordergu">reorderGu</code></td>
<td>
<p>a <code>TRUE/FALSE</code> statement if the Gu matrix should be reordered based on the names of the design matrix of the random effect or passed with the custom order of the user. This may be important when fitting covariance components in a customized fashion. Only for advanced users.</p>
</td></tr>
<tr><td><code id="vsr_+3A_buildgu">buildGu</code></td>
<td>
<p>a <code>TRUE/FALSE</code> statement to indicate if the Gu matrix should be built in R when the value for the argument <code>Gu=NULL</code>. Repeat, only when when the value for the argument <code>Gu</code> is equal to <code>NULL</code>. In some cases when the incidence matrix is wide (e.g. rrBLUP models) the covariance structure is a huge p x p matrix that can be avoided when performing matrix operations. By setting this argument to <code>FALSE</code> it allows to skip forming this covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When providing initial values in the <code>Gti</code> argument the user has to provide scaled variance component values. The user can provide values from a previous model by accessing the <code>sigma_scaled</code> output from an <code>mmer</code> model or if an specific value is desired the user can obtain the scaled value as:
</p>
<p><code>m = x/var(y)</code>
</p>
<p>where <code>x</code> is the desired initial value and <code>y</code> is the response variable. You can find an example in the <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a list with all neccesary elements (incidence matrices, known var-cov structures, unknown covariance structures to be estimated and constraints) to be used in the mmer solver.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package sommer. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>
<p>Covarrubias-Pazaran G (2018) Software update: Moving the R package sommer to
multivariate mixed models for genome-assisted prediction. doi:
https://doi.org/10.1101/354639
</p>


<h3>See Also</h3>

<p>The core function of the package: <code><a href="#topic+mmer">mmer</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_example)
DT &lt;- DT_example
A &lt;- A_example

## ============================ ##
## example to without structure
## ============================ ##
dsr(DT$Year)
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(Name),
            rcov=~ vsr(units),
            data=DT)
            
## ============================ ##
## example to without structure but 
## using covariance among levels in the
## random effect Name
## ============================ ##
dsr(DT$Year)
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(Name, Gu=A),
            rcov=~ vsr(units),
            data=DT)
            
## ============================ ##
## example to use dsr() structure (DIAGONAL)
## ============================ ##
dsr(DT$Year)
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(dsr(Year),Name),
            rcov=~ vsr(dsr(Year),units),
            data=DT)

## ============================ ##
## example to use atr() structure (level-specific)
## ============================ ##
unique(DT$Year)
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(atr(Year,c("2011","2012")),Name),
            rcov=~ vsr(dsr(Year),units),
            data=DT)

## ============================ ##
## example to use usr() structure (UNSTRUCTURED)
## ============================ ##
usr(DT$Year)
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(usr(Year),Name),
            rcov=~ vsr(dsr(Year),units),
            data=DT)

## ============================ ##
## example to use csr() structure (CUSTOMIZED)
## ============================ ##
unique(DT$Year)
mm &lt;- matrix(1,3,3); mm[1,3] &lt;- mm[3,1] &lt;- 0;mm #don't estimate cov 2011-2013
mix &lt;- mmer(Yield~Env, 
            random= ~ vsr(csr(Year,mm),Name),
            rcov=~ vsr(dsr(Year),units),
            data=DT)

## ============================ ##
## example to use overlay() + vsr() structure
## ============================ ##
data("DT_halfdiallel")
DT &lt;- DT_halfdiallel
head(DT)
DT$femalef &lt;- as.factor(DT$female)
DT$malef &lt;- as.factor(DT$male)
DT$genof &lt;- as.factor(DT$geno)
A &lt;- diag(7); colnames(A) &lt;- rownames(A) &lt;- 1:7;A # if you want to provide a covariance matrix
#### model using overlay
modh &lt;- mmer(sugar~1, 
             random=~vsr(overlay(femalef,malef,sparse=FALSE), Gu=A) 
                     + genof,
              data=DT)

## ============================ ##
## example to use vsr() + dsr() + spl2D() structure
## ============================ ##            
# ### mimic two fields
# data(DT_cpdata)
# DT &lt;- DT_cpdata
# GT &lt;- GT_cpdata
# MP &lt;- MP_cpdata
# aa &lt;- DT; bb &lt;- DT
# aa$FIELD &lt;- "A";bb$FIELD &lt;- "B"
# set.seed(1234)
# aa$Yield &lt;- aa$Yield + rnorm(length(aa$Yield),0,4)
# DT2 &lt;- rbind(aa,bb)
# head(DT2)
# 
# mix &lt;- mmer(Yield~1,
#             random=~vsr(dsr(FIELD),id, Gu=A) + 
#               vsr(dsr(FIELD),Rowf) +
#               vsr(dsr(FIELD),Colf) +
#                 vsr(dsr(FIELD),spl2D(Row,Col)),
#             rcov=~vsr(dsr(FIELD),units),
#             data=DT2)

</code></pre>

<hr>
<h2 id='wald.test'>Wald Test for Model Coefficients</h2><span id='topic+wald.test'></span><span id='topic+print.wald.test'></span>

<h3>Description</h3>

<p>Computes a Wald <code class="reqn">\chi^2</code> test for 1 or more coefficients, given their variance-covariance matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wald.test(Sigma, b, Terms = NULL, L = NULL, H0 = NULL,  
            df = NULL, verbose = FALSE)
  ## S3 method for class 'wald.test'
print(x, digits = 2, ...)
  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wald.test_+3A_sigma">Sigma</code></td>
<td>

<p>A var-cov matrix, usually extracted from one of the fitting functions (e.g., <code>lm</code>, <code>glm</code>, ...).
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_b">b</code></td>
<td>

<p>A vector of coefficients with var-cov matrix <code>Sigma</code>. These coefficients are usually extracted from 
one of the fitting functions available in <span class="rlang"><b>R</b></span> (e.g., <code>lm</code>, <code>glm</code>,...).
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_terms">Terms</code></td>
<td>

<p>An optional integer vector specifying which coefficients should be <em>jointly</em> tested, using a Wald 
<code class="reqn">\chi^2</code> or <code class="reqn">F</code> test. Its elements correspond to the columns or rows of the var-cov 
matrix given in <code>Sigma</code>. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_l">L</code></td>
<td>

<p>An optional matrix conformable to <code>b</code>, such as its product with <code>b</code> i.e., <code>L %*% b</code> 
gives the linear combinations of the coefficients to be tested. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_h0">H0</code></td>
<td>

<p>A numeric vector giving the null hypothesis for the test. It must be as long as <code>Terms</code> or 
must have the same number of columns as <code>L</code>. Default to 0 for all the coefficients to be tested.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_df">df</code></td>
<td>

<p>A numeric vector giving the degrees of freedom to be used in an <code class="reqn">F</code> test, i.e. the degrees of freedom 
of the residuals of the model from which <code>b</code> and <code>Sigma</code> were fitted. Default to NULL, for no 
<code class="reqn">F</code> test. See the section <b>Details</b> for more information.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_verbose">verbose</code></td>
<td>

<p>A logical scalar controlling the amount of output information. The default is <code>FALSE</code>, providing minimum output.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_x">x</code></td>
<td>

<p>Object of class &ldquo;wald.test&rdquo;
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_digits">digits</code></td>
<td>

<p>Number of decimal places for displaying test results. Default to 2.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>print</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key assumption is that the coefficients asymptotically follow a (multivariate) normal distribution with mean = 
model coefficients and variance = their var-cov matrix.<br />
One (and only one) of <code>Terms</code> or <code>L</code> must be given. When <code>L</code> is given, it must have the same number of 
columns as the length of <code>b</code>, and the same number of rows as the number of linear combinations of coefficients. 
When <code>df</code> is given, the <code class="reqn">\chi^2</code> Wald statistic is divided by <code>m</code> = the number of 
linear combinations of coefficients to be tested (i.e., <code>length(Terms)</code> or <code>nrow(L)</code>). Under the null 
hypothesis <code>H0</code>, this new statistic follows an <code class="reqn">F(m, df)</code> distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>wald.test</code>, printed with <code>print.wald.test</code>.
</p>


<h3>References</h3>

<p>Diggle, P.J., Liang, K.-Y., Zeger, S.L., 1994. Analysis of longitudinal data. Oxford, Clarendon Press, 253 p.<br />
Draper, N.R., Smith, H., 1998. Applied Regression Analysis. New York, John Wiley &amp; Sons, Inc., 706 p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(DT_yatesoats)
DT &lt;- DT_yatesoats

m3 &lt;- mmer(fixed=Y ~ V + N + V:N-1,
           random = ~ B + B:MP,
           rcov=~units,
           data = DT)

wald.test(b = m3$Beta$Estimate, Sigma = m3$VarBeta, Terms = 2)

LL &lt;- matrix(0,nrow=1, ncol=12)
LL[1,2] &lt;- 1
LL[1,3] &lt;- -1
LL

wald.test(b = m3$Beta$Estimate, Sigma = m3$VarBeta, L=LL)

  </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
