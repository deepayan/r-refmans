<!DOCTYPE html><html><head><title>Help for package slurmR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {slurmR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#slurmR'><p>A Lightweight Wrapper for 'Slurm'</p></a></li>
<li><a href='#expand_array_indexes'><p>Expand Array Indexes</p></a></li>
<li><a href='#JOB_STATE_CODES'><p>Slurm Job state codes</p></a></li>
<li><a href='#makeSlurmCluster'><p>Create a Parallel Socket Cluster using Slurm</p></a></li>
<li><a href='#new_rscript'><p>General purpose function to write R scripts</p></a></li>
<li><a href='#opts_slurmR'><p>Get and set default options for <code>sbatch</code> and <code>slurmR</code> internals</p></a></li>
<li><a href='#parse_flags'><p>Utility function</p></a></li>
<li><a href='#random_job_name'><p>Generate a random job name</p></a></li>
<li><a href='#read_sbatch'><p>Read a slurm batch file and capture the SBATCH options</p></a></li>
<li><a href='#slurm_available'><p>R wrappers for <em>Slurm</em> commands</p></a></li>
<li><a href='#Slurm_clean'><p>Clean a session.</p></a></li>
<li><a href='#Slurm_collect'><p>Collect the results of a slurm job</p></a></li>
<li><a href='#Slurm_env'><p>A wrapper of Sys.getenv</p></a></li>
<li><a href='#Slurm_EvalQ'><p>Submit an expression to be evaluated to multiple jobs.</p></a></li>
<li><a href='#slurm_job'><p>Creating Slurm jobs</p></a></li>
<li><a href='#Slurm_log'><p>Check the R logfile of a job.</p></a></li>
<li><a href='#Slurm_Map'><p>The Slurm version of the <code>*apply</code> family of functions.</p></a></li>
<li><a href='#slurmr_docker'><p>slurmR docker image</p></a></li>
<li><a href='#snames'><p>Full path names for Slurm jobs</p></a></li>
<li><a href='#sourceSlurm'><p>Source an R script as a Slurm job</p></a></li>
<li><a href='#status'><p>Check the status of a Slurm JOB</p></a></li>
<li><a href='#the_plan'><p>Check for possible actions for a <code>slurm_job</code> wrapper</p></a></li>
<li><a href='#wait_slurm'><p>Wait for a Slurm job to be completed</p></a></li>
<li><a href='#WhoAmI'><p>Information about where jobs are submitted</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Lightweight Wrapper for 'Slurm'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>Description:</td>
<td>'Slurm', Simple Linux Utility for Resource Management
          <a href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</a>, is a popular 'Linux' based software used to 
          schedule jobs in 'HPC' (High Performance Computing) clusters. This R package
          provides a specialized lightweight wrapper of 'Slurm' with a syntax similar to
          that found in the 'parallel' R package. The package also includes a method for
          creating socket cluster objects spanning multiple nodes that can be used with
          the 'parallel' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USCbiostats/slurmR/issues">https://github.com/USCbiostats/slurmR/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USCbiostats/slurmR">https://github.com/USCbiostats/slurmR</a>, <a href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, covr, tinytest</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 23:26:22 UTC; george</td>
</tr>
<tr>
<td>Author:</td>
<td>George Vega Yon <a href="https://orcid.org/0000-0002-3171-0844"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Paul Marjoram <a href="https://orcid.org/0000-0003-0824-7449"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, ths],
  National Cancer Institute (NCI) [fnd] (Grant Number 5P01CA196569-02),
  Michael Schubert <a href="https://orcid.org/0000-0002-6862-5221"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev] (JOSS reviewer),
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev]
    (JOSS reviewer)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Vega Yon &lt;g.vegayon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-30 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='slurmR'>A Lightweight Wrapper for 'Slurm'</h2><span id='topic+slurmR'></span><span id='topic+slurmR-package'></span>

<h3>Description</h3>

<p>'Slurm', Simple Linux Utility for Resource Management
<a href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</a>, is a popular 'Linux' based software used to
schedule jobs in 'HPC' (High Performance Computing) clusters. This R package
provides a specialized lightweight wrapper of 'Slurm' with a syntax similar to
that found in the 'parallel' R package. The package also includes a method for
creating socket cluster objects spanning multiple nodes that can be used with
the 'parallel' package.
</p>


<h3>Details</h3>

<p>To cite slurmR in publications use:
</p>
<p>Vega Yon et al., (2019). slurmR: A lightweight wrapper for HPC with Slurm. Journal of Open Source Software,
4(39), 1493, https://doi.org/10.21105/joss.01493
</p>
<p>A BibTeX entry for LaTeX users is
</p>
<div class="sourceCode"><pre> @Article{,
  title = {slurmR: A lightweight wrapper for HPC with Slurm},
  author = {George {Vega Yon} and Paul Marjoram},
  journal = {The Journal of Open Source Software},
  year = {2019},
  month = {jul},
  volume = {4},
  number = {39},
  doi = {10.21105/joss.01493},
  url = {https://doi.org/10.21105/joss.01493},
}
</pre></div>

<hr>
<h2 id='expand_array_indexes'>Expand Array Indexes</h2><span id='topic+expand_array_indexes'></span>

<h3>Description</h3>

<p>When submitting array jobs using <code>sbatch</code>, users can specify indices in several
ways. These could be specified as, for example, ranges, &quot;<code>1-9</code>&quot;, lists,
&quot;<code style="white-space: pre;">&#8288;1,2,5&#8288;</code>&quot;, or intervals as &quot;<code>1-7:3</code>&quot;, which translates into &quot;<code style="white-space: pre;">&#8288;1, 4, 7&#8288;</code>&quot;. This
function expands those cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_array_indexes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_array_indexes_+3A_x">x</code></td>
<td>
<p>A character vector. Array indexes (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is assumed to be in the form of <code style="white-space: pre;">&#8288;[jobid](_[array expression])&#8288;</code>,
where the expression after the underscore is optional. The first
The function will return an expanded version of this, e.g. if <code>x = "8123_[1,3-6]"</code>
the resulting expression will be the vector  &quot;8123_1&quot;, &quot;8123_3&quot;, &quot;8123_4&quot;,
&quot;8123_5&quot;, and &quot;8123_6&quot;.
</p>
<p>This function was developed mainly to be used internally.
</p>


<h3>Value</h3>

<p>A character vector with the expanded indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expand_array_indexes(c("512", "123_1", "55_[1-5]", "122_[1, 5-6]", "44_[1-3:2]"))
# [1] "512"   "123_1" "55_1"  "55_2"  "55_3"  "55_4"  "55_5"
# "122_1" "122_5" "122_6" "44_1"  "44_3"
</code></pre>

<hr>
<h2 id='JOB_STATE_CODES'>Slurm Job state codes</h2><span id='topic+JOB_STATE_CODES'></span>

<h3>Description</h3>

<p>This data frame contains information regarding the job state codes that Slurm
returns when querying the status of a given job. The last column, <code>type</code>,
shows a description of how that corresponding state is considered in the
package's various operations. This is used in the function <a href="#topic+status">status</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JOB_STATE_CODES
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 4 columns.
</p>


<h3>References</h3>

<p>Slurm's website <a href="https://slurm.schedmd.com/squeue.html">https://slurm.schedmd.com/squeue.html</a>
</p>

<hr>
<h2 id='makeSlurmCluster'>Create a Parallel Socket Cluster using Slurm</h2><span id='topic+makeSlurmCluster'></span><span id='topic+stopCluster.slurm_cluster'></span>

<h3>Description</h3>

<p>This function is essentially a wrapper of the function <a href="parallel.html#topic+makeCluster">parallel::makePSOCKcluster</a>.
<code>makeSlurmCluster</code> main feature is adding node addresses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSlurmCluster(
  n,
  job_name = random_job_name(),
  tmp_path = opts_slurmR$get_tmp_path(),
  cluster_opt = list(),
  max_wait = 300L,
  verb = TRUE,
  ...
)

## S3 method for class 'slurm_cluster'
stopCluster(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSlurmCluster_+3A_n">n</code></td>
<td>
<p>Integer scalar. Size of the cluster object (see details).</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_job_name">job_name</code></td>
<td>
<p>Character. Name of the job to be passed to <code>Slurm</code>.</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character. Path to the directory where all the data (including
scripts) will be stored. Notice that this path must be accessible by all the
nodes in the network (See <a href="#topic+opts_slurmR">opts_slurmR</a>).</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_cluster_opt">cluster_opt</code></td>
<td>
<p>A list of arguments passed to <a href="parallel.html#topic+makeCluster">parallel::makePSOCKcluster</a>.</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_max_wait">max_wait</code></td>
<td>
<p>Integer scalar. Wait time before exiting with error while
trying to read the nodes information.</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_verb">verb</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, the function will print messages on
screen reporting on the status of the job submission.</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="#topic+Slurm_EvalQ">Slurm_EvalQ</a> via <code>sbatch_opt</code>.</p>
</td></tr>
<tr><td><code id="makeSlurmCluster_+3A_cl">cl</code></td>
<td>
<p>An object of class <code>slurm_cluster</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, if the <code>time</code> option is not specified via <code>...</code>,
then it is set to the value <code>01:00:00</code>, this is, 1 hour.
</p>
<p>Once a job is submitted via Slurm, the user gets access to the nodes
associated with it, which allows users to star new processes within those.
By means of this, we can create Socket, also known as &quot;PSOCK&quot;, clusters across
nodes in a Slurm environment. The name of the hosts are retrieved and passed
later on to <a href="parallel.html#topic+makeCluster">parallel::makePSOCKcluster</a>.
</p>
<p>It has been the case that R fails to create the cluster with the following
message in the Slurm log file:
</p>
<div class="sourceCode"><pre>srun: fatal: SLURM_MEM_PER_CPU, SLURM_MEM_PER_GPU, and SLURM_MEM_PER_NODE are mutually exclusive
</pre></div>
<p>In such cases, setting the memory, for example, upfront can solve the problem.
For example:
</p>
<div class="sourceCode"><pre>cl &lt;- makeSlurmCluster(20, mem = 20)
</pre></div>
<p>If the problem persists, i.e., the cluster cannot be created, make sure that
your Slurm cluster allows Socket connections between nodes.
</p>
<p>The method <code>stopCluster</code> for <code>slurm_cluster</code> stops the cluster doing
the following:
</p>

<ol>
<li><p> Closes the connection by calling the <code>stopCluster</code> method for <code>PSOCK</code> objects.
</p>
</li>
<li><p> Cancel the Slurm job using <code>scancel</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A object of class <code>c("slurm_cluster", "SOCKcluster", "cluster")</code>. It
is the same as what is returned by <a href="parallel.html#topic+makeCluster">parallel::makePSOCKcluster</a> with the main
difference that it has two extra attributes:
</p>

<ul>
<li> <p><code>SLURM_JOBID</code> Which is the id of the Job that initialized that cluster.
</p>
</li></ul>



<h3>Maximum number of connections</h3>

<p>By default, R limits the number of simultaneous connections (see this thread
in R-sig-hpc <a href="https://stat.ethz.ch/pipermail/r-sig-hpc/2012-May/001373.html">https://stat.ethz.ch/pipermail/r-sig-hpc/2012-May/001373.html</a>)
Current maximum is 128 (R version 3.6.1). To modify that limit, you would need
to reinstall R updating the macro <code>NCONNECTIONS</code> in the file <code>src/main/connections.c</code>.
</p>
<p>For now, if the user sets <code>n</code> above 128 it will get an immediate warning
pointing to this issue, in particular, specifying that the cluster object
may not be able to be created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Creating a cluster with 100 workers/offpring/child R sessions
cl &lt;- makeSlurmCluster(100)

# Computing the mean of a 100 random uniforms within each worker
# for this we can use any of the function available in the parallel package.
ans &lt;- parSapply(1:200, function(x) mean(runif(100)))

# We simply call stopCluster as we would do with any other cluster
# object
stopCluster(ans)

# We can also specify SBATCH options directly (...)
cl &lt;- makeSlurmCluster(200, partition = "thomas", time = "02:00:00")
stopCluster(cl)


## End(Not run)

</code></pre>

<hr>
<h2 id='new_rscript'>General purpose function to write R scripts</h2><span id='topic+new_rscript'></span>

<h3>Description</h3>

<p>This function will create an object of class <code>slurmR_rscript</code> that can be used
to write the R component in a batch job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rscript(
  njobs,
  tmp_path,
  job_name,
  pkgs = list_loaded_pkgs(),
  libPaths = .libPaths()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_rscript_+3A_njobs">njobs</code></td>
<td>
<p>Integer. Number of jobs to use in the job-array. This specifies
the number of R sessions to initialize. This does not specify the number of
cores to be used.</p>
</td></tr>
<tr><td><code id="new_rscript_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character. Path to the directory where all the data (including
scripts) will be stored. Notice that this path must be accessible by all the
nodes in the network (See <a href="#topic+opts_slurmR">opts_slurmR</a>).</p>
</td></tr>
<tr><td><code id="new_rscript_+3A_job_name">job_name</code></td>
<td>
<p>Character. Name of the job to be passed to <code>Slurm</code>.</p>
</td></tr>
<tr><td><code id="new_rscript_+3A_pkgs">pkgs</code></td>
<td>
<p>A named list with packages to be included. Each element of the list
must be a path to the R library, while the names of the list are the names of
the R packages to be loaded.</p>
</td></tr>
<tr><td><code id="new_rscript_+3A_libpaths">libPaths</code></td>
<td>
<p>A character vector. See <a href="base.html#topic+.libPaths">.libPaths</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment of class <code>slurmR_rscript</code>. This has the following accessible
components:
</p>

<ul>
<li> <p><code>add_rds</code> Add rds files to be loaded in each job.&quot;, <code>x</code> is a named list
with the objects that should be loaded in the jobs. If <code>index = TRUE</code> the
function assumes that the user will be accessing a particular subset of <code>x</code>
during the job, which is accessed according to <code>INDICES[[ARRAY_ID]]</code>. The
option <code>compress</code> is passed to <a href="base.html#topic+saveRDS">saveRDS</a>.
</p>
<p>One important side effect is that when this function is called, the object
will be saved in the current job directory, this is <code>opts_slurmR$get_tmp_path()</code>.
</p>
</li>
<li> <p><code>append</code> Adds a line to the R script. Its only argument, <code>x</code> is a character
vector that will be added to the R script.
</p>
</li>
<li> <p><code>rscript</code> A character vector. This is the actual R script that will be written
at the end.
</p>
</li>
<li> <p><code>finalize</code> Adds the final line of the R script. This function receives a
character scalar <code>x</code> which is used as the name of the object to be saved.
If missing, the function will save a NULL object. The <code>compress</code> argument
is passed to <a href="base.html#topic+saveRDS">saveRDS</a>.
</p>
</li>
<li> <p><code>set_seed</code> Adds a vector of seeds to be used across the jobs. This vector
of seeds should be of length <code>njobs</code>. The other two parameters of the
function are passed to <a href="base.html#topic+set.seed">set.seed</a>. By default the seed is picked as follows:
</p>
<div class="sourceCode"><pre>seeds &lt;- sample.int(.Machine$integer.max, njobs, replace = FALSE)
</pre></div>
</li>
<li> <p><code>write</code> Finalizes the process by writing the R script in the corresponding
folder to be used with Slurm.
</p>
</li></ul>


<hr>
<h2 id='opts_slurmR'>Get and set default options for <code>sbatch</code> and <code>slurmR</code> internals</h2><span id='topic+opts_slurmR'></span>

<h3>Description</h3>

<p>Most of the functions in the <code>slurmR</code> package use <code>tmp_path</code> and <code>job-name</code>
options to write and submit jobs to <strong>Slurm</strong>. These options have global
defaults that are set and retrieved using <code>opts_slurmR</code>. These options
also include SBATCH options and things to do before calling RScript,
e.g., loading modules on an HPC cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_slurmR
</code></pre>


<h3>Format</h3>

<p>An object of class <code>opts_slurmR</code> of length 17.
</p>


<h3>Details</h3>

<p>Whatever the path specified on <code>tmp_path</code>, all nodes should have access to it.
Moreover, it is recommended to use a path located in a high-performing drive.
See for example <a href="https://en.wikipedia.org/w/index.php?title=Disk_staging&amp;oldid=908353920">disk staging</a>.
</p>
<p>The <code>tmp_path</code> directory is only created at the time that one of the functions
needs to I/O files. Job creation calls like <a href="#topic+Slurm_EvalQ">Slurm_EvalQ</a> and <a href="#topic+Slurm_lapply">Slurm_lapply</a>
do such.
</p>
<p>The &quot;preamble&quot; options can be specified if, for example, the current cluster
needs to load R, a compiler, or other programs via a <code>module</code> command.
</p>
<p>Current supported options are:
</p>
<p>Debugging mode
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;debug_on : function ()&#8288;</code> Activates the debugging mode. When active, jobs will be submitted using sh and not sbatch. Also, only a single chunk of the data will be processed.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;debug_off : function ()&#8288;</code> Deactivates the debugging mode.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_debug : function ()&#8288;</code> Returns TRUE of debug mode is on
</p>
</li></ul>

<p>Verbose mode
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;verbose_on : function ()&#8288;</code> Deactivates the verbose mode. When ON, sbatch prints the Rscript and batch files on screen so that the user knows what will be submitted to Slurm.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;verbose_off : function ()&#8288;</code> Deactivates the verbose mode.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_verbose : function ()&#8288;</code> Returns TRUE if verbose mode is on.
</p>
</li></ul>

<p>Slurm options
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;set_tmp_path : function (path, recursive = TRUE)&#8288;</code> Sets the tempfile path for I/O
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_tmp_path : function ()&#8288;</code> Retrieves tempfile path for I/O
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;set_job_name : function (path, check = TRUE, overwrite = TRUE)&#8288;</code> Changes the job-name. When changing the name of the job the function will check whether the folder chdir/job-name is empty or not. If empty/not created it will create it, otherwise it will delete its contents (if 'overwrite = TRUE&ldquo;, else it will return with an Error)..
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_job_name : function (check = TRUE)&#8288;</code> Returns the current value of 'job-name'.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;set_preamble : function (...)&#8288;</code> Sets &quot;preamble&quot; to the RScript call. For example, it could be used for loading modules, setting env variables, etc., needed during the R session. Options are passed as characters.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_preamble : function ()&#8288;</code> Returns the preamble, e.g., module loads, environment variable definitions, etc., that will be included in sbatch submissions.
</p>
</li></ul>

<p>Other options
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;get_cmd : function ()&#8288;</code> If debug mode is active, then it returns 'sh', otherwise 'sbatch'
</p>
</li></ul>

<p>For general set/retrieve options
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;set_opts : function (...)&#8288;</code> A generic function to set options.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_opts_job : function (...)&#8288;</code> A generic function to retrieve options for the job (Slurm).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;get_opts_r : function (...)&#8288;</code> A generic function to retrieve options in R.
</p>
</li></ul>

<p>Nuke
</p>

<ul>
<li><p> While reloading the package should reset all the options, if needed, the user
can also use the function <code>opts_slurmR$reset()</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Common setup
## Not run: 
opts_slurmR$set_tmp_path("/staging/pdt/vegayon")
opts_slurmR$set_job_name("simulations-1")
opts_slurm$set_opts(partition="thomas", account="lc_pdt")
opts_slurm$set_preamble("module load gcc")# if needed

## End(Not run)

</code></pre>

<hr>
<h2 id='parse_flags'>Utility function</h2><span id='topic+parse_flags'></span><span id='topic+parse_flags.default'></span><span id='topic+parse_flags.list'></span>

<h3>Description</h3>

<p>Utility function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_flags(...)

## Default S3 method:
parse_flags(...)

## S3 method for class 'list'
parse_flags(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_flags_+3A_...">...</code></td>
<td>
<p>Options to be parsed as bash flags.</p>
</td></tr>
<tr><td><code id="parse_flags_+3A_x">x</code></td>
<td>
<p>A named list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the processed flags.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat(parse_flags(a=1, b=TRUE, hola=2, y="I have spaces", ms=2, `cpus-per-task`=4))
# -a 1 -b --hola=2 -y "I have spaces" --ms=2 --cpus-per-task=4
</code></pre>

<hr>
<h2 id='random_job_name'>Generate a random job name</h2><span id='topic+random_job_name'></span>

<h3>Description</h3>

<p>Generate a random job name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_job_name()
</code></pre>


<h3>Value</h3>

<p>A character scalar that can be used as job. All names will start with
the prefix <code style="white-space: pre;">&#8288;slurmr-job-&#8288;</code> and then some random string. This is a wrapper of
the function <code><a href="base.html#topic+tempfile">tempfile()</a></code> and uses as <code>tmpdir</code> argument
<code>opts_slurmR$get_tmp_path()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_job_name()
</code></pre>

<hr>
<h2 id='read_sbatch'>Read a slurm batch file and capture the SBATCH options</h2><span id='topic+read_sbatch'></span>

<h3>Description</h3>

<p>Read a slurm batch file and capture the SBATCH options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sbatch(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_sbatch_+3A_x">x</code></td>
<td>
<p>Character scalar. Either the path to the batch file to process, or
a character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of the options starting with <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> in the file.
If no option is found, then returns a character vector length 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reading in an example script
x &lt;- system.file("example.slurm", package="slurmR")
read_sbatch(x)

</code></pre>

<hr>
<h2 id='slurm_available'>R wrappers for <em>Slurm</em> commands</h2><span id='topic+slurm_available'></span><span id='topic+squeue'></span><span id='topic+squeue.default'></span><span id='topic+squeue.slurm_job'></span><span id='topic+scancel'></span><span id='topic+scancel.default'></span><span id='topic+scancel.slurm_job'></span><span id='topic+sacct'></span><span id='topic+sacct.default'></span><span id='topic+sacct.slurm_job'></span><span id='topic+slurm.conf'></span><span id='topic+SchedulerParameters'></span><span id='topic+sacct_'></span><span id='topic+sbatch'></span><span id='topic+submit'></span><span id='topic+sbatch.slurm_job'></span><span id='topic+sbatch.character'></span>

<h3>Description</h3>

<p>The functions <code>sbatch</code>, <code>scancel</code>, <code>squeue</code>, <code>sacct</code>, and <code>slurm.conf</code> are
wrappers of calls to Slurm functions via <a href="base.html#topic+system2">system2</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slurm_available()

squeue(x = NULL, ...)

## Default S3 method:
squeue(x = NULL, ...)

## S3 method for class 'slurm_job'
squeue(x, ...)

scancel(x = NULL, ...)

## Default S3 method:
scancel(x = NULL, ...)

## S3 method for class 'slurm_job'
scancel(x = NULL, ...)

sacct(x, ...)

## Default S3 method:
sacct(x = NULL, brief = TRUE, parsable = TRUE, allocations = TRUE, ...)

## S3 method for class 'slurm_job'
sacct(x, ...)

slurm.conf()

SchedulerParameters()

sacct_(x = NULL, ..., no_sacct = FALSE)

sbatch(x, wait = FALSE, submit = TRUE, ...)

## S3 method for class 'slurm_job'
sbatch(x, wait = FALSE, submit = TRUE, ...)

## S3 method for class 'character'
sbatch(x, wait = FALSE, submit = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slurm_available_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>slurm_job</code>, or, in some cases, an
integer as a Slurm jobid. Note that some functions allow passing no arguments.</p>
</td></tr>
<tr><td><code id="slurm_available_+3A_...">...</code></td>
<td>
<p>Further flags passed to the command line function.</p>
</td></tr>
<tr><td><code id="slurm_available_+3A_brief">brief</code>, <code id="slurm_available_+3A_parsable">parsable</code>, <code id="slurm_available_+3A_allocations">allocations</code></td>
<td>
<p>Logical. When <code>TRUE</code>, these are passed as flags directly
to the command line function <code>sacct</code>.</p>
</td></tr>
<tr><td><code id="slurm_available_+3A_no_sacct">no_sacct</code></td>
<td>
<p>Logical. Skip <code>sacct</code> directly (for internal use only.)</p>
</td></tr>
<tr><td><code id="slurm_available_+3A_wait">wait</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the function will pass the <code>--wait</code>
flag to <code>Slurm</code> and set <code>wait = TRUE</code> in the <a href="base.html#topic+system2">system2</a> call.</p>
</td></tr>
<tr><td><code id="slurm_available_+3A_submit">submit</code></td>
<td>
<p>Logical, when <code>TRUE</code> calls <a href="#topic+sbatch">sbatch</a> to submit the job to slurm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>slurm_available</code> checks whether Slurm is available in
the system or not. It is usually called before calling any bash wrapper.
If available, the function will return <code>TRUE</code>, otherwise <code>FALSE</code>.
</p>
<p>The wrapper of squeue includes the flag <code style="white-space: pre;">&#8288;-o%all&#8288;</code> which returns all
available fields separated by a vertical bar. This cannot be changed since it
is the easiest way of processing the information in R.
</p>
<p>The function <code>slurm.conf</code> is a wrapper of the function <code>scontrol</code> that
returns configuration info about Slurm, in particular, the underlying command
that is called is <code style="white-space: pre;">&#8288;scontrol show conf&#8288;</code>. This returns a named character vector
with configuration info about the cluster. The name of this function matches
the name of the file that holds this information.
</p>
<p>The function <code>SchedulerParameters</code> is just a wrapper of <a href="#topic+slurm.conf">slurm.conf</a>.
It processes the field &quot;SchedulerParameters&quot; included in the configuration
file and has information relevant for the scheduler.
</p>
<p><code>sacct.</code> is an alternative that works around when <code>sacct</code> fails due to
lack of accounting on. This function is not intended for direct call.
</p>
<p>In the case of <code>sbatch</code>, function takes an object of class <code>slurm_job</code> and
submits it to the queue. In debug mode the job will be submitted via <code>sh</code>
instead.
</p>
<p>The method for character scalars is used to submit jobs using a slurm
script.
</p>


<h3>Value</h3>

<p>In the case of <code>sbatch</code>, depends on what <code>x</code> is:
</p>

<ul>
<li><p> If <code>x</code> is of class <a href="#topic+slurm_job">slurm_job</a>, then it returns the same object including
the Slurm job ID (if the job was submitted to the queue).
</p>
</li>
<li><p> If <code>x</code> is a file path (e.g. a bash script), an integer with the jobid number
(again, if the job was submitted to Slurm).
</p>
</li></ul>

<p>The functions <code>squeue</code> and <code>sacct</code> return a data frame with the information
returned by the command line utilities. The function <code>scancel</code> returns NULL.
</p>
<p><code>slurm_available()</code> returns a logical scalar equal to <code>TRUE</code> if Slurm is
available.
</p>
<p><code>slurm.conf()</code> and <code>SchedulerParameters()</code> return information about the
Slurm cluster, if available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Are we under a Slurm Cluster?
slurm_available()


## Not run: 
# What is the maximum number of jobs (array size) that the system
# allows?
sconfig &lt;- slurm.conf() # We first retrieve the info.
sconfig["MaxArraySize"]

## End(Not run)

## Not run: 
# Submitting a simple job
job &lt;- Slurm_EvalQ(slurmR::WhoAmI(), njobs = 4L, plan = "submit")

# Checking the status of the job (we can simply print)
job
status(job) # or use the state function
sacct(job) # or get more info with the sactt wrapper.

# Suppose one of the jobs is taking too long to complete (say #4)
# we can stop it and resubmit the job as follows:
scancel(job)

# Resubmitting only 4
sbatch(job, array = 4) # A new jobid will be assigned


## End(Not run)
</code></pre>

<hr>
<h2 id='Slurm_clean'>Clean a session.</h2><span id='topic+Slurm_clean'></span>

<h3>Description</h3>

<p>The functions of the family <a href="#topic+Slurm_lapply">Slurm_*apply</a> generate a set of
temporary files that are used for the job design, submission and collection.
This function will remove all the contents of directory created by calling
those functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_clean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_clean_+3A_x">x</code></td>
<td>
<p>An object of class <code>slurm_job</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the job is finalized, it returns 0 if able to clean the directory
otherwise return whatever <a href="base.html#topic+unlink">unlink</a> returns after trying to remove the job
path.
</p>


<h3>See Also</h3>

<p>Other post submission: 
<code><a href="#topic+Slurm_collect">Slurm_collect</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>
<p>Other utilities: 
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

job &lt;- Slurm_EvalQ(1 + 1, 2, plan = "collect")

# This will remove all the files generated by Slurm_EvalQ
Slurm_clean(job)


## End(Not run)
</code></pre>

<hr>
<h2 id='Slurm_collect'>Collect the results of a slurm job</h2><span id='topic+Slurm_collect'></span><span id='topic+Slurm_collect.slurm_job'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>slurm_job</code> and retrieves the results,
this is, combines the R objects generated by each job. Object of class
<code>slurm_job</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_collect(...)

## S3 method for class 'slurm_job'
Slurm_collect(x, any. = FALSE, wait = 10L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_collect_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="Slurm_collect_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+slurm_job">slurm_job</a>.</p>
</td></tr>
<tr><td><code id="Slurm_collect_+3A_any.">any.</code></td>
<td>
<p>Logical. When <code>TRUE</code>, will collect any output available regardless
of whether the job is completed or not.</p>
</td></tr>
<tr><td><code id="Slurm_collect_+3A_wait">wait</code></td>
<td>
<p>Integer scalar. Number of seconds to wait before checking the
state of a job if the first try returned <code>-1</code> (no job found).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the given job has hooks, which is a list of functions, these will
be applied sequentially to the set of retrieved results before returning.
</p>


<h3>Value</h3>

<p>By default, it returns a concatenated list of the output files
generated by each job. If the job object has a hook, it will apply each hook
to the full list before returning. See <a href="#topic+new_slurm_job">new_slurm_job</a>.
</p>


<h3>See Also</h3>

<p>Other post submission: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Collecting a job after calling it
job &lt;- Slurm_EvalQ(slurmR::WhoAmI(), njobs = 4, plan = "wait")
Slurm_collect(job)

# Collecting a job from a previous R session
job &lt;- read_slurm_job("/path/to/a/job/tmp_dir")
Slurm_collect(job)

## End(Not run)
</code></pre>

<hr>
<h2 id='Slurm_env'>A wrapper of <a href="base.html#topic+Sys.getenv">Sys.getenv</a></h2><span id='topic+Slurm_env'></span>

<h3>Description</h3>

<p>This function is used within the R script written by <code>slurmR</code> to get the
current value of <code>SLURM_ARRAY_TASK_ID</code>, an environment variable that Slurm
creates when running an array. In the case that <code>opts_slurmR$get_debug() == TRUE</code>,
the function will return a 1 (see <a href="#topic+opts_slurmR">opts_slurmR</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_env(x = "SLURM_ARRAY_TASK_ID")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_env_+3A_x">x</code></td>
<td>
<p>Character scalar. Environment variable to get.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If slurm is available and the R session is running under a job
array, meaning that <code>SLURM_ARRAY_TASK_ID</code> is defined, then it returns that
value, otherwise it will return <code>1</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>

<hr>
<h2 id='Slurm_EvalQ'>Submit an expression to be evaluated to multiple jobs.</h2><span id='topic+Slurm_EvalQ'></span>

<h3>Description</h3>

<p>Submit an expression to be evaluated to multiple jobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_EvalQ(
  expr,
  njobs = 2L,
  job_name = opts_slurmR$get_job_name(),
  tmp_path = opts_slurmR$get_tmp_path(),
  plan = "collect",
  sbatch_opt = list(),
  rscript_opt = list(),
  seeds = NULL,
  compress = TRUE,
  export = NULL,
  export_env = NULL,
  libPaths = .libPaths(),
  hooks = NULL,
  overwrite = TRUE,
  preamble = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_EvalQ_+3A_expr">expr</code></td>
<td>
<p>An expression to be passed to Slurm.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_njobs">njobs</code></td>
<td>
<p>Integer. Number of jobs to use in the job-array. This specifies
the number of R sessions to initialize. This does not specify the number of
cores to be used.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_job_name">job_name</code></td>
<td>
<p>Character. Name of the job to be passed to <code>Slurm</code>.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character. Path to the directory where all the data (including
scripts) will be stored. Notice that this path must be accessible by all the
nodes in the network (See <a href="#topic+opts_slurmR">opts_slurmR</a>).</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_plan">plan</code></td>
<td>
<p>A character scalar. (See <a href="#topic+the_plan">the_plan</a>).</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_sbatch_opt">sbatch_opt</code></td>
<td>
<p>List of options to be passed to <code>sbatch</code>. This is usually
done by adding the flags <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> to the bash file.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_rscript_opt">rscript_opt</code></td>
<td>
<p>List. Options to be passed to <code>Rscript</code>.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_seeds">seeds</code></td>
<td>
<p>Integer vector of length <code>njobs</code>. Seeds to be passed to each
job. When <code>NULL</code> (default), seeds will be picked automatically (see <a href="#topic+new_rscript">new_rscript</a>).</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_compress">compress</code></td>
<td>
<p>Logical scalar (default <code>TRUE</code>). Passed to <a href="base.html#topic+saveRDS">saveRDS</a>. Setting
this value to <code>FALSE</code> can be useful when the user requires faster read/write
of R objects on disk.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_export">export</code></td>
<td>
<p>A named list with objects to be included in the Spawned sessions.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_export_env">export_env</code></td>
<td>
<p>An environment. Environment where the objects listed in
<code>export</code> are located (default <code><a href="base.html#topic+parent.frame">parent.frame()</a></code>).</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_libpaths">libPaths</code></td>
<td>
<p>A character vector. See <a href="base.html#topic+.libPaths">.libPaths</a>.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_hooks">hooks</code></td>
<td>
<p>A list of functions (passed to <a href="#topic+new_slurm_job">new_slurm_job</a>).</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, if the path specified by
<code>tmp_path/job_name</code> already exists, it will overwrite it, otherwise the
function returns with an error.</p>
</td></tr>
<tr><td><code id="Slurm_EvalQ_+3A_preamble">preamble</code></td>
<td>
<p>Character vector. Each element is then added to the Slurm
batch file between the <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> options and the script's main call. A
common example is adding required modules, e.g. <code>c("module load gcc/6.1.1")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>njobs</code>.
</p>

<hr>
<h2 id='slurm_job'>Creating Slurm jobs</h2><span id='topic+slurm_job'></span><span id='topic+new_slurm_job'></span><span id='topic+print.slurm_job'></span><span id='topic+read_slurm_job'></span><span id='topic+write_slurm_job'></span><span id='topic+last_submitted_job'></span><span id='topic+last_job'></span>

<h3>Description</h3>

<p>Utilities to deal with objects of class <code>slurm_job</code>. The function <code>new_slurm_job</code>,
which is mostly intended to be for internal used, creates an object of class
<code>slurm_job</code>. The function <code>last_submitted_job</code> returns the last submitted
job in the current R session, and the functions <code>read/write_slurm_job</code> are
utility functions to read and write R jobs respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_slurm_job(
  call,
  rscript,
  bashfile,
  robjects,
  njobs,
  opts_job,
  opts_r,
  hooks = NULL
)

## S3 method for class 'slurm_job'
print(x, ...)

read_slurm_job(path)

write_slurm_job(x, path = NULL)

last_submitted_job()

last_job()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slurm_job_+3A_call">call</code></td>
<td>
<p>The original call</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_rscript">rscript</code>, <code id="slurm_job_+3A_bashfile">bashfile</code></td>
<td>
<p>The R script and bash file path.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_robjects">robjects</code></td>
<td>
<p>A character vector of R objects that will be imported in the job.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_njobs">njobs</code></td>
<td>
<p>Integer. Number of jobs to start (array).</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_opts_job">opts_job</code>, <code id="slurm_job_+3A_opts_r">opts_r</code></td>
<td>
<p>List. In the case of <code>opts_job</code>, a list of parameters
passed to <a href="#topic+sbatch">sbatch</a>. <code>opts_r</code> is a list of parameters used within R. Both can
be retrieved by <a href="#topic+opts_slurmR">opts_slurmR</a><code style="white-space: pre;">&#8288;$get_opts_job()&#8288;</code> and <a href="#topic+opts_slurmR">opts_slurmR</a><code style="white-space: pre;">&#8288;$get_opts_r()&#8288;</code>
respectively.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_hooks">hooks</code></td>
<td>
<p>List of functions. To be called on the collected results after
it finalizes.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_x">x</code></td>
<td>
<p>An object of class <code>slurm_job</code>.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method.</p>
</td></tr>
<tr><td><code id="slurm_job_+3A_path">path</code></td>
<td>
<p>Character scalar. Path to either a directory with a <code>job.rds</code> file,
or directly to a <code>job.rds</code> file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of the function <code>new_slurm_job</code>, besides of creating the
object of class <code>slurm_job</code>, the function calls <code>write_slurm_job</code> and stores
the job object in an <code><a href="base.html#topic+saveRDS">rds</a></code> class file. The name and location of
the saved rds file is generated using the function <code>snames("job")</code>.
</p>
<p>The <code>read_slurm_job</code> can help the user recovering a previously saved
<code>slurm_job</code> object. If <code>path</code> is a directory, then the function will assume
that the file that is looking for lives within that directory and is named
<code>job.rds</code>. Otherwise, if a file, then it will read it directly. In any case,
it will check that the read object is an object of class <code>slurm_job</code>.
</p>
<p>The <code>write_slurm_job</code> function simply takes a <code>slurm_job</code> object
and saves it in, if <code>path</code> is not specified, whatever the <code>job$options$chdir</code>
folder is under the name <code>job.rds</code>. If a path is specified, the it is directly
passed to <code><a href="base.html#topic+saveRDS">saveRDS()</a></code>.
</p>
<p>The <code>las_submitted_job</code> function will return the latest <code>slurm_job</code>
object that was submitted via <a href="#topic+sbatch">sbatch</a> in the current session. The <code>last_job</code>
function is just an alias of the later. If no job has been submitted, then
the resulting value will be <code>NULL</code>.
</p>


<h3>Value</h3>

<p>An environment of class <code>slurm_job</code>. This has the following items:
</p>

<ul>
<li> <p><code>call</code> The original call (<a href="#topic+Slurm_lapply">Slurm_lapply</a>, <a href="#topic+Slurm_Map">Slurm_Map</a>, etc.)
</p>
</li>
<li> <p><code>rscript</code> The full path to the R script to be executed by bash file.
</p>
</li>
<li> <p><code>bashfile</code> The full path to the bash file to be executed by <a href="#topic+sbatch">sbatch</a>.
</p>
</li>
<li> <p><code>robjects</code> Ignored.
</p>
</li>
<li> <p><code>njobs</code> The number of jobs to be submitted (job array).
</p>
</li>
<li> <p><code>opts_job</code>,<code>opts_r</code> Two lists of options as returned by <a href="#topic+opts_slurmR">opts_slurmR</a>$get_opts_job()
and <a href="#topic+opts_slurmR">opts_slurmR</a>$get_r_opts() at the moment of the creation of the <code>slurm_job</code>.
</p>
</li>
<li> <p><code>hooks</code> A list of functions to be called on the collected objects
by <a href="#topic+Slurm_collect">Slurm_collect</a>.
</p>
</li></ul>

<p>In the case of the function <code>write_slurm_job</code>, it returns the full
path to the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The last_job function can be handy when `plan = "collect"` in a called,
# for example
job &lt;- Slurm_lapply(1:1000, function(i) runif(100), njobs = 2, plan = "collect")

# Post collection analysis
status(last_job())

## End(Not run)
</code></pre>

<hr>
<h2 id='Slurm_log'>Check the R logfile of a job.</h2><span id='topic+Slurm_log'></span>

<h3>Description</h3>

<p>After submission, the functions of type <a href="#topic+Slurm_lapply">Slurm_*apply</a> generate
log files, one per each job in the job array. The <code>Slurm_log</code> function can be
used to check the log files of jobs in the array that failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_log(x, which. = NULL, cmd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_log_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+slurm_job">slurm_job</a>.</p>
</td></tr>
<tr><td><code id="Slurm_log_+3A_which.">which.</code></td>
<td>
<p>An integer scalar. The number of the array job to check. This
should range between 1 and <code>x$njobs</code>.</p>
</td></tr>
<tr><td><code id="Slurm_log_+3A_cmd">cmd</code></td>
<td>
<p>Character scalar. The name of the command to use to call view the
log file. Default to <code>less</code> when interactive mode, otherwise <code>cat</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If other than <code>less</code> is used, then the function will try to
check by calling <code>cmd --version</code>. If returns with error, it assumes the
function is not available. Using the <code>cmd</code> argument only works in interactive
mode.
</p>


<h3>Value</h3>

<p>Whatever the command-line call returns.
</p>


<h3>See Also</h3>

<p>Other post submission: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_collect">Slurm_collect</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>
<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- Slurm_EvalQ(slurmR::whoami(), plan = "wait")
Slurm_log(x) # Checking the R log

## End(Not run)
</code></pre>

<hr>
<h2 id='Slurm_Map'>The Slurm version of the <code><a href="base.html#topic+lapply">*apply</a></code> family of functions.</h2><span id='topic+Slurm_Map'></span><span id='topic+Slurm_lapply'></span><span id='topic+Slurm_sapply'></span>

<h3>Description</h3>

<p>The Slurm version of the <code><a href="base.html#topic+lapply">*apply</a></code> family of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Slurm_Map(
  f,
  ...,
  njobs = 2L,
  mc.cores = 1L,
  job_name = opts_slurmR$get_job_name(),
  tmp_path = opts_slurmR$get_tmp_path(),
  plan = "collect",
  sbatch_opt = list(),
  rscript_opt = list(),
  seeds = NULL,
  compress = TRUE,
  export = NULL,
  export_env = NULL,
  libPaths = .libPaths(),
  hooks = NULL,
  overwrite = TRUE,
  preamble = NULL
)

Slurm_lapply(
  X,
  FUN,
  ...,
  njobs = 2L,
  mc.cores = 1L,
  job_name = opts_slurmR$get_job_name(),
  tmp_path = opts_slurmR$get_tmp_path(),
  plan = "collect",
  sbatch_opt = list(),
  rscript_opt = list(),
  seeds = NULL,
  compress = TRUE,
  export = NULL,
  export_env = NULL,
  libPaths = .libPaths(),
  hooks = NULL,
  overwrite = TRUE,
  preamble = NULL
)

Slurm_sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slurm_Map_+3A_njobs">njobs</code></td>
<td>
<p>Integer. Number of jobs to use in the job-array. This specifies
the number of R sessions to initialize. This does not specify the number of
cores to be used.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_job_name">job_name</code></td>
<td>
<p>Character. Name of the job to be passed to <code>Slurm</code>.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character. Path to the directory where all the data (including
scripts) will be stored. Notice that this path must be accessible by all the
nodes in the network (See <a href="#topic+opts_slurmR">opts_slurmR</a>).</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_plan">plan</code></td>
<td>
<p>A character scalar. (See <a href="#topic+the_plan">the_plan</a>).</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_sbatch_opt">sbatch_opt</code></td>
<td>
<p>List of options to be passed to <code>sbatch</code>. This is usually
done by adding the flags <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> to the bash file.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_rscript_opt">rscript_opt</code></td>
<td>
<p>List. Options to be passed to <code>Rscript</code>.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_seeds">seeds</code></td>
<td>
<p>Integer vector of length <code>njobs</code>. Seeds to be passed to each
job. When <code>NULL</code> (default), seeds will be picked automatically (see <a href="#topic+new_rscript">new_rscript</a>).</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_compress">compress</code></td>
<td>
<p>Logical scalar (default <code>TRUE</code>). Passed to <a href="base.html#topic+saveRDS">saveRDS</a>. Setting
this value to <code>FALSE</code> can be useful when the user requires faster read/write
of R objects on disk.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_export">export</code></td>
<td>
<p>A named list with objects to be included in the Spawned sessions.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_export_env">export_env</code></td>
<td>
<p>An environment. Environment where the objects listed in
<code>export</code> are located (default <code><a href="base.html#topic+parent.frame">parent.frame()</a></code>).</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_libpaths">libPaths</code></td>
<td>
<p>A character vector. See <a href="base.html#topic+.libPaths">.libPaths</a>.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_hooks">hooks</code></td>
<td>
<p>A list of functions (passed to <a href="#topic+new_slurm_job">new_slurm_job</a>).</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, if the path specified by
<code>tmp_path/job_name</code> already exists, it will overwrite it, otherwise the
function returns with an error.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_preamble">preamble</code></td>
<td>
<p>Character vector. Each element is then added to the Slurm
batch file between the <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> options and the script's main call. A
common example is adding required modules, e.g. <code>c("module load gcc/6.1.1")</code>.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_x">X</code>, <code id="Slurm_Map_+3A_fun">FUN</code>, <code id="Slurm_Map_+3A_f">f</code>, <code id="Slurm_Map_+3A_mc.cores">mc.cores</code>, <code id="Slurm_Map_+3A_...">...</code></td>
<td>
<p>Arguments passed to either <a href="parallel.html#topic+mclapply">parallel::mclapply</a> or
<a href="parallel.html#topic+mclapply">parallel::mcMap</a>.</p>
</td></tr>
<tr><td><code id="Slurm_Map_+3A_simplify">simplify</code>, <code id="Slurm_Map_+3A_use.names">USE.NAMES</code></td>
<td>
<p>Logical scalar. See <a href="base.html#topic+sapply">sapply</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Slurm_lapply</code> will submit <code>njobs</code> to the queue and distribute
<code>X</code> according to <a href="parallel.html#topic+splitIndices">parallel::splitIndices</a>. For example, if <code>X</code> is list with
1,000 elements, and <code>njobs = 2</code>, then <code>Slurm_lapply</code> will submit 2 jobs with
500 elements of <code>X</code> each (2 chunks of data). The same principle applies to
<code>Slurm_sapply</code> and <code>Slurm_Map</code>, this is, the data is split by chunks so all
the information is sent at once when the job is submitted.
</p>
<p>Just like <a href="base.html#topic+sapply">sapply</a> is to <a href="base.html#topic+lapply">lapply</a>, <code>Slurm_sapply</code> is just a wrapper of
<code>Slurm_lapply</code> with an extra argument, <code>simplify</code>. When <code>TRUE</code>, once the job
is collected, the function <a href="base.html#topic+simplify2array">simplify2array</a> is called.
</p>


<h3>Value</h3>

<p>If <code>plan == "collect"</code>, then whatever the analogous function returns,
otherwise, an object of class <a href="#topic+slurm_job">slurm_job</a>.
</p>


<h3>References</h3>

<p>Job Array Support https://slurm.schedmd.com/job_array.html
</p>


<h3>See Also</h3>

<p>For resubmitting a job, see the example in <a href="#topic+sbatch">sbatch</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # A job drawing 1e6 uniforms on 10 jobs (array)
  # The option plan = "wait" makes it return only once the job is completed.
  job1 &lt;- Slurm_lapply(1:20, function(i) runif(1e6), njobs=10, plan = "wait")

  # To collect
  ans &lt;- Slurm_collect(job1)

  # As before, but this time not waiting, and now we are passing more
  # arguments to the function
  # plan = "none" only creates the job object (and the files), we submit
  # later
  job1 &lt;- Slurm_lapply(1:20, function(i, a) runif(1e6, a), a = -1, njobs=10,
      plan = "none")

  # We submit
  job1 &lt;- sbatch(job1)

  # In order to cancel a job
  scancel(job1)

  # How to clean up
  Slurm_clean(job1)

## End(Not run)
</code></pre>

<hr>
<h2 id='slurmr_docker'>slurmR docker image</h2><span id='topic+slurmr_docker'></span><span id='topic+docker_available'></span><span id='topic+slurmr_docker_pull'></span><span id='topic+slurmr_docker_run'></span><span id='topic+slurmr_docker_stop'></span>

<h3>Description</h3>

<p>Helper functions to use <code>slurmR</code>'s docker image. This requires
having an internet connection and <code>docker</code> installed in your
system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docker_available(path = "")

slurmr_docker_pull(path = "")

slurmr_docker_run(path = "", pull = TRUE, timeout = 60)

slurmr_docker_stop(UUID = "", path = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slurmr_docker_+3A_path">path</code></td>
<td>
<p>Path to the <code>docker</code> executable. If not specified, the function
will try to figure it out by itself.</p>
</td></tr>
<tr><td><code id="slurmr_docker_+3A_pull">pull</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, if not available, it will
invoke <code style="white-space: pre;">&#8288;docker pull&#8288;</code>.</p>
</td></tr>
<tr><td><code id="slurmr_docker_+3A_timeout">timeout</code></td>
<td>
<p>Integer. Number of seconds to wait for docker to start
the slurmR image.</p>
</td></tr>
<tr><td><code id="slurmr_docker_+3A_uuid">UUID</code></td>
<td>
<p>String. Universally Unique Identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Starting version 0.5-0, a Docker image with Slurm, R, and slurmR
is available at <a href="https://hub.docker.com/r/uscbiostats/slurmr">https://hub.docker.com/r/uscbiostats/slurmr</a>.
The source code (Dockerfile) is available in the project GitHub
repository: <a href="https://github.com/USCbiostats/slurmR">https://github.com/USCbiostats/slurmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example requires having Docker installed in the system
## Not run: 
  # Start the docker image. By default it will try to pull the
  # image from Docker Hub if available

  # This opens a bash session with R + Slurm + slurmR
  slurmr_docker_run() 

  # Will pull the docker image
  slurmr_docker_pull()



## End(Not run)

</code></pre>

<hr>
<h2 id='snames'>Full path names for Slurm jobs</h2><span id='topic+snames'></span>

<h3>Description</h3>

<p>Using <a href="#topic+opts_slurmR">opts_slurmR</a><code style="white-space: pre;">&#8288;$get_tmp_path&#8288;</code> and <a href="#topic+opts_slurmR">opts_slurmR</a><code style="white-space: pre;">&#8288;$get_job_name&#8288;</code> creates
file names with full path to the objects. This function is intended for
internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snames(type, array_id = NULL, tmp_path = NULL, job_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snames_+3A_type">type</code></td>
<td>
<p>can be any of r, sh, out, or rds.</p>
</td></tr>
<tr><td><code id="snames_+3A_array_id">array_id</code></td>
<td>
<p>Integer. ID of the array to create the name.</p>
</td></tr>
<tr><td><code id="snames_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character scalar. Path to the temp directory used by the job
to write files.</p>
</td></tr>
<tr><td><code id="snames_+3A_job_name">job_name</code></td>
<td>
<p>Character scalar. Name of the job.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the parameters <code>tmp_path</code> and <code>job_name</code> are retrieved from
the current options specified in <a href="#topic+opts_slurmR">opts_slurmR</a>.
</p>


<h3>Value</h3>

<p>A character scalar. The normalized path to the corresponding file.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>

<hr>
<h2 id='sourceSlurm'>Source an R script as a Slurm job</h2><span id='topic+sourceSlurm'></span><span id='topic+slurmr_cmd'></span>

<h3>Description</h3>

<p>This function sources R scripts using Slurm by creating a batch script file
and submitting it via <a href="#topic+sbatch">sbatch</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sourceSlurm(
  file,
  job_name = NULL,
  tmp_path = opts_slurmR$get_tmp_path(),
  rscript_opt = list(vanilla = TRUE),
  plan = "submit",
  ...
)

slurmr_cmd(
  cmd_path,
  cmd_name = "slurmr",
  add_alias = TRUE,
  bashrc_path = "~/.bashrc"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sourceSlurm_+3A_file">file</code></td>
<td>
<p>Character. Path to the R script to source using Slurm.</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_job_name">job_name</code></td>
<td>
<p>Character. Name of the job to be passed to <code>Slurm</code>.</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_tmp_path">tmp_path</code></td>
<td>
<p>Character. Path to the directory where all the data (including
scripts) will be stored. Notice that this path must be accessible by all the
nodes in the network (See <a href="#topic+opts_slurmR">opts_slurmR</a>).</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_rscript_opt">rscript_opt</code></td>
<td>
<p>List. Options to be passed to <code>Rscript</code>.</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_plan">plan</code></td>
<td>
<p>A character scalar. (See <a href="#topic+the_plan">the_plan</a>).</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_...">...</code></td>
<td>
<p>Further options passed to <a href="#topic+sbatch">sbatch</a>.</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_cmd_path">cmd_path</code></td>
<td>
<p>Character scalar. Path (directory) where to put the command function.
This is usually your home directory.</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_cmd_name">cmd_name</code></td>
<td>
<p>Character scalar. Name of the command (of the file).</p>
</td></tr>
<tr><td><code id="sourceSlurm_+3A_add_alias">add_alias</code>, <code id="sourceSlurm_+3A_bashrc_path">bashrc_path</code></td>
<td>
<p>Logical scalar and character scalar. When
<code>add_alias=TRUE</code> it will modify (or create, if non-existent) the <code>.bashrc</code>
file to add an alias of the same name of <code>cmd_name</code>. The path to <code>.bashrc</code> can be
specified via the <code>bashrc_path</code> option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sourceSlurm</code> checks for flags that may be included in the Slurm job file. If
the R script starts with <code style="white-space: pre;">&#8288;#!/bin/&#8288;</code> or similar, then <code style="white-space: pre;">&#8288;#SBATCH&#8288;</code> flags will be
read from the R script and added to the Slurm job file.
</p>
<p>The function <code>slurmr_cmd</code> writes a simple command that works as a wrapper
of <code>sourceSlurm</code>. In particular, from command line, if the user wants to source an
R script using <code>sourceSlurm</code>, we can either:
</p>
<div class="sourceCode"><pre>$ Rscript -e "slurmR::sourceSlurm('path/to/the/script.R', plan = 'submit')"
</pre></div>
<p>Or, after calling <code>slurmr_cmd</code> from within R, do the following instead
</p>
<div class="sourceCode"><pre>$ ./slurmr path/to/the/script.R
</pre></div>
<p>And, if you used the option <code>add_alias = TRUE</code>, then, after restarting bash,
you can run R scripts with Slurm as follows:
</p>
<div class="sourceCode"><pre>$ slurmr path/to/the/script.R
</pre></div>
<p>The main side effect of this function is that it creates a file named <code>cmd_name</code>
in the directory specified by <code>cmd_path</code>, and, if <code>add_alias = TRUE</code>. it will
create (if not found) or modify (if found) the <code>.bashrc</code> file adding a line
with an alias. For more information on <code>.bashrc</code> see <a href="https://superuser.com/questions/49289">here</a>.
</p>


<h3>Value</h3>

<p>In the case of <code>sourceSlurm</code>, Whatever <a href="#topic+sbatch">sbatch</a> returns.
</p>
<p>The function <code>slurmr_cmd</code> returns <code>invisible()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In this example we will be sourcing an R script that also has #SBATCH
# flags. Here are the contents
file &lt;- system.file("example.R", package="slurmR")

cat(readLines(file), sep="\n")
# #!/bin/sh
# #SBATCH --account=lc_ggv
# #SBATCH --time=01:00:00
# #SBATCH --mem-per-cpu=4G
# #SBATCH --job-name=Waiting
# Sys.sleep(10)
# message("done.")

# We can directly submit this R script as a job by calling `sourceSlurm`.
# (of course you need Slurm to do this!)
## Not run: 
sourceSlurm(file)

## End(Not run)

# The function will create a bash script that is used later to be submitted to
# the queue using `sbatch`. The resulting file looks something like this
# #!/bin/sh
# #SBATCH --job-name=Waiting
# #SBATCH --output=/home/vegayon/Documents/slurmR/Waiting.out
# #SBATCH --account=lc_ggv
# #SBATCH --time=01:00:00
# #SBATCH --mem-per-cpu=4G
# /usr/lib/R/bin/Rscript --vanilla /usr/local/lib/R/site-library/slurmR/example.R
</code></pre>

<hr>
<h2 id='status'>Check the status of a Slurm JOB</h2><span id='topic+status'></span><span id='topic+status.slurm_job'></span><span id='topic+status.default'></span><span id='topic++24.slurm_status'></span>

<h3>Description</h3>

<p>Using the <a href="#topic+sacct">sacct</a> function, it checks the status of a particular job and
returns information about its current state, with details regarding the
jobs (if an array) that are done, running, pending, or failed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(x)

## S3 method for class 'slurm_job'
status(x)

## Default S3 method:
status(x)

## S3 method for class 'slurm_status'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_x">x</code></td>
<td>
<p>Either a Job id, an object of class <code>slurm_job</code>, or an object of
class <code>slurm_status</code>.</p>
</td></tr>
<tr><td><code id="status_+3A_name">name</code></td>
<td>
<p>Character scalar. List of status to retrieve. This can be any of
<code>"done"</code>, <code>"failed"</code>, <code>"running"</code>, or <code>"pending"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer with attributes of class <code>slurm_status</code>. The attributes
are integer vectors indicating which jobs fail in the categories of <code>done</code>,
<code>failed</code>, <code>pending</code>, and <code>running</code> (see <a href="#topic+JOB_STATE_CODES">JOB_STATE_CODES</a>). Possible return
values are:
</p>

<ul>
<li> <p><code>-1</code>: No job found. This may be a false negative as the job may still be
on it's way to be submitted.
</p>
</li>
<li> <p><code>0</code>: Job completed.
</p>
</li>
<li> <p><code>1</code>: All jobs are pending resource allocation or are on it's way to start.
</p>
</li>
<li> <p><code>2</code>: All jobs are currently running.
</p>
</li>
<li> <p><code>3</code>: One or more jobs are still running.
</p>
</li>
<li> <p><code>99</code>: One or more jobs failed.
</p>
</li></ul>

<p>If the job is not an array, then function will return the corresponding code
but the attributes will only have a single number, 1, according to the state
of the job (completed, failed, pending).
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+WhoAmI">WhoAmI</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>
</p>
<p>Other post submission: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_collect">Slurm_collect</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

x &lt;- Slurm_EvalQ(Sys.sleep(100), njobs = 2)

status(x) # A possible result: An integer with attributes
# Status: All jobs are pending resource allocation or are on it's way to start. (Code 1)
# This is a job array. The status of each job, by array id, is the following:
# done      :  -
# failed    :  -
# pending   : 1, 2.
# running   :  -


## End(Not run)
</code></pre>

<hr>
<h2 id='the_plan'>Check for possible actions for a <code>slurm_job</code> wrapper</h2><span id='topic+the_plan'></span>

<h3>Description</h3>

<p>Users can choose whether to submit the job or not, to wait for it, and whether
they want to collect the results right away after the job has finished. This
function will help developers to figure out what set of actions need to be
taken depending on the plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>the_plan(plan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="the_plan_+3A_plan">plan</code></td>
<td>
<p>A character scalar with either of the following values:
<code>"collect"</code>, <code>"wait"</code>, <code>"submit"</code>, or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function that returns a list with three logical values:
<code>wait</code>, <code>collect</code>, and <code>submit</code>. There are four possible cases:
</p>

<ul>
<li> <p><code>plan == "collect"</code>, then all three are <code>TRUE</code>.
</p>
</li>
<li> <p><code>plan == "wait"</code>, then all but <code>collect</code> are <code>TRUE</code>.
</p>
</li>
<li> <p><code>plan == "submit"</code> then only <code>submit</code> equals <code>TRUE</code>.
</p>
</li>
<li> <p><code>plan == "none"</code> then all three are <code>FALSE</code>.
</p>
</li></ul>

<p>In general, bot <code>wait</code> and <code>submit</code> will be passed to <a href="#topic+sbatch">sbatch</a>.
</p>
<p>When <code>collect == TRUE</code>, then it usually means that the function will be calling
<a href="#topic+Slurm_collect">Slurm_collect</a> right after submitting the job via <a href="#topic+sbatch">sbatch</a>.
</p>


<h3>Value</h3>

<p>A list with three logical scalars.
</p>


<h3>See Also</h3>

<p>This is used in <a href="#topic+Slurm_lapply">apply functions</a> and in <a href="#topic+Slurm_EvalQ">Slurm_EvalQ</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>the_plan("none")
# $collect
# [1] FALSE
#
# $wait
# [1] FALSE
#
# $submit
# [1] FALSE

the_plan("wait")
# $collect
# [1] FALSE
#
# $wait
# [1] TRUE
#
# $submit
# [1] TRUE
</code></pre>

<hr>
<h2 id='wait_slurm'>Wait for a Slurm job to be completed</h2><span id='topic+wait_slurm'></span><span id='topic+wait_slurm.slurm_job'></span><span id='topic+wait_slurm.integer'></span>

<h3>Description</h3>

<p>Wait for a Slurm job to be completed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait_slurm(x, ...)

## S3 method for class 'slurm_job'
wait_slurm(x, ...)

## S3 method for class 'integer'
wait_slurm(x, timeout = -1, freq = 0.1, force = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wait_slurm_+3A_x">x</code></td>
<td>
<p>Either a job id number, or an object of class <a href="#topic+slurm_job">slurm_job</a>.</p>
</td></tr>
<tr><td><code id="wait_slurm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the method</p>
</td></tr>
<tr><td><code id="wait_slurm_+3A_timeout">timeout</code></td>
<td>
<p>Integer. Maximum wait time in seconds. If <code>timeout &lt; 0</code>
then the command will only return when the job finishes.</p>
</td></tr>
<tr><td><code id="wait_slurm_+3A_freq">freq</code></td>
<td>
<p>Frequency in seconds to query for the state of the job.</p>
</td></tr>
<tr><td><code id="wait_slurm_+3A_force">force</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>, if the job is not found
after checking for its status, the function will continue to wait
still.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Waiting is only available if there are Slurm clusters
if (slurm_available()) {
  job &lt;- Slurm_EvalQ(Sys.sleep(1000), plan = "submit", njobs = 2)
  wait_slurm(job, timeout = 1) # This will return a warning
  scancel(job)   
  Slurm_clean(job)
}
</code></pre>

<hr>
<h2 id='WhoAmI'>Information about where jobs are submitted</h2><span id='topic+WhoAmI'></span><span id='topic+whoami'></span>

<h3>Description</h3>

<p>This returns a named vector with the following variables:
SLURM_LOCALID, SLURMD_NODENAME, SLURM_ARRAY_TASK_ID, SLURM_CLUSTER_NAME, SLURM_JOB_PARTITION, SLURM_TASK_PID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WhoAmI()

whoami()
</code></pre>


<h3>Details</h3>

<p><code>whoami</code> is just an alias of <code>WhoAmI</code>.
</p>


<h3>Value</h3>

<p>A character vector with the corresponding system environment variables'
values.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+Slurm_clean">Slurm_clean</a>()</code>,
<code><a href="#topic+Slurm_env">Slurm_env</a>()</code>,
<code><a href="#topic+Slurm_log">Slurm_log</a>()</code>,
<code><a href="#topic+parse_flags">parse_flags</a>()</code>,
<code><a href="#topic+snames">snames</a>()</code>,
<code><a href="#topic+status">status</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
