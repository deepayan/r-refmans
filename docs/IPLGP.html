<!DOCTYPE html><html><head><title>Help for package IPLGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IPLGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GA.Dscore'><p>Search For A Subset With The Highest D-score</p></a></li>
<li><a href='#GBLUP.fit'><p>Muti-trait GBLUP Model</p></a></li>
<li><a href='#geno.d'><p>Generate the Genetic Design Matrix with dominance Effect</p></a></li>
<li><a href='#output.best'><p>Summary For The Best Individuals</p></a></li>
<li><a href='#output.gain'><p>Summary For Genetic Gain</p></a></li>
<li><a href='#phe.sd'><p>Standardize Phenotypic Values</p></a></li>
<li><a href='#simu.gamete'><p>Simulate The Genotype Of A Gamete</p></a></li>
<li><a href='#simu.GDO'><p>Simulate Progeny with GD-O Strategy</p></a></li>
<li><a href='#simu.GEBVGD'><p>Simulate Progeny with GEBV-GD Strategy</p></a></li>
<li><a href='#simu.GEBVO'><p>Simulate Progeny with GEBV-O Strategy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification of Parental Lines via Genomic Prediction</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Combining genomic prediction with Monte Carlo simulation, three different 
    strategies are implemented to select parental lines for multiple traits in plant 
    breeding. The selection strategies include (i) GEBV-O considers only genomic 
    estimated breeding values (GEBVs) of the candidate individuals; (ii) GD-O 
    considers only genomic diversity (GD) of the candidate individuals; and (iii) 
    GEBV-GD considers both GEBV and GD. The above method can be seen in Chung PY, 
    Liao CT (2020) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0243159">doi:10.1371/journal.pone.0243159</a>&gt;. Multi-trait genomic best 
    linear unbiased prediction (MT-GBLUP) model is used to simultaneously estimate 
    GEBVs of the target traits, and then a selection index is adopted to evaluate 
    the composite performance of an individual.</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, sommer, grDevices, stats</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/py-chung/IPLGP">https://github.com/py-chung/IPLGP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/py-chung/IPLGP/issues">https://github.com/py-chung/IPLGP/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 10:17:35 UTC; pingyuan</td>
</tr>
<tr>
<td>Author:</td>
<td>Ping-Yuan Chung [cre],
  Chen-Tuo Liao [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ping-Yuan Chung &lt;r06621204@ntu.edu.tw&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GA.Dscore'>Search For A Subset With The Highest D-score</h2><span id='topic+GA.Dscore'></span>

<h3>Description</h3>

<p>Search for an optimal subset of the candidate individuals such that it
achieves the highest D-score by genetic algorithm (GA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GA.Dscore(
  K,
  size,
  keep = c(),
  n0 = size,
  mut = 3,
  cri = 10000,
  console = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GA.Dscore_+3A_k">K</code></td>
<td>
<p>matrix. An n*n matrix denotes the genomic relationship matrix of
the n candidate individuals, where n &gt; 4.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_size">size</code></td>
<td>
<p>integer. An integer denotes the size of the subset, note that
3 &lt; size &lt; n.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_keep">keep</code></td>
<td>
<p>vector. A vector indicates those candidate individuals which
will be retained in the subset before the search. The length of keep must
be less than size.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_n0">n0</code></td>
<td>
<p>integer. An integer indicates the number of chromosomes
(solutions) in the genetic algorithm, note that n0 &gt; 3.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_mut">mut</code></td>
<td>
<p>integer. An integer indicates the number of mutations in the
genetic algorithm, note that mut &lt; size.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_cri">cri</code></td>
<td>
<p>integer. An integer indicates the stopping criterion, note that
cri &lt; 1e+06. The genetic algorithm will stop if the number of iterations
reaches cri.</p>
</td></tr>
<tr><td><code id="GA.Dscore_+3A_console">console</code></td>
<td>
<p>logical. A logical variable, if console is set to be TRUE,
the searching process will be shown in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>subset</code></td>
<td>
<p>The optimal subset with the highest D-score.</p>
</td></tr>
<tr><td><code>D.score</code></td>
<td>
<p>The D.score of the optimal subset.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The number of iterations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>
<p>Ou JH, Liao CT. 2019. Training set determination for genomic selection.
Theor Appl Genet. 132:2781-2792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
geno.test &lt;- matrix(sample(c(1, -1), 600, replace = TRUE), 20, 30)
K.test &lt;- geno.test%*%t(geno.test)/ncol(geno.test)

# run with no specified individual
result1 &lt;- GA.Dscore(K.test, 6, cri = 1000, console = TRUE)
result1

# run with some specified individuals
result2 &lt;- GA.Dscore(K.test, 6, keep = c(1, 5, 10), cri = 1000, console = TRUE)
result2
</code></pre>

<hr>
<h2 id='GBLUP.fit'>Muti-trait GBLUP Model</h2><span id='topic+GBLUP.fit'></span>

<h3>Description</h3>

<p>Built the muti-trait GBLUP model using the phenotypic and genotypic data of a
training population by 'mmer' from R package 'sommer'. Then, output the fitted
values of the training population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBLUP.fit(t1, t2, t3, t4, t5, geno = NULL, K = NULL, outcross = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GBLUP.fit_+3A_t1">t1</code></td>
<td>
<p>vector. The phenotype of trait1. The missing value must be coded as NA.
The length of all triat must be the same.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_t2">t2</code></td>
<td>
<p>vector. The phenotype of trait2. The missing value must be coded as NA.
The length of all triat must be the same.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_t3">t3</code></td>
<td>
<p>vector. The phenotype of trait3. The missing value must be coded as NA.
The length of all triat must be the same.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_t4">t4</code></td>
<td>
<p>vector. The phenotype of trait4. The missing value must be coded as NA.
The length of all triat must be the same.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_t5">t5</code></td>
<td>
<p>vector. The phenotype of trait5. The missing value must be coded as NA.
The length of all triat must be the same.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_geno">geno</code></td>
<td>
<p>matrix. An n*p matrix with n individuals and p markers of the
training population. The markers must be coded as 1, 0, or -1 for alleles AA,
Aa, or aa. The missing value must have been already imputed.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_k">K</code></td>
<td>
<p>matrix. An n*n matrix denotes the genomic relationship matrix of the
training population if geno is set to be NULL.</p>
</td></tr>
<tr><td><code id="GBLUP.fit_+3A_outcross">outcross</code></td>
<td>
<p>logical. A logical variable, if outcross is set to be TRUE,
the crop is regarded as an outcross crop. The kinship matrix of dominance
effects are also considered in the model. The geno data must be given when
outcross being TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fitted.value</code></td>
<td>
<p>The fitted values.</p>
</td></tr>
<tr><td><code>fitted.A</code></td>
<td>
<p>The additive effect part of fitted values.</p>
</td></tr>
<tr><td><code>fitted.D</code></td>
<td>
<p>The dominance effect part of fitted values.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The average value of fitted values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Due to restrictions on the use of the funtion 'mmer', if an unknown error occurs
during use, please try to input the phenotype data as the format shown in the
example.
</p>


<h3>References</h3>

<p>Habier D, Fernando RL, Dekkers JCM. 2007. The impact of genetic relationship
information on genome-assisted breeding values. Genetics 177:2389-2397.
</p>
<p>VanRaden PM. 2008. Efficient methods to compute genomic predictions.
J Dairy Sci. 91:4414-4423.
</p>


<h3>See Also</h3>

<p><code><a href="sommer.html#topic+mmer">mmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(2000)
t1 &lt;- rnorm(50,30,10)
t2 &lt;- rnorm(50,10,5)
t3 &lt;- rnorm(50,20,20)
t4 &lt;- NULL
t5 &lt;- NULL

# run with the marker score matrix
geno.test &lt;- matrix(sample(c(1, -1), 5000, replace = TRUE), 50, 100)
result1 &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
result1$fitted.value

# run with the genomic relationship matrix
K.test &lt;- geno.test%*%t(geno.test)/ncol(geno.test)
result2 &lt;- GBLUP.fit(t1, t2, t3, t4, t5, K = K.test)
result2$fitted.value
</code></pre>

<hr>
<h2 id='geno.d'>Generate the Genetic Design Matrix with dominance Effect</h2><span id='topic+geno.d'></span>

<h3>Description</h3>

<p>Input the commonly used additive effect genetic design matrix to generate the
design matrix and kinship matrix of additive and dominance effects respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.d(geno, AA = 1, Aa = 0, aa = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno.d_+3A_geno">geno</code></td>
<td>
<p>matrix. An n*p matrix denotes the commonly used additive effect
genetic design matrix of the training population.</p>
</td></tr>
<tr><td><code id="geno.d_+3A_aa">AA</code></td>
<td>
<p>number or character. The code denote alleles AA in the geno data.</p>
</td></tr>
<tr><td><code id="geno.d_+3A_aa">Aa</code></td>
<td>
<p>number or character. The code denote alleles Aa in the geno data.</p>
</td></tr>
<tr><td><code id="geno.d_+3A_aa">aa</code></td>
<td>
<p>number or character. The code denote alleles aa in the geno data.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>genoA</code></td>
<td>
<p>An n*p matrix denote additive effects, and the markers are coded
as 1, 0, or -1 for alleles AA, Aa, or aa.</p>
</td></tr>
<tr><td><code>genoD</code></td>
<td>
<p>An n*p matrix denote dominance effects, and the markers are coded
as 0.5, -0.5, or 0.5 for alleles AA, Aa, or aa.</p>
</td></tr>
<tr><td><code>KA</code></td>
<td>
<p>An n*n matrix denote the kinship matrix of individuals with additive
effects. Whitch is caculated by genoA.</p>
</td></tr>
<tr><td><code>KD</code></td>
<td>
<p>An n*n matrix denote the kinship matrix of individuals with dominance
effects. Whitch is caculated by genoD.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cockerham, C. C., 1954. An extension of the concept of partitioning
hereditary variance for analysis of covariances among relatives When
epistasis is present. Genetics 39: 859–882.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
geno &lt;- rbind(rep(1,10),rep(0,10),rep(-1,10),c(rep(1,5),rep(-1,5)),c(rep(-1,5),rep(1,5)))
geno

geno2 &lt;- geno.d(geno)

geno2$genoD
geno2$KD
</code></pre>

<hr>
<h2 id='output.best'>Summary For The Best Individuals</h2><span id='topic+output.best'></span>

<h3>Description</h3>

<p>Output the GEBV average curves and the summary statistics for the best
individuals selected over generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.best(result, save.pdf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.best_+3A_result">result</code></td>
<td>
<p>list. The data list of the output from simu.GEBVO, simu.GDO,
or simu.GEBVGD.</p>
</td></tr>
<tr><td><code id="output.best_+3A_save.pdf">save.pdf</code></td>
<td>
<p>logical. A logical variable, if save.pdf is set to be TRUE,
the pdf file of plots will be saved in the working directory instead of
being shown in the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GEBV averages of the best individuals among the repetitions over
generations for each trait.
</p>


<h3>Note</h3>

<p>The figure output contains the plots of GEBV averages of the best individuals
selected over generations for each trait. If save.pdf is set to be TRUE, the
pdf file of plots will be saved in the working directory instead of being
shown in the console.
</p>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simu.GEBVO">simu.GEBVO</a></code>
<code><a href="#topic+simu.GDO">simu.GDO</a></code>
<code><a href="#topic+simu.GEBVGD">simu.GEBVGD</a></code>
<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(2000)
t1 &lt;- rnorm(10,30,10)
t2 &lt;- rnorm(10,10,5)
t3 &lt;- NULL
t4 &lt;- NULL
t5 &lt;- NULL
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
fit &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
fitvalue &lt;- fit$fitted.value

geno.candidate &lt;- matrix(sample(c(1,-1), 300, replace = TRUE), 15, 20)

# run
result &lt;- simu.GEBVO(fitvalue, geno.t = geno.test, marker = marker.test,
geno.c = geno.candidate, nprog = 5, nsele = 10, ngen = 5, nrep = 5)

# summary for the best individuals
output &lt;- output.best(result)
output
</code></pre>

<hr>
<h2 id='output.gain'>Summary For Genetic Gain</h2><span id='topic+output.gain'></span>

<h3>Description</h3>

<p>Output the GEBV average of parental lines, the GEBV average of the last
generation in simulation process, and the genetic gain average over repetitions
for each target trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output.gain(result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output.gain_+3A_result">result</code></td>
<td>
<p>list. The data list of the output from simu.GEBVO, simu.GDO,
or simu.GEBVGD.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output contains the table of the GEBV average of parental lines, the GEBV
average of the last generation in simulation process, and the genetic gain
average over repetitions for each target trait.
</p>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simu.GEBVO">simu.GEBVO</a></code>
<code><a href="#topic+simu.GDO">simu.GDO</a></code>
<code><a href="#topic+simu.GEBVGD">simu.GEBVGD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(2000)
t1 &lt;- rnorm(10,30,10)
t2 &lt;- rnorm(10,10,5)
t3 &lt;- NULL
t4 &lt;- NULL
t5 &lt;- NULL
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
fit &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
fitvalue &lt;- fit$fitted.value

geno.candidate &lt;- matrix(sample(c(1,-1), 300, replace = TRUE), 15, 20)

# run
result &lt;- simu.GEBVO(fitvalue, geno.t = geno.test, marker = marker.test,
geno.c = geno.candidate, nprog = 5, nsele = 10, ngen = 5, nrep = 5)

# summary for genetic gain
output &lt;- output.gain(result)
output
</code></pre>

<hr>
<h2 id='phe.sd'>Standardize Phenotypic Values</h2><span id='topic+phe.sd'></span>

<h3>Description</h3>

<p>Standardize the phenotypic values of all the target traits from a training
population. Then, output the standardized phenotypic values, the mean vector,
and the standard deviation vector of the target traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe.sd(phe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe.sd_+3A_phe">phe</code></td>
<td>
<p>matrix. An n*t matrix with n individuals and t traits, denotes the
phenotypic values. The missing value must be coded as NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>standardize.phe</code></td>
<td>
<p>An n*t matrix contains the standardized phenotypic values.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A vector with length t contains the averages of the phenotypic values
of the t target traits.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>A vector with length t contains the standard deviations of the phenotypic
values of the t target traits.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
phe.test &lt;- data.frame(trait1 = rnorm(50,30,10), trait2 = rnorm(50,10,5), trait3 = rnorm(50,20,20))

# run and output
result &lt;- phe.sd(phe.test)
result
</code></pre>

<hr>
<h2 id='simu.gamete'>Simulate The Genotype Of A Gamete</h2><span id='topic+simu.gamete'></span>

<h3>Description</h3>

<p>Generate the genotype of a gamete from the genotypic data of its
parents by Monte Carlo simulation. The recombination rate is calculate by
Haldane’s mapping function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu.gamete(marker)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu.gamete_+3A_marker">marker</code></td>
<td>
<p>data frame. A p*4 data frame whose first column indicates the
chromosome number to which a marker belongs; second column indicates the
position of the marker in centi-Morgan (cM); and 3rd and 4th columns
indicates the genotype of the marker (numeric or character).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SNP sequence of gamete.
</p>


<h3>References</h3>

<p>Haldane J.B.S. 1919. The combination of linkage values and the calculation
of distance between the loci for linked factors. Genetics 8: 299–309.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
marker.test &lt;- data.frame(c(1,1,1,1,1,2,2,2,2,2),c(10,20,30,40,50,10,20,30,40,50),
c("A","T","C","G","A","A","G","A","T","A"),c("A","A","G","C","T","A","G","T","T","A"))

# run
simu.gamete(marker.test)
</code></pre>

<hr>
<h2 id='simu.GDO'>Simulate Progeny with GD-O Strategy</h2><span id='topic+simu.GDO'></span>

<h3>Description</h3>

<p>Identify parental lines based on GD-O strategy and simulate their offsprings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu.GDO(
  fittedA.t,
  fittedD.t = NULL,
  fittedmu.t = NULL,
  geno.t,
  marker,
  geno.c = NULL,
  npl = NULL,
  better.c = FALSE,
  weight = NULL,
  direction = NULL,
  outcross = FALSE,
  nprog = 50,
  nsele = NULL,
  ngen = 10,
  nrep = 30,
  cri = 10000,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu.GDO_+3A_fitteda.t">fittedA.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the fitted values of each traits
of the training population. The missing value must have been already imputed.
If outcross is set to be TRUE, this argument must be the additive effect part
of fitted values.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_fittedd.t">fittedD.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the dominance effect part of
fitted values when outcross is set to be TRUE. The missing value must have been
already imputed.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_fittedmu.t">fittedmu.t</code></td>
<td>
<p>numeric or vector. A p*1 vector denote the average value of
fitted values when outcross is set to be TRUE. The length must be the same as
the number of traits.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_geno.t">geno.t</code></td>
<td>
<p>matrix. An n*p matrix denotes the marker score matrix of the
training population. The markers must be coded as 1, 0, or -1 for alleles
AA, Aa, or aa. The missing value must have been already imputed.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_marker">marker</code></td>
<td>
<p>matrix. A p*2 matrix whose first column indicates the chromosome
number to which a marker belongs; and second column indicates the position of
the marker in centi-Morgan (cM).</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_geno.c">geno.c</code></td>
<td>
<p>matrix. An nc*p matrix denotes the marker score matrix of the
candidate population with nc individuals and p markers. It should be pure lines
and markers must be coded as 1, or -1 for alleles AA, or aa. The missing value
must have been already imputed. If geno.c is set to be NULL, the candidate
population is exactly the training population.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_npl">npl</code></td>
<td>
<p>integer. An integer indicates the number of individuals who will
be chosen as the parental lines. If npl = NULL, it will be 4 times the number
of traits.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_better.c">better.c</code></td>
<td>
<p>logical. A logical variable, if better.c is set to be TRUE,
the candidate individuals with GEBVs better than average for all the target
traits will comprise the candidate set. Otherwise, all the candidate
individuals will comprise the candidate set.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_weight">weight</code></td>
<td>
<p>vector. A vector with length t indicates the weights of target
traits in selection index. If weight is set to be NULL, the equal weight will
be assigned to all the target traits. The weights should be a positive number.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_direction">direction</code></td>
<td>
<p>vector. A vector with length t indicates the selecting
directions for target traits. The elements of direction are Inf, or -inf
representing the rule that the larger the better; or the smaller the better.
Or if the element is a number, it will select the individuals with the trait
value close to the number. If direction is set to be NULL, the selecting
direction will be the larger the better for all trait.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_outcross">outcross</code></td>
<td>
<p>logical. A logical variable, if outcross is set to be TRUE,
the crop is regarded as an outcross crop. The kinship matrix of dominance
effects are also considered in the model, and crossing and selection will be
performed in F1 generation. The detail can be seen in the references.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_nprog">nprog</code></td>
<td>
<p>integer. An integer indicates the number of progenies which
will be produced for each of the best individuals at every generation.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_nsele">nsele</code></td>
<td>
<p>integer. An integer indicates the number of the best individuals
which will be selected at each generation. If nsele is set to be NULL, the
number will be the same as the number of F1 individuals.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_ngen">ngen</code></td>
<td>
<p>integer. An integer indicates the number of generations in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_nrep">nrep</code></td>
<td>
<p>integer. An integer indicates the number of repetitions in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_cri">cri</code></td>
<td>
<p>integer. An integer indicates the stopping criterion, note that
cri &lt; 1e+06. The genetic algorithm will stop if the number of iterations
reaches cri.</p>
</td></tr>
<tr><td><code id="simu.GDO_+3A_console">console</code></td>
<td>
<p>logical. A logical variable, if console is set to be TRUE,
the simulation process will be shown in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>method</code></td>
<td>
<p>The GD-O strategy.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>The weights of target traits in selection index.</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>The selecting directions of target traits in selection index.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The mean vector of target traits.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation vector of target traits.</p>
</td></tr>
<tr><td><code>GEBV.value</code></td>
<td>
<p>The GEBVs of target traits in each generation and each
repetition.</p>
</td></tr>
<tr><td><code>parental.lines</code></td>
<td>
<p>The IDs and D-score of parental lines selected in
each repetition.</p>
</td></tr>
<tr><td><code>suggested.subset</code></td>
<td>
<p>The most frequently selected parental lines by this
strategy.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function output.best and output.gain can be used to summarize the result.
</p>
<p>The fitted value data in the input data can be obtained by the function
GBLUP.fit and mmer, that can be seen in the Examples shown below.
</p>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>


<h3>See Also</h3>

<p><code><a href="sommer.html#topic+mmer">mmer</a></code>
<code><a href="#topic+GBLUP.fit">GBLUP.fit</a></code>
<code><a href="#topic+GA.Dscore">GA.Dscore</a></code>
<code><a href="#topic+simu.gamete">simu.gamete</a></code>
<code><a href="#topic+simu.GDO">simu.GDO</a></code>
<code><a href="#topic+simu.GEBVGD">simu.GEBVGD</a></code>
<code><a href="#topic+output.best">output.best</a></code>
<code><a href="#topic+output.gain">output.gain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
t3 &lt;- NULL
t4 &lt;- NULL
t5 &lt;- NULL
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
fit &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
fitvalue &lt;- fit$fitted.value

geno.candidate &lt;- matrix(sample(c(1,-1), 300, replace = TRUE), 15, 20)

# run and output
result &lt;- simu.GDO(fitvalue, geno.t = geno.test, marker = marker.test,
geno.c = geno.candidate, nprog = 5, nsele = 10, ngen = 5, nrep = 5, cri = 250)
result$suggested.subset



# other method: use mmer to obtain the fitted value
## Not run: 
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
phe &lt;- cbind(t1, t2)
nt &lt;- ncol(phe)
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
rownames(geno.test) &lt;- 1:nrow(geno.test)
id &lt;- rownames(geno.test)
K0 &lt;- geno.test%*%t(geno.test)/ncol(geno.test)

dat &lt;- data.frame(id, phe)
fit0 &lt;- sommer::mmer(cbind(t1, t2)~1,
      random = ~sommer::vsr(id, Gu = K0, Gtc = sommer::unsm(nt)),
      rcov = ~sommer::vsr(units, Gtc = sommer::unsm(nt)),
      data = dat,
      tolParInv = 0.1)

u0 &lt;- fit0$U$`u:id`
fit &lt;- matrix(unlist(u0), ncol = nt)
colnames(fit) &lt;- names(u0)

fit &lt;- fit+matrix(fit0$fitted[1,], nrow(fit), nt, byrow = TRUE)
fitvalue &lt;- fit[order(as.numeric(names((u0[[1]])))),]

## End(Not run)
</code></pre>

<hr>
<h2 id='simu.GEBVGD'>Simulate Progeny with GEBV-GD Strategy</h2><span id='topic+simu.GEBVGD'></span>

<h3>Description</h3>

<p>Identify parental lines based on GEBV-GD strategy and simulate their offsprings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu.GEBVGD(
  fittedA.t,
  fittedD.t = NULL,
  fittedmu.t = NULL,
  geno.t,
  marker,
  geno.c = NULL,
  npl = NULL,
  better.c = FALSE,
  npl.best = NULL,
  weight = NULL,
  direction = NULL,
  outcross = FALSE,
  nprog = 50,
  nsele = NULL,
  ngen = 10,
  nrep = 30,
  cri = 10000,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu.GEBVGD_+3A_fitteda.t">fittedA.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the fitted values of each traits
of the training population. The missing value must have been already imputed.
If outcross is set to be TRUE, this argument must be the additive effect part
of fitted values.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_fittedd.t">fittedD.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the dominance effect part of
fitted values when outcross is set to be TRUE. The missing value must have been
already imputed.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_fittedmu.t">fittedmu.t</code></td>
<td>
<p>numeric or vector. A p*1 vector denote the average value of
fitted values when outcross is set to be TRUE. The length must be the same as
the number of traits.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_geno.t">geno.t</code></td>
<td>
<p>matrix. An n*p matrix denotes the marker score matrix of the
training population. The markers must be coded as 1, 0, or -1 for alleles
AA, Aa, or aa. The missing value must have been already imputed.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_marker">marker</code></td>
<td>
<p>matrix. A p*2 matrix whose first column indicates the chromosome
number to which a marker belongs; and second column indicates the position of
the marker in centi-Morgan (cM).</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_geno.c">geno.c</code></td>
<td>
<p>matrix. An nc*p matrix denotes the marker score matrix of the
candidate population with nc individuals and p markers. It should be pure lines
and markers must be coded as 1, or -1 for alleles AA, or aa. The missing value
must have been already imputed. If geno.c is set to be NULL, the candidate
population is exactly the training population.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_npl">npl</code></td>
<td>
<p>integer. An integer indicates the number of individuals who will
be chosen as the parental lines. If npl = NULL, it will be 4 times the number
of traits.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_better.c">better.c</code></td>
<td>
<p>logical. A logical variable, if better.c is set to be TRUE,
the candidate individuals with GEBVs better than average for all the target
traits will comprise the candidate set. Otherwise, all the candidate
individuals will comprise the candidate set.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_npl.best">npl.best</code></td>
<td>
<p>integer. A integer indicates the numbers of the candidate
individuals with the top GEBV index will be retained. If npl.best is set to
be NULL, it will be 2 times the number of traits.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_weight">weight</code></td>
<td>
<p>vector. A vector with length t indicates the weights of target
traits in selection index. If weight is set to be NULL, the equal weight will
be assigned to all the target traits. The weights should be a positive number.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_direction">direction</code></td>
<td>
<p>vector. A vector with length t indicates the selecting
directions for target traits. The elements of direction are Inf, or -inf
representing the rule that the larger the better; or the smaller the better.
Or if the element is a number, it will select the individuals with the trait
value close to the number. If direction is set to be NULL, the selecting
direction will be the larger the better for all trait.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_outcross">outcross</code></td>
<td>
<p>logical. A logical variable, if outcross is set to be TRUE,
the crop is regarded as an outcross crop. The kinship matrix of dominance
effects are also considered in the model, and crossing and selection will be
performed in F1 generation. The detail can be seen in the references.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_nprog">nprog</code></td>
<td>
<p>integer. An integer indicates the number of progenies which
will be produced for each of the best individuals at every generation.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_nsele">nsele</code></td>
<td>
<p>integer. An integer indicates the number of the best individuals
which will be selected at each generation. If nsele is set to be NULL, the
number will be the same as the number of F1 individuals.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_ngen">ngen</code></td>
<td>
<p>integer. An integer indicates the number of generations in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_nrep">nrep</code></td>
<td>
<p>integer. An integer indicates the number of repetitions in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_cri">cri</code></td>
<td>
<p>integer. An integer indicates the stopping criterion, note that
cri &lt; 1e+06. The genetic algorithm will stop if the number of iterations
reaches cri.</p>
</td></tr>
<tr><td><code id="simu.GEBVGD_+3A_console">console</code></td>
<td>
<p>logical. A logical variable, if console is set to be TRUE,
the simulation process will be shown in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>method</code></td>
<td>
<p>The GEBV-GD strategy.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>The weights of target traits in selection index.</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>The selecting directions of target traits in selection index.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The mean vector of target traits.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation vector of target traits.</p>
</td></tr>
<tr><td><code>GEBV.value</code></td>
<td>
<p>The GEBVs of target traits in each generation and each
repetition.</p>
</td></tr>
<tr><td><code>parental.lines</code></td>
<td>
<p>The IDs and D-score of parental lines selected in
each repetition.</p>
</td></tr>
<tr><td><code>suggested.subset</code></td>
<td>
<p>The most frequently selected parental lines by this
strategy.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function output.best and output.gain can be used to summarize the result.
</p>
<p>The fitted value data in the input data can be obtained by the function
GBLUP.fit and mmer, that can be seen in the Examples shown below.
</p>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>


<h3>See Also</h3>

<p><code><a href="sommer.html#topic+mmer">mmer</a></code>
<code><a href="#topic+GBLUP.fit">GBLUP.fit</a></code>
<code><a href="#topic+GA.Dscore">GA.Dscore</a></code>
<code><a href="#topic+simu.gamete">simu.gamete</a></code>
<code><a href="#topic+simu.GEBVO">simu.GEBVO</a></code>
<code><a href="#topic+simu.GEBVGD">simu.GEBVGD</a></code>
<code><a href="#topic+output.best">output.best</a></code>
<code><a href="#topic+output.gain">output.gain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
t3 &lt;- NULL
t4 &lt;- NULL
t5 &lt;- NULL
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
fit &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
fitvalue &lt;- fit$fitted.value

geno.candidate &lt;- matrix(sample(c(1,-1), 300, replace = TRUE), 15, 20)

# run and output
result &lt;- simu.GEBVGD(fitvalue, geno.t = geno.test, marker = marker.test,
geno.c = geno.candidate, nprog = 5, nsele = 10, ngen = 5, nrep = 5, cri = 250)
result$suggested.subset



# other method: use mmer to obtain the fitted value
## Not run: 
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
phe &lt;- cbind(t1, t2)
nt &lt;- ncol(phe)
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
rownames(geno.test) &lt;- 1:nrow(geno.test)
id &lt;- rownames(geno.test)
K0 &lt;- geno.test%*%t(geno.test)/ncol(geno.test)

dat &lt;- data.frame(id, phe)
fit0 &lt;- sommer::mmer(cbind(t1, t2)~1,
      random = ~sommer::vsr(id, Gu = K0, Gtc = sommer::unsm(nt)),
      rcov = ~sommer::vsr(units, Gtc = sommer::unsm(nt)),
      data = dat,
      tolParInv = 0.1)

u0 &lt;- fit0$U$`u:id`
fit &lt;- matrix(unlist(u0), ncol = nt)
colnames(fit) &lt;- names(u0)

fit &lt;- fit+matrix(fit0$fitted[1,], nrow(fit), nt, byrow = TRUE)
fitvalue &lt;- fit[order(as.numeric(names((u0[[1]])))),]

## End(Not run)
</code></pre>

<hr>
<h2 id='simu.GEBVO'>Simulate Progeny with GEBV-O Strategy</h2><span id='topic+simu.GEBVO'></span>

<h3>Description</h3>

<p>Identify parental lines based on GEBV-O strategy and simulate their offsprings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu.GEBVO(
  fittedA.t,
  fittedD.t = NULL,
  fittedmu.t = NULL,
  geno.t,
  marker,
  geno.c = NULL,
  npl = NULL,
  weight = NULL,
  direction = NULL,
  outcross = FALSE,
  nprog = 50,
  nsele = NULL,
  ngen = 10,
  nrep = 30,
  console = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu.GEBVO_+3A_fitteda.t">fittedA.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the fitted values of each traits
of the training population. The missing value must have been already imputed.
If outcross is set to be TRUE, this argument must be the additive effect part
of fitted values.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_fittedd.t">fittedD.t</code></td>
<td>
<p>matrix. An n*t matrix denotes the dominance effect part of
fitted values when outcross is set to be TRUE. The missing value must have been
already imputed.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_fittedmu.t">fittedmu.t</code></td>
<td>
<p>numeric or vector. A p*1 vector denote the average value of
fitted values when outcross is set to be TRUE. The length must be the same as
the number of traits.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_geno.t">geno.t</code></td>
<td>
<p>matrix. An n*p matrix denotes the marker score matrix of the
training population. The markers must be coded as 1, 0, or -1 for alleles
AA, Aa, or aa. The missing value must have been already imputed.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_marker">marker</code></td>
<td>
<p>matrix. A p*2 matrix whose first column indicates the chromosome
number to which a marker belongs; and second column indicates the position of
the marker in centi-Morgan (cM).</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_geno.c">geno.c</code></td>
<td>
<p>matrix. An nc*p matrix denotes the marker score matrix of the
candidate population with nc individuals and p markers. It should be pure lines
and markers must be coded as 1, or -1 for alleles AA, or aa. The missing value
must have been already imputed. If geno.c is set to be NULL, the candidate
population is exactly the training population.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_npl">npl</code></td>
<td>
<p>integer. An integer indicates how many parental lines with the
top GEBV index will be chosen from each trait. If npl is set to be NULL, there
will be be 4 times the number of traits.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_weight">weight</code></td>
<td>
<p>vector. A vector with length t indicates the weights of target
traits in selection index. If weight is set to be NULL, the equal weight will
be assigned to all the target traits. The weights should be a positive number.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_direction">direction</code></td>
<td>
<p>vector. A vector with length t indicates the selecting
directions for target traits. The elements of direction are Inf, or -inf
representing the rule that the larger the better; or the smaller the better.
Or if the element is a number, it will select the individuals with the trait
value close to the number. If direction is set to be NULL, the selecting
direction will be the larger the better for all trait.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_outcross">outcross</code></td>
<td>
<p>logical. A logical variable, if outcross is set to be TRUE,
the crop is regarded as an outcross crop. The kinship matrix of dominance
effects are also considered in the model, and crossing and selection will be
performed in F1 generation. The detail can be seen in the references.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_nprog">nprog</code></td>
<td>
<p>integer. An integer indicates the number of progenies which
will be produced for each of the best individuals at every generation.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_nsele">nsele</code></td>
<td>
<p>integer. An integer indicates the number of the best individuals
which will be selected at each generation. If nsele is set to be NULL, the
number will be the same as the number of F1 individuals.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_ngen">ngen</code></td>
<td>
<p>integer. An integer indicates the number of generations in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_nrep">nrep</code></td>
<td>
<p>integer. An integer indicates the number of repetitions in the
simulation process.</p>
</td></tr>
<tr><td><code id="simu.GEBVO_+3A_console">console</code></td>
<td>
<p>logical. A logical variable, if console is set to be TRUE,
the simulation process will be shown in the R console.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>method</code></td>
<td>
<p>The GEBV-O strategy.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>The weights of target traits in selection index.</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>The selecting directions of target traits in selection index.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The mean vector of target traits.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>The standard deviation vector of target traits.</p>
</td></tr>
<tr><td><code>GEBV.value</code></td>
<td>
<p>The GEBVs of target traits in each generation and each
repetition.</p>
</td></tr>
<tr><td><code>parental.lines</code></td>
<td>
<p>The IDs and D-score of parental lines selected in
each repetition.</p>
</td></tr>
<tr><td><code>suggested.subset</code></td>
<td>
<p>The most frequently selected parental lines by this
strategy.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function output.best and output.gain can be used to summarize the result.
</p>
<p>The fitted value data in the input data can be obtained by the function
GBLUP.fit and mmer, that can be seen in the Examples shown below.
</p>


<h3>References</h3>

<p>Chung PY, Liao CT. 2020. Identification of superior parental lines for
biparental crossing via genomic prediction. PLoS ONE 15(12):e0243159.
</p>


<h3>See Also</h3>

<p><code><a href="sommer.html#topic+mmer">mmer</a></code>
<code><a href="#topic+GBLUP.fit">GBLUP.fit</a></code>
<code><a href="#topic+GA.Dscore">GA.Dscore</a></code>
<code><a href="#topic+simu.gamete">simu.gamete</a></code>
<code><a href="#topic+simu.GDO">simu.GDO</a></code>
<code><a href="#topic+simu.GEBVGD">simu.GEBVGD</a></code>
<code><a href="#topic+output.best">output.best</a></code>
<code><a href="#topic+output.gain">output.gain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simulated data
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
t3 &lt;- NULL
t4 &lt;- NULL
t5 &lt;- NULL
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
fit &lt;- GBLUP.fit(t1, t2, t3, t4, t5, geno = geno.test)
fitvalue &lt;- fit$fitted.value

geno.candidate &lt;- matrix(sample(c(1,-1), 300, replace = TRUE), 15, 20)

# run and output
result &lt;- simu.GEBVO(fitvalue, geno.t = geno.test, marker = marker.test,
geno.c = geno.candidate, nprog = 5, nsele = 10, ngen = 5, nrep = 5)
result$suggested.subset



# other method: use mmer to obtain the fitted value
## Not run: 
set.seed(6000)
geno.test &lt;- matrix(sample(c(1, -1), 200, replace = TRUE), 10, 20)
t1 &lt;- 5*geno.test[,3]+3*geno.test[,7]-geno.test[,11]+rnorm(10,30,10)
t2 &lt;- 3*geno.test[,3]+geno.test[,12]-2*geno.test[,18]+rnorm(10,10,5)
phe &lt;- cbind(t1, t2)
nt &lt;- ncol(phe)
marker.test &lt;- cbind(rep(1:2, each=10), rep(seq(0, 90, 10), 2))
rownames(geno.test) &lt;- 1:nrow(geno.test)
id &lt;- rownames(geno.test)
K0 &lt;- geno.test%*%t(geno.test)/ncol(geno.test)

dat &lt;- data.frame(id, phe)
fit0 &lt;- sommer::mmer(cbind(t1, t2)~1,
      random = ~sommer::vsr(id, Gu = K0, Gtc = sommer::unsm(nt)),
      rcov = ~sommer::vsr(units, Gtc = sommer::unsm(nt)),
      data = dat,
      tolParInv = 0.1)

u0 &lt;- fit0$U$`u:id`
fit &lt;- matrix(unlist(u0), ncol = nt)
colnames(fit) &lt;- names(u0)

fit &lt;- fit+matrix(fit0$fitted[1,], nrow(fit), nt, byrow = TRUE)
fitvalue &lt;- fit[order(as.numeric(names((u0[[1]])))),]

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
