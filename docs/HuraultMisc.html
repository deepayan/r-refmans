<!DOCTYPE html><html lang="en"><head><title>Help for package HuraultMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HuraultMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HuraultMisc-package'><p>HuraultMisc: Guillem Hurault Personal Functions' Library</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#approx_equal'><p>Approximate equal</p></a></li>
<li><a href='#cbbPalette'><p>A colorblind-friendly palette (with black)</p></a></li>
<li><a href='#change_colnames'><p>Change column names of a dataframe</p></a></li>
<li><a href='#compute_calibration'><p>Estimate calibration given forecasts and corresponding outcomes</p></a></li>
<li><a href='#compute_resolution'><p>Compute resolution of forecasts, normalised by the uncertainty</p></a></li>
<li><a href='#compute_RPS'><p>Compute RPS for a single forecast</p></a></li>
<li><a href='#coverage'><p>Coverage probability</p></a></li>
<li><a href='#empirical_pval'><p>Compute empirical p-values</p></a></li>
<li><a href='#extract_ci'><p>Extract confidence intervals from a vector of samples</p></a></li>
<li><a href='#extract_distribution'><p>Extract a distribution represented by samples</p></a></li>
<li><a href='#extract_draws'><p>Extract parameters' draws</p></a></li>
<li><a href='#extract_index_nd'><p>Extract multiple indices inside bracket(s) as a list</p></a></li>
<li><a href='#extract_parameters_from_draw'><p>Extract parameters from a single draw</p></a></li>
<li><a href='#extract_pdf'><p>Extract probability density function from vector of samples</p></a></li>
<li><a href='#extract_pmf'><p>Extract probability mass function from vector of samples</p></a></li>
<li><a href='#factor_to_numeric'><p>Change the type of the column of a dataframe from factor to numeric</p></a></li>
<li><a href='#illustrate_forward_chaining'><p>Illustration forward chaining</p></a></li>
<li><a href='#illustrate_RPS'><p>Illustration of the Ranked Probability Score</p></a></li>
<li><a href='#is_scalar'><p>Test whether x is of length 1</p></a></li>
<li><a href='#is_stanfit'><p>Test whether an object is of class &quot;stanfit&quot;</p></a></li>
<li><a href='#is_wholenumber'><p>Test whether x is a whole number</p></a></li>
<li><a href='#logit'><p>Logit and Inverse logit</p></a></li>
<li><a href='#post_pred_pval'><p>Posterior Predictive p-value</p></a></li>
<li><a href='#PPC_group_distribution'><p>Posterior Predictive Check for Stan model</p></a></li>
<li><a href='#prior_posterior'><p>Compare prior to posterior</p></a></li>
<li><a href='#process_replications'><p>Extract posterior predictive distribution</p></a></li>
<li><a href='#summary_statistics'><p>Extract summary statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Guillem Hurault Functions' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains various functions for data analysis, notably helpers and diagnostics for Bayesian modelling using Stan.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ghurault/HuraultMisc">https://github.com/ghurault/HuraultMisc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ghurault/HuraultMisc/issues">https://github.com/ghurault/HuraultMisc/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, reshape2, rstan, cowplot, Hmisc, stats, grDevices,
HDInterval, magrittr, dplyr, tidyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-02 16:23:44 UTC; gbh16</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillem Hurault <a href="https://orcid.org/0000-0002-1052-3564"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillem Hurault &lt;guillem.hurault@hotmail.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-06 08:20:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='HuraultMisc-package'>HuraultMisc: Guillem Hurault Personal Functions' Library</h2><span id='topic+HuraultMisc'></span><span id='topic+HuraultMisc-package'></span>

<h3>Description</h3>

<p>Contains various functions for data analysis, notably helpers and diagnostics for Bayesian modelling using Stan.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Guillem Hurault <a href="mailto:guillem.hurault@hotmail.fr">guillem.hurault@hotmail.fr</a> (<a href="https://orcid.org/0000-0002-1052-3564">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ghurault/HuraultMisc">https://github.com/ghurault/HuraultMisc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ghurault/HuraultMisc/issues">https://github.com/ghurault/HuraultMisc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='approx_equal'>Approximate equal</h2><span id='topic+approx_equal'></span><span id='topic++25~+25'></span>

<h3>Description</h3>

<p>Compute whether x and y are approximately equal given a tolerance level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_equal(x, y, tol = .Machine$double.eps^0.5)

x %~% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approx_equal_+3A_x">x</code></td>
<td>
<p>Numeric scalar.</p>
</td></tr>
<tr><td><code id="approx_equal_+3A_y">y</code></td>
<td>
<p>Numeric scalar.</p>
</td></tr>
<tr><td><code id="approx_equal_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>approx_equal(1, 1)
1 %~% (1 + 1e-16)
1 %~% 1.01
</code></pre>

<hr>
<h2 id='cbbPalette'>A colorblind-friendly palette (with black)</h2><span id='topic+cbbPalette'></span>

<h3>Description</h3>

<p>Shortcut for <code>c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbbPalette
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 8.
</p>


<h3>Source</h3>

<p><a href="http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/">Cookbook for R</a>
</p>

<hr>
<h2 id='change_colnames'>Change column names of a dataframe</h2><span id='topic+change_colnames'></span>

<h3>Description</h3>

<p>Change column names of a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_colnames(df, current_names, new_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="change_colnames_+3A_df">df</code></td>
<td>
<p>Dataframe</p>
</td></tr>
<tr><td><code id="change_colnames_+3A_current_names">current_names</code></td>
<td>
<p>Vector of column names to change.</p>
</td></tr>
<tr><td><code id="change_colnames_+3A_new_names">new_names</code></td>
<td>
<p>Vector of new names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with new column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(A = 1:2, B = 3:4, C = 5:6)
df &lt;- change_colnames(df, c("A", "C"), c("Aa", "Cc"))
</code></pre>

<hr>
<h2 id='compute_calibration'>Estimate calibration given forecasts and corresponding outcomes</h2><span id='topic+compute_calibration'></span>

<h3>Description</h3>

<p>Estimate calibration given forecasts and corresponding outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_calibration(
  forecast,
  outcome,
  method = c("smoothing", "binning"),
  CI = NULL,
  binwidth = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_calibration_+3A_forecast">forecast</code></td>
<td>
<p>Vector of probability forecasts.</p>
</td></tr>
<tr><td><code id="compute_calibration_+3A_outcome">outcome</code></td>
<td>
<p>Vector of observations (0 or 1).</p>
</td></tr>
<tr><td><code id="compute_calibration_+3A_method">method</code></td>
<td>
<p>Method used to estimate calibration, either &quot;smoothing&quot; or &quot;binning&quot;.</p>
</td></tr>
<tr><td><code id="compute_calibration_+3A_ci">CI</code></td>
<td>
<p>Confidence level (e.g. 0.95). CI not computed if NULL (CI can be expensive to compute for LOWESS).</p>
</td></tr>
<tr><td><code id="compute_calibration_+3A_binwidth">binwidth</code></td>
<td>
<p>Binwidth when calibration is estimated by binning.
If NULL, automatic bin width selection with 'Sturges' method.</p>
</td></tr>
<tr><td><code id="compute_calibration_+3A_...">...</code></td>
<td>
<p>Arguments of <code><a href="stats.html#topic+loess">stats::loess()</a></code> function (e.g. span)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns <code>Forecast</code> (bins), <code>Frequency</code> (frequency of outcomes in the bin),
<code>Lower</code> (lower bound of the CI) and <code>Upper</code> (upper bound of the CI).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 1e4
f &lt;- rbeta(N, 1, 1)
o &lt;- sapply(f, function(x) {rbinom(1, 1, x)})
lapply(c("binning", "smoothing"),
       function(m) {
         cal &lt;- compute_calibration(f, o, method = m)
         with(cal, plot(Forecast, Frequency, type = "l"))
         abline(c(0, 1), col = "red")
       })
</code></pre>

<hr>
<h2 id='compute_resolution'>Compute resolution of forecasts, normalised by the uncertainty</h2><span id='topic+compute_resolution'></span>

<h3>Description</h3>

<p>The resolution is computed as the mean squared distance to a base rate (reference forecast) and
is then normalised by the uncertainty (maximum resolution).
This means the output is between 0 and 1, 1 corresponding to the maximum resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_resolution(f, p0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_resolution_+3A_f">f</code></td>
<td>
<p>Vector of forecasts</p>
</td></tr>
<tr><td><code id="compute_resolution_+3A_p0">p0</code></td>
<td>
<p>Vector of base rate.
In the case rate is usually the prevalence of a uniform forecast (e.g. 1 / number of categories)
but can depend on the observation (hence the vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of resolution values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_resolution(seq(0, 1, .1), 0.5)
</code></pre>

<hr>
<h2 id='compute_RPS'>Compute RPS for a single forecast</h2><span id='topic+compute_RPS'></span>

<h3>Description</h3>

<p>Compute RPS for a single forecast
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_RPS(forecast, outcome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_RPS_+3A_forecast">forecast</code></td>
<td>
<p>Vector of length N (forecast).</p>
</td></tr>
<tr><td><code id="compute_RPS_+3A_outcome">outcome</code></td>
<td>
<p>Index of the true outcome (between 1 and N).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RPS (numeric scalar)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_RPS(c(.2, .5, .3), 2)
</code></pre>

<hr>
<h2 id='coverage'>Coverage probability</h2><span id='topic+coverage'></span><span id='topic+compute_coverage'></span><span id='topic+plot_coverage'></span>

<h3>Description</h3>

<p>Compute and plot coverage of CI for different confidence level.
Useful for fake data check.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_coverage(
  post_samples,
  truth,
  CI = seq(0, 1, 0.05),
  type = c("eti", "hdi")
)

plot_coverage(
  post_samples,
  truth,
  CI = seq(0, 1, 0.05),
  type = c("eti", "hdi")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coverage_+3A_post_samples">post_samples</code></td>
<td>
<p>Matrix of posterior samples. Rows represent a sample and columns represent variables.</p>
</td></tr>
<tr><td><code id="coverage_+3A_truth">truth</code></td>
<td>
<p>Vector of true parameter values (should be the same length as the number of columns in <code>post_samples</code>).</p>
</td></tr>
<tr><td><code id="coverage_+3A_ci">CI</code></td>
<td>
<p>Vector of confidence levels.</p>
</td></tr>
<tr><td><code id="coverage_+3A_type">type</code></td>
<td>
<p>Type of confidence intervals: either &quot;eti&quot; (equal-tailed intervals) or &quot;hdi&quot; (highest density intervals).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute_coverage</code> returns a Dataframe containing coverage (and 95% uncertainty interval for the coverage) for different confidence level (nominal coverage).
<code>plot_coverage</code> returns a ggplot of the coverage as the function of the nominal coverage with 95% uncertainty interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
N_post &lt;- 1e3
truth &lt;- rep(0, N)
post_samples &lt;- sapply(rnorm(N, 0, 1), function(x) {rnorm(N_post, x, 1)})

compute_coverage(post_samples, truth)
plot_coverage(post_samples, truth)
</code></pre>

<hr>
<h2 id='empirical_pval'>Compute empirical p-values</h2><span id='topic+empirical_pval'></span>

<h3>Description</h3>

<p>Compute empirical p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empirical_pval(t_rep, t, alternative = c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empirical_pval_+3A_t_rep">t_rep</code></td>
<td>
<p>Vector of samples from a distribution.</p>
</td></tr>
<tr><td><code id="empirical_pval_+3A_t">t</code></td>
<td>
<p>Observation (numeric scalar).</p>
</td></tr>
<tr><td><code id="empirical_pval_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Empirical p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>empirical_pval(rnorm(1e2), 2)
</code></pre>

<hr>
<h2 id='extract_ci'>Extract confidence intervals from a vector of samples</h2><span id='topic+extract_ci'></span>

<h3>Description</h3>

<p>Extract confidence intervals from a vector of samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ci(x, CI_level = seq(0.1, 0.9, 0.1), type = c("eti", "hdi"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_ci_+3A_x">x</code></td>
<td>
<p>Vector of samples from a distribution.</p>
</td></tr>
<tr><td><code id="extract_ci_+3A_ci_level">CI_level</code></td>
<td>
<p>Vector containing the level of the confidence/credible intervals.</p>
</td></tr>
<tr><td><code id="extract_ci_+3A_type">type</code></td>
<td>
<p>&quot;eti&quot; for equal-tailed intervals and &quot;hdi&quot; for highest density intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns: <code>Lower</code>, <code>Upper</code>, <code>Level.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp(1e4)
extract_ci(x, type = "eti")
extract_ci(x, type = "hdi")
</code></pre>

<hr>
<h2 id='extract_distribution'>Extract a distribution represented by samples</h2><span id='topic+extract_distribution'></span>

<h3>Description</h3>

<p>The distribution can be extracted as:
</p>

<ul>
<li><p> a probability density function (&quot;continuous&quot;).
</p>
</li>
<li><p> a probability mass function (&quot;discrete&quot;).
</p>
</li>
<li><p> a series of equal-tailed confidence/credible intervals (&quot;eti&quot;).
</p>
</li>
<li><p> a series of highest density confidence/credible intervals (&quot;hdi&quot;).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>extract_distribution(
  object,
  parName = "",
  type = c("continuous", "discrete", "eti", "hdi"),
  transform = identity,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_distribution_+3A_object">object</code></td>
<td>
<p>Object specifying the distribution as samples: can be a Stanfit object,
a matrix (columns represents parameters, rows samples) or a vector.</p>
</td></tr>
<tr><td><code id="extract_distribution_+3A_parname">parName</code></td>
<td>
<p>Name of the parameter to extract.</p>
</td></tr>
<tr><td><code id="extract_distribution_+3A_type">type</code></td>
<td>
<p>Indicates how the distribution is summarised.</p>
</td></tr>
<tr><td><code id="extract_distribution_+3A_transform">transform</code></td>
<td>
<p>Function to apply to the samples.</p>
</td></tr>
<tr><td><code id="extract_distribution_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="#topic+extract_pmf">extract_pmf()</a></code>, <code><a href="#topic+extract_pdf">extract_pdf()</a></code> or <code><a href="#topic+extract_ci">extract_ci()</a></code> depending on <code>type</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe
</p>


<h3>Alternative</h3>

<p>This function can notably be used to prepare the data for plotting fan charts when type = &quot;eti&quot; or &quot;hdi&quot;.
In that case, the <a href="https://mjskay.github.io/ggdist/"><code>ggdist</code></a> package offers an alternative with <code>ggdist::stat_lineribbon()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_draws">extract_draws()</a></code> for extracting draws of an object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_distribution(runif(1e2), type = "continuous", support = c(0, 1))
</code></pre>

<hr>
<h2 id='extract_draws'>Extract parameters' draws</h2><span id='topic+extract_draws'></span>

<h3>Description</h3>

<p>Extract parameters' draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_draws(obj, draws)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_draws_+3A_obj">obj</code></td>
<td>
<p>Array/Vector/Matrix of draws (cf. first dimension) or list of it.</p>
</td></tr>
<tr><td><code id="extract_draws_+3A_draws">draws</code></td>
<td>
<p>Vector of draws to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns: <code>Draw</code>, <code>Index</code>, <code>Value</code> and <code>Parameter</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1e3)
X &lt;- matrix(x, ncol = 10)
a &lt;- array(rnorm(80), dim = c(10, 2, 2, 2))
extract_draws(x, sample(1:length(x), 10))
extract_draws(X, sample(1:nrow(X), 10))
extract_draws(a, sample(1:10, 5))
extract_draws(list(x = x, X = X, a = a), 1:10)
</code></pre>

<hr>
<h2 id='extract_index_nd'>Extract multiple indices inside bracket(s) as a list</h2><span id='topic+extract_index_nd'></span>

<h3>Description</h3>

<p>Extract multiple indices inside bracket(s) as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_index_nd(x, dim_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_index_nd_+3A_x">x</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="extract_index_nd_+3A_dim_names">dim_names</code></td>
<td>
<p>Optional character vector of dimension names.
If <code>dim_names</code> is not NULL, if the elements of <code>x</code> don't have the same number of indices,
the missing indices will be set to NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns:
</p>

<ul>
<li> <p><code>Variable</code>, containing <code>x</code> where brackets have been removed
</p>
</li>
<li> <p><code>Index</code>, a list containing values within the brackets.
If <code>dim_names</code> is not NULL, <code>Index</code> is replaced by columns with names <code>dim_names</code> containing numeric values.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>extract_index_nd(c("sigma", "sigma[1]", "sigma[1, 1]", "sigma[1][2]"))
</code></pre>

<hr>
<h2 id='extract_parameters_from_draw'>Extract parameters from a single draw</h2><span id='topic+extract_parameters_from_draw'></span>

<h3>Description</h3>

<p>Extract parameters from a single draw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_parameters_from_draw(fit, param, draw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_parameters_from_draw_+3A_fit">fit</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
<tr><td><code id="extract_parameters_from_draw_+3A_param">param</code></td>
<td>
<p>Vector of parameter names.</p>
</td></tr>
<tr><td><code id="extract_parameters_from_draw_+3A_draw">draw</code></td>
<td>
<p>Index of the draw to extract the parameters from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe
</p>


<h3>Note</h3>

<p>Useful for to generate fake data.
</p>


<h3>Alternative</h3>

<p>The 'tidybayes' package offers an alternative to this function, for example:
</p>
<p><code>fit %&gt;% tidy_draws() %&gt;% gather_variables() %&gt;% filter(.draw == draw &amp; .variable %in% param)</code>
</p>
<p>However, the 'tidybayes' version is less efficient as all draws and parameters are extracted and then filtered (also the draw IDs are not the same).
Using 'tidybayes' would be more recommended when we only want to extract specific parameters,
and that it does not matter which draw are extracted (in that case using <code>tidybayes::spread_draws()</code>).
</p>

<hr>
<h2 id='extract_pdf'>Extract probability density function from vector of samples</h2><span id='topic+extract_pdf'></span>

<h3>Description</h3>

<p>Extract probability density function from vector of samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_pdf(x, support = NULL, n_density = 2^7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_pdf_+3A_x">x</code></td>
<td>
<p>Vector of samples from a distribution.</p>
</td></tr>
<tr><td><code id="extract_pdf_+3A_support">support</code></td>
<td>
<p>Vector of length 2 corresponding to the range of the distribution. Can be NULL.</p>
</td></tr>
<tr><td><code id="extract_pdf_+3A_n_density">n_density</code></td>
<td>
<p>Number of equally spaced points at which the density is to be estimated (better to use a power of 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns: <code>Value</code>, <code>Density.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_pdf(rnorm(1e4))
</code></pre>

<hr>
<h2 id='extract_pmf'>Extract probability mass function from vector of samples</h2><span id='topic+extract_pmf'></span>

<h3>Description</h3>

<p>Extract probability mass function from vector of samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_pmf(x, support = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_pmf_+3A_x">x</code></td>
<td>
<p>Vector of samples from a distribution.</p>
</td></tr>
<tr><td><code id="extract_pmf_+3A_support">support</code></td>
<td>
<p>Vector of all possible values that the distribution can take. Can be NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns: <code>Value</code>, <code>Probability.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_pmf(round(rnorm(1e4, 0, 10)))
</code></pre>

<hr>
<h2 id='factor_to_numeric'>Change the type of the column of a dataframe from factor to numeric</h2><span id='topic+factor_to_numeric'></span>

<h3>Description</h3>

<p>Change the type of the column of a dataframe from factor to numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_to_numeric(df, factor_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="factor_to_numeric_+3A_df">df</code></td>
<td>
<p>Dataframe.</p>
</td></tr>
<tr><td><code id="factor_to_numeric_+3A_factor_name">factor_name</code></td>
<td>
<p>Vector of names of factors to change to numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same dataframe with type of the given columns changed to numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(A = rep(1:5, each = 10))
df$A &lt;- factor(df$A)
df &lt;- factor_to_numeric(df, "A")
</code></pre>

<hr>
<h2 id='illustrate_forward_chaining'>Illustration forward chaining</h2><span id='topic+illustrate_forward_chaining'></span>

<h3>Description</h3>

<p>Illustration forward chaining
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate_forward_chaining(horizon = 7, n_it = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="illustrate_forward_chaining_+3A_horizon">horizon</code></td>
<td>
<p>Prediction horizon.</p>
</td></tr>
<tr><td><code id="illustrate_forward_chaining_+3A_n_it">n_it</code></td>
<td>
<p>Number of iterations to display.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>illustrate_forward_chaining()

</code></pre>

<hr>
<h2 id='illustrate_RPS'>Illustration of the Ranked Probability Score</h2><span id='topic+illustrate_RPS'></span>

<h3>Description</h3>

<p>Illustration of the RPS in the case of forecasts for a discrete &quot;Severity&quot; score, ranging from 0 to 10.
The forecast follow a (truncated between 0 and 10) Gaussian distribution, which is discretised to the nearest integer for RPS calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>illustrate_RPS(mu = 5, sigma = 1, observed = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="illustrate_RPS_+3A_mu">mu</code></td>
<td>
<p>Mean of the Gaussian forecast distribution.</p>
</td></tr>
<tr><td><code id="illustrate_RPS_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of the Gaussian forecast distribution.</p>
</td></tr>
<tr><td><code id="illustrate_RPS_+3A_observed">observed</code></td>
<td>
<p>Observed outcome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RPS is the mean square error between the cumulative outcome and cumulative forecast distribution (shaded are square).
The Ranked Probability Skill Score compares the RPS to a reference RPS (RPS0), <code>RPSS = 1 - RPS / RPS0</code>.
It can be interpreted as a normalised distance to a reference forecast:
RPSS = 0 means that the forecasts are not better than the reference and RPSS = 1 corresponds to perfect forecasts.
</p>


<h3>Value</h3>

<p>Ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>illustrate_RPS()

</code></pre>

<hr>
<h2 id='is_scalar'>Test whether x is of length 1</h2><span id='topic+is_scalar'></span>

<h3>Description</h3>

<p>Test whether x is of length 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_scalar(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_scalar_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_scalar(1) # TRUE
is_scalar("a") # TRUE
is_scalar(c(1, 2)) # FALSE
</code></pre>

<hr>
<h2 id='is_stanfit'>Test whether an object is of class &quot;stanfit&quot;</h2><span id='topic+is_stanfit'></span>

<h3>Description</h3>

<p>Test whether an object is of class &quot;stanfit&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stanfit(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_stanfit_+3A_obj">obj</code></td>
<td>
<p>Object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean
</p>

<hr>
<h2 id='is_wholenumber'>Test whether x is a whole number</h2><span id='topic+is_wholenumber'></span><span id='topic+is_scalar_wholenumber'></span>

<h3>Description</h3>


<ul>
<li> <p><code>is_wholenumber()</code> uses <code><a href="base.html#topic+Round">base::round()</a></code> to test whether <code>x</code> is a whole number,
it will therefore issue an error if <code>x</code> is not of mode numeric.
If used in <code><a href="base.html#topic+stopifnot">base::stopifnot()</a></code> for example, this won't be a problem but it may be in conditionals.
</p>
</li>
<li> <p><code>is_scalar_wholenumber()</code> comes with the additional argument <code>check_numeric</code>
to check whether <code>x</code> is a numeric before checking it is a whole number.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_wholenumber(x, tol = .Machine$double.eps^0.5)

is_scalar_wholenumber(x, check_numeric = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_wholenumber_+3A_x">x</code></td>
<td>
<p>Object to be tested</p>
</td></tr>
<tr><td><code id="is_wholenumber_+3A_tol">tol</code></td>
<td>
<p>Tolerance</p>
</td></tr>
<tr><td><code id="is_wholenumber_+3A_check_numeric">check_numeric</code></td>
<td>
<p>Whether to check whether <code>x</code> is a numeric</p>
</td></tr>
<tr><td><code id="is_wholenumber_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>is_wholenumber()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_wholenumber(1) # TRUE
is_wholenumber(1.0) # TRUE
is_wholenumber(1.1) # FALSE
is_scalar_wholenumber(1) # TRUE
is_scalar_wholenumber(c(1, 2)) # FALSE
</code></pre>

<hr>
<h2 id='logit'>Logit and Inverse logit</h2><span id='topic+logit'></span><span id='topic+inv_logit'></span>

<h3>Description</h3>

<p>Logit and Inverse logit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x)

inv_logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.5)
inv_logit(0)
</code></pre>

<hr>
<h2 id='post_pred_pval'>Posterior Predictive p-value</h2><span id='topic+post_pred_pval'></span>

<h3>Description</h3>

<p>Compute and plot posterior predictive p-value (Bayesian p-value) from samples of a distribution.
The simulations and observations are first summarised into a test statistics,
then the test statistic of the observations is compared to the test statistic of the empirical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_pred_pval(
  yrep,
  y,
  test_statistic = mean,
  alternative = c("two.sided", "less", "greater"),
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post_pred_pval_+3A_yrep">yrep</code></td>
<td>
<p>Matrix of posterior replications with rows corresponding to samples and columns to simulated observations.</p>
</td></tr>
<tr><td><code id="post_pred_pval_+3A_y">y</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="post_pred_pval_+3A_test_statistic">test_statistic</code></td>
<td>
<p>Function of the test statistic to compute the p-value for</p>
</td></tr>
<tr><td><code id="post_pred_pval_+3A_alternative">alternative</code></td>
<td>
<p>Indicates the alternative hypothesis: must be one of &quot;two.sided&quot;, &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="post_pred_pval_+3A_plot">plot</code></td>
<td>
<p>Whether to output a plot visualising the distribution of the test statistic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the p-value and (optionally) a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>post_pred_pval(matrix(rnorm(1e3), ncol = 10), rnorm(10))
</code></pre>

<hr>
<h2 id='PPC_group_distribution'>Posterior Predictive Check for Stan model</h2><span id='topic+PPC_group_distribution'></span>

<h3>Description</h3>

<p>Plot the distribution density of parameters within a same group from a single/multiple draw of the posterior distribution.
In the case of a hierarchical model, we might look at the distribution of patient parameter and compare it to the prior for the population distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPC_group_distribution(obj, parName = "", nDraws = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPC_group_distribution_+3A_obj">obj</code></td>
<td>
<p>Matrix (rows: samples, cols: parameter) or Stanfit object.</p>
</td></tr>
<tr><td><code id="PPC_group_distribution_+3A_parname">parName</code></td>
<td>
<p>Name of the observation-dependent (e.g. patient-dependent) parameter to consider (optional when <code>obj</code> is a matrix).</p>
</td></tr>
<tr><td><code id="PPC_group_distribution_+3A_ndraws">nDraws</code></td>
<td>
<p>Number of draws to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ggplot of the distribution
</p>


<h3>References</h3>

<p>'A. Gelman, J. B. B. Carlin, H. S. S. Stern, and D. B. B. Rubin, Bayesian Data Analysis (Chapter 6), Third Edition, 2014.'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(1e3), ncol = 10)
PPC_group_distribution(X, "", 10)
</code></pre>

<hr>
<h2 id='prior_posterior'>Compare prior to posterior</h2><span id='topic+prior_posterior'></span><span id='topic+combine_prior_posterior'></span><span id='topic+plot_prior_posterior'></span><span id='topic+compute_prior_influence'></span><span id='topic+plot_prior_influence'></span><span id='topic+check_model_sensitivity'></span>

<h3>Description</h3>


<ul>
<li> <p><code>combine_prior_posterior</code> subsets and binds the prior and posterior dataframes.
</p>
</li>
<li> <p><code>plot_prior_posterior</code> plots posterior CI alongside prior CI.
</p>
</li>
<li> <p><code>compute_prior_influence</code> computes diagnostics of how the posterior is influenced by the prior.
</p>
</li>
<li> <p><code>plot_prior_influence</code> plots diagnostics from <code>compute_prior_influence</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>combine_prior_posterior(prior, post, pars = NULL, match_exact = TRUE)

plot_prior_posterior(
  prior,
  post,
  pars = NULL,
  match_exact = TRUE,
  lb = "5%",
  ub = "95%"
)

compute_prior_influence(
  prior,
  post,
  pars = NULL,
  match_exact = TRUE,
  remove_index_prior = TRUE
)

plot_prior_influence(prior, post, pars = NULL, match_exact = TRUE)

check_model_sensitivity(prior, post, pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_posterior_+3A_prior">prior</code></td>
<td>
<p>Dataframe of prior parameter estimates.
The dataframe is expected to have columns <code>Variable</code>, <code>Mean.</code>
For <code>plot_prior_posterior()</code>, the columns <code style="white-space: pre;">&#8288;5%&#8288;</code> and <code style="white-space: pre;">&#8288;95%&#8288;</code> should also be present.
For <code>compute_prior_influence()</code> and <code>plot_prior_influence()</code>, the columns <code>Index</code> and <code>sd</code> should also be present.</p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_post">post</code></td>
<td>
<p>Dataframe of posterior parameter estimates, with same columns as <code>prior</code>.</p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_pars">pars</code></td>
<td>
<p>Vector of parameter names to plot. Defaults to all parameters presents in <code>post</code> and <code>prior.</code></p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_match_exact">match_exact</code></td>
<td>
<p>Logical indicating whether parameters should be matched exactly (e.g. <code>p</code> does not match <code style="white-space: pre;">&#8288;p\[1\]&#8288;</code>).</p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_lb">lb</code></td>
<td>
<p>Name of the column in <code>prior</code> and <code>post</code> corresponding to lower bound of error bar</p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_ub">ub</code></td>
<td>
<p>Name of the column in <code>prior</code> and <code>post</code> corresponding to upper bound of error bar</p>
</td></tr>
<tr><td><code id="prior_posterior_+3A_remove_index_prior">remove_index_prior</code></td>
<td>
<p>Whether to remove the index variable for <code>prior</code> except the first one.
This is useful if a parameter with multiple index have the same prior distribution
(e.g. with subject parameters, when <code>prior</code> does not contain as many subjects as post for computational reasons).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Posterior shrinkage (<code>PostShrinkage = 1 - Var(Post) / Var(Prior)</code>), capturing how much the model is learning.
Shrinkage near 0 indicates that the data provides little information beyond the prior.
Shrinkage near 1 indicates that the data is much more informative than the prior.
</p>
</li>
<li><p> 'Mahalanobis' distance between the mean posterior and the prior (<code>DistPrior</code>), capturing whether the prior &quot;includes&quot; the posterior.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>combine_prior_posterior</code> returns a dataframe with the same columns as in prior and post and a column <code>Distribution</code>.
</p>
</li>
<li> <p><code>compute_prior_influence</code> returns a dataframe with columns: <code>Variable</code>, <code>Index</code>, <code>PostShrinkage</code>, <code>DistPrior.</code>
</p>
</li>
<li> <p><code>plot_prior_posterior</code> and <code>plot_prior_influence</code> returns a ggplot object
</p>
</li></ul>



<h3>Note</h3>

<p>For <code>plot_prior_posterior</code>, parameters with the same name but different indices are plotted together.
If their prior distribution is the same, it can be useful to only keep one index in <code>prior</code>.
If not, we can use <code>match_exact = FALSE</code> to plot <code>parameter[1]</code> and <code>parameter[2]</code> separately.
</p>


<h3>References</h3>

<p><a href="https://betanalpha.github.io/assets/case_studies/principled_bayesian_workflow.html">M. Betancourt, “Towards a Principled Bayesian Workflow”</a>, 2018.
</p>

<hr>
<h2 id='process_replications'>Extract posterior predictive distribution</h2><span id='topic+process_replications'></span>

<h3>Description</h3>

<p>Extract posterior predictive distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_replications(
  fit,
  idx = NULL,
  parName,
  bounds = NULL,
  type = c("continuous", "discrete", "eti", "hdi"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_replications_+3A_fit">fit</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
<tr><td><code id="process_replications_+3A_idx">idx</code></td>
<td>
<p>Dataframe for translating the indices of the parameters into more informative variable (can be NULL).</p>
</td></tr>
<tr><td><code id="process_replications_+3A_parname">parName</code></td>
<td>
<p>Name of the parameter to extract.</p>
</td></tr>
<tr><td><code id="process_replications_+3A_bounds">bounds</code></td>
<td>
<p>NULL or vector of length 2 representing the bounds of the distribution if it needs to be truncated.</p>
</td></tr>
<tr><td><code id="process_replications_+3A_type">type</code></td>
<td>
<p>Indicates how the distribution is summarised.</p>
</td></tr>
<tr><td><code id="process_replications_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to <code><a href="#topic+extract_distribution">extract_distribution()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe.
</p>

<hr>
<h2 id='summary_statistics'>Extract summary statistics</h2><span id='topic+summary_statistics'></span>

<h3>Description</h3>

<p>Extract summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_statistics(fit, pars, probs = c(0.05, 0.25, 0.5, 0.75, 0.95))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_statistics_+3A_fit">fit</code></td>
<td>
<p>Stanfit object.</p>
</td></tr>
<tr><td><code id="summary_statistics_+3A_pars">pars</code></td>
<td>
<p>Character vector of parameters to extract. Defaults to all parameters.</p>
</td></tr>
<tr><td><code id="summary_statistics_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of quantiles to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of posterior summary statistics
</p>


<h3>Alternative</h3>

<p>The <a href="https://mjskay.github.io/tidybayes/">'tidybayes'</a> package offers an alternative to this function, for example:
<code>fit %&gt;% tidy_draws() %&gt;% gather_variables() %&gt;% mean_qi()</code>.
However, this does not provide information about <code>Rhat</code> or <code>Neff</code>, nor does it process the indexes.
The 'tidybayes' package is more useful for summarising the distribution of a handful of parameters (using <code>tidybayes::spread_draws()</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
