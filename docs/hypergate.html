<!DOCTYPE html><html lang="en"><head><title>Help for package hypergate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hypergate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boolmat'><p>boolmat</p></a></li>
<li><a href='#channels_contributions'><p>channels_contributions</p></a></li>
<li><a href='#color_biplot_by_discrete'><p>Colors a biplot according to a vector with discrete values</p></a></li>
<li><a href='#contract'><p>contract</p></a></li>
<li><a href='#contract.update'><p>contract.update</p></a></li>
<li><a href='#coreloop'><p>coreloop</p></a></li>
<li><a href='#en.locator'><p>Wrapper to locator that plots segments on the fly</p></a></li>
<li><a href='#expand'><p>expand</p></a></li>
<li><a href='#expand.update'><p>expand.update</p></a></li>
<li><a href='#f'><p>f</p></a></li>
<li><a href='#F_beta'><p>F_beta</p></a></li>
<li><a href='#fill_FNTN_matrix'><p>fill_FNTN_matrix</p></a></li>
<li><a href='#FNTN_matrix.recycle'><p>FNTN_matrix.recycle</p></a></li>
<li><a href='#gate_from_biplot'><p>gate_from_biplot</p></a></li>
<li><a href='#hgate_info'><p>hgate_info</p></a></li>
<li><a href='#hgate_pheno'><p>hgate_pheno</p></a></li>
<li><a href='#hgate_rule'><p>hgate_rule</p></a></li>
<li><a href='#hgate_sample'><p>hgate_sample</p></a></li>
<li><a href='#hypergate'><p>hypergate</p></a></li>
<li><a href='#plot_gating_strategy'><p>plot_gating_strategy</p></a></li>
<li><a href='#polygon.clean'><p>Remove self intersection in polygons</p></a></li>
<li><a href='#reoptimize_strategy'><p>reoptimize_strategy</p></a></li>
<li><a href='#Samusik_01_subset'><p>2000 events randomly sampled from the 'Samusik_01' dataset</p></a></li>
<li><a href='#subset_matrix_hg'><p>subset_matrix_hg</p></a></li>
<li><a href='#update_gate'><p>Updates a gate vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Machine Learning of Hyperrectangular Gating Strategies for
High-Dimensional Cytometry</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Given a high-dimensional dataset that typically represents a cytometry dataset, and a subset of the datapoints, this algorithm outputs an hyperrectangle so that datapoints within the hyperrectangle best correspond to the specified subset. In essence, this allows the conversion of clustering algorithms' outputs to gating strategies outputs.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, utils, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, flowCore, sp, sf</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 16:03:19 UTC; etienne</td>
</tr>
<tr>
<td>Author:</td>
<td>Etienne Becht [cre, aut],
  Samuel Granjeaud [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Etienne Becht &lt;etienne.becht@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-16 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boolmat'>boolmat</h2><span id='topic+boolmat'></span>

<h3>Description</h3>

<p>Convert an expression matrix and a gating strategy to a boolean matrix (whether each event is gated out by each channel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boolmat(gate, xp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boolmat_+3A_gate">gate</code></td>
<td>
<p>A return from hypergate</p>
</td></tr>
<tr><td><code id="boolmat_+3A_xp">xp</code></td>
<td>
<p>Expression matrix as in the hypergate callxp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0.01)
head(boolmat(hg,xp))
</code></pre>

<hr>
<h2 id='channels_contributions'>channels_contributions</h2><span id='topic+channels_contributions'></span>

<h3>Description</h3>

<p>Gives scores for the contribution of individual channels to a gating strategy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>channels_contributions(gate, xp, gate_vector, level, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="channels_contributions_+3A_gate">gate</code></td>
<td>
<p>A return from hypergate</p>
</td></tr>
<tr><td><code id="channels_contributions_+3A_xp">xp</code></td>
<td>
<p>Expression matrix as in the hypergate call</p>
</td></tr>
<tr><td><code id="channels_contributions_+3A_gate_vector">gate_vector</code></td>
<td>
<p>Categorical vector of length nrow(xp)</p>
</td></tr>
<tr><td><code id="channels_contributions_+3A_level">level</code></td>
<td>
<p>A level of gate_vector that identifies the population of interest</p>
</td></tr>
<tr><td><code id="channels_contributions_+3A_beta">beta</code></td>
<td>
<p>should be the same as for the hypergate object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0)
contribs=channels_contributions(gate=hg,xp=xp,gate_vector=gate_vector,level=23,beta=1)
contribs
</code></pre>

<hr>
<h2 id='color_biplot_by_discrete'>Colors a biplot according to a vector with discrete values</h2><span id='topic+color_biplot_by_discrete'></span>

<h3>Description</h3>

<p>Colors a biplot according to a vector with discrete values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_biplot_by_discrete(
  matrix,
  discrete_vector,
  ...,
  bty = "l",
  pch = 16,
  cex = 0.5,
  colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="color_biplot_by_discrete_+3A_matrix">matrix</code></td>
<td>
<p>a two columns matrix</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_discrete_vector">discrete_vector</code></td>
<td>
<p>a vector of size nrow(matrix)</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_...">...</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_bty">bty</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_pch">pch</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_cex">cex</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="color_biplot_by_discrete_+3A_colors">colors</code></td>
<td>
<p>Palette to used named after the unique elements of discrete_vector. Generated from rainbow() if missing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
levels=unique(sort(Samusik_01_subset$labels))
colors=setNames(colorRampPalette(palette())(length(levels)),sort(levels))
with(Samusik_01_subset,color_biplot_by_discrete(matrix=tsne,discrete_vector=labels,colors=colors))
</code></pre>

<hr>
<h2 id='contract'>contract</h2><span id='topic+contract'></span>

<h3>Description</h3>

<p>Test (some) possible contractions of the hyperrectangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(
  par = par,
  xp_pos = envir$xp_pos,
  state_pos = envir$state_pos,
  xp_neg = envir$xp_neg,
  state_neg = envir$state_neg,
  n = envir$n,
  TP = envir$TP,
  TN = envir$TN,
  beta = envir$beta2,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contract_+3A_par">par</code></td>
<td>
<p>Current parametrization of the hyperrectangle</p>
</td></tr>
<tr><td><code id="contract_+3A_xp_pos">xp_pos</code></td>
<td>
<p>Expression matrix for positive events</p>
</td></tr>
<tr><td><code id="contract_+3A_state_pos">state_pos</code></td>
<td>
<p>State vector of the positive events</p>
</td></tr>
<tr><td><code id="contract_+3A_xp_neg">xp_neg</code></td>
<td>
<p>Expression matrix for negative events</p>
</td></tr>
<tr><td><code id="contract_+3A_state_neg">state_neg</code></td>
<td>
<p>State vector of the negative events</p>
</td></tr>
<tr><td><code id="contract_+3A_n">n</code></td>
<td>
<p>passed to f</p>
</td></tr>
<tr><td><code id="contract_+3A_tp">TP</code></td>
<td>
<p>integer: current number of TP</p>
</td></tr>
<tr><td><code id="contract_+3A_tn">TN</code></td>
<td>
<p>integer: current number of TN</p>
</td></tr>
<tr><td><code id="contract_+3A_beta">beta</code></td>
<td>
<p>Passed from the top-level function</p>
</td></tr>
<tr><td><code id="contract_+3A_envir">envir</code></td>
<td>
<p>Current environment of the optimization</p>
</td></tr>
</table>

<hr>
<h2 id='contract.update'>contract.update</h2><span id='topic+contract.update'></span>

<h3>Description</h3>

<p>Update the hyperrectangle to the best contraction move found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract.update(
  contract_object,
  pars = envir$pars,
  active_channels = envir$active_channels,
  b_pos = envir$b_pos,
  b_neg = envir$b_neg,
  state_pos = envir$state_pos,
  state_neg = envir$state_neg,
  TN = envir$TN,
  TP = envir$TP,
  xp_pos = envir$xp_pos,
  xp_neg = envir$xp_neg,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contract.update_+3A_contract_object">contract_object</code></td>
<td>
<p>output of the contract function</p>
</td></tr>
<tr><td><code id="contract.update_+3A_pars">pars</code></td>
<td>
<p>Current parametrization of the hyperrectangle</p>
</td></tr>
<tr><td><code id="contract.update_+3A_active_channels">active_channels</code></td>
<td>
<p>vector of currently-used parameters</p>
</td></tr>
<tr><td><code id="contract.update_+3A_b_pos">b_pos</code></td>
<td>
<p>boolean matrix of positive events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_b_neg">b_neg</code></td>
<td>
<p>boolean matrix of negative events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_state_pos">state_pos</code></td>
<td>
<p>State vector of the positive events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_state_neg">state_neg</code></td>
<td>
<p>State vector of the negative events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_tn">TN</code></td>
<td>
<p>integer: current number of TN</p>
</td></tr>
<tr><td><code id="contract.update_+3A_tp">TP</code></td>
<td>
<p>integer: current number of TP</p>
</td></tr>
<tr><td><code id="contract.update_+3A_xp_pos">xp_pos</code></td>
<td>
<p>Expression matrix for positive events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_xp_neg">xp_neg</code></td>
<td>
<p>Expression matrix for negative events</p>
</td></tr>
<tr><td><code id="contract.update_+3A_envir">envir</code></td>
<td>
<p>Current environment of the optimization</p>
</td></tr>
</table>

<hr>
<h2 id='coreloop'>coreloop</h2><span id='topic+coreloop'></span>

<h3>Description</h3>

<p>Core optimization loop of hypergate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreloop(par, hg.env = hg.env$hg.env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coreloop_+3A_par">par</code></td>
<td>
<p>Current parametrization of the hyperrectangle</p>
</td></tr>
<tr><td><code id="coreloop_+3A_hg.env">hg.env</code></td>
<td>
<p>Environment where the main execution of hypergate takes place</p>
</td></tr>
</table>

<hr>
<h2 id='en.locator'>Wrapper to locator that plots segments on the fly</h2><span id='topic+en.locator'></span>

<h3>Description</h3>

<p>Wrapper to locator that plots segments on the fly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>en.locator()
</code></pre>

<hr>
<h2 id='expand'>expand</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>Test (some) possible expansions of the hyperrectangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(
  FN = envir$FN,
  FNTN_matrix = envir$FNTN_matrix,
  TP = envir$TP,
  TN = envir$TN,
  n = envir$n,
  beta = envir$beta2,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_+3A_fn">FN</code></td>
<td>
<p>integer: current number of FP</p>
</td></tr>
<tr><td><code id="expand_+3A_fntn_matrix">FNTN_matrix</code></td>
<td>
<p>Boolean matrix of dim (FN, FN + TN), where Mij is TRUE if and only if expanding to include the ith FN in the gate would lead to the inclusion of the jth column event</p>
</td></tr>
<tr><td><code id="expand_+3A_tp">TP</code></td>
<td>
<p>integer: current number of TP</p>
</td></tr>
<tr><td><code id="expand_+3A_tn">TN</code></td>
<td>
<p>integer: current number of TN</p>
</td></tr>
<tr><td><code id="expand_+3A_n">n</code></td>
<td>
<p>passed to f</p>
</td></tr>
<tr><td><code id="expand_+3A_beta">beta</code></td>
<td>
<p>Passed from the top-level function</p>
</td></tr>
<tr><td><code id="expand_+3A_envir">envir</code></td>
<td>
<p>Coreloop environment</p>
</td></tr>
</table>

<hr>
<h2 id='expand.update'>expand.update</h2><span id='topic+expand.update'></span>

<h3>Description</h3>

<p>Update the hyperrectangle to the best expansion move found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.update(
  expand.object,
  pars = envir$pars,
  xp_pos = envir$xp_pos,
  xp_neg = envir$xp_neg,
  state_pos = envir$state_pos,
  state_neg = envir$state_neg,
  b_pos = envir$b_pos,
  b_neg = envir$b_neg,
  n = envir$n,
  TP = envir$TP,
  TN = envir$TN,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand.update_+3A_expand.object">expand.object</code></td>
<td>
<p>output of the expand function</p>
</td></tr>
<tr><td><code id="expand.update_+3A_pars">pars</code></td>
<td>
<p>Current parametrization of the hyperrectangle</p>
</td></tr>
<tr><td><code id="expand.update_+3A_xp_pos">xp_pos</code></td>
<td>
<p>Expression matrix for positive events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_xp_neg">xp_neg</code></td>
<td>
<p>Expression matrix for negative events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_state_pos">state_pos</code></td>
<td>
<p>State vector of the positive events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_state_neg">state_neg</code></td>
<td>
<p>State vector of the negative events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_b_pos">b_pos</code></td>
<td>
<p>boolean matrix of positive events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_b_neg">b_neg</code></td>
<td>
<p>boolean matrix of negative events</p>
</td></tr>
<tr><td><code id="expand.update_+3A_n">n</code></td>
<td>
<p>passed to f</p>
</td></tr>
<tr><td><code id="expand.update_+3A_tp">TP</code></td>
<td>
<p>integer: current number of TP</p>
</td></tr>
<tr><td><code id="expand.update_+3A_tn">TN</code></td>
<td>
<p>integer: current number of TN</p>
</td></tr>
<tr><td><code id="expand.update_+3A_envir">envir</code></td>
<td>
<p>Current environment of the optimization</p>
</td></tr>
</table>

<hr>
<h2 id='f'>f</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>Computes the F_beta score given an intenger number of True Positives (TP), True Negatives (TN). It is optimized for speed and n is thus not the total number of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(TP, TN, n, beta2 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_tp">TP</code></td>
<td>
<p>Number of true positive events</p>
</td></tr>
<tr><td><code id="f_+3A_tn">TN</code></td>
<td>
<p>Number of true negative events</p>
</td></tr>
<tr><td><code id="f_+3A_n">n</code></td>
<td>
<p>beta^2*(TP+FN)+TN+FP</p>
</td></tr>
<tr><td><code id="f_+3A_beta2">beta2</code></td>
<td>
<p>squared-beta to weight precision (low beta) or recall (high beta) more</p>
</td></tr>
</table>

<hr>
<h2 id='F_beta'>F_beta</h2><span id='topic+F_beta'></span>

<h3>Description</h3>

<p>Compute a F_beta score comparing two boolean vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F_beta(pred, truth, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F_beta_+3A_pred">pred</code></td>
<td>
<p>boolean vector of predicted values</p>
</td></tr>
<tr><td><code id="F_beta_+3A_truth">truth</code></td>
<td>
<p>boolean vector of true values</p>
</td></tr>
<tr><td><code id="F_beta_+3A_beta">beta</code></td>
<td>
<p>Weighting of yield as compared to precision. Increase beta so that the optimization favors yield, or decrease to favor purity.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
truth=c(rep(TRUE,40),rep(FALSE,60))
pred=rep(c(TRUE,FALSE),50)
table(pred,truth) ##40% purity, 50% yield
#' F_beta(pred=pred,truth=truth,beta=2) ##Closer to yield
F_beta(pred=pred,truth=truth,beta=1.5) ##Closer to yield
F_beta(pred=pred,truth=truth,beta=1) ##Harmonic mean
F_beta(pred=pred,truth=truth,beta=0.75) ##Closer to purity
F_beta(pred=pred,truth=truth,beta=0.5) ##Closer to purity
</code></pre>

<hr>
<h2 id='fill_FNTN_matrix'>fill_FNTN_matrix</h2><span id='topic+fill_FNTN_matrix'></span>

<h3>Description</h3>

<p>fill_FNTN_matrix Used for assessing whether an expansion move is possible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_FNTN_matrix(xp_FN, xp_TN, B_FN, B_TN, par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_FNTN_matrix_+3A_xp_fn">xp_FN</code></td>
<td>
<p>Expression matrix of False Negative events</p>
</td></tr>
<tr><td><code id="fill_FNTN_matrix_+3A_xp_tn">xp_TN</code></td>
<td>
<p>Expression matrix of True Negative events</p>
</td></tr>
<tr><td><code id="fill_FNTN_matrix_+3A_b_fn">B_FN</code></td>
<td>
<p>Boolean matrix of FN events</p>
</td></tr>
<tr><td><code id="fill_FNTN_matrix_+3A_b_tn">B_TN</code></td>
<td>
<p>Boolean matrix of TN events</p>
</td></tr>
<tr><td><code id="fill_FNTN_matrix_+3A_par">par</code></td>
<td>
<p>Current hyper-rectangle parametrization</p>
</td></tr>
</table>

<hr>
<h2 id='FNTN_matrix.recycle'>FNTN_matrix.recycle</h2><span id='topic+FNTN_matrix.recycle'></span>

<h3>Description</h3>

<p>Recycle an expansion matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FNTN_matrix.recycle(
  FNTN_matrix,
  B_FN_old,
  B_TN_old,
  B_FN_new,
  B_TN_new,
  xp_FN,
  xp_TN,
  par
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FNTN_matrix.recycle_+3A_fntn_matrix">FNTN_matrix</code></td>
<td>
<p>Expansion matrix to recycle</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_b_fn_old">B_FN_old</code></td>
<td>
<p>Boolean matrix of FN events before the last expansion</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_b_tn_old">B_TN_old</code></td>
<td>
<p>Boolean matrix of TN events before the last expansion</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_b_fn_new">B_FN_new</code></td>
<td>
<p>Boolean matrix of FN events after the last expansion</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_b_tn_new">B_TN_new</code></td>
<td>
<p>Boolean matrix of TN events after the last expansion</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_xp_fn">xp_FN</code></td>
<td>
<p>Expression matrix of False Negative events</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_xp_tn">xp_TN</code></td>
<td>
<p>Expression matrix of True Negative events</p>
</td></tr>
<tr><td><code id="FNTN_matrix.recycle_+3A_par">par</code></td>
<td>
<p>Current hyper-rectangle parametrization</p>
</td></tr>
</table>

<hr>
<h2 id='gate_from_biplot'>gate_from_biplot</h2><span id='topic+gate_from_biplot'></span>

<h3>Description</h3>

<p>From a biplot let the user interactively draw polygons to create a &quot;Gate&quot; vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gate_from_biplot(
  matrix,
  x_axis,
  y_axis,
  ...,
  bty = "l",
  pch = 16,
  cex = 0.5,
  sample = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gate_from_biplot_+3A_matrix">matrix</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_x_axis">x_axis</code></td>
<td>
<p>character, colname of matrix used for x-axis in the biplot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_y_axis">y_axis</code></td>
<td>
<p>character, colname of matrix used for y-axis in the biplot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_...">...</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_bty">bty</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_pch">pch</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_cex">cex</code></td>
<td>
<p>passed to plot</p>
</td></tr>
<tr><td><code id="gate_from_biplot_+3A_sample">sample</code></td>
<td>
<p>Used to downsample the data in case there are too many events to plot quickly</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data will be displayed as a bi-plot according to user-specified x_axis and y_axis arguments, then a call to locator() is made. The user can draw a polygon around parts of the plot that need gating. When done, 'right-click' or 'escape' (depending on the IDE) escapes locator() and closes the polygon. Then the user can press &quot;n&quot; to draw another polygon (that will define a new population), &quot;c&quot; to cancell and draw the last polygon again, or &quot;s&quot; to exit. When exiting, events that do not fall within any polygon are assigned NA, the others are assigned an integer value corresponding to the last polygon they lie into.
</p>


<h3>Value</h3>

<p>A named vector of length nrow(matrix) and names rownames(matrix). Ungated events are set to NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
    ##See the details section to see how this function works
    gate_from_biplot(matrix=Samusik_01_subset$tsne,x_axis="tSNE1",y_axis="tSNE2")
}
</code></pre>

<hr>
<h2 id='hgate_info'>hgate_info</h2><span id='topic+hgate_info'></span>

<h3>Description</h3>

<p>Extract information about a hypergate return: the channels of
the phenotype, the sign of the channels, the sign of the comparison, the
thresholds. The function could also compute the Fscores if the xp,
gate_vector and level parameters are given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgate_info(hgate, xp, gate_vector, level, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgate_info_+3A_hgate">hgate</code></td>
<td>
<p>A hypergate object (produced by hypergate())</p>
</td></tr>
<tr><td><code id="hgate_info_+3A_xp">xp</code></td>
<td>
<p>The expression matrix from which the 'hgate' parameter originates,
needed for Fscore computation</p>
</td></tr>
<tr><td><code id="hgate_info_+3A_gate_vector">gate_vector</code></td>
<td>
<p>Categorical data from which the 'hgate' parameter
originates, needed for Fscore computation</p>
</td></tr>
<tr><td><code id="hgate_info_+3A_level">level</code></td>
<td>
<p>Level of gate_vector identifying the population of interest,
needed for Fscore computation</p>
</td></tr>
<tr><td><code id="hgate_info_+3A_beta">beta</code></td>
<td>
<p>Beta to weight purity (low beta) or yield (high beta) more,
needed for Fscore computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with channel, sign, comp and threshold columns, and
optionnally deltaF (score deterioration when parameter is ignored),Fscore1d (F_value when using only this parameter) and Fscore (F score when all parameters up to this one are included). Fscores are computed if xp, gate_vector
and level are passed to the function.
</p>


<h3>See Also</h3>

<p><code>hg_pheno</code>, <code>hg_rule</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0.01)
hgate_info(hgate=hg)
hgate_pheno(hgate=hg)
hgate_rule(hgate=hg)
</code></pre>

<hr>
<h2 id='hgate_pheno'>hgate_pheno</h2><span id='topic+hgate_pheno'></span>

<h3>Description</h3>

<p>Build a human readable phenotype, i.e. a combination of channels
and sign (+ or -) from a hypergate return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgate_pheno(hgate, collapse = ", ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgate_pheno_+3A_hgate">hgate</code></td>
<td>
<p>A hypergate object (produced by hypergate())</p>
</td></tr>
<tr><td><code id="hgate_pheno_+3A_collapse">collapse</code></td>
<td>
<p>A character string to separate the markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representing the phenotype.
</p>


<h3>See Also</h3>

<p><code>hg_rule</code>, <code>hg_info</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See hgate_info
</code></pre>

<hr>
<h2 id='hgate_rule'>hgate_rule</h2><span id='topic+hgate_rule'></span>

<h3>Description</h3>

<p>Build a human readable rule i.e. a combination of channels, sign
of comparison and threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgate_rule(hgate, collapse = ", ", digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgate_rule_+3A_hgate">hgate</code></td>
<td>
<p>A hypergate object (produced by hypergate())</p>
</td></tr>
<tr><td><code id="hgate_rule_+3A_collapse">collapse</code></td>
<td>
<p>A character string to separate the markers.</p>
</td></tr>
<tr><td><code id="hgate_rule_+3A_digits">digits</code></td>
<td>
<p>An integer that specifies the decimal part when rounding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with channel, sign, comp and threshold columns
</p>


<h3>See Also</h3>

<p><code>hg_pheno</code>, <code>hg_rule</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See hgate_info
</code></pre>

<hr>
<h2 id='hgate_sample'>hgate_sample</h2><span id='topic+hgate_sample'></span>

<h3>Description</h3>

<p>Downsample the data in order to fasten the computation and
reduce the memory usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hgate_sample(gate_vector, level, size = 1000, method = "prop")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hgate_sample_+3A_gate_vector">gate_vector</code></td>
<td>
<p>A Categorical vector whose length equals the number of
rows of the matrix to sample (nrow(xp))</p>
</td></tr>
<tr><td><code id="hgate_sample_+3A_level">level</code></td>
<td>
<p>A level of gate_vector so that gate_vector == level will produce
a boolean vector identifying events of interest</p>
</td></tr>
<tr><td><code id="hgate_sample_+3A_size">size</code></td>
<td>
<p>An integer specifying the maximum number of events of interest to
retain. If the count of events of interest is lower than <code>size</code>, than
<code>size</code> will be set to that count.</p>
</td></tr>
<tr><td><code id="hgate_sample_+3A_method">method</code></td>
<td>
<p>A string specifying the method to balance the count of events.
<code>"prop"</code> means proportionnality: if events of interest are sampled in
a 1/10 ratio, then all others events are sampled by the same ratio.
<code>"10x"</code> means a balance of 10 between the count events of interest and
the count all others events. <code>"ceil"</code> means a uniform sampling no more
than the specified size for each level of the gate_vector. <code>level</code> is
unused in that method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector with TRUE correspond to the events being sampled, ie
kept to further analysis
</p>


<h3>Note</h3>

<p>No replacement is applied. If there are less events in one group or the
alternate than the algorithm requires, then all available events are
returned. NA values in gate_vector are not sampled, ie ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Standard procedure with downsampling
data(Samusik_01_subset)
xp &lt;- Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector &lt;- Samusik_01_subset$labels
sampled &lt;- hgate_sample(gate_vector, level=8, 100)
table(sampled)
table(gate_vector[sampled])
xp_sampled &lt;- xp[sampled, ]
gate_vector_sampled &lt;- gate_vector[sampled]
hg &lt;- hypergate(xp_sampled, gate_vector_sampled, level=8, delta_add=0.01)
# cluster 8 consists in 122 events
table(gate_vector)
# Downsampling
table(gate_vector[hgate_sample(gate_vector, level=8, 100)])
# Downsampling reduces the alternate events
table(gate_vector[hgate_sample(gate_vector, level=8, 100, "10x")])
# Downsampling is limited to the maximum number of events of interest
table(gate_vector[hgate_sample(gate_vector, level=8, 150)])
# Downsampling is limited to the maximum number of events of interest, and
# the alternate events are downsampled to a total of 10 times
table(gate_vector[hgate_sample(gate_vector, level=8, 150, "10x")])
# More details about sampling
# Convert -1 to NA, NA are not sampled
gate_vector[gate_vector==-1] = NA
gate_vector = factor(gate_vector)
table(gate_vector, useNA = "alw")
#
# target size = 100 whereas initial freq is 122 for pop 8
smp.prop = hgate_sample(gate_vector, level = 8, size = 100, method = "prop")
smp.10x  = hgate_sample(gate_vector, level = 8, size = 100, method = "10x")
smp.ceil = hgate_sample(gate_vector, size = 10, method = "ceil")
table(smp.prop)
table(smp.10x)
table(smp.ceil)
rbind(raw = table(gate_vector),
      prop = table(gate_vector[smp.prop]),
      `10x` = table(gate_vector[smp.10x]),
      ceil = table(gate_vector[smp.ceil]))
#
# target size = 30 whereas initial freq is 25 for pop 14
smp.prop = hgate_sample(gate_vector, level = 14, size = 30, method = "prop")
smp.10x  = hgate_sample(gate_vector, level = 14, size = 30, method = "10x")
table(smp.prop)
table(smp.10x)
rbind(raw = table(gate_vector),
      prop = table(gate_vector[smp.prop]),
      `10x` = table(gate_vector[smp.10x]))
# prop returns original data, because target size ids larger than initial freq
# 10x  returns sampled data according to initial freq, such as the total amount
# of other events equals 10x initial freq of pop 14
</code></pre>

<hr>
<h2 id='hypergate'>hypergate</h2><span id='topic+hypergate'></span>

<h3>Description</h3>

<p>Finds a hyperrectangle gating around a population of interest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypergate(xp, gate_vector, level, delta_add = 0, beta = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hypergate_+3A_xp">xp</code></td>
<td>
<p>an Expression matrix</p>
</td></tr>
<tr><td><code id="hypergate_+3A_gate_vector">gate_vector</code></td>
<td>
<p>A Categorical vector of length nrow(xp)</p>
</td></tr>
<tr><td><code id="hypergate_+3A_level">level</code></td>
<td>
<p>A level of gate_vector so that gate_vector == level will produce a boolean vector identifying events of interest</p>
</td></tr>
<tr><td><code id="hypergate_+3A_delta_add">delta_add</code></td>
<td>
<p>If the increase in F after an optimization loop is lower than delta_add, the optimization will stop (may save computation time)</p>
</td></tr>
<tr><td><code id="hypergate_+3A_beta">beta</code></td>
<td>
<p>Purity / Yield trade-off</p>
</td></tr>
<tr><td><code id="hypergate_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Whether to print information about the optimization status.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+channels_contributions">channels_contributions</a></code> for ranking parameters within the output, <code><a href="#topic+reoptimize_strategy">reoptimize_strategy</a></code> for reoptimizing a output on a subset of the markers, <code><a href="#topic+plot_gating_strategy">plot_gating_strategy</a></code> for plotting an output, <code><a href="#topic+subset_matrix_hg">subset_matrix_hg</a></code> to apply the output to another input matrix, <code><a href="#topic+boolmat">boolmat</a></code> to obtain a boolean matrix stating which events are filtered out because of which markers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0.01)
</code></pre>

<hr>
<h2 id='plot_gating_strategy'>plot_gating_strategy</h2><span id='topic+plot_gating_strategy'></span>

<h3>Description</h3>

<p>Plot a hypergate return
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gating_strategy(
  gate,
  xp,
  gate_vector,
  level,
  cex = 0.5,
  highlight = "black",
  path = "./",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gating_strategy_+3A_gate">gate</code></td>
<td>
<p>A hypergate object (produced by hypergate())</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_xp">xp</code></td>
<td>
<p>The expression matrix from which the 'gate' parameter originates</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_gate_vector">gate_vector</code></td>
<td>
<p>Categorical data from which the 'gate' parameter originates</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_level">level</code></td>
<td>
<p>Level of gate_vector identifying the population of interest</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_cex">cex</code></td>
<td>
<p>size of dots</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_highlight">highlight</code></td>
<td>
<p>color of the positive population when plotting</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_path">path</code></td>
<td>
<p>Where png files will be produced</p>
</td></tr>
<tr><td><code id="plot_gating_strategy_+3A_...">...</code></td>
<td>
<p>passed to png</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0.01)
par(mfrow=c(1,ceiling(length(hg$active_channels)/2)))
plot_gating_strategy(gate=hg,xp=xp,gate_vector=gate_vector,level=23,highlight="red")
</code></pre>

<hr>
<h2 id='polygon.clean'>Remove self intersection in polygons</h2><span id='topic+polygon.clean'></span>

<h3>Description</h3>

<p>Remove self intersection in polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon.clean(poly)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygon.clean_+3A_poly">poly</code></td>
<td>
<p>a polygon (list with two components x and y which are equal-length numerical vectors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polygon without overlapping edges and new vertices corresponding to non-inner points of intersection
</p>

<hr>
<h2 id='reoptimize_strategy'>reoptimize_strategy</h2><span id='topic+reoptimize_strategy'></span>

<h3>Description</h3>

<p>Optimize a gating strategy given a manual selection of channels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reoptimize_strategy(
  gate,
  channels_subset,
  xp,
  gate_vector,
  level,
  beta = 1,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reoptimize_strategy_+3A_gate">gate</code></td>
<td>
<p>A return from hypergate</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_channels_subset">channels_subset</code></td>
<td>
<p>Character vector identifying the channels that will be retained (others are ignored). The form is e.g. c(&quot;CD4_min&quot;,&quot;CD8_max&quot;)</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_xp">xp</code></td>
<td>
<p>Expression matrix as in the hypergate call</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_gate_vector">gate_vector</code></td>
<td>
<p>Categorical vector as in the hypergate call</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_level">level</code></td>
<td>
<p>Level of gate_vector identifying the population of interest</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_beta">beta</code></td>
<td>
<p>Yield / purity trade-off</p>
</td></tr>
<tr><td><code id="reoptimize_strategy_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print information about optimization status</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0)
contribs=channels_contributions(gate=hg,xp=xp,gate_vector=gate_vector,level=23,beta=1)
significant_channels=names(contribs)[contribs&gt;=0.01]
hg_reoptimized=reoptimize_strategy(gate=hg,channels_subset=significant_channels,xp,gate_vector,23)
</code></pre>

<hr>
<h2 id='Samusik_01_subset'>2000 events randomly sampled from the 'Samusik_01' dataset</h2><span id='topic+Samusik_01_subset'></span>

<h3>Description</h3>

<p>2000 events randomly sampled from the 'Samusik_01' dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Samusik_01_subset
</code></pre>


<h3>Format</h3>

<p>list with four elements: fs_src (a flowSet), xp_src (its expression matrix), labels (manual gates of the events) and tsne (a tSNE projection of the dataset)
</p>


<h3>References</h3>

<p>https://flowrepository.org/id/FR-FCM-ZZPH
</p>

<hr>
<h2 id='subset_matrix_hg'>subset_matrix_hg</h2><span id='topic+subset_matrix_hg'></span>

<h3>Description</h3>

<p>Returns a boolean vector whose TRUE elements correspond to events inside the hyperrectangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_matrix_hg(gate, xp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_matrix_hg_+3A_gate">gate</code></td>
<td>
<p>a return from hypergate</p>
</td></tr>
<tr><td><code id="subset_matrix_hg_+3A_xp">xp</code></td>
<td>
<p>Expression matrix used for gate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Samusik_01_subset)
xp=Samusik_01_subset$xp_src[,Samusik_01_subset$regular_channels]
gate_vector=Samusik_01_subset$labels
hg=hypergate(xp=xp,gate_vector=gate_vector,level=23,delta_add=0.01)
gating_state=subset_matrix_hg(hg,xp)
gating_state=ifelse(gating_state,"Gated in","Gated out")
target=ifelse(gate_vector==23,"Target events","Others")
table(gating_state,target)
</code></pre>

<hr>
<h2 id='update_gate'>Updates a gate vector</h2><span id='topic+update_gate'></span>

<h3>Description</h3>

<p>Updates a gate vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_gate(xp, polygon, gate_vector = rep(0, nrow(xp)), value = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_gate_+3A_xp">xp</code></td>
<td>
<p>A two colums matrix</p>
</td></tr>
<tr><td><code id="update_gate_+3A_polygon">polygon</code></td>
<td>
<p>A list with two components x and y of equal lenghts and numeric values</p>
</td></tr>
<tr><td><code id="update_gate_+3A_gate_vector">gate_vector</code></td>
<td>
<p>a vector of length nrow(xp) with integer values</p>
</td></tr>
<tr><td><code id="update_gate_+3A_value">value</code></td>
<td>
<p>The number that will be assigned to gate_vector, corresponding to points that lie in the polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated gate_vector
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
