<!DOCTYPE html><html><head><title>Help for package dgpsi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dgpsi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alm'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using ALM</p></a></li>
<li><a href='#combine'><p>Combine layers</p></a></li>
<li><a href='#continue'><p>Continue the training of a DGP emulator</p></a></li>
<li><a href='#design'><p>Sequential design of a (D)GP emulator or a bundle of (D)GP emulators</p></a></li>
<li><a href='#dgp'><p>Deep Gaussian process emulator construction</p></a></li>
<li><a href='#draw'><p>Validation plots of a sequential design</p></a></li>
<li><a href='#gp'><p>Gaussian process emulator construction</p></a></li>
<li><a href='#Hetero'><p>Initialize a heteroskedastic Gaussian likelihood node</p></a></li>
<li><a href='#init_py'><p>'python' environment initialization</p></a></li>
<li><a href='#kernel'><p>Initialize a Gaussian process node</p></a></li>
<li><a href='#lgp'><p>Linked (D)GP emulator construction</p></a></li>
<li><a href='#mice'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using MICE</p></a></li>
<li><a href='#NegBin'><p>Initialize a negative Binomial likelihood node</p></a></li>
<li><a href='#nllik'><p>Calculate negative predicted log-likelihood</p></a></li>
<li><a href='#pack'><p>Pack GP and DGP emulators into a bundle</p></a></li>
<li><a href='#pei'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using PEI</p></a></li>
<li><a href='#plot'><p>Validation plots of a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#Poisson'><p>Initialize a Poisson likelihood node</p></a></li>
<li><a href='#predict'><p>Predictions from GP, DGP, or linked (D)GP emulators</p></a></li>
<li><a href='#prune'><p>Static pruning of a DGP emulator</p></a></li>
<li><a href='#read'><p>Load the stored emulator</p></a></li>
<li><a href='#set_imp'><p>Reset number of imputations for a DGP emulator</p></a></li>
<li><a href='#set_linked_idx'><p>Set linked indices</p></a></li>
<li><a href='#set_seed'><p>Random seed generator</p></a></li>
<li><a href='#summary'><p>Summary of a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#trace_plot'><p>Plot of DGP model parameter traces</p></a></li>
<li><a href='#unpack'><p>Unpack a bundle of (D)GP emulators</p></a></li>
<li><a href='#update'><p>Update a GP or DGP emulator</p></a></li>
<li><a href='#validate'><p>Validate a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#vigf'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using VIGF</p></a></li>
<li><a href='#window'><p>Trim the sequences of model parameters of a DGP emulator</p></a></li>
<li><a href='#write'><p>Save the constructed emulator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'dgpsi' for Deep and Linked Gaussian Process
Emulations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deyu Ming &lt;deyu.ming.16@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to the 'python' package 'dgpsi' for Gaussian process, deep Gaussian process, 
             and linked deep Gaussian process emulations of computer models and networks using stochastic imputation (SI). 
             The implementations follow Ming &amp; Guillas (2021) &lt;<a href="https://doi.org/10.1137%2F20M1323771">doi:10.1137/20M1323771</a>&gt; and 
             Ming, Williamson, &amp; Guillas (2023) &lt;<a href="https://doi.org/10.1080%2F00401706.2022.2124311">doi:10.1080/00401706.2022.2124311</a>&gt; and 
             Ming &amp; Williamson (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2306.01212">doi:10.48550/arXiv.2306.01212</a>&gt;. To get started with the package, 
             see <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mingdeyu/dgpsi-R">https://github.com/mingdeyu/dgpsi-R</a>,
<a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mingdeyu/dgpsi-R/issues">https://github.com/mingdeyu/dgpsi-R/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate (&ge; 1.26), benchmarkme (&ge; 1.0.8), utils, ggplot2,
ggforce, reshape2, patchwork, lhs, methods, stats, bitops,
clhs, dplyr, uuid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MASS, R.utils, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-14 11:51:41 UTC; deyu</td>
</tr>
<tr>
<td>Author:</td>
<td>Deyu Ming [aut, cre, cph],
  Daniel Williamson [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-14 12:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='alm'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using ALM</h2><span id='topic+alm'></span><span id='topic+alm.gp'></span><span id='topic+alm.dgp'></span><span id='topic+alm.bundle'></span>

<h3>Description</h3>

<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Active Learning MacKay (ALM), see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alm(object, x_cand, ...)

## S3 method for class 'gp'
alm(object, x_cand, batch_size = 1, workers = 1, ...)

## S3 method for class 'dgp'
alm(
  object,
  x_cand,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
alm(
  object,
  x_cand,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alm_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="alm_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class, <code>x_cand</code> could also
be a list with the length equal to the number of emulators contained in the <code>object</code>. Each slot in <code>x_cand</code> is a matrix
that gives a candidate set for each emulator included in the bundle. See <em>Note</em> section below for further information.</p>
</td></tr>
<tr><td><code id="alm_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+alm">alm()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="alm_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_workers">workers</code></td>
<td>
<p>the number of workers/cores to be used for the criterion calculation. If set to <code>NULL</code>,
the number of workers is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the criterion calculation for a DGP emulator.
Turning this option on could improve the speed of criterion calculations when the DGP emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.</p>
</td></tr>
<tr><td><code id="alm_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the ALM across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregations of scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable the aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, a vector is returned with the length equal to <code>batch_size</code>, giving the positions (i.e., row numbers)
of next design points from <code>x_cand</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to one (if <code>aggregate</code>
is not <code>NULL</code>) or the output dimension (if <code>aggregate</code> is <code>NULL</code>), giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added
to the DGP emulator across different outputs. If <code>object</code> is a DGP emulator with either <code>Hetero</code> or <code>NegBin</code> likelihood layer, the returned matrix has
two columns with the first column giving positions of next design points from <code>x_cand</code> that correspond to the mean parameter of the normal or negative Binomial
distribution, and the second column giving positions of next design points from <code>x_cand</code> that correspond to the variance parameter of the normal distribution or
the dispersion parameter of the negative Binomial distribution.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to the number of
emulators in the bundle, giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added to individual emulators.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The column order of the first argument of <code>aggregate</code> must be consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the
<code>dgp</code> class), or the order of emulators placed in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class;
</p>
</li>
<li><p> If <code>x_cand</code> is supplied as a list when <code>object</code> is an instance of <code>bundle</code> class and a <code>aggregate</code> function is provided, the matrices in <code>x_cand</code> must have
common rows (i.e., the candidate sets of emulators in the bundle have common input locations) so the <code>aggregate</code> function can be applied.
</p>
</li>
<li><p> Any R vector detected in <code>x_cand</code> will be treated as a column vector and automatically converted into a single-column
R matrix.
</p>
</li></ul>



<h3>References</h3>

<p>MacKay, D. J. (1992). Information-based objective functions for active data selection. <em>Neural Computation</em>, <strong>4(4)</strong>, 590-604.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# generate a candidate set
x_cand &lt;- maximinLHS(200,1)

# locate the next design point using ALM
next_point &lt;- alm(m, x_cand = x_cand)
X_new &lt;- x_cand[next_point,,drop = F]

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit with 500 training iterations
m &lt;- update(m, X, Y, refit = TRUE, N = 500)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine'>Combine layers</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>This function combines customized layers into a DGP or linked (D)GP structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>a sequence of lists:
</p>

<ol>
<li><p> For DGP emulations, each list represents a DGP layer and contains GP nodes (produced by <code><a href="#topic+kernel">kernel()</a></code>), or
likelihood nodes (produced by <code><a href="#topic+Poisson">Poisson()</a></code>, <code><a href="#topic+Hetero">Hetero()</a></code>, or <code><a href="#topic+NegBin">NegBin()</a></code>).
</p>
</li>
<li><p> For linked (D)GP emulations, each list represents a system layer and contains emulators (produced by <code><a href="#topic+gp">gp()</a></code> or
<code><a href="#topic+dgp">dgp()</a></code>) in that layer.
</p>
</li></ol>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A list defining a DGP structure (for <code>struc</code> of <code><a href="#topic+dgp">dgp()</a></code>) or a linked (D)GP structure
(for <code>struc</code> for <code><a href="#topic+lgp">lgp()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='continue'>Continue the training of a DGP emulator</h2><span id='topic+continue'></span>

<h3>Description</h3>

<p>This function implements additional training iterations for a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(
  object,
  N = 500,
  cores = 1,
  ess_burn = 10,
  verb = TRUE,
  burnin = NULL,
  B = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class.</p>
</td></tr>
<tr><td><code id="continue_+3A_n">N</code></td>
<td>
<p>additional number of iterations for the DGP emulator training. Defaults to <code>500</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_cores">cores</code></td>
<td>
<p>the number of cores/workers to be used to optimize GP components (in the same layer)
at each M-step of the training. If set to <code>NULL</code>, the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>.
Only use multiple cores when there is a large number of GP components in different layers and optimization of GP components
is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for the ESS-within-Gibbs
at each I-step of the training. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the progress bar will be printed during the training:
</p>

<ol>
<li> <p><code>FALSE</code>: the training progress bar will not be displayed.
</p>
</li>
<li> <p><code>TRUE</code>: the training progress bar will be displayed.
</p>
</li></ol>

<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_burnin">burnin</code></td>
<td>
<p>the number of training iterations to be discarded for
point estimates calculation. Must be smaller than the overall training iterations
so-far implemented. If this is not specified, only the last 25% of iterations
are used. This overrides the value of <code>burnin</code> set in <code><a href="#topic+dgp">dgp()</a></code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce the predictions. Increase the value to account for
more imputation uncertainties. This overrides the value of <code>B</code> set in <code><a href="#topic+dgp">dgp()</a></code> if <code>B</code> is not
<code>NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> One can also use this function to fit an untrained DGP emulator constructed by <code><a href="#topic+dgp">dgp()</a></code> with <code>training = FALSE</code>.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='design'>Sequential design of a (D)GP emulator or a bundle of (D)GP emulators</h2><span id='topic+design'></span><span id='topic+design.gp'></span><span id='topic+design.dgp'></span><span id='topic+design.bundle'></span>

<h3>Description</h3>

<p>This function implements the sequential design of a (D)GP emulator or a bundle of (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(
  object,
  N,
  x_cand,
  y_cand,
  n_cand,
  limits,
  int,
  f,
  reps,
  freq,
  x_test,
  y_test,
  reset,
  target,
  method,
  eval,
  verb,
  autosave,
  new_wave,
  cores,
  ...
)

## S3 method for class 'gp'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  int = FALSE,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  cores = 1,
  ...
)

## S3 method for class 'dgp'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  int = FALSE,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  cores = 1,
  train_N = 100,
  refit_cores = 1,
  pruning = TRUE,
  control = list(),
  ...
)

## S3 method for class 'bundle'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_cand = 200,
  limits = NULL,
  int = FALSE,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  cores = 1,
  train_N = 100,
  refit_cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="design_+3A_n">N</code></td>
<td>
<p>the number of steps for the sequential design.</p>
</td></tr>
<tr><td><code id="design_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
in which the next design point is determined. If <code>x_cand = NULL</code>, the candidate set will be generated using <code>n_cand</code>,
<code>limits</code>, and <code>int</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_y_cand">y_cand</code></td>
<td>
<p>a matrix (with each row being a simulator evaluation and column being an output dimension) that gives the realizations
from the simulator at input positions in <code>x_cand</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_n_cand">n_cand</code></td>
<td>
<p>an integer that gives
</p>

<ul>
<li><p> the size of the candidate set in which the next design point is determined, if <code>x_cand = NULL</code>;
</p>
</li>
<li><p> the size of a sub-set to be sampled from the candidate set <code>x_cand</code> at each step of the sequential design to determine the next
design point, if <code>x_cand</code> is not <code>NULL</code>.
</p>
</li></ul>

<p>Defaults to <code>200</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_limits">limits</code></td>
<td>
<p>a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one
input dimension. If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input
dimensions, and its first and second columns correspond to the minimum and maximum values of the input dimensions. Set
<code>limits = NULL</code> if <code>x_cand</code> is supplied. This argument is only used when <code>x_cand</code> is not supplied, i.e., <code>x_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_int">int</code></td>
<td>
<p>a bool or a vector of bools that indicates if an input dimension is an integer type. If a bool is given, it will be applied to
all input dimensions. If a vector is provided, it should have a length equal to the input dimensions and will be applied to individual
input dimensions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_f">f</code></td>
<td>
<p>an R function that represents the simulator. <code>f</code> needs to be specified with the following basic rules:
</p>

<ul>
<li><p> the first argument of the function should be a matrix with rows being different design points and columns being input dimensions.
</p>
</li>
<li><p> the output of the function can either
</p>

<ul>
<li><p> a matrix with rows being different outputs (corresponding to the input design points) and columns being output dimensions. If there is
only one output dimension, the matrix still needs to be returned with a single column.
</p>
</li>
<li><p> a list with the first element being the output matrix described above and, optionally, additional named elements which will update values
of any arguments with the same names passed via <code>...</code>. The list output can be useful if some additional arguments of <code>f</code> and <code>aggregate</code>
need to be updated after each step of the sequential design.
</p>
</li></ul>

</li></ul>

<p>See <em>Note</em> section below for further information. This argument is used when <code>y_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_reps">reps</code></td>
<td>
<p>an integer that gives the number of repetitions of the located design points to be created and used for evaluations of <code>f</code>. Set the
argument to an integer greater than <code>1</code> if <code>f</code> is a stochastic function that can generate different responses given a same input and the
supplied emulator <code>object</code> can deal with stochastic responses, e.g., a (D)GP emulator with <code>nugget_est = TRUE</code> or a DGP emulator with a
likelihood layer. The argument is only used when <code>f</code> is supplied. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_freq">freq</code></td>
<td>
<p>a vector of two integers with the first element giving the frequency (in number of steps) to re-fit the
emulator, and the second element giving the frequency to implement the emulator validation (for RMSE). Defaults to <code>c(1, 1)</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_x_test">x_test</code></td>
<td>
<p>a matrix (with each row being an input testing data point and each column being an input dimension) that gives the testing
input data to evaluate the emulator after each step of the sequential design. Set to <code>NULL</code> for the LOO-based emulator validation.
Defaults to <code>NULL</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_y_test">y_test</code></td>
<td>
<p>the testing output data that correspond to <code>x_test</code> for the emulator validation after each step of the sequential design:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> class, <code>y_test</code> is a matrix with only one column and each row being an testing output data point.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>dgp</code> class, <code>y_test</code> is a matrix with its rows being testing output data points and columns being
output dimensions.
</p>
</li></ul>

<p>Set to <code>NULL</code> for the LOO-based emulator validation. Defaults to <code>NULL</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_reset">reset</code></td>
<td>
<p>a bool or a vector of bools indicating whether to reset hyperparameters of the emulator to their initial values when it was initially
constructed after the input-output update and before the re-fit. If a bool is given, it will be applied to
every step of the sequential design. If a vector is provided, its length should be equal to <code>N</code> and will be applied to individual
steps of the sequential design. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_target">target</code></td>
<td>
<p>a numeric or a vector that gives the target RMSEs at which the sequential design is terminated. Defaults to <code>NULL</code>, in which
case the sequential design stops after <code>N</code> steps. See <em>Note</em> section below for further information about <code>target</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_method">method</code></td>
<td>
<p>an R function that give indices of designs points in a candidate set. The function must satisfy the following basic rules:
</p>

<ul>
<li><p> the first argument is an emulator object that can be either an instance of
</p>

<ul>
<li><p> the <code>gp</code> class (produced by <code><a href="#topic+gp">gp()</a></code>);
</p>
</li>
<li><p> the <code>dgp</code> class (produced by <code><a href="#topic+dgp">dgp()</a></code>);
</p>
</li>
<li><p> the <code>bundle</code> class (produced by <code><a href="#topic+pack">pack()</a></code>).
</p>
</li></ul>

</li>
<li><p> the second argument is a matrix with rows representing a set of different design points.
</p>
</li>
<li><p> the output of the function
</p>

<ul>
<li><p> is a vector of indices if the first argument is an instance of the <code>gp</code> class;
</p>
</li>
<li><p> is a matrix of indices if the first argument is an instance of the <code>dgp</code> class. If there are different design points to be added with
respect to different outputs of the DGP emulator, the column number of the matrix should equal to the number of the outputs. If design
points are common to all outputs of the DGP emulator, the matrix should be single-columned. If more than one design points are determined
for a given output or for all outputs, the indices of these design points are placed in the matrix with extra rows.
</p>
</li>
<li><p> is a matrix of indices if the first argument is an instance of the <code>bundle</code> class. Each row of the matrix gives the indices of the design
points to be added to individual emulators in the bundle.
</p>
</li></ul>

</li></ul>

<p>See <code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, <code><a href="#topic+pei">pei()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> for examples on customizing <code>method</code>. Defaults to <code><a href="#topic+vigf">vigf()</a></code>.</p>
</td></tr>
<tr><td><code id="design_+3A_eval">eval</code></td>
<td>
<p>an R function that calculates the customized evaluating metric of the emulator. The function must satisfy the following basic rules:
</p>

<ul>
<li><p> the first argument is an emulator object that can be either an instance of
</p>

<ul>
<li><p> the <code>gp</code> class (produced by <code><a href="#topic+gp">gp()</a></code>);
</p>
</li>
<li><p> the <code>dgp</code> class (produced by <code><a href="#topic+dgp">dgp()</a></code>);
</p>
</li>
<li><p> the <code>bundle</code> class (produced by <code><a href="#topic+pack">pack()</a></code>).
</p>
</li></ul>

</li>
<li><p> the output of the function can be
</p>

<ul>
<li><p> a single metric value, if the first argument is an instance of the <code>gp</code> class;
</p>
</li>
<li><p> a single metric value or a vector of metric values with the length equal to the number of output dimensions, if the first argument is an
instance of the <code>dgp</code> class;
</p>
</li>
<li><p> a single metric value metric or a vector of metric values with the length equal to the number of emulators in the bundle, if the first
argument is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li></ul>

<p>If no customized function is provided, the built-in evaluation metric, RMSE, will be calculated. Defaults to <code>NULL</code>. See <em>Note</em> section below for further information.</p>
</td></tr>
<tr><td><code id="design_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information will be printed during the sequential design.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_autosave">autosave</code></td>
<td>
<p>a list that contains configuration settings for the automatic saving of the emulator:
</p>

<ul>
<li> <p><code>switch</code>: a bool indicating whether to enable the automatic saving of the emulator during the sequential design. When set to <code>TRUE</code>,
the emulator in the final iteration is always saved. Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>directory</code>: a string specifying the directory path where the emulators will be stored. Emulators will be stored in a sub-directory
of <code>directory</code> named 'emulator-<code>id</code>'. Defaults to './check_points'.
</p>
</li>
<li> <p><code>fname</code>: a string representing the base name for the saved emulator files. Defaults to 'check_point'.
</p>
</li>
<li> <p><code>freq</code>: an integer indicating the frequency of automatic savings, measured in the number of iterations. Defaults to <code>5</code>.
</p>
</li>
<li> <p><code>overwrite</code>: a bool value controlling the file saving behavior. When set to <code>TRUE</code>, each new automatic saving overwrites the previous one,
keeping only the latest version. If <code>FALSE</code>, each automatic saving creates a new file, preserving all previous versions. Defaults to <code>FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="design_+3A_new_wave">new_wave</code></td>
<td>
<p>a bool indicating if the current execution of <code><a href="#topic+design">design()</a></code> will create a new wave of sequential designs or add the sequential designs to
the last existing wave. This argument is only used if there are waves existing in the emulator. By creating new waves, one can better visualize the performance
of the sequential designs in different executions of <code><a href="#topic+design">design()</a></code> in <code><a href="#topic+draw">draw()</a></code> and can specify a different evaluation frequency in <code>freq</code>. However, it can be
beneficiary to turn this option off to restrict a large number of waves to be visualized in <code><a href="#topic+draw">draw()</a></code> that could run out of colors. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_cores">cores</code></td>
<td>
<p>an integer that gives the number of cores to be used for emulator validations. If set to <code>NULL</code>, the number of cores is
set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+design">design()</a></code>) that are used by <code>f</code>, <code>method</code>, and <code>eval</code>
can be passed here. <code><a href="#topic+design">design()</a></code> will pass relevant arguments to <code>f</code>, <code>method</code>, and <code>eval</code> based on the names of additional arguments provided.</p>
</td></tr>
<tr><td><code id="design_+3A_train_n">train_N</code></td>
<td>
<p>an integer or a vector of integers that gives the number of training iterations to be used to re-fit the DGP emulator at each step
of the sequential design:
</p>

<ul>
<li><p> If <code>train_N</code> is an integer, then at each step the DGP emulator will re-fitted (based on the frequency of re-fit specified in <code>freq</code>) with <code>train_N</code> iterations.
</p>
</li>
<li><p> If <code>train_N</code> is a vector, then its size must be <code>N</code> even the re-fit frequency specified in <code>freq</code> is not one.
</p>
</li></ul>

<p>Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_refit_cores">refit_cores</code></td>
<td>
<p>the number of cores/workers to be used to re-fit GP components (in the same layer of a DGP emulator)
at each M-step during the re-fitting. If set to <code>NULL</code>, the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>.
Only use multiple cores when there is a large number of GP components in different layers and optimization of GP components
is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_pruning">pruning</code></td>
<td>
<p>a bool indicating if dynamic pruning of DGP structures will be implemented during the sequential design after the total number of
design points exceeds <code>min_size</code> in <code>control</code>. The argument is only applicable to DGP emulators (i.e., <code>object</code> is an instance of <code>dgp</code> class)
produced by <code>dgp()</code> with <code>struc = NULL</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_control">control</code></td>
<td>
<p>a list that can supply any of the following components to control the dynamic pruning of the DGP emulator:
</p>

<ul>
<li> <p><code>min_size</code>, the minimum number of design points required to trigger the dynamic pruning. Defaults to 10 times of the input dimensions.
</p>
</li>
<li> <p><code>threshold</code>, the R2 value above which a GP node is considered redundant. Defaults to <code>0.97</code>.
</p>
</li>
<li> <p><code>nexceed</code>, the minimum number of consecutive iterations that the R2 value of a GP node must exceed <code>threshold</code> to trigger the removal of that node from
the DGP structure. Defaults to <code>3</code>.
</p>
</li></ul>

<p>The argument is only used when <code>pruning = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> is returned with a slot called <code>design</code> that contains:
</p>

<ul>
<li> <p><em>S</em> slots, named <code style="white-space: pre;">&#8288;wave1, wave2,..., waveS&#8288;</code>, that contain information of <em>S</em> waves of sequential designs that have been applied to the emulator.
Each slot contains the following elements:
</p>

<ul>
<li> <p><code>N</code>, an integer that gives the numbers of steps implemented in the corresponding wave;
</p>
</li>
<li> <p><code>rmse</code>, a matrix that gives the RMSEs of emulators constructed during the corresponding wave, if <code>eval = NULL</code>;
</p>
</li>
<li> <p><code>metric</code>, a matrix that gives the customized evaluating metric values of emulators constructed during the corresponding wave,
if a customized function is supplied to <code>eval</code>;
</p>
</li>
<li> <p><code>freq</code>, an integer that gives the frequency that the emulator validations are implemented during the corresponding wave.
</p>
</li>
<li> <p><code>enrichment</code>, a vector of size <code>N</code> that gives the number of new design points added after each step of the sequential design (if <code>object</code> is
an instance of the <code>gp</code> or <code>dgp</code> class), or a matrix that gives the number of new design points added to emulators in a bundle after each step of
the sequential design (if <code>object</code> is an instance of the <code>bundle</code> class).
</p>
</li></ul>

<p>If <code>target</code> is not <code>NULL</code>, the following additional elements are also included:
</p>

<ul>
<li> <p><code>target</code>, the target RMSE(s) to stop the sequential design.
</p>
</li>
<li> <p><code>reached</code>, a bool (if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class) or a vector of bools (if <code>object</code> is an instance of the <code>bundle</code>
class) that indicate if the target RMSEs are reached at the end of the sequential design.
</p>
</li></ul>

</li>
<li><p> a slot called <code>type</code> that gives the type of validations:
</p>

<ul>
<li><p> either LOO ('loo') or OOS ('oos') if <code>eval = NULL</code>. See <code><a href="#topic+validate">validate()</a></code> for more information about LOO and OOS.
</p>
</li>
<li><p> 'customized' if a customized R function is provided to <code>eval</code>.
</p>
</li></ul>

</li>
<li><p> two slots called <code>x_test</code> and <code>y_test</code> that contain the data points for the OOS validation if the <code>type</code> slot is 'oos'.
</p>
</li>
<li><p> If <code>y_cand = NULL</code> and there are <code>NA</code>s returned from the supplied <code>f</code> during the sequential design, a slot called <code>exclusion</code> is included
that records the located design positions that produced <code>NA</code>s via <code>f</code>. The sequential design will use this information to
avoid re-visiting the same locations (if <code>x_cand</code> is supplied) or their neighborhoods (if <code>x_cand</code> is <code>NULL</code>) in later runs of <code>design()</code>.
</p>
</li></ul>

<p>See <em>Note</em> section below for further information.
</p>


<h3>Note</h3>


<ul>
<li><p> The validation of an emulator is forced after the final step of a sequential design even <code>N</code> is not multiples of the second element in <code>freq</code>.
</p>
</li>
<li><p> Any <code>loo</code> or <code>oos</code> slot that already exists in <code>object</code> will be cleaned, and a new slot called <code>loo</code> or <code>oos</code> will be created in the returned object
depending on whether <code>x_test</code> and <code>y_test</code> are provided. The new slot gives the validation information of the emulator constructed in the final step of
the sequential design. See <code><a href="#topic+validate">validate()</a></code> for more information about the slots <code>loo</code> and <code>oos</code>.
</p>
</li>
<li><p> If <code>object</code> has previously been used by <code><a href="#topic+design">design()</a></code> for sequential designs, the information of the current wave of the sequential design will replace
those of old waves and be contained in the returned object, unless
</p>

<ul>
<li><p> the validation type (LOO or OOS depending on whether <code>x_test</code> and <code>y_test</code> are supplied or not) of the current wave of the sequential design is the
same as the validation types (shown in the <code>type</code> of the <code>design</code> slot of <code>object</code>) in previous waves, and if the validation type is OOS,
<code>x_test</code> and <code>y_test</code> in the current wave must also be identical to those in the previous waves;
</p>
</li>
<li><p> both the current and previous waves of the sequential design supply customized evaluation functions to <code>eval</code>. Users need to ensure the customized evaluation
functions are consistent among different waves. Otherwise, the trace plot of RMSEs produced by <code><a href="#topic+draw">draw()</a></code> will show values of different evaluation metrics in
different waves.
</p>
</li></ul>

<p>In above two cases, the information of the current wave of the sequential design will be added to the <code>design</code> slot of the returned object under the name <code>waveS</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class and <code>eval = NULL</code>, the matrix in the <code>rmse</code> slot is single-columned. If <code>object</code> is an instance of
the <code>dgp</code> or <code>bundle</code> class and <code>eval = NULL</code>, the matrix in the <code>rmse</code> slot can have multiple columns that correspond to different output dimensions
or different emulators in the bundle.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class and <code>eval = NULL</code>, <code>target</code> needs to be a single value giving the RMSE threshold. If <code>object</code> is an instance
of the <code>dgp</code> or <code>bundle</code> class and <code>eval = NULL</code>, <code>target</code> can be a vector of values that gives the RMSE thresholds for different output dimensions or
different emulators. If a single value is provided, it will be used as the RMSE threshold for all output dimensions (if <code>object</code> is an instance of the <code>dgp</code>) or all emulators
(if <code>object</code> is an instance of the <code>bundle</code>). If a customized function is supplied to <code>eval</code>, the user needs to ensure that the length of <code>target</code> is equal
to that of the output from <code>eval</code>.
</p>
</li>
<li><p> When defining <code>f</code>, it is important to ensure that:
</p>

<ul>
<li><p> the column order of the first argument of <code>f</code> is consistent with the training input used for the emulator;
</p>
</li>
<li><p> the column order of the output matrix of <code>f</code> is consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the <code>dgp</code> class),
or the order of emulators placed in <code>object</code> (if <code>object</code> is an instance of the <code>bundle</code> class).
</p>
</li></ul>

</li>
<li><p> The output matrix produced by <code>f</code> may include <code>NA</code>s. This is especially beneficial as it allows the sequential design process to continue without interruption,
even if errors or <code>NA</code> outputs are encountered from <code>f</code> at certain input locations identified by the sequential designs. Users should ensure to handle any errors
within <code>f</code> by appropriately returning <code>NA</code>s.
</p>
</li>
<li><p> When defining <code>eval</code>, the output metric needs to be positive if <code><a href="#topic+draw">draw()</a></code> is used with <code>log = T</code>. And one needs to ensure that a lower metric value indicates
a better emulation performance if <code>target</code> is set.
</p>
</li>
<li><p> Any R vector detected in <code>x_test</code> and <code>y_test</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>x_test</code> or <code>y_test</code> is a single testing data point with multiple dimensions, it must be given as a matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 2D non-stationary function that takes a matrix as the input
f &lt;- function(x) {
  sin(1/((0.7*x[,1,drop=F]+0.3)*(0.7*x[,2,drop=F]+0.3)))
}

# generate the initial design
X &lt;- maximinLHS(5,2)
Y &lt;- f(X)

# generate the validation data
validate_x &lt;- maximinLHS(30,2)
validate_y &lt;- f(validate_x)

# training a 2-layered DGP emulator with the initial design
m &lt;- dgp(X, Y)

# specify the ranges of the input dimensions
lim_1 &lt;- c(0, 1)
lim_2 &lt;- c(0, 1)
lim &lt;- rbind(lim_1, lim_2)

# 1st wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 2nd wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 3rd wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# draw the design created by the sequential design
draw(m,'design')

# inspect the trace of RMSEs during the sequential design
draw(m,'rmse')

# reduce the number of imputations for faster OOS
m_faster &lt;- set_imp(m, 5)

# plot the OOS validation with the faster DGP emulator
plot(m_faster, x_test = validate_x, y_test = validate_y)

## End(Not run)
</code></pre>

<hr>
<h2 id='dgp'>Deep Gaussian process emulator construction</h2><span id='topic+dgp'></span>

<h3>Description</h3>

<p>This function builds and trains a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp(
  X,
  Y,
  struc = NULL,
  depth = 2,
  node = ncol(X),
  name = "sexp",
  lengthscale = 1,
  bounds = NULL,
  prior = "ga",
  share = TRUE,
  nugget_est = FALSE,
  nugget = ifelse(all(nugget_est), 0.01, 1e-06),
  scale_est = TRUE,
  scale = 1,
  connect = TRUE,
  likelihood = NULL,
  training = TRUE,
  verb = TRUE,
  check_rep = TRUE,
  rff = FALSE,
  M = NULL,
  N = 500,
  cores = 1,
  blocked_gibbs = TRUE,
  ess_burn = 10,
  burnin = NULL,
  B = 10,
  internal_input_idx = NULL,
  linked_idx = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgp_+3A_x">X</code></td>
<td>
<p>a matrix where each row is an input training data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="dgp_+3A_y">Y</code></td>
<td>
<p>a matrix containing observed training output data. The matrix has its rows being output data points and columns being
output dimensions. When <code>likelihood</code> (see below) is not <code>NULL</code>, <code>Y</code> must be a matrix with only one column.</p>
</td></tr>
<tr><td><code id="dgp_+3A_struc">struc</code></td>
<td>
<p>a list that specifies a user-defined DGP structure. It should contain <em>L</em> (the number of DGP layers) sub-lists,
each of which represents a layer and contains a number of GP nodes (defined by <code><a href="#topic+kernel">kernel()</a></code>) in the corresponding layer.
The final layer of the DGP structure (i.e., the final sub-list in <code>struc</code>) can be a likelihood
layer that contains a likelihood function (e.g., <code><a href="#topic+Poisson">Poisson()</a></code>). When <code>struc = NULL</code>,
the DGP structure is automatically generated and can be checked by applying <code><a href="#topic+summary">summary()</a></code> to the output from <code><a href="#topic+dgp">dgp()</a></code> with <code>training = FALSE</code>.
If this argument is used (i.e., user provides a customized DGP structure), arguments <code>depth</code>, <code>node</code>, <code>name</code>, <code>lengthscale</code>, <code>bounds</code>, <code>prior</code>,
<code>share</code>, <code>nugget_est</code>, <code>nugget</code>, <code>scale_est</code>, <code>scale</code>, <code>connect</code>, <code>likelihood</code>, and <code>internal_input_idx</code> will NOT be used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_depth">depth</code></td>
<td>
<p>number of layers (including the likelihood layer) for a DGP structure. <code>depth</code> must be at least <code>2</code>.
Defaults to <code>2</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_node">node</code></td>
<td>
<p>number of GP nodes in each layer (except for the final layer or the layer feeding the likelihood node) of the DGP. Defaults to
<code>ncol(X)</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_name">name</code></td>
<td>
<p>a character or a vector of characters that indicates the kernel functions (either <code>"sexp"</code> for squared exponential kernel or
<code>"matern2.5"</code> for Mat√©rn-2.5 kernel) used in the DGP emulator:
1. if a single character is supplied, the corresponding kernel function will be used for all GP nodes in the DGP hierarchy.
2. if a vector of characters is supplied, each character of the vector specifies the kernel function that will be applied to all GP nodes in the corresponding layer.
</p>
<p>Defaults to <code>"sexp"</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_lengthscale">lengthscale</code></td>
<td>
<p>initial lengthscales for GP nodes in the DGP emulator. It can be a single numeric value or a vector:
</p>

<ol>
<li><p> if it is a single numeric value, the value will be applied as the initial lengthscales for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a vector, each element of the vector specifies the initial lengthscales that will be applied to all GP nodes in the corresponding layer.
The vector should have a length of <code>depth</code> if <code>likelihood = NULL</code> or a length of <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Defaults to a numeric value of <code>1.0</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_bounds">bounds</code></td>
<td>
<p>the lower and upper bounds of lengthscales in GP nodes. It can be a vector or a matrix:
</p>

<ol>
<li><p> if it is a vector, the lower bound (the first element of the vector) and upper bound (the second element of the vector) will be applied to
lengthscales for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a matrix, each row of the matrix specifies the lower and upper bounds of lengthscales for all GP nodes in the corresponding layer.
The matrix should have its row number equal to <code>depth</code> if <code>likelihood = NULL</code> or to <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Defaults to <code>NULL</code> where no bounds are specified for the lengthscales. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_prior">prior</code></td>
<td>
<p>prior to be used for Maximum a Posterior for lengthscales and nuggets of all GP nodes in the DGP hierarchy:
</p>

<ul>
<li><p> gamma prior (<code>"ga"</code>),
</p>
</li>
<li><p> inverse gamma prior (<code>"inv_ga"</code>), or
</p>
</li>
<li><p> jointly robust prior (<code>"ref"</code>).
</p>
</li></ul>

<p>Defaults to <code>"ga"</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_share">share</code></td>
<td>
<p>a bool indicating if all input dimensions of a GP node share a common lengthscale. Defaults to <code>TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_nugget_est">nugget_est</code></td>
<td>
<p>a bool or a bool vector that indicates if the nuggets of GP nodes (if any) in the final layer are to be estimated. If a single bool is
provided, it will be applied to all GP nodes (if any) in the final layer. If a bool vector (which must have a length of <code>ncol(Y)</code>) is provided, each
bool element in the vector will be applied to the corresponding GP node (if any) in the final layer. The value of a bool has following effects:
</p>

<ul>
<li> <p><code>FALSE</code>: the nugget of the corresponding GP in the final layer is fixed to the corresponding value defined in <code>nugget</code> (see below).
</p>
</li>
<li> <p><code>TRUE</code>: the nugget of the corresponding GP in the final layer will be estimated with the initial value given by the correspondence in <code>nugget</code> (see below).
</p>
</li></ul>

<p>Defaults to <code>FALSE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_nugget">nugget</code></td>
<td>
<p>the initial nugget value(s) of GP nodes (if any) in each layer:
</p>

<ol>
<li><p> if it is a single numeric value, the value will be applied as the initial nugget for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a vector, each element of the vector specifies the initial nugget that will be applied to all GP nodes in the corresponding layer.
The vector should have a length of <code>depth</code> if <code>likelihood = NULL</code> or a length of <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Set <code>nugget</code> to a small value and the bools in <code>nugget_est</code> to <code>FASLE</code> for deterministic emulations where the emulator
interpolates the training data points. Set <code>nugget</code> to a reasonable larger value and the bools in <code>nugget_est</code> to <code>TRUE</code> for stochastic emulations where
the computer model outputs are assumed to follow a homogeneous Gaussian distribution. Defaults to <code>1e-6</code> if <code>nugget_est = FALSE</code> and
<code>0.01</code> if <code>nugget_est = TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_scale_est">scale_est</code></td>
<td>
<p>a bool or a bool vector that indicates if variance of GP nodes (if any) in the final layer are to be estimated. If a single bool is
provided, it will be applied to all GP nodes (if any) in the final layer. If a bool vector (which must have a length of <code>ncol(Y)</code>) is provided, each
bool element in the vector will be applied to the corresponding GP node (if any) in the final layer. The value of a bool has following effects:
</p>

<ul>
<li> <p><code>FALSE</code>: the variance of the corresponding GP in the final layer is fixed to the corresponding value defined in <code>scale</code> (see below).
</p>
</li>
<li> <p><code>TRUE</code>: the variance of the corresponding GP in the final layer will be estimated with the initial value given by the correspondence in <code>scale</code> (see below).
</p>
</li></ul>

<p>Defaults to <code>TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_scale">scale</code></td>
<td>
<p>the initial variance value(s) of GP nodes (if any) in the final layer. If it is a single numeric value, it will be applied to all GP nodes (if any)
in the final layer. If it is a vector (which must have a length of <code>ncol(Y)</code>), each numeric in the vector will be applied to the corresponding GP node
(if any) in the final layer. Defaults to <code>1</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_connect">connect</code></td>
<td>
<p>a bool indicating whether to implement global input connection to the DGP structure. Setting it to <code>FALSE</code> may produce a better emulator in some cases at
the cost of slower training. Defaults to <code>TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_likelihood">likelihood</code></td>
<td>
<p>the likelihood type of a DGP emulator:
</p>

<ol>
<li> <p><code>NULL</code>: no likelihood layer is included in the emulator.
</p>
</li>
<li> <p><code>"Hetero"</code>: a heteroskedastic Gaussian likelihood layer is added for stochastic emulation where the computer model outputs are assumed to follow a heteroskedastic Gaussian distribution
(i.e., the computer model outputs have varying noises).
</p>
</li>
<li> <p><code>"Poisson"</code>: a Poisson likelihood layer is added for stochastic emulation where the computer model outputs are assumed to a Poisson distribution.
</p>
</li>
<li> <p><code>"NegBin"</code>: a negative Binomial likelihood layer is added for stochastic emulation where the computer model outputs are assumed to follow a negative Binomial distribution.
</p>
</li></ol>

<p>When <code>likelihood</code> is not <code>NULL</code>, the value of <code>nugget_est</code> is overridden by <code>FALSE</code>. Defaults to <code>NULL</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_training">training</code></td>
<td>
<p>a bool indicating if the initialized DGP emulator will be trained.
When set to <code>FALSE</code>, <code><a href="#topic+dgp">dgp()</a></code> returns an untrained DGP emulator, to which one can apply <code><a href="#topic+summary">summary()</a></code> to inspect its specifications
(especially when a customized <code>struc</code> is provided) or apply <code><a href="#topic+predict">predict()</a></code> to check its emulation performance before the training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on DGP emulator construction and training will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_check_rep">check_rep</code></td>
<td>
<p>a bool indicating whether to check the repetitions in the dataset, i.e., if one input
position has multiple outputs. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_rff">rff</code></td>
<td>
<p>a bool indicating whether to use random Fourier features to approximate the correlation matrices in training. Turning on this option could help accelerate
the training when the training data is relatively large but may reduce the quality of the resulting emulator. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_m">M</code></td>
<td>
<p>the number of features to be used by random Fourier approximation. It is only used
when <code>rff</code> is set to <code>TRUE</code>. Defaults to <code>NULL</code>. If it is <code>NULL</code>, <code>M</code> is automatically set to
<code>max(100, ceiling(sqrt(nrow(X))*log(nrow(X))))</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_n">N</code></td>
<td>
<p>number of iterations for the training. Defaults to <code>500</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_cores">cores</code></td>
<td>
<p>the number of cores/workers to be used to optimize GP components (in the same layer) at each M-step of the training. If set to <code>NULL</code>,
the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Only use multiple cores when there is a large number of GP components in
different layers and optimization of GP components is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_blocked_gibbs">blocked_gibbs</code></td>
<td>
<p>a bool indicating if the latent variables are imputed layer-wise using ESS-within-Blocked-Gibbs. ESS-within-Blocked-Gibbs would be faster and
more efficient than ESS-within-Gibbs that imputes latent variables node-wise because it reduces the number of components to be sampled during the Gibbs,
especially when there is a large number of GP nodes in layers due to higher input dimensions. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for the ESS-within-Gibbs
at each I-step of the training. Defaults to <code>10</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_burnin">burnin</code></td>
<td>
<p>the number of training iterations to be discarded for
point estimates of model parameters. Must be smaller than the training iterations <code>N</code>. If this is not specified, only the last 25% of iterations
are used. Defaults to <code>NULL</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce the later predictions. Increase the value to account for
more imputation uncertainties with slower predictions. Decrease the value for lower imputation uncertainties but faster predictions.
Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_internal_input_idx">internal_input_idx</code></td>
<td>
<p>column indices of <code>X</code> that are generated by the linked emulators in the preceding layers.
Set <code>internal_input_idx = NULL</code> if the DGP emulator is in the first layer of a system or all columns in <code>X</code> are
generated by the linked emulators in the preceding layers. Defaults to <code>NULL</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_linked_idx">linked_idx</code></td>
<td>
<p>either a vector or a list of vectors:
</p>

<ul>
<li><p> If <code>linked_idx</code> is a vector, it gives indices of columns in the pooled output matrix (formed by column-combined outputs of all
emulators in the feeding layer) that feed into the DGP emulator. The length of the vector shall equal to the length of <code>internal_input_idx</code>
when <code>internal_input_idx</code> is not <code>NULL</code>. If the DGP emulator is in the first layer of a linked emulator system, the vector gives the column indices of the global
input (formed by column-combining all input matrices of emulators in the first layer) that the DGP emulator will use. If the DGP emulator is to be used in both the first
and subsequent layers, one should initially set <code>linked_idx</code> to the appropriate values for the situation where the emulator is not in the first layer. Then, use the
function <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to reset the linking information when the emulator is in the first layer.
</p>
</li>
<li><p> When the DGP emulator is not in the first layer of a linked emulator system, <code>linked_idx</code> can be a list that gives the information on connections
between the DGP emulator and emulators in all preceding layers. The length of the list should equal to the number of layers before
the DGP emulator. Each element of the list is a vector that gives indices of columns in the pooled output matrix (formed by column-combined outputs
of all emulators) in the corresponding layer that feed into the DGP emulator. If the DGP emulator has no connections to any emulator in a certain layer,
set <code>NULL</code> in the corresponding position of the list. The order of input dimensions in <code>X[,internal_input_idx]</code> should be consistent with <code>linked_idx</code>.
For example, a DGP emulator in the 4th-layer that is fed by the output dimension 2 and 4 of emulators in layer 2 and all output dimension 1 to 3 of
emulators in layer 3 should have <code>linked_idx = list( NULL, c(2,4), c(1,2,3) )</code>. In addition, the first and second columns of <code>X[,internal_input_idx]</code>
should correspond to the output dimensions 2 and 4 from layer 2, and the third to fifth columns of <code>X[,internal_input_idx]</code> should
correspond to the output dimensions 1 to 3 from layer 3.
</p>
</li></ul>

<p>Set <code>linked_idx = NULL</code> if the DGP emulator will not be used for linked emulations. However, if this is no longer the case, one can use <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code>
to add linking information to the DGP emulator. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the DGP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a> and learn how to customize a DGP structure.
</p>


<h3>Value</h3>

<p>An S3 class named <code>dgp</code> that contains five slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>data</code>: a list that contains two elements: <code>X</code> and <code>Y</code> which are the training input and output data respectively.
</p>
</li>
<li> <p><code>specs</code>: a list that contains
</p>

<ol>
<li> <p><em>L</em> (i.e., the number of layers in the DGP hierarchy) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list contains <em>D</em>
(i.e., the number of GP/likelihood nodes in the corresponding layer) sub-lists named <code style="white-space: pre;">&#8288;node1, node2,..., nodeD&#8288;</code>. If a sub-list
corresponds to a likelihood node, it contains one element called <code>type</code> that gives the name (<code>Hetero</code>, <code>Poisson</code>, or <code>NegBin</code>) of the likelihood node.
If a sub-list corresponds to a GP node, it contains four elements:
</p>

<ul>
<li> <p><code>kernel</code>: the type of the kernel function used for the GP node.
</p>
</li>
<li> <p><code>lengthscales</code>: a vector of lengthscales in the kernel function.
</p>
</li>
<li> <p><code>scale</code>: the variance value in the kernel function.
</p>
</li>
<li> <p><code>nugget</code>: the nugget value in the kernel function.
</p>
</li></ul>

</li>
<li> <p><code>internal_dims</code>: the column indices of <code>X</code> that correspond to the linked emulators in the preceding layers of a linked system.
</p>
</li>
<li> <p><code>external_dims</code>: the column indices of <code>X</code> that correspond to global inputs to the linked system of emulators. It is shown as <code>FALSE</code> if <code>internal_input_idx = NULL</code>.
</p>
</li>
<li> <p><code>linked_idx</code>: the value passed to argument <code>linked_idx</code>. It is shown as <code>FALSE</code> if the argument <code>linked_idx</code> is <code>NULL</code>.
</p>
</li>
<li> <p><code>seed</code>: the random seed generated to produce the imputations. This information is stored for the reproducibility when the DGP emulator (that was saved by <code><a href="#topic+write">write()</a></code>
with the light option <code>light = TRUE</code>) is loaded back to R by <code><a href="#topic+read">read()</a></code>.
</p>
</li>
<li> <p><code>B</code>: the number of imputations used to generate the emulator.
</p>
</li></ol>

<p><code>internal_dims</code> and <code>external_dims</code> are generated only when <code>struc = NULL</code>.
</p>
</li>
<li> <p><code>constructor_obj</code>: a 'python' object that stores the information of the constructed DGP emulator.
</p>
</li>
<li> <p><code>container_obj</code>: a 'python' object that stores the information for the linked emulation.
</p>
</li>
<li> <p><code>emulator_obj</code>: a 'python' object that stores the information for the predictions from the DGP emulator.
</p>
</li></ul>

<p>The returned <code>dgp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for DGP predictions.
</p>
</li>
<li> <p><code><a href="#topic+continue">continue()</a></code> for additional DGP training iterations.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for LOO and OOS validations.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for validation plots.
</p>
</li>
<li> <p><code><a href="#topic+lgp">lgp()</a></code> for linked (D)GP emulator constructions.
</p>
</li>
<li> <p><code><a href="#topic+window">window()</a></code> for model parameter trimming.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the trained DGP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the DGP emulator to a <code>.pkl</code> file.
</p>
</li>
<li> <p><code><a href="#topic+set_imp">set_imp()</a></code> to change the number of imputations.
</p>
</li>
<li> <p><code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to add the linking information to the DGP emulator for linked emulations.
</p>
</li>
<li> <p><code><a href="#topic+design">design()</a></code> for sequential designs.
</p>
</li>
<li> <p><code><a href="#topic+update">update()</a></code> to update the DGP emulator with new inputs and outputs.
</p>
</li>
<li> <p><code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, <code><a href="#topic+pei">pei()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> to locate next design points.
</p>
</li></ul>



<h3>Note</h3>

<p>Any R vector detected in <code>X</code> and <code>Y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>X</code> is a single data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# construct a step function
f &lt;- function(x) {
  if (x &lt; 0.5) return(-1)
  if (x &gt;= 0.5) return(1)
  }

# generate training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# set a random seed
set_seed(999)

# training a DGP emulator
m &lt;- dgp(X, Y)

# continue for further training iterations
m &lt;- continue(m)

# summarizing
summary(m)

# trace plot
trace_plot(m)

# trim the traces of model parameters
m &lt;- window(m, 800)

# LOO cross validation
m &lt;- validate(m)
plot(m)

# prediction
test_x &lt;- seq(0, 1, length = 200)
m &lt;- predict(m, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 10)
validate_y &lt;- sapply(validate_x, f)
plot(m, validate_x, validate_y)

# write and read the constructed emulator
write(m, 'step_dgp')
m &lt;- read('step_dgp')

## End(Not run)
</code></pre>

<hr>
<h2 id='draw'>Validation plots of a sequential design</h2><span id='topic+draw'></span><span id='topic+draw.gp'></span><span id='topic+draw.dgp'></span><span id='topic+draw.bundle'></span>

<h3>Description</h3>

<p>This function draws validation plots of the sequential design of a (D)GP emulator or a bundle of (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(object, ...)

## S3 method for class 'gp'
draw(object, type = "rmse", log = FALSE, ...)

## S3 method for class 'dgp'
draw(object, type = "rmse", log = FALSE, ...)

## S3 method for class 'bundle'
draw(object, emulator = 1, type = "rmse", log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_object">object</code></td>
<td>
<p>can be one of the following emulator classes:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
<tr><td><code id="draw_+3A_type">type</code></td>
<td>
<p>either <code>"rmse"</code>, for the trace plot of RMSEs or customized evaluating metrics of emulators constructed during the sequential designs,
or <code>"design"</code>, for visualizations of input designs created by the sequential design procedure. Defaults to <code>"rmse"</code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_log">log</code></td>
<td>
<p>a bool that indicates whether to plot RMSEs or customized evaluating metrics in log-scale if <code>type = "rmse"</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_emulator">emulator</code></td>
<td>
<p>the index of the emulator packed in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object.
</p>


<h3>Note</h3>

<p>If a customized evaluating function is provided to <code><a href="#topic+design">design()</a></code> and the function returns a single evaluating metric value when <code>object</code> is
an instance of the <code>bundle</code> class, the value of <code>emulator</code> has no effects on the plot when <code>type = "rmse"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See design() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='gp'>Gaussian process emulator construction</h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>This function builds and trains a GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp(
  X,
  Y,
  struc = NULL,
  name = "sexp",
  lengthscale = rep(0.1, ncol(X)),
  bounds = NULL,
  prior = "ref",
  nugget_est = FALSE,
  nugget = ifelse(nugget_est, 0.01, 1e-08),
  scale_est = TRUE,
  scale = 1,
  training = TRUE,
  verb = TRUE,
  internal_input_idx = NULL,
  linked_idx = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_+3A_x">X</code></td>
<td>
<p>a matrix where each row is an input data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="gp_+3A_y">Y</code></td>
<td>
<p>a matrix with only one column and each row being an output data point.</p>
</td></tr>
<tr><td><code id="gp_+3A_struc">struc</code></td>
<td>
<p>an object produced by <code><a href="#topic+kernel">kernel()</a></code> that gives a user-defined GP specifications. When <code>struc = NULL</code>,
the GP specifications are automatically generated using information provided in <code>name</code>, <code>lengthscale</code>,
<code>nugget_est</code>, <code>nugget</code>, <code>scale_est</code>, <code>scale</code>,and <code>internal_input_idx</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_name">name</code></td>
<td>
<p>kernel function to be used. Either <code>"sexp"</code> for squared exponential kernel or
<code>"matern2.5"</code> for Mat√©rn-2.5 kernel. Defaults to <code>"sexp"</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_lengthscale">lengthscale</code></td>
<td>
<p>initial values of lengthscales in the kernel function. It can be a single numeric value or a vector:
</p>

<ul>
<li><p> if it is a single numeric value, it is assumed that kernel functions across input dimensions share the same lengthscale;
</p>
</li>
<li><p> if it is a vector (which must have a length of <code>ncol(X)</code>), it is assumed that kernel functions across input dimensions have different lengthscales.
</p>
</li></ul>

<p>Defaults to a vector of <code>0.1</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_bounds">bounds</code></td>
<td>
<p>the lower and upper bounds of lengthscales in the kernel function. It is a vector of length two where the first element is
the lower bound and the second element is the upper bound. The bounds will be applied to all lengthscales in the kernel function. Defaults
to <code>NULL</code> where no bounds are specified for the lengthscales. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_prior">prior</code></td>
<td>
<p>prior to be used for Maximum a Posterior for lengthscales and nugget of the GP: gamma prior (<code>"ga"</code>), inverse gamma prior (<code>"inv_ga"</code>),
or jointly robust prior (<code>"ref"</code>). Defaults to <code>"ref"</code>. This argument is only used when <code>struc = NULL</code>. See the reference below for the jointly
robust prior.</p>
</td></tr>
<tr><td><code id="gp_+3A_nugget_est">nugget_est</code></td>
<td>
<p>a bool indicating if the nugget term is to be estimated:
</p>

<ol>
<li> <p><code>FALSE</code>: the nugget term is fixed to <code>nugget</code>.
</p>
</li>
<li> <p><code>TRUE</code>: the nugget term will be estimated.
</p>
</li></ol>

<p>Defaults to <code>FALSE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_nugget">nugget</code></td>
<td>
<p>the initial nugget value. If <code>nugget_est = FALSE</code>, the assigned value is fixed during the training.
Set <code>nugget</code> to a small value (e.g., <code>1e-8</code>) and the corresponding bool in <code>nugget_est</code> to <code>FASLE</code> for deterministic emulations where the emulator
interpolates the training data points. Set <code>nugget</code> to a reasonable larger value and the corresponding bool in <code>nugget_est</code> to <code>TRUE</code> for stochastic
emulations where the computer model outputs are assumed to follow a homogeneous Gaussian distribution. Defaults to <code>1e-8</code> if <code>nugget_est = FALSE</code> and
<code>0.01</code> if <code>nugget_est = TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_scale_est">scale_est</code></td>
<td>
<p>a bool indicating if the variance is to be estimated:
</p>

<ol>
<li> <p><code>FALSE</code>: the variance is fixed to <code>scale</code>.
</p>
</li>
<li> <p><code>TRUE</code>: the variance term will be estimated.
</p>
</li></ol>

<p>Defaults to <code>TRUE</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_scale">scale</code></td>
<td>
<p>the initial variance value. If <code>scale_est = FALSE</code>, the assigned value is fixed during the training.
Defaults to <code>1</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_training">training</code></td>
<td>
<p>a bool indicating if the initialized GP emulator will be trained.
When set to <code>FALSE</code>, <code><a href="#topic+gp">gp()</a></code> returns an untrained GP emulator, to which one can apply <code><a href="#topic+summary">summary()</a></code> to inspect its specifications
(especially when a customized <code>struc</code> is provided) or apply <code><a href="#topic+predict">predict()</a></code> to check its emulation performance before the training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on GP emulator construction and training will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_internal_input_idx">internal_input_idx</code></td>
<td>
<p>the column indices of <code>X</code> that are generated by the linked emulators in the preceding layers.
Set <code>internal_input_idx = NULL</code> if the GP emulator is in the first layer of a system or all columns in <code>X</code> are
generated by the linked emulators in the preceding layers. Defaults to <code>NULL</code>. This argument is only used when <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_linked_idx">linked_idx</code></td>
<td>
<p>either a vector or a list of vectors:
</p>

<ul>
<li><p> If <code>linked_idx</code> is a vector, it gives indices of columns in the pooled output matrix (formed by column-combined outputs of all
emulators in the feeding layer) that feed into the GP emulator. The length of the vector shall equal to the length of <code>internal_input_idx</code> when <code>internal_input_idx</code>
is not <code>NULL</code>. If the GP emulator is in the first layer of a linked emulator system, the vector gives the column indices of the global
input (formed by column-combining all input matrices of emulators in the first layer) that the GP emulator will use. If the GP emulator is to be used in both the first
and subsequent layers, one should initially set <code>linked_idx</code> to the appropriate values for the situation where the emulator is not in the first layer. Then, use the
function <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to reset the linking information when the emulator is in the first layer.
</p>
</li>
<li><p> When the GP emulator is not in the first layer of a linked emulator system, <code>linked_idx</code> can be a list that gives the information on connections
between the GP emulator and emulators in all preceding layers. The length of the list should equal to the number of layers before
the GP emulator. Each element of the list is a vector that gives indices of columns in the pooled output matrix (formed by column-combined outputs
of all emulators) in the corresponding layer that feed into the GP emulator. If the GP emulator has no connections to any emulator in a certain layer,
set <code>NULL</code> in the corresponding position of the list. The order of input dimensions in <code>X[,internal_input_idx]</code> should be consistent with <code>linked_idx</code>.
For example, a GP emulator in the second layer that is fed by the output dimension 1 and 3 of emulators in layer 1 should have <code>linked_idx = list( c(1,3) )</code>.
In addition, the first and second columns of <code>X[,internal_input_idx]</code> should correspond to the output dimensions 1 and 3 from layer 1.
</p>
</li></ul>

<p>Set <code>linked_idx = NULL</code> if the GP emulator will not be used for linked emulations. However, if this is no longer the case, one can use <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code>
to add linking information to the GP emulator. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the GP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>gp</code> that contains five slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>data</code>: a list that contains two elements: <code>X</code> and <code>Y</code> which are the training input and output data respectively.
</p>
</li>
<li> <p><code>specs</code>: a list that contains seven elements:
</p>

<ol>
<li> <p><code>kernel</code>: the type of the kernel function used. Either <code>"sexp"</code> for squared exponential kernel or <code>"matern2.5"</code> for Mat√©rn-2.5 kernel.
</p>
</li>
<li> <p><code>lengthscales</code>: a vector of lengthscales in the kernel function.
</p>
</li>
<li> <p><code>scale</code>: the variance value in the kernel function.
</p>
</li>
<li> <p><code>nugget</code>: the nugget value in the kernel function.
</p>
</li>
<li> <p><code>internal_dims</code>: the column indices of <code>X</code> that correspond to the linked emulators in the preceding layers of a linked system.
</p>
</li>
<li> <p><code>external_dims</code>: the column indices of <code>X</code> that correspond to global inputs to the linked system of emulators. It is shown as <code>FALSE</code> if <code>internal_input_idx = NULL</code>.
</p>
</li>
<li> <p><code>linked_idx</code>: the value passed to argument <code>linked_idx</code>. It is shown as <code>FALSE</code> if the argument <code>linked_idx</code> is <code>NULL</code>.
</p>
</li></ol>

<p><code>internal_dims</code> and <code>external_dims</code> are generated only when <code>struc = NULL</code>.
</p>
</li>
<li> <p><code>constructor_obj</code>: a 'python' object that stores the information of the constructed GP emulator.
</p>
</li>
<li> <p><code>container_obj</code>: a 'python' object that stores the information for the linked emulation.
</p>
</li>
<li> <p><code>emulator_obj</code>: a 'python' object that stores the information for the predictions from the GP emulator.
</p>
</li></ul>

<p>The returned <code>gp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for GP predictions.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for LOO and OOS validations.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for validation plots.
</p>
</li>
<li> <p><code><a href="#topic+lgp">lgp()</a></code> for linked (D)GP emulator constructions.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the trained GP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the GP emulator to a <code>.pkl</code> file.
</p>
</li>
<li> <p><code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to add the linking information to the GP emulator for linked emulations.
</p>
</li>
<li> <p><code><a href="#topic+design">design()</a></code> for sequential designs.
</p>
</li>
<li> <p><code><a href="#topic+update">update()</a></code> to update the GP emulator with new inputs and outputs.
</p>
</li>
<li> <p><code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, <code><a href="#topic+pei">pei()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> to locate next design points.
</p>
</li></ul>



<h3>Note</h3>

<p>Any R vector detected in <code>X</code> and <code>Y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>X</code> is a single data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>References</h3>

<p>Gu, M. (2019). Jointly robust prior for Gaussian stochastic process in emulation, calibration and variable selection. <em>Bayesian Analysis</em>, <strong>14(3)</strong>, 857-885.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the package and the Python env
library(dgpsi)

# construct a step function
f &lt;- function(x) {
   if (x &lt; 0.5) return(-1)
   if (x &gt;= 0.5) return(1)
  }

# generate training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# training
m &lt;- gp(X, Y)

# summarizing
summary(m)

# LOO cross validation
m &lt;- validate(m)
plot(m)

# prediction
test_x &lt;- seq(0, 1, length = 200)
m &lt;- predict(m, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 10)
validate_y &lt;- sapply(validate_x, f)
plot(m, validate_x, validate_y)

# write and read the constructed emulator
write(m, 'step_gp')
m &lt;- read('step_gp')

## End(Not run)

</code></pre>

<hr>
<h2 id='Hetero'>Initialize a heteroskedastic Gaussian likelihood node</h2><span id='topic+Hetero'></span>

<h3>Description</h3>

<p>This function constructs a likelihood object to represent a heteroskedastic Gaussian likelihood node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hetero(input_dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hetero_+3A_input_dim">input_dim</code></td>
<td>
<p>a vector of length two that contains the indices of two GP nodes in the feeding
layer whose outputs feed into this likelihood node. When set to <code>NULL</code>,
all outputs from GP nodes in the feeding layer feed into this likelihood node, and in such a case
one needs to ensure that only two GP nodes are specified in the feeding layer.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A 'python' object to represent a heteroskedastic Gaussian likelihood node.
</p>


<h3>Note</h3>

<p>The heteroskedastic Gaussian likelihood node can only be linked to two feeding GP nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Check https://mingdeyu.github.io/dgpsi-R/ for examples
# on how to customize DGP structures using Hetero().

## End(Not run)
</code></pre>

<hr>
<h2 id='init_py'>'python' environment initialization</h2><span id='topic+init_py'></span>

<h3>Description</h3>

<p>This function initializes the 'python' environment for the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_py(
  py_ver = NULL,
  dgpsi_ver = NULL,
  reinstall = FALSE,
  uninstall = FALSE,
  verb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_py_+3A_py_ver">py_ver</code></td>
<td>
<p>a string that gives the 'python' version to be installed. If <code>py_ver = NULL</code>, the default 'python'
version '3.9.13' will be installed.</p>
</td></tr>
<tr><td><code id="init_py_+3A_dgpsi_ver">dgpsi_ver</code></td>
<td>
<p>a string that gives the 'python' version of 'dgpsi' to be used. If <code>dgpsi_ver = NULL</code>,
</p>

<ul>
<li><p> the latest 'python' version of 'dgpsi' will be used, if the package is installed from CRAN;
</p>
</li>
<li><p> the development 'python' version of 'dgpsi' will be used, if the package is installed from GitHub.
</p>
</li></ul>
</td></tr>
<tr><td><code id="init_py_+3A_reinstall">reinstall</code></td>
<td>
<p>a bool that indicates whether to reinstall the 'python' version of 'dgpsi' specified
in <code>dgpsi_ver</code> if it has already been installed. This argument is useful when the development version
of the R package is installed and one may want to regularly update the development 'python' version
of 'dgpsi'. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_py_+3A_uninstall">uninstall</code></td>
<td>
<p>a bool that indicates whether to uninstall the 'python' version of 'dgpsi' specified
in <code>dgpsi_ver</code> if it has already been installed. This argument is useful when the 'python' environment
is corrupted and one wants to completely uninstall and reinstall it. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_py_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value, called to install required 'python' environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)

</code></pre>

<hr>
<h2 id='kernel'>Initialize a Gaussian process node</h2><span id='topic+kernel'></span>

<h3>Description</h3>

<p>This function constructs a kernel object to represent properties of a
Gaussian process node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel(
  length,
  scale = 1,
  nugget = 1e-06,
  name = "sexp",
  prior_name = "ga",
  prior_coef = NULL,
  bounds = NULL,
  nugget_est = FALSE,
  scale_est = FALSE,
  input_dim = NULL,
  connect = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_length">length</code></td>
<td>
<p>a vector of lengthscales. The length of the vector equals to:
</p>

<ol>
<li><p> either one if the lengthscales in the kernel function are assumed same across input dimensions; or
</p>
</li>
<li><p> the total number of input dimensions, which is the sum of the number of feeding GP nodes
in the last layer (defined by the argument <code>input_dim</code>) and the number of connected global
input dimensions (defined by the argument <code>connect</code>), if the lengthscales in the kernel function
are assumed different across input dimensions.
</p>
</li></ol>
</td></tr>
<tr><td><code id="kernel_+3A_scale">scale</code></td>
<td>
<p>the variance of a GP node. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_nugget">nugget</code></td>
<td>
<p>the nugget term of a GP node. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_name">name</code></td>
<td>
<p>kernel function to be used. Either <code>"sexp"</code> for squared exponential kernel or
<code>"matern2.5"</code> for Mat√©rn-2.5 kernel. Defaults to <code>"sexp"</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_prior_name">prior_name</code></td>
<td>
<p>prior options for the lengthscales and nugget term: gamma prior (<code>"ga"</code>), inverse gamma prior (<code>"inv_ga"</code>),
or jointly robust prior (<code>"ref"</code>) for the lengthscales and nugget term. Set <code>NULL</code> to disable the prior. Defaults to <code>"ga"</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_prior_coef">prior_coef</code></td>
<td>
<p>a vector that contains the coefficients for different priors:
</p>

<ul>
<li><p> for the gamma prior, it is a vector of two values specifying the shape and rate parameters of the gamma distribution. Set to <code>NULL</code> for the
default value <code>c(1.6,0.3)</code>.
</p>
</li>
<li><p> for the inverse gamma prior, it is a vector of two values specifying the shape and scale parameters of the inverse gamma distribution. Set
to <code>NULL</code> for the default value <code>c(1.6,0.3)</code>.
</p>
</li>
<li><p> for the jointly robust prior, it is a vector of a single value specifying the <code>a</code> parameter in the prior. Set to <code>NULL</code> for the
default value <code>c(0.2)</code>. See the reference below for the jointly robust prior.
</p>
</li></ul>

<p>Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_bounds">bounds</code></td>
<td>
<p>a vector of length two that gives the lower bound (the first element of the vector) and the upper bound (the second element of the
vector) of all lengthscales of the GP node. Defaults to <code>NULL</code> where no bounds are specified for the lengthscales.</p>
</td></tr>
<tr><td><code id="kernel_+3A_nugget_est">nugget_est</code></td>
<td>
<p>set to <code>TRUE</code> to estimate the nugget term or to <code>FALSE</code> to fix the nugget term as specified
by the argument <code>nugget</code>. If set to <code>TRUE</code>, the value set to the argument <code>nugget</code> is used as the initial
value. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_scale_est">scale_est</code></td>
<td>
<p>set to <code>TRUE</code> to estimate the variance (i.e., scale) or to <code>FALSE</code> to fix the variance (i.e., scale) as specified
by the argument <code>scale</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_input_dim">input_dim</code></td>
<td>
<p>a vector that contains either
</p>

<ol>
<li><p> the indices of GP nodes in the feeding layer whose outputs feed into this GP node; or
</p>
</li>
<li><p> the indices of global input dimensions that are linked to the outputs of some feeding emulators,
if this GP node is in the first layer of a GP or DGP, which will be used for the linked emulation.
</p>
</li></ol>

<p>When set to <code>NULL</code>,
</p>

<ol>
<li><p> all outputs from the GP nodes in the feeding layer feed into this GP node; or
</p>
</li>
<li><p> all global input dimensions feed into this GP node.
</p>
</li></ol>

<p>Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_connect">connect</code></td>
<td>
<p>a vector that contains the indices of dimensions in the global
input connecting to this GP node as additional input dimensions. When set to <code>NULL</code>, no global input
connection is implemented. Defaults to <code>NULL</code>. When this GP node is in the first layer of a GP or DGP emulator,
which will consequently be used for linked emulation, <code>connect</code> gives the indices of global input dimensions
that are not connected to some feeding emulators. In such a case, set <code>input_dim</code> to a vector of indices of
the remaining input dimensions that are connected to the feeding emulators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A 'python' object to represent a GP node.
</p>


<h3>References</h3>

<p>Gu, M. (2019). Jointly robust prior for Gaussian stochastic process in emulation, calibration and variable selection. <em>Bayesian Analysis</em>, <strong>14(3)</strong>, 857-885.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Check https://mingdeyu.github.io/dgpsi-R/ for examples
# on how to customize DGP structures using kernel().

## End(Not run)
</code></pre>

<hr>
<h2 id='lgp'>Linked (D)GP emulator construction</h2><span id='topic+lgp'></span>

<h3>Description</h3>

<p>This function constructs a linked (D)GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgp(struc, B = 10, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgp_+3A_struc">struc</code></td>
<td>
<p>a list contains <em>L</em> (the number of layers in a systems of computer models) sub-lists,
each of which represents a layer and contains (D)GP emulators (represented by
instances of S3 class <code>gp</code> or <code>dgp</code>) of computer models. The sub-lists are placed in the list
in the same order of the specified computer model system's hierarchy.</p>
</td></tr>
<tr><td><code id="lgp_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce the predictions. Increase the value to account for more
imputation uncertainties. Decrease the value for lower imputation uncertainties but faster predictions.
If the system consists only GP emulators, <code>B</code> is set to <code>1</code> automatically. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="lgp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the linked (D)GP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID
(Universally Unique Identifier) will be automatically generated and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>lgp</code> that contains three slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>constructor_obj</code>: a list of 'python' objects that stores the information of the constructed linked emulator.
</p>
</li>
<li> <p><code>emulator_obj</code>, a 'python' object that stores the information for predictions from the linked emulator.
</p>
</li>
<li> <p><code>specs</code>: a list that contains
</p>

<ol>
<li> <p><code>seed</code>: the random seed generated to produce the imputations. This information is stored for the reproducibility
when the linked (D)GP emulator (that was saved by <code><a href="#topic+write">write()</a></code> with the light option <code>light = TRUE</code>) is loaded back
to R by <code><a href="#topic+read">read()</a></code>.
</p>
</li>
<li> <p><code>B</code>: the number of imputations used to generate the linked (D)GP emulator.
</p>
</li></ol>

</li></ul>

<p>The returned <code>lgp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for linked (D)GP predictions.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for the OOS validation.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for the validation plots.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the constructed linked (D)GP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the linked (D)GP emulator to a <code>.pkl</code> file.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# model 1
f1 &lt;- function(x) {
  (sin(7.5*x)+1)/2
}
# model 2
f2 &lt;- function(x) {
  2/3*sin(2*(2*x - 1))+4/3*exp(-30*(2*(2*x-1))^2)-1/3
}
# linked model
f12 &lt;- function(x) {
  f2(f1(x))
}

# training data for Model 1
X1 &lt;- seq(0, 1, length = 9)
Y1 &lt;- sapply(X1, f1)
# training data for Model 2
X2 &lt;- seq(0, 1, length = 13)
Y2 &lt;- sapply(X2, f2)

# emulation of model 1
m1 &lt;- gp(X1, Y1, name = "matern2.5", linked_idx = c(1))
# emulation of model 2
m2 &lt;- dgp(X2, Y2, depth = 2, name = "matern2.5")
# assign linking information after the emulation construction
m2 &lt;- set_linked_idx(m2, c(1))

# emulation of the linked model
struc &lt;- combine(list(m1), list(m2))
m_link &lt;- lgp(struc)

# summarizing
summary(m_link)

# prediction
test_x &lt;- seq(0, 1, length = 300)
m_link &lt;- predict(m_link, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 20)
validate_y &lt;- sapply(validate_x, f12)
plot(m_link, validate_x, validate_y, style = 2)

# write and read the constructed linked emulator
write(m_link, 'linked_emulator')
m_link &lt;- read('linked_emulator')

## End(Not run)
</code></pre>

<hr>
<h2 id='mice'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using MICE</h2><span id='topic+mice'></span><span id='topic+mice.gp'></span><span id='topic+mice.dgp'></span><span id='topic+mice.bundle'></span>

<h3>Description</h3>

<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Mutual Information for Computer Experiments (MICE), see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice(object, x_cand, ...)

## S3 method for class 'gp'
mice(object, x_cand, batch_size = 1, nugget_s = 1e-06, workers = 1, ...)

## S3 method for class 'dgp'
mice(
  object,
  x_cand,
  batch_size = 1,
  nugget_s = 1e-06,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
mice(
  object,
  x_cand,
  batch_size = 1,
  nugget_s = 1e-06,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mice_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mice_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class, <code>x_cand</code> could also
be a list with the length equal to the number of emulators contained in the <code>object</code>. Each slot in <code>x_cand</code> is a matrix
that gives a candidate set for each emulator included in the bundle. See <em>Note</em> section below for further information.</p>
</td></tr>
<tr><td><code id="mice_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+mice">mice()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="mice_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_nugget_s">nugget_s</code></td>
<td>
<p>the value of the smoothing nugget term used by MICE. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_workers">workers</code></td>
<td>
<p>the number of workers/cores to be used for the criterion calculation. If set to <code>NULL</code>,
the number of workers is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the criterion calculation for a DGP emulator.
Turning this option on could improve the speed of criterion calculations when the DGP emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.</p>
</td></tr>
<tr><td><code id="mice_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the MICE across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregations of scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable the aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, a vector is returned with the length equal to <code>batch_size</code>, giving the positions (i.e., row numbers)
of next design points from <code>x_cand</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to one (if <code>aggregate</code>
is not <code>NULL</code>) or the output dimension (if <code>aggregate</code> is <code>NULL</code>), giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added
to the DGP emulator across different outputs. If <code>object</code> is a DGP emulator with either <code>Hetero</code> or <code>NegBin</code> likelihood layer, the returned matrix has
two columns with the first column giving positions of next design points from <code>x_cand</code> that correspond to the mean parameter of the normal or negative Binomial
distribution, and the second column giving positions of next design points from <code>x_cand</code> that correspond to the variance parameter of the normal distribution or
the dispersion parameter of the negative Binomial distribution.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to the number of
emulators in the bundle, giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added to individual emulators.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The column order of the first argument of <code>aggregate</code> must be consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the
<code>dgp</code> class), or the order of emulators placed in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class;
</p>
</li>
<li><p> If <code>x_cand</code> is supplied as a list when <code>object</code> is an instance of <code>bundle</code> class and a <code>aggregate</code> function is provided, the matrices in <code>x_cand</code> must have
common rows (i.e., the candidate sets of emulators in the bundle have common input locations) so the <code>aggregate</code> function can be applied.
</p>
</li>
<li><p> Any R vector detected in <code>x_cand</code> will be treated as a column vector and automatically converted into a single-column
R matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Beck, J., &amp; Guillas, S. (2016). Sequential design with mutual information for computer experiments (MICE): emulation of a tsunami model.
<em>SIAM/ASA Journal on Uncertainty Quantification</em>, <strong>4(1)</strong>, 739-766.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# generate a candidate set
x_cand &lt;- maximinLHS(200,1)

# locate the next design point using MICE
next_point &lt;- mice(m, x_cand = x_cand)
X_new &lt;- x_cand[next_point,,drop = F]

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit with 500 training iterations
m &lt;- update(m, X, Y, refit = TRUE, N = 500)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='NegBin'>Initialize a negative Binomial likelihood node</h2><span id='topic+NegBin'></span>

<h3>Description</h3>

<p>This function constructs a likelihood object to represent a negative Binomial likelihood node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NegBin(input_dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NegBin_+3A_input_dim">input_dim</code></td>
<td>
<p>a vector of length two that contains the indices of two GP nodes in the feeding
layer whose outputs feed into this likelihood node. When set to <code>NULL</code>,
all outputs from GP nodes in the feeding layer feed into this likelihood node, and in such a case
one needs to ensure that only two GP nodes are specified in the feeding layer.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A 'python' object to represent a negative Binomial likelihood node.
</p>


<h3>Note</h3>

<p>The negative Binomial likelihood node can only be linked to two feeding GP nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Check https://mingdeyu.github.io/dgpsi-R/ for examples
# on how to customize DGP structures using NegBin().

## End(Not run)
</code></pre>

<hr>
<h2 id='nllik'>Calculate negative predicted log-likelihood</h2><span id='topic+nllik'></span>

<h3>Description</h3>

<p>This function computes the negative predicted log-likelihood from a
DGP emulator with a likelihood layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nllik(object, x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nllik_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class and it should be produced by <code><a href="#topic+dgp">dgp()</a></code> with one of the following two settings:
</p>

<ol>
<li><p> if <code>struc = NULL</code>, <code>likelihood</code> is not <code>NULL</code>;
</p>
</li>
<li><p> if a customized structure is provided to <code>struc</code>, the final layer must be likelihood layer containing only one
likelihood node produced by <code><a href="#topic+Poisson">Poisson()</a></code>, <code><a href="#topic+Hetero">Hetero()</a></code>, or <code><a href="#topic+NegBin">NegBin()</a></code>.
</p>
</li></ol>
</td></tr>
<tr><td><code id="nllik_+3A_x">x</code></td>
<td>
<p>a matrix where each row is an input testing data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="nllik_+3A_y">y</code></td>
<td>
<p>a matrix with only one column where each row is a scalar-valued testing output data point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> is returned with an additional slot named <code>NLL</code> that contains two elements.
The first one, named <code>meanNLL</code>, is a scalar that gives the average negative predicted log-likelihood
across all testing data points. The second one, named <code>allNLL</code>, is a vector that gives the negative predicted
log-likelihood for each testing data point.
</p>


<h3>Note</h3>

<p>Any R vector detected in <code>x</code> and <code>y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>x</code> is a single testing data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Check https://mingdeyu.github.io/dgpsi-R/ for examples
# on how to compute the negative predicted log-likelihood
# using nllik().

## End(Not run)
</code></pre>

<hr>
<h2 id='pack'>Pack GP and DGP emulators into a bundle</h2><span id='topic+pack'></span>

<h3>Description</h3>

<p>This function packs GP emulators and DGP emulators into a <code>bundle</code> class for
sequential designs if each emulator emulates one output dimension of the underlying simulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(..., id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_+3A_...">...</code></td>
<td>
<p>a sequence or a list of emulators produced by <code><a href="#topic+gp">gp()</a></code> or <code><a href="#topic+dgp">dgp()</a></code>.</p>
</td></tr>
<tr><td><code id="pack_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the bundle emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>bundle</code> to be used by <code><a href="#topic+design">design()</a></code> for sequential designs. It has:
</p>

<ul>
<li><p> a slot called <code>id</code> that is assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><em>N</em> slots named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code>, each of which contains a GP or DGP emulator, where <em>N</em> is the number of emulators
that are provided to the function.
</p>
</li>
<li><p> a slot called <code>data</code> which contains two elements <code>X</code> and <code>Y</code>. <code>X</code> contains <em>N</em> matrices named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code> that are
training input data for different emulators. <code>Y</code> contains <em>N</em> single-column matrices named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code> that are
training output data for different emulators.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a function with a two-dimensional output
f &lt;- function(x) {
 y1 = sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
 y2 = 1/3*sin(2*(2*x - 1))+2/3*exp(-30*(2*(2*x-1))^2)+1/3
 return(cbind(y1,y2))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# generate the validation data
validate_x &lt;- maximinLHS(30,1)
validate_y &lt;- f(validate_x)

# training a 2-layered DGP emulator with respect to each output with the global connection off
m1 &lt;- dgp(X, Y[,1], connect=F)
m2 &lt;- dgp(X, Y[,2], connect=F)

# specify the range of the input dimension
lim &lt;- c(0, 1)

# pack emulators to form an emulator bundle
m &lt;- pack(m1, m2)

# 1st wave of the sequential design with 10 steps with target RMSE 0.01
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y, target = 0.01)

# 2rd wave of the sequential design with 10 steps, the same target, and the aggregation
# function that takes the average of the criterion scores across the two outputs
g &lt;- function(x){
  return(rowMeans(x))
}
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x,
                    y_test = validate_y, aggregate = g, target = 0.01)

# draw sequential designs of the two packed emulators
draw(m, emulator = 1, type = 'design')
draw(m, emulator = 2, type = 'design')

# inspect the traces of RMSEs of the two packed emulators
draw(m, emulator = 1, type = 'rmse')
draw(m, emulator = 2, type = 'rmse')

# write and read the constructed emulator bundle
write(m, 'bundle_dgp')
m &lt;- read('bundle_dgp')

# unpack the bundle into individual emulators
m_unpacked &lt;- unpack(m)

# plot OOS validations of individual emulators
plot(m_unpacked[[1]], x_test = validate_x, y_test = validate_y[,1])
plot(m_unpacked[[2]], x_test = validate_x, y_test = validate_y[,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='pei'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using PEI</h2><span id='topic+pei'></span><span id='topic+pei.gp'></span><span id='topic+pei.dgp'></span><span id='topic+pei.bundle'></span>

<h3>Description</h3>

<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Pseudo Expected Improvement (PEI), see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pei(object, x_cand, ...)

## S3 method for class 'gp'
pei(object, x_cand, pseudo_points = NULL, batch_size = 1, ...)

## S3 method for class 'dgp'
pei(
  object,
  x_cand,
  pseudo_points = NULL,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
pei(
  object,
  x_cand,
  pseudo_points = NULL,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pei_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pei_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class, <code>x_cand</code> could also
be a list with the length equal to the number of emulators contained in the <code>object</code>. Each slot in <code>x_cand</code> is a matrix
that gives a candidate set for each emulator included in the bundle. See <em>Note</em> section below for further information.</p>
</td></tr>
<tr><td><code id="pei_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+pei">pei()</a></code>) that are used by <code>aggregate</code> or <code><a href="#topic+gp">gp()</a></code> (for emulating the
ES-LOO errors) can be passed here.</p>
</td></tr>
<tr><td><code id="pei_+3A_pseudo_points">pseudo_points</code></td>
<td>
<p>an optional matrix (with columns being input dimensions) that gives the pseudo input points for PEI calculations. See the reference below
for further details about the pseudo points. When <code>object</code> is an instance of the <code>bundle</code> class, <code>pseudo_points</code> can also be a list with the length
equal to the number of emulators in the bundle. Each element in the list is a matrix that gives the the pseudo input points for the corresponding
emulator in the bundle. Defaults to <code>NULL</code>. When <code><a href="#topic+pei">pei()</a></code> is used in <code><a href="#topic+design">design()</a></code>, <code>pseudo_points</code> will be automatically generated by <code><a href="#topic+design">design()</a></code>.</p>
</td></tr>
<tr><td><code id="pei_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="pei_+3A_workers">workers</code></td>
<td>
<p>the number of workers/cores to be used for the criterion calculation. If set to <code>NULL</code>,
the number of workers is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="pei_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the criterion calculation for a DGP emulator.
Turning this option on could improve the speed of criterion calculations when the DGP emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.</p>
</td></tr>
<tr><td><code id="pei_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the PEI across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregations of scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable the aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, a vector is returned with the length equal to <code>batch_size</code>, giving the positions (i.e., row numbers)
of next design points from <code>x_cand</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to one (if <code>aggregate</code>
is not <code>NULL</code>) or the output dimension (if <code>aggregate</code> is <code>NULL</code>), giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added
to the DGP emulator across different outputs.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to the number of
emulators in the bundle, giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added to individual emulators.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The column order of the first argument of <code>aggregate</code> must be consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the
<code>dgp</code> class), or the order of emulators placed in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class;
</p>
</li>
<li><p> If <code>x_cand</code> is supplied as a list when <code>object</code> is an instance of <code>bundle</code> class and a <code>aggregate</code> function is provided, the matrices in <code>x_cand</code> must have
common rows (i.e., the candidate sets of emulators in the bundle have common input locations) so the <code>aggregate</code> function can be applied.
</p>
</li>
<li><p> The function is only applicable to DGP emulators without likelihood layers.
</p>
</li>
<li><p> Any R vector detected in <code>x_cand</code> and <code>pseudo_points</code> will be treated as a column vector and automatically converted into a single-column
R matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Mohammadi, H., Challenor, P., Williamson, D., &amp; Goodfellow, M. (2022). Cross-validation-based adaptive sampling for Gaussian process models. <em>SIAM/ASA Journal on Uncertainty Quantification</em>, <strong>10(1)</strong>, 294-316.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# generate a candidate set
x_cand &lt;- maximinLHS(200,1)

# locate the next design point using PEI
next_point &lt;- pei(m, x_cand = x_cand)
X_new &lt;- x_cand[next_point,,drop = F]

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit with 500 training iterations
m &lt;- update(m, X, Y, refit = TRUE, N = 500)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot'>Validation plots of a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+plot'></span><span id='topic+plot.dgp'></span><span id='topic+plot.lgp'></span><span id='topic+plot.gp'></span>

<h3>Description</h3>

<p>This function draws validation plots of a GP, DGP, or linked (D)GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = "mean_var",
  style = 1,
  min_max = TRUE,
  color = "turbo",
  type = "points",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  threading = FALSE,
  ...
)

## S3 method for class 'lgp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = "mean_var",
  style = 1,
  min_max = TRUE,
  color = "turbo",
  type = "points",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  threading = FALSE,
  ...
)

## S3 method for class 'gp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = "mean_var",
  style = 1,
  min_max = TRUE,
  color = "turbo",
  type = "points",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>can be one of the following emulator classes:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_x_test">x_test</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_y_test">y_test</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_dim">dim</code></td>
<td>
<p>if <code>dim = NULL</code>, the index of an emulator's input will be shown on the x-axis in validation plots. Otherwise, <code>dim</code> indicates
which dimension of an emulator's input will be shown on the x-axis in validation plots:
</p>

<ul>
<li><p> If <code>x</code> is an instance of the <code>gp</code> of <code>dgp</code> class, <code>dim</code> is an integer.
</p>
</li>
<li><p> If <code>x</code> is an instance of the <code>lgp</code> class, <code>dim</code> can be
</p>

<ol>
<li><p> an integer referring to the dimension of the global input to emulators in the first layer of a linked emulator system; or
</p>
</li>
<li><p> a vector of three integers referring to the dimension (specified by the third integer) of the global input to an emulator
(specified by the second integer) in a layer (specified by the first integer) that is not the first layer of a linked emulator
system.
</p>
</li></ol>

</li></ul>

<p>This argument is only used when <code>style = 1</code> and the emulator input is at least two-dimensional. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_method">method</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_style">style</code></td>
<td>
<p>either <code>1</code> or <code>2</code>, indicating two different types of validation plots.</p>
</td></tr>
<tr><td><code id="plot_+3A_min_max">min_max</code></td>
<td>
<p>a bool indicating if min-max normalization will be used to scale the testing output, RMSE, predictive mean and std from the
emulator. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>
<p>a character string indicating the color map to use when <code>style = 2</code>:
</p>

<ul>
<li> <p><code>'magma'</code> (or <code>'A'</code>)
</p>
</li>
<li> <p><code>'inferno'</code> (or <code>'B'</code>)
</p>
</li>
<li> <p><code>'plasma'</code> (or '<code>C</code>')
</p>
</li>
<li> <p><code>'viridis'</code> (or <code>'D'</code>)
</p>
</li>
<li> <p><code>'cividis'</code> (or <code>'E'</code>)
</p>
</li>
<li> <p><code>'rocket'</code> (or <code>'F'</code>)
</p>
</li>
<li> <p><code>'mako'</code> (or <code>'G'</code>)
</p>
</li>
<li> <p><code>'turbo'</code> (or <code>'H'</code>)
</p>
</li></ul>

<p>Defaults to <code>'turbo'</code> (or <code>'H'</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>either <code>'line'</code> or <code style="white-space: pre;">&#8288;'points&#8288;</code>, indicating whether to draw testing data in the OOS validation plot as a line or
individual points when the input of the emulator is one-dimensional and <code>style = 1</code>. Defaults to <code>'points'</code></p>
</td></tr>
<tr><td><code id="plot_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on plotting will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_force">force</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_cores">cores</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_threading">threading</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object.
</p>


<h3>Note</h3>


<ul>
<li> <p><code><a href="#topic+plot">plot()</a></code> calls <code><a href="#topic+validate">validate()</a></code> internally to obtain validation results for plotting. However, <code><a href="#topic+plot">plot()</a></code> will not export the
emulator object with validation results. Instead, it only returns the plotting object. For small-scale validations (i.e., small
training or testing data points), direct execution of <code><a href="#topic+plot">plot()</a></code> is fine. However, for moderate- to large-scale validations,
it is recommended to first run <code><a href="#topic+validate">validate()</a></code> to obtain and store validation results in the emulator object, and then supply the
object to <code><a href="#topic+plot">plot()</a></code>. This is because if an emulator object has the validation results stored, each time when <code><a href="#topic+plot">plot()</a></code>
is invoked, unnecessary evaluations of repetitive LOO or OOS validation will not be implemented.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> uses information provided in <code>x_test</code> and <code>y_test</code> to produce the OOS validation plots. Therefore, if validation results
are already stored in <code>x</code>, unless <code>x_test</code> and <code>y_test</code> are identical to those used by <code><a href="#topic+validate">validate()</a></code>, <code><a href="#topic+plot">plot()</a></code> will re-evaluate OOS
validations before plotting.
</p>
</li>
<li><p> Any R vector detected in <code>x_test</code> and <code>y_test</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>x_test</code> or <code>y_test</code> is a single testing data point with multiple dimensions, it must be given as a matrix.
</p>
</li>
<li><p> The returned <code>patchwork</code> object contains the <code>ggplot2</code> objects. One can modify the included individual ggplots
by accessing them with double-bracket indexing. See <a href="https://patchwork.data-imaginist.com/">https://patchwork.data-imaginist.com/</a> for further information.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='Poisson'>Initialize a Poisson likelihood node</h2><span id='topic+Poisson'></span>

<h3>Description</h3>

<p>This function constructs a likelihood object to represent a Poisson likelihood node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Poisson(input_dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Poisson_+3A_input_dim">input_dim</code></td>
<td>
<p>a vector of length one that contains the indices of one GP node in the feeding
layer whose outputs feed into this likelihood node. When set to <code>NULL</code>,
all outputs from GP nodes in the feeding layer feed into this likelihood node, and in such a case
one needs to ensure that only one GP node is specified in the feeding layer.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A 'python' object to represent a Poisson likelihood node.
</p>


<h3>Note</h3>

<p>The Poisson likelihood node can only be linked to one feeding GP node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Check https://mingdeyu.github.io/dgpsi-R/ for examples
# on how to customize DGP structures using Poisson().

## End(Not run)
</code></pre>

<hr>
<h2 id='predict'>Predictions from GP, DGP, or linked (D)GP emulators</h2><span id='topic+predict'></span><span id='topic+predict.dgp'></span><span id='topic+predict.lgp'></span><span id='topic+predict.gp'></span>

<h3>Description</h3>

<p>This function implements single-core or multi-core predictions (with or without multi-threading)
from GP, DGP, or linked (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgp'
predict(
  object,
  x,
  method = "mean_var",
  full_layer = FALSE,
  sample_size = 50,
  cores = 1,
  chunks = NULL,
  threading = FALSE,
  ...
)

## S3 method for class 'lgp'
predict(
  object,
  x,
  method = "mean_var",
  full_layer = FALSE,
  sample_size = 50,
  cores = 1,
  chunks = NULL,
  threading = FALSE,
  ...
)

## S3 method for class 'gp'
predict(
  object,
  x,
  method = "mean_var",
  sample_size = 50,
  cores = 1,
  chunks = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an instance of the <code>gp</code>, <code>dgp</code>, or <code>lgp</code> class.</p>
</td></tr>
<tr><td><code id="predict_+3A_x">x</code></td>
<td>
<p>the testing input data:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class, <code>x</code> is a matrix where each row is an input testing data point and each column is an input dimension.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>lgp</code> class, <code>x</code> can be a matrix or a list:
</p>

<ul>
<li><p> if <code>x</code> is a matrix, it is the global testing input data that feed into the emulators in the first layer of a system.
The rows of <code>x</code> represent different input data points and the columns represent input dimensions across all emulators in
the first layer of the system. In this case, it is assumed that the only global input to the system is the input to the
emulators in the first layer and there is no global input to emulators in other layers.
</p>
</li>
<li><p> if <code>x</code> is a list, it should have <em>L</em> (the number of layers in an emulator system) elements. The first element
is a matrix that represents the global testing input data that feed into the emulators in the first layer of the system. The
remaining <em>L-1</em> elements are <em>L-1</em> sub-lists, each of which contains a number (the same number of emulators in
the corresponding layer) of matrices (rows being testing input data points and columns being input dimensions) that represent the
global testing input data to the emulators in the corresponding layer. The matrices must be placed in the sub-lists based on how
their corresponding emulators are placed in <code>struc</code> argument of <code><a href="#topic+lgp">lgp()</a></code>. If there is no global input data to a certain emulator,
set <code>NULL</code> in the corresponding sub-list of <code>x</code>.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="predict_+3A_method">method</code></td>
<td>
<p>the prediction approach: mean-variance (<code>"mean_var"</code>) or sampling (<code>"sampling"</code>) approach. Defaults to <code>"mean_var"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_full_layer">full_layer</code></td>
<td>
<p>a bool indicating whether to output the predictions of all layers. Defaults to <code>FALSE</code>. Only used when <code>object</code> is a DGP and linked (D)GP emulator.</p>
</td></tr>
<tr><td><code id="predict_+3A_sample_size">sample_size</code></td>
<td>
<p>the number of samples to draw for each given imputation if <code>method = "sampling"</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_cores">cores</code></td>
<td>
<p>the number of cores/workers to be used. If set to <code>NULL</code>,
the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_chunks">chunks</code></td>
<td>
<p>the number of chunks that the testing input matrix <code>x</code> will be divided into for multi-cores to work on.
Only used when <code>cores</code> is not <code>1</code>. If not specified (i.e., <code>chunks = NULL</code>), the number of chunks is set to the value of <code>cores</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the predictions of DGP or linked (D)GP emulators. Turn this option on
when you use the Mat√©rn-2.5 kernel and have a moderately large number of training data points as in such a case you could gain faster predictions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two matrices named <code>mean</code>
for the predictive means and <code>var</code> for the predictive variances. Each matrix has only one column with its rows
corresponding to testing positions (i.e., rows of <code>x</code>).
</p>
</li>
<li><p> if <code>method = "sampling"</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains a matrix whose rows correspond
to testing positions and columns correspond to <code>sample_size</code> number of samples drawn from the predictive distribution of GP.
</p>
</li></ol>

</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two
matrices named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each matrix has its rows corresponding to testing
positions and columns corresponding to DGP global output dimensions (i.e., the number of GP/likelihood nodes in the final layer).
</p>
</li>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two
sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list contains <em>L</em> (i.e., the number of layers)
matrices named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each matrix has its rows corresponding to testing positions and columns corresponding to
output dimensions (i.e., the number of GP/likelihood nodes from the associated layer).
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>D</em> (i.e., the number
of GP/likelihood nodes in the final layer) matrices named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>. Each matrix has its rows corresponding to testing positions and
columns corresponding to samples of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>L</em> (i.e., the number
of layers) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list represents samples drawn from the GP/likelihood nodes in the corresponding layer,
and contains <em>D</em> (i.e., the number of GP/likelihood nodes in the corresponding layer) matrices named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>. Each matrix gives samples
of the output from one of <em>D</em> GP/likelihood nodes, and has its rows corresponding to testing positions and columns corresponding to samples
of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li></ol>

</li>
<li><p> If <code>object</code> is an instance of the <code>lgp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that
contains two sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list
contains <em>M</em> number (same number of emulators in the final layer of the system) of matrices named <code style="white-space: pre;">&#8288;emulator1, emulator2,..., emulatorM&#8288;</code>.
Each matrix has its rows corresponding to global testing positions and columns corresponding to output dimensions of the associated emulator
in the final layer.
</p>
</li>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
two sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list contains <em>L</em>
(i.e., the number of layers in the emulated system) components named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each component represents a layer
and contains <em>M</em> number (same number of emulators in the corresponding layer of the system) of matrices named <code style="white-space: pre;">&#8288;emulator1, emulator2,..., emulatorM&#8288;</code>.
Each matrix has its rows corresponding to global testing positions and columns corresponding to output dimensions of the associated
GP/DGP emulator in the corresponding layer.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
<em>M</em> number (same number of emulators in the final layer of the system) of sub-lists named <code style="white-space: pre;">&#8288;emulator1, emulator2,..., emulatorM&#8288;</code>. Each
sub-list corresponds to an emulator in the final layer, and contains <em>D</em> matrices, named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>, that correspond to the output
dimensions of the GP/DGP emulator. Each matrix has its rows corresponding to testing positions and columns corresponding to samples
of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+lgp">lgp()</a></code>.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
<em>L</em> (i.e., the number of layers of the emulated system) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list represents a layer
and contains <em>M</em> number (same number of emulators in the corresponding layer of the system) of components named <code style="white-space: pre;">&#8288;emulator1, emulator2,..., emulatorM&#8288;</code>.
Each component corresponds to an emulator in the associated layer, and contains <em>D</em> matrices, named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>, that correspond to
the output dimensions of the GP/DGP emulator. Each matrix has its rows corresponding to testing positions and columns corresponding to
samples of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+lgp">lgp()</a></code>.
</p>
</li></ol>

</li></ul>



<h3>Note</h3>

<p>Any R vector detected in <code>x</code> will be treated as a column vector and automatically converted into a single-column R matrix.
Thus, if <code>x</code> is a single testing data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='prune'>Static pruning of a DGP emulator</h2><span id='topic+prune'></span>

<h3>Description</h3>

<p>This function implements the static pruning of a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(object, control = list(), verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class that is generated by <code>dgp()</code> with <code>struc = NULL</code>.</p>
</td></tr>
<tr><td><code id="prune_+3A_control">control</code></td>
<td>
<p>a list that can supply the following two components to control the static pruning of the DGP emulator:
</p>

<ul>
<li> <p><code>min_size</code>, the minimum number of design points required to trigger the pruning. Defaults to 10 times of the input dimensions.
</p>
</li>
<li> <p><code>threshold</code>, the R2 value above which a GP node is considered redundant and removable. Defaults to <code>0.97</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="prune_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information will be printed during the function execution. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> that could be an instance of <code>gp</code>, <code>dgp</code>, or <code>bundle</code> (of GP emulators) class.
</p>


<h3>Note</h3>


<ul>
<li><p> The function requires a DGP emulator that has been trained with a dataset comprising a minimum size equal to <code>min_size</code> in <code>control</code>.
If the training dataset size is smaller than this, it is suggested to enrich the design of the DGP emulator and prune its
structure dynamically using the <code>design()</code> function. Depending on the design of the DGP emulator, the static pruning may not be accurate.
It is thus suggested to implement dynamic pruning as a part of the sequential design via <code>design()</code>.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>;
</p>
</li></ul>

<p>in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# construct the borehole function over a hypercube
f &lt;- function(x){
  x[,1] &lt;- (0.15 - 0.5) * x[,1] + 0.5
  x[,2] &lt;- exp((log(50000) - log(100)) * x[,2] + log(100))
  x[,3] &lt;- (115600 - 63070) *x[,3] + 63070
  x[,4] &lt;- (1110 - 990) * x[,4] + 990
  x[,5] &lt;- (116 - 63.1) * x[,5] + 63.1
  x[,6] &lt;- (820 - 700) * x[,6] + 700
  x[,7] &lt;- (1680 - 1120) * x[,7] + 1120
  x[,8] &lt;- (12045 - 9855) * x[,8] + 9855
  y &lt;- apply(x, 1, RobustGaSP::borehole)
}

# set a random seed
set_seed(999)

# generate training data
X &lt;- maximinLHS(80, 8)
Y &lt;- f(X)

# generate validation data
validate_x &lt;- maximinLHS(500, 8)
validate_y &lt;- f(validate_x)

# training a DGP emulator with anisotropic squared exponential kernels
m &lt;- dgp(X, Y, share = F)

# OOS validation of the DGP emulator
plot(m, validate_x, validate_y)

# prune the emulator until no more GP nodes are removable
m &lt;- prune(m)

# OOS validation of the resulting emulator
plot(m, validate_x, validate_y)

## End(Not run)
</code></pre>

<hr>
<h2 id='read'>Load the stored emulator</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>This function loads the <code>.pkl</code> file that stores the emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(pkl_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_pkl_file">pkl_file</code></td>
<td>
<p>the path to and the name of the <code>.pkl</code> file where the emulator is stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>The S3 class of a GP emulator, a DGP emulator, a linked (D)GP emulator, or a bundle of (D)GP emulators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), lgp(), or pack() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_imp'>Reset number of imputations for a DGP emulator</h2><span id='topic+set_imp'></span>

<h3>Description</h3>

<p>This function resets the number of imputations for predictions from a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_imp(object, B = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_imp_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="set_imp_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce predictions from <code>object</code>. Increase the value to account for
more imputation uncertainties with slower predictions. Decrease the value for lower imputation uncertainties
but faster predictions. Defaults to <code>5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with the information of <code>B</code> incorporated.
</p>


<h3>Note</h3>


<ul>
<li><p> This function is useful when a DGP emulator has been trained and one wants to make faster predictions by decreasing
the number of imputations without rebuilding the emulator.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See design() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_linked_idx'>Set linked indices</h2><span id='topic+set_linked_idx'></span>

<h3>Description</h3>

<p>This function adds the linked information to a GP or DGP emulator if the information is not provided
when the emulator is constructed by <code><a href="#topic+gp">gp()</a></code> or <code><a href="#topic+dgp">dgp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_linked_idx(object, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_linked_idx_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code> or <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="set_linked_idx_+3A_idx">idx</code></td>
<td>
<p>same as the argument <code>linked_idx</code> of <code><a href="#topic+gp">gp()</a></code> and <code><a href="#topic+dgp">dgp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with the information of <code>idx</code> incorporated.
</p>


<h3>Note</h3>

<p>This function is useful when different models are emulated by different teams. Each team can create their (D)GP emulator
even without knowing how different emulators are connected together. When this information is available and
different emulators are collected, the connection information between emulators can then be assigned to
individual emulators with this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_seed'>Random seed generator</h2><span id='topic+set_seed'></span>

<h3>Description</h3>

<p>This function initializes a random number generator that sets the random seed in both R and Python
to ensure reproducible results from the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_seed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_seed_+3A_seed">seed</code></td>
<td>
<p>a single integer value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='summary'>Summary of a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+summary'></span><span id='topic+summary.gp'></span><span id='topic+summary.dgp'></span><span id='topic+summary.lgp'></span>

<h3>Description</h3>

<p>This function summarizes key information of a GP, DGP or linked (D)GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
summary(object, ...)

## S3 method for class 'dgp'
summary(object, ...)

## S3 method for class 'lgp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A table summarizing key information contained in <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='trace_plot'>Plot of DGP model parameter traces</h2><span id='topic+trace_plot'></span>

<h3>Description</h3>

<p>This function plots the traces of model parameters of a chosen GP node
in a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_plot(object, layer = NULL, node = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_plot_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_layer">layer</code></td>
<td>
<p>the index of a layer. Defaults to <code>NULL</code> for the final layer.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_node">node</code></td>
<td>
<p>the index of a GP node in the layer specified by <code>layer</code>. Defaults to <code>1</code> for the first GP node in the
corresponding layer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='unpack'>Unpack a bundle of (D)GP emulators</h2><span id='topic+unpack'></span>

<h3>Description</h3>

<p>This function unpacks a bundle of (D)GP emulators safely so any further manipulations of unpacked individual emulators
will not impact the ones in the bundle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_+3A_object">object</code></td>
<td>
<p>an instance of the class <code>bundle</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A named list that contains individual emulators (named <code style="white-space: pre;">&#8288;emulator1,...,emulatorS&#8288;</code>) packed in <code>object</code>,
where <code>S</code> is the number of emulators in <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See pack() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='update'>Update a GP or DGP emulator</h2><span id='topic+update'></span><span id='topic+update.dgp'></span><span id='topic+update.gp'></span>

<h3>Description</h3>

<p>This function updates the training input and output of a GP or DGP emulator with an option to refit the emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update(object, X, Y, refit, reset, verb, ...)

## S3 method for class 'dgp'
update(
  object,
  X,
  Y,
  refit = FALSE,
  reset = FALSE,
  verb = TRUE,
  N = 100,
  cores = 1,
  ess_burn = 10,
  B = NULL,
  ...
)

## S3 method for class 'gp'
update(object, X, Y, refit = FALSE, reset = FALSE, verb = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="update_+3A_x">X</code></td>
<td>
<p>the new input data which is a matrix where each row is an input training data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="update_+3A_y">Y</code></td>
<td>
<p>the new output data:
</p>

<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, <code>Y</code> is a matrix with only one column and each row being an output data point.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, <code>Y</code> is a matrix with its rows being output data points and columns being
output dimensions. When <code>likelihood</code> (see below) is not <code>NULL</code>, <code>Y</code> must be a matrix with only one column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="update_+3A_refit">refit</code></td>
<td>
<p>a bool indicating whether to re-fit the emulator <code>object</code> after the training input and output are updated. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_reset">reset</code></td>
<td>
<p>a bool indicating whether to reset hyperparameters of the emulator <code>object</code> to their initial values when the emulator was
constructed, after the training input and output are updated. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
<tr><td><code id="update_+3A_n">N</code></td>
<td>
<p>number of training iterations used to re-fit the emulator <code>object</code> if it is an instance of the <code>dgp</code> class. Defaults to <code>100</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_cores">cores</code></td>
<td>
<p>the number of cores/workers to be used to re-fit GP components (in the same layer)
at each M-step during the re-fitting. If set to <code>NULL</code>, the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>.
Only use multiple cores when there is a large number of GP components in different layers and optimization of GP components
is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for the ESS-within-Gibbs at each I-step in training the emulator <code>object</code> if it is an
instance of the <code>dgp</code> class. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_b">B</code></td>
<td>
<p>the number of imputations for predictions from the updated emulator <code>object</code> if it is an instance of the <code>dgp</code> class.
This overrides the number of imputations set in <code>object</code>. Set to <code>NULL</code> to use the same number of imputations set
in <code>object</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>;
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>; and
</p>
</li>
<li> <p><code>design</code> created by <code><a href="#topic+design">design()</a></code>
</p>
</li></ul>

<p>in <code>object</code> will be removed and not contained in the returned object.
</p>
</li>
<li><p> Any R vector detected in <code>X</code> and <code>Y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>X</code> is a single data point with multiple dimensions, it must be given as a matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See alm(), mice(), pei(), or vigf() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='validate'>Validate a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+validate'></span><span id='topic+validate.gp'></span><span id='topic+validate.dgp'></span><span id='topic+validate.lgp'></span>

<h3>Description</h3>

<p>This function validate a constructed GP, DGP, or linked (D)GP emulator via the Leave-One-Out (LOO)
cross validation or Out-Of-Sample (OOS) validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(object, x_test, y_test, method, verb, force, cores, ...)

## S3 method for class 'gp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = "mean_var",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  ...
)

## S3 method for class 'dgp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = "mean_var",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  threading = FALSE,
  ...
)

## S3 method for class 'lgp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = "mean_var",
  verb = TRUE,
  force = FALSE,
  cores = 1,
  threading = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="validate_+3A_x_test">x_test</code></td>
<td>
<p>the OOS testing input data:
</p>

<ul>
<li><p> if <code>x</code> is an instance of the <code>gp</code> or <code>dgp</code> class, <code>x_test</code> is a matrix where each row is an input testing data point and each column is an input dimension.
</p>
</li>
<li><p> if <code>x</code> is an instance of the <code>lgp</code> class, <code>x_test</code> can be a matrix or a list:
</p>

<ul>
<li><p> if <code>x_test</code> is a matrix, it is the global testing input data that feed into the emulators in the first layer of a system.
The rows of <code>x_test</code> represent different input data points and the columns represent input dimensions across all emulators in
the first layer of the system. In this case, it is assumed that the only global input to the system is the input to the
emulators in the first layer and there is no global input to emulators in other layers.
</p>
</li>
<li><p> if <code>x_test</code> is a list, it should have <em>L</em> (the number of layers in an emulator system) elements. The first element
is a matrix that represents the global testing input data that feed into the emulators in the first layer of the system. The
remaining <em>L-1</em> elements are <em>L-1</em> sub-lists, each of which contains a number (the same number of emulators in
the corresponding layer) of matrices (rows being testing input data points and columns being input dimensions) that represent the
global testing input data to the emulators in the corresponding layer. The matrices must be placed in the sub-lists based on how
their corresponding emulators are placed in <code>struc</code> argument of <code><a href="#topic+lgp">lgp()</a></code>. If there is no global input data to a certain emulator,
set <code>NULL</code> in the corresponding sub-list of <code>x_test</code>.
</p>
</li></ul>

</li></ul>

<p><code>x_test</code> must be provided for the validation if <code>x</code> is an instance of the <code>lgp</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_y_test">y_test</code></td>
<td>
<p>the OOS testing output data that correspond to <code>x_test</code>:
</p>

<ul>
<li><p> if <code>x</code> is an instance of the <code>gp</code> class, <code>y_test</code> is a matrix with only one column and each row being an testing output data point.
</p>
</li>
<li><p> if <code>x</code> is an instance of the <code>dgp</code> class, <code>y_test</code> is a matrix with its rows being testing output data points and columns being
output dimensions.
</p>
</li>
<li><p> if <code>x</code> is an instance of the <code>lgp</code> class, <code>y_test</code> can be a single matrix or a list of matrices:
</p>

<ul>
<li><p> if <code>y_test</code> is a single matrix, then there is only one emulator in the final layer of the linked emulator system and <code>y_test</code>
represents the emulator's output with rows being testing positions and columns being output dimensions.
</p>
</li>
<li><p> if <code>y_test</code> is a list, then <code>y_test</code> should have <em>M</em> number (the same number of emulators in the final layer of the system) of matrices.
Each matrix has its rows corresponding to testing positions and columns corresponding to output dimensions of the associated emulator
in the final layer.
</p>
</li></ul>

</li></ul>

<p><code>y_test</code> must be provided for the validation if <code>x</code> is an instance of the <code>lgp</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_method">method</code></td>
<td>
<p>the prediction approach in validations: mean-variance (<code>"mean_var"</code>) or sampling (<code>"sampling"</code>) approach. Defaults to <code>"mean_var"</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on validations will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_force">force</code></td>
<td>
<p>a bool indicating whether to force the LOO or OOS re-evaluation when <code>loo</code> or <code>oos</code> slot already exists in <code>object</code>. When <code>force = FALSE</code>,
<code><a href="#topic+validate">validate()</a></code> will try to determine automatically if the LOO or OOS re-evaluation is needed. Set <code>force</code> to <code>TRUE</code> when LOO or OOS re-evaluation
is required. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_cores">cores</code></td>
<td>
<p>the number of cores/workers to be used for the LOO or OOS validation. If set to <code>NULL</code>,
the number of cores is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
<tr><td><code id="validate_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the LOO or OOS.
Turning this option on could improve the speed of validations when the emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, an updated <code>object</code> is returned with an additional slot called <code>loo</code> (for LOO cross validation) or
<code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_train</code> (or <code>x_test</code>) and <code>y_train</code> (or <code>y_test</code>) that contain the validation data points for LOO (or OOS).
</p>
</li>
<li><p> a column matrix called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of the
GP emulator at validation positions.
</p>
</li>
<li><p> three column matrices called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of the
GP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard deviations above
and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a numeric value called <code>rmse</code> that contains the root mean/median squared error of the GP emulator.
</p>
</li>
<li><p> a numeric value called <code>nrmse</code> that contains the (min-max) normalized root mean/median squared error of the GP emulator. The min-max normalization
is based on the maximum and minimum values of the validation outputs contained in <code>y_train</code> (or <code>y_test</code>).
</p>
</li></ul>

<p>The rows of matrices (<code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, and <code>upper</code>) correspond to the validation positions.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, an updated <code>object</code> is returned with an additional slot called <code>loo</code> (for LOO cross validation) or
<code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_train</code> (or <code>x_test</code>) and <code>y_train</code> (or <code>y_test</code>) that contain the validation data points for LOO (or OOS).
</p>
</li>
<li><p> a matrix called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of the
DGP emulator at validation positions.
</p>
</li>
<li><p> three matrices called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of the
DGP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard deviations above
and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a vector called <code>rmse</code> that contains the root mean/median squared errors of the DGP emulator across different output
dimensions.
</p>
</li>
<li><p> a vector called <code>nrmse</code> that contains the (min-max) normalized root mean/median squared errors of the DGP emulator across different output
dimensions. The min-max normalization is based on the maximum and minimum values of the validation outputs contained in <code>y_train</code> (or <code>y_test</code>).
</p>
</li></ul>

<p>The rows and columns of matrices (<code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, and <code>upper</code>) correspond to the validation positions and DGP emulator output
dimensions, respectively.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>lgp</code> class, an updated <code>object</code> is returned with an additional slot called <code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_test</code> and <code>y_test</code> that contain the validation data points for OOS.
</p>
</li>
<li><p> a list called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of
the linked (D)GP emulator at validation positions.
</p>
</li>
<li><p> three lists called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of
the linked (D)GP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard
deviations above and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a list called <code>rmse</code> that contains the root mean/median squared errors of the linked (D)GP emulator.
</p>
</li>
<li><p> a list called <code>nrmse</code> that contains the (min-max) normalized root mean/median squared errors of the linked (D)GP emulator. The min-max normalization
is based on the maximum and minimum values of the validation outputs contained in <code>y_test</code>.
</p>
</li></ul>

<p>Each element in <code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, <code>upper</code>, <code>rmse</code>, and <code>nrmse</code> corresponds to a (D)GP emulator in the final layer of the linked (D)GP
emulator.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> When both <code>x_test</code> and <code>y_test</code> are <code>NULL</code>, the LOO cross validation will be implemented. Otherwise, OOS validation will
be implemented. The LOO validation is only applicable to a GP or DGP emulator (i.e., <code>x</code> is an instance of the <code>gp</code> or <code>dgp</code>
class). If a linked (D)GP emulator (i.e., <code>x</code> is an instance of the <code>lgp</code> class) is provided, <code>x_test</code> and <code>y_test</code> must
also be provided for OOS validation.
</p>
</li>
<li><p> Any R vector detected in <code>x_test</code> and <code>y_test</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>x_test</code> or <code>y_test</code> is a single testing data point with multiple dimensions, it must be given as a matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='vigf'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using VIGF</h2><span id='topic+vigf'></span><span id='topic+vigf.gp'></span><span id='topic+vigf.dgp'></span><span id='topic+vigf.bundle'></span>

<h3>Description</h3>

<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Variance of Improvement for Global Fit (VIGF). For VIGF on GP emulators, see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vigf(object, x_cand, ...)

## S3 method for class 'gp'
vigf(object, x_cand, batch_size = 1, workers = 1, ...)

## S3 method for class 'dgp'
vigf(
  object,
  x_cand,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
vigf(
  object,
  x_cand,
  batch_size = 1,
  workers = 1,
  threading = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vigf_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vigf_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class, <code>x_cand</code> could also
be a list with the length equal to the number of emulators contained in the <code>object</code>. Each slot in <code>x_cand</code> is a matrix
that gives a candidate set for each emulator included in the bundle. See <em>Note</em> section below for further information.</p>
</td></tr>
<tr><td><code id="vigf_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+vigf">vigf()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="vigf_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_workers">workers</code></td>
<td>
<p>the number of workers/cores to be used for the criterion calculation. If set to <code>NULL</code>,
the number of workers is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_threading">threading</code></td>
<td>
<p>a bool indicating whether to use the multi-threading to accelerate the criterion calculation for a DGP emulator.
Turning this option on could improve the speed of criterion calculations when the DGP emulator is built with a moderately large number of
training data points and the Mat√©rn-2.5 kernel.</p>
</td></tr>
<tr><td><code id="vigf_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the VIGF across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregations of scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable the aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, a vector is returned with the length equal to <code>batch_size</code>, giving the positions (i.e., row numbers)
of next design points from <code>x_cand</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to one (if <code>aggregate</code>
is not <code>NULL</code>) or the output dimension (if <code>aggregate</code> is <code>NULL</code>), giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added
to the DGP emulator across different outputs. If <code>object</code> is a DGP emulator with either <code>Hetero</code> or <code>NegBin</code> likelihood layer, the returned matrix has
two columns with the first column giving positions of next design points from <code>x_cand</code> that correspond to the mean parameter of the normal or negative Binomial
distribution, and the second column giving positions of next design points from <code>x_cand</code> that correspond to the variance parameter of the normal distribution or
the dispersion parameter of the negative Binomial distribution.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with row number equal to <code>batch_size</code> and column number equal to the number of
emulators in the bundle, giving positions (i.e., row numbers) of next design points from <code>x_cand</code> to be added to individual emulators.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> The column order of the first argument of <code>aggregate</code> must be consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the
<code>dgp</code> class), or the order of emulators placed in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class;
</p>
</li>
<li><p> If <code>x_cand</code> is supplied as a list when <code>object</code> is an instance of <code>bundle</code> class and a <code>aggregate</code> function is provided, the matrices in <code>x_cand</code> must have
common rows (i.e., the candidate sets of emulators in the bundle have common input locations) so the <code>aggregate</code> function can be applied.
</p>
</li>
<li><p> Any R vector detected in <code>x_cand</code> will be treated as a column vector and automatically converted into a single-column
R matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Mohammadi, H., &amp; Challenor, P. (2022). Sequential adaptive design for emulating costly computer codes. <em>arXiv:2206.12113</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# generate a candidate set
x_cand &lt;- maximinLHS(200,1)

# locate the next design point using VIGF
next_point &lt;- vigf(m, x_cand = x_cand)
X_new &lt;- x_cand[next_point,,drop = F]

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit with 500 training iterations
m &lt;- update(m, X, Y, refit = TRUE, N = 500)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='window'>Trim the sequences of model parameters of a DGP emulator</h2><span id='topic+window'></span>

<h3>Description</h3>

<p>This function trim the sequences of model parameters of a DGP emulator
that are generated during the training.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window(object, start, end = NULL, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="window_+3A_start">start</code></td>
<td>
<p>the first iteration before which all iterations are trimmed from the sequences.</p>
</td></tr>
<tr><td><code id="window_+3A_end">end</code></td>
<td>
<p>the last iteration after which all iterations are trimmed from the sequences.
Set to <code>NULL</code> to keep all iterations after (including) <code>start</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="window_+3A_thin">thin</code></td>
<td>
<p>the interval between the <code>start</code> and <code>end</code> iterations to thin out the sequences.
Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with trimmed sequences of model parameters.
</p>


<h3>Note</h3>


<ul>
<li><p> This function is useful when a DGP emulator has been trained and one wants to trim
the sequences of model parameters and use the trimmed sequences to generate the point estimates
of DGP model parameters for predictions.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='write'>Save the constructed emulator</h2><span id='topic+write'></span>

<h3>Description</h3>

<p>This function saves the constructed emulator to a <code>.pkl</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write(object, pkl_file, light = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code>, <code>dgp</code>, <code>lgp</code>, or <code>bundle</code>.</p>
</td></tr>
<tr><td><code id="write_+3A_pkl_file">pkl_file</code></td>
<td>
<p>the path to and the name of the <code>.pkl</code> file to which
the emulator <code>object</code> is saved.</p>
</td></tr>
<tr><td><code id="write_+3A_light">light</code></td>
<td>
<p>a bool indicating if a light version of the constructed emulator (that requires a small storage) will be saved.
This argument has no effects on GP or bundles of GP emulators. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value. <code>object</code> will be save to a local <code>.pkl</code> file specified by <code>pkl_file</code>.
</p>


<h3>Note</h3>

<p>Since the constructed emulators are 'python' objects, <code><a href="base.html#topic+save">save()</a></code> from R will not work as it is only for R objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), lgp(), or pack() for an example.

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
