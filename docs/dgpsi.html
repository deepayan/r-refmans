<!DOCTYPE html><html lang="en-US"><head><title>Help for package dgpsi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dgpsi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dgpsi-package'><p>dgpsi: Interface to 'dgpsi' for Deep and Linked Gaussian Process Emulations</p></a></li>
<li><a href='#alm'><p>Locate the next design point(s) for a (D)GP emulator or a bundle of (D)GP emulators using Active Learning MacKay (ALM)</p></a></li>
<li><a href='#combine'><p>Combine layers</p></a></li>
<li><a href='#continue'><p>Continue training a DGP emulator</p></a></li>
<li><a href='#deserialize'><p>Restore the serialized emulator</p></a></li>
<li><a href='#design'><p>Sequential design of a (D)GP emulator or a bundle of (D)GP emulators</p></a></li>
<li><a href='#dgp'><p>Deep Gaussian process emulator construction</p></a></li>
<li><a href='#draw'><p>Validation and diagnostic plots for a sequential design</p></a></li>
<li><a href='#get_thread_num'><p>Get the number of threads</p></a></li>
<li><a href='#gp'><p>Gaussian process emulator construction</p></a></li>
<li><a href='#init_py'><p>'python' environment initialization</p></a></li>
<li><a href='#lgp'><p>Linked (D)GP emulator construction</p></a></li>
<li><a href='#mice'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using MICE</p></a></li>
<li><a href='#nllik'><p>Calculate the predictive negative log-likelihood</p></a></li>
<li><a href='#pack'><p>Pack GP and DGP emulators into a bundle</p></a></li>
<li><a href='#plot'><p>Validation plots of a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#predict'><p>Prediction from GP, DGP, or linked (D)GP emulators</p></a></li>
<li><a href='#prune'><p>Static pruning of a DGP emulator</p></a></li>
<li><a href='#read'><p>Load the stored emulator</p></a></li>
<li><a href='#serialize'><p>Serialize the constructed emulator</p></a></li>
<li><a href='#set_id'><p>Set Emulator ID</p></a></li>
<li><a href='#set_imp'><p>Reset number of imputations for a DGP emulator</p></a></li>
<li><a href='#set_linked_idx'><p>Set linked indices</p></a></li>
<li><a href='#set_seed'><p>Random seed generator</p></a></li>
<li><a href='#set_thread_num'><p>Set the number of threads</p></a></li>
<li><a href='#set_vecchia'><p>Add or remove the Vecchia approximation</p></a></li>
<li><a href='#summary'><p>Summary of a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#trace_plot'><p>Trace plot for DGP hyperparameters</p></a></li>
<li><a href='#unpack'><p>Unpack a bundle of (D)GP emulators</p></a></li>
<li><a href='#update'><p>Update a GP or DGP emulator</p></a></li>
<li><a href='#validate'><p>Validate a constructed GP, DGP, or linked (D)GP emulator</p></a></li>
<li><a href='#vigf'><p>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using VIGF</p></a></li>
<li><a href='#window'><p>Trim the sequence of hyperparameter estimates within a DGP emulator</p></a></li>
<li><a href='#write'><p>Save the constructed emulator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'dgpsi' for Deep and Linked Gaussian Process
Emulations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deyu Ming &lt;deyu.ming.16@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to the 'python' package 'dgpsi' for Gaussian process, deep Gaussian process, 
             and linked deep Gaussian process emulations of computer models and networks using stochastic imputation (SI). 
             The implementations follow Ming &amp; Guillas (2021) &lt;<a href="https://doi.org/10.1137%2F20M1323771">doi:10.1137/20M1323771</a>&gt; and 
             Ming, Williamson, &amp; Guillas (2023) &lt;<a href="https://doi.org/10.1080%2F00401706.2022.2124311">doi:10.1080/00401706.2022.2124311</a>&gt; and 
             Ming &amp; Williamson (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2306.01212">doi:10.48550/arXiv.2306.01212</a>&gt;. To get started with the package, 
             see <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mingdeyu/dgpsi-R">https://github.com/mingdeyu/dgpsi-R</a>,
<a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mingdeyu/dgpsi-R/issues">https://github.com/mingdeyu/dgpsi-R/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate (&ge; 1.26), benchmarkme (&ge; 1.0.8), utils, ggplot2,
ggforce, reshape2, patchwork, lhs, methods, stats, clhs, dplyr,
uuid, tidyr, rlang, lifecycle, magrittr, visNetwork, parallel,
kableExtra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MASS, R.utils, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-14 23:26:04 UTC; deyu</td>
</tr>
<tr>
<td>Author:</td>
<td>Deyu Ming [aut, cre, cph],
  Daniel Williamson [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-14 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dgpsi-package'>dgpsi: Interface to 'dgpsi' for Deep and Linked Gaussian Process Emulations</h2><span id='topic+dgpsi'></span><span id='topic+dgpsi-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Interface to the 'python' package 'dgpsi' for Gaussian process, deep Gaussian process, and linked deep Gaussian process emulations of computer models and networks using stochastic imputation (SI). The implementations follow Ming &amp; Guillas (2021) <a href="https://doi.org/10.1137/20M1323771">doi:10.1137/20M1323771</a> and Ming, Williamson, &amp; Guillas (2023) <a href="https://doi.org/10.1080/00401706.2022.2124311">doi:10.1080/00401706.2022.2124311</a> and Ming &amp; Williamson (2023) <a href="https://doi.org/10.48550/arXiv.2306.01212">doi:10.48550/arXiv.2306.01212</a>. To get started with the package, see <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Deyu Ming <a href="mailto:deyu.ming.16@ucl.ac.uk">deyu.ming.16@ucl.ac.uk</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Williamson <a href="mailto:d.williamson@exeter.ac.uk">d.williamson@exeter.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mingdeyu/dgpsi-R">https://github.com/mingdeyu/dgpsi-R</a>
</p>
</li>
<li> <p><a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mingdeyu/dgpsi-R/issues">https://github.com/mingdeyu/dgpsi-R/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alm'>Locate the next design point(s) for a (D)GP emulator or a bundle of (D)GP emulators using Active Learning MacKay (ALM)</h2><span id='topic+alm'></span><span id='topic+alm.gp'></span><span id='topic+alm.dgp'></span><span id='topic+alm.bundle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Active Learning MacKay (ALM) criterion (see the reference below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alm(object, ...)

## S3 method for class 'gp'
alm(
  object,
  x_cand = NULL,
  n_start = 20,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  ...
)

## S3 method for class 'dgp'
alm(
  object,
  x_cand = NULL,
  n_start = 20,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
alm(
  object,
  x_cand = NULL,
  n_start = 20,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alm_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="alm_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+alm">alm()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="alm_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class and <code>aggregate</code> is not supplied, <code>x_cand</code> can also be a list.
The list must have a length equal to the number of emulators in <code>object</code>, with each element being a matrix representing the candidate set for a corresponding
emulator in the bundle. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_n_start">n_start</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer that gives the number of initial design points to be used to determine next design point(s). This argument
is only used when <code>x_cand</code> is <code>NULL</code>. Defaults to <code>20</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the criterion calculation. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_workers">workers</code></td>
<td>
<p>the number of processes to be used for design point selection. If set to <code>NULL</code>,
the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Defaults to <code>1</code>. The argument does not currently support Windows machines when the <code>aggregate</code>
function is provided, due to the significant overhead caused by initializing the Python environment for each worker under spawning.</p>
</td></tr>
<tr><td><code id="alm_+3A_limits">limits</code></td>
<td>
<p>a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one input dimension.
If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input dimensions, and its
first and second columns correspond to the minimum and maximum values of the input dimensions. This
argument is only used when <code>x_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_int">int</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool or a vector of bools that indicates if an input dimension is an integer type. If a single bool is given, it will be applied to
all input dimensions. If a vector is provided, it should have a length equal to the input dimensions and will be applied to individual
input dimensions. This argument is only used when <code>x_cand = NULL</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="alm_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the ALM across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix is equal to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregate scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ol>
<li><p> If <code>x_cand</code> is not <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a vector of length <code>batch_size</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code>.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a vector of length <code>batch_size * D</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code> to be added to the DGP emulator.
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with <code>batch_size</code> rows and a column for each emulator in
the bundle, containing the positions (row numbers) of the next design points from <code>x_cand</code> for individual emulators.
</p>
</li></ul>

</li>
<li><p> If <code>x_cand</code> is <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a matrix with <code>batch_size</code> rows is returned, giving the next design points to be evaluated.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a matrix with <code>batch_size * D</code> rows is returned, where:
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a list is returned with a length equal to the number of emulators in the bundle. Each
element of the list is a matrix with <code>batch_size</code> rows, where each row represents a design point to be added to the corresponding emulator.
</p>
</li></ul>

</li></ol>



<h3>Note</h3>

<p>The first column of the matrix supplied to the first argument of <code>aggregate</code> must correspond to the first output dimension of the DGP emulator
if <code>object</code> is an instance of the <code>dgp</code> class, and so on for subsequent columns and dimensions. If <code>object</code> is an instance of the <code>bundle</code> class,
the first column must correspond to the first emulator in the bundle, and so on for subsequent columns and emulators.
</p>


<h3>References</h3>

<p>MacKay, D. J. (1992). Information-based objective functions for active data selection. <em>Neural Computation</em>, <strong>4(4)</strong>, 590-604.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# specify the input range
lim &lt;- c(0,1)

# locate the next design point using ALM
X_new &lt;- alm(m, limits = lim)

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit
m &lt;- update(m, X, Y, refit = TRUE)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine'>Combine layers</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated and will be removed in the next release, as it is
simply a wrapper for the <code><a href="base.html#topic+list">list()</a></code> function. To construct linked (D)GP structures,
please use the updated <code><a href="#topic+lgp">lgp()</a></code> function, which provides a simpler and more efficient
approach to building (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_+3A_...">...</code></td>
<td>
<p>a sequence of lists. Each list represents a system layer and contains emulators (produced by <code><a href="#topic+gp">gp()</a></code> or
<code><a href="#topic+dgp">dgp()</a></code>) in that layer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A list defining a linked (D)GP structure to be passed to <code>struc</code> of <code><a href="#topic+lgp">lgp()</a></code>.
</p>

<hr>
<h2 id='continue'>Continue training a DGP emulator</h2><span id='topic+continue'></span>

<h3>Description</h3>

<p>This function implements additional training iterations for a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(
  object,
  N = NULL,
  cores = 1,
  ess_burn = 10,
  verb = TRUE,
  burnin = NULL,
  B = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class.</p>
</td></tr>
<tr><td><code id="continue_+3A_n">N</code></td>
<td>
<p>additional number of iterations to train the DGP emulator. If set to <code>NULL</code>, the number of iterations is set to <code>500</code> if the DGP emulator
was constructed without the Vecchia approximation, and is set to <code>200</code> if Vecchia approximation was used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_cores">cores</code></td>
<td>
<p>the number of processes to be used to optimize GP components (in the same layer) at each M-step of the training. If set to <code>NULL</code>,
the number of processes is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code> if the DGP emulator was constructed without the Vecchia approximation.
Otherwise, the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Only use multiple processes when there is a large number of
GP components in different layers and optimization of GP components is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for ESS-within-Gibbs
at each I-step of the training. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if a progress bar will be printed during training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_burnin">burnin</code></td>
<td>
<p>the number of training iterations to be discarded for
point estimates calculation. Must be smaller than the overall training iterations
so-far implemented. If this is not specified, only the last 25% of iterations
are used. This overrides the value of <code>burnin</code> set in <code><a href="#topic+dgp">dgp()</a></code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="continue_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce predictions. Increase the value to account for
more imputation uncertainty. This overrides the value of <code>B</code> set in <code><a href="#topic+dgp">dgp()</a></code> if <code>B</code> is not
<code>NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> One can also use this function to fit an untrained DGP emulator constructed by <code><a href="#topic+dgp">dgp()</a></code> with <code>training = FALSE</code>.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='deserialize'>Restore the serialized emulator</h2><span id='topic+deserialize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function restores the serialized emulator created by <code><a href="#topic+serialize">serialize()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deserialize(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deserialize_+3A_object">object</code></td>
<td>
<p>the serialized object of an emulator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>The S3 class of a GP emulator, a DGP emulator, a linked (D)GP emulator, or a bundle of (D)GP emulators.
</p>


<h3>Note</h3>

<p>See the <em>Note</em> section in <code><a href="#topic+serialize">serialize()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(future)
library(future.apply)
library(dgpsi)

# model
f &lt;- function(x) {
 (sin(7.5*x)+1)/2
}

# training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# train a DGP emulator
m &lt;- dgp(X, Y, name = "matern2.5")

# testing input data
X_dgp &lt;- seq(0, 1, length = 100)

# serialize the DGP emulator
m_serialized &lt;- serialize(m)

# start a multi-session with three cores for parallel predictions
plan(multisession, workers = 3)

# perform parallel predictions
results &lt;- future_lapply(1:length(X_dgp), function(i) {
  m_deserialized &lt;- deserialize(m_serialized)
  mean_i &lt;- predict(m_deserialized, X_dgp[i])$results$mean
}, future.seed = TRUE)

# reset the future plan to sequential
plan(sequential)

# combine mean predictions
pred_mean &lt;- do.call(rbind, results)

## End(Not run)
</code></pre>

<hr>
<h2 id='design'>Sequential design of a (D)GP emulator or a bundle of (D)GP emulators</h2><span id='topic+design'></span><span id='topic+design.gp'></span><span id='topic+design.dgp'></span><span id='topic+design.bundle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function implements sequential design and active learning for a (D)GP emulator or
a bundle of (D)GP emulators, supporting an array of popular methods as well as user-specified approaches.
It can also be used as a wrapper for Bayesian optimization methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(
  object,
  N,
  x_cand,
  y_cand,
  n_sample,
  n_cand,
  limits,
  f,
  reps,
  freq,
  x_test,
  y_test,
  reset,
  target,
  method,
  batch_size,
  eval,
  verb,
  autosave,
  new_wave,
  M_val,
  cores,
  ...
)

## S3 method for class 'gp'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_sample = 200,
  n_cand = lifecycle::deprecated(),
  limits = NULL,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  batch_size = 1,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  M_val = 50,
  cores = 1,
  ...
)

## S3 method for class 'dgp'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_sample = 200,
  n_cand = lifecycle::deprecated(),
  limits = NULL,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  batch_size = 1,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  M_val = 50,
  cores = 1,
  train_N = NULL,
  refit_cores = 1,
  pruning = TRUE,
  control = list(),
  ...
)

## S3 method for class 'bundle'
design(
  object,
  N,
  x_cand = NULL,
  y_cand = NULL,
  n_sample = 200,
  n_cand = lifecycle::deprecated(),
  limits = NULL,
  f = NULL,
  reps = 1,
  freq = c(1, 1),
  x_test = NULL,
  y_test = NULL,
  reset = FALSE,
  target = NULL,
  method = vigf,
  batch_size = 1,
  eval = NULL,
  verb = TRUE,
  autosave = list(),
  new_wave = TRUE,
  M_val = 50,
  cores = 1,
  train_N = NULL,
  refit_cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="design_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="design_+3A_n">N</code></td>
<td>
<p>the number of iterations for the sequential design.</p>
</td></tr>
<tr><td><code id="design_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design points are determined. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_y_cand">y_cand</code></td>
<td>
<p>a matrix (with each row being a simulator evaluation and column being an output dimension) that gives the realizations
from the simulator at input positions in <code>x_cand</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_n_sample">n_sample</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer that gives the size of a sub-set to be sampled from the candidate set <code>x_cand</code> at each step of the sequential design to determine the next
design point, if <code>x_cand</code> is not <code>NULL</code>.
</p>
<p>Defaults to <code>200</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_n_cand">n_cand</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> this argument is deprecated. Use <code>n_sample</code> instead.</p>
</td></tr>
<tr><td><code id="design_+3A_limits">limits</code></td>
<td>
<p>a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one
input dimension. If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input
dimensions, and its first and second columns correspond to the minimum and maximum values of the input dimensions. Set
<code>limits = NULL</code> if <code>x_cand</code> is supplied. This argument is only used when <code>x_cand</code> is not supplied, i.e., <code>x_cand = NULL</code>. Defaults to <code>NULL</code>. If you provide
a custom <code>method</code> function with an argument called <code>limits</code>, the value of <code>limits</code> will be passed to your function.</p>
</td></tr>
<tr><td><code id="design_+3A_f">f</code></td>
<td>
<p>an R function representing the simulator. <code>f</code> must adhere to the following rules:
</p>

<ul>
<li> <p><strong>First argument</strong>: a matrix where rows correspond to different design points, and columns represent input dimensions.
</p>
</li>
<li> <p><strong>Function output</strong>:
</p>

<ul>
<li><p> a matrix where rows correspond to different outputs (matching the input design points) and columns represent output dimensions.
If there is only one output dimension, the function should return a matrix with a single column.
</p>
</li>
<li><p> alternatively, a list where:
</p>

<ul>
<li><p> the first element is the output matrix as described above.
</p>
</li>
<li><p> additional named elements can optionally update values of arguments with matching names passed via <code>...</code>. This list output is
useful if additional arguments to <code>f</code>, <code>method</code>, or <code>eval</code> need to be updated after each sequential design iteration.
</p>
</li></ul>

</li></ul>

</li></ul>

<p>See the <em>Note</em> section below for additional details. This argument is required and must be supplied when <code>y_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_reps">reps</code></td>
<td>
<p>an integer that gives the number of repetitions of the located design points to be created and used for evaluations of <code>f</code>. Set the
argument to an integer greater than <code>1</code> only if <code>f</code> is a stochastic function that can generate different responses given for the same input and the
supplied emulator <code>object</code> can deal with stochastic responses, e.g., a (D)GP emulator with <code>nugget_est = TRUE</code> or a DGP emulator with a
likelihood layer. The argument is only used when <code>f</code> is supplied. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_freq">freq</code></td>
<td>
<p>a vector of two integers with the first element indicating the number of iterations taken between re-estimating
the emulator hyperparameters, and the second element defining the number of iterations to take between re-calculation of evaluating metrics
on the validation set (see <code>x_test</code> below) via the <code>eval</code> function. Defaults to <code>c(1, 1)</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_x_test">x_test</code></td>
<td>
<p>a matrix (with each row being an input testing data point and each column being an input dimension) that gives the testing
input data to evaluate the emulator after each <code>freq[2]</code> iterations of the sequential design. Set to <code>NULL</code> for LOO-based emulator validation.
Defaults to <code>NULL</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_y_test">y_test</code></td>
<td>
<p>the testing output data corresponding to <code>x_test</code> for emulator validation after each <code>freq[2]</code> iterations of the sequential design:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> class, <code>y_test</code> is a matrix with only one column and each row contains a testing output data point from the corresponding row of <code>x_test</code>.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>dgp</code> class, <code>y_test</code> is a matrix with its rows containing testing output data points corresponding to the same rows of <code>x_test</code> and columns representing the
output dimensions.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>bundle</code> class, <code>y_test</code> is a matrix with each row representing the outputs for the corresponding row of <code>x_test</code> and each column representing the output of the different emulators in the bundle.
</p>
</li></ul>

<p>Set to <code>NULL</code> for LOO-based emulator validation. Defaults to <code>NULL</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_reset">reset</code></td>
<td>
<p>A bool or a vector of bools indicating whether to reset the hyperparameters of the emulator(s) to their initial values (as set during initial construction) before re-fitting.
The re-fitting occurs based on the frequency specified by <code>freq[1]</code>. This option is useful when hyperparameters are suspected to have converged to a local optimum affecting validation performance.
</p>

<ul>
<li><p> If a single bool is provided, it applies to every iteration of the sequential design.
</p>
</li>
<li><p> If a vector is provided, its length must equal <code>N</code> (even if the re-fit frequency specified in <code>freq[1]</code> is not 1) and it will apply to the corresponding iterations of the sequential design.
</p>
</li></ul>

<p>Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_target">target</code></td>
<td>
<p>a number or vector specifying the target evaluation metric value(s) at which the sequential design should terminate.
Defaults to <code>NULL</code>, in which case the sequential design stops after <code>N</code> steps. See the <em>Note</em> section below for further details about <code>target</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_method">method</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> an R function that determines the next design points to be evaluated by <code>f</code>. The function must adhere to the following rules:
</p>

<ul>
<li> <p><strong>First argument</strong>: an emulator object, which can be one of the following:
</p>

<ul>
<li><p> an instance of the <code>gp</code> class (produced by <code><a href="#topic+gp">gp()</a></code>);
</p>
</li>
<li><p> an instance of the <code>dgp</code> class (produced by <code><a href="#topic+dgp">dgp()</a></code>);
</p>
</li>
<li><p> an instance of the <code>bundle</code> class (produced by <code><a href="#topic+pack">pack()</a></code>).
</p>
</li></ul>

</li>
<li> <p><strong>Second argument</strong> (if <code>x_cand</code> is not <code>NULL</code>): a <em>candidate matrix</em> representing a set of potential design points from which the <code>method</code> function selects the next points.
</p>
</li>
<li> <p><strong>Function output</strong>:
</p>

<ul>
<li><p> If <code>x_cand</code> is not <code>NULL</code>:
</p>

<ul>
<li><p> for <code>gp</code> or <code>dgp</code> objects, the output must be a vector of row indices corresponding to the selected design points from the <em>candidate matrix</em> (the second argument).
</p>
</li>
<li><p> for <code>bundle</code> objects, the output must be a matrix containing the row indices of the selected design points from the <em>candidate matrix</em>. Each column corresponds to
the indices for an individual emulator in the bundle.
</p>
</li></ul>

</li>
<li><p> If <code>x_cand</code> is <code>NULL</code>:
</p>

<ul>
<li><p> for <code>gp</code> or <code>dgp</code> objects, the output must be a matrix where each row represents a new design point to be added.
</p>
</li>
<li><p> for <code>bundle</code> objects, the output must be a list with a length equal to the number of emulators in the bundle. Each element in the list is a matrix where rows
represent the new design points for the corresponding emulator.
</p>
</li></ul>

</li></ul>

</li></ul>

<p>See <code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> for examples of built-in <code>method</code> functions. Defaults to <code><a href="#topic+vigf">vigf()</a></code>.</p>
</td></tr>
<tr><td><code id="design_+3A_batch_size">batch_size</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer specifying the number of design points to select in a single iteration. Defaults to <code>1</code>.
This argument is used by the built-in <code>method</code> functions <code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code>.
If you provide a custom <code>method</code> function with an argument named <code>batch_size</code>, the value of <code>batch_size</code> will be passed to your function.</p>
</td></tr>
<tr><td><code id="design_+3A_eval">eval</code></td>
<td>
<p>an R function that computes a customized metric for evaluating emulator performance. The function must adhere to the following rules:
</p>

<ul>
<li> <p><strong>First argument</strong>: an emulator object, which can be one of the following:
</p>

<ul>
<li><p> an instance of the <code>gp</code> class (produced by <code><a href="#topic+gp">gp()</a></code>);
</p>
</li>
<li><p> an instance of the <code>dgp</code> class (produced by <code><a href="#topic+dgp">dgp()</a></code>);
</p>
</li>
<li><p> an instance of the <code>bundle</code> class (produced by <code><a href="#topic+pack">pack()</a></code>).
</p>
</li></ul>

</li>
<li> <p><strong>Function output</strong>:
</p>

<ul>
<li><p> for <code>gp</code> objects, the output must be a single metric value.
</p>
</li>
<li><p> for <code>dgp</code> objects, the output can be a single metric value or a vector of metric values with a length equal to the number of output dimensions.
</p>
</li>
<li><p> for <code>bundle</code> objects, the output can be a single metric value or a vector of metric values with a length equal to the number of emulators in the bundle.
</p>
</li></ul>

</li></ul>

<p>If no custom function is provided, a built-in evaluation metric (RMSE or log-loss, in the case of DGP emulators with categorical likelihoods) will be used.
Defaults to <code>NULL</code>. See the <em>Note</em> section below for additional details.</p>
</td></tr>
<tr><td><code id="design_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information will be printed during the sequential design.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_autosave">autosave</code></td>
<td>
<p>a list that contains configuration settings for the automatic saving of the emulator:
</p>

<ul>
<li> <p><code>switch</code>: a bool indicating whether to enable automatic saving of the emulator during sequential design. When set to <code>TRUE</code>,
the emulator in the final iteration is always saved. Defaults to <code>FALSE</code>.
</p>
</li>
<li> <p><code>directory</code>: a string specifying the directory path where the emulators will be stored. Emulators will be stored in a sub-directory
of <code>directory</code> named 'emulator-<code>id</code>'. Defaults to './check_points'.
</p>
</li>
<li> <p><code>fname</code>: a string representing the base name for the saved emulator files. Defaults to 'check_point'.
</p>
</li>
<li> <p><code>save_freq</code>: an integer indicating the frequency of automatic saves, measured in the number of iterations. Defaults to <code>5</code>.
</p>
</li>
<li> <p><code>overwrite</code>: a bool value controlling the file saving behavior. When set to <code>TRUE</code>, each new automatic save overwrites the previous one,
keeping only the latest version. If <code>FALSE</code>, each automatic save creates a new file, preserving all previous versions. Defaults to <code>FALSE</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="design_+3A_new_wave">new_wave</code></td>
<td>
<p>a bool indicating whether the current call to <code><a href="#topic+design">design()</a></code> will create a new wave of sequential designs or add the next sequence of designs to the most recent wave.
This argument is relevant only if waves already exist in the emulator. Creating new waves can improve the visualization of sequential design performance across different calls
to <code><a href="#topic+design">design()</a></code> via <code><a href="#topic+draw">draw()</a></code>, and allows for specifying a different evaluation frequency in <code>freq</code>. However, disabling this option can help limit the number of waves visualized
in <code><a href="#topic+draw">draw()</a></code> to avoid issues such as running out of distinct colors for large numbers of waves. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_m_val">M_val</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer that gives the size of the conditioning set for the Vecchia approximation in emulator validations. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_cores">cores</code></td>
<td>
<p>an integer that gives the number of processes to be used for emulator validation. If set to <code>NULL</code>, the number of processes is set to
<code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Defaults to <code>1</code>. This argument is only used if <code>eval = NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_...">...</code></td>
<td>
<p>Any arguments with names that differ from those used in <code><a href="#topic+design">design()</a></code> but are required by <code>f</code>, <code>method</code>, or <code>eval</code> can be passed here.
<code><a href="#topic+design">design()</a></code> will forward relevant arguments to <code>f</code>, <code>method</code>, and <code>eval</code> based on the names of the additional arguments provided.</p>
</td></tr>
<tr><td><code id="design_+3A_train_n">train_N</code></td>
<td>
<p>the number of training iterations to be used for re-fitting the DGP emulator at each step of the sequential design:
</p>

<ul>
<li><p> If <code>train_N</code> is an integer, the DGP emulator will be re-fitted at each step (based on the re-fit frequency specified in <code>freq[1]</code>) using <code>train_N</code> iterations.
</p>
</li>
<li><p> If <code>train_N</code> is a vector, its length must be <code>N</code>, even if the re-fit frequency specified in <code>freq[1]</code> is not 1.
</p>
</li>
<li><p> If <code>train_N</code> is <code>NULL</code>, the DGP emulator will be re-fitted at each step (based on the re-fit frequency specified in <code>freq[1]</code>) using:
</p>

<ul>
<li> <p><code>100</code> iterations if the DGP emulator was constructed without the Vecchia approximation, or
</p>
</li>
<li> <p><code>50</code> iterations if the Vecchia approximation was used.
</p>
</li></ul>

</li></ul>

<p>Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_refit_cores">refit_cores</code></td>
<td>
<p>the number of processes to be used to re-fit GP components (in the same layer of a DGP emulator)
at each M-step during the re-fitting. If set to <code>NULL</code>, the number of processes is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code>
if the DGP emulator was constructed without the Vecchia approximation. Otherwise, the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>.
Only use multiple processes when there is a large number of GP components in different layers and optimization of GP components
is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_pruning">pruning</code></td>
<td>
<p>a bool indicating if dynamic pruning of DGP structures will be implemented during the sequential design after the total number of
design points exceeds <code>min_size</code> in <code>control</code>. The argument is only applicable to DGP emulators (i.e., <code>object</code> is an instance of <code>dgp</code> class)
produced by <code>dgp()</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_+3A_control">control</code></td>
<td>
<p>a list that can supply any of the following components to control the dynamic pruning of the DGP emulator:
</p>

<ul>
<li> <p><code>min_size</code>, the minimum number of design points required to trigger dynamic pruning. Defaults to 10 times the number of input dimensions.
</p>
</li>
<li> <p><code>threshold</code>, the <code class="reqn">R^2</code> value above which a GP node is considered redundant. Defaults to <code>0.97</code>.
</p>
</li>
<li> <p><code>nexceed</code>, the minimum number of consecutive iterations that the <code class="reqn">R^2</code> value of a GP node must exceed <code>threshold</code> to trigger the removal of that node from
the DGP structure. Defaults to <code>3</code>.
</p>
</li></ul>

<p>The argument is only used when <code>pruning = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> is returned with a slot called <code>design</code> that contains:
</p>

<ul>
<li> <p><em>S</em> slots, named <code style="white-space: pre;">&#8288;wave1, wave2,..., waveS&#8288;</code>, that contain information of <em>S</em> waves of sequential design that have been applied to the emulator.
Each slot contains the following elements:
</p>

<ul>
<li> <p><code>N</code>, an integer that gives the numbers of iterations implemented in the corresponding wave;
</p>
</li>
<li> <p><code>rmse</code>, a matrix providing the evaluation metric values for emulators constructed during the corresponding wave, when <code>eval = NULL</code>.
Each row of the matrix represents an iteration.
</p>

<ul>
<li><p> for an <code>object</code> of class <code>gp</code>, the matrix contains a single column of RMSE values.
</p>
</li>
<li><p> for an <code>object</code> of class <code>dgp</code> without a categorical likelihood, each row contains mean/median squared errors corresponding to different output dimensions.
</p>
</li>
<li><p> for an <code>object</code> of class <code>dgp</code> with a categorical likelihood, the matrix contains a single column of log-loss values.
</p>
</li>
<li><p> for an <code>object</code> of class <code>bundle</code>, each row contains either mean/median squared errors or log-loss values for the emulators in the bundle.
</p>
</li></ul>

</li>
<li> <p><code>metric</code>: a matrix providing the values of custom evaluation metrics, as computed by the user-supplied <code>eval</code> function, for emulators constructed during the corresponding wave.
</p>
</li>
<li> <p><code>freq</code>, an integer that gives the frequency that the emulator validations are implemented during the corresponding wave.
</p>
</li>
<li> <p><code>enrichment</code>, a vector of size <code>N</code> that gives the number of new design points added after each step of the sequential design (if <code>object</code> is
an instance of the <code>gp</code> or <code>dgp</code> class), or a matrix that gives the number of new design points added to emulators in a bundle after each step of
the sequential design (if <code>object</code> is an instance of the <code>bundle</code> class).
</p>
</li></ul>

<p>If <code>target</code> is not <code>NULL</code>, the following additional elements are also included:
</p>

<ul>
<li> <p><code>target</code>: the target evaluating metric computed by the <code>eval</code> or built-in function to stop the sequential design.
</p>
</li>
<li> <p><code>reached</code>: indicates whether the <code>target</code> was reached at the end of the sequential design:
</p>

<ul>
<li><p> a bool if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class.
</p>
</li>
<li><p> a vector of bools if <code>object</code> is an instance of the <code>bundle</code> class, with its length determined as follows:
</p>

<ul>
<li><p> equal to the number of emulators in the bundle when <code>eval = NULL</code>.
</p>
</li>
<li><p> equal to the length of the output from <code>eval</code> when a custom <code>eval</code> function is provided.
</p>
</li></ul>

</li></ul>

</li></ul>

</li>
<li><p> a slot called <code>type</code> that gives the type of validation:
</p>

<ul>
<li><p> either LOO ('loo') or OOS ('oos') if <code>eval = NULL</code>. See <code><a href="#topic+validate">validate()</a></code> for more information about LOO and OOS.
</p>
</li>
<li><p> 'customized' if a customized R function is provided to <code>eval</code>.
</p>
</li></ul>

</li>
<li><p> two slots called <code>x_test</code> and <code>y_test</code> that contain the data points for the OOS validation if the <code>type</code> slot is 'oos'.
</p>
</li>
<li><p> If <code>y_cand = NULL</code> and <code>x_cand</code> is supplied, and there are <code>NA</code>s returned from the supplied <code>f</code> during the sequential design, a slot called <code>exclusion</code> is included
that records the located design positions that produced <code>NA</code>s via <code>f</code>. The sequential design will use this information to
avoid re-visiting the same locations in later runs of <code>design()</code>.
</p>
</li></ul>

<p>See <em>Note</em> section below for further information.
</p>


<h3>Note</h3>


<ul>
<li><p> Validation of an emulator is forced after the final step of a sequential design even if <code>N</code> is not a multiple of the second element in <code>freq</code>.
</p>
</li>
<li><p> Any <code>loo</code> or <code>oos</code> slot that already exists in <code>object</code> will be cleaned, and a new slot called <code>loo</code> or <code>oos</code> will be created in the returned object
depending on whether <code>x_test</code> and <code>y_test</code> are provided. The new slot gives the validation information of the emulator constructed in the final step of
the sequential design. See <code><a href="#topic+validate">validate()</a></code> for more information about the slots <code>loo</code> and <code>oos</code>.
</p>
</li>
<li><p> If <code>object</code> has previously been used by <code><a href="#topic+design">design()</a></code> for sequential design, the information of the current wave of the sequential design will replace
those of old waves and be contained in the returned object, unless
</p>

<ul>
<li><p> the validation type (LOO or OOS depending on whether <code>x_test</code> and <code>y_test</code> are supplied or not) of the current wave of the sequential design is the
same as the validation types (shown in the <code>type</code> of the <code>design</code> slot of <code>object</code>) in previous waves, and if the validation type is OOS,
<code>x_test</code> and <code>y_test</code> in the current wave must also be identical to those in the previous waves;
</p>
</li>
<li><p> both the current and previous waves of the sequential design supply customized evaluation functions to <code>eval</code>. Users need to ensure the customized evaluation
functions are consistent among different waves. Otherwise, the trace plot of RMSEs produced by <code><a href="#topic+draw">draw()</a></code> will show values of different evaluation metrics in
different waves.
</p>
</li></ul>

<p>For the above two cases, the information of the current wave of the sequential design will be added to the <code>design</code> slot of the returned object under the name <code>waveS</code>.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class and <code>eval = NULL</code>, the matrix in the <code>rmse</code> slot is single-columned. If <code>object</code> is an instance of
the <code>dgp</code> or <code>bundle</code> class and <code>eval = NULL</code>, the matrix in the <code>rmse</code> slot can have multiple columns that correspond to different output dimensions
or different emulators in the bundle.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class and <code>eval = NULL</code>, <code>target</code> needs to be a single value giving the RMSE threshold. If <code>object</code> is an instance
of the <code>dgp</code> or <code>bundle</code> class and <code>eval = NULL</code>, <code>target</code> can be a vector of values that gives the thresholds of evaluating metrics for different output dimensions or
different emulators. If a single value is provided, it will be used as the threshold for all output dimensions (if <code>object</code> is an instance of the <code>dgp</code>) or all emulators
(if <code>object</code> is an instance of the <code>bundle</code>). If a customized function is supplied to <code>eval</code> and <code>target</code> is given as a vector, the user needs to ensure that the length
of <code>target</code> is equal to that of the output from <code>eval</code>.
</p>
</li>
<li><p> When defining <code>f</code>, it is important to ensure that:
</p>

<ul>
<li><p> the column order of the first argument of <code>f</code> is consistent with the training input used for the emulator;
</p>
</li>
<li><p> the column order of the output matrix of <code>f</code> is consistent with the order of emulator output dimensions (if <code>object</code> is an instance of the <code>dgp</code> class),
or the order of emulators placed in <code>object</code> (if <code>object</code> is an instance of the <code>bundle</code> class).
</p>
</li></ul>

</li>
<li><p> The output matrix produced by <code>f</code> may include <code>NA</code>s. This is especially beneficial as it allows the sequential design process to continue without interruption,
even if errors or <code>NA</code> outputs are encountered from <code>f</code> at certain input locations identified by the sequential design. Users should ensure that any errors
within <code>f</code> are handled by appropriately returning <code>NA</code>s.
</p>
</li>
<li><p> When defining <code>eval</code>, the output metric needs to be positive if <code><a href="#topic+draw">draw()</a></code> is used with <code>log = T</code>. And one needs to ensure that a lower metric value indicates
a better emulation performance if <code>target</code> is set.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 2D non-stationary function that takes a matrix as the input
f &lt;- function(x) {
  sin(1/((0.7*x[,1,drop=F]+0.3)*(0.7*x[,2,drop=F]+0.3)))
}

# generate the initial design
X &lt;- maximinLHS(5,2)
Y &lt;- f(X)

# generate the validation data
validate_x &lt;- maximinLHS(30,2)
validate_y &lt;- f(validate_x)

# training a 2-layered DGP emulator with the initial design
m &lt;- dgp(X, Y)

# specify the ranges of the input dimensions
lim_1 &lt;- c(0, 1)
lim_2 &lt;- c(0, 1)
lim &lt;- rbind(lim_1, lim_2)

# 1st wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 2nd wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# 3rd wave of the sequential design with 10 steps
m &lt;- design(m, N=10, limits = lim, f = f, x_test = validate_x, y_test = validate_y)

# draw the design created by the sequential design
draw(m,'design')

# inspect the trace of RMSEs during the sequential design
draw(m,'rmse')

# reduce the number of imputations for faster OOS
m_faster &lt;- set_imp(m, 5)

# plot the OOS validation with the faster DGP emulator
plot(m_faster, x_test = validate_x, y_test = validate_y)

## End(Not run)
</code></pre>

<hr>
<h2 id='dgp'>Deep Gaussian process emulator construction</h2><span id='topic+dgp'></span>

<h3>Description</h3>

<p>This function builds and trains a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp(
  X,
  Y,
  depth = 2,
  node = ncol(X),
  name = "sexp",
  lengthscale = 1,
  bounds = NULL,
  prior = "ga",
  share = TRUE,
  nugget_est = FALSE,
  nugget = NULL,
  scale_est = TRUE,
  scale = 1,
  connect = TRUE,
  likelihood = NULL,
  training = TRUE,
  verb = TRUE,
  check_rep = TRUE,
  vecchia = FALSE,
  M = 25,
  ord = NULL,
  N = ifelse(vecchia, 200, 500),
  cores = 1,
  blocked_gibbs = TRUE,
  ess_burn = 10,
  burnin = NULL,
  B = 10,
  internal_input_idx = NULL,
  linked_idx = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgp_+3A_x">X</code></td>
<td>
<p>a matrix where each row is an input training data point and each column represents an input dimension.</p>
</td></tr>
<tr><td><code id="dgp_+3A_y">Y</code></td>
<td>
<p>a matrix containing observed training output data. The matrix has its rows being output data points and columns representing
output dimensions. When <code>likelihood</code> (see below) is not <code>NULL</code>, <code>Y</code> must be a matrix with a single column.</p>
</td></tr>
<tr><td><code id="dgp_+3A_depth">depth</code></td>
<td>
<p>number of layers (including the likelihood layer) for a DGP structure. <code>depth</code> must be at least <code>2</code>.
Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_node">node</code></td>
<td>
<p>number of GP nodes in each layer (except for the final layer or the layer feeding the likelihood node) of the DGP. Defaults to
<code>ncol(X)</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_name">name</code></td>
<td>
<p>a character or a vector of characters that indicates the kernel functions (either <code>"sexp"</code> for squared exponential kernel or
<code>"matern2.5"</code> for Matérn-2.5 kernel) used in the DGP emulator:
</p>

<ol>
<li><p> if a single character is supplied, the corresponding kernel function will be used for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if a vector of characters is supplied, each character of the vector specifies the kernel function that will be applied to all GP nodes in the corresponding layer.
</p>
</li></ol>

<p>Defaults to <code>"sexp"</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_lengthscale">lengthscale</code></td>
<td>
<p>initial lengthscales for GP nodes in the DGP emulator. It can be a single numeric value or a vector:
</p>

<ol>
<li><p> if it is a single numeric value, the value will be applied as the initial lengthscales for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a vector, each element of the vector specifies the initial lengthscales that will be applied to all GP nodes in the corresponding layer.
The vector should have a length of <code>depth</code> if <code>likelihood = NULL</code> or a length of <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Defaults to a numeric value of <code>1.0</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_bounds">bounds</code></td>
<td>
<p>the lower and upper bounds of lengthscales in GP nodes. It can be a vector or a matrix:
</p>

<ol>
<li><p> if it is a vector, the lower bound (the first element of the vector) and upper bound (the second element of the vector) will be applied to
lengthscales for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a matrix, each row of the matrix specifies the lower and upper bounds of lengthscales for all GP nodes in the corresponding layer.
The matrix should have its row number equal to <code>depth</code> if <code>likelihood = NULL</code> or to <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Defaults to <code>NULL</code> where no bounds are specified for the lengthscales.</p>
</td></tr>
<tr><td><code id="dgp_+3A_prior">prior</code></td>
<td>
<p>prior to be used for MAP estimation of lengthscales and nuggets of all GP nodes in the DGP hierarchy:
</p>

<ul>
<li><p> gamma prior (<code>"ga"</code>),
</p>
</li>
<li><p> inverse gamma prior (<code>"inv_ga"</code>), or
</p>
</li>
<li><p> jointly robust prior (<code>"ref"</code>).
</p>
</li></ul>

<p>Defaults to <code>"ga"</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_share">share</code></td>
<td>
<p>a bool indicating if all input dimensions of a GP node share a common lengthscale. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_nugget_est">nugget_est</code></td>
<td>
<p>a bool or a bool vector that indicates if the nuggets of GP nodes (if any) in the final layer are to be estimated. If a single bool is
provided, it will be applied to all GP nodes (if any) in the final layer. If a bool vector (which must have a length of <code>ncol(Y)</code>) is provided, each
bool element in the vector will be applied to the corresponding GP node (if any) in the final layer. The value of a bool has following effects:
</p>

<ul>
<li> <p><code>FALSE</code>: the nugget of the corresponding GP in the final layer is fixed to the corresponding value defined in <code>nugget</code> (see below).
</p>
</li>
<li> <p><code>TRUE</code>: the nugget of the corresponding GP in the final layer will be estimated with the initial value given by the correspondence in <code>nugget</code> (see below).
</p>
</li></ul>

<p>Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_nugget">nugget</code></td>
<td>
<p>the initial nugget value(s) of GP nodes (if any) in each layer:
</p>

<ol>
<li><p> if it is a single numeric value, the value will be applied as the initial nugget for all GP nodes in the DGP hierarchy.
</p>
</li>
<li><p> if it is a vector, each element of the vector specifies the initial nugget that will be applied to all GP nodes in the corresponding layer.
The vector should have a length of <code>depth</code> if <code>likelihood = NULL</code> or a length of <code>depth - 1</code> if <code>likelihood</code> is not <code>NULL</code>.
</p>
</li></ol>

<p>Set <code>nugget</code> to a small value and the bools in <code>nugget_est</code> to <code>FALSE</code> for deterministic emulation, where the emulator
interpolates the training data points. Set <code>nugget</code> to a larger value and the bools in <code>nugget_est</code> to <code>TRUE</code> for stochastic emulation where
the computer model outputs are assumed to follow a homogeneous Gaussian distribution. Defaults to <code>1e-6</code> if <code>nugget_est = FALSE</code> and
<code>0.01</code> if <code>nugget_est = TRUE</code>. If <code>likelihood</code> is not <code>NULL</code> and <code>nugget_est = FALSE</code>, the nuggets of GPs that feed into the likelihood layer default to
<code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_scale_est">scale_est</code></td>
<td>
<p>a bool or a bool vector that indicates if the variance of GP nodes (if any) in the final layer are to be estimated. If a single bool is
provided, it will be applied to all GP nodes (if any) in the final layer. If a bool vector (which must have a length of <code>ncol(Y)</code>) is provided, each
bool element in the vector will be applied to the corresponding GP node (if any) in the final layer. The value of a bool has following effects:
</p>

<ul>
<li> <p><code>FALSE</code>: the variance of the corresponding GP in the final layer is fixed to the corresponding value defined in <code>scale</code> (see below).
</p>
</li>
<li> <p><code>TRUE</code>: the variance of the corresponding GP in the final layer will be estimated with the initial value given by the correspondence in <code>scale</code> (see below).
</p>
</li></ul>

<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_scale">scale</code></td>
<td>
<p>the initial variance value(s) of GP nodes (if any) in the final layer. If it is a single numeric value, it will be applied to all GP nodes (if any)
in the final layer. If it is a vector (which must have a length of <code>ncol(Y)</code>), each numeric in the vector will be applied to the corresponding GP node
(if any) in the final layer. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_connect">connect</code></td>
<td>
<p>a bool indicating whether to implement global input connection to the DGP structure. Setting it to <code>FALSE</code> may produce a better emulator in some cases at
the cost of slower training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_likelihood">likelihood</code></td>
<td>
<p>the likelihood type of a DGP emulator:
</p>

<ol>
<li> <p><code>NULL</code>: no likelihood layer is included in the emulator.
</p>
</li>
<li> <p><code>"Hetero"</code>: a heteroskedastic Gaussian likelihood layer is added for stochastic emulation where the computer model outputs are assumed to follow a heteroskedastic Gaussian distribution
(i.e., the computer model outputs have input-dependent noise).
</p>
</li>
<li> <p><code>"Poisson"</code>: a Poisson likelihood layer is added for emulation where the computer model outputs are counts and a Poisson distribution is used to model them.
</p>
</li>
<li> <p><code>"NegBin"</code>: a negative Binomial likelihood layer is added for emulation where the computer model outputs are counts and a negative Binomial distribution is used to capture dispersion variability in input space.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> <code>"Categorical"</code>: a categorical likelihood layer is added for emulation (classification), where the computer model output is categorical.
</p>
</li></ol>

<p>When <code>likelihood</code> is not <code>NULL</code>, the value of <code>nugget_est</code> is overridden by <code>FALSE</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_training">training</code></td>
<td>
<p>a bool indicating if the initialized DGP emulator will be trained.
When set to <code>FALSE</code>, <code><a href="#topic+dgp">dgp()</a></code> returns an untrained DGP emulator, to which one can apply <code><a href="#topic+summary">summary()</a></code> to inspect its specifications
or apply <code><a href="#topic+predict">predict()</a></code> to check its emulation performance before training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on DGP emulator construction and training will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_check_rep">check_rep</code></td>
<td>
<p>a bool indicating whether to check for repetitions in the dataset, i.e., if one input
position has multiple outputs. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_vecchia">vecchia</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool indicating whether to use Vecchia approximation for large-scale DGP emulator construction and prediction. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the DGP emulator training. Defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_ord">ord</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an R function that returns the ordering of the input to each GP node contained in the DGP emulator for the Vecchia approximation. The
function must satisfy the following basic rules:
</p>

<ul>
<li><p> the first argument represents the input to a GP node scaled by its lengthscales.
</p>
</li>
<li><p> the output of the function is a vector of indices that gives the ordering of the input to the GP node.
</p>
</li></ul>

<p>If <code>ord = NULL</code>, the default random ordering is used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_n">N</code></td>
<td>
<p>number of iterations for the training. Defaults to <code>500</code> if <code>vecchia = FALSE</code> and <code>200</code> if <code>vecchia = TRUE</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_cores">cores</code></td>
<td>
<p>the number of processes to be used to optimize GP components (in the same layer) at each M-step of the training. If set to <code>NULL</code>,
the number of processes is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code> if <code>vecchia = FALSE</code> and <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code> if <code>vecchia = TRUE</code>.
Only use multiple processes when there is a large number of GP components in different layers and optimization of GP components is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_blocked_gibbs">blocked_gibbs</code></td>
<td>
<p>a bool indicating if the latent variables are imputed layer-wise using ESS-within-Blocked-Gibbs. ESS-within-Blocked-Gibbs would be faster and
more efficient than ESS-within-Gibbs that imputes latent variables node-wise because it reduces the number of components to be sampled during Gibbs steps,
especially when there is a large number of GP nodes in layers due to higher input dimensions. Default to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for the ESS-within-Gibbs
at each I-step of the training. Defaults to <code>10</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_burnin">burnin</code></td>
<td>
<p>the number of training iterations to be discarded for
point estimates of model parameters. Must be smaller than the training iterations <code>N</code>. If this is not specified, only the last 25% of iterations
are used. Defaults to <code>NULL</code>. This argument is only used when <code>training = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_b">B</code></td>
<td>
<p>the number of imputations used to produce predictions. Increase the value to refine the representation of imputation uncertainty.
Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_internal_input_idx">internal_input_idx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The argument will be removed in the next release. To set up connections of emulators for linked emulations,
please use the updated <code><a href="#topic+lgp">lgp()</a></code> function instead.
</p>
<p>Column indices of <code>X</code> that are generated by the linked emulators in the preceding layers.
Set <code>internal_input_idx = NULL</code> if the DGP emulator is in the first layer of a system or all columns in <code>X</code> are
generated by the linked emulators in the preceding layers. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_linked_idx">linked_idx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The argument will be removed in the next release. To set up connections of emulators for linked emulation,
please use the updated <code><a href="#topic+lgp">lgp()</a></code> function instead.
</p>
<p>Either a vector or a list of vectors:
</p>

<ul>
<li><p> If <code>linked_idx</code> is a vector, it gives indices of columns in the pooled output matrix (formed by column-combined outputs of all
emulators in the feeding layer) that feed into the DGP emulator. The length of the vector shall equal to the length of <code>internal_input_idx</code>
when <code>internal_input_idx</code> is not <code>NULL</code>. If the DGP emulator is in the first layer of a linked emulator system, the vector gives the column indices of the global
input (formed by column-combining all input matrices of emulators in the first layer) that the DGP emulator will use. If the DGP emulator is to be used in both the first
and subsequent layers, one should initially set <code>linked_idx</code> to the appropriate values for the situation where the emulator is not in the first layer. Then, use the
function <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to reset the linking information when the emulator is in the first layer.
</p>
</li>
<li><p> When the DGP emulator is not in the first layer of a linked emulator system, <code>linked_idx</code> can be a list that gives the information on connections
between the DGP emulator and emulators in all preceding layers. The length of the list should equal to the number of layers before
the DGP emulator. Each element of the list is a vector that gives indices of columns in the pooled output matrix (formed by column-combined outputs
of all emulators) in the corresponding layer that feed into the DGP emulator. If the DGP emulator has no connections to any emulator in a certain layer,
set <code>NULL</code> in the corresponding position of the list. The order of input dimensions in <code>X[,internal_input_idx]</code> should be consistent with <code>linked_idx</code>.
For example, a DGP emulator in the 4th-layer that is fed by the output dimension 2 and 4 of emulators in layer 2 and all output dimension 1 to 3 of
emulators in layer 3 should have <code>linked_idx = list( NULL, c(2,4), c(1,2,3) )</code>. In addition, the first and second columns of <code>X[,internal_input_idx]</code>
should correspond to the output dimensions 2 and 4 from layer 2, and the third to fifth columns of <code>X[,internal_input_idx]</code> should
correspond to the output dimensions 1 to 3 from layer 3.
</p>
</li></ul>

<p>Set <code>linked_idx = NULL</code> if the DGP emulator will not be used for linked emulations. However, if this is no longer the case, one can use <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code>
to add linking information to the DGP emulator. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dgp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the DGP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>dgp</code> that contains five slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>data</code>: a list that contains two elements: <code>X</code> and <code>Y</code> which are the training input and output data respectively.
</p>
</li>
<li> <p><code>specs</code>: a list that contains
</p>

<ol>
<li> <p><em>L</em> (i.e., the number of layers in the DGP hierarchy) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list contains <em>D</em>
(i.e., the number of GP/likelihood nodes in the corresponding layer) sub-lists named <code style="white-space: pre;">&#8288;node1, node2,..., nodeD&#8288;</code>. If a sub-list
corresponds to a likelihood node, it contains one element called <code>type</code> that gives the name (<code>Hetero</code>, <code>Poisson</code>, <code>NegBin</code>, or <code>Categorical</code>) of the likelihood node.
If a sub-list corresponds to a GP node, it contains four elements:
</p>

<ul>
<li> <p><code>kernel</code>: the type of the kernel function used for the GP node.
</p>
</li>
<li> <p><code>lengthscales</code>: a vector of lengthscales in the kernel function.
</p>
</li>
<li> <p><code>scale</code>: the variance value in the kernel function.
</p>
</li>
<li> <p><code>nugget</code>: the nugget value in the kernel function.
</p>
</li></ul>

</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>internal_dims</code>: the column indices of <code>X</code> that correspond to the linked emulators in the preceding layers of a linked system.
<strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>external_dims</code>: the column indices of <code>X</code> that correspond to global inputs to the linked system of emulators. It is shown
as <code>FALSE</code> if <code>internal_input_idx = NULL</code>. <strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>linked_idx</code>: the value passed to argument <code>linked_idx</code>. It is shown as <code>FALSE</code> if the argument <code>linked_idx</code> is <code>NULL</code>.
<strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><code>seed</code>: the random seed generated to produce imputations. This information is stored for reproducibility when the DGP emulator (that was saved by <code><a href="#topic+write">write()</a></code>
with the light option <code>light = TRUE</code>) is loaded back to R by <code><a href="#topic+read">read()</a></code>.
</p>
</li>
<li> <p><code>B</code>: the number of imputations used to generate the emulator.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> <code>vecchia</code>: whether the Vecchia approximation is used for the GP emulator training.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> <code>M</code>: the size of the conditioning set for the Vecchia approximation in the DGP emulator training. <code>M</code> is generated only when <code>vecchia = TRUE</code>.
</p>
</li></ol>

</li>
<li> <p><code>constructor_obj</code>: a 'python' object that stores the information of the constructed DGP emulator.
</p>
</li>
<li> <p><code>container_obj</code>: a 'python' object that stores the information for the linked emulation.
</p>
</li>
<li> <p><code>emulator_obj</code>: a 'python' object that stores the information for the predictions from the DGP emulator.
</p>
</li></ul>

<p>The returned <code>dgp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for DGP predictions.
</p>
</li>
<li> <p><code><a href="#topic+continue">continue()</a></code> for additional DGP training iterations.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for LOO and OOS validations.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for validation plots.
</p>
</li>
<li> <p><code><a href="#topic+lgp">lgp()</a></code> for linked (D)GP emulator constructions.
</p>
</li>
<li> <p><code><a href="#topic+window">window()</a></code> for model parameter trimming.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the trained DGP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the DGP emulator to a <code>.pkl</code> file.
</p>
</li>
<li> <p><code><a href="#topic+set_imp">set_imp()</a></code> to change the number of imputations.
</p>
</li>
<li> <p><code><a href="#topic+design">design()</a></code> for sequential design.
</p>
</li>
<li> <p><code><a href="#topic+update">update()</a></code> to update the DGP emulator with new inputs and outputs.
</p>
</li>
<li> <p><code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> to locate next design points.
</p>
</li></ul>



<h3>Note</h3>

<p>Any R vector detected in <code>X</code> and <code>Y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>X</code> is a single data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# construct a step function
f &lt;- function(x) {
  if (x &lt; 0.5) return(-1)
  if (x &gt;= 0.5) return(1)
  }

# generate training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# set a random seed
set_seed(999)

# training a DGP emulator
m &lt;- dgp(X, Y)

# continue for further training iterations
m &lt;- continue(m)

# summarizing
summary(m)

# trace plot
trace_plot(m)

# trim the traces of model parameters
m &lt;- window(m, 800)

# LOO cross validation
m &lt;- validate(m)
plot(m)

# prediction
test_x &lt;- seq(0, 1, length = 200)
m &lt;- predict(m, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 10)
validate_y &lt;- sapply(validate_x, f)
plot(m, validate_x, validate_y)

# write and read the constructed emulator
write(m, 'step_dgp')
m &lt;- read('step_dgp')

## End(Not run)
</code></pre>

<hr>
<h2 id='draw'>Validation and diagnostic plots for a sequential design</h2><span id='topic+draw'></span><span id='topic+draw.gp'></span><span id='topic+draw.dgp'></span><span id='topic+draw.bundle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function draws diagnostic and validation plots for a sequential design of a (D)GP emulator or a bundle of (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(object, ...)

## S3 method for class 'gp'
draw(object, type = "rmse", log = FALSE, ...)

## S3 method for class 'dgp'
draw(object, type = "rmse", log = FALSE, ...)

## S3 method for class 'bundle'
draw(object, type = "rmse", log = FALSE, emulator = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_+3A_object">object</code></td>
<td>
<p>can be one of the following emulator classes:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
<tr><td><code id="draw_+3A_type">type</code></td>
<td>
<p>specifies the type of plot or visualization to generate:
</p>

<ul>
<li> <p><code>"rmse"</code>: generates a trace plot of RMSEs, log-losses for DGP emulators with categorical likelihoods, or custom evaluation metrics specified via the <code>"eval"</code> argument in the <code style="white-space: pre;">&#8288;[design()]&#8288;</code> function.
</p>
</li>
<li> <p><code>"design"</code>: shows visualizations of input designs created by the sequential design procedure.
</p>
</li></ul>

<p>Defaults to <code>"rmse"</code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_log">log</code></td>
<td>
<p>a bool indicating whether to plot RMSEs, log-losses (for DGP emulators with categorical likelihoods), or custom evaluation metrics on a log scale when <code>type = "rmse"</code>.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="draw_+3A_emulator">emulator</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> an index or vector of indices of emulators packed in <code>object</code>. This argument is only used if <code>object</code> is an instance of the <code>bundle</code> class. When set to <code>NULL</code>, all
emulators in the bundle are drawn. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See design() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='get_thread_num'>Get the number of threads</h2><span id='topic+get_thread_num'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function gets the number of threads used for parallel computations involved
in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_thread_num()
</code></pre>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>the number of threads.
</p>

<hr>
<h2 id='gp'>Gaussian process emulator construction</h2><span id='topic+gp'></span>

<h3>Description</h3>

<p>This function builds and trains a GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp(
  X,
  Y,
  name = "sexp",
  lengthscale = rep(0.1, ncol(X)),
  bounds = NULL,
  prior = "ref",
  nugget_est = FALSE,
  nugget = ifelse(nugget_est, 0.01, 1e-08),
  scale_est = TRUE,
  scale = 1,
  training = TRUE,
  verb = TRUE,
  vecchia = FALSE,
  M = 25,
  ord = NULL,
  internal_input_idx = NULL,
  linked_idx = NULL,
  id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gp_+3A_x">X</code></td>
<td>
<p>a matrix where each row is an input data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="gp_+3A_y">Y</code></td>
<td>
<p>a matrix with only one column and each row being an output data point.</p>
</td></tr>
<tr><td><code id="gp_+3A_name">name</code></td>
<td>
<p>kernel function to be used. Either <code>"sexp"</code> for squared exponential kernel or
<code>"matern2.5"</code> for Matérn-2.5 kernel. Defaults to <code>"sexp"</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_lengthscale">lengthscale</code></td>
<td>
<p>initial values of lengthscales in the kernel function. It can be a single numeric value or a vector of length <code>ncol(X)</code>:
</p>

<ul>
<li><p> if it is a single numeric value, it is assumed that kernel functions across input dimensions share the same lengthscale;
</p>
</li>
<li><p> if it is a vector, it is assumed that kernel functions across input dimensions have different lengthscales.
</p>
</li></ul>

<p>Defaults to a vector of <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_bounds">bounds</code></td>
<td>
<p>the lower and upper bounds of lengthscales in the kernel function. It is a vector of length two where the first element is
the lower bound and the second element is the upper bound. The bounds will be applied to all lengthscales in the kernel function. Defaults
to <code>NULL</code> where no bounds are specified for the lengthscales.</p>
</td></tr>
<tr><td><code id="gp_+3A_prior">prior</code></td>
<td>
<p>prior to be used for Maximum a Posterior for lengthscales and nugget of the GP: gamma prior (<code>"ga"</code>), inverse gamma prior (<code>"inv_ga"</code>),
or jointly robust prior (<code>"ref"</code>). Defaults to <code>"ref"</code>. See the reference below for the jointly
robust prior.</p>
</td></tr>
<tr><td><code id="gp_+3A_nugget_est">nugget_est</code></td>
<td>
<p>a bool indicating if the nugget term is to be estimated:
</p>

<ol>
<li> <p><code>FALSE</code>: the nugget term is fixed to <code>nugget</code>.
</p>
</li>
<li> <p><code>TRUE</code>: the nugget term will be estimated.
</p>
</li></ol>

<p>Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_nugget">nugget</code></td>
<td>
<p>the initial nugget value. If <code>nugget_est = FALSE</code>, the assigned value is fixed during the training.
Set <code>nugget</code> to a small value (e.g., <code>1e-8</code>) and the corresponding bool in <code>nugget_est</code> to <code>FALSE</code> for deterministic computer models where the emulator
should interpolate the training data points. Set <code>nugget</code> to a larger value and the corresponding bool in <code>nugget_est</code> to <code>TRUE</code> for stochastic
emulation where the computer model outputs are assumed to follow a homogeneous Gaussian distribution. Defaults to <code>1e-8</code> if <code>nugget_est = FALSE</code> and
<code>0.01</code> if <code>nugget_est = TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_scale_est">scale_est</code></td>
<td>
<p>a bool indicating if the variance is to be estimated:
</p>

<ol>
<li> <p><code>FALSE</code>: the variance is fixed to <code>scale</code>.
</p>
</li>
<li> <p><code>TRUE</code>: the variance term will be estimated.
</p>
</li></ol>

<p>Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_scale">scale</code></td>
<td>
<p>the initial variance value. If <code>scale_est = FALSE</code>, the assigned value is fixed during the training.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_training">training</code></td>
<td>
<p>a bool indicating if the initialized GP emulator will be trained.
When set to <code>FALSE</code>, <code><a href="#topic+gp">gp()</a></code> returns an untrained GP emulator, to which one can apply <code><a href="#topic+summary">summary()</a></code> to inspect its specification or apply <code><a href="#topic+predict">predict()</a></code> to check its emulation performance before the training. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if the trace information on GP emulator construction and training will be printed during function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_vecchia">vecchia</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool indicating whether to use Vecchia approximation for large-scale GP emulator construction and prediction. Defaults to <code>FALSE</code>.
The Vecchia approximation implemented for the GP emulation largely follows Katzfuss et al. (2022). See reference below.</p>
</td></tr>
<tr><td><code id="gp_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the GP emulator training. Defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_ord">ord</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an R function that returns the ordering of the input to the GP emulator for the Vecchia approximation. The function must satisfy the following basic rules:
</p>

<ul>
<li><p> the first argument represents the input scaled by the lengthscales.
</p>
</li>
<li><p> the output of the function is a vector of indices that gives the ordering of the input to the GP emulator.
</p>
</li></ul>

<p>If <code>ord = NULL</code>, the default random ordering is used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_internal_input_idx">internal_input_idx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> The column indices of <code>X</code> that are generated by the linked emulators in the preceding layers.
Set <code>internal_input_idx = NULL</code> if the GP emulator is in the first layer of a system or all columns in <code>X</code> are
generated by the linked emulators in the preceding layers. Defaults to <code>NULL</code>.
</p>
<p><strong>The argument will be removed in the next release. To set up connections of emulators for linked emulations, please use the updated <code><a href="#topic+lgp">lgp()</a></code> function instead.</strong></p>
</td></tr>
<tr><td><code id="gp_+3A_linked_idx">linked_idx</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Either a vector or a list of vectors:
</p>

<ul>
<li><p> If <code>linked_idx</code> is a vector, it gives indices of columns in the pooled output matrix (formed by column-combined outputs of all
emulators in the feeding layer) that feed into the GP emulator. The length of the vector shall equal to the length of <code>internal_input_idx</code> when <code>internal_input_idx</code>
is not <code>NULL</code>. If the GP emulator is in the first layer of a linked emulator system, the vector gives the column indices of the global
input (formed by column-combining all input matrices of emulators in the first layer) that the GP emulator will use. If the GP emulator is to be used in both the first
and subsequent layers, one should initially set <code>linked_idx</code> to the appropriate values for the situation where the emulator is not in the first layer. Then, use the
function <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code> to reset the linking information when the emulator is in the first layer.
</p>
</li>
<li><p> When the GP emulator is not in the first layer of a linked emulator system, <code>linked_idx</code> can be a list that gives the information on connections
between the GP emulator and emulators in all preceding layers. The length of the list should equal to the number of layers before
the GP emulator. Each element of the list is a vector that gives indices of columns in the pooled output matrix (formed by column-combined outputs
of all emulators) in the corresponding layer that feed into the GP emulator. If the GP emulator has no connections to any emulator in a certain layer,
set <code>NULL</code> in the corresponding position of the list. The order of input dimensions in <code>X[,internal_input_idx]</code> should be consistent with <code>linked_idx</code>.
For example, a GP emulator in the second layer that is fed by the output dimension 1 and 3 of emulators in layer 1 should have <code>linked_idx = list( c(1,3) )</code>.
In addition, the first and second columns of <code>X[,internal_input_idx]</code> should correspond to the output dimensions 1 and 3 from layer 1.
</p>
</li></ul>

<p>Set <code>linked_idx = NULL</code> if the GP emulator will not be used for linked emulations. However, if this is no longer the case, one can use <code><a href="#topic+set_linked_idx">set_linked_idx()</a></code>
to add linking information to the GP emulator. Defaults to <code>NULL</code>.
</p>
<p><strong>The argument will be removed in the next release. To set up connections of emulators for linked emulations, please use the updated <code><a href="#topic+lgp">lgp()</a></code> function instead.</strong></p>
</td></tr>
<tr><td><code id="gp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the GP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>gp</code> that contains five slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>data</code>: a list that contains two elements: <code>X</code> and <code>Y</code> which are the training input and output data respectively.
</p>
</li>
<li> <p><code>specs</code>: a list that contains seven elements:
</p>

<ol>
<li> <p><code>kernel</code>: the type of the kernel function used. Either <code>"sexp"</code> for squared exponential kernel or <code>"matern2.5"</code> for Matérn-2.5 kernel.
</p>
</li>
<li> <p><code>lengthscales</code>: a vector of lengthscales in the kernel function.
</p>
</li>
<li> <p><code>scale</code>: the variance value in the kernel function.
</p>
</li>
<li> <p><code>nugget</code>: the nugget value in the kernel function.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>internal_dims</code>: the column indices of <code>X</code> that correspond to the linked emulators in the preceding layers of a linked system.
<strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>external_dims</code>: the column indices of <code>X</code> that correspond to global inputs to the linked system of emulators.
It is shown as <code>FALSE</code> if <code>internal_input_idx = NULL</code>. <strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> <code>linked_idx</code>: the value passed to argument <code>linked_idx</code>. It is shown as <code>FALSE</code> if the argument <code>linked_idx</code> is <code>NULL</code>.
<strong>The slot will be removed in the next release</strong>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> <code>vecchia</code>: whether the Vecchia approximation is used for the GP emulator training.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> <code>M</code>: the size of the conditioning set for the Vecchia approximation in the GP emulator training.
</p>
</li></ol>

</li>
<li> <p><code>constructor_obj</code>: a 'python' object that stores the information of the constructed GP emulator.
</p>
</li>
<li> <p><code>container_obj</code>: a 'python' object that stores the information for the linked emulation.
</p>
</li>
<li> <p><code>emulator_obj</code>: a 'python' object that stores the information for the predictions from the GP emulator.
</p>
</li></ul>

<p>The returned <code>gp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for GP predictions.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for LOO and OOS validations.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for validation plots.
</p>
</li>
<li> <p><code><a href="#topic+lgp">lgp()</a></code> for linked (D)GP emulator constructions.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the trained GP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the GP emulator to a <code>.pkl</code> file.
</p>
</li>
<li> <p><code><a href="#topic+design">design()</a></code> for sequential designs.
</p>
</li>
<li> <p><code><a href="#topic+update">update()</a></code> to update the GP emulator with new inputs and outputs.
</p>
</li>
<li> <p><code><a href="#topic+alm">alm()</a></code>, <code><a href="#topic+mice">mice()</a></code>, and <code><a href="#topic+vigf">vigf()</a></code> to locate next design points.
</p>
</li></ul>



<h3>Note</h3>

<p>Any R vector detected in <code>X</code> and <code>Y</code> will be treated as a column vector and automatically converted into a single-column
R matrix. Thus, if <code>X</code> is a single data point with multiple dimensions, it must be given as a matrix.
</p>


<h3>References</h3>


<ul>
<li><p> Gu, M. (2019). Jointly robust prior for Gaussian stochastic process in emulation, calibration and variable selection. <em>Bayesian Analysis</em>, <strong>14(3)</strong>, 857-885.
</p>
</li>
<li><p> Katzfuss, M., Guinness, J., &amp; Lawrence, E. (2022). Scaled Vecchia approximation for fast computer-model emulation. <em>SIAM/ASA Journal on Uncertainty Quantification</em>, <strong>10(2)</strong>, 537-554.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the package and the Python env
library(dgpsi)

# construct a step function
f &lt;- function(x) {
   if (x &lt; 0.5) return(-1)
   if (x &gt;= 0.5) return(1)
  }

# generate training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# training
m &lt;- gp(X, Y)

# summarizing
summary(m)

# LOO cross validation
m &lt;- validate(m)
plot(m)

# prediction
test_x &lt;- seq(0, 1, length = 200)
m &lt;- predict(m, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 10)
validate_y &lt;- sapply(validate_x, f)
plot(m, validate_x, validate_y)

# write and read the constructed emulator
write(m, 'step_gp')
m &lt;- read('step_gp')

## End(Not run)

</code></pre>

<hr>
<h2 id='init_py'>'python' environment initialization</h2><span id='topic+init_py'></span>

<h3>Description</h3>

<p>This function initializes the 'python' environment for the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_py(
  py_ver = NULL,
  dgpsi_ver = NULL,
  reinstall = FALSE,
  uninstall = FALSE,
  verb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_py_+3A_py_ver">py_ver</code></td>
<td>
<p>a string that gives the 'python' version to be installed. If <code>py_ver = NULL</code>, the default 'python'
version '3.9.13' will be installed.</p>
</td></tr>
<tr><td><code id="init_py_+3A_dgpsi_ver">dgpsi_ver</code></td>
<td>
<p>a string that gives the 'python' version of 'dgpsi' to be used. If <code>dgpsi_ver = NULL</code>,
</p>

<ul>
<li><p> the latest 'python' version of 'dgpsi' will be used, if the package is installed from CRAN;
</p>
</li>
<li><p> the development 'python' version of 'dgpsi' will be used, if the package is installed from GitHub.
</p>
</li></ul>
</td></tr>
<tr><td><code id="init_py_+3A_reinstall">reinstall</code></td>
<td>
<p>a bool that indicates whether to reinstall the 'python' version of 'dgpsi' specified
in <code>dgpsi_ver</code> if it has already been installed. This argument is useful when the development version
of the R package is installed and one may want to regularly update the development 'python' version
of 'dgpsi'. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_py_+3A_uninstall">uninstall</code></td>
<td>
<p>a bool that indicates whether to uninstall the 'python' version of 'dgpsi' specified
in <code>dgpsi_ver</code> if it has already been installed. This argument is useful when the 'python' environment
is corrupted and one wants to completely uninstall and reinstall it. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="init_py_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information will be printed during function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value, called to install required 'python' environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)

</code></pre>

<hr>
<h2 id='lgp'>Linked (D)GP emulator construction</h2><span id='topic+lgp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function constructs a linked (D)GP emulator for a model chain or network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgp(struc, emulators = NULL, B = 10, activate = TRUE, verb = TRUE, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lgp_+3A_struc">struc</code></td>
<td>
<p>the structure of the linked emulator, which can take one of two forms:
</p>

<ul>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> a list contains <em>L</em> (the number of layers in a systems of computer models) sub-lists,
each of which represents a layer and contains (D)GP emulators (represented by
instances of S3 class <code>gp</code> or <code>dgp</code>) of computer models. The sub-lists are placed in the list
in the same order of the specified computer model system's hierarchy. <strong>This option is deprecated and will be removed in the next release.</strong>
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a data frame that defines the connection structure between emulators in the linked system, with the following columns:
</p>

<ul>
<li> <p><code>From_Emulator</code>: the ID of the emulator providing the output. This ID must match the <code>id</code> slot
in the corresponding emulator object (produced by <code><a href="#topic+gp">gp()</a></code> or <code><a href="#topic+dgp">dgp()</a></code>) within <code>emulators</code> argument of <code><a href="#topic+lgp">lgp()</a></code>, or it should
be special value <code>"Global"</code>, indicating the global inputs to the model chain or network. The <code>id</code> slot
is either automatically generated by <code><a href="#topic+gp">gp()</a></code> or <code><a href="#topic+dgp">dgp()</a></code>, or can be manually specified via the <code>id</code> argument in these functions or set with the
<code><a href="#topic+set_id">set_id()</a></code> function.
</p>
</li>
<li> <p><code>To_Emulator</code>: the ID of the emulator receiving the input, also matching the <code>id</code> slot in the
corresponding emulator object.
</p>
</li>
<li> <p><code>From_Output</code>: a single integer specifying the output dimension of the <code>From_Emulator</code> that is being connected to the
input dimension of the <code>To_Emulator</code> specified by <code>To_Input</code>. If <code>From_Emulator</code> is <code>"Global"</code>, then <code>From_Output</code>
indicates the dimension of the global input passed to the <code>To_Emulator</code>.
</p>
</li>
<li> <p><code>To_Input</code>: a single integer specifying the input dimension of the <code>To_Emulator</code> that is receiving the <code>From_Output</code>  dimension
from the <code>From_Emulator</code>.
</p>
</li></ul>

<p>Each row represents a single one-to-one connection between a specified output dimension of <code>From_Emulator</code>
and a corresponding input dimension of <code>To_Emulator</code>. If multiple connections are required between
two emulators, each connection should be specified in a separate row.
</p>
<p><strong>Note:</strong> When using the data frame option for <code>struc</code>, the <code>emulators</code> argument must be provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="lgp_+3A_emulators">emulators</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a list of emulator objects, each containing an <code>id</code> slot that uniquely identifies it within the
linked system. The <code>id</code> slot in each emulator object must match the <code>From_Emulator</code>/<code>To_Emulator</code> columns in <code>struc</code>.
</p>
<p>If the same emulator is used multiple times within the linked system, the list must contain distinct copies
of that emulator, each with a unique ID stored in their <code>id</code> slot. Use the <code><a href="#topic+set_id">set_id()</a></code> function to produce copies with different IDs
to ensure each instance can be uniquely referenced.</p>
</td></tr>
<tr><td><code id="lgp_+3A_b">B</code></td>
<td>
<p>the number of imputations used for prediction. Increase the value to refine representation of
imputation uncertainty. If the system consists of only GP emulators, <code>B</code> is set to <code>1</code> automatically. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="lgp_+3A_activate">activate</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool indicating whether the initialized linked emulator should be activated:
</p>

<ul>
<li><p> If <code>activate = FALSE</code>, <code><a href="#topic+lgp">lgp()</a></code> returns an inactive linked emulator, allowing inspection of its structure using <code><a href="#topic+summary">summary()</a></code>.
</p>
</li>
<li><p> If <code>activate = TRUE</code>, <code><a href="#topic+lgp">lgp()</a></code> returns an active linked emulator, ready for prediction and validation using <code><a href="#topic+predict">predict()</a></code> and <code><a href="#topic+validate">validate()</a></code>, respectively.
</p>
</li></ul>

<p>Defaults to <code>TRUE</code>. This argument is only applicable when <code>struc</code> is specified as a data frame.</p>
</td></tr>
<tr><td><code id="lgp_+3A_verb">verb</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool indicating if the trace information on linked (D)GP emulator construction should be printed during the function call.
Defaults to <code>TRUE</code>. This argument is only applicable when <code>struc</code> is specified as a data frame.</p>
</td></tr>
<tr><td><code id="lgp_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the linked (D)GP emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID
(Universally Unique Identifier) will be automatically generated and assigned to the emulator. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>lgp</code> that contains three slots:
</p>

<ul>
<li> <p><code>id</code>: A number or character string assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><code>constructor_obj</code>: a list of 'python' objects that stores the information of the constructed linked emulator.
</p>
</li>
<li> <p><code>emulator_obj</code>, a 'python' object that stores the information for predictions from the linked emulator.
</p>
</li>
<li> <p><code>specs</code>: a list that contains
</p>

<ol>
<li> <p><code>seed</code>: the random seed generated to produce the imputations. This information is stored for reproducibility
when the linked (D)GP emulator (that was saved by <code><a href="#topic+write">write()</a></code> with the light option <code>light = TRUE</code>) is loaded back
to R by <code><a href="#topic+read">read()</a></code>.
</p>
</li>
<li> <p><code>B</code>: the number of imputations used to generate the linked (D)GP emulator.
</p>
</li></ol>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>struc</code> is a data frame, <code>specs</code> also includes:
</p>

<ol>
<li> <p><code>metadata</code>: a data frame providing configuration details for each emulator in the linked system, with following columns:
</p>

<ul>
<li> <p><code>Emulator</code>: the ID of an emulator.
</p>
</li>
<li> <p><code>Layer</code>: the layer in the linked system where the emulator is positioned. A lower <code>Layer</code> number indicates
a position closer to the input, with layer numbering increasing as you move away from the input.
</p>
</li>
<li> <p><code>Pos_in_Layer</code>: the position of the emulator within its layer. A lower <code>Pos_in_Layer</code> number
indicates a position higher up in that layer.
</p>
</li>
<li> <p><code>Total_Input_Dims</code>: the total number of input dimensions of the emulator.
</p>
</li>
<li> <p><code>Total_Output_Dims</code>: the total number of output dimensions of the emulator.
</p>
</li></ul>

</li>
<li> <p><code>struc</code>: The linked system structure, as supplied by <code>struc</code>.
</p>
</li></ol>

</li></ul>

<p>The returned <code>lgp</code> object can be used by
</p>

<ul>
<li> <p><code><a href="#topic+predict">predict()</a></code> for linked (D)GP predictions.
</p>
</li>
<li> <p><code><a href="#topic+validate">validate()</a></code> for OOS validation.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> for validation plots.
</p>
</li>
<li> <p><code><a href="#topic+summary">summary()</a></code> to summarize the constructed linked (D)GP emulator.
</p>
</li>
<li> <p><code><a href="#topic+write">write()</a></code> to save the linked (D)GP emulator to a <code>.pkl</code> file.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# model 1
f1 &lt;- function(x) {
  (sin(7.5*x)+1)/2
}
# model 2
f2 &lt;- function(x) {
  2/3*sin(2*(2*x - 1))+4/3*exp(-30*(2*(2*x-1))^2)-1/3
}
# linked model
f12 &lt;- function(x) {
  f2(f1(x))
}

# training data for Model 1
X1 &lt;- seq(0, 1, length = 9)
Y1 &lt;- sapply(X1, f1)
# training data for Model 2
X2 &lt;- seq(0, 1, length = 13)
Y2 &lt;- sapply(X2, f2)

# emulation of model 1
m1 &lt;- gp(X1, Y1, name = "matern2.5", id = "emulator1")
# emulation of model 2
m2 &lt;- dgp(X2, Y2, depth = 2, name = "matern2.5", id = "emulator2")

struc &lt;- data.frame(From_Emulator = c("Global", "emulator1"),
                    To_Emulator = c("emulator1", "emulator2"),
                    From_Output = c(1, 1),
                    To_Input = c(1, 1))
emulators &lt;- list(m1, m2)

# construct the linked emulator for visual inspection
m_link &lt;- lgp(struc, emulators, activate = FALSE)

# visual inspection
summary(m_link)

# build the linked emulator for prediction
m_link &lt;- lgp(struc, emulators, activate = TRUE)
test_x &lt;- seq(0, 1, length = 300)
m_link &lt;- predict(m_link, x = test_x)

# OOS validation
validate_x &lt;- sample(test_x, 20)
validate_y &lt;- sapply(validate_x, f12)
plot(m_link, validate_x, validate_y, style = 2)

# write and read the constructed linked emulator
write(m_link, 'linked_emulator')
m_link &lt;- read('linked_emulator')

## End(Not run)
</code></pre>

<hr>
<h2 id='mice'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using MICE</h2><span id='topic+mice'></span><span id='topic+mice.gp'></span><span id='topic+mice.dgp'></span><span id='topic+mice.bundle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Mutual Information for Computer Experiments (MICE), see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mice(object, ...)

## S3 method for class 'gp'
mice(
  object,
  x_cand = NULL,
  n_cand = 200,
  batch_size = 1,
  M = 50,
  nugget_s = 1e-06,
  workers = 1,
  limits = NULL,
  int = FALSE,
  ...
)

## S3 method for class 'dgp'
mice(
  object,
  x_cand = NULL,
  n_cand = 200,
  batch_size = 1,
  M = 50,
  nugget_s = 1e-06,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
mice(
  object,
  x_cand = NULL,
  n_cand = 200,
  batch_size = 1,
  M = 50,
  nugget_s = 1e-06,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mice_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mice_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+mice">mice()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="mice_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class and <code>aggregate</code> is not supplied, <code>x_cand</code> can also be a list.
The list must have a length equal to the number of emulators in <code>object</code>, with each element being a matrix representing the candidate set for a corresponding
emulator in the bundle. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_n_cand">n_cand</code></td>
<td>
<p>an integer specifying the size of the candidate set to be generated for selecting the next design point(s).
This argument is used only when <code>x_cand</code> is <code>NULL</code>. Defaults to <code>200</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the criterion calculation. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_nugget_s">nugget_s</code></td>
<td>
<p>the value of the smoothing nugget term used by MICE. Defaults to <code>1e-6</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_workers">workers</code></td>
<td>
<p>the number of processes to be used for the criterion calculation. If set to <code>NULL</code>,
the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_limits">limits</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one input dimension.
If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input dimensions, and its
first and second columns correspond to the minimum and maximum values of the input dimensions. This
argument is only used when <code>x_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_int">int</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool or a vector of bools that indicates if an input dimension is an integer type. If a single bool is given, it will be applied to
all input dimensions. If a vector is provided, it should have a length equal to the input dimensions and will be applied to individual
input dimensions. This argument is only used when <code>x_cand = NULL</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mice_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the MICE across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregate scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ol>
<li><p> If <code>x_cand</code> is not <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a vector of length <code>batch_size</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code>.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a vector of length <code>batch_size * D</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code> to be added to the DGP emulator.
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with <code>batch_size</code> rows and a column for each emulator in
the bundle, containing the positions (row numbers) of the next design points from <code>x_cand</code> for individual emulators.
</p>
</li></ul>

</li>
<li><p> If <code>x_cand</code> is <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a matrix with <code>batch_size</code> rows is returned, giving the next design points to be evaluated.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a matrix with <code>batch_size * D</code> rows is returned, where:
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a list is returned with a length equal to the number of emulators in the bundle. Each
element of the list is a matrix with <code>batch_size</code> rows, where each row represents a design point to be added to the corresponding emulator.
</p>
</li></ul>

</li></ol>



<h3>Note</h3>

<p>The first column of the matrix supplied to the first argument of <code>aggregate</code> must correspond to the first output dimension of the DGP emulator
if <code>object</code> is an instance of the <code>dgp</code> class, and so on for subsequent columns and dimensions. If <code>object</code> is an instance of the <code>bundle</code> class,
the first column must correspond to the first emulator in the bundle, and so on for subsequent columns and emulators.
</p>


<h3>References</h3>

<p>Beck, J., &amp; Guillas, S. (2016). Sequential design with mutual information for computer experiments (MICE): emulation of a tsunami model.
<em>SIAM/ASA Journal on Uncertainty Quantification</em>, <strong>4(1)</strong>, 739-766.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# generate a candidate set
x_cand &lt;- maximinLHS(200,1)

# locate the next design point using MICE
next_point &lt;- mice(m, x_cand = x_cand)
X_new &lt;- x_cand[next_point,,drop = F]

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit
m &lt;- update(m, X, Y, refit = TRUE)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='nllik'>Calculate the predictive negative log-likelihood</h2><span id='topic+nllik'></span>

<h3>Description</h3>

<p>This function computes the predictive negative log-likelihood from a
DGP emulator with a likelihood layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nllik(object, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nllik_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class and it should be produced by <code><a href="#topic+dgp">dgp()</a></code> with <code>likelihood</code> not being <code>NULL</code>;</p>
</td></tr>
<tr><td><code id="nllik_+3A_x">x</code></td>
<td>
<p>a matrix where each row is an input testing data point and each column is an input dimension.</p>
</td></tr>
<tr><td><code id="nllik_+3A_y">y</code></td>
<td>
<p>a matrix with only one column where each row is a scalar-valued testing output data point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> is returned with an additional slot named <code>NLL</code> that contains two elements.
The first one, named <code>meanNLL</code>, is a scalar that gives the average negative predicted log-likelihood
across all testing data points. The second one, named <code>allNLL</code>, is a vector that gives the negative predicted
log-likelihood for each testing data point.
</p>

<hr>
<h2 id='pack'>Pack GP and DGP emulators into a bundle</h2><span id='topic+pack'></span>

<h3>Description</h3>

<p>This function packs GP emulators and DGP emulators into a <code>bundle</code> class for
sequential designs if each emulator emulates one output dimension of the underlying simulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(..., id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pack_+3A_...">...</code></td>
<td>
<p>a sequence or a list of emulators produced by <code><a href="#topic+gp">gp()</a></code> or <code><a href="#topic+dgp">dgp()</a></code>.</p>
</td></tr>
<tr><td><code id="pack_+3A_id">id</code></td>
<td>
<p>an ID to be assigned to the bundle emulator. If an ID is not provided (i.e., <code>id = NULL</code>), a UUID (Universally Unique Identifier) will be automatically generated
and assigned to the emulator. Default to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An S3 class named <code>bundle</code> to be used by <code><a href="#topic+design">design()</a></code> for sequential designs. It has:
</p>

<ul>
<li><p> a slot called <code>id</code> that is assigned through the <code>id</code> argument.
</p>
</li>
<li> <p><em>N</em> slots named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code>, each of which contains a GP or DGP emulator, where <em>N</em> is the number of emulators
that are provided to the function.
</p>
</li>
<li><p> a slot called <code>data</code> which contains two elements <code>X</code> and <code>Y</code>. <code>X</code> contains <em>N</em> matrices named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code> that are
training input data for different emulators. <code>Y</code> contains <em>N</em> single-column matrices named <code style="white-space: pre;">&#8288;emulator1,...,emulatorN&#8288;</code> that are
training output data for different emulators.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages
library(lhs)
library(dgpsi)

# construct a function with a two-dimensional output
f &lt;- function(x) {
 y1 = sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
 y2 = 1/3*sin(2*(2*x - 1))+2/3*exp(-30*(2*(2*x-1))^2)+1/3
 return(cbind(y1,y2))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# generate the validation data
validate_x &lt;- maximinLHS(30,1)
validate_y &lt;- f(validate_x)

# training a 2-layered DGP emulator with respect to each output with the global connection off
m1 &lt;- dgp(X, Y[,1], connect = F)
m2 &lt;- dgp(X, Y[,2], connect = F)

# specify the range of the input dimension
lim &lt;- c(0, 1)

# pack emulators to form an emulator bundle
m &lt;- pack(m1, m2)

# 1st wave of the sequential design with 10 iterations and the target RMSE of 0.01
m &lt;- design(m, N = 10, limits = lim, f = f, x_test = validate_x, y_test = validate_y, target = 0.01)

# 2rd wave of the sequential design with additional 10 iterations and the same target
m &lt;- design(m, N = 10, limits = lim, f = f, x_test = validate_x, y_test = validate_y, target = 0.01)

# draw sequential designs of the two packed emulators
draw(m, type = 'design')

# inspect the traces of RMSEs of the two packed emulators
draw(m, type = 'rmse')

# write and read the constructed emulator bundle
write(m, 'bundle_dgp')
m &lt;- read('bundle_dgp')

# unpack the bundle into individual emulators
m_unpacked &lt;- unpack(m)

# plot OOS validations of individual emulators
plot(m_unpacked[[1]], x_test = validate_x, y_test = validate_y[,1])
plot(m_unpacked[[2]], x_test = validate_x, y_test = validate_y[,2])

## End(Not run)
</code></pre>

<hr>
<h2 id='plot'>Validation plots of a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+plot'></span><span id='topic+plot.dgp'></span><span id='topic+plot.lgp'></span><span id='topic+plot.gp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function draws validation plots of a GP, DGP, or linked (D)GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = NULL,
  sample_size = 50,
  style = 1,
  min_max = TRUE,
  normalize = TRUE,
  color = "turbo",
  type = "points",
  verb = TRUE,
  M = 50,
  force = FALSE,
  cores = 1,
  ...
)

## S3 method for class 'lgp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = NULL,
  sample_size = 50,
  style = 1,
  min_max = TRUE,
  color = "turbo",
  type = "points",
  M = 50,
  verb = TRUE,
  force = FALSE,
  cores = 1,
  ...
)

## S3 method for class 'gp'
plot(
  x,
  x_test = NULL,
  y_test = NULL,
  dim = NULL,
  method = NULL,
  sample_size = 50,
  style = 1,
  min_max = TRUE,
  color = "turbo",
  type = "points",
  verb = TRUE,
  M = 50,
  force = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>can be one of the following emulator classes:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_+3A_x_test">x_test</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_y_test">y_test</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_dim">dim</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> if <code>dim = NULL</code>, the index of an emulator's input within the design will be shown on the x-axis in validation plots. Otherwise, <code>dim</code> indicates
which dimension of an emulator's input will be shown on the x-axis in validation plots:
</p>

<ul>
<li><p> If <code>x</code> is an instance of the <code>gp</code> of <code>dgp</code> class, <code>dim</code> is an integer.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> If <code>x</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> without specifying the <code>struc</code> argument in data frame form, <code>dim</code> can be:
</p>

<ol>
<li><p> an integer referring to the dimension of the global input to emulators in the first layer of a linked emulator system; or
</p>
</li>
<li><p> a vector of three integers referring to the dimension (specified by the third integer) of the global input to an emulator
(specified by the second integer) in a layer (specified by the first integer) that is not the first layer of a linked emulator
system.
</p>
</li></ol>

<p><strong>This option for linked (D)GP emulators is deprecated and will be removed in the next release.</strong>
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>x</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> with argument <code>struc</code> in data frame form, <code>dim</code> is an integer referring
to the dimension of the global input to the linked emulator system.
</p>
</li></ul>

<p>This argument is only used when <code>style = 1</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_method">method</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_sample_size">sample_size</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_style">style</code></td>
<td>
<p>either <code>1</code> or <code>2</code>, indicating two different plotting styles for validation.</p>
</td></tr>
<tr><td><code id="plot_+3A_min_max">min_max</code></td>
<td>
<p>a bool indicating if min-max normalization will be used to scale the testing output, RMSE, predictive mean and std from the
emulator. Defaults to <code>TRUE</code>. This argument is not applicable to DGP emulators with categorical likelihoods.</p>
</td></tr>
<tr><td><code id="plot_+3A_normalize">normalize</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool indicating if normalization will be used to scale the counts in validation plots of DGP emulators with categorical
likelihoods when <code>style = 2</code>.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>
<p>a character string indicating the color map to use when <code>style = 2</code>:
</p>

<ul>
<li> <p><code>'magma'</code> (or <code>'A'</code>)
</p>
</li>
<li> <p><code>'inferno'</code> (or <code>'B'</code>)
</p>
</li>
<li> <p><code>'plasma'</code> (or '<code>C</code>')
</p>
</li>
<li> <p><code>'viridis'</code> (or <code>'D'</code>)
</p>
</li>
<li> <p><code>'cividis'</code> (or <code>'E'</code>)
</p>
</li>
<li> <p><code>'rocket'</code> (or <code>'F'</code>)
</p>
</li>
<li> <p><code>'mako'</code> (or <code>'G'</code>)
</p>
</li>
<li> <p><code>'turbo'</code> (or <code>'H'</code>)
</p>
</li></ul>

<p>Defaults to <code>'turbo'</code> (or <code>'H'</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>either <code>'line'</code> or <code style="white-space: pre;">&#8288;'points&#8288;</code>, indicating whether to draw testing data in the OOS validation plot as a line or
individual points when the input of the emulator is one-dimensional and <code>style = 1</code>. This argument is not applicable to DGP emulators with
categorical likelihoods. Defaults to <code>'points'</code></p>
</td></tr>
<tr><td><code id="plot_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information on plotting will be printed during execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_force">force</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_cores">cores</code></td>
<td>
<p>same as that of <code><a href="#topic+validate">validate()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>patchwork</code> object.
</p>


<h3>Note</h3>


<ul>
<li> <p><code><a href="#topic+plot">plot()</a></code> calls <code><a href="#topic+validate">validate()</a></code> internally to obtain validation results for plotting. However, <code><a href="#topic+plot">plot()</a></code> will not export the
emulator object with validation results. Instead, it only returns the plotting object. For small-scale validations (i.e., small
training or testing data points), direct execution of <code><a href="#topic+plot">plot()</a></code> works well. However, for moderate- to large-scale validation,
it is recommended to first run <code><a href="#topic+validate">validate()</a></code> to obtain and store validation results in the emulator object, and then supply the
object to <code><a href="#topic+plot">plot()</a></code>. <code><a href="#topic+plot">plot()</a></code> checks the object's <code>loo</code> and <code>oos</code> slots prior to calling <code><a href="#topic+validate">validate()</a></code> and will not perform further calculation if the required information is already stored.
</p>
</li>
<li> <p><code><a href="#topic+plot">plot()</a></code> will only use stored OOS validation if <code>x_test</code> and <code>y_test</code> are identical to those used by <code><a href="#topic+validate">validate()</a></code> to produce the data contained in the object's <code>oos</code> slot, otherwise <code><a href="#topic+plot">plot()</a></code> will re-evaluate OOS validation before plotting.
</p>
</li>
<li><p> The returned <a href="patchwork.html#topic+patchwork-package">patchwork::patchwork</a> object contains the <a href="ggplot2.html#topic+ggplot2-package">ggplot2::ggplot2</a> objects. One can modify the included individual ggplots
by accessing them with double-bracket indexing. See <a href="https://patchwork.data-imaginist.com/">https://patchwork.data-imaginist.com/</a> for further information.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='predict'>Prediction from GP, DGP, or linked (D)GP emulators</h2><span id='topic+predict'></span><span id='topic+predict.dgp'></span><span id='topic+predict.lgp'></span><span id='topic+predict.gp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function implements prediction from GP, DGP, or linked (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgp'
predict(
  object,
  x,
  method = NULL,
  mode = "label",
  full_layer = FALSE,
  sample_size = 50,
  M = 50,
  cores = 1,
  chunks = NULL,
  ...
)

## S3 method for class 'lgp'
predict(
  object,
  x,
  method = NULL,
  full_layer = FALSE,
  sample_size = 50,
  M = 50,
  cores = 1,
  chunks = NULL,
  ...
)

## S3 method for class 'gp'
predict(
  object,
  x,
  method = NULL,
  sample_size = 50,
  M = 50,
  cores = 1,
  chunks = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an instance of the <code>gp</code>, <code>dgp</code>, or <code>lgp</code> class.</p>
</td></tr>
<tr><td><code id="predict_+3A_x">x</code></td>
<td>
<p>the testing input data:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class, <code>x</code> is a matrix where each row is an input testing data point and each column is an input dimension.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> if <code>object</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> without specifying argument <code>struc</code> in data frame form, <code>x</code> can be either a matrix or a list:
</p>

<ul>
<li><p> if <code>x</code> is a matrix, its rows are treated as instances of the <code>Global</code> inputs. In this case, it is assumed that the only global input to the system is the input to the
emulators in the first layer and there is no global input to emulators in other layers.
</p>
</li>
<li><p> if <code>x</code> is a list, it should have <em>L</em> (the number of layers in an emulator system) elements. The first element
is a matrix that represents the global testing input data that feed into the emulators in the first layer of the system. The
remaining <em>L-1</em> elements are <em>L-1</em> sub-lists, each of which contains a number (the same number of emulators in
the corresponding layer) of matrices (rows being testing input data points and columns being input dimensions) that represent the
global testing input data to the emulators in the corresponding layer. The matrices must be placed in the sub-lists based on how
their corresponding emulators are placed in <code>struc</code> argument of <code><a href="#topic+lgp">lgp()</a></code>. If there is no global input data to a certain emulator,
set <code>NULL</code> in the corresponding sub-list of <code>x</code>.
</p>
</li></ul>

<p><strong>This option for linked (D)GP emulators is deprecated and will be removed in the next release.</strong>
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>object</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> with argument <code>struc</code> in data frame form,
<code>x</code> must be a matrix representing the global input, where each row corresponds to a test data point and each column represents a global input dimension.
The column indices in <code>x</code> must align with the indices specified in the <code>From_Output</code> column of the <code>struc</code> data frame (used in <code><a href="#topic+lgp">lgp()</a></code>),
corresponding to rows where the <code>From_Emulator</code> column is <code>"Global"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict_+3A_method">method</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> the prediction approach to use: either the mean-variance approach (<code>"mean_var"</code>) or the sampling approach (<code>"sampling"</code>).
The mean-variance approach returns the means and variances of the predictive distributions, while the sampling approach generates samples from predictive distributions
using the derived means and variances. For DGP emulators with a categorical likelihood (<code>likelihood = "Categorical"</code> in <code><a href="#topic+dgp">dgp()</a></code>), <code>method</code> is only applicable
when <code>full_layer = TRUE</code>. In this case, the sampling approach generates samples from the GP nodes in all hidden layers using the derived means and variances,
and subsequently propagates these samples through the categorical likelihood. By default, the method is set to <code>"sampling"</code> for DGP emulators with Poisson, Negative Binomial, and
Categorical likelihoods, and to <code>"mean_var"</code> otherwise.</p>
</td></tr>
<tr><td><code id="predict_+3A_mode">mode</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> whether to predict the classes (<code>"label"</code>) or probabilities (<code>"proba"</code>) of different classes when <code>object</code> is a DGP emulator with a categorical likelihood.
Defaults to <code>"label"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_full_layer">full_layer</code></td>
<td>
<p>a bool indicating whether to output the predictions of all layers. Defaults to <code>FALSE</code>. Only used when <code>object</code> is a DGP or a linked (D)GP emulator.</p>
</td></tr>
<tr><td><code id="predict_+3A_sample_size">sample_size</code></td>
<td>
<p>the number of samples to draw for each given imputation if <code>method = "sampling"</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the emulator prediction. Defaults to <code>50</code>. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation.</p>
</td></tr>
<tr><td><code id="predict_+3A_cores">cores</code></td>
<td>
<p>the number of processes to be used for prediction. If set to <code>NULL</code>, the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_chunks">chunks</code></td>
<td>
<p>the number of chunks that the testing input matrix <code>x</code> will be divided into for multi-cores to work on.
Only used when <code>cores</code> is not <code>1</code>. If not specified (i.e., <code>chunks = NULL</code>), the number of chunks is set to the value of <code>cores</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two matrices named <code>mean</code>
for the predictive means and <code>var</code> for the predictive variances. Each matrix has only one column with its rows
corresponding to testing positions (i.e., rows of <code>x</code>).
</p>
</li>
<li><p> if <code>method = "sampling"</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains a matrix whose rows correspond
to testing positions and columns correspond to <code>sample_size</code> number of samples drawn from the predictive distribution of GP.
</p>
</li></ol>

</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two
matrices named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each matrix has its rows corresponding to testing
positions and columns corresponding to DGP global output dimensions (i.e., the number of GP/likelihood nodes in the final layer).
</p>
</li>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains two
sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list contains <em>L</em> (i.e., the number of layers)
matrices named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each matrix has its rows corresponding to testing positions and columns corresponding to
output dimensions (i.e., the number of GP/likelihood nodes from the associated layer).
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>D</em> (i.e., the number
of GP/likelihood nodes in the final layer) matrices named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>. Each matrix has its rows corresponding to testing positions and
columns corresponding to samples of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>L</em> (i.e., the number
of layers) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list represents samples drawn from the GP/likelihood nodes in the corresponding layer,
and contains <em>D</em> (i.e., the number of GP/likelihood nodes in the corresponding layer) matrices named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>. Each matrix gives samples
of the output from one of <em>D</em> GP/likelihood nodes, and has its rows corresponding to testing positions and columns corresponding to samples
of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li></ol>

</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>object</code> is an instance of the <code>dgp</code> class with a categorical likelihood:
</p>

<ol>
<li><p> if <code>full_layer = FALSE</code> and <code>mode = "label"</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains one matrix named <code>label</code>.
The matrix has rows corresponding to testing positions and columns corresponding to sample labels of size: <code>B * sample_size</code>, where <code>B</code> is the number
of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li>
<li><p> if <code>full_layer = FALSE</code> and <code>mode = "proba"</code>, an updated <code>object</code> is returned with an additional slot called <code>results</code>. This slot contains <em>D</em> matrices (where
<em>D</em> is the number of classes in the training output), where each matrix gives probability samples for the corresponding class with its rows corresponding to testing
positions and columns containing probabilities. The number of columns of each matrix is <code>B * sample_size</code>, where <code>B</code> is the number of imputations
specified in the <code><a href="#topic+dgp">dgp()</a></code> function.
</p>
</li>
<li><p> if <code>method = "mean_var"</code> and <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>L</em> (i.e., the number
of layers) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each of first <code>L-1</code> sub-lists contains two matrices named <code>mean</code> for the predictive means and <code>var</code>
for the predictive variances of the GP nodes in the associated layer. Rows of each matrix correspond to testing positions.
</p>

<ul>
<li><p> when <code>mode = "label"</code>, the sub-list <code>LayerL</code> contains one matrix named <code>label</code>. The matrix has its rows corresponding to testing positions and columns
corresponding to label samples of size: <code>B * sample_size</code>. <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li>
<li><p> when <code>mode = "proba"</code>, the sub-list <code>LayerL</code> contains <em>D</em> matrices (where <em>D</em> is the number of classes in the training output), where each matrix gives probability
samples for the corresponding class with its rows corresponding to testing positions and columns containing probabilities. The number of columns of each matrix
is <code>B * sample_size</code>. <code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li></ul>

</li>
<li><p> if <code>method = "sampling"</code> and <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains <em>L</em> (i.e., the number
of layers) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each of first <code>L-1</code> sub-lists represents samples drawn from the GP nodes in the
corresponding layer, and contains <em>D</em> (i.e., the number of GP nodes in the corresponding layer) matrices named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>. Each matrix
gives samples of the output from one of <em>D</em> GP nodes, and has its rows corresponding to testing positions and columns corresponding to samples
of size: <code>B * sample_size</code>.
</p>

<ul>
<li><p> when <code>mode = "label"</code>, the sub-list <code>LayerL</code> contains one matrix named <code>label</code>. The matrix has its rows corresponding to testing positions and columns
corresponding to label samples of size: <code>B * sample_size</code>.
</p>
</li>
<li><p> when <code>mode = "proba"</code>, the sub-list <code>LayerL</code> contains <em>D</em> matrices (where <em>D</em> is the number of classes in the training output), where each matrix gives probability
samples for the corresponding class with its rows corresponding to testing positions and columns containing probabilities. The number of columns of each matrix
is <code>B * sample_size</code>.
</p>
</li></ul>

<p><code>B</code> is the number of imputations specified in <code><a href="#topic+dgp">dgp()</a></code>.
</p>
</li></ol>

</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> If <code>object</code> is an instance of the <code>lgp</code> class:
</p>

<ol>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that
contains two sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list
contains <em>K</em> (same number of emulators in the final layer of the system) matrices named using the <code>ID</code>s of the corresponding emulators in the final layer.
Each matrix has rows corresponding to global testing positions and columns corresponding to output dimensions of the associated emulator
in the final layer.
</p>
</li>
<li><p> if <code>method = "mean_var"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
two sub-lists named <code>mean</code> for the predictive means and <code>var</code> for the predictive variances respectively. Each sub-list contains <em>L</em>
(i.e., the number of layers in the emulated system) components named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each component represents a layer
and contains <em>K</em> (same number of emulators in the corresponding layer of the system) matrices named using the <code>ID</code>s of the corresponding emulators in that layer.
Each matrix has its rows corresponding to global testing positions and columns corresponding to output dimensions of the associated
GP/DGP emulator in the corresponding layer.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = FALSE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
<em>K</em> (same number of emulators in the final layer of the system) sub-lists named using the <code>ID</code>s of the corresponding emulators in the final layer. Each
sub-list contains <em>D</em> matrices, named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>, that correspond to the output
dimensions of the GP/DGP emulator. Each matrix has rows corresponding to testing positions and columns corresponding to samples
of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+lgp">lgp()</a></code>.
</p>
</li>
<li><p> if <code>method = "sampling"</code> and  <code>full_layer = TRUE</code>: an updated <code>object</code> is returned with an additional slot called <code>results</code> that contains
<em>L</em> (i.e., the number of layers of the emulated system) sub-lists named <code style="white-space: pre;">&#8288;layer1, layer2,..., layerL&#8288;</code>. Each sub-list represents a layer
and contains <em>K</em> (same number of emulators in the corresponding layer of the system) components named using the <code>ID</code>s of the corresponding emulators in that layer.
Each component contains <em>D</em> matrices, named <code style="white-space: pre;">&#8288;output1, output2,..., outputD&#8288;</code>, that correspond to
the output dimensions of the GP/DGP emulator. Each matrix has its rows corresponding to testing positions and columns corresponding to
samples of size: <code>B * sample_size</code>, where <code>B</code> is the number of imputations specified in <code><a href="#topic+lgp">lgp()</a></code>.
</p>
</li></ol>

<p>If <code>object</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> without specifying the <code>struc</code> argument in data frame form, the <code>ID</code>s, that are used as names of sub-lists or
matrices within <code>results</code>, will be replaced by <code>emulator1</code>, <code>emulator2</code>, and so on.
</p>
</li></ul>

<p>The <code>results</code> slot will also include:
</p>

<ul>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the value of <code>M</code>, which represents the size of the conditioning set for the Vecchia approximation, if used, in the emulator prediction.
</p>
</li>
<li><p> the value of <code>sample_size</code> if <code>method = "sampling"</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='prune'>Static pruning of a DGP emulator</h2><span id='topic+prune'></span>

<h3>Description</h3>

<p>This function implements static pruning for a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(object, control = list(), verb = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prune_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class that is generated by <code>dgp()</code>.</p>
</td></tr>
<tr><td><code id="prune_+3A_control">control</code></td>
<td>
<p>a list that can supply the following two components to control static pruning of the DGP emulator:
</p>

<ul>
<li> <p><code>min_size</code>, the minimum number of design points required to trigger pruning. Defaults to 10 times of the input dimensions.
</p>
</li>
<li> <p><code>threshold</code>, the <code class="reqn">R^2</code> value above which a GP node is considered redundant and removable. Defaults to <code>0.97</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="prune_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information will be printed during the function execution. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> that could be an instance of <code>gp</code>, <code>dgp</code>, or <code>bundle</code> (of GP emulators) class.
</p>


<h3>Note</h3>


<ul>
<li><p> The function requires a DGP emulator that has been trained with a dataset comprising a minimum size equal to <code>min_size</code> in <code>control</code>.
If the training dataset size is smaller than this, it is recommended that the design of the DGP emulator is enriched and its
structure pruned dynamically using the <code>design()</code> function. Depending on the design of the DGP emulator, static pruning may not be accurate.
It is thus recommended that dynamic pruning is implemented as a part of a sequential design via <code>design()</code>.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>;
</p>
</li></ul>

<p>in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load the package and the Python env
library(dgpsi)

# construct the borehole function over a hypercube
f &lt;- function(x){
  x[,1] &lt;- (0.15 - 0.5) * x[,1] + 0.5
  x[,2] &lt;- exp((log(50000) - log(100)) * x[,2] + log(100))
  x[,3] &lt;- (115600 - 63070) *x[,3] + 63070
  x[,4] &lt;- (1110 - 990) * x[,4] + 990
  x[,5] &lt;- (116 - 63.1) * x[,5] + 63.1
  x[,6] &lt;- (820 - 700) * x[,6] + 700
  x[,7] &lt;- (1680 - 1120) * x[,7] + 1120
  x[,8] &lt;- (12045 - 9855) * x[,8] + 9855
  y &lt;- apply(x, 1, RobustGaSP::borehole)
}

# set a random seed
set_seed(999)

# generate training data
X &lt;- maximinLHS(80, 8)
Y &lt;- f(X)

# generate validation data
validate_x &lt;- maximinLHS(500, 8)
validate_y &lt;- f(validate_x)

# training a DGP emulator with anisotropic squared exponential kernels
m &lt;- dgp(X, Y, share = F)

# OOS validation of the DGP emulator
plot(m, validate_x, validate_y)

# prune the emulator until no more GP nodes are removable
m &lt;- prune(m)

# OOS validation of the resulting emulator
plot(m, validate_x, validate_y)

## End(Not run)
</code></pre>

<hr>
<h2 id='read'>Load the stored emulator</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>This function loads the <code>.pkl</code> file that stores the emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(pkl_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_+3A_pkl_file">pkl_file</code></td>
<td>
<p>the path to and the name of the <code>.pkl</code> file where the emulator is stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>The S3 class of a GP emulator, a DGP emulator, a linked (D)GP emulator, or a bundle of (D)GP emulators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), lgp(), or pack() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='serialize'>Serialize the constructed emulator</h2><span id='topic+serialize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function serializes the constructed emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialize(object, light = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serialize_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code>, <code>dgp</code>, <code>lgp</code>, or <code>bundle</code>.</p>
</td></tr>
<tr><td><code id="serialize_+3A_light">light</code></td>
<td>
<p>a bool indicating if a light version of the constructed emulator (that requires a small storage) will be serialized.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A serialized version of <code>object</code>.
</p>


<h3>Note</h3>

<p>Since the constructed emulators are 'python' objects, they cannot be directly exported to other R processes for parallel
processing in multi-session workers created through spawning. This function provides a solution by converting the emulators
into serialized objects, which can be restored using <code><a href="#topic+deserialize">deserialize()</a></code> for multi-session processing. Note that in forking,
serialization is generally not required.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(future)
library(future.apply)
library(dgpsi)

# model
f &lt;- function(x) {
 (sin(7.5*x)+1)/2
}

# training data
X &lt;- seq(0, 1, length = 10)
Y &lt;- sapply(X, f)

# train a DGP emulator
m &lt;- dgp(X, Y, name = "matern2.5")

# testing input data
X_dgp &lt;- seq(0, 1, length = 100)

# serialize the DGP emulator
m_serialized &lt;- serialize(m)

# start a multi-session with three cores for parallel predictions
plan(multisession, workers = 3)

# perform parallel predictions
results &lt;- future_lapply(1:length(X_dgp), function(i) {
  m_deserialized &lt;- deserialize(m_serialized)
  mean_i &lt;- predict(m_deserialized, X_dgp[i])$results$mean
}, future.seed = TRUE)

# reset the future plan to sequential
plan(sequential)

# combine mean predictions
pred_mean &lt;- do.call(rbind, results)

## End(Not run)
</code></pre>

<hr>
<h2 id='set_id'>Set Emulator ID</h2><span id='topic+set_id'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function assigns a unique identifier to an emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_id(object, id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_id_+3A_object">object</code></td>
<td>
<p>an emulator object to which the ID will be assigned.</p>
</td></tr>
<tr><td><code id="set_id_+3A_id">id</code></td>
<td>
<p>a unique identifier for the emulator as either a numeric or character
string. Ensure this ID does not conflict with other emulator IDs, especially
when used in linked emulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>The updated <code>object</code>, with the assigned ID stored in its <code>id</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_imp'>Reset number of imputations for a DGP emulator</h2><span id='topic+set_imp'></span>

<h3>Description</h3>

<p>This function resets the number of imputations for prediction from a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_imp(object, B = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_imp_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="set_imp_+3A_b">B</code></td>
<td>
<p>the number of imputations to produce predictions from <code>object</code>. Increase the value to improve imputation uncertainty quantification. Decrease the value to improve speed of prediction. Defaults to <code>5</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with the information of <code>B</code> incorporated.
</p>


<h3>Note</h3>


<ul>
<li><p> This function is useful when a DGP emulator has been trained and one wants to make faster predictions by decreasing
the number of imputations without rebuilding the emulator.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See design() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_linked_idx'>Set linked indices</h2><span id='topic+set_linked_idx'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated and will be removed in the next release. The updated
<code><a href="#topic+lgp">lgp()</a></code> function now offers a simpler, more efficient way to specify linked information
for (D)GP emulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_linked_idx(object, idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_linked_idx_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code> or <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="set_linked_idx_+3A_idx">idx</code></td>
<td>
<p>same as the argument <code>linked_idx</code> of <code><a href="#topic+gp">gp()</a></code> and <code><a href="#topic+dgp">dgp()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with the information of <code>idx</code> incorporated.
</p>


<h3>Note</h3>

<p>This function is useful when different models are emulated by different teams. Each team can create their (D)GP emulator
even without knowing how different emulators are connected together. When this information is available and
different emulators are collected, the connection information between emulators can then be assigned to
individual emulators with this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_seed'>Random seed generator</h2><span id='topic+set_seed'></span>

<h3>Description</h3>

<p>This function initializes a random number generator that sets the random seed in both R and Python
to ensure reproducible results from the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_seed(seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_seed_+3A_seed">seed</code></td>
<td>
<p>a single integer value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='set_thread_num'>Set the number of threads</h2><span id='topic+set_thread_num'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function sets the number of threads for parallel computations involved
in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_thread_num(num)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_thread_num_+3A_num">num</code></td>
<td>
<p>the number of threads. If it is greater than the maximum number of threads available, the
number of threads will be set to the maximum value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='set_vecchia'>Add or remove the Vecchia approximation</h2><span id='topic+set_vecchia'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a>
</p>
<p>This function adds or removes the Vecchia approximation from a GP, DGP or linked (D)GP emulator
constructed by <code><a href="#topic+gp">gp()</a></code>, <code><a href="#topic+dgp">dgp()</a></code> or <code><a href="#topic+lgp">lgp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_vecchia(object, vecchia = TRUE, M = 25, ord = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_vecchia_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code>, <code>dgp</code>, or <code>lgp</code>.</p>
</td></tr>
<tr><td><code id="set_vecchia_+3A_vecchia">vecchia</code></td>
<td>
<p>a bool or a list of bools to indicate the addition or removal of the Vecchia approximation:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class, <code>vecchia</code> is a bool that indicates
either addition (<code>vecchia = TRUE</code>) or removal (<code>vecchia = FALSE</code>) of the Vecchia approximation from <code>object</code>.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>lgp</code> class, <code>x</code> can be a bool or a list of bools:
</p>

<ul>
<li><p> if <code>vecchia</code> is a bool, it indicates either addition (<code>vecchia = TRUE</code>) or removal (<code>vecchia = FALSE</code>) of
the Vecchia approximation from all individual (D)GP emulators contained in <code>object</code>.
</p>
</li>
<li><p> if <code>vecchia</code> is a list of bools, it should have same shape as <code>struc</code> that was supplied to <code><a href="#topic+lgp">lgp()</a></code>. Each bool
in the list indicates if the corresponding (D)GP emulator contained in <code>object</code> shall have the Vecchia approximation
added or removed.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="set_vecchia_+3A_m">M</code></td>
<td>
<p>the size of the conditioning set for the Vecchia approximation in the (D)GP emulator training. Defaults to <code>25</code>.</p>
</td></tr>
<tr><td><code id="set_vecchia_+3A_ord">ord</code></td>
<td>
<p>an R function that returns the ordering of the input to the (D)GP emulator for the Vecchia approximation. The
function must satisfy the following basic rules:
</p>

<ul>
<li><p> the first argument represents the lengthscale-scaled input to the GP emulator or the lengthscale-scaled input to a GP node
of the DGP emulator.
</p>
</li>
<li><p> the output of the function is a vector of indices that gives the ordering of the input to the GP emulator or the input to
the GP nodes of the DGP emulator.
</p>
</li></ul>

<p>If <code>ord = NULL</code>, the default random ordering is used. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with the Vecchia approximation either added or removed.
</p>


<h3>Note</h3>

<p>This function is useful for quickly switching between Vecchia and non-Vecchia approximations for an existing emulator
without the need to reconstruct the emulator. If the emulator was built without the Vecchia approximation, the function
can add it, and if the emulator was built with the Vecchia approximation, the function can remove it. If the current
state already matches the requested state, the emulator remains unchanged.
</p>

<hr>
<h2 id='summary'>Summary of a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+summary'></span><span id='topic+summary.gp'></span><span id='topic+summary.dgp'></span><span id='topic+summary.lgp'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function provides a summary of key information for a GP, DGP, or linked (D)GP emulator
by generating either a table or an interactive plot of the emulator’s structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gp'
summary(object, type = "plot", ...)

## S3 method for class 'dgp'
summary(object, type = "plot", ...)

## S3 method for class 'lgp'
summary(object, type = "plot", group_size = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary_+3A_type">type</code></td>
<td>
<p>a character string, either <code>"table"</code> or <code>"plot"</code>, indicating the format of the output.
If set to <code>"table"</code>, the function returns a summary in table. If set to <code>"plot"</code>, the function
returns an interactive visualization. Defaults to <code>"plot"</code>. If the <code>object</code> was created with
<code><a href="#topic+lgp">lgp()</a></code> where <code>struc</code> is not a data frame, <code>type</code> will automatically default to <code>"table"</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Any arguments that can be passed to <code><a href="kableExtra.html#topic+kbl">kableExtra::kbl()</a></code> when <code>type = "table"</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_group_size">group_size</code></td>
<td>
<p>an integer specifying the number of consecutive layers to be grouped together
in the interactive visualization of linked emulators when <code>type = "plot"</code>.
This argument is only applicable if <code>object</code> is an instance of the <code>lgp</code> class.
Defaults to <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>Either a summary table (returned as <code>kableExtra</code> object) or an interactive visualization
(returned as a <code>visNetwork</code> object) of the emulator. The visualization is compatible with R Markdown
documents and the RStudio Viewer. The summary table can be further customized by <a href="kableExtra.html#topic+kableExtra-package">kableExtra::kableExtra</a> package.
The resulting <code>visNetwork</code> object can be saved as an HTML file using <code><a href="visNetwork.html#topic+visSave">visNetwork::visSave()</a></code> from the <a href="visNetwork.html#topic+visNetwork">visNetwork::visNetwork</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='trace_plot'>Trace plot for DGP hyperparameters</h2><span id='topic+trace_plot'></span>

<h3>Description</h3>

<p>This function draws trace plots for the hyperparameters of a chosen GP node
in a DGP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_plot(object, layer = NULL, node = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_plot_+3A_object">object</code></td>
<td>
<p>an instance of the <code>dgp</code> class.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_layer">layer</code></td>
<td>
<p>the index of a layer. Defaults to <code>NULL</code> for the final layer.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_node">node</code></td>
<td>
<p>the index of a GP node in the layer specified by <code>layer</code>. Defaults to <code>1</code> for the first GP node in the
corresponding layer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='unpack'>Unpack a bundle of (D)GP emulators</h2><span id='topic+unpack'></span>

<h3>Description</h3>

<p>This function unpacks a bundle of (D)GP emulators safely so that any further manipulations of unpacked individual emulators
will not impact those in the bundle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack_+3A_object">object</code></td>
<td>
<p>an instance of the class <code>bundle</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>A named list that contains individual emulators (named <code style="white-space: pre;">&#8288;emulator1,...,emulatorS&#8288;</code>) packed in <code>object</code>,
where <code>S</code> is the number of emulators in <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See pack() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='update'>Update a GP or DGP emulator</h2><span id='topic+update'></span><span id='topic+update.dgp'></span><span id='topic+update.gp'></span>

<h3>Description</h3>

<p>This function updates the training input and output of a GP or DGP emulator with an option to refit the emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update(object, X, Y, refit, reset, verb, ...)

## S3 method for class 'dgp'
update(
  object,
  X,
  Y,
  refit = TRUE,
  reset = FALSE,
  verb = TRUE,
  N = NULL,
  cores = 1,
  ess_burn = 10,
  B = NULL,
  ...
)

## S3 method for class 'gp'
update(object, X, Y, refit = TRUE, reset = FALSE, verb = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="update_+3A_x">X</code></td>
<td>
<p>the new input data which is a matrix where each row is an input training data point and each column represents an input dimension.</p>
</td></tr>
<tr><td><code id="update_+3A_y">Y</code></td>
<td>
<p>the new output data:
</p>

<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, <code>Y</code> is a matrix with only one column and each row being an output data point.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, <code>Y</code> is a matrix with its rows being output data points and columns being
output dimensions. When <code>likelihood</code> (see below) is not <code>NULL</code>, <code>Y</code> must be a matrix with only one column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="update_+3A_refit">refit</code></td>
<td>
<p>a bool indicating whether to re-fit the emulator <code>object</code> after the training input and output are updated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_reset">reset</code></td>
<td>
<p>a bool indicating whether to reset hyperparameters of the emulator <code>object</code> to the initial values first obtained when the emulator was
constructed. Use if it is suspected that a local mode for the hyperparameters has been reached through successive updates. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information will be printed during the function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
<tr><td><code id="update_+3A_n">N</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> number of training iterations used to re-fit the emulator <code>object</code> if it is an instance of the <code>dgp</code> class. If set to <code>NULL</code>,
the number of iterations is set to <code>100</code> if the DGP emulator was constructed without the Vecchia approximation, and is set to <code>50</code>
if Vecchia approximation was used. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_cores">cores</code></td>
<td>
<p>the number of processes to be used to re-fit GP components (in the same layer)
at each M-step during the re-fitting. If set to <code>NULL</code>, the number of processes is set to <code style="white-space: pre;">&#8288;(max physical cores available - 1)&#8288;</code> if <code>vecchia = FALSE</code>
and <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code> if <code>vecchia = TRUE</code>. Only use multiple processes when there is a large number of GP components in different
layers and optimization of GP components is computationally expensive. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_ess_burn">ess_burn</code></td>
<td>
<p>number of burnin steps for the ESS-within-Gibbs sampler at each I-step of the training of the emulator <code>object</code> if it is an
instance of the <code>dgp</code> class. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="update_+3A_b">B</code></td>
<td>
<p>the number of imputations for predictions from the updated emulator <code>object</code> if it is an instance of the <code>dgp</code> class.
This overrides the number of imputations set in <code>object</code>. Set to <code>NULL</code> to use the same number of imputations set
in <code>object</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>;
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>; and
</p>
</li>
<li> <p><code>design</code> created by <code><a href="#topic+design">design()</a></code>
</p>
</li></ul>

<p>in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See alm(), mice(), or vigf() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='validate'>Validate a constructed GP, DGP, or linked (D)GP emulator</h2><span id='topic+validate'></span><span id='topic+validate.gp'></span><span id='topic+validate.dgp'></span><span id='topic+validate.lgp'></span>

<h3>Description</h3>

<p>This function calculates Leave-One-Out (LOO) cross validation or Out-Of-Sample (OOS) validation statistics for a constructed GP, DGP, or linked (D)GP emulator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(
  object,
  x_test,
  y_test,
  method,
  sample_size,
  verb,
  M,
  force,
  cores,
  ...
)

## S3 method for class 'gp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = NULL,
  sample_size = 50,
  verb = TRUE,
  M = 50,
  force = FALSE,
  cores = 1,
  ...
)

## S3 method for class 'dgp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = NULL,
  sample_size = 50,
  verb = TRUE,
  M = 50,
  force = FALSE,
  cores = 1,
  ...
)

## S3 method for class 'lgp'
validate(
  object,
  x_test = NULL,
  y_test = NULL,
  method = NULL,
  sample_size = 50,
  verb = TRUE,
  M = 50,
  force = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>lgp</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="validate_+3A_x_test">x_test</code></td>
<td>
<p>OOS testing input data:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code> class, <code>x_test</code> is a matrix where each row is a new input location to be used for validating the emulator and each column is an input dimension.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> if <code>object</code> is an instance of the <code>lgp</code> class, <code>x_test</code> can be a matrix or a list:
</p>

<ul>
<li><p> if <code>x_test</code> is a matrix, it is the global testing input data that feed into the emulators in the first layer of a system.
The rows of <code>x_test</code> represent different input data points and the columns represent input dimensions across all emulators in
the first layer of the system. In this case, it is assumed that the only global input to the system is the input to the
emulators in the first layer and there is no global input to emulators in other layers.
</p>
</li>
<li><p> if <code>x_test</code> is a list, it should have <em>L</em> (the number of layers in an emulator system) elements. The first element
is a matrix that represents the global testing input data that feed into the emulators in the first layer of the system. The
remaining <em>L-1</em> elements are <em>L-1</em> sub-lists, each of which contains a number (the same number of emulators in
the corresponding layer) of matrices (rows being testing input data points and columns being input dimensions) that represent the
global testing input data to the emulators in the corresponding layer. The matrices must be placed in the sub-lists based on how
their corresponding emulators are placed in <code>struc</code> argument of <code><a href="#topic+lgp">lgp()</a></code>. If there is no global input data to a certain emulator,
set <code>NULL</code> in the corresponding sub-list of <code>x_test</code>.
</p>
</li></ul>

<p><strong>This option for linked (D)GP emulators is deprecated and will be removed in the next release.</strong>
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>object</code> is an instance of the <code>lgp</code> class created by <code><a href="#topic+lgp">lgp()</a></code> with argument <code>struc</code> in data frame form,
<code>x_test</code> must be a matrix representing the global input, where each row corresponds to a test data point and each column represents a global input dimension.
The column indices in <code>x_test</code> must align with the indices specified in the <code>From_Output</code> column of the <code>struc</code> data frame (used in <code><a href="#topic+lgp">lgp()</a></code>),
corresponding to rows where the <code>From_Emulator</code> column is <code>"Global"</code>.
</p>
</li></ul>

<p><code>x_test</code> must be provided if <code>object</code> is an instance of the <code>lgp</code>. <code>x_test</code> must also be provided if <code>y_test</code> is provided. Defaults to <code>NULL</code>, in which case LOO validation is performed.</p>
</td></tr>
<tr><td><code id="validate_+3A_y_test">y_test</code></td>
<td>
<p>the OOS output data corresponding to <code>x_test</code>:
</p>

<ul>
<li><p> if <code>object</code> is an instance of the <code>gp</code> class, <code>y_test</code> is a matrix with only one column where each row represents the output corresponding to the matching row of <code>x_test</code>.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>dgp</code> class, <code>y_test</code> is a matrix where each row represents the output corresponding to the matching row of <code>x_test</code> and with columns representing output dimensions.
</p>
</li>
<li><p> if <code>object</code> is an instance of the <code>lgp</code> class, <code>y_test</code> can be a single matrix or a list of matrices:
</p>

<ul>
<li><p> if <code>y_test</code> is a single matrix, then there should be only one emulator in the final layer of the linked emulator system and <code>y_test</code>
represents the emulator's output with rows being testing positions and columns being output dimensions.
</p>
</li>
<li><p> if <code>y_test</code> is a list, then <code>y_test</code> should have <em>L</em> matrices, where <em>L</em> is the number of emulators in the final layer of the system.
Each matrix has its rows corresponding to testing positions and columns corresponding to output dimensions of the associated emulator
in the final layer.
</p>
</li></ul>

</li></ul>

<p><code>y_test</code> must be provided if <code>object</code> is an instance of the <code>lgp</code>. <code>y_test</code> must also be provided if <code>x_test</code> is provided. Defaults to <code>NULL</code>, in which case LOO validation is performed.</p>
</td></tr>
<tr><td><code id="validate_+3A_method">method</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a> the prediction approach to use for validation: either the mean-variance approach (<code>"mean_var"</code>) or the sampling approach (<code>"sampling"</code>). For details see <code><a href="#topic+predict">predict()</a></code>.
For DGP emulators with a categorical likelihood (<code>likelihood = "Categorical"</code> in <code><a href="#topic+dgp">dgp()</a></code>), only the sampling approach is supported.
By default, the method is set to <code>"sampling"</code> for DGP emulators with Poisson, Negative Binomial, and Categorical likelihoods and <code>"mean_var"</code> otherwise.</p>
</td></tr>
<tr><td><code id="validate_+3A_sample_size">sample_size</code></td>
<td>
<p>the number of samples to draw for each given imputation if <code>method = "sampling"</code>. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_verb">verb</code></td>
<td>
<p>a bool indicating if trace information for validation should be printed during function execution.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in emulator validation. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_force">force</code></td>
<td>
<p>a bool indicating whether to force LOO or OOS re-evaluation when the <code>loo</code> or <code>oos</code> slot already exists in <code>object</code>. When <code>force = FALSE</code>,
<code><a href="#topic+validate">validate()</a></code> will only re-evaluate the emulators if the <code>x_test</code> and <code>y_test</code> are not identical to the values in the <code>oos</code> slot. If the existing <code>loo</code> or <code>oos</code> validation used a different <code>M</code> in a Vecchia approximation or a different <code>method</code> to the one prescribed in this call, the emulator will be re-evaluated. Set <code>force</code> to <code>TRUE</code> when LOO or OOS re-evaluation
is required. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_cores">cores</code></td>
<td>
<p>the number of processes to be used for validation. If set to <code>NULL</code>, the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>N/A.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ul>
<li><p> If <code>object</code> is an instance of the <code>gp</code> class, an updated <code>object</code> is returned with an additional slot called <code>loo</code> (for LOO cross validation) or
<code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_train</code> (or <code>x_test</code>) and <code>y_train</code> (or <code>y_test</code>) that contain the validation data points for LOO (or OOS).
</p>
</li>
<li><p> a column matrix called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of the
GP emulator at validation positions.
</p>
</li>
<li><p> three column matrices called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of the
GP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard deviations above
and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a numeric value called <code>rmse</code> that contains the root mean/median squared error of the GP emulator.
</p>
</li>
<li><p> a numeric value called <code>nrmse</code> that contains the (max-min) normalized root mean/median squared error of the GP emulator. The max-min normalization
uses the maximum and minimum values of the validation outputs contained in <code>y_train</code> (or <code>y_test</code>).
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer called <code>M</code> that contains the size of the conditioning set used for the Vecchia approximation, if used, for emulator validation.
</p>
</li>
<li><p> an integer called <code>sample_size</code> that contains the number of samples used for validation if <code>method = "sampling"</code>.
</p>
</li></ul>

<p>The rows of matrices (<code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, and <code>upper</code>) correspond to the validation positions.
</p>
</li>
<li><p> If <code>object</code> is an instance of the <code>dgp</code> class, an updated <code>object</code> is returned with an additional slot called <code>loo</code> (for LOO cross validation) or
<code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_train</code> (or <code>x_test</code>) and <code>y_train</code> (or <code>y_test</code>) that contain the validation data points for LOO (or OOS).
</p>
</li>
<li><p> a matrix called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of the
DGP emulator at validation positions.
</p>
</li>
<li><p> three matrices called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of the
DGP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard deviations above
and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a vector called <code>rmse</code> that contains the root mean/median squared errors of the DGP emulator across different output
dimensions.
</p>
</li>
<li><p> a vector called <code>nrmse</code> that contains the (max-min) normalized root mean/median squared errors of the DGP emulator across different output
dimensions. The max-min normalization uses the maximum and minimum values of the validation outputs contained in <code>y_train</code> (or <code>y_test</code>).
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer called <code>M</code> that contains size of the conditioning set used for the Vecchia approximation, if used, for emulator validation.
</p>
</li>
<li><p> an integer called <code>sample_size</code> that contains the number of samples used for validation if <code>method = "sampling"</code>.
</p>
</li></ul>

<p>The rows and columns of matrices (<code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, and <code>upper</code>) correspond to the validation positions and DGP emulator output
dimensions, respectively.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> If <code>object</code> is an instance of the <code>dgp</code> class with a categorical likelihood, an updated <code>object</code> is returned with an additional slot called <code>loo</code>
(for LOO cross validation) or <code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_train</code> (or <code>x_test</code>) and <code>y_train</code> (or <code>y_test</code>) that contain the validation data points for LOO (or OOS).
</p>
</li>
<li><p> a matrix called <code>label</code> that contains predictive samples of labels from the DGP emulator at validation positions. The matrix has its rows
corresponding to validation positions and columns corresponding to samples of labels.
</p>
</li>
<li><p> a list called <code>probability</code> that contains predictive samples of probabilities for each class from the DGP emulator at validation positions. The element in the list
is a matrix that has its rows corresponding to validation positions and columns corresponding to samples of probabilities.
</p>
</li>
<li><p> a scalar called <code>log_loss</code> that represents the average log loss of the predicted labels in the DGP emulator across all validation positions. Log loss measures the
accuracy of probabilistic predictions, with lower values indicating better classification performance. <code>log_loss</code> ranges from <code>0</code> to positive infinity, where a
value closer to <code>0</code> suggests more confident and accurate predictions.
</p>
</li>
<li><p> an integer called <code>M</code> that contains size of the conditioning set used for the Vecchia approximation, if used, in emulator validation.
</p>
</li>
<li><p> an integer called <code>sample_size</code> that contains the number of samples used for validation.
</p>
</li></ul>

</li>
<li><p> If <code>object</code> is an instance of the <code>lgp</code> class, an updated <code>object</code> is returned with an additional slot called <code>oos</code> (for OOS validation) that contains:
</p>

<ul>
<li><p> two slots called <code>x_test</code> and <code>y_test</code> that contain the validation data points for OOS.
</p>
</li>
<li><p> a list called <code>mean</code>, if <code>method = "mean_var"</code>, or <code>median</code>, if <code>method = "sampling"</code>, that contains the predictive means or medians of
the linked (D)GP emulator at validation positions.
</p>
</li>
<li><p> three lists called <code>std</code>, <code>lower</code>, and <code>upper</code> that contain the predictive standard deviations and credible intervals of
the linked (D)GP emulator at validation positions. If <code>method = "mean_var"</code>, the upper and lower bounds of a credible interval are two standard
deviations above and below the predictive mean. If <code>method = "sampling"</code>, the upper and lower bounds of a credible interval are 2.5th and 97.5th percentiles.
</p>
</li>
<li><p> a list called <code>rmse</code> that contains the root mean/median squared errors of the linked (D)GP emulator.
</p>
</li>
<li><p> a list called <code>nrmse</code> that contains the (max-min) normalized root mean/median squared errors of the linked (D)GP emulator. The max-min normalization
uses the maximum and minimum values of the validation outputs contained in <code>y_test</code>.
</p>
</li>
<li> <p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer called <code>M</code> that contains size of the conditioning set used for the Vecchia approximation, if used, in emulator validation.
</p>
</li>
<li><p> an integer called <code>sample_size</code> that contains the number of samples used for validation if <code>method = "sampling"</code>.
</p>
</li></ul>

<p>Each element in <code>mean</code>, <code>median</code>, <code>std</code>, <code>lower</code>, <code>upper</code>, <code>rmse</code>, and <code>nrmse</code> corresponds to a (D)GP emulator in the final layer of the linked (D)GP
emulator.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> When both <code>x_test</code> and <code>y_test</code> are <code>NULL</code>, LOO cross validation will be implemented. Otherwise, OOS validation will
be implemented. LOO validation is only applicable to a GP or DGP emulator (i.e., <code>object</code> is an instance of the <code>gp</code> or <code>dgp</code>
class). If a linked (D)GP emulator (i.e., <code>object</code> is an instance of the <code>lgp</code> class) is provided, <code>x_test</code> and <code>y_test</code> must
also be provided for OOS validation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), or lgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='vigf'>Locate the next design point for a (D)GP emulator or a bundle of (D)GP emulators using VIGF</h2><span id='topic+vigf'></span><span id='topic+vigf.gp'></span><span id='topic+vigf.dgp'></span><span id='topic+vigf.bundle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#updated"><img src="../help/figures/lifecycle-updated.svg" alt='[Updated]' /></a>
</p>
<p>This function searches from a candidate set to locate the next design point(s) to be added to a (D)GP emulator
or a bundle of (D)GP emulators using the Variance of Improvement for Global Fit (VIGF). For VIGF on GP emulators, see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vigf(object, ...)

## S3 method for class 'gp'
vigf(
  object,
  x_cand = NULL,
  n_start = 10,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  ...
)

## S3 method for class 'dgp'
vigf(
  object,
  x_cand = NULL,
  n_start = 10,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)

## S3 method for class 'bundle'
vigf(
  object,
  x_cand = NULL,
  n_start = 10,
  batch_size = 1,
  M = 50,
  workers = 1,
  limits = NULL,
  int = FALSE,
  aggregate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vigf_+3A_object">object</code></td>
<td>
<p>can be one of the following:
</p>

<ul>
<li><p> the S3 class <code>gp</code>.
</p>
</li>
<li><p> the S3 class <code>dgp</code>.
</p>
</li>
<li><p> the S3 class <code>bundle</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vigf_+3A_...">...</code></td>
<td>
<p>any arguments (with names different from those of arguments used in <code><a href="#topic+vigf">vigf()</a></code>) that are used by <code>aggregate</code>
can be passed here.</p>
</td></tr>
<tr><td><code id="vigf_+3A_x_cand">x_cand</code></td>
<td>
<p>a matrix (with each row being a design point and column being an input dimension) that gives a candidate set
from which the next design point(s) are determined. If <code>object</code> is an instance of the <code>bundle</code> class and <code>aggregate</code> is not supplied, <code>x_cand</code> can also be a list.
The list must have a length equal to the number of emulators in <code>object</code>, with each element being a matrix representing the candidate set for a corresponding
emulator in the bundle. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_n_start">n_start</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> an integer that gives the number of initial design points to be used to determine next design point(s). This argument
is only used when <code>x_cand</code> is <code>NULL</code>. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_batch_size">batch_size</code></td>
<td>
<p>an integer that gives the number of design points to be chosen.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_m">M</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> the size of the conditioning set for the Vecchia approximation in the criterion calculation. This argument is only used if the emulator <code>object</code>
was constructed under the Vecchia approximation. Defaults to <code>50</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_workers">workers</code></td>
<td>
<p>the number of processes to be used for design point selection. If set to <code>NULL</code>,
the number of processes is set to <code style="white-space: pre;">&#8288;max physical cores available %/% 2&#8288;</code>. Defaults to <code>1</code>. The argument does not currently support Windows machines when the <code>aggregate</code>
function is provided, due to the significant overhead caused by initializing the Python environment for each worker under spawning.</p>
</td></tr>
<tr><td><code id="vigf_+3A_limits">limits</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a two-column matrix that gives the ranges of each input dimension, or a vector of length two if there is only one input dimension.
If a vector is provided, it will be converted to a two-column row matrix. The rows of the matrix correspond to input dimensions, and its
first and second columns correspond to the minimum and maximum values of the input dimensions. This
argument is only used when <code>x_cand = NULL</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_int">int</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#new"><img src="../help/figures/lifecycle-new.svg" alt='[New]' /></a> a bool or a vector of bools that indicates if an input dimension is an integer type. If a single bool is given, it will be applied to
all input dimensions. If a vector is provided, it should have a length equal to the input dimensions and will be applied to individual
input dimensions. This argument is only used when <code>x_cand = NULL</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vigf_+3A_aggregate">aggregate</code></td>
<td>
<p>an R function that aggregates scores of the VIGF across different output dimensions (if <code>object</code> is an instance
of the <code>dgp</code> class) or across different emulators (if <code>object</code> is an instance of the <code>bundle</code> class). The function should be specified in the
following basic form:
</p>

<ul>
<li><p> the first argument is a matrix representing scores. The rows of the matrix correspond to different design points. The number of columns
of the matrix equals to:
</p>

<ul>
<li><p> the emulator output dimension if <code>object</code> is an instance of the <code>dgp</code> class; or
</p>
</li>
<li><p> the number of emulators contained in <code>object</code> if <code>object</code> is an instance of the <code>bundle</code> class.
</p>
</li></ul>

</li>
<li><p> the output should be a vector that gives aggregate scores at different design points.
</p>
</li></ul>

<p>Set to <code>NULL</code> to disable aggregation. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>


<ol>
<li><p> If <code>x_cand</code> is not <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a vector of length <code>batch_size</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code>.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a vector of length <code>batch_size * D</code> is returned, containing the positions
(row numbers) of the next design points from <code>x_cand</code> to be added to the DGP emulator.
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a matrix is returned with <code>batch_size</code> rows and a column for each emulator in
the bundle, containing the positions (row numbers) of the next design points from <code>x_cand</code> for individual emulators.
</p>
</li></ul>

</li>
<li><p> If <code>x_cand</code> is <code>NULL</code>:
</p>

<ul>
<li><p> When <code>object</code> is an instance of the <code>gp</code> class, a matrix with <code>batch_size</code> rows is returned, giving the next design points to be evaluated.
</p>
</li>
<li><p> When <code>object</code> is an instance of the <code>dgp</code> class, a matrix with <code>batch_size * D</code> rows is returned, where:
</p>

<ul>
<li> <p><code>D</code> is the number of output dimensions of the DGP emulator if no likelihood layer is included.
</p>
</li>
<li><p> For a DGP emulator with a <code>Hetero</code> or <code>NegBin</code> likelihood layer, <code>D = 2</code>.
</p>
</li>
<li><p> For a DGP emulator with a <code>Categorical</code> likelihood layer, <code>D = 1</code> for binary output or <code>D = K</code> for multi-class output with <code>K</code> classes.
</p>
</li></ul>

</li>
<li><p> When <code>object</code> is an instance of the <code>bundle</code> class, a list is returned with a length equal to the number of emulators in the bundle. Each
element of the list is a matrix with <code>batch_size</code> rows, where each row represents a design point to be added to the corresponding emulator.
</p>
</li></ul>

</li></ol>



<h3>Note</h3>

<p>The first column of the matrix supplied to the first argument of <code>aggregate</code> must correspond to the first output dimension of the DGP emulator
if <code>object</code> is an instance of the <code>dgp</code> class, and so on for subsequent columns and dimensions. If <code>object</code> is an instance of the <code>bundle</code> class,
the first column must correspond to the first emulator in the bundle, and so on for subsequent columns and emulators.
</p>


<h3>References</h3>

<p>Mohammadi, H., &amp; Challenor, P. (2022). Sequential adaptive design for emulating costly computer codes. <em>arXiv:2206.12113</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load packages and the Python env
library(lhs)
library(dgpsi)

# construct a 1D non-stationary function
f &lt;- function(x) {
 sin(30*((2*x-1)/2-0.4)^5)*cos(20*((2*x-1)/2-0.4))
}

# generate the initial design
X &lt;- maximinLHS(10,1)
Y &lt;- f(X)

# training a 2-layered DGP emulator with the global connection off
m &lt;- dgp(X, Y, connect = F)

# specify the input range
lim &lt;- c(0,1)

# locate the next design point using VIGF
X_new &lt;- vigf(m, limits = lim)

# obtain the corresponding output at the located design point
Y_new &lt;- f(X_new)

# combine the new input-output pair to the existing data
X &lt;- rbind(X, X_new)
Y &lt;- rbind(Y, Y_new)

# update the DGP emulator with the new input and output data and refit
m &lt;- update(m, X, Y, refit = TRUE)

# plot the LOO validation
plot(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='window'>Trim the sequence of hyperparameter estimates within a DGP emulator</h2><span id='topic+window'></span>

<h3>Description</h3>

<p>This function trims the sequence of hyperparameter estimates within a DGP emulator
generated during training.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window(object, start, end = NULL, thin = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="window_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>dgp</code>.</p>
</td></tr>
<tr><td><code id="window_+3A_start">start</code></td>
<td>
<p>the first iteration before which all iterations are trimmed from the sequence.</p>
</td></tr>
<tr><td><code id="window_+3A_end">end</code></td>
<td>
<p>the last iteration after which all iterations are trimmed from the sequence.
Set to <code>NULL</code> to keep all iterations after (including) <code>start</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="window_+3A_thin">thin</code></td>
<td>
<p>the interval between the <code>start</code> and <code>end</code> iterations to thin out the sequence.
Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>An updated <code>object</code> with a trimmed sequence of hyperparameters.
</p>


<h3>Note</h3>


<ul>
<li><p> This function is useful when a DGP emulator has been trained and one wants to trim
the sequence of hyperparameters estimated and to use the trimmed sequence to generate point estimates
of the DGP model parameters for prediction.
</p>
</li>
<li><p> The following slots:
</p>

<ul>
<li> <p><code>loo</code> and <code>oos</code> created by <code><a href="#topic+validate">validate()</a></code>; and
</p>
</li>
<li> <p><code>results</code> created by <code><a href="#topic+predict">predict()</a></code>
in <code>object</code> will be removed and not contained in the returned object.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See dgp() for an example.

## End(Not run)
</code></pre>

<hr>
<h2 id='write'>Save the constructed emulator</h2><span id='topic+write'></span>

<h3>Description</h3>

<p>This function saves the constructed emulator to a <code>.pkl</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write(object, pkl_file, light = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_+3A_object">object</code></td>
<td>
<p>an instance of the S3 class <code>gp</code>, <code>dgp</code>, <code>lgp</code>, or <code>bundle</code>.</p>
</td></tr>
<tr><td><code id="write_+3A_pkl_file">pkl_file</code></td>
<td>
<p>the path to and the name of the <code>.pkl</code> file to which
the emulator <code>object</code> is saved.</p>
</td></tr>
<tr><td><code id="write_+3A_light">light</code></td>
<td>
<p>a bool indicating if a light version of the constructed emulator
(that requires less disk space to store) will be saved. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See further examples and tutorials at <a href="https://mingdeyu.github.io/dgpsi-R/">https://mingdeyu.github.io/dgpsi-R/</a>.
</p>


<h3>Value</h3>

<p>No return value. <code>object</code> will be saved to a local <code>.pkl</code> file specified by <code>pkl_file</code>.
</p>


<h3>Note</h3>

<p>Since emulators built from the package are 'python' objects, <code><a href="base.html#topic+save">save()</a></code> from R will not work as it would for R objects. If <code>object</code>
was processed by <code><a href="#topic+set_vecchia">set_vecchia()</a></code> to add or remove the Vecchia approximation, <code>light</code> should be set to <code>FALSE</code> to ensure
reproducibility after the saved emulator is reloaded by <code><a href="#topic+read">read()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# See gp(), dgp(), lgp(), or pack() for an example.

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
