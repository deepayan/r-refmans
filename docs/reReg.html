<!DOCTYPE html><html><head><title>Help for package reReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#reReg-package'><p>reReg: Recurrent Event Regression</p></a></li>
<li><a href='#basebind'><p>Function used to combine baseline functions in one plot</p></a></li>
<li><a href='#plot.Recur'><p>Produce Event Plot or Mean Cumulative Function Plot</p></a></li>
<li><a href='#plot.reReg'><p>Plot the Baseline Cumulative Rate Function and the Baseline Cumulative Hazard Function</p></a></li>
<li><a href='#plotEvents'><p>Produce Event Plots</p></a></li>
<li><a href='#plotEvents.control'><p>Plot options for plotEvents</p></a></li>
<li><a href='#plotHaz'><p>Plot the Baseline Cumulative Hazard Function for the Terminal Time</p></a></li>
<li><a href='#plotRate'><p>Plotting the Baseline Cumulative Rate Function for the Recurrent Event Process</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reReg'><p>Fits Semiparametric Regression Models for Recurrent Event Data</p></a></li>
<li><a href='#reReg.control'><p>Package options for reReg</p></a></li>
<li><a href='#residuals.reReg'><p>Calculate Residuals for a &lsquo;reReg&rsquo; Fit</p></a></li>
<li><a href='#reSurv'><p>Create an <code>reSurv</code> Object</p></a></li>
<li><a href='#simDat'><p>Simulated dataset for demonstration</p></a></li>
<li><a href='#simGSC'><p>Function to generate simulated recurrent event data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Recurrent Event Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive collection of practical and easy-to-use tools for regression analysis of recurrent events, with or without the presence of a (possibly) informative terminal event described in Chiou et al. (2023) &lt;<a href="https://doi.org/10.18637%2Fjss.v105.i05">doi:10.18637/jss.v105.i05</a>&gt;. The modeling framework is based on a joint frailty scale-change model, that includes models described in Wang et al. (2001) &lt;<a href="https://doi.org/10.1198%2F016214501753209031">doi:10.1198/016214501753209031</a>&gt;, Huang and Wang (2004) &lt;<a href="https://doi.org/10.1198%2F016214504000001033">doi:10.1198/016214504000001033</a>&gt;, Xu et al. (2017) &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1173557">doi:10.1080/01621459.2016.1173557</a>&gt;, and Xu et al. (2019) &lt;<a href="https://doi.org/10.5705%2FSS.202018.0224">doi:10.5705/SS.202018.0224</a>&gt; as special cases. The implemented estimating procedure does not require any parametric assumption on the frailty distribution. The package also allows the users to specify different model forms for both the recurrent event process and the terminal event. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stc04003/reReg">https://github.com/stc04003/reReg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stc04003/reReg/issues">https://github.com/stc04003/reReg/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>BB, nleqslv, dfoptim, optimx, SQUAREM, survival, directlabels,
ggplot2, MASS, methods, reda (&ge; 0.5.0), scam, Rcpp, rootSolve</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 23:03:14 UTC; chiou</td>
</tr>
<tr>
<td>Author:</td>
<td>Sy Han (Steven) Chiou [aut, cre],
  Chiung-Yu Huang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sy Han (Steven) Chiou &lt;schiou@smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='reReg-package'>reReg: Recurrent Event Regression</h2><span id='topic+reReg-package'></span><span id='topic+_PACKAGE'></span><span id='topic+reReg-packages'></span>

<h3>Description</h3>

<p>The package offers a comprehensive collection of practical and easy-to-use tools for analyzing
recurrent event data, with or without the presence of a (possibly) correlated terminal event.
The modeling framework is based on a joint frailty scale-change model,
that encompasses many existing models, including the popular Cox-type models,
as special cases and accommodates informative censoring through a subject-specific frailty.
The implemented estimating procedure does not require any parametric assumption on the frailty
distribution.
The package allows the users to specify different model forms for both the recurrent event process
and the terminal event.
The package also includes tools for visualization of recurrent events and
simulation from the regression models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sy Han (Steven) Chiou <a href="mailto:schiou@smu.edu">schiou@smu.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Chiung-Yu  Huang <a href="mailto:ChiungYu.Huang@ucsf.edu">ChiungYu.Huang@ucsf.edu</a>
</p>
</li></ul>



<h3>References</h3>

<p>Chiou, S.H., Xu, G., Yan, J. and Huang, C.-Y. (2023). Regression Modeling for Recurrent Events Possibly with an Informative Terminal Event Using R Package reReg.
<em>Journal of Statistical Software</em>, <b>105</b>(5): 1&ndash;34.
</p>
<p>Lin, D., Wei, L., Yang, I. and Ying, Z. (2000). Semiparametric Regression for the Mean and Rate Functions of Recurrent Events.
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, <b>62</b>: 711&ndash;730.
</p>
<p>Wang, M.-C., Qin, J., and Chiang, C.-T. (2001). Analyzing Recurrent Event Data with Informative Censoring.
<em>Journal of the American Statistical Association</em>, <b>96</b>(455): 1057&ndash;1065.
</p>
<p>Ghosh, D. and Lin, D.Y. (2002). Marginal Regression Models for Recurrent and Terminal Events. <em>Statistica Sinica</em>: 663&ndash;688.
</p>
<p>Ghosh, D. and Lin, D.Y. (2003). Semiparametric Analysis of Recurrent Events Data in the Presence of Dependent Censoring.
<em>Biometrics</em>, <b>59</b>: 877&ndash;885.
</p>
<p>Huang, C.-Y. and Wang, M.-C. (2004). Joint Modeling and Estimation for Recurrent Event Processes and Failure Time Data.
<em>Journal of the American Statistical Association</em>, <b>99</b>(468): 1153&ndash;1165.
</p>
<p>Xu, G., Chiou, S.H., Huang, C.-Y., Wang, M.-C. and Yan, J. (2017).
Joint Scale-change Models for Recurrent Events and Failure Time.
<em>Journal of the American Statistical Association</em>, <b>112</b>(518): 796&ndash;805.
</p>
<p>Xu, G., Chiou, S.H., Yan, J., Marr, K., and Huang, C.-Y. (2019). Generalized Scale-Change Models for Recurrent Event
Processes under Informative Censoring. <em>Statistica Sinica</em>, <b>30</b>: 1773&ndash;1795.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stc04003/reReg">https://github.com/stc04003/reReg</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stc04003/reReg/issues">https://github.com/stc04003/reReg/issues</a>
</p>
</li></ul>


<hr>
<h2 id='basebind'>Function used to combine baseline functions in one plot</h2><span id='topic+basebind'></span>

<h3>Description</h3>

<p>Combine different plots into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basebind(..., legend.title, legend.labels, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basebind_+3A_...">...</code></td>
<td>
<p><code>ggplot</code> objects created by plotting <code>reReg</code> objects.</p>
</td></tr>
<tr><td><code id="basebind_+3A_legend.title">legend.title</code></td>
<td>
<p>an optional character string to specify the legend title.</p>
</td></tr>
<tr><td><code id="basebind_+3A_legend.labels">legend.labels</code></td>
<td>
<p>an optional character string to specify the legend labels.</p>
</td></tr>
<tr><td><code id="basebind_+3A_control">control</code></td>
<td>
<p>a list of control parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
fm &lt;- Recur(t.stop, id, event, status) ~ x1 + x2
fit1 &lt;- reReg(fm, subset = x1 == 0, data = simDat, B = 200)
fit2 &lt;- reReg(fm, subset = x1 == 1, data = simDat, B = 200)
basebind(plot(fit1), plot(fit2))
</code></pre>

<hr>
<h2 id='plot.Recur'>Produce Event Plot or Mean Cumulative Function Plot</h2><span id='topic+plot.Recur'></span>

<h3>Description</h3>

<p>Plot the event plot or the mean cumulative function (MCF) from an <code>Recur</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Recur'
plot(
  x,
  mcf = FALSE,
  event.result = c("increasing", "decreasing", "asis"),
  event.calendarTime = FALSE,
  mcf.adjustRiskset = TRUE,
  mcf.conf.int = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Recur_+3A_x">x</code></td>
<td>
<p>an object of class <code>Recur</code> returned by the <code>Recur()</code> function.
See <code>?Recur</code> for creating <code>Recur</code> objects.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_mcf">mcf</code></td>
<td>
<p>an optional logical value indicating whether the mean cumulative function (MCF) will
be plotted instead of the event plot. When <code>mcf = TRUE</code>,
the <code>mcf</code> is internally called. See <code><a href="#topic+mcf">mcf</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_event.result">event.result</code></td>
<td>
<p>an optional character string that is passed to the
<code>plotEvents()</code> function as the <code>result</code> argument. See <code><a href="#topic+plotEvents">plotEvents</a></code>.
This argument is used to specify whether the event plot is sorted by the subjects' terminal time.
The available options are
</p>

<dl>
<dt><code>increasing</code></dt><dd><p>sort the terminal time from in ascending order (default).
This places longer terminal times on top. </p>
</dd>
<dt><code>decreasing</code></dt><dd><p>sort the terminal time from in descending order.
This places shorter terminal times on top. </p>
</dd>
<dt><code>none</code></dt><dd><p>present the event plots as is, without sorting by the terminal times.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.Recur_+3A_event.calendartime">event.calendarTime</code></td>
<td>
<p>an optional logical value indicating whether to plot in calendar time.
When <code>event.calendarTime = FALSE</code> (default),
the event plot will have patient time on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_mcf.adjustriskset">mcf.adjustRiskset</code></td>
<td>
<p>an optional logical value that is passed to
the <code>mcf()</code> function as the <code>adjustRiskset</code> argument. 
This argument indicates whether risk set size will be adjusted.
If <code>mcf.adjustRiskset = TRUE</code>, subjects leave the risk set after terminal times
as in the Nelson-Aalen estimator.
If <code>mcf.adjustRiskset = FALSE</code>, subjects remain in the risk set after terminal time.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_mcf.conf.int">mcf.conf.int</code></td>
<td>
<p>an optional logical value that is passed to
the <code>mcf()</code> function as the <code>conf.int</code> argument. See <code><a href="#topic+mcf">mcf</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plot.Recur_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>control</code> consists of options with argument defaults to a list with
the following values:
</p>

<dl>
<dt>xlab</dt><dd><p>customizable x-label, default value is &quot;Time&quot;.</p>
</dd>
<dt>ylab</dt><dd><p>customizable y-label, default value is &quot;Subject&quot; for event plot and
&quot;Cumulative mean&quot; for MCF plot.</p>
</dd>
<dt>main</dt><dd><p>customizable title, the default value is &quot;Recurrent event plot&quot;
when <code>mcf = FALSE</code> and
&quot;Sample cumulative mean function plot&quot; when <code>mcf = TRUE</code>.</p>
</dd>
<dt>terminal.name</dt><dd><p>customizable label for terminal event,
the default value is &quot;Terminal event&quot;.</p>
</dd>
<dt>recurrent.name</dt><dd><p>customizable legend title for recurrent event,
the default value is &quot;Recurrent events&quot;.</p>
</dd>
<dt>recurrent.types</dt><dd><p>customizable label for recurrent event type,
the default value is <code>NULL</code>.</p>
</dd>
<dt>alpha</dt><dd><p>between 0 and 1, controls the transparency of points.</p>
</dd>
</dl>

<p>The <code>xlab</code>, <code>ylab</code> and <code>main</code> parameters can be specified
outside of the <code>control</code> list.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>References</h3>

<p>Nelson, W. B. (1995) Confidence Limits for Recurrence Data-Applied to Cost
or Number of Product Repairs. <em>Technometrics</em>, <b>37</b>(2): 147&ndash;157.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recur">Recur</a></code>, <code><a href="#topic+plotEvents">plotEvents</a></code>, <code><a href="#topic+mcf">mcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
reObj &lt;- with(simDat, Recur(t.start %to% t.stop, id, event, status))

## Event plots:
plot(reObj)
plot(reObj, event.result = "decreasing")

## With (hypothetical) multiple event types
simDat$event2 &lt;- with(simDat, ifelse(t.stop &gt; 10 &amp; event &gt; 0, 2, event))
reObj2 &lt;- with(simDat, Recur(t.start %to% t.stop, id, event2, status))
plot(reObj2)

## With (hypothetical) calendar times
simDat2 &lt;- simDat
simDat2$t.start &lt;- as.Date(simDat2$t.start + simDat2$x2 * 5, origin = "20-01-01")
simDat2$t.stop &lt;- as.Date(simDat2$t.stop + simDat2$x2 * 5, origin = "20-01-01")
reObj3 &lt;- with(simDat2, Recur(t.start %to% t.stop, id, event, status))
plot(reObj3, event.calendarTime = TRUE)

## MCF plots
plot(reObj, mcf = TRUE)
plot(reObj, mcf = TRUE, mcf.adjustRiskset = FALSE)



library(reReg)
data(simDat)
reObj &lt;- with(simDat, Recur(t.start %to% t.stop, id, event, status))
summary(reObj)
</code></pre>

<hr>
<h2 id='plot.reReg'>Plot the Baseline Cumulative Rate Function and the Baseline Cumulative Hazard Function</h2><span id='topic+plot.reReg'></span>

<h3>Description</h3>

<p>Plot the baseline cumulative rate function and the baseline cumulative hazard function
(if applicable) for an <code>reReg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reReg'
plot(
  x,
  baseline = c("both", "rate", "hazard"),
  smooth = FALSE,
  newdata = NULL,
  frailty = NULL,
  showName = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.reReg_+3A_x">x</code></td>
<td>
<p>an object of class <code>reReg</code>, returned by the <code>reReg</code> function.</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_baseline">baseline</code></td>
<td>
<p>a character string specifying which baseline function to plot.
</p>

<dl>
<dt><code>baseline = "both"</code></dt><dd><p>plot both the baseline cumulative rate and
the baseline cumulative hazard function (if applicable) in separate panels
within the same display (default).</p>
</dd>
<dt><code>baseline = "rate"</code></dt><dd><p>plot the baseline cumulative rate function.</p>
</dd>
<dt><code>baseline = "hazard"</code></dt><dd><p>plot the baseline cumulative hazard function.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.reReg_+3A_smooth">smooth</code></td>
<td>
<p>an optional logical value indicating whether to add a smooth curve
obtained from a monotone increasing P-splines implemented in package <code>scam</code>.</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame contains variables to include in the calculation
of the cumulative rate function.
If omitted, the baseline rate function will be plotted.</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_frailty">frailty</code></td>
<td>
<p>an optional vector to specify the shared frailty for <code>newdata</code>.
If <code>newdata</code> is given and <code>frailty</code> is not specified, the</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_showname">showName</code></td>
<td>
<p>an optional logical value indicating whether to label the curves
when <code>newdata</code> is specified.</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plot.reReg_+3A_...">...</code></td>
<td>
<p>additional graphical parameters to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>control</code> consists of options with argument defaults to a list
with the following values:
</p>

<dl>
<dt>xlab</dt><dd><p>customizable x-label, default value is &quot;Time&quot;.</p>
</dd>
<dt>ylab</dt><dd><p>customizable y-label, default value is empty.</p>
</dd>
<dt>main</dt><dd><p>customizable title, default value are &quot;Baseline cumulative rate and
hazard function&quot; when <code>baseline = "both"</code>,
&quot;Baseline cumulative rate function&quot; when <code>baseline = "rate"</code>,
and &quot;Baseline cumulative hazard function&quot; when <code>baseline = "hazard"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reReg">reReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
fm &lt;- Recur(t.start %to% t.stop, id, event, status) ~ x1 + x2

fit &lt;- reReg(fm, data = simDat, B = 0)
plot(fit)
plot(fit, xlab = "Time (days)", smooth = TRUE)

## Predicted cumulative rate and hazard given covariates
newdata &lt;- expand.grid(x1 = 0:1, x2 = mean(simDat$x2))
plot(fit, newdata = newdata, showName = TRUE)
</code></pre>

<hr>
<h2 id='plotEvents'>Produce Event Plots</h2><span id='topic+plotEvents'></span>

<h3>Description</h3>

<p>Plot the event plot for an <code>Recur</code> object.
The usage of the function is similar to that of <code>plot.Recur()</code> but with more flexible options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEvents(
  formula,
  data,
  result = c("increasing", "decreasing", "asis"),
  calendarTime = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEvents_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a &quot;~&quot; operator,
and the predictors on the right.
The response must be a recurrent event survival object as returned by function <code>Recur()</code>.</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables occurring in
the &quot;<code>formula</code>&quot;.</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_result">result</code></td>
<td>
<p>an optional character string specifying whether the event plot is
sorted by the subjects' terminal time. The available options are
</p>

<dl>
<dt><code>increasing</code></dt><dd><p>sort the terminal time from in ascending order (default).
This places longer terminal times on top. </p>
</dd>
<dt><code>decreasing</code></dt><dd><p>sort the terminal time from in descending order.
This places shorter terminal times on top. </p>
</dd>
<dt><code>none</code></dt><dd><p>present the event plots as is, without sorting by the terminal times.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotEvents_+3A_calendartime">calendarTime</code></td>
<td>
<p>an optional logical value indicating whether to plot in calendar time.
When <code>calendarTime = FALSE</code> (default), the event plot will have patient time on the x-axis.</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plotEvents_+3A_...">...</code></td>
<td>
<p>graphical parameters to be passed to methods.
These include <code>xlab</code>, <code>ylab</code>, <code>main</code>, and more. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>control</code> consists of options with argument defaults to a list with
the following values:
</p>

<dl>
<dt>xlab</dt><dd><p>customizable x-label, default value is &quot;Time&quot;.</p>
</dd>
<dt>ylab</dt><dd><p>customizable y-label, default value is &quot;Subject&quot; for event plot and
&quot;Cumulative mean&quot; for MCF plot.</p>
</dd>
<dt>main</dt><dd><p>customizable title, the default value is &quot;Recurrent event plot&quot;
when <code>mcf = FALSE</code> and
&quot;Sample cumulative mean function plot&quot; when <code>mcf = TRUE</code>.</p>
</dd>
<dt>terminal.name</dt><dd><p>customizable label for terminal event,
the default value is &quot;Terminal event&quot;.</p>
</dd>
<dt>recurrent.name</dt><dd><p>customizable legend title for recurrent event,
the default value is &quot;Recurrent events&quot;.</p>
</dd>
<dt>recurrent.types</dt><dd><p>customizable label for recurrent event type,
the default value is <code>NULL</code>.</p>
</dd>
<dt>alpha</dt><dd><p>between 0 and 1, controls the transparency of points.</p>
</dd>
</dl>

<p>The <code>xlab</code>, <code>ylab</code> and <code>main</code> parameters can be specified
outside of the <code>control</code> list.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recur">Recur</a></code>, <code><a href="#topic+plot.Recur">plot.Recur</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
plotEvents(Recur(t.start %to% t.stop, id, event, status) ~ 1, data = simDat,
           xlab = "Time in days", ylab = "Subjects arranged by terminal time")

## Separate plots by x1
plotEvents(Recur(t.start %to% t.stop, id, event, status) ~ x1, data = simDat)

## For multiple recurrent events
simDat$x3 &lt;- ifelse(simDat$x2 &lt; 0, "x2 &lt; 0", "x2 &gt; 0")
simDat$event &lt;- simDat$event * sample(1:3, nrow(simDat), TRUE)
plotEvents(Recur(t.start %to% t.stop, id, event, status) ~ x1 + x3, data = simDat)
</code></pre>

<hr>
<h2 id='plotEvents.control'>Plot options for plotEvents</h2><span id='topic+plotEvents.control'></span>

<h3>Description</h3>

<p>This function provides the plotting options for the <code>plotEvents()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEvents.control(
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  terminal.name = NULL,
  recurrent.name = NULL,
  recurrent.type = NULL,
  legend.position = NULL,
  base_size = 12,
  cex = NULL,
  alpha = 0.7,
  width = NULL,
  bar.color = NULL,
  recurrent.color = NULL,
  recurrent.shape = NULL,
  recurrent.stroke = NULL,
  terminal.color = NULL,
  terminal.shape = NULL,
  terminal.stroke = NULL,
  not.terminal.color = NULL,
  not.terminal.shape = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEvents.control_+3A_xlab">xlab</code></td>
<td>
<p>a character string indicating the label for the x axis.
The default value is &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_ylab">ylab</code></td>
<td>
<p>a character string indicating the label for the y axis.
The default value is &quot;Subject&quot;.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_main">main</code></td>
<td>
<p>a character string indicating the title of the plot.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_terminal.name">terminal.name</code></td>
<td>
<p>a character string indicating the label for the terminal event
displayed in the legend. The default value is &quot;Terminal event&quot;.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_recurrent.name">recurrent.name</code></td>
<td>
<p>a character string indicating the label for the recurrent event
displayed in the legend. The default value is &quot;Recurrent events&quot;.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_recurrent.type">recurrent.type</code></td>
<td>
<p>a factor indicating the labels for the different recurrent event types.
This option is only available when there are more than one types of recurrent events.
The default value is &quot;Recurrent events 1&quot;, &quot;Recurrent events 2&quot;, ....</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_legend.position">legend.position</code></td>
<td>
<p>a character string specifies the position of the legend.
The available options are &quot;none&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot;, &quot;top&quot;,
&quot;bottomright&quot;, &quot;bottomleft&quot;,&quot;topleft&quot;, &quot;topright&quot;,
or a two-element numeric vector specifies the coordinate of the legend.
The legend is placed inside of the plotting region when
<code>legend.position</code> is specified as one of
&quot;bottomright&quot;, &quot;bottomleft&quot;,&quot;topleft&quot;, &quot;topright&quot;.
Otherwise, the argument is passed to the <code>ggplot</code> theme environment.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_base_size">base_size</code></td>
<td>
<p>a numerical value to specify the base font size, given in pts.
This argument is passed to the <code>ggplot</code> theme environment.
The default value is 12.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_cex">cex</code></td>
<td>
<p>a numerical value specifies the size of the points.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_alpha">alpha</code></td>
<td>
<p>a numerical value specifies the transparency of the points.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_width">width</code></td>
<td>
<p>a numerical value specifies the width of the event plot.
By <code>ggplot</code> default, set to 90% of the resolution of the data.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_bar.color">bar.color</code></td>
<td>
<p>a numerical value or a character string specifies
color for lines. Default to gray.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_recurrent.color">recurrent.color</code></td>
<td>
<p>a numerical value or a character string
specifies color for recurrent events. Default to green.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_recurrent.shape">recurrent.shape</code></td>
<td>
<p>a numerical value or a character string
specifies shape for recurrent events. Default to circle.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_recurrent.stroke">recurrent.stroke</code></td>
<td>
<p>a numerical value or a character string
specifies stroke for recurrent events. Default to circle.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_terminal.color">terminal.color</code></td>
<td>
<p>a numerical value or a character string
specifies color for terminal events. Default to red.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_terminal.shape">terminal.shape</code></td>
<td>
<p>a numerical value or a character string
specifies shape for terminal events. Default to triangle.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_terminal.stroke">terminal.stroke</code></td>
<td>
<p>a numerical value or a character string
specifies stroke for terminal events. Default to triangle.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_not.terminal.color">not.terminal.color</code></td>
<td>
<p>a numerical value or a character string
specifies color for non-terminal events.
Non-terminal events are not plotted at default.</p>
</td></tr>
<tr><td><code id="plotEvents.control_+3A_not.terminal.shape">not.terminal.shape</code></td>
<td>
<p>a numerical value or a character string
specifies shape for terminal events.
Non-terminal events are not plotted at default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plotEvents">plotEvents</a></code>
</p>

<hr>
<h2 id='plotHaz'>Plot the Baseline Cumulative Hazard Function for the Terminal Time</h2><span id='topic+plotHaz'></span>

<h3>Description</h3>

<p>Plot the baseline cumulative hazard function for an <code>reReg</code> object.
The 95% confidence interval on the baseline cumulative rate function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHaz(
  x,
  newdata = NULL,
  frailty = NULL,
  showName = FALSE,
  type = c("unrestricted", "bounded", "scaled"),
  smooth = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHaz_+3A_x">x</code></td>
<td>
<p>an object of class <code>reReg</code>, returned by the <code>reReg</code> function.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame contains variables to include in the calculation
of the cumulative rate function.
If omitted, the baseline rate function will be plotted.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_frailty">frailty</code></td>
<td>
<p>an optional vector to specify the shared frailty for <code>newdata</code>.
If <code>newdata</code> is given and <code>frailty</code> is not specified, the</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_showname">showName</code></td>
<td>
<p>an optional logical value indicating whether to label the curves
when <code>newdata</code> is specified.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of rate function to be plotted.
Options are &quot;unrestricted&quot;, &quot;scaled&quot;, &quot;bounded&quot;. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_smooth">smooth</code></td>
<td>
<p>an optional logical value indicating whether to add a smooth curve
obtained from a monotone increasing P-splines implemented in package <code>scam</code>.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_control">control</code></td>
<td>
<p>a list of control parameters.</p>
</td></tr>
<tr><td><code id="plotHaz_+3A_...">...</code></td>
<td>
<p>graphical parameters to be passed to methods.
These include <code>xlab</code>, <code>ylab</code>, <code>main</code>, and more. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>control</code> consists of options with argument
defaults to a list with the following values:
</p>

<dl>
<dt>xlab</dt><dd><p>customizable x-label, default value is &quot;Time&quot;.</p>
</dd>
<dt>ylab</dt><dd><p>customizable y-label, default value is empty.</p>
</dd>
<dt>main</dt><dd><p>customizable title, default value is &quot;Baseline cumulative hazard function&quot;.</p>
</dd>
</dl>

<p>These arguments can also be passed down without specifying a <code>control</code> list.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reReg">reReg</a></code> <code><a href="#topic+plot.reReg">plot.reReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
fm &lt;- Recur(t.start %to% t.stop, id, event, status) ~ x1 + x2

fit &lt;- reReg(fm, data = simDat, model = "cox|cox", B = 0)
## Plot both the baseline cumulative rate and hazard function
plot(fit)
## Plot baseline cumulative hazard function
plotHaz(fit)
plotHaz(fit, smooth = TRUE)
</code></pre>

<hr>
<h2 id='plotRate'>Plotting the Baseline Cumulative Rate Function for the Recurrent Event Process</h2><span id='topic+plotRate'></span>

<h3>Description</h3>

<p>Plot the baseline cumulative rate function for an <code>reReg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRate(
  x,
  newdata = NULL,
  frailty = NULL,
  showName = FALSE,
  type = c("unrestricted", "bounded", "scaled"),
  smooth = FALSE,
  control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRate_+3A_x">x</code></td>
<td>
<p>an object of class <code>reReg</code>, usually returned by the <code>reReg</code> function.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame contains variables to include in the calculation
of the cumulative rate function.
If omitted, the baseline rate function will be plotted.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_frailty">frailty</code></td>
<td>
<p>an optional vector to specify the shared frailty for <code>newdata</code>.
If <code>newdata</code> is given and <code>frailty</code> is not specified, the</p>
</td></tr>
<tr><td><code id="plotRate_+3A_showname">showName</code></td>
<td>
<p>an optional logical value indicating whether to label the curves
when <code>newdata</code> is specified.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of rate function to be plotted.
Options are &quot;unrestricted&quot;, &quot;scaled&quot;, &quot;bounded&quot;. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_smooth">smooth</code></td>
<td>
<p>an optional logical value indicating whether to add a smooth curve
obtained from a monotone increasing P-splines implemented in package <code>scam</code>.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_control">control</code></td>
<td>
<p>a list of control parameters.</p>
</td></tr>
<tr><td><code id="plotRate_+3A_...">...</code></td>
<td>
<p>graphical parameters to be passed to methods.
These include <code>xlab</code>, <code>ylab</code>, <code>main</code>, and more. See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plotRate()</code> plots the estimated baseline cumulative rate function 
depending on the identifiability assumption.
When <code>type = "unrestricted"</code> (default), the baseline cumulative rate function
is plotted under the assumption <code class="reqn">E(Z) = 1</code>.
When <code>type = "scaled"</code>, the baseline cumulative rate function is plotted
under the assumption <code class="reqn">\Lambda(\min(Y^\ast, \tau)) = 1</code>.
When <code>type = "bounded"</code>, the baseline cumulative rate function is plotted
under the assumption <code class="reqn">\Lambda(\tau) = 1</code>.
See <code>?reReg</code> for the specification of the notations and underlying models.
</p>
<p>The argument <code>control</code> consists of options with argument defaults
to a list with the following values:
</p>

<dl>
<dt>xlab</dt><dd><p>customizable x-label, default value is &quot;Time&quot;.</p>
</dd>
<dt>ylab</dt><dd><p>customizable y-label, default value is empty.</p>
</dd>
<dt>main</dt><dd><p>customizable title, default value is &quot;Baseline cumulative rate function&quot;.</p>
</dd>
</dl>

<p>These arguments can also be specified outside of the <code>control</code> list.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reReg">reReg</a></code> <code><a href="#topic+plot.reReg">plot.reReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)
fm &lt;- Recur(t.start %to% t.stop, id, event, status) ~ x1 + x2
fit &lt;- reReg(fm, data = simDat, model = "cox|cox", B = 0)
## Plot both the baseline cumulative rate and hazard function
plot(fit)
## Plot baseline cumulative rate function
plotRate(fit)
plotRate(fit, smooth = TRUE)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Recur'></span><span id='topic+is.Recur'></span><span id='topic+check_Recur'></span><span id='topic++25to+25'></span><span id='topic++252+25'></span><span id='topic+mcf'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>reda</dt><dd><p><code><a href="reda.html#topic+Recur-to">%2%</a></code>, <code><a href="reda.html#topic+Recur-to">%to%</a></code>, <code><a href="reda.html#topic+check_Recur">check_Recur</a></code>, <code><a href="reda.html#topic+is.Recur">is.Recur</a></code>, <code><a href="reda.html#topic+mcf">mcf</a></code>, <code><a href="reda.html#topic+Recur">Recur</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reReg'>Fits Semiparametric Regression Models for Recurrent Event Data</h2><span id='topic+reReg'></span>

<h3>Description</h3>

<p>Fits a general (joint) semiparametric regression model for the recurrent event data,
where the rate function of the underlying recurrent event process and
the hazard function of the terminal event can be specified as a Cox-type model,
an accelerated mean model, an accelerated rate model, or a generalized scale-change model.
See details for model specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reReg(
  formula,
  data,
  subset,
  model = "cox",
  B = 0,
  se = c("boot", "sand"),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reReg_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a &quot;~&quot; operator,
and the predictors on the right.
The response must be a recurrent event survival object as returned by function <code>Recur</code>.</p>
</td></tr>
<tr><td><code id="reReg_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the variables occurring
in the <code>"formula"</code>.</p>
</td></tr>
<tr><td><code id="reReg_+3A_subset">subset</code></td>
<td>
<p>an optional logical vector specifying a subset of observations to be used
in the fitting process.</p>
</td></tr>
<tr><td><code id="reReg_+3A_model">model</code></td>
<td>
<p>a character string specifying the underlying model.
The available functional form for the rate function and the hazard function include a Cox-type model,
an accelerated mean model, an accelerated rate model, or a generalized scale-change model,
and can be specified via &quot;cox&quot;, &quot;am&quot;, &quot;ar&quot;, or &quot;gsc&quot;, respectively.
The rate function and hazard function separated by &quot;<code>|</code>&quot;.
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="reReg_+3A_b">B</code></td>
<td>
<p>a numeric value specifies the number of bootstraps for variance estimation.
When <code>B = 0</code>, variance estimation will not be performed.</p>
</td></tr>
<tr><td><code id="reReg_+3A_se">se</code></td>
<td>
<p>a character string specifying the method for the variance estimation. See <b>Details</b>.
</p>

<dl>
<dt><code>boot</code></dt><dd><p> nonparametric bootstrap approach</p>
</dd>
<dt><code>sand</code></dt><dd><p> resampling-based sandwich estimator</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reReg_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See <code><a href="#topic+reReg.control">reReg.control</a></code> for default values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Model specification:</b>
</p>
<p>Suppose the recurrent event process and the failure events are
observed in the time interval <code class="reqn">t\in[0,\tau]</code>,
for some constant <code class="reqn">\tau</code>.
We formulate the recurrent event rate function, <code class="reqn">\lambda(t)</code>,
and the terminal event hazard function, <code class="reqn">h(t)</code>, 
in the form of
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = Z \lambda_0(te^{X^\top\alpha}) e^{X^\top\beta}, h(t) = Z h_0(te^{X^\top\eta})e^{X^\top\theta},</code>
</p>

<p>where <code class="reqn">\lambda_0(t)</code> is the baseline rate function,
<code class="reqn">h_0(t)</code> is the baseline hazard function,
<code class="reqn">X</code> is a <code class="reqn">n</code> by <code class="reqn">p</code> covariate matrix and <code class="reqn">\alpha</code>,
<code class="reqn">Z</code> is an unobserved shared frailty variable, and
<code class="reqn">(\alpha, \eta)</code> and <code class="reqn">(\beta, \theta)</code> correspond to the shape and size parameters,
respectively.
The model includes several popular semiparametric models as special cases,
which can be specified via the <code>model</code> argument with the rate function
and the hazard function separated by &quot;<code>|</code>&quot;.
For examples,
Wang, Qin and Chiang (2001) (<code class="reqn">\alpha = \eta = \theta = 0</code>)
can be called with <code>model = "cox"</code>;
Huang and Wang (2004) (<code class="reqn">\alpha = \eta = 0</code>)
can be called with <code>model = "cox|cox"</code>;
Xu et al. (2017) (<code class="reqn">\alpha = \beta</code> and <code class="reqn">\eta = \theta</code>)
can be called with <code>model = "am|am"</code>;
Xu et al. (2019) (<code class="reqn">\eta = \theta = 0</code>) can be called with <code>model = "gsc"</code>.
Users can mix the models depending on the application. For example,
<code>model = "cox|ar"</code> postulate a Cox proportional model for the
recurrent event rate function and an accelerated rate model for
the terminal event hazard function (<code class="reqn">\alpha = \theta = 0</code>).
If only one model is specified without an &quot;<code>|</code>&quot;,
it is used for both the rate function and the hazard function.
For example, specifying <code>model = "cox"</code> is equivalent to <code>model = "cox|cox"</code>.
Some models that assumes <code>Z = 1</code> and requires independent
censoring are also implemented in <code>reReg</code>;
these includes <code>model = "cox.LWYY"</code> for Lin et al. (2000),
<code>model = "cox.GL"</code> for Ghosh and Lin (2002),
and <code>model = "am.GL"</code> for Ghosh and Lin (2003).
Additionally, an improved estimation of the proportional rate model
(Huang and Huang 2022) can be called by <code>model = "cox.HH"</code> with
additional <code>control</code> options to specify the underlying procedure.
See <a href="https://www.sychiou.com/reReg/articles/reReg-reg.html">online vignette</a>
for a detailed discussion of the implemented regression models.
</p>
<p><b>Variance estimation:</b>
</p>
<p>The available methods for variance estimation are:
</p>

<dl>
<dt>boot</dt><dd><p>performs nonparametric bootstrap.</p>
</dd>
<dt>sand</dt><dd><p>performs the efficient resampling-based variance estimation.</p>
</dd>
</dl>

<p><b>Improving proportional rate model:</b>
A common semiparametric regression model for recurrent event process
under the noninformative censoring assumption is the Cox-type proportional rate model
(available in <code>reReg()</code> via <code>model = "cox.LWYY"</code>).
However, the construction of the pseudo-partial score function ignores the
dependency among recurrent events and thus could be inefficient. 
To improve upon this popular method, Huang and Huang (2022) proposed to combine
a system of weighted pseudo-partial score equations via the generalized method of moments (GMM)
and empirical likelihood (EL) estimation.
The proposed GMM and EL procedures are available in <code>reReg</code> via <code>model = "cox.HH"</code>
with additional control specifications.
See <a href="https://www.sychiou.com/reReg/articles/reReg-cppl.html">online vignette</a>
for an illustration of this feature.
</p>
<p><b>Control options:</b>
</p>
<p>The <code>control</code> list consists of the following parameters:
</p>

<dl>
<dt>tol</dt><dd><p>absolute error tolerance.</p>
</dd>
<dt>init</dt><dd><p>a list contains initial guesses used for root search.</p>
</dd>
<dt>solver</dt><dd><p>the equation solver used for root search.
The available options are <code>BB::BBsolve</code>, <code>BB::dfsane</code>, <code>BB::BBoptim</code>, 
<code>optimx::optimr</code>, <code>dfoptim::hjk</code>, <code>dfoptim::mads</code>, <code>optim</code>,
and <code>nleqslv::nleqslv</code>.</p>
</dd>
<dt>eqType</dt><dd><p>a character string indicating whether the log-rank type estimating equation or
the Gehan-type estimating equation (when available) will be used. </p>
</dd>
<dt>boot.parallel</dt><dd><p>an logical value indicating whether parallel computation
will be applied when <code>se = "boot"</code> is called.</p>
</dd>
<dt>boot.parCl</dt><dd><p>an integer value specifying the number of CPU cores to be used when
<code>parallel = TRUE</code>. The default value is half the CPU cores on the current host.</p>
</dd>
<dt>cppl</dt><dd><p>A character string indicating either to improve the proportional rate model via
the generalized method of moments (<code>cppl = "GMM"</code>) or empirical likelihood estimation (<code>cppl = "EL"</code>).
This option is only used when <code>model = "cox.HH"</code>.</p>
</dd>
<dt>cppl.wfun</dt><dd><p>A list of (up to two) weight functions to be combined with the weighted pseudo-partial likelihood scores.
Available options are <code>"Gehan"</code> and <code>"cumbase"</code>,
which correspond to the Gehan's weight and the cumulative baseline hazard function, respectively.
Alternatively, the weight functions can be specified with function formulas.
This option is only used when <code>model = "cox.HH"</code>.</p>
</dd>
<dt>trace</dt><dd><p>A logical variable denoting whether some of the
intermediate results of iterations should be displayed to the user.  Default is <code>FALSE</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chiou, S.H., Xu, G., Yan, J. and Huang, C.-Y. (2023). Regression Modeling for Recurrent Events Possibly with an Informative Terminal Event Using R Package reReg.
<em>Journal of Statistical Software</em>, <b>105</b>(5): 1&ndash;34.
</p>
<p>Lin, D., Wei, L., Yang, I. and Ying, Z. (2000). Semiparametric Regression for the Mean and Rate Functions of Recurrent Events.
<em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, <b>62</b>: 711&ndash;730.
</p>
<p>Wang, M.-C., Qin, J., and Chiang, C.-T. (2001). Analyzing Recurrent Event Data with Informative Censoring.
<em>Journal of the American Statistical Association</em>, <b>96</b>(455): 1057&ndash;1065.
</p>
<p>Ghosh, D. and Lin, D.Y. (2002). Marginal Regression Models for Recurrent and Terminal Events. <em>Statistica Sinica</em>: 663&ndash;688.
</p>
<p>Ghosh, D. and Lin, D.Y. (2003). Semiparametric Analysis of Recurrent Events Data in the Presence of Dependent Censoring.
<em>Biometrics</em>, <b>59</b>: 877&ndash;885.
</p>
<p>Huang, C.-Y. and Wang, M.-C. (2004). Joint Modeling and Estimation for Recurrent Event Processes and Failure Time Data.
<em>Journal of the American Statistical Association</em>, <b>99</b>(468): 1153&ndash;1165.
</p>
<p>Xu, G., Chiou, S.H., Huang, C.-Y., Wang, M.-C. and Yan, J. (2017). Joint Scale-change Models for Recurrent Events and Failure Time.
<em>Journal of the American Statistical Association</em>, <b>112</b>(518): 796&ndash;805.
</p>
<p>Xu, G., Chiou, S.H., Yan, J., Marr, K., and Huang, C.-Y. (2019). Generalized Scale-Change Models for Recurrent Event
Processes under Informative Censoring. <em>Statistica Sinica</em>, <b>30</b>: 1773&ndash;1795.
</p>
<p>Huang, M.-Y. and Huang, C.-Y. (2022). Improved semiparametric estimation of the proportional rate model with recurrent event data.
<em>In revision</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recur">Recur</a></code>, <code><a href="#topic+simGSC">simGSC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simDat)

## Nonparametric estimate
plot(reReg(Recur(t.start %to% t.stop, id, event, status) ~ 1, data = simDat, B = 50))

fm &lt;- Recur(t.start %to% t.stop, id, event, status) ~ x1 + x2
## Fit the Cox rate model
summary(reReg(fm, data = simDat, model = "cox", B = 50))
## Fit the joint Cox/Cox model
summary(reReg(fm, data = simDat, model = "cox|cox", B = 50))
## Fit the scale-change rate model
summary(reReg(fm, data = simDat, model = "gsc", B = 50, se = "sand"))
</code></pre>

<hr>
<h2 id='reReg.control'>Package options for reReg</h2><span id='topic+reReg.control'></span>

<h3>Description</h3>

<p>This function provides the fitting options for the <code>reReg()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reReg.control(
  eqType = c("logrank", "gehan", "gehan_s"),
  solver = c("BB::dfsane", "BB::BBsolve", "BB::BBoptim", "optimx::optimr",
    "dfoptim::hjk", "dfoptim::mads", "optim", "nleqslv::nleqslv"),
  tol = 1e-07,
  cppl = NULL,
  cppl.wfun = list(NULL, NULL),
  init = list(alpha = 0, beta = 0, eta = 0, theta = 0),
  boot.parallel = FALSE,
  boot.parCl = NULL,
  maxit1 = 100,
  maxit2 = 10,
  trace = FALSE,
  numAdj = 1e-07
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reReg.control_+3A_eqtype">eqType</code></td>
<td>
<p>a character string indicating whether the log-rank type estimating equation
or the Gehan-type estimating equation (when available) will be used.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_solver">solver</code></td>
<td>
<p>a character string specifying the equation solver to be used for root search.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_tol">tol</code></td>
<td>
<p>a positive numerical value specifying the absolute error tolerance in root search.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_cppl">cppl</code></td>
<td>
<p>a character string indicating either to improve the proportional rate model via
the generalized method of moments (<code>cppl = "GMM"</code>) or empirical likelihood estimation (<code>cppl = "EL"</code>).
This option is only used when <code>model = "cox.HH"</code>.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_cppl.wfun">cppl.wfun</code></td>
<td>
<p>a list of (up to two) weight functions to be combined with the weighted pseudo-partial likelihood scores.
Available options are <code>"Gehan"</code> and <code>"cumbase"</code>,
which correspond to the Gehan's weight and the cumulative baseline hazard function, respectively.
Alternatively, the weight functions can be specified with function formulas.
This option is only used when <code>model = "cox.HH"</code>.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_init">init</code></td>
<td>
<p>a list contains the initial guesses used for root search.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_boot.parallel">boot.parallel</code></td>
<td>
<p>an logical value indicating whether parallel computation will be
applied when <code>se = "boot"</code> is specified in <code>reReg()</code>.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_boot.parcl">boot.parCl</code></td>
<td>
<p>an integer value specifying the number of CPU cores to be used when
<code>parallel = TRUE</code>. The default value is half the CPU cores on the current host.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_maxit1">maxit1</code>, <code id="reReg.control_+3A_maxit2">maxit2</code></td>
<td>
<p>max number of iteration used when <code>model = "cox.HH"</code>.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_trace">trace</code></td>
<td>
<p>a logical variable denoting whether some of the
intermediate results of iterations should be displayed to the user.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="reReg.control_+3A_numadj">numAdj</code></td>
<td>
<p>a positive numerical value specifying the small constant used in heuristic adjustment of the borrow strength method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+reReg">reReg</a></code>
</p>

<hr>
<h2 id='residuals.reReg'>Calculate Residuals for a &lsquo;reReg&rsquo; Fit</h2><span id='topic+residuals.reReg'></span>

<h3>Description</h3>

<p>Calculates residuals for a joint frailty scale-change model fitted by 'reReg'.
Under the recurrent event model, at each observation time, <code class="reqn">t</code>,
the residual is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\mbox{observed number of recurrent events at } t- 
\mbox{expected number of recurrent events at} t.</code>
</p>

<p>The expected number of recurrent events at <code class="reqn">t</code> is calculated by the
cumulative rate function at <code class="reqn">t</code>.
Under the failure time model, the residual is calculated as
</p>
<p style="text-align: center;"><code class="reqn">\Delta - H(t),</code>
</p>

<p>where <code class="reqn">\Delta</code> is the terminal event indicator and
<code class="reqn">H(t)</code> is the cumulative hazard function at <code class="reqn">t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'reReg'
residuals(object, model = c("recurrent", "failure"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.reReg_+3A_object">object</code></td>
<td>
<p>an object of class <code>reReg</code> returned by the <code>reReg()</code> function.</p>
</td></tr>
<tr><td><code id="residuals.reReg_+3A_model">model</code></td>
<td>
<p>a character string specifying whether the residuals will be calculated
under the recurrent event model or the failure time model.</p>
</td></tr>
<tr><td><code id="residuals.reReg_+3A_...">...</code></td>
<td>
<p>additional parameters for future development.</p>
</td></tr>
</table>

<hr>
<h2 id='reSurv'>Create an <code>reSurv</code> Object</h2><span id='topic+reSurv'></span>

<h3>Description</h3>

<p>Create a recurrent event survival object, used as a response variable in <code>reReg</code>.
This function is deprecated in Version 1.1.6.
A recurrent event object is now being created with <code>Recur()</code>.
See '?Recur()' for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reSurv(time1, time2, id, event, status, origin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reSurv_+3A_time1">time1</code></td>
<td>
<p>when &quot;<code>time2</code>&quot; is provided, this vector is treated as the starting time for the gap time between two successive recurrent events.
In the absence of &quot;<code>time2</code>&quot;, this is the observation time of recurrence on calendar time scale, in which, the time corresponds to the time since entry/inclusion in the study.</p>
</td></tr>
<tr><td><code id="reSurv_+3A_time2">time2</code></td>
<td>
<p>an optional vector for ending time for the gap time between two successive recurrent events.</p>
</td></tr>
<tr><td><code id="reSurv_+3A_id">id</code></td>
<td>
<p>subject's id.</p>
</td></tr>
<tr><td><code id="reSurv_+3A_event">event</code></td>
<td>
<p>a binary vector used as the recurrent event indicator. <code>event = 1</code> for recurrent times.</p>
</td></tr>
<tr><td><code id="reSurv_+3A_status">status</code></td>
<td>
<p>a binary vector used as the status indicator for the terminal event. <code>status = 0</code> for censored times.</p>
</td></tr>
<tr><td><code id="reSurv_+3A_origin">origin</code></td>
<td>
<p>a numerical vector indicating the time origin of subjects.
When <code>origin</code> is a scalar, <code>reSurv</code> assumes all subjects have the same origin.
Otherwise, <code>origin</code> needs to be a numerical vector, with length equals to the number of subjects.
In this case, each element corresponds to different origins for different subjects.
This argument is only needed when &quot;<code>time2</code>&quot; is missing.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(simDat)
  ## being deprecated in Verson 1.1.7
  with(dat, reSurv(Time, id, event, status))
  ## Use Recur() instead
  with(dat, Recur(Time, id, event, status))

## End(Not run)

</code></pre>

<hr>
<h2 id='simDat'>Simulated dataset for demonstration</h2><span id='topic+simDat'></span>

<h3>Description</h3>

<p>A simulated data frame with the following variables
</p>

<dl>
<dt>id</dt><dd><p>subjects identification</p>
</dd>
<dt>t.start</dt><dd><p>start of the interval</p>
</dd>
<dt>t.stop</dt><dd><p>endpoint of the interval; when time origin is 0 this variable also marks the recurrence or terminal/censoring time</p>
</dd>
<dt>status</dt><dd><p>terminal event indicator; 1 if a terminal event is recorded</p>
</dd>
<dt>event</dt><dd><p>recurrent event indicator; 1 if a recurrent event is recorded</p>
</dd>
<dt>x1</dt><dd><p>baseline covariate generated from a standard uniform distribution</p>
</dd>
<dt>x2</dt><dd><p>baseline covariate generated from a standard uniform distribution (independent from <code>z1</code></p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(simDat)
</code></pre>


<h3>Format</h3>

<p>A data frame with 874 rows and 7 variables.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+simGSC">simGSC</a></code> for instruction on simulating recurrent event data from
scale-change models.
</p>

<hr>
<h2 id='simGSC'>Function to generate simulated recurrent event data</h2><span id='topic+simGSC'></span>

<h3>Description</h3>

<p>The function <code>simGSC()</code> generates simulated recurrent event data from either
a Cox-type model, an accelerated mean model, an accelerated rate model, or a generalized scale-change model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simGSC(
  n,
  summary = FALSE,
  para,
  xmat,
  censoring,
  frailty,
  tau,
  origin,
  Lam0,
  Haz0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simGSC_+3A_n">n</code></td>
<td>
<p>number of observation.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_summary">summary</code></td>
<td>
<p>a logical value indicating whether a brief data summary will be printed.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_para">para</code></td>
<td>
<p>a list of numerical vectors for the regression coefficients
in the joint scale-change model. 
The names of the list elements are <code>alpha</code>, <code>beta</code>, <code>eta</code>, and
<code>theta</code>, correspond to <code class="reqn">\alpha</code>, <code class="reqn">\beta</code>, <code class="reqn">\eta</code>, and <code class="reqn">\theta</code>
in the joint scale-change model, respectively.
See <b>Details</b> for <code><a href="#topic+reReg">reReg</a></code>.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_xmat">xmat</code></td>
<td>
<p>an optional matrix specifying the design matrix.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_censoring">censoring</code></td>
<td>
<p>a numeric variable specifying the censoring times for each of the
<code class="reqn">n</code> observation.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_frailty">frailty</code></td>
<td>
<p>a numeric variable specifying the frailty variable.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_tau">tau</code></td>
<td>
<p>a numeric value specifying the maximum observation time.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_origin">origin</code></td>
<td>
<p>a numeric value specifying the time origin.</p>
</td></tr>
<tr><td><code id="simGSC_+3A_lam0">Lam0</code></td>
<td>
<p>is an optional function that specifies the baseline cumulative rate function.
When left-unspecified, the recurrent events are generated using the
baseline rate function of </p>
<p style="text-align: center;"><code class="reqn">\lambda_0(t) = \frac{2}{1 + t},</code>
</p>
<p> or equivalently,
the cumulative rate function of </p>
<p style="text-align: center;"><code class="reqn">\Lambda_0(t) = 2\log(1 + t).</code>
</p>
</td></tr>
<tr><td><code id="simGSC_+3A_haz0">Haz0</code></td>
<td>
<p>is an optional function that specifies the baseline hazard function.
When left-unspecified, the recurrent events are generated using the baseline hazard function
</p>
<p style="text-align: center;"><code class="reqn">h_0(t) = \frac{1}{5(1 + t)},</code>
</p>
<p> or equivalently,
the cumulative hazard function of </p>
<p style="text-align: center;"><code class="reqn">H_0(t) = \log(1 + t) / 5.</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simGSC()</code> generates simulated recurrent event data over
the interval <code class="reqn">(0, \tau)</code> based on the specification of the recurrent process and
the terminal events.
Specifically, the rate function, <code class="reqn">\lambda(t)</code>, of the recurrent process
can be specified as one of the following model:
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = Z \lambda_0(te^{X^\top\alpha}) e^{X^\top\beta}, h(t) = Z h_0(te^{X^\top\eta})e^{X^\top\theta}, </code>
</p>

<p>where <code class="reqn">\lambda_0(t)</code> is the baseline rate function,
<code class="reqn">h_0(t)</code> is the baseline hazard function,
<code class="reqn">X</code> is a <code class="reqn">n</code> by <code class="reqn">p</code> covariate matrix and <code class="reqn">\alpha</code>,
<code class="reqn">Z</code> is an unobserved shared frailty variable, and
<code class="reqn">(\alpha, \eta)</code> and <code class="reqn">(\beta, \theta)</code> correspond to the shape and size parameters of the
rate function and the hazard function, respectively.
</p>
<p>Under the default settings, the <code>simGSC()</code> function assumes <code class="reqn">p = 2</code>
and the regression parameters to be <code class="reqn">\alpha = \eta = (0, 0)^\top</code>,
and <code class="reqn">\beta = \theta = (1, 1)^\top</code>.
When the <code>xmat</code> argument is not specified, the <code>simGSC()</code> function
assumes <code class="reqn">X_i</code> is a two-dimensional vector <code class="reqn">X_i = (X_{i1}, X_{i2}), i = 1, \ldots, n</code>,
where <code class="reqn">X_{i1}</code> is a Bernoulli variable with rate 0.5 and
<code class="reqn">X_{i2}</code> is a standard normal variable.
With the default <code>xmat</code>, the censoring time $C$ is generated from
an exponential distribution with mean <code class="reqn">\tau X_{i1} + Z^2\tau(1 - X_{i1})</code>.
Thus, the censoring distribution is covariate dependent and
is informative when <code class="reqn">Z</code> is not a constant.
When the <code>frailty</code> argument is not specified, the frailty variable <code class="reqn">Z</code> is generated
from a gamma distribution with a unit mean and a variance of 0.25.
The default values for <code>tau</code> and <code>origin</code> are 60 and 0, respectively.
When arguments <code>Lam0</code> and <code>Haz0</code> are left unspecified,
the <code>simGSC()</code> function uses <code class="reqn">\Lambda_0(t) = 2\log(1 + t)</code>
and <code class="reqn">H_0(t) = \log(1 + t) / 5</code>, respectively.
This is equivalent to setting
<code>Lam0 = function(x) 2 * log(1 + x)</code> and <code>Haz0 = function(x) log(1 + x) / 5</code>.
Overall, the default specifications generate the recurrent events and the terminal events
from the model:
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = \displaystyle \frac{2Z}{1 + te^{-X_{i1} - X_{i2}}},
h(t) = \displaystyle \frac{Z}{5(1 + te^{X_{i1} + X_{i2}})},  t\in[0, 60].</code>
</p>

<p>See <a href="https://www.sychiou.com/reReg/articles/reReg-sims.html">online vignette</a>
for more examples.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reReg">reReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
simGSC(100, summary = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
