<!DOCTYPE html><html><head><title>Help for package HTSSIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HTSSIP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HTSSIP'><p>HTSSIP: analyzing high throughput sequence data from nucleotide stable isotope probing experiments</p></a></li>
<li><a href='#as.Num'><p>conversion to numeric</p></a></li>
<li><a href='#BD_shift'><p>Assessing the magnitude of BD shifts with 16S rRNA community</p>
data by calculating the beta diversity between unlabeled control
and labeled treatment gradient fraction communities.</a></li>
<li><a href='#calc_atom_excess'><p>Calculate atom fraction excess</p></a></li>
<li><a href='#calc_Gi'><p>Calculate G+C from unlabeled buoyant density</p></a></li>
<li><a href='#calc_Mheavymax'><p>Calculate the theoretical maximum molecular weight of fully-labeled DNA</p></a></li>
<li><a href='#data-physeq_rep3'><p>(Data) A simulated HTS-SIP dataset</p></a></li>
<li><a href='#data-physeq_rep3_qPCR'><p>(Data) qPCR data associated with the physeq_rep3 HTS-SIP dataset</p></a></li>
<li><a href='#data-physeq_S2D1'><p>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=1)</p></a></li>
<li><a href='#data-physeq_S2D1_l'><p>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=1)</p></a></li>
<li><a href='#data-physeq_S2D2'><p>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=2)</p></a></li>
<li><a href='#data-physeq_S2D2_l'><p>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=2)</p></a></li>
<li><a href='#delta_BD'><p>delta_BD calculation</p></a></li>
<li><a href='#DESeq2_l2fc'><p>Calculating log2 fold change for HTS-SIP data.</p></a></li>
<li><a href='#evaluate_matches'><p>Evaluate String Interpolation Matches</p></a></li>
<li><a href='#expr_param_extract'><p>Extract all quoted values in the expression used for phyloseq subsetting.</p></a></li>
<li><a href='#extract_expressions'><p>Extract Expression Objects from String Interpolation Matches</p></a></li>
<li><a href='#extract_formats'><p>Extract String Interpolation Formats from Matched Placeholders</p></a></li>
<li><a href='#filter_l2fc'><p>Filter l2fc table</p></a></li>
<li><a href='#format_metadata'><p>Format phyloseq metadata for calculating BD range overlaps.</p></a></li>
<li><a href='#fraction_overlap'><p>Calculate the BD range overlap of gradient fractions</p></a></li>
<li><a href='#get_treatment_params'><p>Get parameters for subsetting the phyloseq dataset</p></a></li>
<li><a href='#gradient_sim'><p>Simulate HTS-SIP communities for 1 density gradient</p></a></li>
<li><a href='#heavy_SIP'><p>Heavy-SIP analysis</p></a></li>
<li><a href='#HRSIP'><p>(MW-)HR-SIP analysis</p></a></li>
<li><a href='#HTSSIP_sim'><p>Simulate a HTS-SIP dataset</p></a></li>
<li><a href='#match_brace'><p>Utility Function for Matching a Closing Brace</p></a></li>
<li><a href='#match_placeholders'><p>Match Expression Placeholders for String Interpolation</p></a></li>
<li><a href='#max_BD_range'><p>Adjusting BD range size if negative.</p></a></li>
<li><a href='#OTU_qPCR_trans'><p>Transform OTU counts based on qPCR data</p></a></li>
<li><a href='#overlap_wmean_dist'><p>Calculating weighted mean beta-diversities of overlapping gradient fractions.</p></a></li>
<li><a href='#parse_dist'><p>Filtering out non-relevant distances in distance matrix</p></a></li>
<li><a href='#perc_overlap'><p>Calculate the percent overlap between two ranges (x &amp; y).</p></a></li>
<li><a href='#phyloseq_list_ord_dfs'><p>Converting ordination objects to data.frames</p></a></li>
<li><a href='#phyloseq_ord_plot'><p>Plotting beta diversity ordination</p></a></li>
<li><a href='#phyloseq_subset'><p>Make a list of phyloseq object subsets</p></a></li>
<li><a href='#phyloseq2df'><p>phyloseq data object conversion to data.frame</p></a></li>
<li><a href='#phyloseq2table'><p>Phyloseq conversion to a ggplot-formatted table</p></a></li>
<li><a href='#physeq_format'><p>Checking format of phyloseq object for HTSSIP compatibility</p></a></li>
<li><a href='#physeq_list_betaDiv'><p>calculating beta diversity for a list of phyloseq objects</p></a></li>
<li><a href='#physeq_list_ord'><p>calculating ordinations from a list of distance matrices</p></a></li>
<li><a href='#qPCR_sim'><p>Simulate qPCR values</p></a></li>
<li><a href='#qSIP_atom_excess'><p>Calculate atom fraction excess using q-SIP method</p></a></li>
<li><a href='#qSIP_atom_excess_format'><p>Reformat a phyloseq object of qSIP_atom_excess analysis</p></a></li>
<li><a href='#qSIP_bootstrap'><p>Calculate bootstrap CI for atom fraction excess using q-SIP method</p></a></li>
<li><a href='#SIP_betaDiv_ord'><p>Calculating &amp; plotting beta diversity for a list of phyloseq objects</p></a></li>
<li><a href='#stringterpolate'><p>String Interpolation</p></a></li>
<li><a href='#tss'><p>Total sum scaling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Throughput Sequencing of Stable Isotope Probing Data
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Barnett &lt;seb369@cornell.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for analyzing high throughput sequencing 
    stable isotope probing (HTS-SIP) data.
    Analyses include high resolution stable isotope probing (HR-SIP),
    multi-window high resolution stable isotope probing (MW-HR-SIP), 
    and quantitative stable isotope probing (q-SIP). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph(&ge; 1.1.2), ape(&ge; 4.1), magrittr (&ge; 1.5), stringr (&ge;
1.2.0), plyr (&ge; 1.8.4), dplyr (&ge; 0.7.4), tidyr (&ge; 0.7.2),
ggplot2 (&ge; 2.2.1), vegan (&ge; 2.4.0), DESeq2 (&ge; 1.16.1),
phyloseq (&ge; 1.20.0), coenocliner (&ge; 0.2.2), lazyeval(&ge;
0.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, doParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-13 20:09:39 UTC; sambarnett</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Youngblut [aut],
  Samuel Barnett [cre, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-13 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='HTSSIP'>HTSSIP: analyzing high throughput sequence data from nucleotide stable isotope probing experiments</h2><span id='topic+HTSSIP'></span><span id='topic+HTSSIP-package'></span>

<h3>Description</h3>

<p>HTSSIP provides a toolset for reproducibly analyzing HTS-SIP data.
HTS-SIP data is the combination of nucleotide stable isotope probing (DNA- &amp; RNA-SIP)
and high throughput sequence data (e.g., MiSeq of 16S rRNA amplicons).
</p>


<h3>Details</h3>

<p>To learn more about HTSSIP, start with the vignettes:
<code>browseVignettes(package = "HTSSIP")</code>
</p>

<hr>
<h2 id='as.Num'>conversion to numeric</h2><span id='topic+as.Num'></span>

<h3>Description</h3>

<p>Conducts conversion: as.character &ndash;&gt; as.numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Num(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Num_+3A_x">x</code></td>
<td>
<p>single value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='BD_shift'>Assessing the magnitude of BD shifts with 16S rRNA community
data by calculating the beta diversity between unlabeled control
and labeled treatment gradient fraction communities.</h2><span id='topic+BD_shift'></span>

<h3>Description</h3>

<p>This function is meant to compare 16S rRNA sequence communities
of gradient fractions from 2 gradients: a labeled
treatment (eg., 13C-labeled DNA) and its corresponding unlabeled
control. First, the beta-diversity (e.g, weighted-Unifrac) is calculated
pairwise between fraction communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BD_shift(physeq, method = "unifrac", weighted = TRUE, fast = TRUE,
  normalized = FALSE, ex = "Substrate=='12C-Con'",
  perm_method = c("control", "treatment", "overlap", "adjacent"),
  nperm = 100, a = 0.1, parallel_perm = FALSE,
  parallel_dist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BD_shift_+3A_physeq">physeq</code></td>
<td>
<p>phyloseq object</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_method">method</code></td>
<td>
<p>See phyloseq::distance</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_weighted">weighted</code></td>
<td>
<p>Weighted Unifrac (if calculating Unifrac)</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_fast">fast</code></td>
<td>
<p>Fast calculation method</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_normalized">normalized</code></td>
<td>
<p>Normalized abundances</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_ex">ex</code></td>
<td>
<p>Expression for selecting controls based on metadata</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_perm_method">perm_method</code></td>
<td>
<p>&quot;BD shift window&quot; permutation method. See description.</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_nperm">nperm</code></td>
<td>
<p>Number of bootstrap permutations</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_a">a</code></td>
<td>
<p>The alpha for calculating confidence intervals</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_parallel_perm">parallel_perm</code></td>
<td>
<p>Calculate bootstrap permutations in parallel</p>
</td></tr>
<tr><td><code id="BD_shift_+3A_parallel_dist">parallel_dist</code></td>
<td>
<p>Calculate beta-diveristy distances in parallel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sample_data table of the user-provided phyloseq object
MUST contain the buoyant density (BD) of each sample
(a &quot;Buoyant_density&quot; column in the sample_data table).
The BD information is used to identify overlapping gradient fractions
(gradient fractions usually only partially overlap in BD between gradients)
between the labeled treatment gradient and the control gradient.
Beta diversity between overlapping fractions is calculated. Then,
to standardize the values relative to the unlabeled control
(1 beta-diversity value for each control gradient fraction), the
mean beta diversity of overlapping labeled treatment gradients is
calculated for each unlabeled control, and the percent overlap of
each labeled treatment fraction is used to weight the mean.
</p>
<p>A permutation test is used to determine &quot;BD shift windows&quot;.
OTU abundances are permuted, and beta-diversity is calculated.
The permutations are used to calculate confidence intervals.
The possible permutation methods are:
</p>

<ul>
<li><p>&quot;control&quot; = 
OTU abundances are permuted among all control samples,
and these new samples are used as a null treatment.
Thus, this provides a baseline beta-diversity distribution
that would result from comparing the control fractions to
a randomly shuffled version of themselves.

</p>
</li>
<li><p>&quot;treatment&quot; = 
OTU abundances are permuted among all treatment samples.
Thus, a &quot;homogenized&quot; treatment gradient null model.

</p>
</li>
<li><p>&quot;overlap&quot; = 
OTU abundances are permuted among overlapping control &amp; treatment fractions.
Thus, is beta-diversity higher than if the overlapping treatment &amp; control
samples were homogenized. This method tends to be too permisive.

</p>
</li>
<li><p>&quot;adjacent&quot; = 
The null &quot;treatment&quot; communities are generated by permuting OTU abundances
among adjacent control fractions. Thus, null model is local gradient region
was homogenized.

</p>
</li></ul>



<h3>Value</h3>

<p>a data.frame object of weighted mean distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2)
## Not run: 
# Subsetting phyloseq by Substrate and Day
params = get_treatment_params(physeq_S2D2, c('Substrate', 'Day'))
params = dplyr::filter(params, Substrate!='12C-Con')
ex = "(Substrate=='12C-Con' &amp; Day=='${Day}') | (Substrate=='${Substrate}' &amp; Day == '${Day}')"
physeq_S2D2_l = phyloseq_subset(physeq_S2D2, params, ex)

# Calculating BD_shift on 1 subset (use lapply function to process full list)
wmean1 = BD_shift(physeq_S2D2_l[[1]], nperm=5)

ggplot(wmean1, aes(BD_min.x, wmean_dist)) +
   geom_point()

# Calculating BD_shift on all subsets; using just 5 permutations to speed up analysis
lapply(physeq_S2D2_l, BD_shift, nperm=5)

## End(Not run)

</code></pre>

<hr>
<h2 id='calc_atom_excess'>Calculate atom fraction excess</h2><span id='topic+calc_atom_excess'></span>

<h3>Description</h3>

<p>See Hungate et al., 2015 for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_atom_excess(Mlab, Mlight, Mheavymax, isotope = "13C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_atom_excess_+3A_mlab">Mlab</code></td>
<td>
<p>The molecular wight of labeled DNA</p>
</td></tr>
<tr><td><code id="calc_atom_excess_+3A_mlight">Mlight</code></td>
<td>
<p>The molecular wight of unlabeled DNA</p>
</td></tr>
<tr><td><code id="calc_atom_excess_+3A_mheavymax">Mheavymax</code></td>
<td>
<p>The theoretical maximum molecular weight of fully-labeled DNA</p>
</td></tr>
<tr><td><code id="calc_atom_excess_+3A_isotope">isotope</code></td>
<td>
<p>The isotope for which the DNA is labeled with ('13C' or '18O')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value: atom fraction excess (A)
</p>

<hr>
<h2 id='calc_Gi'>Calculate G+C from unlabeled buoyant density</h2><span id='topic+calc_Gi'></span>

<h3>Description</h3>

<p>See Hungate et al., 2015 for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Gi(Wlight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Gi_+3A_wlight">Wlight</code></td>
<td>
<p>A vector with &gt;=1 weighted mean BD from
'light' gradient fractions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value (fractional G+C; Gi)
</p>

<hr>
<h2 id='calc_Mheavymax'>Calculate the theoretical maximum molecular weight of fully-labeled DNA</h2><span id='topic+calc_Mheavymax'></span>

<h3>Description</h3>

<p>See Hungate et al., 2015 for more details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Mheavymax(Mlight, isotope = "13C", Gi = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Mheavymax_+3A_mlight">Mlight</code></td>
<td>
<p>The molecular wight of unlabeled DNA</p>
</td></tr>
<tr><td><code id="calc_Mheavymax_+3A_isotope">isotope</code></td>
<td>
<p>The isotope for which the DNA is labeled with ('13C' or '18O')</p>
</td></tr>
<tr><td><code id="calc_Mheavymax_+3A_gi">Gi</code></td>
<td>
<p>The G+C content of unlabeled DNA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value: maximum molecular weight of fully-labeled DNA
</p>

<hr>
<h2 id='data-physeq_rep3'>(Data) A simulated HTS-SIP dataset</h2><span id='topic+data-physeq_rep3'></span><span id='topic+physeq_rep3'></span>

<h3>Description</h3>

<p>6 gradients:
</p>

<ul>
<li><p>*12C-control, replicate 1
</p>
</li>
<li><p>*12C-control, replicate 2
</p>
</li>
<li><p>*12C-control, replicate 3
</p>
</li>
<li><p>*13C-treatment, replicate 1
</p>
</li>
<li><p>*13C-treatment, replicate 2
</p>
</li>
<li><p>*13C-treatment, replicate 3
</p>
</li></ul>


<hr>
<h2 id='data-physeq_rep3_qPCR'>(Data) qPCR data associated with the physeq_rep3 HTS-SIP dataset</h2><span id='topic+data-physeq_rep3_qPCR'></span><span id='topic+physeq_rep3_qPCR'></span>

<h3>Description</h3>

<p>The dataset contains simulated 16S rRNA copies for each gradient
fraction of each gradient (measured via qPCR).
</p>


<h3>See Also</h3>

<p><code>physeq_rep3</code>
</p>

<hr>
<h2 id='data-physeq_S2D1'>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=1)</h2><span id='topic+data-physeq_S2D1'></span><span id='topic+physeq_S2D1'></span>

<h3>Description</h3>

<p>1 of the 2 'substrates' is the 12C-control;
the other is the 13C-labeled substrate
</p>

<hr>
<h2 id='data-physeq_S2D1_l'>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=1)</h2><span id='topic+data-physeq_S2D1_l'></span><span id='topic+physeq_S2D1_l'></span>

<h3>Description</h3>

<p>1 of the 2 'substrates' is the 12C-control;
the other is the 13C-labeled substrate.
</p>


<h3>Details</h3>

<p>The dataset has been parsed into a list of corresponding
13C-treatment vs 12C-control comparisons. Each comparison
is of all gradient fraction samples of the treatment vs
the gradient fraction samples of the control.
</p>

<hr>
<h2 id='data-physeq_S2D2'>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=2)</h2><span id='topic+data-physeq_S2D2'></span><span id='topic+physeq_S2D2'></span>

<h3>Description</h3>

<p>1 of the 2 'substrates' is the 12C-control;
the other is the 13C-labeled substrate.
</p>

<hr>
<h2 id='data-physeq_S2D2_l'>(Data) A subset of full HTS-SIP dataset (Substrates=2, Days=2)</h2><span id='topic+data-physeq_S2D2_l'></span><span id='topic+physeq_S2D2_l'></span>

<h3>Description</h3>

<p>1 of the 2 'substrates' is the 12C-control;
the other is the 13C-labeled substrate.
</p>


<h3>Details</h3>

<p>The dataset has been parsed into a list of corresponding
13C-treatment vs 12C-control comparisons. Each comparison
is of all gradient fraction samples of the treatment vs
the gradient fraction samples of the control.
</p>

<hr>
<h2 id='delta_BD'>delta_BD calculation</h2><span id='topic+delta_BD'></span>

<h3>Description</h3>

<p>Calculate delta_BD as described in
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC4867679/">Pepe-Ranney et al., 2016</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_BD(physeq, control_expr, n = 20, BD_min = NULL, BD_max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_BD_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="delta_BD_+3A_control_expr">control_expr</code></td>
<td>
<p>An expression for identifying unlabeled control
samples in the phyloseq object (eg., &quot;Substrate=='12C-Con'&quot;)</p>
</td></tr>
<tr><td><code id="delta_BD_+3A_n">n</code></td>
<td>
<p>How many evenly-spaced buoyant density values to use for linear
interpolation of abundances.</p>
</td></tr>
<tr><td><code id="delta_BD_+3A_bd_min">BD_min</code></td>
<td>
<p>The minimum BD value of the BD range used for OTU abundance interpolation.
If NULL, then BD_min will be the minimum of all BD values in the phyloseq object.</p>
</td></tr>
<tr><td><code id="delta_BD_+3A_bd_max">BD_max</code></td>
<td>
<p>The maximum BD value of the BD range used for OTU abundance interpolation.
If NULL, then BD_max will be the maximum of all BD values in the phyloseq object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, the abundance of each OTU is interpolated at specific BD values in order to
have abundance values at consistent points across gradients (gradient fraction BDs
normally vary from gradient to gradient). The center of mass (CM) is calculcated from these
interpolated values, which is the weighted mean BD with interpolated OTU abundances
used as weights (ie., where in the density gradient contains the 'center' of the OTU
abundance distribution). Delta_BD is then calculated by substracting the CM for the
unlabeled control gradient from the labeled treatment gradient.
</p>
<p>The delta_BD calculation will be a comparison between unlabled control and labeled
treatment samples. These samples are distinguished from each other with the
'control_expr' parameter. NOTE: if multiple gradients fall into the control or
treatment category, they will be treated as one gradient (which may be OK if
you want to combine replicate gradients).
</p>
<p>NaN values may occur due low abundances.
</p>
<p>The BD range used for interpolation is set by the min/max of all buoyant density
values in the phyloseq object (standardize across).
</p>


<h3>Value</h3>

<p>data.frame with delta_BD values for each OTU. 'CM' stands for 'center of mass'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
# just selecting 1 treatment-control comparison
physeq = physeq_S2D2_l[[1]]

## Not run: 
# calculating delta_BD
df = delta_BD(physeq, control_expr='Substrate=="12C-Con"')
head(df)

# In this example, the replicate gradients will be combined for treatments/controls
data(physeq_rep3)
df = delta_BD(physeq_rep3, control_expr='Treatment=="12C-Con"')
head(df)

## End(Not run)

</code></pre>

<hr>
<h2 id='DESeq2_l2fc'>Calculating log2 fold change for HTS-SIP data.</h2><span id='topic+DESeq2_l2fc'></span>

<h3>Description</h3>

<p>The phyloseq object will be filtered to 1) just OTUs
that pass the sparsity cutoff 2) just samples in the user-defined
'heavy' fractions. The log2 fold change (l2fc) is calculated
between labeled treatment and control gradients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DESeq2_l2fc(physeq, density_min, density_max, design,
  l2fc_threshold = 0.25, sparsity_threshold = 0.25,
  sparsity_apply = "all", size_factors = "geoMean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DESeq2_l2fc_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_density_min">density_min</code></td>
<td>
<p>Minimum buoyant density of the 'heavy' gradient fractions</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_density_max">density_max</code></td>
<td>
<p>Maximum buoyant density of the 'heavy' gradient fractions</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_design">design</code></td>
<td>
<p><code>design</code> parameter used for DESeq2 analysis.
See <code>DESeq2::DESeq</code> for more details.</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_l2fc_threshold">l2fc_threshold</code></td>
<td>
<p>log2 fold change (l2fc) values must be significantly above this
threshold in order to reject the hypothesis of equal counts.</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_sparsity_threshold">sparsity_threshold</code></td>
<td>
<p>All OTUs observed in less than this portion (fraction: 0-1)
of gradient fraction samples are pruned. A a form of indepedent filtering,
The sparsity cutoff with the most rejected hypotheses is used.</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_sparsity_apply">sparsity_apply</code></td>
<td>
<p>Apply sparsity threshold to all gradient fraction samples ('all')
or just heavy fraction samples ('heavy')</p>
</td></tr>
<tr><td><code id="DESeq2_l2fc_+3A_size_factors">size_factors</code></td>
<td>
<p>Method of estimating size factors.
'geoMean' is from (Pepe-Ranney et. al., 2016) and removes all zero-abundances from the calculation.
'default' is the default for estimateSizeFactors.
'iterate' is an alternative when every OTU has a zero in &gt;=1 sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'use_geo_mean' parameter uses geometric means on all non-zero abundances
for estimateSizeFactors instead of using the default log-tranformed geometric means.
</p>


<h3>Value</h3>

<p>dataframe of HRSIP results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2)
## Not run: 
df_l2fc = DESeq2_l2fc(physeq_S2D2, density_min=1.71, density_max=1.75, design=~Substrate)
head(df_l2fc)

## End(Not run)

</code></pre>

<hr>
<h2 id='evaluate_matches'>Evaluate String Interpolation Matches</h2><span id='topic+evaluate_matches'></span>

<h3>Description</h3>

<p>The expression part of string interpolation matches are evaluated in a
specified environment and formatted for replacement in the original string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_matches(matches, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_matches_+3A_matches">matches</code></td>
<td>
<p>Match data</p>
</td></tr>
<tr><td><code id="evaluate_matches_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate the expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of replacement strings.
</p>

<hr>
<h2 id='expr_param_extract'>Extract all quoted values in the expression used for phyloseq subsetting.</h2><span id='topic+expr_param_extract'></span>

<h3>Description</h3>

<p>This can be useful for creating custom (shorter) labels for each subset
relative to using the entire subsetting expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_param_extract(ex, collapse = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_param_extract_+3A_ex">ex</code></td>
<td>
<p>Expression for subsetting the phyloseq object</p>
</td></tr>
<tr><td><code id="expr_param_extract_+3A_collapse">collapse</code></td>
<td>
<p>Similar to the collapse parameter in <code>base::paste</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>length(ex) == 1</code>, then a vector of quoted values in the input string.
If <code>length(ex) &gt; 1</code>, then a matrix or list of quote values,
1 column/index per input string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex = '(Substrate=="12C-Con" &amp; Day=="14")'
expr_param_extract(ex)

ex = '(Substrate=="12C-Con" &amp; Day=="14") | (Substrate=="13C-Cel" &amp; Day == "14")'
expr_param_extract(ex)

# returns a matrix
ex = c('(Substrate=="12C-Con" &amp; Day=="14")',
       '(Substrate=="13C-Cel" &amp; Day == "14")')
expr_param_extract(ex)

# returns a list
ex = c('(Substrate=="12C-Con" &amp; Day=="14")',
       '(Substrate=="13C-Cel" &amp; Day == "14")',
       '(Substrate=="13C-Cel")')
expr_param_extract(ex)

</code></pre>

<hr>
<h2 id='extract_expressions'>Extract Expression Objects from String Interpolation Matches</h2><span id='topic+extract_expressions'></span>

<h3>Description</h3>

<p>An interpolation match object will contain both its wrapping <code>${ }</code> part
and possibly a format. This extracts the expression parts and parses them to
prepare them for evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_expressions(matches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_expressions_+3A_matches">matches</code></td>
<td>
<p>Match data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of R expressions
</p>

<hr>
<h2 id='extract_formats'>Extract String Interpolation Formats from Matched Placeholders</h2><span id='topic+extract_formats'></span>

<h3>Description</h3>

<p>An expression placeholder for string interpolation may optionally contain a
format valid for <code><a href="base.html#topic+sprintf">sprintf</a></code>. This function will extract such or
default to &quot;s&quot; the format for strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_formats(matches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_formats_+3A_matches">matches</code></td>
<td>
<p>Match data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of format specifiers.
</p>

<hr>
<h2 id='filter_l2fc'>Filter l2fc table</h2><span id='topic+filter_l2fc'></span>

<h3>Description</h3>

<p><code>filter_l2fc</code> filters a l2fc table to 'best' sparsity cutoffs &amp;
bouyant density windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_l2fc(df_l2fc, padj_cutoff = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_l2fc_+3A_df_l2fc">df_l2fc</code></td>
<td>
<p>data.frame of log2 fold change values</p>
</td></tr>
<tr><td><code id="filter_l2fc_+3A_padj_cutoff">padj_cutoff</code></td>
<td>
<p>Adjusted p-value cutoff for rejecting the null hypothesis
that l2fc values were not greater than the l2fc_threshold.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered df_l2fc object
</p>

<hr>
<h2 id='format_metadata'>Format phyloseq metadata for calculating BD range overlaps.</h2><span id='topic+format_metadata'></span>

<h3>Description</h3>

<p>Format phyloseq metadata for calculating BD range overlaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_metadata(physeq, ex = "Substrate=='12C-Con'", rep = "Replicate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_metadata_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="format_metadata_+3A_ex">ex</code></td>
<td>
<p>Expression for selecting the control samples to
compare to the non-control samples.</p>
</td></tr>
<tr><td><code id="format_metadata_+3A_rep">rep</code></td>
<td>
<p>Column specifying gradient replicates. If the column
is not present, then all are considered &quot;Replicate=1&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object of formatted metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(physeq_S2D1)
ex = "Substrate=='12C-Con'"
metadata = HTSSIP:::format_metadata(physeq_S2D1, ex)

## End(Not run)

</code></pre>

<hr>
<h2 id='fraction_overlap'>Calculate the BD range overlap of gradient fractions</h2><span id='topic+fraction_overlap'></span>

<h3>Description</h3>

<p>Calculate the BD range overlap of gradient fractions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fraction_overlap(metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fraction_overlap_+3A_metadata">metadata</code></td>
<td>
<p>Metdata data.frame object. See <code>format_metadata()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object of metadata with fraction BD overlaps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(physeq_S2D2)
ex = "Substrate=='12C-Con'"
metadata = HTSSIP:::format_metadata(physeq_S2D2, ex)
m = HTSSIP:::fraction_overlap(metadata)
head(m)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_treatment_params'>Get parameters for subsetting the phyloseq dataset</h2><span id='topic+get_treatment_params'></span>

<h3>Description</h3>

<p>This function is needed if you want to make multiple
subsets of the phyloseq object in order to make specific
comparisons between isotopically labeled-treatments and
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_treatment_params(physeq, exp_params, treatment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_treatment_params_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="get_treatment_params_+3A_exp_params">exp_params</code></td>
<td>
<p>a vector listing the columns in the phyloseq sample_data
table that can subset the phyloseq dataset in order to make the specific
labeled-treatment vs labeled-control comparisons that you would like to make.</p>
</td></tr>
<tr><td><code id="get_treatment_params_+3A_treatment">treatment</code></td>
<td>
<p>This is an expression used to filter out the
control-specific parameters (if needed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>their corresponding controls (eg., from the same time point).
</p>
<p>Makes a data.frame of all of the parameter values that differ
among the treatment-control comparisons.
</p>
<p>For example, if you want to compare the gradient fractions from
each labeled-treatment to its corresponding unlabeled-Control (both from the
same time point).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2)
# Here, the treatment/controls (12C &amp; 13C) are listed in substrate,
# and should be matched by 'Day'. The 13C-treatments can be identified by
# the expression: "Substrate != '12C-Con'"
get_treatment_params(physeq_S2D2, c('Substrate', 'Day'), "Substrate != '12C-Con'")

</code></pre>

<hr>
<h2 id='gradient_sim'>Simulate HTS-SIP communities for 1 density gradient</h2><span id='topic+gradient_sim'></span>

<h3>Description</h3>

<p>Simulate HTS-SIP communities for 1 density gradient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient_sim(locs, params, responseModel = "gaussian",
  countModel = "poisson", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_sim_+3A_locs">locs</code></td>
<td>
<p>Buoyant densities of each gradient fraction</p>
</td></tr>
<tr><td><code id="gradient_sim_+3A_params">params</code></td>
<td>
<p>A matrix of parameters for <code>coenocliner::coenocline()</code>.
See that function's documentation for more details.</p>
</td></tr>
<tr><td><code id="gradient_sim_+3A_responsemodel">responseModel</code></td>
<td>
<p>See <code>coenocliner::coenocline()</code></p>
</td></tr>
<tr><td><code id="gradient_sim_+3A_countmodel">countModel</code></td>
<td>
<p>See <code>coenocliner::coenocline()</code></p>
</td></tr>
<tr><td><code id="gradient_sim_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>coenocliner::coenocline()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of OTU counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting parameters
set.seed(2)
M = 10                                  # number of species (OTUs)
ming = 1.67                             # gradient minimum...
maxg = 1.78                                # ...and maximum
nfrac = 24                                 # number of gradient fractions
locs = seq(ming, maxg, length=nfrac)       # gradient fraction BD values
tol = rep(0.005, M)                       # species tolerances
h = ceiling(rlnorm(M, meanlog=11))    # max abundances
opt = rnorm(M, mean=1.7, sd=0.005)      # species optima
params = cbind(opt=opt, tol=tol, h=h)  # put in a matrix
# simulate the OTU abundances
df_OTU = gradient_sim(locs, params)
head(df_OTU)

</code></pre>

<hr>
<h2 id='heavy_SIP'>Heavy-SIP analysis</h2><span id='topic+heavy_SIP'></span>

<h3>Description</h3>

<p>Compare taxon abundances in 'heavy' fractions versus specific controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heavy_SIP(physeq, ex = "Substrate=='12C-Con'", rep = "Replicate",
  light_window = c(1.68, 1.7), heavy_window = c(1.73, 1.75),
  comparison = c("H", "H-v-L", "H-v-H"), hypo_test = c("binary",
  "t-test", "wilcox"), alternative = c("greater", "two.sided", "less"),
  sparsity_threshold = 0.1, sparsity_apply = c("all", "heavy"),
  padj_method = "BH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heavy_SIP_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object of just treatment vs control.
If you have a more complicated experimental design, subset the
phyloseq object into a list of treatment vs control comparisions.</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_ex">ex</code></td>
<td>
<p>Expression for selecting controls based on metadata</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_rep">rep</code></td>
<td>
<p>Column specifying gradient replicates. If the column
does not exiset, then the column will be created, and all will be considered
&quot;replicate=1&quot;</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_light_window">light_window</code></td>
<td>
<p>A vector designating the &quot;light&quot; BD window start and stop</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_heavy_window">heavy_window</code></td>
<td>
<p>A vector designating the &quot;heavy&quot; BD window start and stop</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_comparison">comparison</code></td>
<td>
<p>Which light/heavy BD windows to compare (see the description)?</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_hypo_test">hypo_test</code></td>
<td>
<p>Which hypothesis test to run on each OTU?
Note that &quot;binary&quot; isn't really a hypothesis test, but just qualitative.</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_alternative">alternative</code></td>
<td>
<p>The &quot;alternative&quot; option for the hypothesis test functions.
Note that &quot;two.sided&quot; doesn't work for the &quot;binary&quot; test.</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_sparsity_threshold">sparsity_threshold</code></td>
<td>
<p>All OTUs observed in less than this portion (fraction: 0-1)
of gradient fraction samples are pruned. A a form of indepedent filtering,
The sparsity cutoff with the most rejected hypotheses is used.</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_sparsity_apply">sparsity_apply</code></td>
<td>
<p>Apply sparsity threshold to all gradient fraction samples ('all')
or just heavy fraction samples ('heavy')</p>
</td></tr>
<tr><td><code id="heavy_SIP_+3A_padj_method">padj_method</code></td>
<td>
<p>Multiple hypothesis correction method. See 'p.adjust()' for more
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Heavy-SIP' encompasses the analyses often used in SIP studies prior
to new HTS-SIP methodologies. These methods all consisted of identifying
'heavy' gradient fractions. This was often done by comparing
the distribution of DNA conc. or gene copies across gradient fractions
in labeled treatments versus unlabeled controls. Sometimes, the unlabeled
control was left out, and &quot;heavy&quot; gradients were identified based on
comparisons with theoretic distributions of unlabeled DNA.
</p>
<p>Although hypothesis testing was often used to assess increased
taxon abundances in &quot;heavy&quot; gradients of labled treatments (eg., one-tailed
t-tests), the hypothesis testing usually did not account for the compositional
nature of sequence data (relative abundances).
</p>
<p>Here, &quot;heavy-SIP&quot; can define incorporators as either:
</p>

<ul>
<li><p>&quot;H&quot; =
Any taxa IN the &quot;heavy&quot; fractions of the labeled treatment gradients

</p>
</li>
<li><p>&quot;H-v-L&quot; =
Any taxa IN the &quot;heavy&quot; fractions of the labeled treatment and NOT
present in the &quot;heavy&quot; fractions of the control

</p>
</li>
<li><p>&quot;H-v-H&quot; =
Any taxa IN the &quot;heavy&quot; fractions of the labeled treatment and NOT
present in the &quot;light&quot; fractions of the labeled treatment

</p>
</li></ul>

<p>Instead of binary comparisions (presence/absence),
one-tailed t-tests or Wilcoxon Rank Sum tests can be used to assess
differential abundance between &quot;heavy&quot; and controls. The hypothesis
testing methods require multiple replicate controls, will use the mean
taxon abundance in the &quot;heavy&quot; (and &quot;light&quot;) window.
</p>


<h3>Value</h3>

<p>a data.frame object of hypothesis test results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2)
data(physeq_rep3)
## Not run: 
# Calculating 'binary' for unreplicated experiment
## Subsetting phyloseq by Substrate and Day
params = get_treatment_params(physeq_S2D2, c('Substrate', 'Day'))
params = dplyr::filter(params, Substrate!='12C-Con')
ex = "(Substrate=='12C-Con' &amp; Day=='${Day}') | (Substrate=='${Substrate}' &amp; Day == '${Day}')"
physeq_S2D2_l = phyloseq_subset(physeq_S2D2, params, ex)

## Calculating heavy-SIP on 1 subset (use lapply function to process full list)
incorps = heavy_SIP(physeq_S2D2_l[[1]])

# Calculating wilcox test on replicated design
## (comparing heavy-treatment versus heavy-control)
incorps = heavy_SIP(physeq_rep3, ex="Treatment=='12C-Con'", comparison='H-v-H', hypo_test='wilcox')

## End(Not run)
</code></pre>

<hr>
<h2 id='HRSIP'>(MW-)HR-SIP analysis</h2><span id='topic+HRSIP'></span>

<h3>Description</h3>

<p>Conduct (multi-window) high resolution stable isotope probing (HR-SIP) analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HRSIP(physeq, design, density_windows = data.frame(density_min = c(1.7),
  density_max = c(1.75)), sparsity_threshold = seq(0, 0.3, 0.1),
  sparsity_apply = "all", l2fc_threshold = 0.25, padj_method = "BH",
  padj_cutoff = NULL, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HRSIP_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_design">design</code></td>
<td>
<p><code>design</code> parameter used for DESeq2 analysis.
This is usually used to differentiate labeled-treatment and unlabeld-control samples.
See <code>DESeq2::DESeq</code> for more details on the option.</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_density_windows">density_windows</code></td>
<td>
<p>The buoyant density window(s) used for for calculating log2
fold change values. Input can be a vector (length 2) or a data.frame with a 'density_min'
and a 'density_max' column (each row designates a density window).</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_sparsity_threshold">sparsity_threshold</code></td>
<td>
<p>All OTUs observed in less than this portion (fraction: 0-1)
of gradient fraction samples are pruned. This is a form of indepedent filtering.
The sparsity cutoff with the most rejected hypotheses is used.</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_sparsity_apply">sparsity_apply</code></td>
<td>
<p>Apply sparsity threshold to all gradient fraction samples ('all')
or just 'heavy' fraction samples ('heavy'), where 'heavy' samples are designated
by the <code>density_windows</code>.</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_l2fc_threshold">l2fc_threshold</code></td>
<td>
<p>log2 fold change (l2fc) values must be significantly above this
threshold in order to reject the hypothesis of equal counts.
See <code>DESeq2</code> for more information.</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_padj_method">padj_method</code></td>
<td>
<p>Method for global p-value adjustment (See <code>p.adjust()</code>).</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_padj_cutoff">padj_cutoff</code></td>
<td>
<p>Adjusted p-value cutoff for rejecting the null hypothesis
that l2fc values were not greater than the l2fc_threshold.
Set to <code>NULL</code> to skip filtering of results to the sparsity cutoff with most
rejected hypotheses and filtering each OTU to the buoyant density window with the
greatest log2 fold change.</p>
</td></tr>
<tr><td><code id="HRSIP_+3A_parallel">parallel</code></td>
<td>
<p>Process each parameter combination in parallel.
See <code>plyr::mdply()</code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (MW-)HR-SIP workflow is as follows:
</p>

<ol>
<li><p> For each sparsity threshold &amp; BD window: calculate log2 fold change values (with DESeq2) for each OTU
</p>
</li>
<li><p> Globally adjust p-values with a user-defined method (see p.adjust())
</p>
</li>
<li><p> Select the sparsity cutoff with the most rejected hypotheses
</p>
</li>
<li><p> For each OTU, select the BD window with the greatest log2 fold change value
</p>
</li></ol>



<h3>Value</h3>

<p>dataframe of HRSIP results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)

## Not run: 
# HR-SIP on just 1 treatment-control comparison
## 1st item in list of phyloseq objects
physeq = physeq_S2D2_l[[1]]
## HR-SIP
### Note: treatment-control samples differentiated with 'design=~Substrate'
df_l2fc = HRSIP(physeq, design=~Substrate)
head(df_l2fc)

## Same, but multiple BD windows (MW-HR-SIP) &amp; run in parallel
### Windows = 1.7-1.73 &amp; 1.72-1.75
doParallel::registerDoParallel(2)
dw = data.frame(density_min=c(1.7, 1.72), density_max=c(1.73, 1.75))
df_l2fc = HRSIP(physeq_S2D1_l[[1]],
                design=~Substrate,
                density_windows=dw,
                parallel=TRUE)
head(df_l2fc)

## End(Not run)

</code></pre>

<hr>
<h2 id='HTSSIP_sim'>Simulate a HTS-SIP dataset</h2><span id='topic+HTSSIP_sim'></span>

<h3>Description</h3>

<p>This is a simple method for simulating high thoughput sequencing
stable isotope probing datasets and is mainly used for package testing
purposes. See <code>SIPSim</code> for more detailed and simulation pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTSSIP_sim(locs, params, responseModel = "gaussian",
  countModel = "poisson", meta = NULL, sim_tree = FALSE,
  parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTSSIP_sim_+3A_locs">locs</code></td>
<td>
<p>Buoyant densities of each gradient fraction</p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_params">params</code></td>
<td>
<p>A matrix of parameters for <code>coenocliner::coenocline()</code>.
See that function's documentation for more details.</p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_responsemodel">responseModel</code></td>
<td>
<p>See <code>coenocliner::coenocline()</code></p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_countmodel">countModel</code></td>
<td>
<p>See <code>coenocliner::coenocline()</code></p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_meta">meta</code></td>
<td>
<p>Data.frame object of metadata to add to <code>sample_data</code> table.
The data.frame object must have a 'Gradient' column, which is used for joining
with <code>dplyr::left_join()</code>.</p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_sim_tree">sim_tree</code></td>
<td>
<p>Simulate a tree?</p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_parallel">parallel</code></td>
<td>
<p>Parallel processing. See <code>.parallel</code> option in
<code>dplyr::mdply()</code> for more details.</p>
</td></tr>
<tr><td><code id="HTSSIP_sim_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>coenocliner::coenocline()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phyloseq object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setting parameters for tests
set.seed(2)
M = 10                                  # number of species
ming = 1.67                             # gradient minimum...
maxg = 1.78                                # ...and maximum
nfrac = 24                                 # number of gradient fractions
locs = seq(ming, maxg, length=nfrac)       # gradient locations
tol  = rep(0.005, M)                       # species tolerances
h    = ceiling(rlnorm(M, meanlog=11))    # max abundances
## creating parameter matrices for each density gradient
opt1 = rnorm(M, mean=1.7, sd=0.005)      # species optima
params1 = cbind(opt=opt1, tol=tol, h=h)  # put in a matrix
opt2 = rnorm(M, mean=1.7, sd=0.005)      # species optima
params2 = cbind(opt=opt2, tol=tol, h=h)  # put in a matrix
param_l = list(
  '12C-Con_rep1' = params1,
  '13C-Cel_rep1' = params2
)
## Not run: 
# simulating phyloseq object
physeq = HTSSIP_sim(locs, param_l)
physeq

## End(Not run)

</code></pre>

<hr>
<h2 id='match_brace'>Utility Function for Matching a Closing Brace</h2><span id='topic+match_brace'></span>

<h3>Description</h3>

<p>Given positions of opening and closing braces <code>match_brace</code> identifies
the closing brace matching the first opening brace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_brace(opening, closing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_brace_+3A_opening">opening</code></td>
<td>
<p>integer: Vector with positions of opening braces.</p>
</td></tr>
<tr><td><code id="match_brace_+3A_closing">closing</code></td>
<td>
<p>integer: Vector with positions of closing braces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer with the posision of the matching brace.
</p>

<hr>
<h2 id='match_placeholders'>Match Expression Placeholders for String Interpolation</h2><span id='topic+match_placeholders'></span>

<h3>Description</h3>

<p>Given a character string a set of expression placeholders are matched. They
are of the form <code>${...}</code> or optionally <code>$[f]{...}</code> where <code>f</code>
is a valid format for <code><a href="base.html#topic+sprintf">sprintf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_placeholders(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_placeholders_+3A_string">string</code></td>
<td>
<p>character: The string to be interpolated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing <code>indices</code> (regex match data) and <code>matches</code>,
the string representations of matched expressions.
</p>

<hr>
<h2 id='max_BD_range'>Adjusting BD range size if negative.</h2><span id='topic+max_BD_range'></span>

<h3>Description</h3>

<p>If BD (buoyant density) range size is negative,
use BD_to_set value to set new BD_max. The <code>BD_to_set</code>
determines the <code>BD_max</code> if BD range is negative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_BD_range(BD_range, BD_min, BD_max, BD_to_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_BD_range_+3A_bd_range">BD_range</code></td>
<td>
<p>BD range size</p>
</td></tr>
<tr><td><code id="max_BD_range_+3A_bd_min">BD_min</code></td>
<td>
<p>Minimum BD value</p>
</td></tr>
<tr><td><code id="max_BD_range_+3A_bd_max">BD_max</code></td>
<td>
<p>Maximum BD value</p>
</td></tr>
<tr><td><code id="max_BD_range_+3A_bd_to_set">BD_to_set</code></td>
<td>
<p>Value added to BD_min to set new BD_max</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New max BD value
</p>

<hr>
<h2 id='OTU_qPCR_trans'>Transform OTU counts based on qPCR data</h2><span id='topic+OTU_qPCR_trans'></span>

<h3>Description</h3>

<p>OTU counts in the phyloseq otu_table object will be normalized
to sample totals (total sum scaling), then multiplied by the
qPCR value associated with each sample. Thus, the qPCR table
should have ONE value matching the OTU count table. Value
matching between the OTU table &amp; qPCR value table to set by
<code>sample_idx()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OTU_qPCR_trans(physeq, qPCR, sample_idx = "Sample",
  value_idx = "qPCR_tech_rep_mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OTU_qPCR_trans_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object</p>
</td></tr>
<tr><td><code id="OTU_qPCR_trans_+3A_qpcr">qPCR</code></td>
<td>
<p>Either a list or a data.frame of qPCR data.
If a list, the list should include a 'summary' tag as is produced
from <code>qPCR_sim()</code>.
If a data.frame, the table should be formatted as the 'summary' table
produced from <code>qPCR_sim()</code>.</p>
</td></tr>
<tr><td><code id="OTU_qPCR_trans_+3A_sample_idx">sample_idx</code></td>
<td>
<p>The qPCR table column index for
matching to otu table samples.</p>
</td></tr>
<tr><td><code id="OTU_qPCR_trans_+3A_value_idx">value_idx</code></td>
<td>
<p>The qPCR table column index for qPCR values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: only the 'summa
</p>


<h3>Value</h3>

<p>A phyloseq object with transformed OTU counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'># qPCR data simulation
data(physeq_rep3)
data(physeq_rep3_qPCR)
physeq_rep3_t = OTU_qPCR_trans(physeq_rep3, physeq_rep3_qPCR)

</code></pre>

<hr>
<h2 id='overlap_wmean_dist'>Calculating weighted mean beta-diversities of overlapping gradient fractions.</h2><span id='topic+overlap_wmean_dist'></span>

<h3>Description</h3>

<p>Calculating weighted mean beta-diversities of overlapping gradient fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap_wmean_dist(df_dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_wmean_dist_+3A_df_dist">df_dist</code></td>
<td>
<p>Filtered distance matrix in data.frame format.
See <code>parse_dist()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object of weighted mean distances
</p>

<hr>
<h2 id='parse_dist'>Filtering out non-relevant distances in distance matrix</h2><span id='topic+parse_dist'></span>

<h3>Description</h3>

<p>Filtering out non-relevant distances in distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_dist(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_dist_+3A_d">d</code></td>
<td>
<p>a distance matrix object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object of metadata with fraction BD overlaps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(physeq_S2D2)
physeq_S2D2_d = phyloseq::distance(physeq_S2D2,
                             method='unifrac',
                             weighted=TRUE,
                             fast=TRUE,
                             normalized=FALSE)
physeq_S2D2_d = HTSSIP:::parse_dist(physeq_S2D2_d)
head(physeq_S2D2_d)

## End(Not run)

</code></pre>

<hr>
<h2 id='perc_overlap'>Calculate the percent overlap between two ranges (x &amp; y).</h2><span id='topic+perc_overlap'></span>

<h3>Description</h3>

<p>The fraction of overlap is relative to Range X (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perc_overlap(x.start, x.end, y.start, y.end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perc_overlap_+3A_x.start">x.start</code></td>
<td>
<p>The start value for Range X</p>
</td></tr>
<tr><td><code id="perc_overlap_+3A_x.end">x.end</code></td>
<td>
<p>The end value for Range X</p>
</td></tr>
<tr><td><code id="perc_overlap_+3A_y.start">y.start</code></td>
<td>
<p>The start value for Range Y</p>
</td></tr>
<tr><td><code id="perc_overlap_+3A_y.end">y.end</code></td>
<td>
<p>The end value for Range Y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the percent overlap of the ranges
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x = HTSSIP:::perc_overlap(0, 1, 0, 0.5)
stopifnot(x == 50)
x = HTSSIP:::perc_overlap(0, 0.5, 0, 1)
stopifnot(x == 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='phyloseq_list_ord_dfs'>Converting ordination objects to data.frames</h2><span id='topic+phyloseq_list_ord_dfs'></span>

<h3>Description</h3>

<p>For each ordination object in a list, converts to a data.frame
for easy plotting with ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloseq_list_ord_dfs(physeq_l, physeq_l_ords, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloseq_list_ord_dfs_+3A_physeq_l">physeq_l</code></td>
<td>
<p>A list of phyloseq objects</p>
</td></tr>
<tr><td><code id="phyloseq_list_ord_dfs_+3A_physeq_l_ords">physeq_l_ords</code></td>
<td>
<p>A list of ordination objects</p>
</td></tr>
<tr><td><code id="phyloseq_list_ord_dfs_+3A_parallel">parallel</code></td>
<td>
<p>Parallel processing. See <code>plyr::adply</code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data.frame objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
## Not run: 
# make a list of beta diversity distance matrix objects
physeq_S2D2_l_d = physeq_list_betaDiv(physeq_S2D2_l)
# make a list of ordinations
physeq_S2D2_l_d_ord = physeq_list_ord(physeq_S2D2_l, physeq_S2D2_l_d)
# convert ordination information to data.frame objects
physeq_S2D2_l_d_ord_df = phyloseq_list_ord_dfs(physeq_S2D2_l, physeq_S2D2_l_d_ord)

## End(Not run)

</code></pre>

<hr>
<h2 id='phyloseq_ord_plot'>Plotting beta diversity ordination</h2><span id='topic+phyloseq_ord_plot'></span>

<h3>Description</h3>

<p>For each data.frame object in a list (coverted from ordination objects),
creates a ggplot figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloseq_ord_plot(physeq_ord_df, title = NULL,
  point_size = "Buoyant_density", point_fill = "Substrate",
  point_alpha = 0.5, point_shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloseq_ord_plot_+3A_physeq_ord_df">physeq_ord_df</code></td>
<td>
<p>A list of data.frame objects (see phyloseq_list_ord_dfs)</p>
</td></tr>
<tr><td><code id="phyloseq_ord_plot_+3A_title">title</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="phyloseq_ord_plot_+3A_point_size">point_size</code></td>
<td>
<p>The data.frame column determining point size</p>
</td></tr>
<tr><td><code id="phyloseq_ord_plot_+3A_point_fill">point_fill</code></td>
<td>
<p>The data.frame column determining point fill color</p>
</td></tr>
<tr><td><code id="phyloseq_ord_plot_+3A_point_alpha">point_alpha</code></td>
<td>
<p>The data.frame column (or just a single value) determining point alpha</p>
</td></tr>
<tr><td><code id="phyloseq_ord_plot_+3A_point_shape">point_shape</code></td>
<td>
<p>The data.frame column (or just a single value) determining point shape</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
## Not run: 
# make a list of beta diversity distance matrix objects
physeq_S2D2_l_d = physeq_list_betaDiv(physeq_S2D2_l)
# make a list of ordinations
physeq_S2D2_l_d_ord = physeq_list_ord(physeq_S2D2_l, physeq_S2D2_l_d)
# convert ordination information to data.frame objects
physeq_S2D2_l_d_ord_df = phyloseq_list_ord_dfs(physeq_S2D2_l, physeq_S2D2_l_d_ord)
# make ordination plots with ggplot2
phyloseq_ord_plot(physeq_S2D2_l_d_ord_df)

## End(Not run)

</code></pre>

<hr>
<h2 id='phyloseq_subset'>Make a list of phyloseq object subsets</h2><span id='topic+phyloseq_subset'></span>

<h3>Description</h3>

<p>Create a list of phyloseq object subsets based on phyloseq
sample data parameters (e.g., a phyloseq subset for each treatment)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloseq_subset(physeq, params, ex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloseq_subset_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="phyloseq_subset_+3A_params">params</code></td>
<td>
<p>data.frame of parameters supplies to <code>ex</code></p>
</td></tr>
<tr><td><code id="phyloseq_subset_+3A_ex">ex</code></td>
<td>
<p>Expression for subsetting the phyloseq object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of Phyloseq objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2)
# making subsets by substrate and time point
params = get_treatment_params(physeq_S2D2, c('Substrate', 'Day'))
# filtering out controls
params = dplyr::filter(params, Substrate!='12C-Con')
# making expression for subsetting labeled-unlabeled gradient comparisons
ex = "(Substrate=='12C-Con' &amp; Day=='${Day}') | (Substrate=='${Substrate}' &amp; Day == '${Day}')"
physeq_l = phyloseq_subset(physeq_S2D2, params, ex)
physeq_l

</code></pre>

<hr>
<h2 id='phyloseq2df'>phyloseq data object conversion to data.frame</h2><span id='topic+phyloseq2df'></span>

<h3>Description</h3>

<p>Conducts conversion of 1 of the data objects
in a phyloseq object (eg., tax_table) to a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloseq2df(physeq, table_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloseq2df_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="phyloseq2df_+3A_table_func">table_func</code></td>
<td>
<p>See <code>Phyloseq::phyloseq-class</code> for options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D1)
df_otu = phyloseq2df(physeq_S2D1, table_func=phyloseq::otu_table)
head(df_otu)

df_sample = phyloseq2df(physeq_S2D1, table_func=phyloseq::sample_data)
head(df_sample)

</code></pre>

<hr>
<h2 id='phyloseq2table'>Phyloseq conversion to a ggplot-formatted table</h2><span id='topic+phyloseq2table'></span>

<h3>Description</h3>

<p>Convert the OTU table (+ metadata) to a format that can be
easily plotted with phyloseq
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phyloseq2table(physeq, include_sample_data = FALSE,
  sample_col_keep = NULL, include_tax_table = FALSE,
  tax_col_keep = NULL, control_expr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phyloseq2table_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
<tr><td><code id="phyloseq2table_+3A_include_sample_data">include_sample_data</code></td>
<td>
<p>Include <code>sample_table</code> information?</p>
</td></tr>
<tr><td><code id="phyloseq2table_+3A_sample_col_keep">sample_col_keep</code></td>
<td>
<p>Which columns in the <code>sample_data</code> table to keep?
Use <code>NULL</code> to keep all columns.</p>
</td></tr>
<tr><td><code id="phyloseq2table_+3A_include_tax_table">include_tax_table</code></td>
<td>
<p>Include <code>tax_table</code> information?</p>
</td></tr>
<tr><td><code id="phyloseq2table_+3A_tax_col_keep">tax_col_keep</code></td>
<td>
<p>A vector for column names to keep.
Use <code>NULL</code> to keep all columns.</p>
</td></tr>
<tr><td><code id="phyloseq2table_+3A_control_expr">control_expr</code></td>
<td>
<p>An expression for identifying which samples are controls.
Control/non-control identification will be in the 'IS_CONTROL' column of the
returned data.frame object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D1)
# Including some columns from sample metadata
df_OTU = phyloseq2table(physeq_S2D1,
                        include_sample_data=TRUE,
                        sample_col_keep=c('Buoyant_density', 'Substrate', 'Day'))
head(df_OTU)

## Not run: 
# Including some columns from sample metadata &amp; taxonomy
df_OTU = phyloseq2table(physeq_S2D1,
                        include_sample_data=TRUE,
                        sample_col_keep=c('Buoyant_density', 'Substrate', 'Day'),
                        include_tax_table=TRUE)
head(df_OTU)

## End(Not run)

</code></pre>

<hr>
<h2 id='physeq_format'>Checking format of phyloseq object for HTSSIP compatibility</h2><span id='topic+physeq_format'></span>

<h3>Description</h3>

<p>Checking format of phyloseq object for HTSSIP compatibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>physeq_format(physeq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physeq_format_+3A_physeq">physeq</code></td>
<td>
<p>Phyloseq object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phyloseq object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this data should be formatted for HTSSIP
data(physeq_S2D2)
physeq_format(physeq_S2D2)

# this data should NOT be correctly formatted for HTSSIP
## Not run: 
library(phyloseq)
data(GlobalPatterns)
tryCatch(
 physeq_format(GlobalPatterns),
 function(e) e
 )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='physeq_list_betaDiv'>calculating beta diversity for a list of phyloseq objects</h2><span id='topic+physeq_list_betaDiv'></span>

<h3>Description</h3>

<p>For each phyloseq object in a list, calculates beta-diversity
between all samples using the phyloseq::distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>physeq_list_betaDiv(physeq_l, method = "unifrac", weighted = TRUE,
  fast = TRUE, normalized = TRUE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physeq_list_betaDiv_+3A_physeq_l">physeq_l</code></td>
<td>
<p>A list of phyloseq objects</p>
</td></tr>
<tr><td><code id="physeq_list_betaDiv_+3A_method">method</code></td>
<td>
<p>See phyloseq::distance</p>
</td></tr>
<tr><td><code id="physeq_list_betaDiv_+3A_weighted">weighted</code></td>
<td>
<p>Weighted Unifrac (if calculating Unifrac)</p>
</td></tr>
<tr><td><code id="physeq_list_betaDiv_+3A_fast">fast</code></td>
<td>
<p>Fast calculation method</p>
</td></tr>
<tr><td><code id="physeq_list_betaDiv_+3A_normalized">normalized</code></td>
<td>
<p>Normalized abundances</p>
</td></tr>
<tr><td><code id="physeq_list_betaDiv_+3A_parallel">parallel</code></td>
<td>
<p>Calculate in parallel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: for calculating Unifrac values, phyloseq will select
a root at random if the input phylogeny is not rooted.
</p>


<h3>Value</h3>

<p>List of dist objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
## Not run: 
physeq_S2D2_l_d = physeq_list_betaDiv(physeq_S2D2_l)

## End(Not run)

</code></pre>

<hr>
<h2 id='physeq_list_ord'>calculating ordinations from a list of distance matrices</h2><span id='topic+physeq_list_ord'></span>

<h3>Description</h3>

<p>For each <code>dist</code> object in a provided list, the fucntion
calculates an ordination with the <code>phyloseq::ordinate</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>physeq_list_ord(physeq_l, physeq_l_d, ord_method = "NMDS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physeq_list_ord_+3A_physeq_l">physeq_l</code></td>
<td>
<p>A list of phyloseq objects</p>
</td></tr>
<tr><td><code id="physeq_list_ord_+3A_physeq_l_d">physeq_l_d</code></td>
<td>
<p>A list of dist objects</p>
</td></tr>
<tr><td><code id="physeq_list_ord_+3A_ord_method">ord_method</code></td>
<td>
<p>See phyloseq::ordinate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of ordination objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
## Not run: 
# make a list of beta diversity distance matrix objects
physeq_S2D2_l_d = physeq_list_betaDiv(physeq_S2D2_l)
# make a list of ordinations
physeq_S2D2_l_d_ord = physeq_list_ord(physeq_S2D2_l, physeq_S2D2_l_d)

## End(Not run)

</code></pre>

<hr>
<h2 id='qPCR_sim'>Simulate qPCR values</h2><span id='topic+qPCR_sim'></span>

<h3>Description</h3>

<p>qPCR values will be simulated for each sample in the provided phyloseq object.
The error distribution for each sample is drawn from a Gaussian distribution,
where the mean and standard deviation of the Gaussian distribution are set by
user-defined functions. The user-defined functions that take buoyant density
as input and returns a numeric value (see examples), which allows the qPCR
values to increase in mean &amp; variance at certain buoyant densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qPCR_sim(physeq, control_mean_fun, control_sd_fun, treat_mean_fun,
  treat_sd_fun, n_tech_rep = 3, control_expr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qPCR_sim_+3A_physeq">physeq</code></td>
<td>
<p>Object of class &quot;phyloseq&quot;</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_control_mean_fun">control_mean_fun</code></td>
<td>
<p>Function used for simulating the qPCR normal distribution mean
for control samples.</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_control_sd_fun">control_sd_fun</code></td>
<td>
<p>Function used for simulating the qPCR normal distribution
standard deviation for control samples.</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_treat_mean_fun">treat_mean_fun</code></td>
<td>
<p>Function used for simulating the qPCR normal distribution mean
for treatment samples.</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_treat_sd_fun">treat_sd_fun</code></td>
<td>
<p>Function used for simulating the qPCR normal distribution
standard deviation for treatment samples.</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_n_tech_rep">n_tech_rep</code></td>
<td>
<p>Number of technical replicates.</p>
</td></tr>
<tr><td><code id="qPCR_sim_+3A_control_expr">control_expr</code></td>
<td>
<p>Expression used to identify control samples based on sample_data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of qPCR values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># making functions for simulating values
## 'x' will be Buoyant_density as defined in the phyloseq object sample_data
control_mean_fun = function(x) dnorm(x, mean=1.70, sd=0.01) * 1e8
## This will set sd to scale with the mean
control_sd_fun = function(x) control_mean_fun(x) / 3
## This will 'shift' the gene copy distribution to 'heavier' BDs
treat_mean_fun = function(x) dnorm(x, mean=1.75, sd=0.01) * 1e8
treat_sd_fun = function(x) treat_mean_fun(x) / 3
# simulating qPCR values
df_qPCR = qPCR_sim(physeq_S2D2,
                control_expr='Substrate=="12C-Con"',
                control_mean_fun=control_mean_fun,
                control_sd_fun=control_sd_fun,
                treat_mean_fun=treat_mean_fun,
                treat_sd_fun=treat_sd_fun)

# using the Cauchy distribution instead of normal distributions
control_mean_fun = function(x) dcauchy(x, location=1.70, scale=0.01) * 1e8
control_sd_fun = function(x) control_mean_fun(x) / 3
treat_mean_fun = function(x) dcauchy(x, location=1.74, scale=0.01) * 1e8
treat_sd_fun = function(x) treat_mean_fun(x) / 3
# simulating qPCR values
df_qPCR = qPCR_sim(physeq_S2D2,
                control_expr='Substrate=="12C-Con"',
                control_mean_fun=control_mean_fun,
                control_sd_fun=control_sd_fun,
                treat_mean_fun=treat_mean_fun,
                treat_sd_fun=treat_sd_fun)

</code></pre>

<hr>
<h2 id='qSIP_atom_excess'>Calculate atom fraction excess using q-SIP method</h2><span id='topic+qSIP_atom_excess'></span>

<h3>Description</h3>

<p>Calculate atom fraction excess using q-SIP method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qSIP_atom_excess(physeq, control_expr, treatment_rep = NULL,
  isotope = "13C", df_OTU_W = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qSIP_atom_excess_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_+3A_control_expr">control_expr</code></td>
<td>
<p>Expression used to identify control samples based on sample_data.</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_+3A_treatment_rep">treatment_rep</code></td>
<td>
<p>Which column in the phyloseq sample data designates
replicate treatments</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_+3A_isotope">isotope</code></td>
<td>
<p>The isotope for which the DNA is labeled with ('13C' or '18O')</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_+3A_df_otu_w">df_OTU_W</code></td>
<td>
<p>Keep NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 data.frame objects. 'W' contains
the weighted mean buoyant density (W) values for each OTU in
each treatment/control. 'A' contains the atom fraction excess
values for each OTU. For the 'A' table, the 'Z' column is buoyant
density shift, and the 'A' column is atom fraction excess.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tranforming values
physeq_rep3_t = OTU_qPCR_trans(physeq_rep3, physeq_rep3_qPCR)

## Not run: 
# BD shift (Z) &amp; atom excess (A)
atomX = qSIP_atom_excess(physeq_rep3_t,
                         control_expr='Treatment=="12C-Control"',
                         treatment_rep='Replicate')

## End(Not run)

</code></pre>

<hr>
<h2 id='qSIP_atom_excess_format'>Reformat a phyloseq object of qSIP_atom_excess analysis</h2><span id='topic+qSIP_atom_excess_format'></span>

<h3>Description</h3>

<p>Reformat a phyloseq object of qSIP_atom_excess analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qSIP_atom_excess_format(physeq, control_expr, treatment_rep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qSIP_atom_excess_format_+3A_physeq">physeq</code></td>
<td>
<p>A phyloseq object</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_format_+3A_control_expr">control_expr</code></td>
<td>
<p>An expression for identifying unlabeled control
samples in the phyloseq object (eg., &quot;Substrate=='12C-Con'&quot;)</p>
</td></tr>
<tr><td><code id="qSIP_atom_excess_format_+3A_treatment_rep">treatment_rep</code></td>
<td>
<p>Which column in the phyloseq sample data designates
replicate treatments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value: atom fraction excess (A)
</p>

<hr>
<h2 id='qSIP_bootstrap'>Calculate bootstrap CI for atom fraction excess using q-SIP method</h2><span id='topic+qSIP_bootstrap'></span>

<h3>Description</h3>

<p>Calculate bootstrap CI for atom fraction excess using q-SIP method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qSIP_bootstrap(atomX, isotope = "13C", n_sample = c(3, 3),
  n_boot = 10, parallel = FALSE, a = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qSIP_bootstrap_+3A_atomx">atomX</code></td>
<td>
<p>A list object created by <code>qSIP_atom_excess()</code></p>
</td></tr>
<tr><td><code id="qSIP_bootstrap_+3A_isotope">isotope</code></td>
<td>
<p>The isotope for which the DNA is labeled with ('13C' or '18O')</p>
</td></tr>
<tr><td><code id="qSIP_bootstrap_+3A_n_sample">n_sample</code></td>
<td>
<p>A vector of length 2.
The sample size for data resampling (with replacement) for 1) control samples
and 2) treatment samples.</p>
</td></tr>
<tr><td><code id="qSIP_bootstrap_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="qSIP_bootstrap_+3A_parallel">parallel</code></td>
<td>
<p>Parallel processing. See <code>.parallel</code> option in
<code>dplyr::mdply()</code> for more details.</p>
</td></tr>
<tr><td><code id="qSIP_bootstrap_+3A_a">a</code></td>
<td>
<p>A numeric value. The alpha for calculating confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of atom fraction excess values (A) and
atom fraction excess confidence intervals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tranforming values
physeq_rep3_t = OTU_qPCR_trans(physeq_rep3, physeq_rep3_qPCR)

## Not run: 
# BD shift (Z) &amp; atom excess (A)
atomX = qSIP_atom_excess(physeq_rep3_t,
                        control_expr='Treatment=="12C-Con"',
                        treatment_rep='Replicate')

# bootstrapping in parallel
doParallel::registerDoParallel(2)
df_atomX_boot = qSIP_bootstrap(atomX, parallel=TRUE)
head(df_atomX_boot)

## End(Not run)

</code></pre>

<hr>
<h2 id='SIP_betaDiv_ord'>Calculating &amp; plotting beta diversity for a list of phyloseq objects</h2><span id='topic+SIP_betaDiv_ord'></span>

<h3>Description</h3>

<p>For each phyloseq object in a list, calculates beta-diversity
between all samples using the phyloseq::distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIP_betaDiv_ord(physeq_l, method = "unifrac", weighted = TRUE,
  fast = TRUE, normalized = TRUE, parallel = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIP_betaDiv_ord_+3A_physeq_l">physeq_l</code></td>
<td>
<p>A list of phyloseq objects</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_method">method</code></td>
<td>
<p>See phyloseq::distance</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_weighted">weighted</code></td>
<td>
<p>Weighted Unifrac (if calculating Unifrac)</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_fast">fast</code></td>
<td>
<p>Fast calculation method</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_normalized">normalized</code></td>
<td>
<p>Normalized abundances</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_parallel">parallel</code></td>
<td>
<p>Calculate in parallel</p>
</td></tr>
<tr><td><code id="SIP_betaDiv_ord_+3A_plot">plot</code></td>
<td>
<p>Return a plot (instead of a data.frame of ordination data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If plot==FALSE, a data.frame object of beta-diversity values.
If plot==TRUE, a glob object for plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(physeq_S2D2_l)
## Not run: 
physeq_S2D2_l_df = SIP_betaDiv_ord(physeq_S2D2_l)
head(physeq_S2D2_l_df, n=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='stringterpolate'>String Interpolation</h2><span id='topic+stringterpolate'></span>

<h3>Description</h3>

<p>String interpolation is a useful way of specifying a character string which
depends on values in a certain environment. It allows for string creation
which is easier to read and write when compared to using e.g.
<code><a href="base.html#topic+paste">paste</a></code> or <code><a href="base.html#topic+sprintf">sprintf</a></code>. The (template) string can
include expression placeholders of the form <code>${expression}</code> or
<code>$[format]{expression}</code>, where expressions are valid R expressions that
can be evaluated in the given environment, and <code>format</code> is a format
specification valid for use with <code><a href="base.html#topic+sprintf">sprintf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringterpolate(string, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringterpolate_+3A_string">string</code></td>
<td>
<p>A template character string.</p>
</td></tr>
<tr><td><code id="stringterpolate_+3A_env">env</code></td>
<td>
<p>The environment in which to evaluate the expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interpolated character string.
</p>

<hr>
<h2 id='tss'>Total sum scaling</h2><span id='topic+tss'></span>

<h3>Description</h3>

<p>Total sum scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tss(x, MARGIN = 2, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tss_+3A_x">x</code></td>
<td>
<p>data.frame of numeric values</p>
</td></tr>
<tr><td><code id="tss_+3A_margin">MARGIN</code></td>
<td>
<p>table margin (1=rows, 2=columns)</p>
</td></tr>
<tr><td><code id="tss_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NAs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of qPCR values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># making functions for simulating values
df = data.frame(1:5, 5:9)
df_t = tss(df)
apply(df_t, 2, sum)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
