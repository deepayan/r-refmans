<!DOCTYPE html><html><head><title>Help for package ltsspca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ltsspca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Angle'><p>Standardized last principal angle</p></a></li>
<li><a href='#dataSim'><p>Simulate data</p></a></li>
<li><a href='#Glass'><p>Glass data</p></a></li>
<li><a href='#ltspca'><p>Principal Component Analysis Based on Least Trimmed Squaers (LTS-PCA)</p></a></li>
<li><a href='#ltsspca'><p>Sparse Principal Component Analysis Based on Least Trimmed Squaers (LTS-SPCA)</p></a></li>
<li><a href='#ltsspcaRw'><p>Reweighted LTS-SPCA</p></a></li>
<li><a href='#mydiagPlot'><p>Make diagnostic plot using the estimated PC subspace</p></a></li>
<li><a href='#sPCA_rSVD'><p>Sparse Principal Component Analysis via Regularized Singular Value Decompsition (sPCA-rSVD)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Principal Component Based on Least Trimmed Squares</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-13</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yixin Wang &lt;wangyixin07@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of robust and sparse PCA algorithm of Wang and Van Aelst (2019) &lt;<a href="https://doi.org/10.1080%2F00401706.2019.1671234">doi:10.1080/00401706.2019.1671234</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>robustbase, rrcov, stats, mvtnorm, graphics, knitr,
rmarkdown, testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1),pracma</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-10-07 19:44:19 UTC; wangy</td>
</tr>
<tr>
<td>Author:</td>
<td>Yixin Wang [aut, cre],
  Stefan Van Aelst [aut],
  Holger Cevallos Valdiviezo [ctb] (Original R code for the LTS-PCA
    algorithm),
  Tom Reynkens [ctb] (Original R code for angle in the rospca package)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-10-09 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Angle'>Standardized last principal angle</h2><span id='topic+Angle'></span>

<h3>Description</h3>

<p>Standardised last principal angle between the subspaces generated by the columns of A and B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Angle(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Angle_+3A_a">A</code></td>
<td>
<p>numerical matrix of size <em>p</em> by <em>k</em></p>
</td></tr>
<tr><td><code id="Angle_+3A_b">B</code></td>
<td>
<p>numerical matrix of size <em>q</em> by <em>l</em></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardised last principal angle between A and B.
</p>


<h3>Author(s)</h3>

<p>Tom Reynkens
</p>


<h3>References</h3>

<p>Bjorck, A. and Golub, G. H. (1973), &ldquo;Numerical Methods for Computing Angles Between Linear Subspaces,&rdquo; <em>Mathematics of Computation</em>, 27, 579&ndash;594.
</p>
<p>Hubert, M., Rousseeuw, P. J., and Vanden Branden, K. (2005), &ldquo;ROBPCA: A New Approach to Robust Principal Component Analysis,&rdquo; <em>Technometrics</em>, 47, 64&ndash;79.
</p>
<p>Hubert, M., Reynkens, T., Schmitt, E. and Verdonck, T. (2016), &ldquo;Sparse PCA for High-Dimensional Data With Outliers,&rdquo; <em>Technometrics</em>, 58, 424&ndash;434.
</p>

<hr>
<h2 id='dataSim'>Simulate data</h2><span id='topic+dataSim'></span>

<h3>Description</h3>

<p>the function that generates the simulation data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataSim(n = 200, p = 20, bLength = 4, a = c(0.9, 0.5, 0),
  SD = c(10, 5, 2), eps = 0, eta = 25, setting = "3", seed = 123,
  vc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataSim_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="dataSim_+3A_p">p</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="dataSim_+3A_blength">bLength</code></td>
<td>
<p>the number of correlated variables in the first k blocks</p>
</td></tr>
<tr><td><code id="dataSim_+3A_a">a</code></td>
<td>
<p>numveric vector of length k+1 that contains the correlations between the variables in each block (the last block contains uncorrelated variables); by default is (0.9, 0.5, 0)</p>
</td></tr>
<tr><td><code id="dataSim_+3A_sd">SD</code></td>
<td>
<p>numveric vector of length k+1 that contains the standard deviation of the variables in each block (the last block contains uncorrelated variables); by default is (10, 5, 2)</p>
</td></tr>
<tr><td><code id="dataSim_+3A_eps">eps</code></td>
<td>
<p>proportion of outliers, default is 0</p>
</td></tr>
<tr><td><code id="dataSim_+3A_eta">eta</code></td>
<td>
<p>parameter that contols the outlyingness, default is 25</p>
</td></tr>
<tr><td><code id="dataSim_+3A_setting">setting</code></td>
<td>
<p>type of outliers: <code>setting</code>=&quot;1&quot; generates the outliers which are outlying in the first two variables in the second block; <code>setting</code>=&quot;2&quot; generates
score outliers; <code>setting</code>=&quot;3&quot; generates the orthogonal outliers which are easy to detect (the setting used in Hubert, et al (2016)); default is &quot;3&quot;</p>
</td></tr>
<tr><td><code id="dataSim_+3A_seed">seed</code></td>
<td>
<p>random seed used to simulate the data</p>
</td></tr>
<tr><td><code id="dataSim_+3A_vc">vc</code></td>
<td>
<p>controls the direction of the score outliers within the PC subspace, default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components <br />
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>generated data matrix</p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>row indices of outliers</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Correlation matrix of the data</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>Covariance matrix of the data</p>
</td></tr>
</table>

<hr>
<h2 id='Glass'>Glass data</h2><span id='topic+Glass'></span>

<h3>Description</h3>

<p>Glass data of Lemberge et al. (2000) containing Electron Probe X-ray Microanalysis (EPXMA)
intensities for different wavelengths of 16â€“17th century archaeological glass vessels. This dataset was also used in Hubert et al. (2005) and Hubert et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Glass
</code></pre>


<h3>Format</h3>

<p>A data frame with columns:
</p>

<p>A data frame with 180 observations and 750 variables. These variables correspond to
EPXMA intensities for different wavelengths and are indicated by <code>V1</code>, <code>V2</code>, ..., <code>V750</code>.
</p>


<h3>Source</h3>

<p>Lemberge, P., De Raedt, I., Janssens, K. H., Wei, F., and Van Espen, P. J. (2000), &ldquo;Quantitative Z-Analysis of the 16&ndash;17th Century Archaelogical Glass Vessels using PLS Regression of EPXMA and <code class="reqn">\mu</code>-XRF Data,&quot; <em>Journal of Chemometrics</em>, 14, 751&ndash;763.
</p>


<h3>References</h3>

<p>Hubert, M., Rousseeuw, P. J., and Vanden Branden, K. (2005), &ldquo;ROBPCA: A New Approach to Robust Principal Component Analysis,&rdquo; <em>Technometrics</em>, 47, 64&ndash;79.
</p>
<p>Hubert, M., Reynkens, T., Schmitt, E. and Verdonck, T. (2016), &ldquo;Sparse PCA for High-Dimensional Data With Outliers,&rdquo; <em>Technometrics</em>, 58, 424&ndash;434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(Glass)

## End(Not run)
</code></pre>

<hr>
<h2 id='ltspca'>Principal Component Analysis Based on Least Trimmed Squaers (LTS-PCA)</h2><span id='topic+ltspca'></span>

<h3>Description</h3>

<p>the function that computes LTS-PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltspca(x, q, alpha = 0.5, b.choice = NULL, tol = 1e-06, N1 = 3,
  N2 = 2, N2bis = 10, Npc = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltspca_+3A_x">x</code></td>
<td>
<p>the input data matrix</p>
</td></tr>
<tr><td><code id="ltspca_+3A_q">q</code></td>
<td>
<p>the dimension of the PC subspace</p>
</td></tr>
<tr><td><code id="ltspca_+3A_alpha">alpha</code></td>
<td>
<p>the robust parameter which takes value between 0 to 0.5, default is 0.5</p>
</td></tr>
<tr><td><code id="ltspca_+3A_b.choice">b.choice</code></td>
<td>
<p>intial loading matrix; by default is NULL and the deterministic starting values will be computed by the algorithm</p>
</td></tr>
<tr><td><code id="ltspca_+3A_tol">tol</code></td>
<td>
<p>convergence criterion</p>
</td></tr>
<tr><td><code id="ltspca_+3A_n1">N1</code></td>
<td>
<p>the number controls the updates for a without updating b in the concentration step</p>
</td></tr>
<tr><td><code id="ltspca_+3A_n2">N2</code></td>
<td>
<p>the number controls outer loop in the concentration step</p>
</td></tr>
<tr><td><code id="ltspca_+3A_n2bis">N2bis</code></td>
<td>
<p>the number controls the outer loop for the selected b</p>
</td></tr>
<tr><td><code id="ltspca_+3A_npc">Npc</code></td>
<td>
<p>the number controls the inner loop</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object of class &quot;ltspca&quot; is returned <br />
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p>the unnormalized loading matrix</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the center estimate</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>
<p>if the observation in included in the h-subset <code>ws</code>=1; otherwise <code>ws</code>=0</p>
</td></tr>
<tr><td><code>best.cand</code></td>
<td>
<p>the method which computes the best deterministic starting value in the concentration step</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cevallos Valdiviezo
</p>


<h3>References</h3>

<p>Cevallos Valdiviezo, H., Van Aelst, S. (2019), &ldquo; Fast computation of robust subspace estimators&rdquo;, <em>Computational Statistics &amp; Data Analysis</em>, 134, 171&ndash;185.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ltspcaM &lt;- ltspca(x = x, q = 2, alpha = 0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='ltsspca'>Sparse Principal Component Analysis Based on Least Trimmed Squaers (LTS-SPCA)</h2><span id='topic+ltsspca'></span>

<h3>Description</h3>

<p>the function that computes the initial LTS-SPCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltsspca(x, kmax, alpha = 0.5, mu.choice = NULL, l.search = NULL,
  ls.min = 1, tol = 1e-06, N1 = 3, N2 = 2, N2bis = 10,
  Npc = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltsspca_+3A_x">x</code></td>
<td>
<p>the input data matrix</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_kmax">kmax</code></td>
<td>
<p>the maximal number of PCs searched by the intial LTS-SPCA</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_alpha">alpha</code></td>
<td>
<p>the robust parameter which takes value between 0 to 0.5, default is 0.5</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_mu.choice">mu.choice</code></td>
<td>
<p>the center estimate fixed by the user; by default, the center will be estimated automatically by the algorithm</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_l.search">l.search</code></td>
<td>
<p>a list of length kmax which contains the search grids chosen by the user; default is NULL</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_ls.min">ls.min</code></td>
<td>
<p>the smallest grid step when searching for the sparsity of each PC; default is 1</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_tol">tol</code></td>
<td>
<p>convergence criterion</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_n1">N1</code></td>
<td>
<p>the number controls the updates for a without updating b in the concentration step for LTS-PCA</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_n2">N2</code></td>
<td>
<p>the number controls outer loop in the concentration step for LTS-PCA</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_n2bis">N2bis</code></td>
<td>
<p>the number controls the outer loop for the selected b for both LTS-PCA and LTS-SPCA</p>
</td></tr>
<tr><td><code id="ltsspca_+3A_npc">Npc</code></td>
<td>
<p>the number controls the inner loop for both LTS-PCA and LTS-SPCA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object of class &quot;ltsspca&quot; is returned <br />
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>the initially estimated loading matrix by LTS-SPCA</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the center estimates associated with each PC</p>
</td></tr>
<tr><td><code>spca.it</code></td>
<td>
<p>the list that contains the results of LTS-SPCA when searching for the individual PCs</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>the list that contains the final search grid for each PC direction</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yixin Wang
</p>


<h3>References</h3>

<p>Wang, Y., Van Aelst, S. (2019), &ldquo; Sparse Principal Component Based On Least Trimmed Squares&rdquo;, <em>Technometrics, accepted</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mvtnorm)
dataM &lt;- dataSim(n = 200, p = 20, bLength = 4, a = c(0.9, 0.5, 0),
                SD = c(10, 5, 2), eps = 0, seed = 123)
x &lt;- dataM$data
ltsspcaMI &lt;- ltsspca(x = x, kmax = 5, alpha = 0.5)
ltsspcaMR &lt;- ltsspcaRw(x = x, obj = ltsspcaMI, k = 2, alpha = 0.5)
matplot(ltsspcaMR$loadings,type="b",ylab="Loadings")
</code></pre>

<hr>
<h2 id='ltsspcaRw'>Reweighted LTS-SPCA</h2><span id='topic+ltsspcaRw'></span>

<h3>Description</h3>

<p>the function that computes the reweighted LTS-SPCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltsspcaRw(x, obj, k = NULL, alpha = 0.5, co.sd = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltsspcaRw_+3A_x">x</code></td>
<td>
<p>the input data matrix</p>
</td></tr>
<tr><td><code id="ltsspcaRw_+3A_obj">obj</code></td>
<td>
<p>initial LTS-SPCA object given by ltsspca function</p>
</td></tr>
<tr><td><code id="ltsspcaRw_+3A_k">k</code></td>
<td>
<p>dimension of the PC subspace; by default is NULL then k takes the value of kmax in the initial LTS-SPCA</p>
</td></tr>
<tr><td><code id="ltsspcaRw_+3A_alpha">alpha</code></td>
<td>
<p>the robust parameter which takes value between 0 to 0.5, default is 0.5</p>
</td></tr>
<tr><td><code id="ltsspcaRw_+3A_co.sd">co.sd</code></td>
<td>
<p>cutoff value for score outlier weight, default is 0.25</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object of class &quot;ltsspcaRw&quot; is returned <br />
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>the sparse loading matrix estimated with reweighted LTS-SPCA</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>the estimated score matrix</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the estimated eigenvalues</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the center estimate</p>
</td></tr>
<tr><td><code>rw.obj</code></td>
<td>
<p>the list that contains the results of sPCA_rSVD on the reduced data</p>
</td></tr>
<tr><td><code>od</code></td>
<td>
<p>the orthonal distances with respect to the initially estimated PC subspace with all the noisy variables removed</p>
</td></tr>
<tr><td><code>co.od</code></td>
<td>
<p>the cutoff value for the orthogonal distances</p>
</td></tr>
<tr><td><code>ws.od</code></td>
<td>
<p>if the observation is outlying in the orthgonal complement of the initially estimated PC subspace <code>ws.od</code>=0; otherwise <code>ws.od</code>=1</p>
</td></tr>
<tr><td><code>sc.wt</code></td>
<td>
<p>the score outlier weight, which is compared with 0.25 (by default) to flag score outliers</p>
</td></tr>
<tr><td><code>co.sd</code></td>
<td>
<p>the cutoff value for score outlier weight, default is 0.25</p>
</td></tr>
<tr><td><code>ws.sd</code></td>
<td>
<p>if the observation is outlying with the PC subspace <code>ws.sd</code>=0; otherwise <code>ws.sd</code>=1</p>
</td></tr>
<tr><td><code>sc.out</code></td>
<td>
<p>the retruned object when computing the score outlier weights</p>
</td></tr>
</table>

<hr>
<h2 id='mydiagPlot'>Make diagnostic plot using the estimated PC subspace</h2><span id='topic+mydiagPlot'></span>

<h3>Description</h3>

<p>Make diagnostic plot using the estimated PC subspace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mydiagPlot(x, obj, k, alpha = 0.5, co.sd = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mydiagPlot_+3A_x">x</code></td>
<td>
<p>the input data matrix</p>
</td></tr>
<tr><td><code id="mydiagPlot_+3A_obj">obj</code></td>
<td>
<p>the returned output from rwltsspca</p>
</td></tr>
<tr><td><code id="mydiagPlot_+3A_k">k</code></td>
<td>
<p>dimension of the PC subspace</p>
</td></tr>
<tr><td><code id="mydiagPlot_+3A_alpha">alpha</code></td>
<td>
<p>the robust parameter which takes value between 0 to 0.5, default is 0.5</p>
</td></tr>
<tr><td><code id="mydiagPlot_+3A_co.sd">co.sd</code></td>
<td>
<p>cutoff value for score outlier weight, default is 0.25</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the diagnostics of outliers <br />
</p>
<table>
<tr><td><code>od</code></td>
<td>
<p>the orthgonal distances with respect to the k-dimensional PC subspace</p>
</td></tr>
<tr><td><code>ws.od</code></td>
<td>
<p>if the observation is outlying in the orthgonal complement of the PC subspace <code>ws.od</code>=0; otherwise <code>ws.sd</code>=1</p>
</td></tr>
<tr><td><code>co.od</code></td>
<td>
<p>the cutoff value for orthogonal distances</p>
</td></tr>
<tr><td><code>sc.wt</code></td>
<td>
<p>the score outlier weight, which is compared with 0.25 (by default) to flag score outliers</p>
</td></tr>
<tr><td><code>ws.sd</code></td>
<td>
<p>if the observation is outlying with the PC subspace <code>ws.sd</code>=0; otherwise <code>ws.sd</code>=1</p>
</td></tr>
<tr><td><code>co.sd</code></td>
<td>
<p>the cutoff value for score outlier weight, default is 0.25</p>
</td></tr>
<tr><td><code>sc.out</code></td>
<td>
<p>the retruned object when computing the score outlier weights</p>
</td></tr>
</table>

<hr>
<h2 id='sPCA_rSVD'>Sparse Principal Component Analysis via Regularized Singular Value Decompsition (sPCA-rSVD)</h2><span id='topic+sPCA_rSVD'></span>

<h3>Description</h3>

<p>the function that computes sPCA_rSVD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sPCA_rSVD(x, k, method = "hard", center = FALSE, scale = FALSE,
  l.search = NULL, ls.min = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sPCA_rSVD_+3A_x">x</code></td>
<td>
<p>the input data matrix</p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_k">k</code></td>
<td>
<p>the maximal number of PC's to seach for in the initial stage</p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_method">method</code></td>
<td>
<p>threshold method used in the algorithm; If <code>method = "hard"</code> (defauls), the hard threshold function is used;
if <code>method = "soft"</code>, the soft threshold function is used; if <code>method = "scad"</code>, the scad threshold function is used</p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_center">center</code></td>
<td>
<p>if <code>center = TRUE</code> the data will be centered by the columnwise means; default is <code>center = FALSE</code></p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_scale">scale</code></td>
<td>
<p>if <code>scale = TRUE</code> the data will be scaled by the columnwise standard deviations; default is <code>scaled = FALSE</code></p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_l.search">l.search</code></td>
<td>
<p>a list of length kmax which contains the search grids chosen by the user; default is NULL</p>
</td></tr>
<tr><td><code id="sPCA_rSVD_+3A_ls.min">ls.min</code></td>
<td>
<p>the smallest grid step when searching for the sparsity of each PC; default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;sPCA_rSVD&quot; is returned <br />
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>the sparse loading matrix estimated with sPCA_rSVD</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>the estimated score matrix</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the estimated eigenvalues</p>
</td></tr>
<tr><td><code>spca.it</code></td>
<td>
<p>the list that contains the results of sPCA_rSVD when searching for the individual PCs</p>
</td></tr>
<tr><td><code>ls</code></td>
<td>
<p>the list that contains the final search grid for each PC direction</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shen, H. and Huang, J. (2008), &ldquo;Sparse principal component anlysis via regularized low rank matrix decomposition&rdquo;, <em>Journal of Multivariate Analysis</em>, 99, 1015&ndash;1034.
</p>
<p>Shen, D., Shen, H., and Marron, J. (2013). &ldquo;Consistency of sparse PCA in high dimensional low sample size context&rdquo;, <em>Journal of Multivariate Analysis</em>, 115, 315&ndash;333.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nonrobM &lt;- sPCA_rSVD(x = x, k = 2, center =  T, scale = F)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
