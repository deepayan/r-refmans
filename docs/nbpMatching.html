<!DOCTYPE html><html><head><title>Help for package nbpMatching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nbpMatching}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nbpMatching-package'><p>Nonbipartite Matching</p></a></li>
<li><a href='#assign.grp'><p>Random Group Assignment</p></a></li>
<li><a href='#distancematrix'><p>Distance matrix</p></a></li>
<li><a href='#fill.missing'><p>Data Imputation</p></a></li>
<li><a href='#gendistance'><p>Generate a Distance Matrix</p></a></li>
<li><a href='#get.sets'><p>Get named sets of matches</p></a></li>
<li><a href='#make.phantoms'><p>Add Phantom Rows and Columns</p></a></li>
<li><a href='#nbpMatching-internal'><p>Internal nbpMatching objects.</p></a></li>
<li><a href='#nonbimatch'><p>Nonbipartite Matching</p></a></li>
<li><a href='#qom'><p>Quality of Match</p></a></li>
<li><a href='#quantile+2Cdistancematrix-method'><p>Quantile for upper-triangular values in distance matrix</p></a></li>
<li><a href='#scalar.dist'><p>Calculate scalar distance</p></a></li>
<li><a href='#subsetMatches'><p>Subset Matches</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Optimal Non-Bipartite Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Cole Beck [aut, cre],
  Bo Lu [aut],
  Robert Greevy [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cole Beck &lt;cole.beck@vumc.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform non-bipartite matching and matched randomization. A
    "bipartite" matching utilizes two separate groups, e.g. smokers being
    matched to nonsmokers or cases being matched to controls. A "non-bipartite"
    matching creates mates from one big group, e.g. 100 hospitals being
    randomized for a two-arm cluster randomized trial or 5000 children who
    have been exposed to various levels of secondhand smoke and are being
    paired to form a greater exposure vs. lesser exposure comparison. At the
    core of a non-bipartite matching is a N x N distance matrix for N potential
    mates. The distance between two units expresses a measure of similarity or
    quality as mates (the lower the better). The 'gendistance()' and
    'distancematrix()' functions assist in creating this. The 'nonbimatch()'
    function creates the matching that minimizes the total sum of distances
    between mates; hence, it is referred to as an "optimal" matching. The
    'assign.grp()' function aids in performing a matched randomization. Note
    bipartite matching can be performed using the prevent option in
    'gendistance()'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, Hmisc, MASS, utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://biostat.app.vumc.org/wiki/Main/MatchedRandomization">https://biostat.app.vumc.org/wiki/Main/MatchedRandomization</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'distancematrix.R' 'nonbimatch.R' 'assign.grp.R'
'fill.missing.R' 'gendistance.R' 'make.phantoms.R'
'nbpmatching-package.R' 'qom.R' 'quantile.R' 'subsetMatches.R'
'utils.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 17:48:02 UTC; beckca</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nbpMatching-package'>Nonbipartite Matching</h2><span id='topic+nbpMatching-package'></span><span id='topic+nbpMatching'></span>

<h3>Description</h3>

<p>This package will take an input distance matrix and generate the set of
pairwise matches that minimizes the sum of distances between the pairs by
running nonbimatch.
</p>


<h3>Details</h3>

<p>The most current documentation is available at
<a href="https://biostat.app.vumc.org/wiki/Main/MatchedRandomization">https://biostat.app.vumc.org/wiki/Main/MatchedRandomization</a>.
</p>


<h3>Author(s)</h3>

<p>Bo Lu, Robert Greevy, Cole Beck
</p>
<p>Maintainer: Cole Beck <a href="mailto:cole.beck@vumc.org">cole.beck@vumc.org</a>
</p>


<h3>References</h3>

<p>Lu B, Greevy R, Xu X, Beck C. Optimal Nonbipartite Matching and
its Statistical Applications. The American Statistician. Vol. 65, no. 1. :
21-30. 2011.
</p>
<p>Greevy RA Jr, Grijalva CG, Roumie CL, Beck C, Hung AM, Murff HJ, Liu X,
Griffin MR. Reweighted Mahalanobis distance matching for cluster-randomized
trials with missing data. Pharmacoepidemiol Drug Saf. 2012 May;21 Suppl
2:148-54. doi: 10.1002/pds.3260.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://biostat.app.vumc.org/wiki/Main/MatchedRandomization">https://biostat.app.vumc.org/wiki/Main/MatchedRandomization</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# create a covariate matrix
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
# create distances
df.dist &lt;- gendistance(df, idcol=1)
# create distancematrix object
df.mdm &lt;- distancematrix(df.dist)
# create matches
df.match &lt;- nonbimatch(df.mdm)
# review quality of matches
df.qom &lt;- qom(df.dist$cov, df.match$matches)

# some helper functions are available
# runner -- start with the covariate, run through the entire process
df.1 &lt;- runner(df, idcol=1)
# full.qom -- start with the covariate, generate a full quality of match report
df.2 &lt;- full.qom(df)

## Not run: 
try a large matrix
nonbimatch(distancematrix(as.matrix(dist(sample(1:10^8, 5000, replace=TRUE)))))

## End(Not run)

</code></pre>

<hr>
<h2 id='assign.grp'>Random Group Assignment</h2><span id='topic+assign.grp'></span><span id='topic+assign.grp+2Cdata.frame-method'></span><span id='topic+assign.grp+2Cnonbimatch-method'></span>

<h3>Description</h3>

<p>Randomly assign each element into treatment group A or B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign.grp(matches, seed = 68, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign.grp_+3A_matches">matches</code></td>
<td>
<p>A data.frame or nonbimatch object.  Contains information on
how to match the covariate data set.</p>
</td></tr>
<tr><td><code id="assign.grp_+3A_seed">seed</code></td>
<td>
<p>Seed provided for random-number generation.  Default value of 68.</p>
</td></tr>
<tr><td><code id="assign.grp_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the matched pairs generated by nonbimatch and randomly
assigns each element to a group.
</p>


<h3>Value</h3>

<p>original data.frame with treatment group column
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonbimatch">nonbimatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df.dist &lt;- gendistance(df, idcol=1)
df.mdm &lt;- distancematrix(df.dist)
df.match &lt;- nonbimatch(df.mdm)
assign.grp(df.match)
assign.grp(df.match$matches)

</code></pre>

<hr>
<h2 id='distancematrix'>Distance matrix</h2><span id='topic+distancematrix'></span><span id='topic+distancematrix-class'></span><span id='topic+distancematrix+2Cmatrix-method'></span><span id='topic+distancematrix+2Ccharacter-method'></span><span id='topic+distancematrix+2Cdata.frame-method'></span><span id='topic+distancematrix+2Clist-method'></span>

<h3>Description</h3>

<p>The distancematrix function is used to reformat the input distance matrix
into the format required by the nonbipartite matching Fortran code. The
original matrix should have dimensions <code class="reqn">NxN</code>, where <code class="reqn">N</code> is the total
number of elements to be matched.  The matrix may be created in R and input
into the distancematrix function.  Alternately, the matrix may be read in
from a CSV file, i.e. a text file where distances in a given row are
delimited by commas.  If a list element is given, it should have a data.frame
element named &quot;dist&quot;, preferably generated by the gendistance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancematrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distancematrix_+3A_x">x</code></td>
<td>
<p>A matrix, data.frame, list or filename.  This should be an
<code class="reqn">N</code>x<code class="reqn">N</code> distance matrix for the <code class="reqn">N</code> elements to be matched.  The
values in the diagonal are ignored because an element cannot be matched to
itself.  Using zeros in the diagonal is preferable, although other values are
acceptable provided they are not so large that they distort the scaling of
the other values.</p>
</td></tr>
<tr><td><code id="distancematrix_+3A_...">...</code></td>
<td>
<p>Additional arguments, potentially used when reading in a
filename and passed into read.csv.</p>
</td></tr>
</table>


<h3>Details</h3>

 <ul>
<li><p> The distancematrix function is used to reformat the input
distance matrix into the format required by the nonbipartite matching Fortran
code.
</p>
</li>
<li><p> If an extra column or row is present, it will be converted into row
names.  In other words, if the matrix has dimensions <code class="reqn">(N+1)</code>x<code class="reqn">N</code>, or
<code class="reqn">N</code>x<code class="reqn">(N+1)</code>, then the function will take the first row, or column, as
an ID column.  If both row and column names are present, i.e. a
<code class="reqn">(N+1)</code>x<code class="reqn">(N+1)</code> matrix, the function cannot identify the names.
</p>
</li>
<li><p> If an odd number of elements exist, a ghost element, or sink, will be
created whose distance is zero to all of the other elements.  For example,
when matching 17 elements, the function will create an 18th element that
matches every element perfectly.  This sink may or not be appropriate for
your application.  Naturally, you may create sinks as needed in the distance
matrix you input to the distancematrix function.
</p>
</li>
<li><p> The elements of distancematrix may not be re-assigned once created.  In
other words, you cannot edit the formatted distance matrix.  You need to edit
the matrix being input into the distancematrix function.  </p>
</li></ul>



<h3>Value</h3>

<p>distancematrix S4 object
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nonbimatch">nonbimatch</a> <a href="#topic+gendistance">gendistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plainmatrix&lt;-as.matrix(dist(sample(1:25, 8, replace=TRUE)))
diag(plainmatrix) &lt;- 99999  # setting diagonal to an infinite distance for
                           # pedagogical reasons (the diagonal may be left
                           # as zero)
mdm&lt;-distancematrix(plainmatrix)
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df[sample(seq_len(nrow(df)), ceiling(nrow(df)*0.1)), 2] &lt;- NA
df.dist &lt;- gendistance(df, idcol=1, ndiscard=2)
mdm2 &lt;- distancematrix(df.dist)

</code></pre>

<hr>
<h2 id='fill.missing'>Data Imputation</h2><span id='topic+fill.missing'></span><span id='topic+fill.missing+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The fill.missing function uses the <code><a href="Hmisc.html#topic+transcan">transcan</a></code> function from the
<span class="pkg">Hmisc</span> package to impute values for the given data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill.missing(x, seed = 101, simplify = TRUE, idcol = "id", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill.missing_+3A_x">x</code></td>
<td>
<p>A data.frame object.  It should have missing values.</p>
</td></tr>
<tr><td><code id="fill.missing_+3A_seed">seed</code></td>
<td>
<p>Seed provided for random-number generation.  Default value of
101.</p>
</td></tr>
<tr><td><code id="fill.missing_+3A_simplify">simplify</code></td>
<td>
<p>logical: whether to remove duplicate missingness columns.</p>
</td></tr>
<tr><td><code id="fill.missing_+3A_idcol">idcol</code></td>
<td>
<p>An integer value or character string.  Indicates the column
containing IDs, specified as column index or column name.  Defaults to &quot;id&quot;,
or NA, when not found.</p>
</td></tr>
<tr><td><code id="fill.missing_+3A_...">...</code></td>
<td>
<p>Additional arguments, potentially passed to <code><a href="Hmisc.html#topic+transcan">transcan</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fill.missing function will fill the missing values within a data.frame
with the values imputed with the <code><a href="Hmisc.html#topic+transcan">transcan</a></code> function.  An idcol may be
specified to prevent including the use of IDs in the imputation.  In addition
for every column that contains missing data, a new column will be attached to
the data.frame containing an indicator of missingness.  A &quot;1&quot; indicates that
the value was missing and has been imputed.
</p>


<h3>Value</h3>

<p>data.frame with imputed values
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+transcan">transcan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df[sample(seq_len(nrow(df)), ceiling(nrow(df)*0.1)), 2] &lt;- NA
df &lt;- fill.missing(df)

</code></pre>

<hr>
<h2 id='gendistance'>Generate a Distance Matrix</h2><span id='topic+gendistance'></span><span id='topic+gendistance+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The gendistance function creates an <code class="reqn">(N+K)</code>x<code class="reqn">(N+K)</code> distance matrix
from an <code class="reqn">N</code>x<code class="reqn">P</code> covariates matrix, where <code class="reqn">N</code> is the number
of subjects, <code class="reqn">P</code> the number of covariates, and <code class="reqn">K</code> the number of
phantom subjects requested (see <code>ndiscard</code> option). Provided the
covariates' covariance matrix is invertible, the distances computed are
Mahalanobis distances, or if covariate weights are provided, Reweighted
Mahalanobis distances (see <code>weights</code> option and Greevy, et al.,
Pharmacoepidemiology and Drug Safety 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendistance(
  covariate,
  idcol = NULL,
  weights = NULL,
  prevent = NULL,
  force = NULL,
  rankcols = NULL,
  missing.weight = 0.1,
  ndiscard = 0,
  singular.method = "solve",
  talisman = NULL,
  prevent.res.match = NULL,
  outRawDist = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendistance_+3A_covariate">covariate</code></td>
<td>
<p>A data.frame object, containing the covariates of the data
set.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_idcol">idcol</code></td>
<td>
<p>An integer or column name, providing the index of the column
containing row ID's.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_weights">weights</code></td>
<td>
<p>A numeric vector, the length should match the number of
columns.  This value determines how much weight is given to each column when
generating the distance matrix.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_prevent">prevent</code></td>
<td>
<p>A vector of integers or column names, providing the index of
columns that should be used to prevent matches.  When generating the distance
matrix, elements that match on these columns are given a maximum distance.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_force">force</code></td>
<td>
<p>An integer or column name, providing the index of the column
containing information used to force pairs to match.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_rankcols">rankcols</code></td>
<td>
<p>A vector of integers or column names, providing the index of
columns that should have the rank function applied to them before generating
the distance matrix.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_missing.weight">missing.weight</code></td>
<td>
<p>A numeric value, or vector, used to generate the weight
of missingness indicator columns.  Missingness indicator columns are created
if there is missing data within the data set.  Defaults to 0.1.  If a single
value is supplied, weights are generating by multiplying this by the original
columns' weight.  If a vector is supplied, it's length should match the
number of columns with missing data, and the weight is used as is.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_ndiscard">ndiscard</code></td>
<td>
<p>An integer, providing the number of elements that should be
allowed to match phantom values.  The default value is 0.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_singular.method">singular.method</code></td>
<td>
<p>A character string, indicating the function to use
when encountering a singular matrix.  By default, <code><a href="base.html#topic+solve">solve</a></code> is called.
The alternative is to call <code><a href="MASS.html#topic+ginv">ginv</a></code> from the <span class="pkg">MASS</span> package.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_talisman">talisman</code></td>
<td>
<p>An integer or column name, providing location of talisman column.
The talisman column should only contains values of 0 and 1.  Records with zero
will match phantoms perfectly, while other records will match phantoms at max distance.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_prevent.res.match">prevent.res.match</code></td>
<td>
<p>An integer or column name, providing location of the column
containing assigned treatment groups.  This is useful in some settings, such as
trickle-in randomized trials.  When set, non-NA values from this column are
replaced with the value 1.  This prevents records with previously assigned
treatments (the &lsquo;reservior&rsquo;) from matching each other.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_outrawdist">outRawDist</code></td>
<td>
<p>a logical, indicating if the raw distance matrix should also
be returned.  The raw form is before distance modifiers such as &lsquo;prevent&rsquo;
take effect.</p>
</td></tr>
<tr><td><code id="gendistance_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a data.frame of covariates, generate a distance matrix.  Missing values
are imputed with <code><a href="#topic+fill.missing">fill.missing</a></code>.  For each column with missing
data, a missingness indicator column will be added.  Phantoms are fake
elements that perfectly match all elements.  They can be used to discard a
certain number of elements.
</p>


<h3>Value</h3>

<p>a list object with several elements
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>generated distance matrix</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariate matrix used to generate distances</p>
</td></tr>
<tr><td><code>ignored</code></td>
<td>
<p>ignored columns from original covariate matrix</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights applied to each column in covariate matrix</p>
</td></tr>
<tr><td><code>prevent</code></td>
<td>
<p>columns used to prevent matches</p>
</td></tr>
<tr><td><code>mates</code></td>
<td>
<p>index of rows that should be forced to match</p>
</td></tr>
<tr><td><code>rankcols</code></td>
<td>
<p>index of columns that should use rank</p>
</td></tr>
<tr><td><code>missing.weight</code></td>
<td>
<p>weight to apply to missingness indicator columns</p>
</td></tr>
<tr><td><code>ndiscard</code></td>
<td>
<p>number of elements that will match phantoms</p>
</td></tr>
<tr><td><code>rawDist</code></td>
<td>
<p>raw distance matrix, only provided if &lsquo;outRawDist&rsquo; is TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distancematrix">distancematrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
# add some missing data
df[sample(seq_len(nrow(df)), ceiling(nrow(df)*0.1)), 2] &lt;- NA
df.dist &lt;- gendistance(df, idcol=1, ndiscard=2)
# up-weight the second column
df.weighted &lt;- gendistance(df, idcol=1, weights=c(1,2,1), ndiscard=2, missing.weight=0.25)
df[,3] &lt;- df[,2]*2
df.sing.solve &lt;- gendistance(df, idcol=1, ndiscard=2)
df.sing.ginv &lt;- gendistance(df, idcol=1, ndiscard=2, singular.method="ginv")

</code></pre>

<hr>
<h2 id='get.sets'>Get named sets of matches</h2><span id='topic+get.sets'></span><span id='topic+get.sets+2Cdata.frame-method'></span><span id='topic+get.sets+2Cnonbimatch-method'></span>

<h3>Description</h3>

<p>Create a factor variable using the names from a matched data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sets(matches, remove.unpaired = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sets_+3A_matches">matches</code></td>
<td>
<p>A data.frame or nonbimatch object.  Contains information on
how to match the covariate data set.</p>
</td></tr>
<tr><td><code id="get.sets_+3A_remove.unpaired">remove.unpaired</code></td>
<td>
<p>A boolean value.  The default is to remove elements
matched to phantom elements.</p>
</td></tr>
<tr><td><code id="get.sets_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate a name for each pair by using the ID columns from the matched data
set.  Return a factor of these named pairs.
</p>


<h3>Value</h3>

<p>a factor vector
</p>


<h3>Author(s)</h3>

<p>Jake Bowers, <a href="http://www.jakebowers.org/">http://www.jakebowers.org/</a>, Cole Beck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df.dist &lt;- gendistance(df, idcol=1)
df.mdm &lt;- distancematrix(df.dist)
df.match &lt;- nonbimatch(df.mdm)
get.sets(df.match)
get.sets(df.match$matches)
# include the phantom match
get.sets(df.match$matches, FALSE)

</code></pre>

<hr>
<h2 id='make.phantoms'>Add Phantom Rows and Columns</h2><span id='topic+make.phantoms'></span><span id='topic+make.phantoms+2CANY+2Cmissing-method'></span><span id='topic+make.phantoms+2Cdata.frame+2Cnumeric-method'></span><span id='topic+make.phantoms+2Cmatrix+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The make.phantoms function will take an <code class="reqn">N</code>x<code class="reqn">N</code> matrix and add
<code class="reqn">NP</code> phantom elements, thus creating a matrix with <code class="reqn">N+NP</code>x<code class="reqn">N+NP</code>
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.phantoms(x, nphantoms, name = "phantom", maxval = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.phantoms_+3A_x">x</code></td>
<td>
<p>A matrix or data.frame object, with <code class="reqn">N</code>x<code class="reqn">N</code> dimensions.</p>
</td></tr>
<tr><td><code id="make.phantoms_+3A_nphantoms">nphantoms</code></td>
<td>
<p>An integer, providing the number of phantom elements to add.</p>
</td></tr>
<tr><td><code id="make.phantoms_+3A_name">name</code></td>
<td>
<p>A character string, indicating the name attribute for new
elements.  Defaults to &quot;phantom&quot;.</p>
</td></tr>
<tr><td><code id="make.phantoms_+3A_maxval">maxval</code></td>
<td>
<p>An integer value, the default value to give the pairs of
phantoms (indeces [N+1:N+NP, N+1:N+NP]), assumed to be a maximum distance.
Defaults to Inf.</p>
</td></tr>
<tr><td><code id="make.phantoms_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internal to the <code><a href="#topic+gendistance">gendistance</a></code> function, but may be
useful in manufacturing personalized distance matrices.  Phantoms are fake
elements that perfectly match all elements.  They can be used to discard a
certain number of elements.
</p>


<h3>Value</h3>

<p>a matrix or data.frame object
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendistance">gendistance</a></code> <code><a href="#topic+distancematrix">distancematrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 5x5 distance matrix
dist.mat &lt;- matrix(c(0,5,10,15,20,5,0,15,25,35,10,15,0,25,40,15,25,25,0,15,20,35,40,15,0), nrow=5)
# add one phantom element
dm.ph &lt;- make.phantoms(dist.mat, 1)
# create distancematrix object
distancematrix(dm.ph)
# add three phantoms
make.phantoms(dist.mat, 3)

</code></pre>

<hr>
<h2 id='nbpMatching-internal'>Internal nbpMatching objects.</h2><span id='topic+nbpMatching-internal'></span><span id='topic+.requireCachedGenerics'></span><span id='topic+initialize+2Cdistancematrix-method'></span><span id='topic++5B+3C-+2Cdistancematrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cdistancematrix-method'></span><span id='topic++5B+5B+3C-+2Cdistancematrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+3C-+2Cdistancematrix-method'></span><span id='topic+runner'></span><span id='topic+runner+2Cdata.frame-method'></span><span id='topic+full.qom'></span><span id='topic+full.qom+2Cdata.frame-method'></span><span id='topic+show+2Cnonbimatch-method'></span>

<h3>Description</h3>

<p>Internal nbpMatching objects.
</p>


<h3>Details</h3>

<p>This function should not be called by the user.
</p>

<hr>
<h2 id='nonbimatch'>Nonbipartite Matching</h2><span id='topic+nonbimatch'></span><span id='topic+nonbimatch+2Cdistancematrix-method'></span><span id='topic+nonbimatch-class'></span>

<h3>Description</h3>

<p>The nonbinmatch function creates the set of pairwise matches that minimizes
the sum of distances between the pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonbimatch(mdm, threshold = NA, precision = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonbimatch_+3A_mdm">mdm</code></td>
<td>
<p>A distancematrix object.  See the distancematrix function.</p>
</td></tr>
<tr><td><code id="nonbimatch_+3A_threshold">threshold</code></td>
<td>
<p>An numeric value, indicating the distance needed to create
chameleon matches.</p>
</td></tr>
<tr><td><code id="nonbimatch_+3A_precision">precision</code></td>
<td>
<p>The largest value in the matrix will have at most this many
digits.  The default value is six.</p>
</td></tr>
<tr><td><code id="nonbimatch_+3A_...">...</code></td>
<td>
<p>Additional arguments, these are not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nonbinmatch function calls the Fortran code (Derigs) and set of pairwise
matches that minimizes the sum of distances between the pairs.
</p>


<h3>Value</h3>

<p>nonbimatch S4 object with several elements
</p>
<table>
<tr><td><code>matches</code></td>
<td>
<p>data.frame containing matches</p>
</td></tr>
<tr><td><code>halves</code></td>
<td>
<p>data.frame containing each match</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>sum of the distances across all pairs</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean distance for each pair</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distancematrix">distancematrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plainmatrix&lt;-as.matrix(dist(sample(1:25, 8, replace=TRUE)))
diag(plainmatrix) &lt;- 99999  # setting diagonal to an infinite distance for
                           # pedagogical reasons (the diagonal may be left
                           # as zero)
mdm&lt;-distancematrix(plainmatrix)
res&lt;-nonbimatch(mdm)

</code></pre>

<hr>
<h2 id='qom'>Quality of Match</h2><span id='topic+qom'></span><span id='topic+qom+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+qom+2Cdata.frame+2Cnonbimatch-method'></span>

<h3>Description</h3>

<p>Quality of matches show how well matched pairs differ.  For each variable the
average distance is generated.  Each item in a pair is assigned a group and
after several iterations the quantile of these average distances is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qom(
  covariate,
  matches,
  iterations = 10000,
  probs = NA,
  use.se = FALSE,
  all.vals = FALSE,
  seed = 101,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qom_+3A_covariate">covariate</code></td>
<td>
<p>A data.frame object.</p>
</td></tr>
<tr><td><code id="qom_+3A_matches">matches</code></td>
<td>
<p>A data.frame or nonbimatch object.  Contains information on
how to match the covariate data set.</p>
</td></tr>
<tr><td><code id="qom_+3A_iterations">iterations</code></td>
<td>
<p>An integer.  Number of iterations to run, defaults to
10,000.</p>
</td></tr>
<tr><td><code id="qom_+3A_probs">probs</code></td>
<td>
<p>A numeric vector.  Probabilities to pass to the quantile
function.</p>
</td></tr>
<tr><td><code id="qom_+3A_use.se">use.se</code></td>
<td>
<p>A logical value.  Determines if the standard error should be
computed.  Default value of FALSE.</p>
</td></tr>
<tr><td><code id="qom_+3A_all.vals">all.vals</code></td>
<td>
<p>A logical value.  Determines if false matches should be
included in comparison.  Default value of FALSE.</p>
</td></tr>
<tr><td><code id="qom_+3A_seed">seed</code></td>
<td>
<p>Seed provided for random-number generation.  Default value of
101.</p>
</td></tr>
<tr><td><code id="qom_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This fuction is useful for determining the effectiveness of your weights
(when generating a distance matrix).  Weighting a variable more will lower
the average distance, but it could penalize the distance of the other
variables. Calculating the standard error requires calling
<code><a href="Hmisc.html#topic+hdquantile">hdquantile</a></code> from <span class="pkg">Hmisc</span>.  The quantiles may be slighly
different when using <code><a href="Hmisc.html#topic+hdquantile">hdquantile</a></code>.
</p>


<h3>Value</h3>

<p>a list object containing elements with quality of match information
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>data.frame with quantiles for each covariate</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>data.frame with standard error for each covariate</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>vector with standard deviate for each covariate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df.dist &lt;- gendistance(df, idcol=1)
df.mdm &lt;- distancematrix(df.dist)
df.match &lt;- nonbimatch(df.mdm)
qom(df.dist$cov, df.match)
qom(df.dist$cov, df.match$matches)

</code></pre>

<hr>
<h2 id='quantile+2Cdistancematrix-method'>Quantile for upper-triangular values in distance matrix</h2><span id='topic+quantile+2Cdistancematrix-method'></span><span id='topic+quantile'></span>

<h3>Description</h3>

<p>Extend the stats <code><a href="stats.html#topic+quantile">quantile</a></code> function for handling distancematrix objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distancematrix'
quantile(x, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile+2B2Cdistancematrix-method_+3A_x">x</code></td>
<td>
<p>A distancematrix object.</p>
</td></tr>
<tr><td><code id="quantile+2B2Cdistancematrix-method_+3A_probs">probs</code></td>
<td>
<p>numeric vector or probabilities with values in [0,1].</p>
</td></tr>
<tr><td><code id="quantile+2B2Cdistancematrix-method_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upper.triangular values of the distance matrix object are passed to the
<code><a href="#topic+quantile">quantile</a></code> function.
</p>


<h3>Value</h3>

<p>numeric vector of quantiles corresponding to the given probabilities
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plainmatrix&lt;-as.matrix(dist(sample(1:25, 8, replace=TRUE)))
mdm&lt;-distancematrix(plainmatrix)
quantile(mdm, probs=c(0.0, 0.25, 0.50, 0.75, 1.00))

</code></pre>

<hr>
<h2 id='scalar.dist'>Calculate scalar distance</h2><span id='topic+scalar.dist'></span><span id='topic+scalar.dist+2Cvector-method'></span>

<h3>Description</h3>

<p>Calculate the scalar distance between elements of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalar.dist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalar.dist_+3A_x">x</code></td>
<td>
<p>A vector of numeric values.</p>
</td></tr>
<tr><td><code id="scalar.dist_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Take the absolute difference between all elements in a vector, and return a
matrix of the distances.
</p>


<h3>Value</h3>

<p>a matrix object
</p>


<h3>Author(s)</h3>

<p>Jake Bowers, <a href="http://www.jakebowers.org/">http://www.jakebowers.org/</a>, Cole Beck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
scalar.dist(1:10)

</code></pre>

<hr>
<h2 id='subsetMatches'>Subset Matches</h2><span id='topic+subsetMatches'></span><span id='topic+subsetMatches+2Cnonbimatch-method'></span>

<h3>Description</h3>

<p>Remove unpaired or unnecessary matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetMatches(
  matches,
  phantom = TRUE,
  chameleon = TRUE,
  ghost = TRUE,
  infinite = TRUE,
  halvesOnly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetMatches_+3A_matches">matches</code></td>
<td>
<p>A nonbimatch object.</p>
</td></tr>
<tr><td><code id="subsetMatches_+3A_phantom">phantom</code></td>
<td>
<p>A logical value.  Remove elements matched to phantom elements.</p>
</td></tr>
<tr><td><code id="subsetMatches_+3A_chameleon">chameleon</code></td>
<td>
<p>A logical value.  Remove elements matched to chameleon
elements.</p>
</td></tr>
<tr><td><code id="subsetMatches_+3A_ghost">ghost</code></td>
<td>
<p>A logical value.  Remove elements matched to ghost elements.</p>
</td></tr>
<tr><td><code id="subsetMatches_+3A_infinite">infinite</code></td>
<td>
<p>A logical value.  Remove elements matched at infinite
distance. This will include elements forced to match in spite of having an
infinite distance set by the prevent option in <code><a href="#topic+gendistance">gendistance</a></code>.</p>
</td></tr>
<tr><td><code id="subsetMatches_+3A_halvesonly">halvesOnly</code></td>
<td>
<p>A logical value.  Use halves element instead of matches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a nonbimatch object, remove elements matched to phantoms, chameleons, or
ghosts.  Also remove pairs whose distance is infinite.
</p>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Author(s)</h3>

<p>Cole Beck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(id=LETTERS[1:25], val1=rnorm(25), val2=rnorm(25))
df.dist &lt;- gendistance(df, idcol=1, ndiscard=4)
df.mdm &lt;- distancematrix(df.dist)
df.match &lt;- nonbimatch(df.mdm)
subsetMatches(df.match)
subsetMatches(df.match, halvesOnly=FALSE)
subsetMatches(df.match, phantom=FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
