<!DOCTYPE html><html lang="en"><head><title>Help for package BayesCTDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesCTDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genbernoullidata'><p>Generating function for Bernoulli Data.</p></a></li>
<li><a href='#gengaussiandata'><p>Generating function for Gaussian Data.</p></a></li>
<li><a href='#genlognormaldata'><p>Generating function for Lognormal Data.</p></a></li>
<li><a href='#genpoissondata'><p>Generating function for Poisson Data.</p></a></li>
<li><a href='#genpwedata'><p>Generating function for Piece-wise Exponential Data.</p></a></li>
<li><a href='#genweibulldata'><p>Generating function for Weibull Data.</p></a></li>
<li><a href='#historic_sim'><p>Two Arm Bayesian Clinical Trial Simulation with Historical Data</p></a></li>
<li><a href='#plot.bayes_ctd_array'><p>Plot Data from Two Arm Bayesian Clinical Trial Simulation.</p></a></li>
<li><a href='#print.bayes_ctd_array'><p>Print Data from Two Arm Bayesian Clinical Trial Simulation.</p></a></li>
<li><a href='#simple_sim'><p>Two Arm Bayesian Clinical Trial Simulation without Historical Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Two Arm Bayesian Clinical Trial Design with and Without
Historical Control Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to help clinical trial researchers calculate power and sample size for two-arm Bayesian randomized clinical trials that do or do not incorporate historical control data.  At some point during the design process, a clinical trial researcher who is designing a basic two-arm Bayesian randomized clinical trial needs to make decisions about power and sample size within the context of hypothesized treatment effects.  Through simulation, the simple_sim() function will estimate power and other user specified clinical trial characteristics at user specified sample sizes given user defined scenarios about treatment effect,control group characteristics, and outcome.  If the clinical trial researcher has access to historical control data, then the researcher can design a two-arm Bayesian randomized clinical trial that incorporates the historical data.  In such a case, the researcher needs to work through the potential consequences of historical and randomized control differences on trial characteristics, in addition to working through issues regarding power in the context of sample size, treatment effect size, and outcome.  If a researcher designs a clinical trial that will incorporate historical control data, the researcher needs the randomized controls to be from the same population as the historical controls.  What if this is not the case when the designed trial is implemented?  During the design phase, the researcher needs to investigate the negative effects of possible historic/randomized control differences on power, type one error, and other trial characteristics.  Using this information, the researcher should design the trial to mitigate these negative effects.  Through simulation, the historic_sim() function will estimate power and other user specified clinical trial characteristics at user specified sample sizes given user defined scenarios about historical and randomized control differences as well as treatment effects and outcomes.  The results from historic_sim() and simple_sim() can be printed with print_table() and graphed with plot_table() methods.  Outcomes considered are Gaussian, Poisson, Bernoulli, Lognormal, Weibull, and Piecewise Exponential.  The methods are described in Eggleston et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i21">doi:10.18637/jss.v100.i21</a>&gt;.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/begglest/BayesCTDesign">https://github.com/begglest/BayesCTDesign</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/begglest/BayesCTDesign/issues">https://github.com/begglest/BayesCTDesign/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>eha (&ge; 2.9.0), ggplot2 (&ge; 2.2.1), survival (&ge; 2.41-3),
reshape2 (&ge; 1.4.3), stats (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-28 07:11:42 UTC; TEgglest</td>
</tr>
<tr>
<td>Author:</td>
<td>Barry Eggleston [cre, aut],
  Doug Wilson [aut],
  Becky McNeil [aut],
  Joseph Ibrahim [aut],
  Diane Catellier [fnd, rth, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barry Eggleston &lt;beggleston@rti.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-30 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='genbernoullidata'>Generating function for Bernoulli Data.</h2><span id='topic+genbernoullidata'></span>

<h3>Description</h3>

<p><code>genlogisticdata()</code> function used mainly internally by
<code>logistictrialsimulator()</code> function to generate data for a two-arm
clinical trial, experimental and control groups.  Can be used to generate
random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genbernoullidata(sample_size, prob1, odds_ratio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genbernoullidata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="genbernoullidata_+3A_prob1">prob1</code></td>
<td>
<p>prob parameter used in call to <code>rbinom()</code>.
Used only in control arm.</p>
</td></tr>
<tr><td><code id="genbernoullidata_+3A_odds_ratio">odds_ratio</code></td>
<td>
<p>Desired Odds Ratio between experimental and control groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genlogisticdata()</code> returns a data frame with columns: 'id', 'treatment',
and 'y'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplehistdata &lt;- genbernoullidata(sample_size=60, prob1=0.6, odds_ratio=0.6)
samplehistdata
</code></pre>

<hr>
<h2 id='gengaussiandata'>Generating function for Gaussian Data.</h2><span id='topic+gengaussiandata'></span>

<h3>Description</h3>

<p><code>gengaussiandata()</code> function used mainly internally by
<code>gaussiantrialsimulator()</code> function to generate data for a two-arm
clinical trial, experimental and control groups.  Can be used to generate
random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gengaussiandata(sample_size, mu1, mean_diff, common_sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gengaussiandata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="gengaussiandata_+3A_mu1">mu1</code></td>
<td>
<p>mean parameter used in call to <code>rnorm()</code>.
Used only in control arm.</p>
</td></tr>
<tr><td><code id="gengaussiandata_+3A_mean_diff">mean_diff</code></td>
<td>
<p>Desired Mean Difference between experimental and control groups.</p>
</td></tr>
<tr><td><code id="gengaussiandata_+3A_common_sd">common_sd</code></td>
<td>
<p>sd parameter used in call to <code>rnorm()</code>.
Used in both arms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gengaussiandata()</code> returns a data frame with columns: 'id', 'treatment',
and 'y'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplehistdata &lt;- gengaussiandata(sample_size=60, mu1=25, mean_diff=0, common_sd=3)
samplehistdata
</code></pre>

<hr>
<h2 id='genlognormaldata'>Generating function for Lognormal Data.</h2><span id='topic+genlognormaldata'></span>

<h3>Description</h3>

<p><code>genlognormaldata()</code> function used mainly internally by
<code>lognormaltrialsimulator()</code> and <code>lognormaltrialsimulatornohist()</code> functions
to generate data for a two-arm clinical trial, experimental and control groups.
Can be used to generate random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genlognormaldata(sample_size, mu1, mean_ratio, common_sd, censor_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genlognormaldata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="genlognormaldata_+3A_mu1">mu1</code></td>
<td>
<p>meanlog parameter used in call to <code>rlnorm()</code>.
Used only in control arm.</p>
</td></tr>
<tr><td><code id="genlognormaldata_+3A_mean_ratio">mean_ratio</code></td>
<td>
<p>Desired Mean Ratio between experimental and control groups.</p>
</td></tr>
<tr><td><code id="genlognormaldata_+3A_common_sd">common_sd</code></td>
<td>
<p>sdlog parameter used in call to <code>rlnorm()</code>.
Used in both arms.</p>
</td></tr>
<tr><td><code id="genlognormaldata_+3A_censor_value">censor_value</code></td>
<td>
<p>Value at which time-to-event data are right censored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genlognormaldata()</code> returns a data frame with columns: 'id', 'treatment',
'event_time', and 'status'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplehistdata &lt;- genlognormaldata(sample_size=60, mu1=1.06, mean_ratio=0.6,
                                   common_sd=1.25, censor_value=3)
samplehistdata
</code></pre>

<hr>
<h2 id='genpoissondata'>Generating function for Poisson Data.</h2><span id='topic+genpoissondata'></span>

<h3>Description</h3>

<p><code>genpoissondata()</code> function mainly used internally by
<code>poissontrialsimulator()</code> function to generate data for a two-arm
clinical trial, experimental and control groups.  Can be used to generate
random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genpoissondata(sample_size, mu1, mean_ratio)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genpoissondata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="genpoissondata_+3A_mu1">mu1</code></td>
<td>
<p>lambda parameter used in call to <code>rpois()</code>.
Used only in control arm.</p>
</td></tr>
<tr><td><code id="genpoissondata_+3A_mean_ratio">mean_ratio</code></td>
<td>
<p>Desired Mean Ratio between experimental and control groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genpoissondata()</code> returns a data frame with columns: 'id', 'treatment',
and 'y'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samplehistdata &lt;- genpoissondata(sample_size=60, mu1=1, mean_ratio=1.0)
samplehistdata
</code></pre>

<hr>
<h2 id='genpwedata'>Generating function for Piece-wise Exponential Data.</h2><span id='topic+genpwedata'></span>

<h3>Description</h3>

<p><code>genpwedata()</code> function used mainly internally by
<code>pwetrialsimulator()</code> function to generate data for a two-arm
clinical trial, experimental and control groups.  Can be used to generate
random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genpwedata(sample_size, lambda_vec, hazard_ratio, time_vec, censor_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genpwedata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="genpwedata_+3A_lambda_vec">lambda_vec</code></td>
<td>
<p>Set of lambdas passed to <code>eha::rpch()</code> through the
levels parameter.  Used only in control arm.</p>
</td></tr>
<tr><td><code id="genpwedata_+3A_hazard_ratio">hazard_ratio</code></td>
<td>
<p>Desired Hazard Ratio between experimental and control groups.</p>
</td></tr>
<tr><td><code id="genpwedata_+3A_time_vec">time_vec</code></td>
<td>
<p>Set of cutpoints passed to <code>eha::rpch()</code> through the
cuts parameter.</p>
</td></tr>
<tr><td><code id="genpwedata_+3A_censor_value">censor_value</code></td>
<td>
<p>Value at which time-to-event data are right censored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genpwedata()</code> returns a data frame with columns: 'id', 'treatment',
'event_time', 'status', and 'indicator'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nvalHC &lt;- 60
time.vec &lt;- c(0.3,0.9,1.5,2.1,2.4)
lambdaHC.vec &lt;- c(0.19,0.35,0.56,0.47,0.38,0.34)
censor.value &lt;- 3

SampleHistData &lt;- genpwedata(nvalHC, lambdaHC.vec, 1.0, time.vec, censor.value)
SampleHistData
</code></pre>

<hr>
<h2 id='genweibulldata'>Generating function for Weibull Data.</h2><span id='topic+genweibulldata'></span>

<h3>Description</h3>

<p><code>genweibulldata()</code> function used mainly internally by
<code>weibulltrialsimulator()</code> and <code>weibulltrialsimulatornohist()</code> functions
to generate data for a two-arm clinical trial, experimental and control groups.
Can be used to generate random trial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genweibulldata(sample_size, scale1, hazard_ratio, common_shape, censor_value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genweibulldata_+3A_sample_size">sample_size</code></td>
<td>
<p>Number of subjects per arm.</p>
</td></tr>
<tr><td><code id="genweibulldata_+3A_scale1">scale1</code></td>
<td>
<p>Scale parameter used in call to <code>rweibull()</code>.
Used only in control arm.</p>
</td></tr>
<tr><td><code id="genweibulldata_+3A_hazard_ratio">hazard_ratio</code></td>
<td>
<p>Desired Hazard Ratio between experimental and control groups.</p>
</td></tr>
<tr><td><code id="genweibulldata_+3A_common_shape">common_shape</code></td>
<td>
<p>Shape parameter used in call to <code>rweibull()</code>.
Used in both arms.</p>
</td></tr>
<tr><td><code id="genweibulldata_+3A_censor_value">censor_value</code></td>
<td>
<p>Value at which time-to-event data are right censored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genweibulldata()</code> returns a data frame with columns: 'id', 'treatment',
'event_time', and 'status'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SampleHistData &lt;- genweibulldata(sample_size=60, scale1=2.82487,
                                 hazard_ratio=0.6, common_shape=3,
                                 censor_value=3)
SampleHistData
</code></pre>

<hr>
<h2 id='historic_sim'>Two Arm Bayesian Clinical Trial Simulation with Historical Data</h2><span id='topic+historic_sim'></span>

<h3>Description</h3>

<p><code>historic_sim()</code> returns an S3 object of class <code>bayes_ctd_array</code>, which
will contain simulation results for power, statistic estimation, bias,
variance, and mse as requested by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>historic_sim(
  trial_reps = 100,
  outcome_type = "weibull",
  subj_per_arm = c(50, 100, 150, 200, 250),
  a0_vals = c(0, 0.33, 0.67, 1),
  effect_vals = c(0.6, 1, 1.4),
  rand_control_diff = c(0.8, 1, 1.2),
  hist_control_data = NULL,
  time_vec = NULL,
  censor_value = NULL,
  alpha = 0.05,
  get_var = FALSE,
  get_bias = FALSE,
  get_mse = FALSE,
  seedval = NULL,
  quietly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="historic_sim_+3A_trial_reps">trial_reps</code></td>
<td>
<p>Number of trials to replicate within each combination of
<code>a0_vals</code>, <code>subj_per_arm</code>, <code>effect_vals</code>, and <code>rand_control_parms</code>.
As the number of trials increases, the precision of the estimate will increase.
Default is 100.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_outcome_type">outcome_type</code></td>
<td>
<p>Outcome distribution. Must be equal to <code>weibull</code>,
<code>lognormal</code>, <code>pwe</code> (Piecewise Exponential), <code>gaussian</code>,
<code>bernoulli</code>, or <code>poisson</code>.  Default is <code>weibull</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_subj_per_arm">subj_per_arm</code></td>
<td>
<p>A vector of sample sizes, all of which must be positive
integers.  Default is <code>c(50, 100, 150, 200, 250)</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_a0_vals">a0_vals</code></td>
<td>
<p>A vector of power prior parameters ranging from 0 to 1, where 0
implies no information from historical data should be used, and 1 implies all of
the information from historical data should be used.  A value between 0 and 1
implies that a proportion of the information from historical data will be used.
Default is <code>c(0, 0.33, 0.67, 1)</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_effect_vals">effect_vals</code></td>
<td>
<p>A vector of effects that should be reasonable for the
outcome_type being studied, hazard ratios for Weibull, odds ratios for
Bernoulli, mean ratios for Poisson, etc..  When <code>effect_vals</code> contain
the null effect for a given <code>outcome_type</code>, the <code>power</code> component
of <code>data</code> will contain an estimate of Type One Error.  In order to
have a good set of Type One Error estimates, <code>trial_reps</code> need to be
at least 10,000.  In such a case, if the total number of combinations
made up from <code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code> is very large, the time to complete the simulation
can be substantial.  Default is <code>c(0.6, 1, 1.4)</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_rand_control_diff">rand_control_diff</code></td>
<td>
<p>For piecewise exponential and Weibull outcomes, this is
a vector of hazard ratios (randomized controls over historical controls)
representing differences between historical and randomized controls.  For
lognormal and Poisson outcomes, this is a vector of mean ratios (randomized
controls over historical controls).  For a Bernoulli outcome, this is a vector
of odds ratios (randomized controls over historical controls).  For a Gaussian
outcome, this is a vector of mean differences (randomized minus historical
controls). Default is <code>c(0.8, 1, 1.2)</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_hist_control_data">hist_control_data</code></td>
<td>
<p>A dataset of historical data.  Default is <code>NULL</code>.
For survival outcomes, historical datasets must have 4 columns: id, treatment,
event_time, and status.  The value of treatment should be 0.  For other
outcomes, historical datasets must have columns: id, treatment, and y.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_time_vec">time_vec</code></td>
<td>
<p>A vector of time values which are used to create time periods
within which the exponential hazard is constant.  Only used for piecewise
exponential models.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_censor_value">censor_value</code></td>
<td>
<p>A single value at which right censoring occurs when
simulating randomized subject outcomes.  Used with survival outcomes.
Default is <code>NULL</code>, where <code>NULL</code> implies no right censoring.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_alpha">alpha</code></td>
<td>
<p>A number ranging between 0 and 1 that defines the acceptable Type 1
error rate. Default is 0.05.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_get_var">get_var</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of variance
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_get_bias">get_bias</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of bias
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_get_mse">get_mse</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of MSE
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_seedval">seedval</code></td>
<td>
<p>A seed value for pseudo-random number generation.</p>
</td></tr>
<tr><td><code id="historic_sim_+3A_quietly">quietly</code></td>
<td>
<p>A TRUE/FALSE indicator of whether notes are printed
to output about simulation progress as the simulation runs.  If
running interactively in RStudio or running in the R console,
<code>quietly</code> can be set to FALSE.  If running in a Notebook or
knitr document, <code>quietly</code> needs to be set to TRUE.  Otherwise
each note will be printed on a separate line and it will take up
a lot of output space.  Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>bayes_ctd_array</code> has 6 elements: a list containing simulation
results (<code>data</code>), copies of the 4 function arguments <code>subj_per_arm</code>,
<code>a0_vals</code>, <code>effect_vals</code>, and <code>rand_control_diff</code>, and finally
a <code>objtype</code> value indicating that <code>historic_sim()</code> was used. Each element of
<code>data</code> is a four-dimensional array, where each dimension is determined by the
length of parameters <code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code>. The size of <code>data</code> depends on which results are
requested by the user. At a minimum, at least one of <code>subj_per_arm</code>,
<code>a0_vals</code>, <code>effect_vals</code>, or <code>rand_control_diff</code> must contain at
least 2 values, while the other three must contain at least 1 value. The <code>data</code>
list will always contain two elements: an array of power results (<code>power</code>) and
an array of estimation results (<code>est</code>). In addition to <code>power</code> and
<code>est</code>, data may also contain elements <code>var</code>, <code>bias</code>, or <code>mse</code>,
depending on the values of <code>get_var</code>, <code>get_bias</code>, and <code>get_mse</code>. The
values returned in <code>est</code> are in the form of hazard ratios, mean ratios, odds
ratios, or mean differences depending on the value of <code>outcome_type</code>.  For a
Gaussian outcome, the estimation results are differences in group means (experimental
group minus control group). For a logistic outcome, the estimation results are odds
ratios (experimental group over control group). For lognormal and Poisson outcomes,
the estimation results are mean ratios (experimental group over control group). For a
piecewise exponential or a Weibull outcome, the estimation results are hazard
ratios (experimental group over control group).  The values returned in <code>bias</code>,
<code>var</code>, and <code>mse</code> are on the scale of the values returned in
<code>est</code>.
</p>
<p>The object <code>bayes_ctd_array</code> has two primary methods, <code>print()</code> and
<code>plot()</code>, for printing and plotting slices of the arrays contained in
<code>bayes_ctd_array$data</code>.
</p>
<p>As dimensions of the four dimensional array increases, the time required to complete
the simulation will increase; however, it will be faster than a similar simulation
based on repeated calls to MCMC routines to analyze each simulated trial.
</p>
<p>The meaning of the estimation results, and the test used to generate power results,
depends on the outcome used. In all cases, power is based on a two-sided test
involving a (1-alpha)100% credible interval, where the interval is used to determine
if the null hypothesis should be rejected (null value outside of the interval) or
not rejected (null value inside the interval). For a Gaussian outcome, the 95%
credible interval is an interval for the difference in group means
(experimental group minus control group), and the test determines if 0 is in or
outside of the interval. For a Bernoulli outcome, the 95% credible interval
is an interval for the odds ratio (experimental group over control group),
and the test determines if 1 is in or outside of the interval. For a lognormal or
a Poisson outcome, the 95% credible interval is an interval for the mean ratio
(experimental group over control group), and the test determines if 1 is in or
outside of the interval. Finally, for a piecewise exponential or a Weibull outcome,
the 95% credible interval is an interval for the hazard ratio (experimental group
over control group), and the test determines if 1 is in or outside of the interval.
</p>
<p>Please refer to the examples for illustration of package use.
</p>


<h3>Value</h3>

<p><code>historic_sim()</code> returns an S3 object of class <code>bayes_ctd_array</code>.
As noted in details, an object of class <code>bayes_ctd_array </code>has 6 elements: a
list of simulation results (<code>data</code>), copies of the 4 function arguments
<code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code>, and finally <code>objtype</code> indicating that <code>historic_sim()</code>
was used. See details for a discussion about the contents of
<code>data</code>. Results from the simulation contained in the <code>bayes_ctd_array</code>
object can be printed or plotted using the <code>print()</code> and
<code>plot()</code> methods. The results can also be accessed using basic list
element identification and array slicing. For example, to get the 4-dimensional
array of power results from a simulation, one could use the code
<code>bayes_ctd_array$data$power</code>, where <code>bayes_ctd_array</code> is replaced
with the name of the variable containing the <code>bayes_ctd_array</code> object. If
one wanted a table of power for sample size by a0, while holding effect equal to
the first considered value and control differences equal to the second considered
value, then the code is <code>bayes_ctd_array$data$power[,,1,2]</code>, where
<code>bayes_ctd_array</code> is replaced with the name of the variable containing the
<code>bayes_ctd_array</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a sample of historical data for use in example.
set.seed(2250)
SampleHistData &lt;- genweibulldata(sample_size=60, scale1=2.82487,
                                 hazard_ratio=0.6, common_shape=3,
                                 censor_value=3)
histdata &lt;- subset(SampleHistData, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#Run a Weibull simulation, using historic_sim().
#For meaningful results, trial_reps needs to be much larger than 2.
weibull_test &lt;- historic_sim(trial_reps = 2, outcome_type = "weibull",
                             subj_per_arm = c(50, 100, 150),
                             a0_vals = c(0, 0.50, 1),
                             effect_vals = c(0.6, 1),
                             rand_control_diff = c(0.8, 1),
                             hist_control_data = histdata, time_vec = NULL,
                             censor_value = 3, alpha = 0.05, get_var = TRUE,
                             get_bias = TRUE, get_mse = TRUE, seedval=123,
                             quietly=TRUE)

#Tabulate the simulation results for power.
test_table &lt;- print(x=weibull_test, measure="power",
                    tab_type="WX|YZ", effect_val=0.6,
                    rand_control_diff_val=1.0)
print(test_table)


#Create a plot of the power simulation results.
plot(x=weibull_test, measure="power", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)
#Create a plot of the estimated hazard ratio simulation results.
plot(x=weibull_test, measure="est", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)
#Create a plot of the hazard ratio variance simulation results.
plot(x=weibull_test, measure="var", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)
#Create a plot of the hazard ratio bias simulation results.
plot(x=weibull_test, measure="bias", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)
#Create a plot of the hazard ratio mse simulation results.
plot(x=weibull_test, measure="mse", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)

#Create other power plots using different values for tab_type
plot(x=weibull_test, measure="power", tab_type="XY|WZ",
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=150,
     rand_control_diff_val=1.0)

plot(x=weibull_test, measure="power", tab_type="XZ|WY",
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=150, effect_val=0.6)

plot(x=weibull_test, measure="power", tab_type="YZ|WX",
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=150, a0_val=0.5)

plot(x=weibull_test, measure="power", tab_type="WY|XZ",
     smooth=FALSE, plot_out=TRUE, rand_control_diff_val=1, a0_val=0.5)

plot(x=weibull_test, measure="power", tab_type="WZ|XY",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6, a0_val=0.5)



#Run Poisson simulation, using historic_sim(), but set two design characteristic
# parameters to only 1 value.
#Note: historic_sim() can take a while to run.
#Generate a sample of historical poisson data for use in example.
set.seed(2250)
samplehistdata &lt;- genpoissondata(sample_size=60, mu1=1, mean_ratio=1.0)
histdata &lt;- subset(samplehistdata, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#For meaningful results, trial_reps needs to be larger than 100.
poisson_test &lt;- historic_sim(trial_reps = 100, outcome_type = "poisson",
                              subj_per_arm = c(50, 75, 100, 125, 150, 175, 200, 225, 250),
                              a0_vals = c(1),
                              effect_vals = c(0.6),
                              rand_control_diff = c(0.6, 1, 1.6),
                              hist_control_data = histdata, time_vec = NULL,
                              censor_value = 3, alpha = 0.05, get_var = TRUE,
                              get_bias = TRUE, get_mse = TRUE, seedval=123,
                              quietly=TRUE)

#Tabulate the simulation results for power.
test_table &lt;- print(x=poisson_test, measure="power",
                    tab_type=NULL)
print(test_table)

#Create a plot of the power simulation results.
plot(x=poisson_test, measure="power", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)



#At least one of subj_per_arm, a0_vals, effect_vals, or rand_control_diff
#must contain at least 2 values.
#Generate a sample of historical lognormal data for use in example.
set.seed(2250)
samplehistdata &lt;- genlognormaldata(sample_size=60, mu1=1.06, mean_ratio=0.6, common_sd=1.25,
                                   censor_value=3)
histdata &lt;- subset(samplehistdata, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#Run a Lognormal simulation, using historic_sim().
#For meaningful results, trial_reps needs to be larger than 100.
lognormal_test &lt;- historic_sim(trial_reps = 100, outcome_type = "lognormal",
                               subj_per_arm = c(25,50,75,100,125,150,175,200,225,250),
                               a0_vals = c(1.0),
                               effect_vals = c(0.6),
                               rand_control_diff = c(1.8),
                               hist_control_data = histdata, time_vec = NULL,
                               censor_value = 3, alpha = 0.05, get_var = TRUE,
                               get_bias = TRUE, get_mse = TRUE, seedval=123,
                               quietly=TRUE)

test_table &lt;- print(x=lognormal_test, measure="power",
                    tab_type=NULL)
print(test_table)
#Create a plot of the power simulation results.
plot(x=lognormal_test, measure="power", tab_type=NULL,
     smooth=TRUE, plot_out=TRUE)


</code></pre>

<hr>
<h2 id='plot.bayes_ctd_array'>Plot Data from Two Arm Bayesian Clinical Trial Simulation.</h2><span id='topic+plot.bayes_ctd_array'></span>

<h3>Description</h3>

<p><code>plot.bayes_ctd_array()</code> takes an S3 object of class <code>bayes_ctd_array</code>, and
creates a line plot from a one or two dimensional slice of the data generated by a
clinical trial simulation using <code>historic_sim()</code> or <code>simple_sim()</code>.  The
plotted results can be smoothed or unsmoothed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayes_ctd_array'
plot(
  x = NULL,
  measure = "power",
  tab_type = "WX|YZ",
  smooth = FALSE,
  plot_out = TRUE,
  subj_per_arm_val = NULL,
  a0_val = NULL,
  effect_val = NULL,
  rand_control_diff_val = NULL,
  span = 0.75,
  degree = 2,
  family = "gaussian",
  title = NULL,
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bayes_ctd_array_+3A_x">x</code></td>
<td>
<p>Name of object of class <code>bayes_ctd_array</code> containing
data from clinical trial simulation.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_measure">measure</code></td>
<td>
<p>Must be equal to <code>power</code>, <code>est</code>, <code>var</code>, <code>bias</code>,
or <code>mse</code>.  Default is <code>power</code>.  Case does not matter.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_tab_type">tab_type</code></td>
<td>
<p>A character string that must equal <code>WX|YZ</code>, <code>WY|XZ</code>,
<code>WZ|XY</code>, <code>XY|WZ</code>, <code>XZ|WY</code>, <code>YZ|WX</code>, <code>ZX|WY</code>, <code>XW|YZ</code>,
<code>YW|XZ</code>, <code>YX|WZ</code>, <code>ZW|XY</code>, <code>ZX|WY</code>, <code>ZY|WX</code> when
<code>x</code> is generated by <code>historic_sim()</code>.  Default is
<code>WX|YZ</code>.  When <code>x</code> is generated by <code>simple_sim()</code>,
<code>tab_type</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_smooth">smooth</code></td>
<td>
<p>A true/false parameter indicating whether smoothed results
should be plotted. Note, smoothing of simulation results requires the length of
<code>subj_per_arm_val</code> or <code>a0_val</code> or <code>effect_val</code> or
<code>rand_control_diff_val</code>, whichever populates the x-axis on the graph to
contain enough elements to justify the smoothing.  No checking occurs to
determine if enough elements are present to justify smoothing.  Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_plot_out">plot_out</code></td>
<td>
<p>A true/false parameter indicating whether the plot should be
produced.  This parameter is useful if the user only wants a table of smoothed
values.  Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_subj_per_arm_val">subj_per_arm_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and sample size is being held constant.
If <code>x</code> is generated by <code>historic_sim()</code> and sample size
is being held constant, <code>subj_per_arm_val</code> must equal a value submitted
to <code>historic_sim()</code> within the <code>subj_per_arm</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>subj_per_arm_val</code>
is ignored.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_a0_val">a0_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and a0, the power prior parameter, is being held
constant.  If <code>x</code> is generated by <code>historic_sim()</code> and
a0 is being held constant, <code>a0_val</code> must equal a value submitted
to <code>historic_sim()</code> within the <code>a0_val</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>a0_val</code> is
ignored.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_effect_val">effect_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and effect is being held constant.  If
<code>x</code> is generated by <code>historic_sim()</code> and effect is being
held constant, <code>effect_val</code> must equal a value submitted to
<code>historic_sim()</code> within the <code>effect_vals</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>effect_val</code> is
ignored.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_rand_control_diff_val">rand_control_diff_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is
generated by <code>historic_sim()</code> and differences between randomized
and historical controls are being held constant.  If <code>x</code>
is generated by <code>historic_sim()</code> and control differences are being
held constant, <code>rand_control_diff_val</code> must equal a value submitted to
<code>historic_sim()</code> within the <code>rand_control_diff</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>,
<code>rand_control_diff_val</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_span">span</code></td>
<td>
<p>The <code>span</code> parameter value for a call <code>loess()</code>.  Default is 0.75.  If
<code>span</code> is a single number, then that value will be used to smooth the data in all
columns of the table being plotted.  If <code>span</code> is a vector, then it must have length
equal to the number of columns being plotted.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_degree">degree</code></td>
<td>
<p>The <code>degree</code> parameter value for a call <code>loess()</code>.  Default is 2.
The value of <code>degree</code> will be used for all columns being plotted.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_family">family</code></td>
<td>
<p>The <code>family</code> parameter value for a call <code>loess()</code>.  Default is
&quot;<code>gaussian</code>&quot;.  The value of <code>family</code> will be used for all columns being plotted.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_title">title</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_ylim">ylim</code></td>
<td>
<p>Lower and upper limits for y-axis of plot.</p>
</td></tr>
<tr><td><code id="plot.bayes_ctd_array_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object of class <code>bayes_ctd_array</code> is created by <code>historic_sim()</code>,
the function <code>plot()</code> allows the user to create line plots of user-specified
1- or 2- dimensional slices of the simulation results based on slicing code
described below. If the object of class <code>bayes_ctd_array</code> is created by
<code>simple_sim()</code>, a basic plot of characteristic by sample size and effect is created.
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>simple_sim()</code>, then
all four trial characteristics (<code>subj_per_arm_val</code>, <code>a0_vals</code>,
<code>effect_val</code>, and <code>rand_control_diff_val</code>) can be ignored as can the
parameter defining what type of plot to create through the parameter <code>tab_type</code>.
A call to <code>plot()</code> will require the user to specify a measure (power, est,
var, bias, or mse).
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>historic_sim()</code>,
when calling <code>plot()</code> the user must specify a measure to plot
(power, est, var, bias, or mse) and may be required to specify a plot type through
the <code>tab_type</code> parameter.  A plot type, <code>tab_type</code>, will be required if
3 of the 4 trial characteristics are equal to a vector of 2 or more values.  This
plot type specification uses the letters W, X, Y, and Z.  The letter W represents
the subject per arm dimension.  The letter X represents the a0 dimension.  The
letter Y represents the effect dimension.  The letter Z represents the control
difference dimension.  To plot a slice of the 4-dimensional array, these letters
are put into an AB|CD pattern just like in <code>print()</code>.  The two letters
to the right of the vertical bar define which variables are held constant.  The two
letters to the left of the vertical bar define which variables are going to show up
in the plot.  The first letter defines the x-axis variable and the second letter
defines the stratification variable.  The result is a plot of power, estimate,
variance, bias, or mse by the trial characteristic represented by the first letter.
On this plot, one line will be created for each value of the trial characteristic
represented by the second letter.  For example if tab_type equals <code>WX|YZ</code>,
then effect and control differences will be held constant, while sample size will be
represented along the horizontal axis and a0 values will be represented by separate
lines.  The actual values that are plotted on the y-axis depend on what measure is
requested in the parameter <code>measure</code>.
</p>

<ul>
<li> <p><code>tab_type='WX|YZ'</code>, Sample Size by a0
</p>
</li>
<li> <p><code>tab_type='WY|XZ'</code>, Sample Size by Effect
</p>
</li>
<li> <p><code>tab_type='WZ|XY'</code>, Sample Size by Control Differences
</p>
</li>
<li> <p><code>tab_type='XY|WZ'</code>, a0 by Effect
</p>
</li>
<li> <p><code>tab_type='XZ|WY'</code>, a0 by Control Differences
</p>
</li>
<li> <p><code>tab_type='YZ|WX'</code>, Effect by Control Differences
</p>
</li>
<li> <p><code>tab_type='ZX|WY'</code>, Control Differences by a0
</p>
</li>
<li> <p><code>tab_type='XW|YZ'</code>, a0 by Sample Size
</p>
</li>
<li> <p><code>tab_type='YW|XZ'</code>, Effect by Sample Size
</p>
</li>
<li> <p><code>tab_type='YX|WZ'</code>, Effect by a0
</p>
</li>
<li> <p><code>tab_type='ZW|XY'</code>, Control Differences by Sample Size
</p>
</li>
<li> <p><code>tab_type='ZY|WX'</code>, Control Differences by Effect
</p>
</li></ul>

<p>It is very important to populate the values of <code>subj_per_arm_val</code>,
<code>a0_val</code>, <code>effect_val</code>, and <code>rand_control_diff_val</code> correctly given
the value of tab_type, when the object of class <code>bayes_ctd_array</code> is created by
<code>historic_sim()</code> and at least 3 of the four parameters have more than one
value.  On, the other hand, if 2 or more of the four parameters have only one value,
then <code>subj_per_arm_val</code>, <code>a0_vals</code>, <code>effect_val</code>,
<code>rand_control_diff_val</code>, as well as <code>tab_type</code> can be ignored.  If the last
two letters are <code>YZ</code>, then <code>effect_val</code> and <code>rand_control_diff_val</code>
must be populated.  If the last two letters are <code>XZ</code>, then <code>a0_val</code> and
<code>rand_control_diff_val</code> must be populated.  If the last two letters are <code>XY</code>,
then <code>a0_val</code> and <code>effect_val</code> must be populated.  If the last two letters
are <code>WZ</code>, then <code>sample_val</code> and <code>rand_control_diff_val</code> must be
populated.  If the last two letters are <code>WY</code>, then <code>sample_size_val</code> and
<code>effect_val</code> must be populated.  If the last two letters are <code>WX</code>, then
<code>sample_size_val</code> and <code>a0_val</code> must be populated.
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>simple_sim()</code>, the
parameters <code>tab_type</code>, <code>subj_per_arm_val</code>, <code>a0_val</code>, <code>effect_val</code>,
and <code>rand_control_diff_val</code> are ignored.
</p>


<h3>Value</h3>

<p><code>plot()</code> returns a plot for a two dimensional array of simulation
results.  If <code>smooth</code> is <code>TRUE</code>, then the plot is based on a smoothed
version of the simulation results. If <code>smooth</code> is <code>FALSE</code>, then the plot
is based on the raw data from the simulation results.  What actually is plotted
depends on the value of <code>measure</code>.  If <code>plot_out</code> is <code>FALSE</code>, the
plot is not created.  This option is useful when the user wants a table of smoothed
simulation results but does not want the plot. Smoothing of simulation results
requires the length of <code>subj_per_arm_val</code> or <code>a0_val</code> or <code>effect_val</code>
or <code>rand_control_diff_val</code>, whichever populates the x-axis on the graph to
contain enough elements to justify the smoothing.  No checking occurs to
determine if enough elements are present to justify smoothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run a Weibull simulation, using simple_sim().
#For meaningful results, trial_reps needs to be much larger than 2.
weibull_test &lt;- simple_sim(trial_reps = 2, outcome_type = "weibull",
                           subj_per_arm = c(50, 100, 150, 200),
                           effect_vals = c(0.6, 1),
                           control_parms = c(2.82487,3), time_vec = NULL,
                           censor_value = NULL, alpha = 0.05,
                           get_var = TRUE, get_bias = TRUE, get_mse = TRUE,
                           seedval=123, quietly=TRUE)

#Create a plot of the power simulation results.
plot(x=weibull_test, measure="power", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL)
#Create a plot of the hazard ratio simulation results.
plot(x=weibull_test, measure="est", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL)
#Create a plot of the hazard ratio variance simulation results.
plot(x=weibull_test, measure="var", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL)
#Create a plot of the hazard ratio bias simulation results.
plot(x=weibull_test, measure="bias", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL)
#Create a plot of the hazard ratio mse simulation results.
plot(x=weibull_test, measure="mse", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL)


#Run a second Weibull simulation, using simple_sim() and smooth the plot.
#For meaningful results, trial_reps needs to be larger than 100.
weibull_test2 &lt;- simple_sim(trial_reps = 100, outcome_type = "weibull",
                            subj_per_arm = c(50, 75, 100, 125, 150, 175, 200, 225, 250),
                            effect_vals = c(0.6, 1, 1.4),
                            control_parms = c(2.82487,3), time_vec = NULL,
                            censor_value = NULL, alpha = 0.05, get_var = TRUE,
                            get_bias = TRUE, get_mse = TRUE, seedval=123,
                            quietly=TRUE)

#Create a plot of the power simulation results.
plot(x=weibull_test2, measure="power", tab_type=NULL,
     smooth=TRUE, plot_out=TRUE, subj_per_arm_val=NULL, a0_val=NULL,
     effect_val=NULL, rand_control_diff_val=NULL, span=c(1,1,1))



#Run a third weibull simulation, using historic_sim().
#Note: historic_sim() can take a while to run.
#Generate a sample of historical data for use in example.
set.seed(2250)
SampleHistData &lt;- genweibulldata(sample_size=60, scale1=2.82487,
                                 hazard_ratio=0.6, common_shape=3,
                                 censor_value=3)
histdata &lt;- subset(SampleHistData, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#For meaningful results, trial_reps needs to be larger than 100.
weibull_test3 &lt;- historic_sim(trial_reps = 100, outcome_type = "weibull",
                              subj_per_arm = c(50, 100, 150, 200, 250),
                              a0_vals = c(0, 0.33, 0.67, 1),
                              effect_vals = c(0.6, 1, 1.4),
                              rand_control_diff = c(0.8, 1, 1.2),
                              hist_control_data = histdata, time_vec = NULL,
                              censor_value = 3, alpha = 0.05, get_var = TRUE,
                              get_bias = TRUE, get_mse = TRUE, seedval=123,
                              quietly=TRUE)

#Create a plot of the power simulation results.
plot(x=weibull_test3, measure="power", tab_type="WX|YZ",
     smooth=FALSE, plot_out=TRUE, effect_val=0.6,
     rand_control_diff_val=1.0)



#Run a Gaussian simulation, using historic_sim()
#Generate a sample of historical Gaussian data for use in example.
set.seed(2250)
samplehistdata &lt;- gengaussiandata(sample_size=60, mu1=25, mean_diff=0, common_sd=3)
histdata &lt;- subset(samplehistdata, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#For meaningful results, trial_reps needs to be larger than 100.
gaussian_test &lt;- historic_sim(trial_reps = 100, outcome_type = "gaussian",
                             subj_per_arm = c(150),
                             a0_vals = c(1.0),
                             effect_vals = c(0.15),
                             rand_control_diff = c(-4.0,-3.5,-3.0,-2.5,-2.0,
                                                   -1.5,-1.0,-0.5,0,0.5,1.0),
                             hist_control_data = histdata, time_vec = NULL,
                             censor_value = 3, alpha = 0.05, get_var = TRUE,
                             get_bias = TRUE, get_mse = TRUE, seedval=123,
                             quietly=TRUE)
test_table &lt;- print(x=gaussian_test, measure="power",
                         tab_type=NULL, effect_val=NULL,
                         subj_per_arm_val=NULL)
print(test_table)
#Create a plot of the power simulation results.
plot(x=gaussian_test, measure="power", tab_type=NULL,
     smooth=TRUE, plot_out=TRUE, effect_val=NULL,
     rand_control_diff_val=NULL)



#Generate a sample of historical pwe data for use in example.
set.seed(2250)
nvalHC &lt;- 60
time.vec &lt;- c(0.3,0.9,1.5,2.1,2.4)
lambdaHC.vec &lt;- c(0.19,0.35,0.56,0.47,0.38,0.34)
censor.value &lt;- 3

SampleHistData &lt;- genpwedata(nvalHC, lambdaHC.vec, 1.0, time.vec, censor.value)
histdata &lt;- subset(SampleHistData, subset=(treatment==0))
histdata$indicator &lt;- 2 #If set to 2, then historical controls will be collapsed with
#randomized controls, when time_vec is re-considered and
#potentially restructured.  If set to 1, then historical
#controls will be treated as a separated cohort when
#time_vec is being assessed for restructuring.
histdata$id &lt;- histdata$id+10000

#Run a pwe simulation, using historic_sim().
#For meaningful results, trial_reps needs to be larger than 100.
pwe_test &lt;- historic_sim(trial_reps = 100, outcome_type = "pwe",
                        subj_per_arm = c(25,50,75,100,125,150,175,200,225,250),
                        a0_vals = c(1.0),
                        effect_vals = c(0.6),
                        rand_control_diff = c(1.8),
                        hist_control_data = histdata, time_vec = time.vec,
                        censor_value = 3, alpha = 0.05, get_var = TRUE,
                        get_bias = TRUE, get_mse = TRUE, seedval=123,
                        quietly=TRUE)

#Create a plot of the power simulation results.
plot(x=pwe_test, measure="power", tab_type=NULL,
     smooth=TRUE, plot_out=TRUE, effect_val=NULL,
     rand_control_diff_val=NULL)


</code></pre>

<hr>
<h2 id='print.bayes_ctd_array'>Print Data from Two Arm Bayesian Clinical Trial Simulation.</h2><span id='topic+print.bayes_ctd_array'></span>

<h3>Description</h3>

<p><code>print.bayes_ctd_array()</code> takes an S3 object of class <code>bayes_ctd_array</code>, and
prints a two dimensional slice from the data generated by a clinical trial simulation
using <code>historic_sim()</code> or <code>simple_sim()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayes_ctd_array'
print(
  x = NULL,
  measure = "power",
  tab_type = "WX|YZ",
  subj_per_arm_val = NULL,
  a0_val = NULL,
  effect_val = NULL,
  rand_control_diff_val = NULL,
  print_chg_warn = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bayes_ctd_array_+3A_x">x</code></td>
<td>
<p>Name of object of class <code>bayes_ctd_array</code> containing
data from clinical trial simulation.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_measure">measure</code></td>
<td>
<p>Must be equal to <code>power</code>, <code>est</code>, <code>var</code>, <code>bias</code>,
or <code>mse</code>.  Default is <code>power</code>.  Case does not matter.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_tab_type">tab_type</code></td>
<td>
<p>A character string that must equal <code>WX|YZ</code>, <code>WY|XZ</code>,
<code>WZ|XY</code>, <code>XY|WZ</code>, <code>XZ|WY</code>, <code>YZ|WX</code>, <code>ZX|WY</code>, <code>XW|YZ</code>,
<code>YW|XZ</code>, <code>YX|WZ</code>, <code>ZW|XY</code>, <code>ZX|WY</code>, <code>ZY|WX</code> when
<code>x</code> is generated by <code>historic_sim()</code>.  Default is
<code>WX|YZ</code>.  When <code>x</code> is generated by <code>simple_sim()</code>,
<code>tab_type</code> is ignored.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_subj_per_arm_val">subj_per_arm_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and sample size is being held constant.
If <code>x</code> is generated by <code>historic_sim()</code> and sample size
is being held constant, <code>subj_per_arm_val</code> must equal a value submitted
to <code>historic_sim()</code> within the <code>subj_per_arm</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>subj_per_arm_val</code>
is ignored.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_a0_val">a0_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and a0, the power prior parameter, is being held
constant.  If <code>x</code> is generated by <code>historic_sim()</code> and
a0 is being held constant, <code>a0_val</code> must equal a value submitted
to <code>historic_sim()</code> within the <code>a0_vals</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>a0_val</code> is
ignored.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_effect_val">effect_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is generated
by <code>historic_sim()</code> and effect is being held constant.  If
<code>x</code> is generated by <code>historic_sim()</code> and effect is being
held constant, <code>effect_val</code> must equal a value submitted to
<code>historic_sim()</code> within the <code>effect_vals</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>, <code>effect_val</code> is
ignored.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_rand_control_diff_val">rand_control_diff_val</code></td>
<td>
<p>Must be non-missing, if <code>x</code> is
generated by <code>historic_sim()</code> and differences between randomized
and historical controls are being held constant.  If <code>x</code>
is generated by <code>historic_sim()</code> and control differences are being
held constant, <code>rand_control_diff_val</code> must equal a value submitted to
<code>historic_sim()</code> within the <code>rand_control_diff</code> parameter.  When
<code>x</code> is generated by <code>simple_sim()</code>,
<code>rand_control_diff_val</code> is ignored.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_print_chg_warn">print_chg_warn</code></td>
<td>
<p>A parameter not used by the user, but is used by
<code>plot()</code> to ensure warnings are not printed twice.</p>
</td></tr>
<tr><td><code id="print.bayes_ctd_array_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object of class <code>bayes_ctd_array</code> is created by <code>historic_sim()</code>,
then the function <code>print()</code> allows the user to print user-specified 1- and 2-
dimensional slices of the simulation results based on slicing code described
below.  If the object of class <code>bayes_ctd_array</code> is created by
<code>simple_sim()</code>, a basic table of characteristic by sample size and effect is created.
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>simple_sim()</code>, then
all four trial characteristics (<code>subj_per_arm_val</code>, <code>a0_vals</code>,
<code>effect_val</code>, and <code>rand_control_diff_val</code>) can be ignored, as can the
parameter defining what type of table to print, <code>tab_type</code>.  A call to
<code>print()</code> will require the user to specify a measure (power, est, var, bias,
or mse).
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>historic_sim()</code>,
a call to <code>print()</code> will require the user to specify a measure
(power, est, var, bias, or mse) and may require the user to specify a table type.
A table type, <code>tab_type</code>, will be required if 3 of the 4 trial characteristics
are equal to a vector of 2 or more values.  The table type specification
uses the letters W, X, Y, and Z.  The letter W represents the subject per arm
dimension.  The letter X represents the a0 dimension.  The letter Y represents
the effect dimension.  The letter Z represents the control difference dimension.
To define a slice of the 4-dimensional array, these letters are put into an AB|CD
pattern.  The two letters to the right of the vertical bar define which variables
are held constant.  The two letters to the left of the vertical bar define which
variables are going to show up in the rows (first letter) and in the columns (second
letter).  For example if tab_type equals <code>WX|YZ</code>, then effect and control
differences will be held constant, while sample size will be represented by the rows
in the generated table and a0 values will be represented by the columns.  The actual
values that are printed in the tables depend on what measure is requested in the
parameter <code>measure</code>.
</p>

<ul>
<li> <p><code>tab_type='WX|YZ'</code>, Sample Size by a0
</p>
</li>
<li> <p><code>tab_type='WY|XZ'</code>, Sample Size by Effect
</p>
</li>
<li> <p><code>tab_type='WZ|XY'</code>, Sample Size by Control Differences
</p>
</li>
<li> <p><code>tab_type='XY|WZ'</code>, a0 by Effect
</p>
</li>
<li> <p><code>tab_type='XZ|WY'</code>, a0 by Control Differences
</p>
</li>
<li> <p><code>tab_type='YZ|WX'</code>, Effect by Control Differences
</p>
</li>
<li> <p><code>tab_type='ZX|WY'</code>, Control Differences by a0
</p>
</li>
<li> <p><code>tab_type='XW|YZ'</code>, a0 by Sample Size
</p>
</li>
<li> <p><code>tab_type='YW|XZ'</code>, Effect by Sample Size
</p>
</li>
<li> <p><code>tab_type='YX|WZ'</code>, Effect by a0
</p>
</li>
<li> <p><code>tab_type='ZW|XY'</code>, Control Differences by Sample Size
</p>
</li>
<li> <p><code>tab_type='ZY|WX'</code>, Control Differences by Effect
</p>
</li></ul>

<p>It is very important to populate the values of <code>subj_per_arm_val</code>,
<code>a0_vals</code>, <code>effect_val</code>, and <code>rand_control_diff_val</code> correctly given
the value of tab_type, when the object of class <code>bayes_ctd_array</code> is created by
<code>historic_sim()</code> and at least 3 of the four parameters have more than one
value.  On the other hand, if 2 or more of the four parameters have only one value,
then <code>subj_per_arm_val</code>, <code>a0_vals</code>, <code>effect_val</code>,
<code>rand_control_diff_val</code>, as well as <code>tab_type</code> can be ignored.  If the last
two letters are <code>YZ</code>, then <code>effect_val</code> and <code>rand_control_diff_val</code>
must be populated.  If the last two letters are <code>XZ</code>, then <code>a0_vals</code> and
<code>rand_control_diff_val</code> must be populated.  If the last two letters are
<code>XY</code>, then <code>a0_vals</code> and <code>effect_val</code> must be populated.  If the last
two letters are <code>WZ</code>, then <code>sample_val</code> and <code>rand_control_diff_val</code>
must be populated.  If the last two letters are <code>WY</code>, then <code>sample_size_val</code>
and <code>effect_val</code> must be populated.  If the last two letters are <code>WX</code>, then
<code>sample_size_val</code> and <code>a0_vals</code> must be populated.
</p>
<p>If the object of class <code>bayes_ctd_array</code> is created by <code>simple_sim()</code>, the
parameters <code>tab_type</code>, <code>subj_per_arm_val</code>, <code>a0_vals</code>, <code>effect_val</code>,
and <code>rand_control_diff_val</code> are ignored.
</p>


<h3>Value</h3>

<p><code>print()</code> returns a two dimensional array of simulation results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run a Weibull simulation, using simple_sim().
#For meaningful results, trial_reps needs to be much larger than 2.
weibull_test &lt;- simple_sim(trial_reps = 2, outcome_type = "weibull",
                           subj_per_arm = c(50, 100, 150, 200),
                           effect_vals = c(0.6, 1, 1.4),
                           control_parms = c(2.82487,3),
                           time_vec = NULL, censor_value = NULL,
                           alpha = 0.05, get_var = TRUE,
                           get_bias = TRUE, get_mse = TRUE,
                           seedval=123, quietly=TRUE)

#Tabulate the simulation results for power.
test_table &lt;- print(x=weibull_test, measure="power",
                    tab_type=NULL, subj_per_arm_val=NULL, a0_val=NULL,
                    effect_val=NULL, rand_control_diff_val=NULL)
print(test_table)

#Tabulate the simulation results for estimates.
print(x=weibull_test, measure="est")

#Tabulate the simulation results for variance.
print(x=weibull_test, measure="var")

#Tabulate the simulation results for bias.
print(x=weibull_test, measure="bias")

#Tabulate the simulation results for mse.
print(x=weibull_test, measure="mse")


#Run another weibull simulation, using historic_sim().
#Note: historic_sim() can take a while to run.
#Generate a sample of historical data for use in example.
set.seed(2250)
SampleHistData &lt;- genweibulldata(sample_size=60, scale1=2.82487,
                                 hazard_ratio=0.6, common_shape=3,
                                 censor_value=3)
histdata &lt;- subset(SampleHistData, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#For meaningful results, trial_reps needs to be larger than 100.
weibull_test2 &lt;- historic_sim(trial_reps = 100, outcome_type = "weibull",
                              subj_per_arm = c(50, 100, 150, 200, 250),
                              a0_vals = c(0, 0.33, 0.67, 1),
                              effect_vals = c(0.6, 1, 1.4),
                              rand_control_diff = c(0.8, 1, 1.2),
                              hist_control_data = histdata, time_vec = NULL,
                              censor_value = 3, alpha = 0.05, get_var = TRUE,
                              get_bias = TRUE, get_mse = TRUE, seedval=123,
                              quietly=TRUE)

#Tabulate the simulation results for power.
test_table &lt;- print(x=weibull_test2, measure="power",
                    tab_type="WX|YZ", effect_val=0.6,
                    rand_control_diff_val=1.0)
print(test_table)

#Tabulate the simulation results for estimates.
print(x=weibull_test2, measure="est", tab_type="WX|YZ",
      effect_val=0.6, rand_control_diff_val=1.0)

#Tabulate the simulation results for variance.
print(x=weibull_test2, measure="var", tab_type="WX|YZ",
      effect_val=0.6, rand_control_diff_val=1.0)

#Tabulate the simulation results for bias.
print(x=weibull_test2, measure="bias", tab_type="WX|YZ",
      effect_val=0.6, rand_control_diff_val=1.0)

#Tabulate the simulation results for mse.
print(x=weibull_test2, measure="mse", tab_type="WX|YZ",
      effect_val=0.6, rand_control_diff_val=1.0)



#Run a Bernoulli simulation, using historic_sim().
#Generate a sample of historical Bernoulli data for use in example.
set.seed(2250)
samplehistdata &lt;- genbernoullidata(sample_size=60, prob1=0.6, odds_ratio=0.6)
histdata &lt;- subset(samplehistdata, subset=(treatment==0))
histdata$id &lt;- histdata$id+10000

#For meaningful results, trial_reps needs to be larger than 100.
bernoulli_test &lt;- historic_sim(trial_reps = 100, outcome_type = "bernoulli",
                              subj_per_arm = c(150),
                              a0_vals = c(1.0),
                              effect_vals = c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0),
                              rand_control_diff = c(1.8),
                              hist_control_data = histdata, time_vec = NULL,
                              censor_value = 3, alpha = 0.05, get_var = TRUE,
                              get_bias = TRUE, get_mse = TRUE, seedval=123,
                              quietly=TRUE)
test_table &lt;- print(x=bernoulli_test, measure="power",
                    tab_type=NULL, effect_val=NULL,
                    subj_per_arm_val=NULL)
print(test_table)

#If only one or two of the subj_per_arm, a0_vals, effect_vals, or
#rand_control_diff parameters have length greater than 1, then
#only bayes_ctd_array and measure parameters are needed.
#Tabulate the simulation results for estimates.
print(x=bernoulli_test, measure="est")

#Tabulate the simulation results for variance.
print(x=bernoulli_test, measure="var")

#Tabulate the simulation results for bias.
print(x=bernoulli_test, measure="bias")

#Tabulate the simulation results for mse.
print(x=bernoulli_test, measure="mse")


</code></pre>

<hr>
<h2 id='simple_sim'>Two Arm Bayesian Clinical Trial Simulation without Historical Data</h2><span id='topic+simple_sim'></span>

<h3>Description</h3>

<p><code>simple_sim()</code> returns an S3 object of class <code>bayes_ctd_array</code>, which
will contain simulation results for power, statistic estimation, bias, variance,
and mse as requested by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_sim(
  trial_reps = 100,
  outcome_type = "weibull",
  subj_per_arm = c(50, 100, 150, 200, 250),
  effect_vals = c(0.6, 1, 1.4),
  control_parms = NULL,
  time_vec = NULL,
  censor_value = NULL,
  alpha = 0.05,
  get_var = FALSE,
  get_bias = FALSE,
  get_mse = FALSE,
  seedval = NULL,
  quietly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple_sim_+3A_trial_reps">trial_reps</code></td>
<td>
<p>Number of trials to replicate within each combination of
<code>a0_vals</code>, <code>subj_per_arm</code>, <code>effect_vals</code>, and <code>rand_control_parms</code>.
As the number of trials increases, the precision of the estimate will increase.
Default is 100.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_outcome_type">outcome_type</code></td>
<td>
<p>Outcome distribution. Must be equal to <code>weibull</code>,
<code>lognormal</code>, <code>pwe</code> (Piecewise Exponential), <code>gaussian</code>,
<code>bernoulli</code>, or <code>poisson</code>.  Default is <code>weibull</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_subj_per_arm">subj_per_arm</code></td>
<td>
<p>A vector of sample sizes, all of which must be positive
integers.  Default is <code>c(50, 100, 150, 200, 250)</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_effect_vals">effect_vals</code></td>
<td>
<p>A vector of effects that should be reasonable for the
outcome_type being studied, hazard ratios for Weibull, odds ratios for
Bernoulli, mean ratios for Poisson, etc..  When <code>effect_vals</code> contain
the null effect for a given <code>outcome_type</code>, the <code>power</code> component
of <code>data</code> will contain an estimate of Type One Error.  In order to
have a good set of Type One Error estimates, <code>trial_reps</code> need to be
at least 10,000.  In such a case, if the total number of combinations
made up from <code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code> is very large, the time to complete the simulation
can be substantial. Default is <code>c(0.6, 1, 1.4)</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_control_parms">control_parms</code></td>
<td>
<p>A vector of parameter values defining the outcome
distribution for randomized controls. See Details for what is required for
each <code>outcome_type</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_time_vec">time_vec</code></td>
<td>
<p>A vector of time values that are used to create time periods
within which the exponential hazard is constant.  Only used for piecewise
exponential models.  Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_censor_value">censor_value</code></td>
<td>
<p>A single value at which right censoring occurs when
simulating randomized subject outcomes.  Used with survival outcomes.
Default is <code>NULL</code>, where <code>NULL</code> implies no right censoring.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_alpha">alpha</code></td>
<td>
<p>A number ranging between 0 and 1 that defines the acceptable Type 1
error rate. Default is 0.05.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_get_var">get_var</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of variance
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_get_bias">get_bias</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of bias
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_get_mse">get_mse</code></td>
<td>
<p>A TRUE/FALSE indicator of whether an array of MSE
estimates will be returned.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_seedval">seedval</code></td>
<td>
<p>A seed value for pseudo-random number generation.</p>
</td></tr>
<tr><td><code id="simple_sim_+3A_quietly">quietly</code></td>
<td>
<p>A TRUE/FALSE indicator of whether notes are printed
to output about simulation progress as the simulation runs.  If
running interactively in RStudio or running in the R console,
<code>quietly</code> can be set to FALSE.  If running in a Notebook or
knitr document, <code>quietly</code> needs to be set to TRUE.  Otherwise
each note will be printed on a separate line and it will take up
a lot of output space.  Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>bayes_ctd_array</code> has 6 elements: a list containing simulation
results (<code>data</code>), copies of the 4 function arguments <code>subj_per_arm</code>,
<code>a0_vals</code>, <code>effect_vals</code>, and <code>rand_control_diff</code>, and finally
a <code>objtype</code> value indicating that <code>simple_sim()</code> was used. Each element of
<code>data</code> is a four-dimensional array, where each dimension is determined by the
length of parameters <code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code>. The size of <code>data</code> depends on which results are
requested by the user. At a minimum, at least one of <code>subj_per_arm</code>,
<code>a0_vals</code>, <code>effect_vals</code>, or <code>rand_control_diff</code> must contain at
least 2 values, while the other three must contain at least 1 value.  The <code>data</code>
list will always contain two elements: an array of power results (<code>power</code>) and
an array of estimation results (<code>est</code>).  In addition to <code>power</code> and
<code>est</code>, <code>data</code> may also contain elements <code>var</code>, <code>bias</code>, or
<code>mse</code>, depending on the values of <code>get_var</code>, <code>get_bias</code>, and
<code>get_mse</code>. The values returned in <code>est</code> are in the form of hazard ratios,
mean ratios, odds ratios, or mean differences depending on the value of
<code>outcome_type</code>.   For a Gaussian outcome, the estimation results are
differences in group means (experimental group minus control group). For a
logistic outcome, the estimation results are odds ratios (experimental group over
control group). For lognormal and Poisson outcomes, the estimation results are mean
ratios (experimental group over control group). For a piecewise exponential or a
Weibull outcome, the estimation results are hazard ratios (experimental group over
control group).  The values returned in <code>bias</code>, <code>var</code>, and <code>mse</code> are
on the scale of the values returned in <code>est</code>.
</p>
<p>The object <code>bayes_ctd_array</code> has two primary methods, <code>print()</code> and
<code>plot()</code>, for printing and plotting slices of the arrays contained in
<code>bayes_ctd_array$data</code>.
</p>
<p>As dimensions of the four dimensional array increases, the time required to complete
the simulation will increase; however, it will be faster than a similar simulation
based on repeated calls to MCMC routines to analyze each simulated trial.
</p>
<p>The meaning of the estimation results, and the test used to generate power results,
depends on the outcome used. In all cases, power is based on a two-sided test
involving a (1-alpha)100% credible interval, where the interval is used to determine
if the null hypothesis should be rejected (null value outside of the interval) or
not rejected (null value inside the interval). For a Gaussian outcome, the 95%
credible interval is an interval for the difference in group means
(experimental group minus control group), and the test determines if 0 is in or
outside of the interval. For a Bernoulli outcome, the 95% credible interval
is an interval for the odds ratio (experimental group over control group),
and the test determines if 1 is in or outside of the interval. For a lognormal or
a Poisson outcome, the 95% credible interval is an interval for the mean ratio
(experimental group over control group), and the test determines if 1 is in or
outside of the interval. Finally, for a piecewise exponential or a Weibull outcome,
the 95% credible interval is an interval for the hazard ratio (experimental group
over control group), and the test determines if 1 is in or outside of the interval.
</p>
<p>For a Gaussian outcome, the <code>control_parms</code> values should be <code>(mean, sd)</code>,
where mean is the mean parameter for the control group used in a call to <code>rnorm()</code>,
and sd is the common sd parameter for both groups used in a call to<code>rlnorm()</code>.
</p>
<p>For a Bernoulli outcome, the <code>control_parms</code> values should be <code>(prob)</code>, where
prob is the event probability for the control group used in a call to <code>rbinom()</code>.
</p>
<p>For a lognormal outcome, the <code>control_parms</code> values should be <code>(meanlog, sdlog)</code>,
where meanlog is the meanlog parameter for the control group used in a call to
<code>rlnorm()</code>, and sdlog is the common sdlog parameter for both groups used in
a call to <code>rlnorm()</code>.
</p>
<p>For a Poisson outcome, the <code>control_parms</code> value should be <code>(lambda)</code>, where
lambda is the lambda parameter for the control group used in a call to <code>rpois()</code> and
is equal to the mean of a Poisson distribution.
</p>
<p>For a Weibull outcome, the <code>control_parms</code> values should be <code>(scale, shape)</code>,
where scale is the scale parameter for the control group used in a call to
<code>rweibull()</code>, and shape is the common shape parameter for both groups used in
a call to <code>rweibull()</code>.
</p>
<p>For a piecewise exponential outcome, the <code>control_parms</code> values should be a vector
of lambdas used in a call to <code>eha::rpch()</code>.  Each element in <code>control_parms</code>
is a hazard for an interval defined by the <code>time_vec</code> parameter.
</p>
<p>Please refer to the examples for illustration of package use.
</p>


<h3>Value</h3>

<p><code>simple_sim()</code> returns an S3 object of class <code>bayes_ctd_array</code>.
As noted in Details, an object of class <code>bayes_ctd_array</code> has 6 elements: a
list containing simulation results (<code>data</code>), copies of the 4 function
arguments <code>subj_per_arm</code>, <code>a0_vals</code>, <code>effect_vals</code>, and
<code>rand_control_diff</code>, and finally <code>objtype</code> indicating that <code>simple_sim()</code>
was used. See Details for a discussion about the contents of
<code>data</code>. Results from the simulation contained in the <code>bayes_ctd_array</code>
object can be printed or plotted using the <code>print()</code> and
<code>plot()</code> methods. The results can also be accessed using basic list
element identification and array slicing. For example, to get the power results
from a simulation, one could use the code <code>bayes_ctd_array$data$power</code>, where
<code>bayes_ctd_array</code> is replaced with the name of the variable containing the
<code>bayes_ctd_array</code> object. Even though this is a 4-dimensional array, the power
results only occupy a single 2-dimensional table. To print this 2-dimensional table,
one would use the code <code>bayes_ctd_array$data$power[,1,,1]</code>, where
<code>bayes_ctd_array</code> is replaced with the name of the variable containing the
<code>bayes_ctd_array</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run a Weibull simulation, using simple_sim().
#For meaningful results, trial_reps needs to be much larger than 2.
weibull_test &lt;- simple_sim(trial_reps = 2, outcome_type = "weibull",
                           subj_per_arm = c(50, 100, 150, 200),
                           effect_vals = c(0.6, 1, 1.4),
                           control_parms = c(2.82487,3), time_vec = NULL,
                           censor_value = NULL, alpha = 0.05,
                           get_var = TRUE, get_bias = TRUE, get_mse = TRUE,
                           seedval=123, quietly=TRUE)

#Tabulate the simulation results for power.
test_table &lt;- print(x=weibull_test, measure="power",
                    tab_type=NULL, subj_per_arm_val=NULL, a0_val=NULL,
                    effect_val=NULL, rand_control_diff_val=NULL)
print(test_table)

#Create a plot of the power simulation results.
plot(x=weibull_test, measure="power", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)
#Create a plot of the estimated hazard ratio simulation results.
plot(x=weibull_test, measure="est", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)
#Create a plot of the hazard ratio variance simulation results.
plot(x=weibull_test, measure="var", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)
#Create a plot of the hazard ratio bias simulation results.
plot(x=weibull_test, measure="bias", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)
#Create a plot of the hazard ratio mse simulation results.
plot(x=weibull_test, measure="mse", tab_type=NULL,
     smooth=FALSE, plot_out=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
