<!DOCTYPE html><html><head><title>Help for package communication</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {communication}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#audio'><p>Audio features from Stephen Breyer</p></a></li>
<li><a href='#extractAudioFeatures'><p>Title</p></a></li>
<li><a href='#hmm'><p>Train a hidden Markov model with multivariate normal state distributions.</p></a></li>
<li><a href='#llh'><p>Title</p></a></li>
<li><a href='#standardizeFeatures'><p>Title</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Feature Extraction and Model Estimation for Audio of Human
Speech</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Lucas &lt;christopher.lucas@wustl.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast, easy feature extraction of human speech and model estimation
	     with hidden Markov models. Flexible extraction of phonetic features and their
	     derivatives, with necessary preprocessing options like feature standardization.
	     Communication can estimate supervised and unsupervised hidden Markov models with
	     these features, with cross validation and corrections for auto-correlation in
	     features. Methods developed in Knox and Lucas (2021) &lt;<a href="https://doi.org/10.7910%2FDVN.8BTOHQ">doi:10.7910/DVN.8BTOHQ</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), purrr, magrittr, diagram, GGally, grid,
useful, ggplot2, reshape2, tuneR, wrassp, gtools, signal, plyr,
RColorBrewer, scales, abind, igraph, gtable</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.700.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, qpdf, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-24 00:34:37 UTC; christopher</td>
</tr>
<tr>
<td>Author:</td>
<td>Dean Knox [aut],
  Christopher Lucas [aut, cre],
  Guilherme Duarte [ctb],
  Alex Shmuley [ctb],
  Vineet Bansal [ctb],
  Vadym Vashchenko [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-25 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='audio'>Audio features from Stephen Breyer</h2><span id='topic+audio'></span>

<h3>Description</h3>

<p>Features extracted from 100 randomly selected utterances by Stephen
Breyer in Supreme Court Oral Arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(audio)
</code></pre>


<h3>Format</h3>

<p>An object of class preppedAudio
</p>

<hr>
<h2 id='extractAudioFeatures'>Title</h2><span id='topic+extractAudioFeatures'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractAudioFeatures(
  wav.dir = getwd(),
  wav.fnames = NULL,
  windowSize = 25,
  windowShift = 12.5,
  windowType = "HAMMING",
  derivatives = 2,
  verbose = 1,
  recursive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAudioFeatures_+3A_wav.dir">wav.dir</code></td>
<td>
<p>Directory of wav files for featurization</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_wav.fnames">wav.fnames</code></td>
<td>
<p>If wav.dir = NULL, a list of wav files for featurization</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_windowsize">windowSize</code></td>
<td>
<p>Size of window in milliseconds</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_windowshift">windowShift</code></td>
<td>
<p>Amoung to shift window in milliseconds</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_windowtype">windowType</code></td>
<td>
<p>Window type</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_derivatives">derivatives</code></td>
<td>
<p>Include no (0), first (1), or first and second (2) derivatives of features</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Verbose printing</p>
</td></tr>
<tr><td><code id="extractAudioFeatures_+3A_recursive">recursive</code></td>
<td>
<p>Recursively traverse directory for wav files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class preppedAudio, which consists of a list
of 'data', 'files', and 'control'. 'data' is a list with
elements corresponding to audio features for each of the input
wav files, where each element is the audio features for the
respective wav file. 'files' contains metadata about each wav
file for which audio features were extracted. 'control' records
arguments passed to extractAudioFeatures().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
wav.fnames = list.files(file.path('PATH/TO/WAV/FILES'),
                        pattern = 'wav$',
                        recursive = TRUE,
                        full.names = TRUE
                        )
audio &lt;- extractAudioFeatures(wav.fnames = wav.fnames,
                              derivatives = 0
                              )

## End(Not run)

</code></pre>

<hr>
<h2 id='hmm'>Train a hidden Markov model with multivariate normal state distributions.</h2><span id='topic+hmm'></span>

<h3>Description</h3>

<p>Train a hidden Markov model with multivariate normal state distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmm(
  Xs,
  weights = NULL,
  nstates,
  par = list(),
  control = list(),
  labels = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmm_+3A_xs">Xs</code></td>
<td>
<p>List of nsequences matrices; each matrix represents one observation
sequence and is of dimension nobs x nfeatures. For a single observation
sequence, a single matrix can be provided</p>
</td></tr>
<tr><td><code id="hmm_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights, one for each observation sequence</p>
</td></tr>
<tr><td><code id="hmm_+3A_nstates">nstates</code></td>
<td>
<p>Integer; number of states</p>
</td></tr>
<tr><td><code id="hmm_+3A_par">par</code></td>
<td>
<p>List of initialization parameters; see 'Details'</p>
</td></tr>
<tr><td><code id="hmm_+3A_control">control</code></td>
<td>
<p>List of control parameters for EM steps</p>
</td></tr>
<tr><td><code id="hmm_+3A_labels">labels</code></td>
<td>
<p>List of observation labels for supervised training, with each
element corresponding to an observation sequence. Element i can either be
an vector of integer state labels in <code>1:nstates</code> or a matrix of
dimension <code>nstates</code> x <code>nrow(Xs[[i]])</code> with columns summing to 1.
If labels are supplied, E-step is suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>par</code> argument is a list of initialization parameters.
Can supply any of the following components:
</p>

<ul>
<li><p><code>method</code>
Name of method used to automatically initialize EM run. Currently only
<code>'dirichlet'</code> and <code>'random-spherical'</code> are implemented. If
provided, user-specified state distributions are ignored.
<code>'dirichlet'</code> randomly generates responsibilities which are in turn
used to calculate starting distributions. <code>'random-spherical'</code> randomly draws
nstates observations and uses their features as state means; all state covariance matrices are set to a
diagonal matrix with entries <code>method_arg</code> (default=1).

</p>
</li>
<li><p><code>method_arg</code>
Argument to supply to <code>method</code>. For <code>method='dirichlet'</code>, this
is a scalar concentration <code>alpha</code> (same value used for all states). For <code>method='random-spherical'</code>, this is a
scalar for diagonal entries of the spherical covariance matrices of the
starting distributions (after features are standardized).
<code>'dirichlet'</code> is implemented. If provided, all other arguments are ignored.

</p>
</li>
<li><p><code>resp</code>
Matrix or list of nsequences matrices with rows summing to 1; each matrix
represents one observation sequence and is of dimension nobs x nstates,
with the (t,k)-th entry giving the initial probability that the t-th
observation belongs to state k. If either <code>resp</code> or both <code>mus</code>
and <code>Sigmas</code> are not provided, responsibilities are randomly
initialized using <code>rdirichlet</code> with all shape parameters set to 10.

</p>
</li>
<li><p><code>mus</code>
List of nstates vectors with length nfeatures, each corresponding to the mean of
a state distribution

</p>
</li>
<li><p><code>Sigmas</code>
List of nstates matrices with dimension nfeatures x nfeatures, each
corresponding to the covariance matrix of a state distribution

</p>
</li>
<li><p><code>Gamma</code>
Matrix of transition probabilities with dimension nstates x nstates, with
row k representing the probabilities of each transition out of k and
summing to 1. If not supplied, each row is randomly drawn from
<code>rdirichlet</code> with all shape parameters set to 10.

</p>
</li>
<li><p><code>delta</code>
Vector of initial state probabilities, of length nstates and summing to
1. If not supplied, <code>delta</code> is set to the stationary distribution of
<code>Gamma</code>, i.e. the normalized first left eigenvector.

</p>
</li></ul>

<p>The <code>control</code> argument is a list of EM control parameters that can supply
any of the following components
</p>

<ul>
<li><p><code>lambda</code>
Ridge-like regularization parameter. <code>lambda</code> is added to each
<code>diag(Sigmas[[k]])</code> to stabilize each state's covariance matrix,
which might otherwise be numerically singular, before inverting to
calculate multivariate normal densities. Note that regularization is
applied after all features are standardized, so <code>diag(Sigmas[[k]])</code>
is unlikely to contain elements greater than 1. This parameter should be
selected through cross-validation.

</p>
</li>
<li><p><code>tol</code>
EM terminates when the improvement in the log-likelihood between
successive steps is <code>&lt; tol</code>. Defaults to 1e-6.

</p>
</li>
<li><p><code>maxiter</code>
EM terminates with a warning if <code>maxiter</code> iterations are reached
without convergence as defined by <code>tol</code>. Defaults to 100.

</p>
</li>
<li><p><code>uncollapse</code>
Threshold for detecting and resetting state distribution when they
collapse on a single point. State distributions are uncollapsed by
re-drawing <code>mus[[k]]</code> from a standard multivariate normal and
setting <code>Sigmas[[k]]</code> to the nfeatures-dimensional identity matrix.
Note that this distribution is with respect to the standardized features.

</p>
</li>
<li><p><code>standardize</code>
Whether features should be standardized. Defaults to <code>TRUE</code>. This
option also adds a small amount of noise , equal to .01 x feature
standard deviation, to observation-features that have been zeroed out
(e.g. f0 during unvoiced periods). If set to <code>FALSE</code>, it is assumed
that features have been externally standardized and zeroed-out values
handled. scaling$feature_means and scaling$feature_sds are set to 0s and
1s, respectively, and no check is done to ensure this is correct. If
features are in fact not standardized and zeroes handled, bad things will
happen and nobody will feel sorry for you.

</p>
</li>
<li><p><code>verbose</code>
Integer in 0:1. If <code>1</code>, information on the EM process is reported.
Defaults to 1.

</p>
</li></ul>



<h3>Value</h3>

<p>An object of class hmm. Contains fitted values of model
parameters, along with input values for hyperparameters and
features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('audio')
## Not run: 
mod &lt;- hmm(audio$data, nstates = 2, control = list(verbose = TRUE))

## End(Not run)

</code></pre>

<hr>
<h2 id='llh'>Title</h2><span id='topic+llh'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llh(Xs, mod, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llh_+3A_xs">Xs</code></td>
<td>
<p>List of nsequences matrices; each matrix represents one observation
sequence and is of dimension nobs x nfeatures. For a single observation
sequence, a single matrix can be provided</p>
</td></tr>
<tr><td><code id="llh_+3A_mod">mod</code></td>
<td>
<p>Model object of class 'feelr.hmm', as output by <code>hmm</code></p>
</td></tr>
<tr><td><code id="llh_+3A_control">control</code></td>
<td>
<p>List of control parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two components. <code>llhs</code> is a numeric vector of
log-likelihoods of each observation sequence in <code>Xs</code>. <code>llh_total</code>
is the log-likelihood of all observation sequences together, i.e.
<code>sum(llhs)</code>. If <code>Xs</code> is the same data that generated <code>mod</code>,
the values calculated here will be slightly lower than those output in
<code>mod$llhs</code>. This is because <code>hmm</code> estimates the starting state of
each sequence, whereas here it is assumed that the starting state is drawn
from the stationary distribution <code>mod$delta</code>.
</p>

<hr>
<h2 id='standardizeFeatures'>Title</h2><span id='topic+standardizeFeatures'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeFeatures(Xs, feature_means = NULL, feature_sds = NULL, verbose = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardizeFeatures_+3A_xs">Xs</code></td>
<td>
<p>Data</p>
</td></tr>
<tr><td><code id="standardizeFeatures_+3A_feature_means">feature_means</code></td>
<td>
<p>Numeric vector corresponding to columns of elements in Xs</p>
</td></tr>
<tr><td><code id="standardizeFeatures_+3A_feature_sds">feature_sds</code></td>
<td>
<p>Numeric vector corresponding to columns of elements in Xs. If not supplied, will be computed from Xs.</p>
</td></tr>
<tr><td><code id="standardizeFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Verbose printing</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>feature_means</code> and <code>feature_sds</code> are provided to allow
alignment of new datasets. For example, after a model is trained, new data
for prediction must be transformed in the same way as the training data to
ensure predictions are valid. If either is <code>NULL</code>, both will be
computed from <code>Xs</code> and the output will be internally standardized
(i.e., columns of <code>do.call(rbind, standardizeFeatures(Xs))</code> will be
have a mean of 0 and a standard deviation of 1).
</p>


<h3>Value</h3>

<p>Standardizes 'data' of objects of class
'preppedAudio'. Maintains structure of original object
otherwise. Is used to standardize data where the recording
environment systematically shifts audio features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('audio')
audio$data &lt;- standardizeFeatures(
    lapply(audio$data, function(x) na.omit(x))
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
