<!DOCTYPE html><html><head><title>Help for package dittoViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dittoViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barPlot'><p>Outputs a stacked bar plot to show the percent composition of samples, groups, clusters, or other groupings</p></a></li>
<li><a href='#colLevels'><p>Gives the distinct values of a column of data from the data_frame</p></a></li>
<li><a href='#dittoColors'><p>Extracts the dittoViz default colors</p></a></li>
<li><a href='#dittoExampleData'><p>Example Data Generation</p></a></li>
<li><a href='#freqPlot'><p>Plot discrete observation frequencies per sample and per grouping</p></a></li>
<li><a href='#scatterHex'><p>scatter plot where observations are grouped into hexagonal bins and then summarized</p></a></li>
<li><a href='#scatterPlot'><p>Show RNAseq data overlayed on a scatter plot</p></a></li>
<li><a href='#yPlot'><p>Plots continuous data per group on a y- (or x-) axis using customizable data representations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>User Friendly Data Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive visualization toolkit built with coders of all
    skill levels and color-vision impaired audiences in mind. It allows creation
    of finely-tuned, publication-quality figures from single function calls.
    Visualizations include scatter plots, compositional bar plots, violin, box,
    and ridge plots, and more. Customization ranges from size and title
    adjustments to discrete-group circling and labeling, hidden data overlay
    upon cursor hovering via ggplotly() conversion, and many more, all with
    simple, discrete inputs. Color blindness friendliness is powered by legend
    adjustments (enlarged keys), and by allowing the use of shapes or
    letter-overlay in addition to the carefully selected dittoColors().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENCE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cowplot, ggrepel, ggridges, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plotly, testthat (&ge; 3.0.0), ggplot.multistats,
palmerpenguins, ggrastr (&ge; 0.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dtm2451/dittoViz">https://github.com/dtm2451/dittoViz</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dtm2451/dittoViz/issues">https://github.com/dtm2451/dittoViz/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 23:16:05 UTC; dan</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Bunis <a href="https://orcid.org/0000-0002-0010-1616"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Bunis &lt;daniel.bunis@ucsf.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-02 00:00:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='barPlot'>Outputs a stacked bar plot to show the percent composition of samples, groups, clusters, or other groupings</h2><span id='topic+barPlot'></span>

<h3>Description</h3>

<p>Outputs a stacked bar plot to show the percent composition of samples, groups, clusters, or other groupings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barPlot(
  data_frame,
  var,
  group.by,
  scale = c("percent", "count"),
  split.by = NULL,
  rows.use = NULL,
  retain.factor.levels = TRUE,
  data.out = FALSE,
  data.only = FALSE,
  do.hover = FALSE,
  hover.round.digits = 5,
  color.panel = dittoColors(),
  colors = seq_along(color.panel),
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  y.breaks = NA,
  min = 0,
  max = NA,
  var.labels.rename = NULL,
  var.labels.reorder = NULL,
  x.labels = NULL,
  x.labels.rotate = TRUE,
  x.reorder = NULL,
  theme = theme_classic(),
  xlab = group.by,
  ylab = "make",
  main = "make",
  sub = NULL,
  legend.show = TRUE,
  legend.title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barPlot_+3A_data_frame">data_frame</code></td>
<td>
<p>A data_frame where columns are features and rows are observations you might wish to visualize.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_var">var</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> to quantify within x-axis groups.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_group.by">group.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> to use for separating data across discrete x-axis groups.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_scale">scale</code></td>
<td>
<p>&quot;count&quot; or &quot;percent&quot;. Sets whether data should be shown as counts versus percentage.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_split.by">split.by</code></td>
<td>
<p>1 or 2 strings denoting the name(s) of column(s) of <code>data_frame</code> containing discrete data to use for faceting / separating data points into separate plots.
</p>
<p>When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.
</p>
<p>When 1 column is named, shape control can be achieved with <code>split.nrow</code> and <code>split.ncol</code></p>
</td></tr>
<tr><td><code id="barPlot_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rownames of <code>data_frame</code> OR an integer vector specifying the row-indices of data points which should be plotted.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in <code>data_frame</code>, where <code>TRUE</code> values indicate which rows to plot.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_retain.factor.levels">retain.factor.levels</code></td>
<td>
<p>Logical which controls whether factor identities of <code>var</code> and <code>group.by</code> data should be respected.
Set to TRUE to faithfully reflect ordering of groupings encoded in factor levels,
but Note that this will also force retention of groupings that could otherwise be removed via <code>rows.use</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_data.out">data.out</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, changes the output, from the plot alone, to a list containing the plot (&quot;p&quot;) and a data.frame (&quot;data&quot;) containing the underlying data.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_data.only">data.only</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, the underlying data will be returned, but not the plot itself.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_do.hover">do.hover</code></td>
<td>
<p>Logical which sets whether the ggplot output should be converted to a ggplotly object with data about individual bars displayed when you hover your cursor over them.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_hover.round.digits">hover.round.digits</code></td>
<td>
<p>Integer number specifying the number of decimal digits to round displayed numeric values to, when <code>do.hover</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_color.panel">color.panel</code></td>
<td>
<p>String vector which sets the colors to draw from for data representation fills.
Default = <code>dittoColors()</code>.
</p>
<p>A named vector can be used if names are matched to the distinct values of the <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_colors">colors</code></td>
<td>
<p>Integer vector, the indexes / order, of colors from <code>color.panel</code> to actually use.
</p>
<p>Useful for quickly swapping around colors of the default set (when not using names for color matching).</p>
</td></tr>
<tr><td><code id="barPlot_+3A_split.nrow">split.nrow</code>, <code id="barPlot_+3A_split.ncol">split.ncol</code></td>
<td>
<p>Integers which set the dimensions of faceting/splitting when faceting by a single feature.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_split.adjust">split.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. 'list(scales = &quot;free&quot;)'.
</p>
<p>For options, when giving 1 column to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>,
OR when giving 2 columns to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_y.breaks">y.breaks</code></td>
<td>
<p>Numeric vector which sets the plot's tick marks / major gridlines. c(break1,break2,break3,etc.)</p>
</td></tr>
<tr><td><code id="barPlot_+3A_min">min</code>, <code id="barPlot_+3A_max">max</code></td>
<td>
<p>Scalars which control the zoom of the plot.
These inputs set the minimum / maximum values of the y-axis.
Default = set based on the limits of the data, 0 to 1 for <code>scale = "percent"</code>, or 0 to maximum count for 0 to 1 for <code>scale = "count"</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_var.labels.rename">var.labels.rename</code></td>
<td>
<p>String vector for renaming the distinct identities of <code>var</code>-values.
This vector must be the same length as the number of levels or unique values in the <code>var</code>-data.
</p>
<p>Hint: use <code><a href="#topic+colLevels">colLevels</a></code> or <code>unique(data_frame[,var])</code> to original values.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_var.labels.reorder">var.labels.reorder</code></td>
<td>
<p>Integer vector. A sequence of numbers, from 1 to the number of distinct <code>var</code>-value identities, for rearranging the order labels' groupings within the plot space.
</p>
<p>Method: Make a first plot without this input.
Then, treating the top-most grouping as index 1, and the bottom-most as index n.
Values of <code>var.labels.reorder</code> should be these indices, but in the order that you would like them rearranged to be.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_x.labels">x.labels</code></td>
<td>
<p>String vector which will replace the x-axis groupings' labels.
Regardless of <code>x.reorder</code>, the first component of <code>x.labels</code> sets the name for the left-most x-axis grouping.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_x.labels.rotate">x.labels.rotate</code></td>
<td>
<p>Logical which sets whether the x-axis grouping labels should be rotated.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_x.reorder">x.reorder</code></td>
<td>
<p>Integer vector. A sequence of numbers, from 1 to the number of groupings, for rearranging the order of x-axis groupings.
</p>
<p>Method: Make a first plot without this input.
Then, treating the leftmost grouping as index 1, and the rightmost as index n.
Values of <code>x.reorder</code> should be these indices, but in the order that you would like them rearranged to be.
</p>
<p>Recommendation for advanced users: If you find yourself coming back to this input too many times, an alternative solution that can be easier long-term
is to make the target data into a factor, and to put its levels in the desired order: <code>factor(data, levels = c("level1", "level2", ...))</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme which will be applied before dittoViz adjustments.
Default = <code>theme_classic()</code>.
See <a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> for other options and ideas.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_xlab">xlab</code></td>
<td>
<p>String which sets the x-axis title.
Default is <code>group.by</code> so it defaults to the name of the grouping information.
Set to <code>NULL</code> to remove.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_ylab">ylab</code></td>
<td>
<p>String which sets the y-axis title.
Default = &quot;make&quot; and if left as make, a title will be automatically generated.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_main">main</code></td>
<td>
<p>String, sets the plot title</p>
</td></tr>
<tr><td><code id="barPlot_+3A_sub">sub</code></td>
<td>
<p>String, sets the plot subtitle</p>
</td></tr>
<tr><td><code id="barPlot_+3A_legend.show">legend.show</code></td>
<td>
<p>Logical. Whether the legend should be displayed. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="barPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>String which adds a title to the legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a dataframe containing counts and percent makeup of <code>var</code> identities for each x-axis grouping (determined by the <code>group.by</code> input).
If a subset of data points to use is indicated with the <code>rows.use</code> input, only those rows of the <code>data_frame</code> are used for counts and percent makeup calculations.
In other words, the <code>row.use</code> input adjusts the universe that compositions are calculated within.
Then, a vertical bar plot is generated (<code>ggplot2::geom_col()</code>) showing either percent makeup if
<code>scale = "percent"</code>, which is the default, or raw counts if <code>scale = "count"</code>.
</p>


<h3>Value</h3>

<p>A ggplot plot where discrete data, grouped by sample, condition, cluster, etc. on the x-axis, is shown on the y-axis as either counts or percent-of-total-per-grouping in a stacked barplot.
</p>
<p>Alternatively, if <code>data.out = TRUE</code>, a list containing the plot (&quot;p&quot;) and a dataframe of the underlying data (&quot;data&quot;).
</p>
<p>Alternatively, if <code>do.hover = TRUE</code>, a plotly conversion of the ggplot output in which underlying data can be retrieved upon hovering the cursor over the plot.
</p>


<h3>Many characteristics of the plot can be adjusted using discrete inputs</h3>


<ul>
<li><p> Colors can be adjusted with <code>color.panel</code> and/or <code>colors</code>.
</p>
</li>
<li><p> y-axis zoom and tick marks can be adjusted using <code>min</code>, <code>max</code>, and <code>y.breaks</code>.
</p>
</li>
<li><p> Titles can be adjusted with <code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>, and <code>legend.title</code> arguments.
</p>
</li>
<li><p> The legend can be removed by setting <code>legend.show = FALSE</code>.
</p>
</li>
<li><p> x-axis labels and groupings can be changed / reordered using <code>x.labels</code> and <code>x.reorder</code>, and rotation of these labels can be turned off with <code>x.labels.rotate = FALSE</code>.
</p>
</li>
<li><p> y-axis <code>var</code>-group labels and their order can be changed / reordered using <code>var.labels</code> and <code>var.labels.reorder</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

# There are two main inputs for this function, in addition to 'data_frame'.
#  var = typically this will be observation-type annotations or clustering
#    This is the set of observations for which we will calculate frequencies
#    (per each unique value of this data) within each group
#  group.by = how to group observations together
barPlot(
    data_frame = example_df,
    var = "clustering",
    group.by = "groups")

# 'scale' then allows choice of scaling by 'percent' (default) or 'count'
barPlot(example_df, "clustering", group.by = "groups",
    scale = "count")

# Particular observations can be ignored from calculations and plotting using
#   the 'rows.use' input.
#   Here, we'll remove an entire "cluster" from consideration, but notice the
#     fractions will still sum to 1.
barPlot(example_df, "clustering", group.by = "groups",
    rows.use = example_df$clustering!="1")

### Accessing underlying data:
# as data.frame, with plot returned too
barPlot(example_df, "clustering", group.by = "groups",
    data.out = TRUE)
# as data.frame, no plot
barPlot(example_df, "clustering", group.by = "groups",
    data.out = TRUE,
    data.only = TRUE)
# through hovering the cursor over the relevant parts of the plot
if (requireNamespace("plotly", quietly = TRUE)) {
    barPlot(example_df, "clustering", group.by = "groups",
        do.hover = TRUE)
    }

</code></pre>

<hr>
<h2 id='colLevels'>Gives the distinct values of a column of data from the data_frame</h2><span id='topic+colLevels'></span>

<h3>Description</h3>

<p>Gives the distinct values of a column of data from the data_frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colLevels(col, data_frame, rows.use = NULL, used.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colLevels_+3A_col">col</code></td>
<td>
<p>quoted column name. the data column whose potential values should be retrieved.</p>
</td></tr>
<tr><td><code id="colLevels_+3A_data_frame">data_frame</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="colLevels_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rows names OR an integer vector specifying the indices of rows which should be included.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in the data_frame, which indicates which rows to include.</p>
</td></tr>
<tr><td><code id="colLevels_+3A_used.only">used.only</code></td>
<td>
<p>TRUE by default, for target data that are factors, whether levels nonexistent in the target data should be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String vector, the distinct values of the <code>col</code> data column (among the <code>rows.use</code> targeted rows) of <code>data_frame</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

colLevels("conditions", example_df)

# Note: Set 'used.only' (default = TRUE) to FALSE to show unused levels
#  of data that are already factors.  By default, only the used options
#  of the data will be given.
colLevels("conditions", example_df,
    rows.use = example_df$conditions!="condition1"
    )
colLevels("conditions", example_df,
    rows.use = example_df$conditions!="condition1",
    used.only = FALSE)
</code></pre>

<hr>
<h2 id='dittoColors'>Extracts the dittoViz default colors</h2><span id='topic+dittoColors'></span>

<h3>Description</h3>

<p>Creates a string vector of 40 unique colors, in hexadecimal form, repeated 100 times.
Or, if <code>get.names</code> is set to <code>TRUE</code>, outputs the names of the colors which can be helpful as reference when adjusting how colors get used.
</p>
<p>These colors are a modification of the protanope and deuteranope friendly colors from Wong, B. Nature Methods, 2011.
</p>
<p>Truly, only the first 1-7 are maximally (red-green) color-blindness friendly, but the lightened and darkened versions (plus grey) in slots 8-40 still work releatively well at extending their utility further.
Note that past 40, the colors simply repeat in order to most easily allow dittoViz visualizations to handle situations requiring even more colors.
</p>
<p>The colors are:
</p>
<p>1-7 = Suggested color panel from Wong, B. Nature Methods, 2011, minus black
</p>

<ul>
<li><p> 1- orange = &quot;#E69F00&quot;
</p>
</li>
<li><p> 2- skyBlue = &quot;#56B4E9&quot;
</p>
</li>
<li><p> 3- bluishGreen = &quot;#009E73&quot;
</p>
</li>
<li><p> 4- yellow = &quot;#F0E442&quot;
</p>
</li>
<li><p> 5- blue = &quot;#0072B2&quot;
</p>
</li>
<li><p> 6- vermillion = &quot;#D55E00&quot;
</p>
</li>
<li><p> 7- reddishPurple = &quot;#CC79A7&quot;
</p>
</li></ul>

<p>8 = gray40
</p>
<p>9-16 = 25% darker versions of colors 1-8
</p>
<p>17-24 = 25% lighter versions of colors 1-8
</p>
<p>25-32 = 40% lighter versions of colors 1-8
</p>
<p>33-40 = 40% darker versions of colors 1-8
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dittoColors(reps = 100, get.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dittoColors_+3A_reps">reps</code></td>
<td>
<p>Integer which sets how many times the original set of colors should be repeated</p>
</td></tr>
<tr><td><code id="dittoColors_+3A_get.names">get.names</code></td>
<td>
<p>Logical, whether only the names of the default dittoViz color panel should be returned instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector with length = 24.
</p>


<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dittoColors()

#To retrieve names:
dittoColors(get.names = TRUE)
</code></pre>

<hr>
<h2 id='dittoExampleData'>Example Data Generation</h2><span id='topic+dittoExampleData'></span>

<h3>Description</h3>

<p>Example Data Generation
</p>


<h3>Details</h3>

<p>This documentation point exists only to be a set source of example data for other dittoViz documentation.
Running the examples section code creates a data.frame called 'example_df' containing data of various types.
These data are randomly generated each time and simulate what a user might use as the 'data_frame' input of dittoViz visualization functions.
</p>


<h3>Value</h3>

<p>Running <code>example("dittoExampleData")</code> creates a data.frame called example_df.
</p>


<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some random data
nobs &lt;- 120

# Fake "PCA" that we'll based some other attributes on
example_pca &lt;- matrix(rnorm(nobs*2), nobs)

example_df &lt;- data.frame(
        conditions = factor(rep(c("condition1", "condition2"), each=nobs/2)),
        timepoint = rep(c("d0", "d3", "d6", "d9"), each = nobs/4),
        SNP = rep(c(rep(TRUE,7),rep(FALSE,8)), nobs/15),
        groups = sample(c("A","B","C","D"), nobs, TRUE),
        score = seq_len(nobs)/2,
        gene1 = log2(rpois(nobs, 5) +1),
        gene2 = log2(rpois(nobs, 30) +1),
        gene3 = log2(rpois(nobs, 4) +1),
        gene4 = log2(rpois(nobs, 2) +1),
        gene5 = log2(rpois(nobs, 17) +1),
        PC1 = example_pca[,1],
        PC2 = example_pca[,2],
        clustering = as.character(1*(example_pca[,1]&gt;0&amp;example_pca[,2]&gt;0) +
                       2*(example_pca[,1]&lt;0&amp;example_pca[,2]&gt;0) +
                       3*(example_pca[,1]&gt;0&amp;example_pca[,2]&lt;0) +
                       4*(example_pca[,1]&lt;0&amp;example_pca[,2]&lt;0)),
        sample = rep(1:12, each = nobs/12),
        category = rep(c("A", "B"), each = nobs/2),
        subcategory = rep(as.character(rep(1:3,4)), each = nobs/12),
        row.names = paste0("obs", 1:nobs)
        )

# cleanup
rm(example_pca, nobs)

summary(example_df)
</code></pre>

<hr>
<h2 id='freqPlot'>Plot discrete observation frequencies per sample and per grouping</h2><span id='topic+freqPlot'></span>

<h3>Description</h3>

<p>Plot discrete observation frequencies per sample and per grouping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqPlot(
  data_frame,
  var,
  sample.by = NULL,
  group.by,
  color.by = group.by,
  vars.use = NULL,
  scale = c("percent", "count"),
  max.normalize = FALSE,
  plots = c("boxplot", "jitter"),
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  rows.use = NULL,
  data.out = FALSE,
  data.only = FALSE,
  do.hover = FALSE,
  hover.round.digits = 5,
  color.panel = dittoColors(),
  colors = seq_along(color.panel),
  y.breaks = NULL,
  min = 0,
  max = NA,
  var.labels.rename = NULL,
  var.labels.reorder = NULL,
  x.labels = NULL,
  x.labels.rotate = TRUE,
  x.reorder = NULL,
  theme = theme_classic(),
  xlab = group.by,
  ylab = "make",
  main = "make",
  sub = NULL,
  jitter.size = 1,
  jitter.width = 0.2,
  jitter.color = "black",
  jitter.position.dodge = boxplot.position.dodge,
  do.raster = FALSE,
  raster.dpi = 300,
  boxplot.width = 0.4,
  boxplot.color = "black",
  boxplot.show.outliers = NA,
  boxplot.outlier.size = 1.5,
  boxplot.fill = TRUE,
  boxplot.position.dodge = vlnplot.width,
  boxplot.lineweight = 1,
  vlnplot.lineweight = 1,
  vlnplot.width = 1,
  vlnplot.scaling = "area",
  vlnplot.quantiles = NULL,
  ridgeplot.lineweight = 1,
  ridgeplot.scale = 1.25,
  ridgeplot.ymax.expansion = NA,
  ridgeplot.shape = c("smooth", "hist"),
  ridgeplot.bins = 30,
  ridgeplot.binwidth = NULL,
  add.line = NULL,
  line.linetype = "dashed",
  line.color = "black",
  legend.show = TRUE,
  legend.title = color.by
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqPlot_+3A_data_frame">data_frame</code></td>
<td>
<p>A data_frame where columns are features and rows are observations you might wish to visualize.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_var">var</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> that contains the discrete data you wish to quantify as frequencies.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_sample.by">sample.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> that contains an indicator of which sample each observation belongs to.
</p>
<p>Note that when this is not provided, there will only be one data point per grouping.
A warning can be expected then for all <code>plots</code> options except <code>"jitter"</code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_group.by">group.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> containing discrete data to use for separating the data points into groups.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_color.by">color.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> containing discrete data to use for setting data representation color fills.
This data does not need to be the same as <code>group.by</code>, which is great for highlighting supersets or subgroups when wanted, but it defaults to <code>group.by</code> so the input can often be skipped.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_vars.use">vars.use</code></td>
<td>
<p>String or string vector naming a subset of the values of <code>var</code>-data which should be shown.
If left as <code>NULL</code>, all values are shown.
</p>
<p>Hint: use <code><a href="#topic+colLevels">colLevels</a></code> or <code>unique(data_frame[,var])</code> to assess options.
</p>
<p>Note: When <code>var.labels.rename</code> is jointly utilized to update how the <code>var</code>-values are shown, the <strong>updated</strong> values must be used.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_scale">scale</code></td>
<td>
<p>&quot;count&quot; or &quot;percent&quot;. Sets whether data should be shown as counts versus percentage.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_max.normalize">max.normalize</code></td>
<td>
<p>Logical which sets whether the data for each <code>var</code>-data value (each facet) should be normalized to have the same maximum value.
</p>
<p>When set to <code>TRUE</code>, lower frequency <code>var</code>-values will make use of just as much plot space as higher frequency vars.
</p>
<p>Note: Similarly equal plot space utilization can be achieved by using <code>split.adjust = list(scales = "free_y")</code>, and that alternative route retains original values of the data.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_plots">plots</code></td>
<td>
<p>String vector which sets the types of plots to include: possibilities = &quot;jitter&quot;, &quot;boxplot&quot;, &quot;vlnplot&quot;, &quot;ridgeplot&quot;.
</p>
<p>Order matters: c(&quot;vlnplot&quot;, &quot;boxplot&quot;, &quot;jitter&quot;) will put a violin plot in the back, boxplot in the middle, and then individual dots in the front.
</p>
<p>See details section for more info.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_split.nrow">split.nrow</code>, <code id="freqPlot_+3A_split.ncol">split.ncol</code></td>
<td>
<p>Integers which set the dimensions of the facet grid.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_split.adjust">split.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting function <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>, e.g. 'list(scales = &quot;free_y&quot;)'.
</p>
<p>See <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code> for options.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rownames of <code>data_frame</code> OR an integer vector specifying the row-indices of data points which should be plotted.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in <code>data_frame</code>, where <code>TRUE</code> values indicate which rows to plot.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_data.out">data.out</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, changes the output, from the plot alone, to a list containing the plot (<code>p</code>), its underlying data (<code>data</code>).</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_data.only">data.only</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, the underlying data will be returned, but not the plot itself.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_do.hover">do.hover</code></td>
<td>
<p>Logical which sets whether the ggplot output should be converted to a ggplotly object with data about individual bars displayed when you hover your cursor over them.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_hover.round.digits">hover.round.digits</code></td>
<td>
<p>Integer number specifying the number of decimal digits to round displayed numeric values to, when <code>do.hover</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_color.panel">color.panel</code></td>
<td>
<p>String vector which sets the colors to draw from for data representation fills.
Default = <code>dittoColors()</code>.
</p>
<p>A named vector can be used if names are matched to the distinct values of the <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_colors">colors</code></td>
<td>
<p>Integer vector, the indexes / order, of colors from <code>color.panel</code> to actually use.
</p>
<p>Useful for quickly swapping around colors of the default set (when not using names for color matching).</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_y.breaks">y.breaks</code></td>
<td>
<p>Numeric vector, a set of breaks that should be used as major grid lines. c(break1,break2,break3,etc.).</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_min">min</code>, <code id="freqPlot_+3A_max">max</code></td>
<td>
<p>Scalars which control the zoom on the continuous axis of the plot.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_var.labels.rename">var.labels.rename</code></td>
<td>
<p>String vector for renaming the distinct identities of <code>var</code>-values.
This vector must be the same length as the number of levels or unique values in the <code>var</code>-data.
</p>
<p>Hint: use <code><a href="#topic+colLevels">colLevels</a></code> or <code>unique(data_frame[,var])</code> to original values.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_var.labels.reorder">var.labels.reorder</code></td>
<td>
<p>Integer vector. A sequence of numbers, from 1 to the number of distinct <code>var</code>-value identities, for rearranging the order of facets within the plot space.
</p>
<p>Method: Make a first plot without this input.
Then, treating the top-left-most grouping as index 1, and the bottom-right-most as index n.
Values of <code>var.labels.reorder</code> should be these indices, but in the order that you would like them rearranged to be.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_x.labels">x.labels</code></td>
<td>
<p>String vector, c(&quot;label1&quot;,&quot;label2&quot;,&quot;label3&quot;,...) which overrides the names of groupings.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_x.labels.rotate">x.labels.rotate</code></td>
<td>
<p>Logical which sets whether the labels should be rotated.
Default: <code>TRUE</code> for violin and box plots, but <code>FALSE</code> for ridgeplots.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_x.reorder">x.reorder</code></td>
<td>
<p>Integer vector. A sequence of numbers, from 1 to the number of groupings, for rearranging the order of x-axis groupings.
</p>
<p>Method: Make a first plot without this input.
Then, treating the leftmost grouping as index 1, and the rightmost as index n.
Values of x.reorder should be these indices, but in the order that you would like them rearranged to be.
</p>
<p>Recommendation for advanced users: If you find yourself coming back to this input too many times, an alternative solution that can be easier long-term
is to make the target data into a factor, and to put its levels in the desired order: <code>factor(data, levels = c("level1", "level2", ...))</code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme which will be applied before internal adjustments.
Default = <code>theme_classic()</code>.
See <a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> for other options and ideas.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_xlab">xlab</code></td>
<td>
<p>String which sets the grouping-axis label (=x-axis for box and violin plots, y-axis for ridgeplots).
Set to <code>NULL</code> to remove.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ylab">ylab</code></td>
<td>
<p>String, sets the continuous-axis label (=y-axis for box and violin plots, x-axis for ridgeplots).
Default = &quot;make&quot; and if left as make, this title will be automatically generated.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_main">main</code></td>
<td>
<p>String, sets the plot title. Default = &quot;make&quot; and if left as make, a title will be automatically generated.  To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_sub">sub</code></td>
<td>
<p>String, sets the plot subtitle.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_jitter.size">jitter.size</code></td>
<td>
<p>Scalar which sets the size of the jitter shapes.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_jitter.width">jitter.width</code></td>
<td>
<p>Scalar that sets the width/spread of the jitter in the x direction. Ignored in ridgeplots.
</p>
<p>Note for when <code>color.by</code> is used to split x-axis groupings into additional bins: ggplot does not shrink jitter widths accordingly, so be sure to do so yourself!
Ideally, needs to be 0.5/num_subgroups.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_jitter.color">jitter.color</code></td>
<td>
<p>String which sets the color of the jitter shapes</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_jitter.position.dodge">jitter.position.dodge</code></td>
<td>
<p>Scalar which adjusts the relative distance between jitter widths when multiple subgroups exist per <code>group.by</code> grouping (a.k.a. when <code>group.by</code> and <code>color.by</code> are not equal).
Similar to <code>boxplot.position.dodge</code> input &amp; defaults to the value of that input so that BOTH will actually be adjusted when only, say, <code>boxplot.position.dodge = 0.3</code> is given.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_do.raster">do.raster</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, rasterizes the jitter plot layer, changing it from individually encoded points to a flattened set of pixels.
This can be useful for editing in external programs (e.g. Illustrator) when there are many thousands of data points.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Number indicating dots/pixels per inch (dpi) to use for rasterization. Default = 300.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.width">boxplot.width</code></td>
<td>
<p>Scalar which sets the width/spread of the boxplot in the x direction</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.color">boxplot.color</code></td>
<td>
<p>String which sets the color of the lines of the boxplot</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.show.outliers">boxplot.show.outliers</code></td>
<td>
<p>Logical, whether outliers should by including in the boxplot.
Default is <code>FALSE</code> when there is a jitter plotted, <code>TRUE</code> if there is no jitter.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.outlier.size">boxplot.outlier.size</code></td>
<td>
<p>Scalar which adjusts the size of points used to mark outliers.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.fill">boxplot.fill</code></td>
<td>
<p>Logical, whether the boxplot should be filled in or not.
Known bug: when boxplot fill is turned off, outliers do not render.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.position.dodge">boxplot.position.dodge</code></td>
<td>
<p>Scalar which adjusts the relative distance between boxplots when multiple are drawn per grouping (a.k.a. when <code>group.by</code> and <code>color.by</code> are not equal).
By default, this input actually controls the value of <code>jitter.position.dodge</code> unless the <code>jitter</code> version is provided separately.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_boxplot.lineweight">boxplot.lineweight</code></td>
<td>
<p>Scalar which adjusts the thickness of boxplot lines.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_vlnplot.lineweight">vlnplot.lineweight</code></td>
<td>
<p>Scalar which sets the thickness of the line that outlines the violin plots.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_vlnplot.width">vlnplot.width</code></td>
<td>
<p>Scalar which sets the width/spread of violin plots in the x direction</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_vlnplot.scaling">vlnplot.scaling</code></td>
<td>
<p>String which sets how the widths of the of violin plots are set in relation to each other.
Options are &quot;area&quot;, &quot;count&quot;, and &quot;width&quot;. If the default is not right for your data, I recommend trying &quot;width&quot;.
For an explanation of each, see <code><a href="ggplot2.html#topic+geom_violin">geom_violin</a></code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_vlnplot.quantiles">vlnplot.quantiles</code></td>
<td>
<p>Single number or numeric vector of values in [0,1] naming quantiles at which to draw a horizontal line within each violin plot. Example: <code>c(0.1, 0.5, 0.9)</code></p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.lineweight">ridgeplot.lineweight</code></td>
<td>
<p>Scalar which sets the thickness of the ridgeplot outline.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.scale">ridgeplot.scale</code></td>
<td>
<p>Scalar which sets the distance/overlap between ridgeplots.
A value of 1 means the tallest density curve just touches the baseline of the next higher one.
Higher numbers lead to greater overlap.  Default = 1.25</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.ymax.expansion">ridgeplot.ymax.expansion</code></td>
<td>
<p>Scalar which adjusts the minimal space between the topmost grouping and the top of the plot in order to ensure the curve is not cut off by the plotting grid.
The larger the value, the greater the space requested.
When left as NA, dittoViz will attempt to determine an ideal value itself based on the number of groups &amp; linear interpolation between these goal posts: #groups of 3 or fewer: 0.6; #groups=12: 0.1; #groups or 34 or greater: 0.05.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.shape">ridgeplot.shape</code></td>
<td>
<p>Either &quot;smooth&quot; or &quot;hist&quot;, sets whether ridges will be smoothed (the typical, and default) versus rectangular like a histogram.
(Note: as of the time shape &quot;hist&quot; was added, combination of jittered points is not supported by the <code><a href="ggridges.html#topic+stat_binline">stat_binline</a></code> that dittoViz relies on.)</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.bins">ridgeplot.bins</code></td>
<td>
<p>Integer which sets how many chunks to break the x-axis into when <code>ridgeplot.shape = "hist"</code>.
Overridden by <code>ridgeplot.binwidth</code> when that input is provided.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_ridgeplot.binwidth">ridgeplot.binwidth</code></td>
<td>
<p>Integer which sets the width of chunks to break the x-axis into when <code>ridgeplot.shape = "hist"</code>.
Takes precedence over <code>ridgeplot.bins</code> when provided.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_add.line">add.line</code></td>
<td>
<p>numeric value(s) where one or multiple line(s) should be added</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_line.linetype">line.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.line</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_line.color">line.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.line</code> line(s)</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_legend.show">legend.show</code></td>
<td>
<p>Logical. Whether the legend should be displayed. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="freqPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>String or <code>NULL</code>, sets the title for the main legend which includes colors and data representations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a dataframe containing counts and percent makeup of <code>var</code> identities per sample if <code>sample.by</code> is given, or per group if only <code>group.by</code> is given.
<code>color.by</code> can optionally be used to add subgroupings to calculations and ultimate plots, or to convey super-groups of <code>group.by</code> groupings.
</p>
<p>Typically, <code>var</code> might target clustering or observation-type annotations, but in truth it can be given any discrete data.
</p>
<p>If a set of rows to use was indicated with the <code>rows.use</code> input, only the targeted rows are used for counts and percent makeup calculations.
In other words, the <code>row.use</code> input adjusts the universe that frequencies are calculated within.
</p>
<p>If a set of <code>var</code>-values to show is indicated with the <code>vars.use</code> input, the data.frame is trimmed at the end to include only the corresponding rows.
Thus, this input does not affect the universe for frequency calculation.
</p>
<p>If <code>max.normalized</code> is set to <code>TRUE</code>, counts and percent data are transformed to a 0-1 scale, which is one method for making better use of white space for lower frequency <code>var</code>-values.
Alternatively, <code>split.adjust = list(scales = "free_y")</code> can be used to achieve the same white-space utilization while retaining original data values.
</p>
<p>Either percent of total (<code>scale = "percent"</code>), which is the default, or counts (if <code>scale = "count"</code>)
data is then (gg)plotted with the data representation types in <code>plots</code> by utilizing the same machinery as <code><a href="#topic+yPlot">yPlot</a></code>.
Faceting by <code>var</code>-data values is utilized to achieve per <code>var</code>-value (e.g. cluster) granularity.
</p>
<p>See below for additional customization options!
</p>


<h3>Value</h3>

<p>A ggplot plot where frequencies of discrete <code>var</code>-data per sample, grouped by condition, timepoint, etc., is shown on the y-axis by a violin plot, boxplot, and/or jittered points, or on the x-axis by a ridgeplot with or without jittered points.
</p>
<p>Alternatively, if <code>data.out = TRUE</code>, a list containing the plot (&quot;p&quot;) and a dataframe of the underlying data (&quot;data&quot;).
</p>
<p>Alternatively, if <code>do.hover = TRUE</code>, a plotly conversion of the ggplot output in which underlying data can be retrieved upon hovering the cursor over the plot.
</p>


<h3>Calculation Details</h3>

<p>The function is restricted in that each samples' observations, indicated by the unique values of <code>sample.by</code>-data, must exist within single <code>group.by</code> and <code>color.by</code> groupings.
Thus, in order to ensure all valid <code>var</code>-data composition data points are generated, prior to calculations... </p>

<ul>
<li> <p><code>var</code>-data are ensured to be a factor, which ensures a calculation will be run for every <code>var</code>-value (a.k.a. cluster)
</p>
</li>
<li> <p><code>group.by</code>-data and <code>color-by</code>-data are treated as non-factor data, which ensures that calculations are run only for the groupings that each sample is associated with.
</p>
</li></ul>



<h3>Plot Customization</h3>

<p>The <code>plots</code> argument determines the types of <strong>data representation</strong> that will be generated, as well as their order from back to front.
Options are <code>"jitter"</code>, <code>"boxplot"</code>, <code>"vlnplot"</code>, and <code>"ridgeplot"</code>.
</p>
<p>Each plot type has specific associated options which are controlled by variables that start with their associated string.
For example, all jitter adjustments start with &quot;<code>jitter.</code>&quot;, such as <code>jitter.size</code> and <code>jitter.width</code>.
</p>
<p>Inclusion of <code>"ridgeplot"</code> overrides <code>"boxplot"</code> and <code>"vlnplot"</code> presence and changes the plot to be horizontal.
</p>
<p>Additionally:
</p>

<ul>
<li> <p><strong>Colors can be adjusted</strong> with <code>color.panel</code>.
</p>
</li>
<li> <p><strong>Subgroupings:</strong> <code>color.by</code> can be utilized to split major <code>group.by</code> groupings into subgroups.
When this is done in y-axis plotting, dittoViz automatically ensures the centers of all geoms will align,
but users will need to manually adjust <code>jitter.width</code> to less than 0.5/num_subgroups to avoid overlaps.
There are also three inputs through which one can use to control geom-center placement, but the easiest way to do all at once so is to just adjust <code>vlnplot.width</code>!
The other two: <code>boxplot.position.dodge</code>, and <code>jitter.position.dodge</code>.
</p>
</li>
<li> <p><strong>Line(s) can be added</strong> at single or multiple value(s) by providing these values to <code>add.line</code>.
Linetype and color are set with <code>line.linetype</code>, which is &quot;dashed&quot; by default, and <code>line.color</code>, which is &quot;black&quot; by default.
</p>
</li>
<li> <p><strong>Titles and axes labels</strong> can be adjusted with <code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>, and <code>legend.title</code> arguments.
</p>
</li>
<li><p> The <strong>legend can be hidden</strong> by setting <code>legend.show = FALSE</code>.
</p>
</li>
<li> <p><strong>y-axis zoom and tick marks</strong> can be adjusted using <code>min</code>, <code>max</code>, and <code>y.breaks</code>.
</p>
</li>
<li> <p><strong>x-axis labels and groupings</strong> can be changed / reordered using <code>x.labels</code> and <code>x.reorder</code>, and rotation of these labels can be turned on/off with <code>x.labels.rotate = TRUE/FALSE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+barPlot">barPlot</a></code> for a data representation that emphasizes total makeup of samples/groups rather than focusing on the <code>var</code>-data values individually.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

# There are three main inputs for this function, in addition to 'data_frame'.
#  var = typically this will be observation-type annotations or clustering
#    This is the set of observations for which we will calculate frequencies
#    (per each unique value of this data) within each sample
#  sample.by = the name of a column containing sample assignments
#    We'll treat all observations with the same value in this column as part
#    of the same sample.
#  group.by = how to group samples together
freqPlot(example_df,
    var = "clustering",
    sample.by = "sample",
    group.by = "category")

# 'color.by' can also be set differently from 'group.by' to have the effect
#  of highlighting supersets or subgroupings:
freqPlot(example_df, "clustering",
    group.by = "category",
    sample.by = "sample",
    color.by = "subcategory")

# The var-values shown can be subset with 'vars.use'
freqPlot(example_df, "clustering",
    group.by = "category", sample.by = "sample", color.by = "subcategory",
    vars.use = 1:2)

# Particular observations can be ignored from calculations and plotting using
#   the 'rows.use' input. Note that doing so adjusts the universe in which
#   frequencies are calculated; all frequencies will now be in terms of freq.
#   out of the rows.use cells.
#   This can be useful for quantifying subtypes within a given supertype,
#     rather than per all observations.
#   For our example, we'll calculate among clusters 1 and 2, treating clusters 3
#     and 4 observations as part of an unwanted other group of data. You'll
#     notice that frequencies are higher here than when we used 'vars.use' in
#     the previous example.
freqPlot(example_df, "clustering",
    group.by = "category", sample.by = "sample", color.by = "subcategory",
    rows.use = example_df$clustering %in% 1:2)

# Lower frequency targets can be expanded to use the entire y-axis by:
#  turning on 'max.normalize'-ation:
freqPlot(example_df, "clustering",
    group.by = "category", sample.by = "sample", color.by = "subcategory",
    max.normalize = TRUE)
#  or by setting y-scale limits to be set by the contents of facets:
freqPlot(example_df, "clustering",
    group.by = "category", sample.by = "sample", color.by = "subcategory",
    split.adjust = list(scales = "free_y"))

# Data representations can also be selected and reordered with the 'plots'
#  input, and further adjusted with inputs applying to each representation.
freqPlot(example_df,
    var = "clustering", sample.by = "sample", group.by = "category",
    plots = c("vlnplot", "boxplot", "jitter"),
    vlnplot.lineweight = 0.2,
    boxplot.fill = FALSE,
    boxplot.lineweight = 0.2)

# Finally, 'sample.by' is not technically required. When not given, a
#  single data point of overall composition stats will be shown for each
#  grouping.
#  Just note, all data representation other than "jitter" will complain
#  due to there only being the one datapoint per group unless you set
#  plots to "jitter".
freqPlot(example_df,
    var = "clustering", group.by = "category", color.by = "subcategory",
    plots = "jitter")

</code></pre>

<hr>
<h2 id='scatterHex'>scatter plot where observations are grouped into hexagonal bins and then summarized</h2><span id='topic+scatterHex'></span>

<h3>Description</h3>

<p>scatter plot where observations are grouped into hexagonal bins and then summarized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatterHex(
  data_frame,
  x.by,
  y.by,
  color.by = NULL,
  bins = 30,
  color.method = NULL,
  split.by = NULL,
  rows.use = NULL,
  color.panel = dittoColors(),
  colors = seq_along(color.panel),
  x.adjustment = NULL,
  y.adjustment = NULL,
  color.adjustment = NULL,
  x.adj.fxn = NULL,
  y.adj.fxn = NULL,
  color.adj.fxn = NULL,
  multivar.split.dir = c("col", "row"),
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  min.density = NA,
  max.density = NA,
  min.color = "#F0E442",
  max.color = "#0072B2",
  min.opacity = 0.2,
  max.opacity = 1,
  min = NA,
  max = NA,
  rename.color.groups = NULL,
  xlab = x.by,
  ylab = y.by,
  main = "make",
  sub = NULL,
  theme = theme_bw(),
  do.contour = FALSE,
  contour.color = "black",
  contour.linetype = 1,
  do.ellipse = FALSE,
  do.label = FALSE,
  labels.size = 5,
  labels.highlight = TRUE,
  labels.repel = TRUE,
  labels.split.by = split.by,
  labels.repel.adjust = list(),
  add.trajectory.by.groups = NULL,
  add.trajectory.curves = NULL,
  trajectory.group.by,
  trajectory.arrow.size = 0.15,
  add.xline = NULL,
  xline.linetype = "dashed",
  xline.color = "black",
  add.yline = NULL,
  yline.linetype = "dashed",
  yline.color = "black",
  legend.show = TRUE,
  legend.color.title = "make",
  legend.color.breaks = waiver(),
  legend.color.breaks.labels = waiver(),
  legend.density.title = "Observations",
  legend.density.breaks = waiver(),
  legend.density.breaks.labels = waiver(),
  show.grid.lines = TRUE,
  data.out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterHex_+3A_data_frame">data_frame</code></td>
<td>
<p>A data_frame where columns are features and rows are observations you might wish to visualize.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_x.by">x.by</code>, <code id="scatterHex_+3A_y.by">y.by</code></td>
<td>
<p>Single strings denoting the name of a column of <code>data_frame</code> containing numeric data to use for the x- and y-axis of the scatterplot.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_color.by">color.by</code></td>
<td>
<p>Single string denoting the name of a column of <code>data_frame</code> to use, instead of point density, for setting the color of plotted hexagons.
Alternatively, a string vector naming multiple such columns of data to plot at once.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_bins">bins</code></td>
<td>
<p>Numeric or numeric vector giving the number of hexagonal bins in the x and y directions. Set to 30 by default.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_color.method">color.method</code></td>
<td>
<p>Single string that specifies how <code>color.by</code> data should be summarized per each hexagonal bin.
Options, and the default, depend on whether the <code>color.by</code>-data is continuous versus discrete:
</p>
<p><strong>Continuous</strong>: String naming a function for how target data should be summarized for each bin.
Can be any function that inputs (summarizes) a numeric vector and outputs a single numeric value.
Default is <code>median</code>.
Other useful options are <code>sum</code>, <code>mean</code>, <code>sd</code>, or <code>max</code>.
You can also use a custom function as long as you give it a name; e.g. first run <code>logsum &lt;- function(x) { log(sum(x)) }</code> externally, then give <code>color.method = "logsum"</code>
</p>
<p><strong>Discrete</strong>: A string signifying whether the color should (default) be simply based on the &quot;max&quot; grouping of the bin,
or based on the &quot;max.prop&quot;ortion of observations belonging to any grouping.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_split.by">split.by</code></td>
<td>
<p>1 or 2 strings denoting the name(s) of column(s) of <code>data_frame</code> containing discrete data to use for faceting / separating data points into separate plots.
</p>
<p>When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.
</p>
<p>When 1 column is named, shape control can be achieved with <code>split.nrow</code> and <code>split.ncol</code></p>
</td></tr>
<tr><td><code id="scatterHex_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rownames of <code>data_frame</code> OR an integer vector specifying the row-indices of data points which should be plotted.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in <code>data_frame</code>, where <code>TRUE</code> values indicate which rows to plot.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_color.panel">color.panel</code></td>
<td>
<p>String vector which sets the colors to draw from when <code>color.by</code> indicates discrete data.
<code>dittoColors()</code> by default, see <code><a href="#topic+dittoColors">dittoColors</a></code> for contents.
</p>
<p>A named vector can be used if names are matched to the distinct values of the <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_colors">colors</code></td>
<td>
<p>Integer vector, the indexes / order, of colors from <code>color.panel</code> to actually use.
</p>
<p>Useful for quickly swapping around colors of the default set (when not using names for color matching).</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_x.adjustment">x.adjustment</code>, <code id="scatterHex_+3A_y.adjustment">y.adjustment</code>, <code id="scatterHex_+3A_color.adjustment">color.adjustment</code></td>
<td>
<p>A recognized string indicating whether numeric <code>x.by</code>, <code>y.by</code>, and <code>color.by</code> data should be used directly (default) or should be adjusted to be
</p>

<ul>
<li><p>&quot;z-score&quot;: scaled with the scale() function to produce a relative-to-mean z-score representation
</p>
</li>
<li><p>&quot;relative.to.max&quot;: divided by the maximum value to give percent of max values between [0,1]
</p>
</li></ul>

<p>Ignored if the target data is not numeric as these known adjustments target numeric data only.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_x.adj.fxn">x.adj.fxn</code>, <code id="scatterHex_+3A_y.adj.fxn">y.adj.fxn</code>, <code id="scatterHex_+3A_color.adj.fxn">color.adj.fxn</code></td>
<td>
<p>If you wish to apply a function to edit the <code>x.by</code>, <code>y.by</code>, or <code>color.by</code> data before use, in a way not possible with the <code>color.adjustment</code> input,
this input can be given a function which takes in a vector of values as input and returns a vector of values of the same length as output.
</p>
<p>For example, <code>function(x) {log2(x)}</code> or <code>as.factor</code>.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_multivar.split.dir">multivar.split.dir</code></td>
<td>
<p>&quot;row&quot; or &quot;col&quot;, sets the direction of faceting used for 'var' values when: </p>

<ul>
<li> <p><code>var</code> is given multiple column names
</p>
</li>
<li><p> AND <code>split.by</code> is used to provide an additional feature to facet by
</p>
</li></ul>
</td></tr>
<tr><td><code id="scatterHex_+3A_split.nrow">split.nrow</code>, <code id="scatterHex_+3A_split.ncol">split.ncol</code></td>
<td>
<p>Integers which set the dimensions of faceting/splitting when faceting by a single feature.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_split.adjust">split.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. 'list(scales = &quot;free&quot;)'.
</p>
<p>For options, when giving 1 column to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>,
OR when giving 2 columns to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_min.density">min.density</code>, <code id="scatterHex_+3A_max.density">max.density</code></td>
<td>
<p>Number which sets the min/max values used for the density scale.
Used no matter whether density is represented through opacity or color.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_min.color">min.color</code>, <code id="scatterHex_+3A_max.color">max.color</code></td>
<td>
<p>color for the min/max values of the color scale.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_min.opacity">min.opacity</code>, <code id="scatterHex_+3A_max.opacity">max.opacity</code></td>
<td>
<p>Scalar between [0,1] which sets the minimum or maximum opacity used for the density legend (when color is used for <code>color.by</code> data and density is shown via opacity).</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_min">min</code>, <code id="scatterHex_+3A_max">max</code></td>
<td>
<p>Number which sets the values associated with the minimum or maximum color for <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_rename.color.groups">rename.color.groups</code></td>
<td>
<p>String vector which sets new names for the identities of <code>color.by</code> groups.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_xlab">xlab</code>, <code id="scatterHex_+3A_ylab">ylab</code></td>
<td>
<p>Strings which set the labels for the axes. To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_main">main</code></td>
<td>
<p>String, sets the plot title. The default title is either &quot;Density&quot;, <code>color.by</code>, or NULL, depending on the identity of <code>color.by</code>.
To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_sub">sub</code></td>
<td>
<p>String, sets the plot subtitle.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme which will be applied before internal adjustments.
Default = <code>theme_bw()</code>.
See <a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> for other options and ideas.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_do.contour">do.contour</code></td>
<td>
<p>Logical. Whether density-based contours should be displayed.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_contour.color">contour.color</code></td>
<td>
<p>String that sets the color of the <code>do.contour</code> contours.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_contour.linetype">contour.linetype</code></td>
<td>
<p>String or numeric which sets the type of line used for <code>do.contour</code> contours.
Defaults to &quot;solid&quot;, but see <code><a href="ggplot2.html#topic+linetype">linetype</a></code> for other options.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_do.ellipse">do.ellipse</code></td>
<td>
<p>Logical. Whether <code>color.by</code> groups should be surrounded by median-centered ellipses.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_do.label">do.label</code></td>
<td>
<p>Logical. Whether to add text labels near the center (median) of <code>color.by</code> groups.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_labels.size">labels.size</code></td>
<td>
<p>Number which sets the size of labels text when <code>do.label = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_labels.highlight">labels.highlight</code></td>
<td>
<p>Logical. Whether labels should have a box behind them when <code>do.label = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_labels.repel">labels.repel</code></td>
<td>
<p>Logical, that sets whether the labels' placements will be adjusted with <a href="ggrepel.html#topic+ggrepel">ggrepel</a> to avoid intersections between labels and plot bounds when <code>do.label = TRUE</code>.
TRUE by default.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_labels.split.by">labels.split.by</code></td>
<td>
<p>String of one or two column names which controls the facet-split calculations for label placements.
Defaults to <code>split.by</code>, so generally there is no need to adjust this except when if you plan to apply faceting externally.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_labels.repel.adjust">labels.repel.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to ggrepel function calls.
List elements should be valid inputs to the <code><a href="ggrepel.html#topic+geom_label_repel">geom_label_repel</a></code> by default, or <code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code> when <code>labels.highlight = FALSE</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_add.trajectory.by.groups">add.trajectory.by.groups</code></td>
<td>
<p>List of vectors representing trajectory paths, each from start-group to end-group, where vector contents are the group-names indicated by the <code>trajectory.group.by</code> column of <code>data_frame</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_add.trajectory.curves">add.trajectory.curves</code></td>
<td>
<p>List of matrices, each representing coordinates for a trajectory path, from start to end, where matrix columns represent x and y coordinates of the paths.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_trajectory.group.by">trajectory.group.by</code></td>
<td>
<p>String denoting the name of a column of <code>data_frame</code> to use for generating trajectories from data point groups.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_trajectory.arrow.size">trajectory.arrow.size</code></td>
<td>
<p>Number representing the size of trajectory arrows, in inches.  Default = 0.15.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_add.xline">add.xline</code></td>
<td>
<p>numeric value(s) where one or multiple vertical line(s) should be added.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_xline.linetype">xline.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.xline</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_xline.color">xline.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.xline</code> line(s).</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_add.yline">add.yline</code></td>
<td>
<p>numeric value(s) where one or multiple vertical line(s) should be added.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_yline.linetype">yline.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.yline</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_yline.color">yline.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.yline</code> line(s).</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_legend.show">legend.show</code></td>
<td>
<p>Logical. Whether any legend should be displayed. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_legend.density.title">legend.density.title</code>, <code id="scatterHex_+3A_legend.color.title">legend.color.title</code></td>
<td>
<p>Strings which set the title for the legends.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_legend.density.breaks">legend.density.breaks</code>, <code id="scatterHex_+3A_legend.color.breaks">legend.color.breaks</code></td>
<td>
<p>Numeric vector which sets the discrete values to label in the density and color.by legends.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_legend.density.breaks.labels">legend.density.breaks.labels</code>, <code id="scatterHex_+3A_legend.color.breaks.labels">legend.color.breaks.labels</code></td>
<td>
<p>String vector, with same length as <code>legend.*.breaks</code>, which sets the labels for the tick marks or hex icons of the associated legend.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_show.grid.lines">show.grid.lines</code></td>
<td>
<p>Logical which sets whether grid lines should be shown within the plot space.</p>
</td></tr>
<tr><td><code id="scatterHex_+3A_data.out">data.out</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, changes the output from the plot alone to a list containing the plot (&quot;plot&quot;),
and data.frame of the underlying data for target observations (&quot;data&quot;),
and the ultimately used mapping of columns to given aesthetic sets, because modification of newly made columns is required for many features (&quot;cols_used&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first makes any requested adjustments to data in the given <code>data_frame</code>, internally only, such as scaling the <code>color.by</code>-column if <code>color.adjustment</code> was given <code>"z-score"</code>.
</p>
<p>Next, data_frame is then subset to only target rows based on the <code>rows.use</code> input.
</p>
<p>Finally, a hex plot is created using this dataframe:
</p>
<p>If <code>color.by</code> is not rovided, coloring is based on the density of observations within each hex bin.
When <code>color.by</code> is provided, density is represented through opacity while coloring is based on a summarization, chosen with the <code>color.method</code> input, of the target <code>color.by</code> data.
</p>
<p>If <code>split.by</code> was used, the plot will be split into a matrix of panels based on the associated groupings.
</p>


<h3>Value</h3>

<p>A ggplot object where colored hexagonal bins are used to summarize observations in a scatter plot.
</p>
<p>Alternatively, if <code>data.out=TRUE</code>, a list containing three slots is output:
the plot (named 'plot'),
a data.table containing the updated underlying data for target rows (named 'data'),
and a list providing mappings of final column names in 'data' to given plot aesthetics (named 'cols_used'), because modification of newly made columns is required for many features.
</p>


<h3>Many characteristics of the plot can be adjusted using discrete inputs</h3>


<ul>
<li><p> Colors: <code>min.color</code> and <code>max.color</code> adjust the colors for continuous data.
</p>
</li>
<li><p> For discrete <code>color.by</code> plotting with <code>color.method = "max"</code>, colors are instead adjusted with <code>color.panel</code> and/or <code>colors</code> &amp; the labels of the groupings can be changed using <code>rename.color.groups</code>.
</p>
</li>
<li><p> Titles and axes labels can be adjusted with <code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>, and <code>legend.color.title</code> and <code>legend.density.title</code> arguments.
</p>
</li>
<li><p> Legends can also be adjusted in other ways, using variables that all start with &quot;<code>legend.</code>&quot; for easy tab completion lookup.
</p>
</li></ul>



<h3>Additional Features</h3>

<p>Other tweaks and features can be added as well.
Each is accessible through 'tab' autocompletion starting with &quot;<code>do.</code>&quot;<code>---</code> or &quot;<code>add.</code>&quot;<code>---</code>,
and if additional inputs are involved in implementing or tweaking these, the associated inputs will start with the &quot;<code>---.</code>&quot;:
</p>

<ul>
<li><p> If <code>do.contour</code> is provided, density gradient contour lines will be overlaid with color and linetype adjustable via <code>contour.color</code> and <code>contour.linetype</code>.
</p>
</li>
<li><p> If <code>add.trajectory.by.groups</code> is provided a list of vectors (each vector being group names from start-group-name to end-group-name), and a column name pointing to the relevant grouping information is provided to <code>trajectory.group.by</code>,
then median centers of the groups will be calculated and arrows will be overlayed to show trajectory inference paths.
</p>
</li>
<li><p> If <code>add.trajectory.curves</code> is provided a list of matrices (each matrix containing x, y coordinates from start to end), paths and arrows will be overlayed to show trajectory inference curves.
Arrow size is controlled with the <code>trajectory.arrow.size</code> input.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Bunis with some code adapted from Giuseppe D'Agostino
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scatterPlot">scatterPlot</a></code> for making non-hex-binned scatter plots showing each individual data point.
It is often best to investigate your data with both the individual and hex-bin methods, then pick whichever is the best representation for your particular goal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

# The minimal inputs for scatterHex are the 'data_frame', and 2 column names,
#   given to 'x.by' and 'y.by', indicating which data to use for the x and y
#   axes, respectively.
scatterHex(
    example_df, x.by = "PC1", y.by = "PC2")

# 'color.by' can also be given a column name in order to represent that
#   column's data in the color of the hexes.
# Note: This capability requires the suggested package 'ggplot.multistats'.
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(
        example_df, x.by = "PC1", y.by = "PC2",
        color.by = "groups")
}
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(
        example_df, x.by = "PC1", y.by = "PC2",
        color.by = "gene1")
}

# Data can be "split" or faceted by a discrete variable as well.
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    split.by = "timepoint") # single split.by element
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    split.by = c("groups","SNP")) # row and col split.by elements

# Modify the look with intuitive inputs
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    show.grid.lines = FALSE,
    ylab = NULL, xlab = "PC2 by PC1",
    main = "Plot Title",
    sub = "subtitle",
    legend.density.title = "Items")
# 'max.density' is one of these intuitively named inputs that can be
#   extremely useful for saying "I only can for opacity to be decreased
#   in regions with exceptionally low observation numbers."
# (A good value for this in "real" data might be 10 or 50 or higher, but for
#   our sparse example data, we need to do a lot to show this off at all!)
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(
        example_df, x.by = "PC1", y.by = "PC2",
        color.by = "gene1", bins = 10,
        sub = "Default density scale")
}
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(
        example_df, x.by = "PC1", y.by = "PC2",
        color.by = "gene1", bins = 10,
        sub = "Density capped low for ignoring sparse regions",
        max.density = 2)
}

# You can restrict to only certain data points using the 'rows.use' input.
#   The input can be given rownames, indexes, or a logical vector
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    sub = "show only first 40 observations, by index",
    rows.use = 1:40)
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    sub = "show only 3 obs, by name (plotting gets a bit wonky for few points)",
    rows.use = c("obs1", "obs2", "obs25"))
scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    sub = "show groups A,B,D only, by logical",
    rows.use = example_df$groups!="C")

# Many extra features are easy to add as well:
#   Each is started via an input starting with 'do.FEATURE*' or 'add.FEATURE*'
#   And when tweaks for that feature are possible, those inputs will start be
#   named starting with 'FEATURE*'. For example, color.by groups can be labeled
#   with 'do.label = TRUE' and the tweaks for this feature are given with inputs
#   'labels.size', 'labels.highlight', and 'labels.repel':
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
        sub = "default labeling",
        do.label = TRUE)          # Turns on the labeling feature
}
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
        sub = "tweaked labeling",
        do.label = TRUE,          # Turns on the labeling feature
        labels.size = 8,          # Adjust the text size of labels
        labels.highlight = FALSE, # Removes white background behind labels
        labels.repel = FALSE)     # Turns off anti-overlap location adjustments
}

# Faceting can also be used to show multiple continuous variables side-by-side
#   by giving a vector of column names to 'color.by'.
#   This can also be combined with 1 'split.by' variable, with direction then
#   controlled via 'multivar.split.dir':
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(example_df, x.by = "PC1", y.by = "PC2", bins = 10,
        color.by = c("gene1", "gene2"))
}
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(example_df, x.by = "PC1", y.by = "PC2", bins = 10,
        color.by = c("gene1", "gene2"),
        split.by = "groups")
}
if (requireNamespace("ggplot.multistats", quietly = TRUE)) {
    scatterHex(example_df, x.by = "PC1", y.by = "PC2", bins = 10,
        color.by = c("gene1", "gene2"),
        split.by = "groups",
        multivar.split.dir = "row")
}

# Sometimes, it can be useful for external editing or troubleshooting purposes
#   to see the underlying data that was directly used for plotting.
# 'data.out = TRUE' can be provided in order to obtain not just plot ("plot"),
#   but also the "data" and "cols_used" returned as a list.
out &lt;- scatterHex(example_df, x.by = "PC1", y.by = "PC2",
    rows.use = 1:40,
    data.out = TRUE)
out$plot
summary(out$data)
out$cols_use

</code></pre>

<hr>
<h2 id='scatterPlot'>Show RNAseq data overlayed on a scatter plot</h2><span id='topic+scatterPlot'></span>

<h3>Description</h3>

<p>Show RNAseq data overlayed on a scatter plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatterPlot(
  data_frame,
  x.by,
  y.by,
  color.by = NULL,
  shape.by = NULL,
  split.by = NULL,
  size = 1,
  rows.use = NULL,
  show.others = TRUE,
  x.adjustment = NULL,
  y.adjustment = NULL,
  color.adjustment = NULL,
  x.adj.fxn = NULL,
  y.adj.fxn = NULL,
  color.adj.fxn = NULL,
  split.show.all.others = TRUE,
  opacity = 1,
  color.panel = dittoColors(),
  colors = seq_along(color.panel),
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  multivar.split.dir = c("col", "row"),
  shape.panel = c(16, 15, 17, 23, 25, 8),
  rename.color.groups = NULL,
  rename.shape.groups = NULL,
  min.color = "#F0E442",
  max.color = "#0072B2",
  min.value = NA,
  max.value = NA,
  plot.order = c("unordered", "increasing", "decreasing", "randomize"),
  xlab = x.by,
  ylab = y.by,
  main = "make",
  sub = NULL,
  theme = theme_bw(),
  do.hover = FALSE,
  hover.data = unique(c(color.by, paste0(color.by, ".color.adj"), "color.multi",
    "color.which", x.by, paste0(x.by, ".x.adj"), y.by, paste0(y.by, ".y.adj"), shape.by,
    split.by)),
  hover.round.digits = 5,
  do.contour = FALSE,
  contour.color = "black",
  contour.linetype = 1,
  add.trajectory.by.groups = NULL,
  add.trajectory.curves = NULL,
  trajectory.group.by,
  trajectory.arrow.size = 0.15,
  add.xline = NULL,
  xline.linetype = "dashed",
  xline.color = "black",
  add.yline = NULL,
  yline.linetype = "dashed",
  yline.color = "black",
  do.letter = FALSE,
  do.ellipse = FALSE,
  do.label = FALSE,
  labels.size = 5,
  labels.highlight = TRUE,
  labels.repel = TRUE,
  labels.repel.adjust = list(),
  labels.split.by = split.by,
  legend.show = TRUE,
  legend.color.title = "make",
  legend.color.size = 5,
  legend.color.breaks = waiver(),
  legend.color.breaks.labels = waiver(),
  legend.shape.title = shape.by,
  legend.shape.size = 5,
  show.grid.lines = TRUE,
  do.raster = FALSE,
  raster.dpi = 300,
  data.out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterPlot_+3A_data_frame">data_frame</code></td>
<td>
<p>A data_frame where columns are features and rows are observations you might wish to visualize.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_x.by">x.by</code>, <code id="scatterPlot_+3A_y.by">y.by</code></td>
<td>
<p>Single strings denoting the name of a column of <code>data_frame</code> containing numeric data to use for the x- and y-axis of the scatterplot.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_color.by">color.by</code></td>
<td>
<p>Single string denoting the name of a column of <code>data_frame</code> to use for setting the color of plotted points.
Alternatively, a string vector naming multiple such columns of data to plot at once.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_shape.by">shape.by</code></td>
<td>
<p>Single string denoting the name of a column of <code>data_frame</code> containing discrete data to use for setting the shape of plotted points.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_split.by">split.by</code></td>
<td>
<p>1 or 2 strings denoting the name(s) of column(s) of <code>data_frame</code> containing discrete data to use for faceting / separating data points into separate plots.
</p>
<p>When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.
</p>
<p>When 1 column is named, shape control can be achieved with <code>split.nrow</code> and <code>split.ncol</code></p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_size">size</code></td>
<td>
<p>Number which sets the size of data points. Default = 1.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rownames of <code>data_frame</code> OR an integer vector specifying the row-indices of data points which should be plotted.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in <code>data_frame</code>, where <code>TRUE</code> values indicate which rows to plot.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_show.others">show.others</code></td>
<td>
<p>Logical. TRUE by default, whether rows not targeted by <code>rows.use</code> should be shown in the background in light gray.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_x.adjustment">x.adjustment</code>, <code id="scatterPlot_+3A_y.adjustment">y.adjustment</code>, <code id="scatterPlot_+3A_color.adjustment">color.adjustment</code></td>
<td>
<p>A recognized string indicating whether numeric <code>x.by</code>, <code>y.by</code>, and <code>color.by</code> data should be used directly (default) or should be adjusted to be
</p>

<ul>
<li><p>&quot;z-score&quot;: scaled with the scale() function to produce a relative-to-mean z-score representation
</p>
</li>
<li><p>&quot;relative.to.max&quot;: divided by the maximum value to give percent of max values between [0,1]
</p>
</li></ul>

<p>Ignored if the target data is not numeric as these known adjustments target numeric data only.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_x.adj.fxn">x.adj.fxn</code>, <code id="scatterPlot_+3A_y.adj.fxn">y.adj.fxn</code>, <code id="scatterPlot_+3A_color.adj.fxn">color.adj.fxn</code></td>
<td>
<p>If you wish to apply a function to edit the <code>x.by</code>, <code>y.by</code>, or <code>color.by</code> data before use, in a way not possible with the <code>color.adjustment</code> input,
this input can be given a function which takes in a vector of values as input and returns a vector of values of the same length as output.
</p>
<p>For example, <code>function(x) {log2(x)}</code> or <code>as.factor</code>.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_split.show.all.others">split.show.all.others</code></td>
<td>
<p>Logical which sets whether gray &quot;others&quot; points of facets should include all points of other facets (<code>TRUE</code>) versus just points left out by <code>rows.use</code> which would exist in the current facet (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_opacity">opacity</code></td>
<td>
<p>Number between 0 and 1.
1 = opaque. 0 = invisible. Default = 1.
(In terms of typical ggplot variables, = alpha)</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_color.panel">color.panel</code></td>
<td>
<p>String vector which sets the colors to draw from when <code>color.by</code> indicates discrete data.
<code>dittoColors()</code> by default, see <code><a href="#topic+dittoColors">dittoColors</a></code> for contents.
</p>
<p>A named vector can be used if names are matched to the distinct values of the <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_colors">colors</code></td>
<td>
<p>Integer vector, the indexes / order, of colors from <code>color.panel</code> to actually use.
</p>
<p>Useful for quickly swapping around colors of the default set (when not using names for color matching).</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_split.nrow">split.nrow</code>, <code id="scatterPlot_+3A_split.ncol">split.ncol</code></td>
<td>
<p>Integers which set the dimensions of faceting/splitting when faceting by a single feature.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_split.adjust">split.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. 'list(scales = &quot;free&quot;)'.
</p>
<p>For options, when giving 1 column to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>,
OR when giving 2 columns to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_multivar.split.dir">multivar.split.dir</code></td>
<td>
<p>&quot;row&quot; or &quot;col&quot;, sets the direction of faceting used for 'var' values when: </p>

<ul>
<li> <p><code>var</code> is given multiple column names
</p>
</li>
<li><p> AND <code>split.by</code> is used to provide an additional feature to facet by
</p>
</li></ul>
</td></tr>
<tr><td><code id="scatterPlot_+3A_shape.panel">shape.panel</code></td>
<td>
<p>Vector of integers, corresponding to ggplot shapes, which sets what shapes to use in conjunction with <code>shape.by</code>.
When nothing is supplied to <code>shape.by</code>, only the first value is used.
Default is a set of 6, <code>c(16,15,17,23,25,8)</code>, the first being a simple, solid, circle.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_rename.color.groups">rename.color.groups</code></td>
<td>
<p>String vector which sets new names for the identities of <code>color.by</code> groups.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_rename.shape.groups">rename.shape.groups</code></td>
<td>
<p>String vector which sets new names for the identities of <code>shape.by</code> groups.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_min.color">min.color</code></td>
<td>
<p>color for <code>min</code> value of numeric <code>color.by</code>-data. Default = yellow</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_max.color">max.color</code></td>
<td>
<p>color for <code>max</code> value of numeric <code>color.by</code>-data. Default = blue</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_min.value">min.value</code>, <code id="scatterPlot_+3A_max.value">max.value</code></td>
<td>
<p>Number which sets the <code>color.by</code>-data value associated with the minimum or maximum colors.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_plot.order">plot.order</code></td>
<td>
<p>String. If the data should be plotted based on the order of the color data, sets whether to plot in &quot;increasing&quot;, &quot;decreasing&quot;, or &quot;randomize&quot;d order.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_xlab">xlab</code>, <code id="scatterPlot_+3A_ylab">ylab</code></td>
<td>
<p>Strings which set the labels for the axes. To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_main">main</code></td>
<td>
<p>String, sets the plot title.
A default title is automatically generated based on <code>color.by</code> and <code>shape.by</code> when either are provided.
To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_sub">sub</code></td>
<td>
<p>String, sets the plot subtitle.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme which will be applied before internal adjustments.
Default = <code>theme_bw()</code>.
See <a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> for other options and ideas.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.hover">do.hover</code></td>
<td>
<p>Logical which controls whether the ggplot output will be converted to a plotly object so that data about individual points can be displayed when you hover your cursor over them.
The <code>hover.data</code> argument is used to determine what data to show upon hover.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_hover.data">hover.data</code></td>
<td>
<p>String vector which denotes what data to show for each data point, upon hover, when <code>do.hover</code> is set to <code>TRUE</code>.
Defaults to all data expected to be useful.
Only values present in the plotting data are actually used.
These can be column names of <code>data_frame</code> and any column names which will be created to accommodate multivar and data adjustment functionality.
You can run the function with <code>data.out = TRUE</code> and inspect the <code>$Target_data</code> output's columns to view your available options.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_hover.round.digits">hover.round.digits</code></td>
<td>
<p>Integer number specifying the number of decimal digits to round displayed numeric values to, when <code>do.hover</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.contour">do.contour</code></td>
<td>
<p>Logical. Whether density-based contours should be displayed.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_contour.color">contour.color</code></td>
<td>
<p>String that sets the color of the <code>do.contour</code> contours.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_contour.linetype">contour.linetype</code></td>
<td>
<p>String or numeric which sets the type of line used for <code>do.contour</code> contours.
Defaults to &quot;solid&quot;, but see <code><a href="ggplot2.html#topic+linetype">linetype</a></code> for other options.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_add.trajectory.by.groups">add.trajectory.by.groups</code></td>
<td>
<p>List of vectors representing trajectory paths, each from start-group to end-group, where vector contents are the group-names indicated by the <code>trajectory.group.by</code> column of <code>data_frame</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_add.trajectory.curves">add.trajectory.curves</code></td>
<td>
<p>List of matrices, each representing coordinates for a trajectory path, from start to end, where matrix columns represent x and y coordinates of the paths.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_trajectory.group.by">trajectory.group.by</code></td>
<td>
<p>String denoting the name of a column of <code>data_frame</code> to use for generating trajectories from data point groups.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_trajectory.arrow.size">trajectory.arrow.size</code></td>
<td>
<p>Number representing the size of trajectory arrows, in inches.  Default = 0.15.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_add.xline">add.xline</code></td>
<td>
<p>numeric value(s) where one or multiple vertical line(s) should be added.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_xline.linetype">xline.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.xline</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_xline.color">xline.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.xline</code> line(s).</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_add.yline">add.yline</code></td>
<td>
<p>numeric value(s) where one or multiple vertical line(s) should be added.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_yline.linetype">yline.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.yline</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_yline.color">yline.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.yline</code> line(s).</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.letter">do.letter</code></td>
<td>
<p>Logical which sets whether letters should be added on top of the colored dots.
For extended colorblindness compatibility.
NOTE: <code>do.letter</code> is ignored if <code>do.hover = TRUE</code> or <code>shape.by</code> is used because lettering is incompatible with plotly and with changing the dots' to be different shapes.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.ellipse">do.ellipse</code></td>
<td>
<p>Logical. Whether <code>color.by</code> groups should be surrounded by median-centered ellipses.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.label">do.label</code></td>
<td>
<p>Logical. Whether to add text labels near the center (median) of <code>color.by</code> groups.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_labels.size">labels.size</code></td>
<td>
<p>Number which sets the size of labels text when <code>do.label = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_labels.highlight">labels.highlight</code></td>
<td>
<p>Logical. Whether labels should have a box behind them when <code>do.label = TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_labels.repel">labels.repel</code></td>
<td>
<p>Logical, that sets whether the labels' placements will be adjusted with <a href="ggrepel.html#topic+ggrepel">ggrepel</a> to avoid intersections between labels and plot bounds when <code>do.label = TRUE</code>.
TRUE by default.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_labels.repel.adjust">labels.repel.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to ggrepel function calls.
List elements should be valid inputs to the <code><a href="ggrepel.html#topic+geom_label_repel">geom_label_repel</a></code> by default, or <code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code> when <code>labels.highlight = FALSE</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_labels.split.by">labels.split.by</code></td>
<td>
<p>String of one or two column names which controls the facet-split calculations for label placements.
Defaults to <code>split.by</code>, so generally there is no need to adjust this except when if you plan to apply faceting externally.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_legend.show">legend.show</code></td>
<td>
<p>Logical. Whether any legend should be displayed. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_legend.color.title">legend.color.title</code>, <code id="scatterPlot_+3A_legend.shape.title">legend.shape.title</code></td>
<td>
<p>Strings which set the title for the color or shape legends.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_legend.color.size">legend.color.size</code>, <code id="scatterPlot_+3A_legend.shape.size">legend.shape.size</code></td>
<td>
<p>Numbers representing the size of shapes in the color and shape legends (for discrete variable plotting).
Default = 5. *Enlarging the icons in the colors legend is incredibly helpful for making colors more distinguishable by color blind individuals.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_legend.color.breaks">legend.color.breaks</code></td>
<td>
<p>Numeric vector which sets the discrete values to label in the color-scale legend for <code>color.by</code>-data.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_legend.color.breaks.labels">legend.color.breaks.labels</code></td>
<td>
<p>String vector, with same length as <code>legend.color.breaks</code>, which sets the labels for the tick marks of the color-scale.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_show.grid.lines">show.grid.lines</code></td>
<td>
<p>Logical which sets whether grid lines should be shown within the plot space.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_do.raster">do.raster</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, rasterizes the internal plot layer, changing it from individually encoded points to a flattened set of pixels.
This can be useful for editing in external programs (e.g. Illustrator) when there are many thousands of data points.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Number indicating dots/pixels per inch (dpi) to use for rasterization. Default = 300.</p>
</td></tr>
<tr><td><code id="scatterPlot_+3A_data.out">data.out</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, changes the output, from the plot alone, to a list containing the plot (&quot;p&quot;),
a data.frame containing the underlying data for target rows (&quot;Target_data&quot;),
a data.frame containing the underlying data for non-target rows (&quot;Others_data&quot;),
and the ultimately used mapping of columns to given aesthetic sets (&quot;cols_used&quot;), because modification of newly made columns is required for many features.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first makes any requested adjustments to data in the given <code>data_frame</code>, internally only, such as scaling the <code>color.by</code>-column if <code>color.adjustment</code> was given <code>"z-score"</code>.
</p>
<p>Next, if a set of rows to target was indicated with the <code>rows.use</code> input, then the data_frame is split into <code>Target_data</code> and <code>Others_data</code>.
</p>
<p>Then, rows are reordered to match with the requested <code>plot.order</code> behavior.
</p>
<p>Finally, a scatter plot is created from the resultant data.frames.
Non-target data points are colored in gray if <code>show.others=TRUE</code>,
and target data points are displayed on top, colored and shaped based on the <code>color.by</code>- and <code>shape.by</code>-associated data.
If <code>split.by</code> was used, the plot will be split into a matrix of panels based on the associated groupings.
</p>


<h3>Value</h3>

<p>a ggplot scatterplot where colored dots and/or shapes represent individual rows of the given <code>data_frame</code>.
</p>
<p>Alternatively, if <code>data.out=TRUE</code>, a list containing four slots is output:
the plot (named 'p'),
a data.frame containing the underlying data for target rows (named 'Target_data'),
a data.frame containing the underlying data for non-target rows (named 'Others_data'),
and a list providing mappings of final column names in 'Target_data' to given plot aesthetics (named 'cols_used') because modification of newly made columns is required for many features.
</p>
<p>Alternatively, if <code>do.hover</code> is set to <code>TRUE</code>, the plot is coverted from ggplot to plotly &amp;
additional information about each data point, determined by the <code>hover.data</code> input, is displayed upon hovering the cursor over the plot.
</p>


<h3>Many characteristics of the plot can be adjusted using discrete inputs</h3>


<ul>
<li> <p><code>size</code> and <code>opacity</code> can be used to adjust the size and transparency of the data points. <strong><code>size</code></strong> can be given a number, or a column name of <code>data_frame</code>.
</p>
</li>
<li><p> Colors used can be adjusted with <code>color.panel</code> and/or <code>colors</code> for discrete data, or <code>min</code>, <code>max</code>, <code>min.color</code>, and <code>max.color</code> for continuous data.
</p>
</li>
<li><p> Shapes used can be adjusted with <code>shape.panel</code>.
</p>
</li>
<li><p> Color and shape labels can be changed using <code>rename.color.groups</code> and <code>rename.shape.groups</code>.
</p>
</li>
<li><p> Titles and axes labels can be adjusted with <code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>, and <code>legend.title</code> arguments.
</p>
</li>
<li><p> Legends can also be adjusted in other ways, using variables that all start with &quot;<code>legend.</code>&quot; for easy tab completion lookup.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scatterHex">scatterHex</a></code> for a hex-binned version that can be useful when points are very dense.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

# The minimal inputs for scatterPlot are the 'data_frame', and 2 column names,
#   given to 'x.by' and 'y.by', indicating which data to use for the x and y
#   axes, respectively.
scatterPlot(
    example_df, x.by = "PC1", y.by = "PC2")

# 'color.by' and/or 'shape.by' can also be given column names in order to
#   show represent that columns data in the color or shape of the data points.
#   'shape.by' must be pointed to discrete data, but 'color.by' can be given
#   discrete or numeric data.
scatterPlot(
    example_df, x.by = "PC1", y.by = "PC2",
    color.by = "groups",
    shape.by = "SNP",
    size = 3)
scatterPlot(
    example_df, x.by = "PC1", y.by = "PC2",
    color.by = "gene1",
    size = 3)

# Data can be "split" or faceted by a discrete variable as well.
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "gene1",
    split.by = "timepoint") # single split.by element
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "gene1",
    split.by = c("groups","SNP")) # row and col split.by elements

# Modify the look with intuitive inputs
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    size = 5,
    opacity = 0.3,
    show.grid.lines = FALSE,
    ylab = NULL, xlab = "PC2 by PC1",
    main = "Plot Title",
    sub = "subtitle",
    legend.color.title = "Legend\nRetitle")

# You can restrict to only certain data points using the 'rows.use' input.
#   The input can be given rownames, indexes, or a logical vector
#   All "other" points will now only be shown as a gray background, or will not
#   be shown add all if you also add 'show.others = FALSE'
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    sub = "show only first 40 observations, by index",
    rows.use = 1:40)
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    sub = "show only 3 observations, by name",
    rows.use = c("obs1", "obs2", "obs25"))
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    sub = "show groups A,B,D only, by logical, without others as background",
    rows.use = example_df$groups!="C",
    show.others = FALSE)

# Many extra features are easy to add as well:
#   Each is started via an input starting with 'do.FEATURE*' or 'add.FEATURE*'
#   And when tweaks for that feature are possible, those inputs will start be
#   named starting with 'FEATURE*'. For example, color.by groups can be labeled
#   with 'do.label = TRUE' and the tweaks for this feature are given with inputs
#   'labels.size', 'labels.highlight', and 'labels.repel':
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    sub = "default labeling",
    do.label = TRUE)          # Turns on the labeling feature
scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    sub = "tweaked labeling",
    do.label = TRUE,          # Turns on the labeling feature
    labels.size = 8,          # Adjust the text size of labels
    labels.highlight = FALSE, # Removes white background behind labels
    labels.repel = FALSE)     # Turns off anti-overlap location adjustments

# Faceting can also be used to show multiple continuous variables side-by-side
#   by giving a vector of column names to 'color.by'.
#   This can also be combined with 1 'split.by' variable, with direction then
#   controlled via 'multivar.split.dir':
scatterPlot(example_df, x.by = "PC1", y.by = "PC2",
    color.by = c("gene1", "gene2"))
scatterPlot(example_df, x.by = "PC1", y.by = "PC2",
    color.by = c("gene1", "gene2"),
    split.by = "groups")
scatterPlot(example_df, x.by = "PC1", y.by = "PC2",
    color.by = c("gene1", "gene2"),
    split.by = "groups",
    multivar.split.dir = "row")

# Sometimes, it can be useful for external editing or troubleshooting purposes
#   to see the underlying data that was directly used for plotting.
# 'data.out = TRUE' can be provided in order to obtain not just plot ("plot"),
#   but also the "Target_data" and "Others_data" data.frames and "cols_used"
#   returned as a list.
out &lt;- scatterPlot(example_df, x.by = "PC1", y.by = "PC2", color.by = "groups",
    rows.use = 1:40,
    data.out = TRUE)
out$plot
summary(out$Target_data)
summary(out$Others_data)
out$cols_used

</code></pre>

<hr>
<h2 id='yPlot'>Plots continuous data per group on a y- (or x-) axis using customizable data representations</h2><span id='topic+yPlot'></span><span id='topic+ridgePlot'></span><span id='topic+ridgeJitter'></span><span id='topic+boxPlot'></span>

<h3>Description</h3>

<p>Plots continuous data per group on a y- (or x-) axis using customizable data representations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yPlot(
  data_frame,
  var,
  group.by,
  color.by = group.by,
  shape.by = NULL,
  split.by = NULL,
  rows.use = NULL,
  plots = c("vlnplot", "boxplot", "jitter"),
  multivar.aes = c("split", "group", "color"),
  multivar.split.dir = c("col", "row"),
  var.adjustment = NULL,
  var.adj.fxn = NULL,
  do.hover = FALSE,
  hover.data = unique(c(var, paste0(var, ".adj"), "var.multi", "var.which", group.by,
    color.by, shape.by, split.by)),
  hover.round.digits = 5,
  color.panel = dittoColors(),
  colors = seq_along(color.panel),
  shape.panel = c(16, 15, 17, 23, 25, 8),
  theme = theme_classic(),
  main = "make",
  sub = NULL,
  ylab = "make",
  y.breaks = NULL,
  min = NA,
  max = NA,
  xlab = "make",
  x.labels = NULL,
  x.labels.rotate = NA,
  x.reorder = NULL,
  split.nrow = NULL,
  split.ncol = NULL,
  split.adjust = list(),
  do.raster = FALSE,
  raster.dpi = 300,
  jitter.size = 1,
  jitter.width = 0.2,
  jitter.color = "black",
  jitter.shape.legend.size = 5,
  jitter.shape.legend.show = TRUE,
  jitter.position.dodge = boxplot.position.dodge,
  boxplot.width = 0.2,
  boxplot.color = "black",
  boxplot.show.outliers = NA,
  boxplot.outlier.size = 1.5,
  boxplot.fill = TRUE,
  boxplot.position.dodge = vlnplot.width,
  boxplot.lineweight = 1,
  vlnplot.lineweight = 1,
  vlnplot.width = 1,
  vlnplot.scaling = "area",
  vlnplot.quantiles = NULL,
  ridgeplot.lineweight = 1,
  ridgeplot.scale = 1.25,
  ridgeplot.ymax.expansion = NA,
  ridgeplot.shape = c("smooth", "hist"),
  ridgeplot.bins = 30,
  ridgeplot.binwidth = NULL,
  add.line = NULL,
  line.linetype = "dashed",
  line.color = "black",
  legend.show = TRUE,
  legend.title = "make",
  data.out = FALSE
)

ridgePlot(..., plots = c("ridgeplot"))

ridgeJitter(..., plots = c("ridgeplot", "jitter"))

boxPlot(..., plots = c("boxplot", "jitter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yPlot_+3A_data_frame">data_frame</code></td>
<td>
<p>A data_frame where columns are features and rows are observations you might wish to visualize.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_var">var</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> to be used as the primary, y-axis, data.
Alternatively, a string vector naming multiple such columns of data to plot at once.
See the input <code>multivar.aes</code> to understand or tweak how multiple var-data will be shown.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_group.by">group.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> containing discrete data to use for separating the data points into groups.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_color.by">color.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> containing discrete data to use for setting data representation color fills.
This data does not need to be the same as <code>group.by</code>, which is great for highlighting supersets or subgroups when wanted, but it defaults to <code>group.by</code> so the input can often be skipped.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_shape.by">shape.by</code></td>
<td>
<p>Single string representing the name of a column of <code>data_frame</code> containing discrete data to use for setting shapes of the jitter points.
When not provided, all jitter points will be dots.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_split.by">split.by</code></td>
<td>
<p>1 or 2 strings denoting the name(s) of column(s) of <code>data_frame</code> containing discrete data to use for faceting / separating data points into separate plots.
</p>
<p>When 2 columns are named, c(row,col), the first is used as rows and the second is used for columns of the resulting facet grid.
</p>
<p>When 1 column is named, shape control can be achieved with <code>split.nrow</code> and <code>split.ncol</code></p>
</td></tr>
<tr><td><code id="yPlot_+3A_rows.use">rows.use</code></td>
<td>
<p>String vector of rownames of <code>data_frame</code> OR an integer vector specifying the row-indices of data points which should be plotted.
</p>
<p>Alternatively, a Logical vector, the same length as the number of rows in <code>data_frame</code>, where <code>TRUE</code> values indicate which rows to plot.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_plots">plots</code></td>
<td>
<p>String vector which sets the types of plots to include: possibilities = &quot;jitter&quot;, &quot;boxplot&quot;, &quot;vlnplot&quot;, &quot;ridgeplot&quot;.
</p>
<p>Order matters: c(&quot;vlnplot&quot;, &quot;boxplot&quot;, &quot;jitter&quot;) will put a violin plot in the back, boxplot in the middle, and then individual dots in the front.
</p>
<p>See details section for more info.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_multivar.aes">multivar.aes</code></td>
<td>
<p>&quot;split&quot;, &quot;group&quot;, or &quot;color&quot;, the plot feature to utilize for displaying 'var' value when <code>var</code> is given multiple column names.
When set to &quot;split&quot; (the default), note that displaying the <code>var</code>-identity of the data will be prioritized so the <code>split.by</code> input becomes limited to receiving a single usable element.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_multivar.split.dir">multivar.split.dir</code></td>
<td>
<p>&quot;row&quot; or &quot;col&quot;, sets the direction of faceting used for 'var' values when: </p>

<ul>
<li> <p><code>var</code> is given multiple column names
</p>
</li>
<li> <p><code>multivar.aes = "split"</code> (default)
</p>
</li>
<li><p> AND <code>split.by</code> is used to provide an additional feature to facet by
</p>
</li></ul>
</td></tr>
<tr><td><code id="yPlot_+3A_var.adjustment">var.adjustment</code></td>
<td>
<p>A recognized string indicating whether numeric <code>var</code> data should be used directly (default) or should be adjusted to be
</p>

<ul>
<li><p>&quot;z-score&quot;: scaled with the scale() function to produce a relative-to-mean z-score representation
</p>
</li>
<li><p>&quot;relative.to.max&quot;: divided by the maximum expression value to give percent of max values between [0,1]
</p>
</li></ul>

<p>Ignored if the <code>var</code> data is not numeric as these known adjustments target numeric data only.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_var.adj.fxn">var.adj.fxn</code></td>
<td>
<p>If you wish to apply a function to edit the <code>var</code> data before use, in a way not possible with the <code>var.adjustment</code> input,
this input can be given a function which takes in a vector of values as input and returns a vector of values of the same length as output.
</p>
<p>For example, <code>function(x) {log2(x)}</code> or <code>as.factor</code>.
</p>
<p>In order to leave the unedited data available for use in other features, the adjusted data are put in a new column and that new column is used for plotting.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_do.hover">do.hover</code></td>
<td>
<p>Logical which controls whether the ggplot output will be converted to a plotly object so that data about individual points can be displayed when you hover your cursor over them.
The <code>hover.data</code> argument is used to determine what data to show upon hover.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_hover.data">hover.data</code></td>
<td>
<p>String vector which denotes what data to show for each jitter data point, upon hover, when <code>do.hover</code> is set to <code>TRUE</code>.
Defaults to all data expected to be useful.
Only values present in the plotting data are actually used.
These can be column names of <code>data_frame</code> and any column names which will be created to accommodate multivar and data adjustment functionality.
You can run the function with <code>data.out = TRUE</code> and inspect the <code>$data</code> output's columns to view your available options.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_hover.round.digits">hover.round.digits</code></td>
<td>
<p>Integer number specifying the number of decimal digits to round displayed numeric values to, when <code>do.hover</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_color.panel">color.panel</code></td>
<td>
<p>String vector which sets the colors to draw from for data representation fills.
Default = <code>dittoColors()</code>.
</p>
<p>A named vector can be used if names are matched to the distinct values of the <code>color.by</code> data.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_colors">colors</code></td>
<td>
<p>Integer vector, the indexes / order, of colors from <code>color.panel</code> to actually use.
</p>
<p>Useful for quickly swapping around colors of the default set (when not using names for color matching).</p>
</td></tr>
<tr><td><code id="yPlot_+3A_shape.panel">shape.panel</code></td>
<td>
<p>Vector of integers corresponding to ggplot shapes which sets what shapes to use.
When discrete groupings are supplied by <code>shape.by</code>, this sets the panel of shapes which will be used.
When nothing is supplied to <code>shape.by</code>, only the first value is used.
Default is a set of 6, <code>c(16,15,17,23,25,8)</code>, the first being a simple, solid, circle.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_theme">theme</code></td>
<td>
<p>A ggplot theme which will be applied before internal adjustments.
Default = <code>theme_classic()</code>.
See <a href="https://ggplot2.tidyverse.org/reference/ggtheme.html">https://ggplot2.tidyverse.org/reference/ggtheme.html</a> for other options and ideas.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_main">main</code></td>
<td>
<p>String, sets the plot title. Default = &quot;make&quot; and if left as make, a title will be automatically generated.  To remove, set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_sub">sub</code></td>
<td>
<p>String, sets the plot subtitle.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ylab">ylab</code></td>
<td>
<p>String, sets the continuous-axis label (=y-axis for box and violin plots, x-axis for ridgeplots).
Defaults to &quot;<code>var</code>&quot;.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_y.breaks">y.breaks</code></td>
<td>
<p>Numeric vector, a set of breaks that should be used as major grid lines. c(break1,break2,break3,etc.).</p>
</td></tr>
<tr><td><code id="yPlot_+3A_min">min</code>, <code id="yPlot_+3A_max">max</code></td>
<td>
<p>Scalars which control the zoom on the continuous axis of the plot.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_xlab">xlab</code></td>
<td>
<p>String which sets the grouping-axis label (=x-axis for box and violin plots, y-axis for ridgeplots).
Set to <code>NULL</code> to remove.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_x.labels">x.labels</code></td>
<td>
<p>String vector, c(&quot;label1&quot;,&quot;label2&quot;,&quot;label3&quot;,...) which overrides the names of groupings.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_x.labels.rotate">x.labels.rotate</code></td>
<td>
<p>Logical which sets whether the labels should be rotated.
Default: <code>TRUE</code> for violin and box plots, but <code>FALSE</code> for ridgeplots.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_x.reorder">x.reorder</code></td>
<td>
<p>Integer vector. A sequence of numbers, from 1 to the number of groupings, for rearranging the order of x-axis groupings.
</p>
<p>Method: Make a first plot without this input.
Then, treating the leftmost grouping as index 1, and the rightmost as index n.
Values of x.reorder should be these indices, but in the order that you would like them rearranged to be.
</p>
<p>Recommendation for advanced users: If you find yourself coming back to this input too many times, an alternative solution that can be easier long-term
is to make the target data into a factor, and to put its levels in the desired order: <code>factor(data, levels = c("level1", "level2", ...))</code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_split.nrow">split.nrow</code>, <code id="yPlot_+3A_split.ncol">split.ncol</code></td>
<td>
<p>Integers which set the dimensions of faceting/splitting when faceting by a single feature.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_split.adjust">split.adjust</code></td>
<td>
<p>A named list which allows extra parameters to be pushed through to the faceting function call.
List elements should be valid inputs to the faceting functions, e.g. 'list(scales = &quot;free&quot;)'.
</p>
<p>For options, when giving 1 column to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>,
OR when giving 2 columns to <code>split.by</code>, see <code><a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_do.raster">do.raster</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, rasterizes the jitter plot layer, changing it from individually encoded points to a flattened set of pixels.
This can be useful for editing in external programs (e.g. Illustrator) when there are many thousands of data points.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>Number indicating dots/pixels per inch (dpi) to use for rasterization. Default = 300.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.size">jitter.size</code></td>
<td>
<p>Scalar which sets the size of the jitter shapes.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.width">jitter.width</code></td>
<td>
<p>Scalar that sets the width/spread of the jitter in the x direction. Ignored in ridgeplots.
</p>
<p>Note for when <code>color.by</code> is used to split x-axis groupings into additional bins: ggplot does not shrink jitter widths accordingly, so be sure to do so yourself!
Ideally, needs to be 0.5/num_subgroups.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.color">jitter.color</code></td>
<td>
<p>String which sets the color of the jitter shapes</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.shape.legend.size">jitter.shape.legend.size</code></td>
<td>
<p>Scalar which changes the size of the shape key in the legend.
If set to <code>NA</code>, <code>jitter.size</code> is used.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.shape.legend.show">jitter.shape.legend.show</code></td>
<td>
<p>Logical which sets whether the shapes legend will be shown when its shape is determined by <code>shape.by</code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_jitter.position.dodge">jitter.position.dodge</code></td>
<td>
<p>Scalar which adjusts the relative distance between jitter widths when multiple subgroups exist per <code>group.by</code> grouping (a.k.a. when <code>group.by</code> and <code>color.by</code> are not equal).
Similar to <code>boxplot.position.dodge</code> input &amp; defaults to the value of that input so that BOTH will actually be adjusted when only, say, <code>boxplot.position.dodge = 0.3</code> is given.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.width">boxplot.width</code></td>
<td>
<p>Scalar which sets the width/spread of the boxplot in the x direction</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.color">boxplot.color</code></td>
<td>
<p>String which sets the color of the lines of the boxplot</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.show.outliers">boxplot.show.outliers</code></td>
<td>
<p>Logical, whether outliers should by including in the boxplot.
Default is <code>FALSE</code> when there is a jitter plotted, <code>TRUE</code> if there is no jitter.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.outlier.size">boxplot.outlier.size</code></td>
<td>
<p>Scalar which adjusts the size of points used to mark outliers.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.fill">boxplot.fill</code></td>
<td>
<p>Logical, whether the boxplot should be filled in or not.
Known bug: when boxplot fill is turned off, outliers do not render.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.position.dodge">boxplot.position.dodge</code></td>
<td>
<p>Scalar which adjusts the relative distance between boxplots when multiple are drawn per grouping (a.k.a. when <code>group.by</code> and <code>color.by</code> are not equal).
By default, this input actually controls the value of <code>jitter.position.dodge</code> unless the <code>jitter</code> version is provided separately.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_boxplot.lineweight">boxplot.lineweight</code></td>
<td>
<p>Scalar which adjusts the thickness of boxplot lines.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_vlnplot.lineweight">vlnplot.lineweight</code></td>
<td>
<p>Scalar which sets the thickness of the line that outlines the violin plots.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_vlnplot.width">vlnplot.width</code></td>
<td>
<p>Scalar which sets the width/spread of violin plots in the x direction</p>
</td></tr>
<tr><td><code id="yPlot_+3A_vlnplot.scaling">vlnplot.scaling</code></td>
<td>
<p>String which sets how the widths of the of violin plots are set in relation to each other.
Options are &quot;area&quot;, &quot;count&quot;, and &quot;width&quot;. If the default is not right for your data, I recommend trying &quot;width&quot;.
For an explanation of each, see <code><a href="ggplot2.html#topic+geom_violin">geom_violin</a></code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_vlnplot.quantiles">vlnplot.quantiles</code></td>
<td>
<p>Single number or numeric vector of values in [0,1] naming quantiles at which to draw a horizontal line within each violin plot. Example: <code>c(0.1, 0.5, 0.9)</code></p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.lineweight">ridgeplot.lineweight</code></td>
<td>
<p>Scalar which sets the thickness of the ridgeplot outline.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.scale">ridgeplot.scale</code></td>
<td>
<p>Scalar which sets the distance/overlap between ridgeplots.
A value of 1 means the tallest density curve just touches the baseline of the next higher one.
Higher numbers lead to greater overlap.  Default = 1.25</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.ymax.expansion">ridgeplot.ymax.expansion</code></td>
<td>
<p>Scalar which adjusts the minimal space between the topmost grouping and the top of the plot in order to ensure the curve is not cut off by the plotting grid.
The larger the value, the greater the space requested.
When left as NA, dittoViz will attempt to determine an ideal value itself based on the number of groups &amp; linear interpolation between these goal posts: #groups of 3 or fewer: 0.6; #groups=12: 0.1; #groups or 34 or greater: 0.05.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.shape">ridgeplot.shape</code></td>
<td>
<p>Either &quot;smooth&quot; or &quot;hist&quot;, sets whether ridges will be smoothed (the typical, and default) versus rectangular like a histogram.
(Note: as of the time shape &quot;hist&quot; was added, combination of jittered points is not supported by the <code><a href="ggridges.html#topic+stat_binline">stat_binline</a></code> that dittoViz relies on.)</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.bins">ridgeplot.bins</code></td>
<td>
<p>Integer which sets how many chunks to break the x-axis into when <code>ridgeplot.shape = "hist"</code>.
Overridden by <code>ridgeplot.binwidth</code> when that input is provided.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_ridgeplot.binwidth">ridgeplot.binwidth</code></td>
<td>
<p>Integer which sets the width of chunks to break the x-axis into when <code>ridgeplot.shape = "hist"</code>.
Takes precedence over <code>ridgeplot.bins</code> when provided.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_add.line">add.line</code></td>
<td>
<p>numeric value(s) where one or multiple line(s) should be added</p>
</td></tr>
<tr><td><code id="yPlot_+3A_line.linetype">line.linetype</code></td>
<td>
<p>String which sets the type of line for <code>add.line</code>.
Defaults to &quot;dashed&quot;, but any ggplot linetype will work.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_line.color">line.color</code></td>
<td>
<p>String that sets the color(s) of the <code>add.line</code> line(s)</p>
</td></tr>
<tr><td><code id="yPlot_+3A_legend.show">legend.show</code></td>
<td>
<p>Logical. Whether the legend should be displayed. Default = <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_legend.title">legend.title</code></td>
<td>
<p>String or <code>NULL</code>, sets the title for the main legend which includes colors and data representations.</p>
</td></tr>
<tr><td><code id="yPlot_+3A_data.out">data.out</code></td>
<td>
<p>Logical. When set to <code>TRUE</code>, changes the output, from the plot alone, to a list containing the plot (<code>p</code>), its underlying data (<code>data</code>),
and the ultimately used mapping of columns to given aesthetic sets, because modification of newly made columns is required for many features (&quot;cols_used&quot;).</p>
</td></tr>
<tr><td><code id="yPlot_+3A_...">...</code></td>
<td>
<p>arguments passed to yPlot by ridgePlot, ridgeJitter, and boxPlot wrappers.
Options are all the ones above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots the targeted <code>var</code> data of <code>data_frame</code>, grouped by the columns of data given to <code>group.by</code> and <code>color.by</code>, using data representations given by <code>plots</code>.
Data representations will also be colored (filled) based on <code>color.by</code>.
If a subset of data points to use is indicated with the <code>rows.use</code> input, the data_frame is internally subset to include only those indicated rows before plotting.
</p>
<p>The <code>plots</code> argument determines the types of data representation that will be generated, as well as their order from back to front.
Options are <code>"jitter"</code>, <code>"boxplot"</code>, <code>"vlnplot"</code>, and <code>"ridgeplot"</code>.
Inclusion of <code>"ridgeplot"</code> overrides <code>"boxplot"</code> and <code>"vlnplot"</code> presence and changes the plot to be horizontal.
</p>
<p>When <code>split.by</code> is provided a column name of <code>data_frame</code>, separate plots will be produced representing each of the distinct groupings of the split.by data using ggplots facetting functionality.
</p>
<p><code>ridgePlot</code>, <code>ridgeJitter</code>, and <code>boxPlot</code> are included as wrappers of the basic <code>yPlot</code> function
that simply change the default for the <code>plots</code> input to be <code>"ridgeplot"</code>, <code>c("ridgeplot","jitter")</code>, or <code>c("boxplot","jitter")</code>,
to make such plots even easier to produce.
</p>


<h3>Value</h3>

<p>a ggplot where continuous data, grouped by sample, age, cluster, etc., shown on either the y-axis by a violin plot, boxplot, and/or jittered points, or on the x-axis by a ridgeplot with or without jittered points.
</p>
<p>Alternatively when <code>data.out=TRUE</code>, a list containing
the plot (&quot;p&quot;)
the underlying data as a dataframe (&quot;data&quot;),
and the ultimately used mapping of columns to given aesthetic sets (&quot;cols_used&quot;), because modification of newly made columns is required for many features.
</p>
<p>Alternatively when <code>do.hover = TRUE</code>, a plotly converted version of the ggplot where additional data will be displayed when the cursor is hovered over jitter points.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ridgePlot()</code>: simple yPlot wrapper with distinct plots input defaults
</p>
</li>
<li> <p><code>ridgeJitter()</code>: simple yPlot wrapper with distinct plots input defaults
</p>
</li>
<li> <p><code>boxPlot()</code>: simple yPlot wrapper with distinct plots input defaults
</p>
</li></ul>


<h3>Many characteristics of the plot can be adjusted using discrete inputs</h3>

<p>The <code>plots</code> argument determines the types of <strong>data representation</strong> that will be generated, as well as their order from back to front.
Options are <code>"jitter"</code>, <code>"boxplot"</code>, <code>"vlnplot"</code>, and <code>"ridgeplot"</code>.
</p>
<p>Each plot type has specific associated options which are controlled by variables that start with their associated string.
For example, all jitter adjustments start with &quot;<code>jitter.</code>&quot;, such as <code>jitter.size</code> and <code>jitter.width</code>.
</p>
<p>Inclusion of <code>"ridgeplot"</code> overrides <code>"boxplot"</code> and <code>"vlnplot"</code> presence and changes the plot to be horizontal.
</p>
<p>Additionally:
</p>

<ul>
<li> <p><strong>Colors can be adjusted</strong> with <code>color.panel</code>.
</p>
</li>
<li> <p><strong>Subgroupings:</strong> <code>color.by</code> can be utilized to split major <code>group.by</code> groupings into subgroups.
When this is done in y-axis plotting, dittoViz automatically ensures the centers of all geoms will align,
but users will need to manually adjust <code>jitter.width</code> to less than 0.5/num_subgroups to avoid overlaps.
There are also three inputs through which one can use to control geom-center placement, but the easiest way to do all at once so is to just adjust <code>vlnplot.width</code>!
The other two: <code>boxplot.position.dodge</code>, and <code>jitter.position.dodge</code>.
</p>
</li>
<li> <p><strong>Line(s) can be added</strong> at single or multiple value(s) by providing these values to <code>add.line</code>.
Linetype and color are set with <code>line.linetype</code>, which is &quot;dashed&quot; by default, and <code>line.color</code>, which is &quot;black&quot; by default.
</p>
</li>
<li> <p><strong>Titles and axes labels</strong> can be adjusted with <code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>, and <code>legend.title</code> arguments.
</p>
</li>
<li><p> The <strong>legend can be hidden</strong> by setting <code>legend.show = FALSE</code>.
</p>
</li>
<li> <p><strong>y-axis zoom and tick marks</strong> can be adjusted using <code>min</code>, <code>max</code>, and <code>y.breaks</code>.
</p>
</li>
<li> <p><strong>x-axis labels and groupings</strong> can be changed / reordered using <code>x.labels</code> and <code>x.reorder</code>, and rotation of these labels can be turned on/off with <code>x.labels.rotate = TRUE/FALSE</code>.
</p>
</li>
<li> <p><strong>Shapes used</strong> in conjunction with <code>shape.by</code> can be adjusted with <code>shape.panel</code>.
This can be very useful for making manual additional alterations <em>after</em> dittoViz plot generation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Daniel Bunis
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridgePlot">ridgePlot</a></code>, <code><a href="#topic+ridgeJitter">ridgeJitter</a></code>, and <code><a href="#topic+boxPlot">boxPlot</a></code> for shortcuts to a few 'plots' input shortcuts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example("dittoExampleData", echo = FALSE)

# Basic yPlot, with jitter behind a vlnplot (looks better with more points)
yPlot(data_frame = example_df, var = "gene1", group.by = "timepoint")
yPlot(data_frame = example_df, var = c("gene1", "gene2"), group.by = "timepoint")

# Color distinctly from the grouping variable using 'color.by'
yPlot(data_frame = example_df, var = "gene1", group.by = "timepoint",
    color.by = "conditions")

# Update the 'plots' input to change / reorder the data representations
yPlot(example_df, "gene1", "timepoint",
    plots = c("vlnplot", "boxplot", "jitter"))
yPlot(example_df, "gene1", "timepoint",
    plots = c("ridgeplot", "jitter"))

# Provided wrappers enable certain easy adjustments of the 'plots' parameter.
# Quickly make a Boxplot
boxPlot(example_df, "gene1", "timepoint")
# Quickly make a Ridgeplot, with or without jitter
ridgePlot(example_df, "gene1", "timepoint")
ridgeJitter(example_df, "gene1", "timepoint")

# Modify the look with intuitive inputs
yPlot(example_df, "gene1", "timepoint",
    plots = c("vlnplot", "boxplot", "jitter"),
    boxplot.color = "white",
    main = "CD3E",
    legend.show = FALSE)

# Data can also be split in other ways with 'shape.by' or 'split.by'
yPlot(data_frame = example_df, var = "gene1", group.by = "timepoint",
    plots = c("vlnplot", "boxplot", "jitter"),
    shape.by = "clustering",
    split.by = "SNP") # single split.by element
yPlot(data_frame = example_df, var = "gene1", group.by = "timepoint",
    plots = c("vlnplot", "boxplot", "jitter"),
    split.by = c("groups","SNP")) # row and col split.by elements

# Multiple features can also be plotted at once by giving them as a vector to
#   the 'var' input. One aesthetic of the plot will then be used to display the
#   'var'-info, and you can control which (faceting / "split", x-axis grouping
#   / "group", or color / "color") with 'multivar.aes':
yPlot(data_frame = example_df, group.by = "timepoint",
    var = c("gene1", "gene2"))
yPlot(data_frame = example_df, group.by = "timepoint",
    var = c("gene1", "gene2"),
    multivar.aes = "group")
yPlot(data_frame = example_df, group.by = "timepoint",
    var = c("gene1", "gene2"),
    multivar.aes = "color")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
