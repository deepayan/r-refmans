<!DOCTYPE html><html><head><title>Help for package PPRL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PPRL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CompareAS16'><p>Comparing bit vectors generated by CreateAS16</p></a></li>
<li><a href='#Create581'><p>Create Encrypted Statistical Linkage Keys</p></a></li>
<li><a href='#CreateALC'>
<p>Anonymous Linkage Codes (ALCs)</p></a></li>
<li><a href='#CreateAS16'><p>Creating Records with Armknechts method create</p></a></li>
<li><a href='#CreateBalancedBF'><p>Balanced Bloom Filter Encoding</p></a></li>
<li><a href='#CreateBF'><p>Bloom Filter Encoding</p></a></li>
<li><a href='#CreateBitFlippingBF'><p>Permanent Randomized Response Bloom Filters</p></a></li>
<li><a href='#CreateCLK'><p>Cryptographic Long-term Keys (CLKs)</p></a></li>
<li><a href='#CreateDoubleBalancedBF'><p>Double Balanced Bloomfilter Encoding</p></a></li>
<li><a href='#CreateEnsembleCLK'>
<p>Combine multiple independent CLKs using a simple majority rule</p></a></li>
<li><a href='#CreateMarkovCLK'>
<p>Create CLKs with Markov Chain-based transition matrix</p></a></li>
<li><a href='#CreateRecordLevelBF'><p>Record Level Bloom Filter (RLBF) Encoding</p></a></li>
<li><a href='#DeterministicLinkage'><p>Deterministic Record Linkage</p></a></li>
<li><a href='#ElegantPairingInt'><p>Elegant Pairing</p></a></li>
<li><a href='#ElegantPairingVec'><p>Simple Pairing Function</p></a></li>
<li><a href='#ProbabilisticLinkage'><p>Probabilistic Record Linkage</p></a></li>
<li><a href='#SelectBlockingFunction'><p>Select blocking method prior to linkage</p></a></li>
<li><a href='#SelectSimilarityFunction'>
<p>Select Similarity Function for Linkage</p></a></li>
<li><a href='#StandardizeString'><p>Standardize String</p></a></li>
<li><a href='#WolframRule30'><p>Apply Wolframs rule 30 on bit vectors</p></a></li>
<li><a href='#WolframRule90'><p>Apply Wolframs rule 90 on bit vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Privacy Preserving Record Linkage</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Rainer Schnell [aut, cph],
  Dorothea Rukasz [aut, cre],
  Christian Borgs [ctb],
  Stefan Brumme [ctb] (HMAC, SHA256),
  William B. Brogden [ctb] (Metaphone),
  Tim O'Brien [ctb] (Metaphone),
  Stephen Lacy [ctb] (Double Metaphone),
  Apache Software Foundation [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dorothea Rukasz &lt;mitarbeiter.schnell@uni-due.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for deterministic, probabilistic and privacy-preserving record linkage techniques. Combines the functionality of the 'Merge ToolBox' (<a href="https://www.record-linkage.de">https://www.record-linkage.de</a>) with current privacy-preserving techniques.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7), settings</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-10 10:23:54 UTC; julian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-10 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CompareAS16'>Comparing bit vectors generated by CreateAS16</h2><span id='topic+CompareAS16'></span>

<h3>Description</h3>

<p>Comparing all elements of two vectors of records with each other using Armknechts &amp; Schnells methods &quot;create&quot; and &quot;compare&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareAS16(IDA, dataA, IDB, dataB, password, t = 0.85)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CompareAS16_+3A_ida">IDA</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the first data.frame.</p>
</td></tr>
<tr><td><code id="CompareAS16_+3A_dataa">dataA</code></td>
<td>
<p>A character vector containing the bit vectors that are to be created by Armknechts method &quot;create&quot;.</p>
</td></tr>
<tr><td><code id="CompareAS16_+3A_idb">IDB</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the second data.frame.</p>
</td></tr>
<tr><td><code id="CompareAS16_+3A_datab">dataB</code></td>
<td>
<p>A character vector containing the bit vectors that are to be  created by Armknechts method &quot;create&quot;.</p>
</td></tr>
<tr><td><code id="CompareAS16_+3A_password">password</code></td>
<td>
<p>A string containing the password used in the method &quot;create&quot;.</p>
</td></tr>
<tr><td><code id="CompareAS16_+3A_t">t</code></td>
<td>
<p>A float containing the lower Tanimoto similarity threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two bit vectors generated by <code><a href="#topic+CreateAS16">CreateAS16</a></code> are compared as described in the original publication.
</p>


<h3>Value</h3>

<p>The function returns a data.frame with four columns containing all ID-pairs of all bit vectors, the estimated Tanimoto similarity and the classification (links/non-links).
</p>


<h3>Source</h3>

<p>Armknecht, F., Schnell, R. (unpublished): Privacy Preserving Record Linkage Based on
Bloom Filters and Codes. Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateAS16">CreateAS16</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create Bloom Filter
testData &lt;- CreateBF(ID = testData$V1, testData$V7, k = 20, padding = 1,
  q = 2, l = 1000, password = "(H]$6Uh*-Z204q")

# Optional: Create the new Bloom filter, the output of this function is just
# to see the created bit vectors, it is not the input of CompareAS16.
testAS &lt;- CreateAS16(testData$ID, testData$CLKs, password = "khäuds")

# Compare bit vectcors, input is not the out put of CreateAS16,
# but the original Bloom Filters. CreateAS16 is executated in CompareAS16.
res &lt;- CompareAS16(testData$ID, testData$CLKs, testData$ID, testData$CLKs,
  password = "khäuds", t = 0.85)

</code></pre>

<hr>
<h2 id='Create581'>Create Encrypted Statistical Linkage Keys</h2><span id='topic+Create581'></span><span id='topic+ESL'></span><span id='topic+581'></span><span id='topic+Australian'></span>

<h3>Description</h3>

<p>Creates ESLs (also known as 581-Keys), which are the hashed combination of the full date of birth and sex and subsets of first and last names. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Create581(ID, data, code, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Create581_+3A_id">ID</code></td>
<td>
<p>a character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="Create581_+3A_data">data</code></td>
<td>
<p>a data.frame containig the data to be encoded.</p>
</td></tr>
<tr><td><code id="Create581_+3A_code">code</code></td>
<td>
<p>a list indicating  how data is to be encoded for each column. The list must have the same length as the number of columns of the data.frame to be encrypted.</p>
</td></tr>
<tr><td><code id="Create581_+3A_password">password</code></td>
<td>
<p>a string used as a password for the HMAC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original implementation uses the second and third position of the first name, the second, third and fifth position of the last name and full date of birth and sex as an input for an HMAC. This would be akin to using <code>code = list(c(2, 3), c(2, 3, 5), 0, 0)</code>. In this implementation, the positions of the subsets can be customized.
</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding Encrypted Statistical Linkage Keys.
</p>


<h3>Source</h3>

<p>Karmel, R., Anderson, P., Gibson, D., Peut, A., Duckett, S., Wells, Y. (2010): Empirical aspects of record linkage across multiple data sets using statistical linkage keys: the experience of the PIAC cohort study. BMC Health Services Research 41(10).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateALC">CreateALC</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Encrypt data
res &lt;- Create581(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  code = list(0, 0, c(2, 3), c(2, 3, 5)),
  password = "(H]$6Uh*-Z204q")

# Code: 0 means the whole string is used, 
# c(2, 3) means the second and third letter of the string is used

</code></pre>

<hr>
<h2 id='CreateALC'>
Anonymous Linkage Codes (ALCs)
</h2><span id='topic+CreateALC'></span><span id='topic+ALC'></span><span id='topic+Soundex'></span>

<h3>Description</h3>

<p>Creates ALCs from clear-text data by creating soundex phonetics for first and last names and concatenating all other identifiers. The resulting code is encrypted using SHA-2. The user can decide on which columns the soundex phonetic is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateALC(ID, data, soundex, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateALC_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateALC_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to be encoded.</p>
</td></tr>
<tr><td><code id="CreateALC_+3A_soundex">soundex</code></td>
<td>
<p>a binary vector with one element for each input column, indicating whether soundex is to be used. 1 = soundex is used, 0 = soundex is not used. The soundex vector must have the same length as the number of columns the data.frame.</p>
</td></tr>
<tr><td><code id="CreateALC_+3A_password">password</code></td>
<td>
<p>a string used as a password for the HMAC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding Anonymous Linkage Codes.
</p>


<h3>Source</h3>

<p>Herzog, T. N., Scheuren, F. J., Winkler, W. E. (2007): Data Quality and Record Linkage Techniques. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Create581">Create581</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Encrypt data, use Soundex for names
res &lt;- CreateALC(ID = testData$V1,   
  data = testData[, c(2, 3, 7, 8)],
  soundex = c(0, 0, 1, 1),  
  password = "$6Uh*-Z204q")
  
</code></pre>

<hr>
<h2 id='CreateAS16'>Creating Records with Armknechts method create</h2><span id='topic+CreateAS16'></span><span id='topic+Armknecht'></span>

<h3>Description</h3>

<p>This method generates a new bit vector out of an existing Bloom Filter. Building and comparisons are both possible with <code><a href="#topic+CompareAS16">CompareAS16</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateAS16(ID, data, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateAS16_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the second data.frame.</p>
</td></tr>
<tr><td><code id="CreateAS16_+3A_data">data</code></td>
<td>
<p>A character vector containing the original bit vectors created by any Bloom Filter-based method.</p>
</td></tr>
<tr><td><code id="CreateAS16_+3A_password">password</code></td>
<td>
<p>A string containing the password to be used for both &quot;create&quot; and &quot;compare&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing bit vectors created as described in the original publication.
</p>


<h3>Source</h3>

<p>Armknecht, F., Schnell, R. (unpublished): Privacy Preserving Record Linkage Based on
Bloom Filters and Codes. Working Paper.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CompareAS16">CompareAS16</a></code>,
<code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create Bloom Filter
testData &lt;- CreateBF(ID = testData$V1, testData$V7, k = 20, padding = 1,
  q = 2, l = 1000, password = "(H]$6Uh*-Z204q")

# Create the new Bloom Filter
testAS &lt;- CreateAS16(testData$ID, testData$CLKs, password = "khäuds")


</code></pre>

<hr>
<h2 id='CreateBalancedBF'>Balanced Bloom Filter Encoding</h2><span id='topic+CreateBalancedBF'></span><span id='topic+BalancedBloomfilter'></span><span id='topic+Balanced+20Codes'></span><span id='topic+Green+20function'></span><span id='topic+Balanced+20Bloom+20Filter'></span>

<h3>Description</h3>

<p>Creates CLKs with constant Hamming weights by adding a negated copy of the binary input vector which is then permutated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateBalancedBF(ID, data, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateBalancedBF_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateBalancedBF_+3A_data">data</code></td>
<td>
<p>Bit vectors as created by any Bloom filter-based method.</p>
</td></tr>
<tr><td><code id="CreateBalancedBF_+3A_password">password</code></td>
<td>
<p>a string used as a password for the random permutation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding Balanced Bloom Filter.
</p>


<h3>References</h3>

<p>Berger, J. M. (1961): A Note on Error Detection Codes for
Asymmetric Channels. In: Information and Control 4: 68–73.
</p>
<p>Knuth, Donald E. (1986): Efficient Balanced Codes. In: IEEE
Transactions on Information Theory IT-32 (1): 51–53.
</p>
<p>Schnell, R., Borgs, C. (2016): Randomized Response and Balanced Bloom Filters for Privacy Preserving Record Linkage. IEEE International Conference on Data Mining (ICDM 2016), Barcelona.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateBitFlippingBF">CreateBitFlippingBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+CreateDoubleBalancedBF">CreateDoubleBalancedBF</a></code>,
<code><a href="#topic+CreateEnsembleCLK">CreateEnsembleCLK</a></code>,
<code><a href="#topic+CreateMarkovCLK">CreateMarkovCLK</a></code>,
<code><a href="#topic+CreateRecordLevelBF">CreateRecordLevelBF</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create bit vectors e.g. with CreateBF
testData &lt;- CreateBF(ID = testData$V1,
  testData$V7, k = 20, padding = 1, q = 2,
  l = 1000, password = "(H]$6Uh*-Z204q")

# Create Balanced Bloom Filters
BB &lt;- CreateBalancedBF(ID = testData$ID, data = testData$CLKs,
  password = "hdayfkgh")

</code></pre>

<hr>
<h2 id='CreateBF'>Bloom Filter Encoding</h2><span id='topic+CreateBF'></span><span id='topic+BF'></span><span id='topic+Bloomfilter'></span><span id='topic+Bloom+20Filter'></span>

<h3>Description</h3>

<p>Creates Bloom filters for each row of the input data by splitting the input into q-grams which are hashed into a bit vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateBF(ID, data, password, k = 20, padding = 1, qgram = 2, lenBloom = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateBF_+3A_id">ID</code></td>
<td>
<p>a character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_data">data</code></td>
<td>
<p>a character vector containing the data to be encoded. Make sure the input vectors are not factors.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_password">password</code></td>
<td>
<p>a string used as a password for the random hashing of the q-grams.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_k">k</code></td>
<td>
<p>number of bit positions set to one for each bigram.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_padding">padding</code></td>
<td>
<p>integer (0 or 1) indicating if string padding is to be used.</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_qgram">qgram</code></td>
<td>
<p>integer (1 or 2) indicating whether to split the input strings into bigrams (q = 2) or unigrams (q = 1).</p>
</td></tr>
<tr><td><code id="CreateBF_+3A_lenbloom">lenBloom</code></td>
<td>
<p>desired length of the Bloom filter in bits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding bit vector.
</p>


<h3>Source</h3>

<p>Schnell, R., Bachteler, T., Reiher, J. (2009): Privacy-preserving record linkage using Bloom filters. BMC Medical Informatics and Decision Making 9: 41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Encode data
BF &lt;- CreateBF(ID = testData$V1, data = testData$V7,
  k = 20, padding = 1, q = 2, l = 1000,
  password = "(H]$6Uh*-Z204q")

</code></pre>

<hr>
<h2 id='CreateBitFlippingBF'>Permanent Randomized Response Bloom Filters</h2><span id='topic+CreateBitFlippingBF'></span><span id='topic+RRT'></span><span id='topic+Permanent+20Randomized+20Response'></span>

<h3>Description</h3>

<p>Applies Permanent Randomized Response to flip bits of the bit vectors given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateBitFlippingBF(data, password, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateBitFlippingBF_+3A_data">data</code></td>
<td>
<p>a data.frame containing the IDs in the first column and bit vectors created by any Bloom filter-based method in the second column.</p>
</td></tr>
<tr><td><code id="CreateBitFlippingBF_+3A_password">password</code></td>
<td>
<p>a string to seed the random bit flipping.</p>
</td></tr>
<tr><td><code id="CreateBitFlippingBF_+3A_f">f</code></td>
<td>
<p>a numeric between 0 and 1 giving the probability of flipping a bit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The randomized response technique is used on each
bit position B[i] of a Bloom filter B. B[i] is set to one or zero with a probability of <code class="reqn">1/2 * f</code> for each outcome. The bit position remains unchanged with a probability of <code class="reqn">1 - f</code>, where  <code class="reqn"> 0 &lt;= f &lt;= 1</code>.</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding bit vector.
</p>


<h3>Source</h3>

<p>Schnell, R., Borgs, C. (2016): Randomized Response and Balanced Bloom Filters for Privacy Preserving Record Linkage. IEEE International Conference on Data Mining (ICDM 2016), Barcelona.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;-read.csv(testFile, head = FALSE,
  sep = "\t", colClasses = "character")

## Encode data into Bloom Filters
BF &lt;- CreateBF(ID = testData$V1, data = testData$V7,
  k = 20, padding = 1, q = 2, l = 1000,
  password = "(H]$6Uh*-Z204q" )

# Create Permanent Randomized Response Bloom Filter
RR &lt;- CreateBitFlippingBF(BF, password = "l+kfdj1J", f = 0.1)

</code></pre>

<hr>
<h2 id='CreateCLK'>Cryptographic Long-term Keys (CLKs)</h2><span id='topic+CreateCLK'></span><span id='topic+CLK'></span><span id='topic+CLKs'></span><span id='topic+additive+20BF'></span>

<h3>Description</h3>

<p>Each column of the input data.frame is hashed into a single additive Bloom filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateCLK(ID, data, password, k = 20,
  padding =  as.integer(c(0)),
  qgram =  as.integer(c(2)), lenBloom = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateCLK_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to be encoded. Make sure the input vectors are not factors.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_password">password</code></td>
<td>
<p>a character vector with a password for each column of the input data.frame for the random hashing of the q-grams.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_k">k</code></td>
<td>
<p>number of bit positions set to one for each bigram.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_padding">padding</code></td>
<td>
<p>integer vector (0 or 1) indicating if string padding is to be used on the columns of the input. The padding vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_qgram">qgram</code></td>
<td>
<p>integer vector (1 or 2) indicating whether to split the input strings into bigrams (q = 2) or unigrams (q = 1). The qgram vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateCLK_+3A_lenbloom">lenBloom</code></td>
<td>
<p>desired length of the final Bloom filter in bits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding bit vector.
</p>


<h3>Source</h3>

<p>Schnell, R. (2014): An efficient Privacy-Preserving Record Linkage Technique for Administrative Data and Censuses. Journal of the International Association for Official Statistics (IAOS) 30: 263-270.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;-read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

## Encode data
CLK &lt;- CreateCLK(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  k = 20, padding = c(0, 0, 1, 1),
  q = c(1, 1, 2, 2), l = 1000,
  password = c("HUh4q", "lkjg", "klh", "Klk5"))

</code></pre>

<hr>
<h2 id='CreateDoubleBalancedBF'>Double Balanced Bloomfilter Encoding</h2><span id='topic+CreateDoubleBalancedBF'></span><span id='topic+Double+20Balanced+20Bloom+20Filter'></span>

<h3>Description</h3>

<p>Double balanced Bloom Filter are created by first creating balanced Bloom Filters, see <code><a href="#topic+CreateBalancedBF">CreateBalancedBF</a></code>, negating the whole data set and shuffling each Bloom Filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateDoubleBalancedBF(ID, data, password)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateDoubleBalancedBF_+3A_id">ID</code></td>
<td>
<p>A character vector containing the ID. The ID vector must have the same size as the number of rows of data.</p>
</td></tr>
<tr><td><code id="CreateDoubleBalancedBF_+3A_data">data</code></td>
<td>
<p>CLKs as created by <code><a href="#topic+CreateCLK">CreateCLK</a></code> or <code><a href="#topic+CreateBF">CreateBF</a></code>.</p>
</td></tr>
<tr><td><code id="CreateDoubleBalancedBF_+3A_password">password</code></td>
<td>
<p>A string to encode the routines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding double balanced bit vector.
</p>


<h3>References</h3>

<p>Schnell, R. (2017): Recent Developments in Bloom Filter-based Methods for Privacy-preserving Record Linkage. Curtin Institute for Computation, Curtin University, Perth, 12.9.2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBalancedBF">CreateBalancedBF</a></code>,
<code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;-read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create bit vectors e.g. with CreateBF
testData &lt;- CreateBF(ID = testData$V1,
  testData$V7, k = 20, padding = 1, q = 2,
  l = 1000, password = "(H]$6Uh*-Z204q")

# Create Double Balanced Bloom Filters
DBB &lt;- CreateDoubleBalancedBF(ID = testData$ID, data = testData$CLKs,
  password = "hdayfkgh")

</code></pre>

<hr>
<h2 id='CreateEnsembleCLK'>
Combine multiple independent CLKs using a simple majority rule
</h2><span id='topic+CreateEnsembleCLK'></span><span id='topic+Ensemble+20CLK'></span><span id='topic+majority'></span><span id='topic+majority+20rule'></span>

<h3>Description</h3>

<p>Creates multiple CLKs which are combined using a simple majority rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateEnsembleCLK(ID, data, password, NumberOfCLK = 1 , k = 20,
  padding = as.integer(c(0)), qgram = as.integer(c(2)),
  lenBloom = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateEnsembleCLK_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to be encoded. Make sure the input vectors are not factors.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_password">password</code></td>
<td>
<p>a character vector with a password for each column of the input data.frame for the random hashing of the q-grams.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_numberofclk">NumberOfCLK</code></td>
<td>
<p>number of independent CLKs to be built.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_k">k</code></td>
<td>
<p>number of bit positions set to one for each bigram.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_padding">padding</code></td>
<td>
<p>integer vector (0 or 1) indicating if string padding is to be used on the columns of the input. The padding vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_qgram">qgram</code></td>
<td>
<p>integer vector (1 or 2) indicating whether to split the input strings into bigrams (q = 2) or unigrams (q = 1). The qgram vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateEnsembleCLK_+3A_lenbloom">lenBloom</code></td>
<td>
<p>desired length of the final Bloom filter in bits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a set number of independent CLKs for each record of the input data.frame and combines them using  a simple majority rule. The bit positions <code class="reqn">B[i]</code> in the final CLK of the length <code class="reqn">B</code> are set to <code class="reqn">B[i] = 1</code> if more than half of the independent CLKs bit positions <code class="reqn">B[i]</code> have a value of one. Otherwise the final bit position is zero.
</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding ensemble bit vector.
</p>


<h3>References</h3>

<p>Kuncheva, L. (2014): Combining Pattern Classifiers: Methods and Algorithms. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;-read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")
## Not run: 
# Create Ensemble CLK
EnsembleCLK &lt;- CreateEnsembleCLK(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  k = 20, padding = c(0, 0, 1, 1),
  q = c(1, 2, 2, 2), l = 1000,
  password = c("HUh4q", "lkjg", "klh", "Klk5"),
  NumberOfCLK = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='CreateMarkovCLK'>
Create CLKs with Markov Chain-based transition matrix
</h2><span id='topic+CreateMarkovCLK'></span><span id='topic+Markov+20Chains'></span>

<h3>Description</h3>

<p>Builds CLKs encoding additional bigrams based on the transition probabilities as estimated by a Markov Chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateMarkovCLK(ID, data, password, markovTable, k1 = 20, k2 = 4,
  padding = as.integer(c(0)), qgram = as.integer(c(2)),
  lenBloom = 1000,  includeOriginalBigram = TRUE, v = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateMarkovCLK_+3A_id">ID</code></td>
<td>
<p>a character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to be encoded. Make sure the input vectors are not factors.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_password">password</code></td>
<td>
<p>a character vector with a password for each column of the input data.frame for the random hashing of the q-grams.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_markovtable">markovTable</code></td>
<td>
<p>a numeric matrix containing the transition probabilities for all bigrams possible.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_k1">k1</code></td>
<td>
<p>number of bit positions set to one for each bigram.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_k2">k2</code></td>
<td>
<p>number of additional bigrams drawn for each original bigram.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_padding">padding</code></td>
<td>
<p>integer vector (0 or 1) indicating if string padding is to be used on the columns of the input. The padding vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_qgram">qgram</code></td>
<td>
<p>integer vector (1 or 2) indicating whether to split the input strings into bigrams (q = 2) or unigrams (q = 1). The qgram vector must have the same size as the number of columns of the input data.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_lenbloom">lenBloom</code></td>
<td>
<p>desired length of the final Bloom filter in bits.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_includeoriginalbigram">includeOriginalBigram</code></td>
<td>
<p>by default, the original bigram is encoded together with the additional bigrams. Set this to <code>FALSE</code> to include only the additional bigrams to further increase the security.</p>
</td></tr>
<tr><td><code id="CreateMarkovCLK_+3A_v">v</code></td>
<td>
<p>verbose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A transition matrix for all possible bigrams is built using a function to fit a markov chain distribution using a Laplacian smoother. A transition matrix built for bigrams using the NC Voter Data is included in the package. For each original bigram in the data, <code>k2</code> new bigrams are drawn according to their follow-up probability as given by the transition matrix. The final bigram set is then encoded following  <code><a href="#topic+CreateCLK">CreateCLK</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding bit vector.
</p>


<h3>References</h3>

<p>Schnell R., Borgs C. (2017): Using Markov Chains for Hardening Bloom Filter Encryptions against
Cryptographic Attacks in Privacy Preserving Record Linkage. German Record Linkage Center Working Paper.
</p>
<p>Schnell, R. (2017): Recent Developments in Bloom Filter-based Methods for Privacy-preserving Record Linkage. Curtin Institute for Computation, Curtin University, Perth, 12.9.2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;-read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

## Not run: 
# Load example Markov chain matrix (created from NC Voter Data)
markovFile &lt;-file.path(path.package("PPRL"), "extdata/TestMatrize.csv")
markovData &lt;-read.csv(markovFile,  sep = " ",
  header = TRUE, check.names = FALSE)
markovData &lt;- as.matrix(markovData)

# Create Markov CLK using
CLKMarkov &lt;- CreateMarkovCLK(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  markovTable = markovData,
  k1 = 20, k2 = 4, l = 1000,
  padding = c(0, 0, 1, 1),
  q = c(1, 2, 2, 2),
  password = c("(H]$6Uh*-Z204q", "lkjg", "klh", "KJHklk5"),
  includeOriginalBigram = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='CreateRecordLevelBF'>Record Level Bloom Filter (RLBF) Encoding</h2><span id='topic+CreateRecordLevelBF'></span><span id='topic+RLBF'></span><span id='topic+Record+20Level+20Bloom+20Filter'></span><span id='topic+Durham'></span>

<h3>Description</h3>

<p>Creates Record Level Bloom filters, combining single Bloom filters into a singular bit vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateRecordLevelBF(ID, data, password, lenRLBF = 1000, k = 20,
                       padding = as.integer(c(0)),
                       qgram = as.integer(c(2)),
                       lenBloom = as.integer(c(500)),
                       method = "StaticUniform",
                       weigths = as.numeric(c(1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateRecordLevelBF_+3A_id">ID</code></td>
<td>
<p>a character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_data">data</code></td>
<td>
<p>a character vector containing the data to be encoded. Make sure the input vectors are not factors.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_password">password</code></td>
<td>
<p>a string used as a password for the random hashing of the q-grams and the shuffling.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_lenrlbf">lenRLBF</code></td>
<td>
<p>length of the final Bloom filter.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_lenbloom">lenBloom</code></td>
<td>
<p>an integer vector containing the length of the first level Bloom filters which are to be combined. For the methods &quot;StaticUniform&quot; and &quot;StaticWeighted&quot;, a single integer is required, since all original Bloom filters will have the same length.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_k">k</code></td>
<td>
<p>number of bit positions set to one for each q-gram.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_padding">padding</code></td>
<td>
<p>integer (0 or 1) indicating if string padding is to be used.</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_qgram">qgram</code></td>
<td>
<p>integer (1 or 2) indicating whether to split the input strings into bigrams (q = 2) or unigrams (q = 1).</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_method">method</code></td>
<td>
<p>any of either &quot;StaticUniform&quot;, &quot;StaticWeigthed&quot;, &quot;DynamicUniform&quot; or &quot;DynamicWeighted&quot; (see details).</p>
</td></tr>
<tr><td><code id="CreateRecordLevelBF_+3A_weigths">weigths</code></td>
<td>
<p>weigths are used for the &quot;StaticWeighted&quot; and &quot;DynamicWeighted&quot; methods. The weights vector must have the same length as number of columns in the input data. The sum of the weights must be  1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Single Bloom filters are first built for every variable in the input data.frame. Combining the Bloom filters is done by sampling a set fraction of the original Bloom filters and concatenating the samples. The result is then shuffled. The sampling can be done using four different weighting methods:
</p>

<ol>
<li><p> StaticUniform
</p>
</li>
<li><p> StaticWeighted
</p>
</li>
<li><p> DynamicUniform
</p>
</li>
<li><p> DynamicWeighted
</p>
</li></ol>

<p>Details are described in the original publication.</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the corresponding bit vector.
</p>


<h3>Source</h3>

<p>Durham, E. A. (2012). A framework for accurate, efficient
private record linkage. Dissertation. Vanderbilt University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
## Not run: 
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# StaticUniform
RLBF &lt;- CreateRecordLevelBF(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  lenRLBF = 1000, k = 20,
  padding = c(0, 0, 1, 1), qgram = c(1, 1, 2, 2),
  lenBloom = 500,
  password = c("(H]$6Uh*-Z204q", "lkjg", "klh", "KJHkälk5"),
  method = "StaticUniform")

# StaticWeigthed
RLBF &lt;- CreateRecordLevelBF(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  lenRLBF = 1000, k = 20,
  padding = c(0, 0, 1, 1), qgram = c(1, 1, 2, 2),
  lenBloom = 500,
  password = c("(H]$6Uh*-Z204q", "lkjg", "klh", "KJHkälk5"),
  method = "StaticWeigthed", weigths = c(0.1, 0.1, 0.5, 0.3))

# DynamicUniform
RLBF &lt;- CreateRecordLevelBF(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  lenRLBF = 1000, k = 20,
  padding = c(0, 0, 1, 1), qgram = c(1, 1, 2, 2),
  lenBloom = c(300, 400, 550, 500),
  password = c("(H]$6Uh*-Z204q", "lkjg", "klh", "KJHkälk5"),
  method = "DynamicUniform")

# DynamicWeigthed
RLBF &lt;- CreateRecordLevelBF(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  lenRLBF = 1000, k = 20,
  padding = c(0, 0, 1, 1), qgram = c(1, 1, 2, 2),
  lenBloom = c(300, 400, 550, 500),
  password = c("(H]$6Uh*-Z204q", "lkjg", "klh", "KJHkälk5"),
  method = "DynamicWeigthed", weigths = c(0.1, 0.1, 0.5, 0.3))

## End(Not run)
</code></pre>

<hr>
<h2 id='DeterministicLinkage'>Deterministic Record Linkage</h2><span id='topic+DeterministicLinkage'></span><span id='topic+Record+20Linkage'></span>

<h3>Description</h3>

<p>Deterministic Record Linkage of two data sets giving results enabling rule-based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeterministicLinkage(IDA, dataA, IDB, dataB, blocking = NULL, similarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeterministicLinkage_+3A_ida">IDA</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the first data.frame.</p>
</td></tr>
<tr><td><code id="DeterministicLinkage_+3A_dataa">dataA</code></td>
<td>
<p>A data.frame containing the data to be linked and all linking variables as specified in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
<tr><td><code id="DeterministicLinkage_+3A_idb">IDB</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the second data.frame.</p>
</td></tr>
<tr><td><code id="DeterministicLinkage_+3A_datab">dataB</code></td>
<td>
<p>A data.frame containing the data to be linked and all linking variables as specified in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
<tr><td><code id="DeterministicLinkage_+3A_blocking">blocking</code></td>
<td>
<p>Optional blocking variables. See <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code>.</p>
</td></tr>
<tr><td><code id="DeterministicLinkage_+3A_similarity">similarity</code></td>
<td>
<p>Variables used for linking and their respective linkage methods as specified in <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To call the Deterministic Linkage function it is necessary to set up linking variables and methods. Using blocking variables is optional. Further options are available in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame containing ID-pairs and the link status for each linking variable. This way, rules can be put into place allowing the user to classify links and non-links.
</p>


<h3>Source</h3>

<p>Christen, P. (2012): Data Matching - Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection. Springer.
</p>
<p>Schnell, R., Bachteler, T., Reiher, J. (2004): A toolbox for record linkage. Austrian Journal of Statistics 33(1-2): 125-133.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>,
<code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code>,
<code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# define year of birth (V3) as blocking variable
bl &lt;- SelectBlockingFunction("V3", "V3", method = "exact")

# Select first name and last name as linking variables,
# to be linked using the soundex phonetic (first name)
# and exact matching (last name)
l1 &lt;- SelectSimilarityFunction("V7", "V7", method = "Soundex")
l2 &lt;- SelectSimilarityFunction("V8", "V8", method = "exact")

# Link the data as specified in bl and l1/l2
# (in this small example data is linked to itself)
res &lt;- DeterministicLinkage(testData$V1, testData,
  testData$V1, testData, similarity = c(l1, l2), blocking = bl)

</code></pre>

<hr>
<h2 id='ElegantPairingInt'>Elegant Pairing</h2><span id='topic+ElegantPairingInt'></span><span id='topic+elegant+20pairing'></span>

<h3>Description</h3>

<p>Unordered Pairing Function creating a new unique integer from two input integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElegantPairingInt(int1, int2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElegantPairingInt_+3A_int1">int1</code></td>
<td>
<p>first integer to be paired.</p>
</td></tr>
<tr><td><code id="ElegantPairingInt_+3A_int2">int2</code></td>
<td>
<p>second integer to be paired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With two of non-negative integers x and y as an input, the pairing is computed as:
</p>
<p style="text-align: center;"><code class="reqn">elegantPairing(x, y) = (x * y) + floor ((|x - y| - 1)^2) / 4)</code>
</p>

<p>The function is commutative. x and y have to be non-negative integers.</p>


<h3>Value</h3>

<p>The function outputs a single non-negative integer that is uniquely associated with that unordered pair.
</p>


<h3>Source</h3>

<p>Szudzik, M. (2006): An Elegant Pairing Function. Wolfram Science Conference NKS 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ElegantPairingVec">ElegantPairingVec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ElegantPairingInt(2, 3)

</code></pre>

<hr>
<h2 id='ElegantPairingVec'>Simple Pairing Function</h2><span id='topic+ElegantPairingVec'></span><span id='topic+Pairing'></span><span id='topic+unordered+20pairing'></span>

<h3>Description</h3>

<p>Unordered Pairing Function creating a new unique integer from two input integers in a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElegantPairingVec (ID, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElegantPairingVec_+3A_id">ID</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the data.frame.</p>
</td></tr>
<tr><td><code id="ElegantPairingVec_+3A_data">data</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> consisting of two columns containing the integers on which the pairing function is to be applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With two of non-negative integers x and y as an input, the pairing is computed as:
</p>
<p style="text-align: center;"><code class="reqn">elegantPairing(x, y) = (x * y) + floor ((|x - y| - 1)^2) / 4)</code>
</p>

<p>The function is commutative. x and y have to be non-negative integers. The function outputs a single
non-negative integer that is uniquely associated with that unordered pair.</p>


<h3>Value</h3>

<p>A data.frame containing IDs and the computed integer.
</p>


<h3>Source</h3>

<p>Szudzik, M. (2006): An Elegant Pairing Function. Wolfram Science Conference NKS 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ElegantPairingInt">ElegantPairingInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create numeric data frame of day and month of birth
dataInt &lt;- data.frame(as.integer(testData$V4), as.integer(testData$V5))

# Use unordered pairing on day and month
res &lt;- ElegantPairingVec(testData$V1, dataInt)

</code></pre>

<hr>
<h2 id='ProbabilisticLinkage'>Probabilistic Record Linkage</h2><span id='topic+ProbabilisticLinkage'></span><span id='topic+MergeToolBox'></span><span id='topic+Merge+20Tool+20Box'></span><span id='topic+Probabilistic'></span>

<h3>Description</h3>

<p>Probabilistic Record Linkage of two data sets using distance-based or probabilistic methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProbabilisticLinkage(IDA, dataA, IDB, dataB,  blocking = NULL, similarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ProbabilisticLinkage_+3A_ida">IDA</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the first data.frame.</p>
</td></tr>
<tr><td><code id="ProbabilisticLinkage_+3A_dataa">dataA</code></td>
<td>
<p>A data.frame containing the data to be linked and all linking variables as specified in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
<tr><td><code id="ProbabilisticLinkage_+3A_idb">IDB</code></td>
<td>
<p>A character vector or integer vector containing the IDs of the second data.frame.</p>
</td></tr>
<tr><td><code id="ProbabilisticLinkage_+3A_datab">dataB</code></td>
<td>
<p>A data.frame containing the data to be linked and all linking variables as specified in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
<tr><td><code id="ProbabilisticLinkage_+3A_blocking">blocking</code></td>
<td>
<p>Optional blocking variables. See <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code>.</p>
</td></tr>
<tr><td><code id="ProbabilisticLinkage_+3A_similarity">similarity</code></td>
<td>
<p>Variables used for linking and their respective linkage methods as specified in <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To call the Probabilistic Linkage function it is necessary to set up linking variables and methods. Using blocking variables is optional. Further options are available in <code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code> and <code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>. Using this method, the Fellegi-Sunter model is used, with the EM algorithm estimating the weights (Winkler 1988).
</p>


<h3>Value</h3>

<p>A data.frame containing pairs of IDs, their corresponding similarity value and the match status as determined by the linkage procedure.
</p>


<h3>Source</h3>

<p>Christen, P. (2012): Data Matching - Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection. Springer.
</p>
<p>Schnell, R., Bachteler, T., Reiher, J. (2004): A toolbox for record linkage. Austrian Journal of Statistics 33(1-2): 125-133.
</p>
<p>Winkler, W. E. (1988): Using the EM algorithm for weight computation in the Fellegi-Sunter model of record linkage. Proceedings of the Section on Survey Research Methods Vol. 667, American Statistical Association: 671.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CreateBF">CreateBF</a></code>,
<code><a href="#topic+CreateCLK">CreateCLK</a></code>,
<code><a href="#topic+DeterministicLinkage">DeterministicLinkage</a></code>,
<code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code>,
<code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# define year of birth (V3) as blocking variable
bl &lt;- SelectBlockingFunction("V3", "V3", method = "exact")

# Select first name and last name as linking variables,
# to be linked using the Jaro-Winkler similarity measure (first name)
# and levenshtein distance (last name)
l1 &lt;- SelectSimilarityFunction("V7", "V7", method = "jw")
l2 &lt;- SelectSimilarityFunction("V8", "V8", method = "lv")

# Link the data as specified in bl and l1/l2
# (in this small example data is linked to itself)
res &lt;- ProbabilisticLinkage(testData$V1, testData,
  testData$V1, testData, similarity = c(l1, l2), blocking = bl)

</code></pre>

<hr>
<h2 id='SelectBlockingFunction'>Select blocking method prior to linkage</h2><span id='topic+SelectBlockingFunction'></span><span id='topic+blocking'></span><span id='topic+indexing'></span><span id='topic+partitioning'></span>

<h3>Description</h3>

<p>Before calling <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code> or <code><a href="#topic+DeterministicLinkage">DeterministicLinkage</a></code>, a blocking method can be selected. For each blocking variable desired, the function call has to be repeated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectBlockingFunction(variable1, variable2, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectBlockingFunction_+3A_variable1">variable1</code></td>
<td>
<p>Column name of blocking variable 1.</p>
</td></tr>
<tr><td><code id="SelectBlockingFunction_+3A_variable2">variable2</code></td>
<td>
<p>Column name of blocking variable 2.</p>
</td></tr>
<tr><td><code id="SelectBlockingFunction_+3A_method">method</code></td>
<td>
<p>Desired blocking method. Possible values are <code>'exact'</code> and <code>'exactCL'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods are available for blocking:
</p>
<dl>
<dt><code>'exact'</code></dt><dd><p>Simple exact blocking. All records with the same values for the blocking variable create a block. Searching for links is only done within these blocks.</p>
</dd>
<dt><code>'exactCL'</code></dt><dd><p>The same as <code>'exact'</code>. Only works with strings; all caracters are capitalised.</p>
</dd>
</dl>



<h3>References</h3>

<p>Christen, P. (2012): Data Matching - Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DeterministicLinkage">DeterministicLinkage</a></code>,
<code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>,
<code><a href="#topic+SelectSimilarityFunction">SelectSimilarityFunction</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# define year of birth (V3) as blocking variable
bl &lt;- SelectBlockingFunction("V3", "V3", method = "exact")

# Select first name and last name as linking variables,
# to be linked using the Jaro-Winkler similarity measure (first name)
# and levenshtein distance (last name)
l1 &lt;- SelectSimilarityFunction("V7", "V7", method = "jw")
l2 &lt;- SelectSimilarityFunction("V8", "V8", method = "lv")

# Link the data as specified in bl and l1/l2
# (in this small example data is linked to itself)
res &lt;- ProbabilisticLinkage(testData$V1, testData,
  testData$V1, testData, similarity = c(l1, l2), blocking = bl)

</code></pre>

<hr>
<h2 id='SelectSimilarityFunction'>
Select Similarity Function for Linkage
</h2><span id='topic+SelectSimilarityFunction'></span><span id='topic+Similarity'></span><span id='topic+Linkage'></span>

<h3>Description</h3>

<p>To call <code><a href="#topic+DeterministicLinkage">DeterministicLinkage</a></code> or <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>
it is mandatory to select a similarity function for each variable. Each element of the setup contains the two variable names and the method. For some methods further informations can be entered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectSimilarityFunction(variable1, variable2,
  method = "jw",
  ind_c0 = FALSE, ind_c1 = FALSE,
  m = 0.9, u = 0.1, p = 0.05, epsilon = 0.0004,
  lower = 0.0, upper = 0.0,
  threshold = 0.85, jaroWeightFactor = 1.0, lenNgram = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SelectSimilarityFunction_+3A_variable1">variable1</code></td>
<td>
<p>name of linking variable 1 in the data.frame. The column must be of type character, numeric or integer,  containing the data to be merged. The data vector must have the same length as the ID vector.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_variable2">variable2</code></td>
<td>
<p>name of linking variable 2 in the data.frame. The column must be of type character, numeric or integer,  containing the data to be merged. The data vector must have the same length as the ID vector.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_method">method</code></td>
<td>
<p>linking method. Possible values are:
</p>

<ul>
<li><p> 'exact' = Exact matching
</p>
</li>
<li><p> 'exactCL' = Exact matching using capital letters
</p>
</li>
<li><p> 'LCS' = Longest Common Subsequence
</p>
</li>
<li><p> 'lv' = Levenshtein distance
</p>
</li>
<li><p> 'dl' = Damerau Levenshtein distance
</p>
</li>
<li><p> 'jaro' = Jaro similarity
</p>
</li>
<li><p> 'jw' = Jaro-Winkler similarity
</p>
</li>
<li><p> 'jw2' = Modified Jaro-Winkler similarity
</p>
</li>
<li><p> 'ngram' = n-gram similarity
</p>
</li>
<li><p> 'Gcp' = German census phonetic (Baystat)
</p>
</li>
<li><p> 'Reth' = Reth-Schek (IBM) phonetic
</p>
</li>
<li><p> 'Soundex' = Soundex phonetic
</p>
</li>
<li><p> 'Metaphone' = Metaphone phonetic
</p>
</li>
<li><p> 'DoubleMetaphone' = Double Metaphone phonetic
</p>
</li></ul>

</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_ind_c0">ind_c0</code></td>
<td>
<p>Only used for jw2.
</p>
<p>Increase the probability of a match when the number of matched
characters is large. This option allows for a little more
tolerance when the strings are large. It is not an appropriate
test when comparing fixed length fields such as phone and
social security numbers. A nonzero value indicates the option is deactivated.
</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_ind_c1">ind_c1</code></td>
<td>
<p>Only used for jw2.
</p>
<p>All lower case characters are converted to upper case prior
to the comparison. Disabling this feature means that the lower
case string &quot;code&quot; will not be recognized as the same as the
upper case string &quot;CODE&quot;. Also, the adjustment for similar
characters section only applies to uppercase characters. A nonzero value indicates the option is deactivated.
</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_m">m</code></td>
<td>
<p>Initial m value for the EM algorithm. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>. 0.0 &lt; m &lt; 1.0.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_u">u</code></td>
<td>
<p>Initial u value for the EM algorithm. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>. 0.0 &lt; u &lt; 1.0.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_p">p</code></td>
<td>
<p>Initial p value for the EM algorithm. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>. 0.0 &lt; u &lt; 1.0.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_epsilon">epsilon</code></td>
<td>
<p>epsilon is a stop criterum for the EM algorithm. The EM algorithm can be terminated when relative change of likelihood logarithm is less than epsilon. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_lower">lower</code></td>
<td>
<p>Matches lower than 'lower' are classified as non-match. Everything between 'lower' and 'upper' is classified as possible match. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_upper">upper</code></td>
<td>
<p>Matches higher than 'upper' are classified as match. Everything between 'lower' and 'upper' is classified as possible match. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_threshold">threshold</code></td>
<td>
<p>If using string similarities: Outputs only matches above the similarity threshold value. If using string distances: Outputs only matches below the set threshold distance.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_jaroweightfactor">jaroWeightFactor</code></td>
<td>
<p>By the Jaro weight adjustment the matching weight is adjusted according to the degree of similarity between the
variable values. The weight factor which determines the Jaro adjusted matching weight. Only used when linking using <code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>.</p>
</td></tr>
<tr><td><code id="SelectSimilarityFunction_+3A_lenngram">lenNgram</code></td>
<td>
<p>Length of ngrams. Only used for the method ngram. Length of ngrams must be between 1 and 4.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calling the function will not return anything.
</p>


<h3>References</h3>

<p>Christen, P. (2012): Data Matching - Concepts and Techniques for Record Linkage, Entity Resolution, and Duplicate Detection. Springer.
</p>
<p>Schnell, R., Bachteler, T., Reiher, J. (2004): A toolbox for record linkage. Austrian Journal of Statistics 33(1-2): 125-133.
</p>
<p>Winkler, W. E. (1988): Using the EM algorithm for weight computation in the Fellegi-Sunter model of record linkage. Proceedings of the Section on Survey Research Methods Vol. 667, American Statistical Association: 671.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DeterministicLinkage">DeterministicLinkage</a></code>,
<code><a href="#topic+ProbabilisticLinkage">ProbabilisticLinkage</a></code>,
<code><a href="#topic+SelectBlockingFunction">SelectBlockingFunction</a></code>,
<code><a href="#topic+StandardizeString">StandardizeString</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# define year of birth (V3) as blocking variable
bl &lt;- SelectBlockingFunction("V3", "V3", method = "exact")

# Select first name and last name as linking variables,
# to be linked using the jaro-winkler (first name)
# and exact matching (last name)
l1 &lt;- SelectSimilarityFunction("V7","V7", method = "jw",
  ind_c0 = FALSE, ind_c1 = FALSE , m = 0.9, u = 0.1,
  lower = 0.0, upper = 0.0)
l2 &lt;- SelectSimilarityFunction("V8","V8", method = "exact")

# Link the data as specified in bl and l1/l2
# (in this small example data is linked to itself)
res &lt;- ProbabilisticLinkage(testData$V1, testData,
  testData$V1, testData, similarity = c(l1, l2), blocking = bl)

</code></pre>

<hr>
<h2 id='StandardizeString'>Standardize String</h2><span id='topic+StandardizeString'></span><span id='topic+Preprocess'></span><span id='topic+Standardize'></span><span id='topic+Clean'></span>

<h3>Description</h3>

<p>Preprocessing (cleaning) of strings prior to linkage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StandardizeString(strings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StandardizeString_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to be standardized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Strings are capitalized, letters are substituted as described below. Leading and trailing blanks are removed. Other non-ASCII characters are deleted.
</p>

<ul>
<li><p> Replace &quot;Æ&quot; with &quot;AE&quot;
</p>
</li>
<li><p> Replace &quot;æ&quot; with &quot;AE&quot;
</p>
</li>
<li><p> Replace &quot;Ä&quot; with &quot;AE&quot;
</p>
</li>
<li><p> Replace &quot;ä&quot; with &quot;AE&quot;
</p>
</li>
<li><p> Replace &quot;Å&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;å&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;Â&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;â&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;À&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;à&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;Á&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;á&quot; with &quot;A&quot;
</p>
</li>
<li><p> Replace &quot;Ç&quot; with &quot;C&quot;
</p>
</li>
<li><p> Replace &quot;Ç&quot; with &quot;C&quot;
</p>
</li>
<li><p> Replace &quot;Ê&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;ê&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;È&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;è&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;É&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;é&quot; with &quot;E&quot;
</p>
</li>
<li><p> Replace &quot;Ï&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;ï&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;Î&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;î&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;Ì&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;ì&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;Í&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;í&quot; with &quot;I&quot;
</p>
</li>
<li><p> Replace &quot;Ö&quot; with &quot;OE&quot;
</p>
</li>
<li><p> Replace &quot;ö&quot; with &quot;OE&quot;
</p>
</li>
<li><p> Replace &quot;Ø&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;ø&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;Ô&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;ô&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;Ò&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;ò&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;Ó&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;ó&quot; with &quot;O&quot;
</p>
</li>
<li><p> Replace &quot;ß&quot; with &quot;SS&quot;
</p>
</li>
<li><p> Replace &quot;Ş&quot; with &quot;S&quot;
</p>
</li>
<li><p> Replace &quot;ş&quot; with &quot;S&quot;
</p>
</li>
<li><p> Replace &quot;ü&quot; with &quot;UE&quot;
</p>
</li>
<li><p> Replace &quot;Ü&quot; with &quot;UE&quot;
</p>
</li>
<li><p> Replace &quot;Ů&quot; with &quot;U&quot;
</p>
</li>
<li><p> Replace &quot;Û&quot; with &quot;U&quot;
</p>
</li>
<li><p> Replace &quot;û&quot; with &quot;U&quot;
</p>
</li>
<li><p> Replace &quot;Ù&quot; with &quot;U&quot;
</p>
</li>
<li><p> Replace &quot;ù&quot; with &quot;U&quot;</p>
</li></ul>



<h3>Value</h3>

<p>Returns a character vector with standardized strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings = c("Päter", " Jürgen", " Roß")
StandardizeString(strings)

</code></pre>

<hr>
<h2 id='WolframRule30'>Apply Wolframs rule 30 on bit vectors</h2><span id='topic+WolframRule30'></span><span id='topic+Rule+2030'></span>

<h3>Description</h3>

<p>Apply Wolframs Cellular Automaton rule 30 on the input bit vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WolframRule30(ID, data, lenBloom, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WolframRule30_+3A_id">ID</code></td>
<td>
<p>IDs as character vector.</p>
</td></tr>
<tr><td><code id="WolframRule30_+3A_data">data</code></td>
<td>
<p>character vector containing bit vectors.</p>
</td></tr>
<tr><td><code id="WolframRule30_+3A_lenbloom">lenBloom</code></td>
<td>
<p>length of Bloom filters.</p>
</td></tr>
<tr><td><code id="WolframRule30_+3A_t">t</code></td>
<td>
<p>indicates how often rule 30 is to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector with new bit vectors after rule 30 has been applied t times.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Rule_30
</p>
<p>Schnell, R. (2017): Recent Developments in Bloom Filter-based Methods for Privacy-preserving Record Linkage. Curtin Institute for Computation, Curtin University, Perth, 12.9.2017.
</p>
<p>Wolfram, S. (1983): Statistical mechanics of cellular automata. Rev. Mod. Phys. 55 (3): 601–644.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WolframRule90">WolframRule90</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create bit vector e.g. by CreateCLK or CreateBF
CLK &lt;- CreateCLK(ID = testData$V1,
  data = testData[, c(2, 3, 7, 8)],
  k = 20, padding = c(0, 0, 1, 1),
  q = c(1, 1, 2, 2), l = 1000,
  password = c("HUh4q", "lkjg", "klh", "Klk5"))

# Apply rule 30 once
res &lt;- WolframRule30(CLK$ID, CLK$CLK, lenBloom = 1000, t = 1)

</code></pre>

<hr>
<h2 id='WolframRule90'>Apply Wolframs rule 90 on bit vectors</h2><span id='topic+WolframRule90'></span><span id='topic+Rule+2090'></span><span id='topic+Cellular+20Automata'></span>

<h3>Description</h3>

<p>Apply Wolframs Cellular Automaton rule 90 on the input bit vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WolframRule90(ID, data,  lenBloom, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WolframRule90_+3A_id">ID</code></td>
<td>
<p>IDs as character vector.</p>
</td></tr>
<tr><td><code id="WolframRule90_+3A_data">data</code></td>
<td>
<p>character vector containing bit vectors.</p>
</td></tr>
<tr><td><code id="WolframRule90_+3A_lenbloom">lenBloom</code></td>
<td>
<p>length of Bloom filters.</p>
</td></tr>
<tr><td><code id="WolframRule90_+3A_t">t</code></td>
<td>
<p>indicates how often rule 90 is to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector with new bit vectors after rule 90 has been applied t times.
</p>


<h3>References</h3>

<p>https://en.wikipedia.org/wiki/Rule_90
</p>
<p>Martin, O., Odlyzko, A. M., Wolfram, S. (1984): Algebraic properties of cellular automata. Communications in Mathematical Physics, 93 (2): 219-258.
</p>
<p>Schnell, R. (2017): Recent Developments in Bloom Filter-based Methods for Privacy-preserving Record Linkage. Curtin Institute for Computation, Curtin University, Perth, 12.9.2017.
</p>
<p>Wolfram, S. (1983): Statistical mechanics of cellular automata. Rev. Mod. Phys. 55 (3): 601–644. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WolframRule30">WolframRule30</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load test data
testFile &lt;- file.path(path.package("PPRL"), "extdata/testdata.csv")
testData &lt;- read.csv(testFile, head = FALSE, sep = "\t",
  colClasses = "character")

# Create bit vector e.g. by CreateCLK or CreateBF
CLK &lt;- CreateCLK(ID = testData$V1, 
  data = testData[, c(2, 3, 7, 8)],
  k = 20, padding = c(0, 0, 1, 1), 
  q = c(1, 1, 2, 2), l = 1000, 
  password = c("HUh4q", "lkjg", "klh", "Klk5"))

# Apply rule 90 once  
res &lt;- WolframRule90(CLK$ID, CLK$CLK, lenBloom = 1000, t = 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
