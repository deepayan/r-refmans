<!DOCTYPE html><html><head><title>Help for package nnspat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nnspat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nnspat-package'><p>nnspat: A package for NN Methods and Their Use in Testing Spatial Patterns</p></a></li>
<li><a href='#.onAttach'><p>.onAttach start message</p></a></li>
<li><a href='#.onLoad'><p>.onLoad getOption package settings</p></a></li>
<li><a href='#aij.theta'><p>Closeness or Proximity Matrix for Tango's Spatial Clustering Tests</p></a></li>
<li><a href='#asycovTkTl'><p>Asymptotic Covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> Values</p></a></li>
<li><a href='#asyvarTk'><p>Asymptotic Variance of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#bvnorm.pdf'><p>pdf of the Bivariate Normal Distribution</p></a></li>
<li><a href='#cellsTij'><p>Entries for the Types I-IV cell-specific tests</p></a></li>
<li><a href='#ceTk'><p>Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#ceTkinv'><p>Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</p></a></li>
<li><a href='#ceTrun'><p>Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</p></a></li>
<li><a href='#cov.nnct'><p>Covariance Matrix of the Cell Counts in an NNCT</p></a></li>
<li><a href='#cov.nnsym'><p>Covariance Matrix of the Differences of the Off-Diagonal Cell Counts in an NNCT</p></a></li>
<li><a href='#cov.seg.coeff'><p>Covariance Matrix of Segregation Coefficients in a Multi-class Case</p></a></li>
<li><a href='#cov.tct'><p>Covariance Matrix of the Entries of the Type I-IV TCTs</p></a></li>
<li><a href='#covNrow2col'><p>Conversion of the Covariance Matrix of the Row-wise Vectorized Cell Counts</p>
to Column-wise Vectorized Cell Counts in an NNCT</a></li>
<li><a href='#covTcomb'><p>Covariance matrix for <code class="reqn">T_k</code> values in <code>Tcomb</code></p></a></li>
<li><a href='#covTkTl'><p>Finite Sample Covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> Values</p></a></li>
<li><a href='#dist.std.data'><p>Interpoint Distance Matrix for Standardized Data</p></a></li>
<li><a href='#dist2full'><p>Converts a lower triangular distance matrix to a full distance matrix</p></a></li>
<li><a href='#euc.dist'><p>The Euclidean distance between two vectors, matrices, or data frames</p></a></li>
<li><a href='#EV.Nii'><p>Expected Values of the Self Entries in a Species Correspondence Contingency Table (SCCT)</p></a></li>
<li><a href='#EV.nnct'><p>Expected Values of the Cell Counts in NNCT</p></a></li>
<li><a href='#EV.rct'><p>Expected Values of the Cell Counts in RCT</p></a></li>
<li><a href='#EV.Tcomb'><p>Expected Value for Cuzick &amp; Edwards <code class="reqn">T_{comb}</code> Test Statistic</p></a></li>
<li><a href='#EV.tct'><p>Expected Values of the Types I-IV cell-specific tests</p></a></li>
<li><a href='#EV.tctI'><p>Expected Values of the Type I cell-specific tests</p></a></li>
<li><a href='#EV.Tkinv'><p>Expected Value of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</p></a></li>
<li><a href='#exact.nnct'><p>Exact version of Pearson's chi-square test on NNCTs</p></a></li>
<li><a href='#exact.pval1s'><p><code class="reqn">p</code>-value correction to the one-sided version of exact NNCT test</p></a></li>
<li><a href='#exact.pval2s'><p><code class="reqn">p</code>-value correction to the two-sided version of exact NNCT test</p></a></li>
<li><a href='#funs.auxcovtct'><p>Auxiliary Functions for Computing Covariances</p>
Between Cell Counts in the TCT</a></li>
<li><a href='#funs.base.class.spec'><p>Base Class-specific Chi-square Tests based on NNCTs</p></a></li>
<li><a href='#funs.cell.spec.ss'><p>Pielou's Cell-specific Segregation Test with Normal Approximation (for Sparse Sampling)</p></a></li>
<li><a href='#funs.class.spec'><p>Class-specific Chi-square Tests based on NNCTs</p></a></li>
<li><a href='#funs.covNii'><p>Covariance Matrix of the Self Entries in a Species Correspondence Contingency Table (SCCT)</p></a></li>
<li><a href='#funs.covtct'><p>Functions for Covariances of the Entries of the</p>
Types I, III and IV TCTs</a></li>
<li><a href='#funs.kNNdist'><p>Functions for the <code class="reqn">k^{th}</code> and <code>k</code> NN distances</p></a></li>
<li><a href='#funs.kNNdist2cl'><p>Functions for the <code class="reqn">k^{th}</code> and <code>k</code> NN distances</p></a></li>
<li><a href='#funs.overall.nnct'><p>Dixon's Overall Test of Segregation for NNCT</p></a></li>
<li><a href='#funs.overall.seg'><p>Overall Segregation Tests for NNCTs</p></a></li>
<li><a href='#funs.overall.tct'><p>Types I-IV Overall Tests of Segregation for NNCT</p></a></li>
<li><a href='#funs.pijPij'><p>The functions for probability of selecting a number of points</p>
from respective classes</a></li>
<li><a href='#funs.scct'><p>Species Correspondence Contingency Table (SCCT)</p></a></li>
<li><a href='#funs.seg.coeff'><p>Pielou's Segregation Coefficients for NNCTs</p></a></li>
<li><a href='#funs.varNii'><p>Variances of the Self Entries in a Species Correspondence Contingency Table (SCCT)</p></a></li>
<li><a href='#funs.vartct'><p>Functions for Variances of Cell Counts</p>
in the Types I, III and IV TCTs</a></li>
<li><a href='#funsAijmat'><p>Aij matrices for computation of Moments of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#funsC_MI_II'><p>Correction Matrices for the Covariance Matrix of NNCT entries</p></a></li>
<li><a href='#funsExpTk'><p>Expected Value for Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#funsExpTrun'><p>Expected Value for Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</p></a></li>
<li><a href='#funsN_I_II'><p>Correction Matrices for the NNCT entries</p></a></li>
<li><a href='#funsNNclass.spec'><p>NN Class-specific Chi-square Tests based on NNCTs</p></a></li>
<li><a href='#funsOnevsRest'><p>Functions for one versus rest type labeling</p></a></li>
<li><a href='#funsPseg.ss'><p>Pielou's Overall Test of Segregation for NNCT (for Sparse Sampling)</p></a></li>
<li><a href='#funsQandR'><p>Functions for the number of shared NNs,</p>
shared NN vector, and the number of reflexive NNs</a></li>
<li><a href='#funsRowColSums'><p>Functions for row and column sums of a matrix</p></a></li>
<li><a href='#funsVarTk'><p>Variance of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#funsVarTrun'><p>Variance of Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</p></a></li>
<li><a href='#funsW345values'><p><code class="reqn">W_k</code> values for Tango's <code class="reqn">T</code> test statistic</p></a></li>
<li><a href='#funsXsq.nnref'><p>Reflexivity Test with Chi-square Approximation</p></a></li>
<li><a href='#funsXsq.nnsym.dx'><p>Dixon's NN Symmetry Test with Chi-square Approximation for multiple classes</p></a></li>
<li><a href='#funsXsq.nnsym.ss'><p>Pielou's First Type of NN Symmetry Test with Chi-square Approximation for multiple classes</p>
(for Sparse Sampling)</a></li>
<li><a href='#funsXsq.seg.coeff'><p>Chi-square Test for Segregation Coefficients</p></a></li>
<li><a href='#funsXsq.spec.cor'><p>Overall Species Correspondence Test with Chi-square Approximation</p></a></li>
<li><a href='#funsZcell.nnct'><p>Dixon's Cell-specific Z Tests of Segregation for NNCT</p></a></li>
<li><a href='#funsZcell.nnct.pval'><p><code class="reqn">p</code>-values for Cell-specific Z Test Statistics for NNCT</p></a></li>
<li><a href='#funsZcell.spec'><p>Cell-specific Z Tests of Segregation for NNCTs</p></a></li>
<li><a href='#funsZcell.tct'><p>Types I-IV Cell-specific Z Tests of Segregation based on NNCTs</p></a></li>
<li><a href='#funsZdir.nnct'><p>Directional Segregation Test for Two Classes with Normal Approximation</p></a></li>
<li><a href='#funsZdir.nnct.ss'><p>Directional Segregation Test for Two Classes with Normal Approximation (for Sparse Sampling)</p></a></li>
<li><a href='#funsZmixed.nonref'><p>Mixed-Non-Reflexivity Test with Normal Approximation</p></a></li>
<li><a href='#funsZnnref'><p>Z Tests for NN Reflexivity</p></a></li>
<li><a href='#funsZnnself'><p>Self-Reflexivity Tests with Normal Approximation</p></a></li>
<li><a href='#funsZnnself.sum'><p>Cumulative Species Correspondence Test with Normal Approximation</p></a></li>
<li><a href='#funsZnnsym.dx'><p>Dixon's Pairwise NN Symmetry Test with Normal Approximation</p></a></li>
<li><a href='#funsZnnsym.ss'><p>Pielou's Pairwise NN Symmetry Test with Normal Approximation (for Sparse Sampling)</p></a></li>
<li><a href='#funsZnnsym2cl.dx'><p>Dixon's NN Symmetry Test with Normal Approximation for Two Classes</p></a></li>
<li><a href='#funsZnnsym2cl.ss'><p>Pielou's First Type of NN Symmetry Test with Normal Approximation for Two Classes</p>
(for Sparse Sampling)</a></li>
<li><a href='#funsZseg.coeff'><p>Z Tests for Segregation Coefficients</p></a></li>
<li><a href='#funsZsegind'><p>Z Tests for Segregation Indices</p></a></li>
<li><a href='#funsZself.ref'><p>Self-Reflexivity Test with Normal Approximation</p></a></li>
<li><a href='#funsZTkinv'><p>Z-Test for Cuzick and Edwards <code class="reqn">T_k^{inv}</code> statistic</p></a></li>
<li><a href='#ind.nnsym'><p>Index Matrix for Computing the Covariance of Dixon's Overall NN Symmetry Test</p></a></li>
<li><a href='#ind.seg.coeff'><p>Index Matrix for Computing the Covariance of Segregation Coefficients</p></a></li>
<li><a href='#ipd.mat'><p>Interpoint Distance Matrix</p></a></li>
<li><a href='#ipd.mat.euc'><p>Euclidean Interpoint Distance Matrix</p></a></li>
<li><a href='#kNN'><p>Finding the indices of the <code>k</code> NNs of a given point</p></a></li>
<li><a href='#mat2vec'><p>Conversion of a Matrix to a Vector</p></a></li>
<li><a href='#matrix.sqrt'><p>Square root of a matrix</p></a></li>
<li><a href='#Ninv'><p>Vector of Shared NNs and Number of Reflexive NNs</p></a></li>
<li><a href='#NN'><p>Finding the index of the NN of a given point</p></a></li>
<li><a href='#nnct'><p>Nearest Neighbor Contingency Table (NNCT)</p></a></li>
<li><a href='#nnct.boot.dis'><p>Bootstrap Nearest Neighbor Contingency Table (NNCT)</p></a></li>
<li><a href='#nnct.sub'><p>Nearest Neighbor Contingency Table (NNCT) with (only)</p>
base points restricted to a subsample</a></li>
<li><a href='#NNdist'><p>Distances between subjects and their NNs</p></a></li>
<li><a href='#NNdist2cl'><p>Distances between subjects from class <code class="reqn">i</code></p>
and their NNs from class <code class="reqn">j</code></a></li>
<li><a href='#NNsub'><p>Finding the index of the NN of a given point among a subset of points</p></a></li>
<li><a href='#Nt.def'><p><code class="reqn">N_t</code> Value (found with the definition formula)</p></a></li>
<li><a href='#Ntkl'><p><code class="reqn">N_{tkl}</code> Value</p></a></li>
<li><a href='#pairwise.lab'><p>Keeping the pair of the specified labels in the data</p></a></li>
<li><a href='#pick.min.max'><p>Smallest and Largest Distances in a Distance Matrix</p></a></li>
<li><a href='#pk'><p>Probability of <code>k</code> items selected from the class with size <code class="reqn">n_1</code></p></a></li>
<li><a href='#plot.Clusters'><p>Plot a <code>Clusters</code> object</p></a></li>
<li><a href='#plot.SpatPatterns'><p>Plot a <code>SpatPatterns</code> object</p></a></li>
<li><a href='#print.cellhtest'><p>Print a summary of a <code>cellhtest</code> object</p></a></li>
<li><a href='#print.Chisqtest'><p>Print a summary of a <code>Chisqtest</code> object</p></a></li>
<li><a href='#print.classhtest'><p>Print a summary of a <code>classhtest</code> object</p></a></li>
<li><a href='#print.Clusters'><p>Print a <code>Clusters</code> object</p></a></li>
<li><a href='#print.refhtest'><p>Print a summary of a <code>refhtest</code> object</p></a></li>
<li><a href='#print.SpatPatterns'><p>Print a <code>SpatPatterns</code> object</p></a></li>
<li><a href='#print.summary.Clusters'><p>Print a summary of a <code>Clusters</code> object</p></a></li>
<li><a href='#print.summary.SpatPatterns'><p>Print a summary of a <code>SpatPatterns</code> object</p></a></li>
<li><a href='#prob.nnct'><p>Probability of the current nearest neighbor contingency table</p></a></li>
<li><a href='#QRval'><p>Number of Shared and Reflexive NNs</p></a></li>
<li><a href='#Qsym.ct'><p><code class="reqn">Q</code>-symmetry Contingency Table (QCT)</p></a></li>
<li><a href='#Qsym.test'><p>Pielou's Second Type of NN Symmetry Test with Chi-square Approximation</p></a></li>
<li><a href='#rassoc'><p>Generation of Points Associated with a Given Set of Points</p></a></li>
<li><a href='#rassocC'><p>Generation of Points Associated in the Type C Sense with a Given Set of Points</p></a></li>
<li><a href='#rassocG'><p>Generation of Points Associated in the Type G Sense with a Given Set of Points</p></a></li>
<li><a href='#rassocI'><p>Generation of Points Associated in the Type I Sense with a Given Set of Points</p></a></li>
<li><a href='#rassocU'><p>Generation of Points Associated in the Type U Sense with a Given Set of Points</p></a></li>
<li><a href='#rct'><p>Reflexivity Contingency Table (RCT)</p></a></li>
<li><a href='#rdiag.clust'><p>Generation of Points with Clusters along the First Diagonal</p></a></li>
<li><a href='#rhor.clust'><p>Generation of Points with Clusters along the Horizontal Axis</p></a></li>
<li><a href='#rnonRL'><p>Non-Random Labeling of a Given Set of Points</p></a></li>
<li><a href='#rnonRLI'><p>Type I Non-Random Labeling of a Given Set of Points</p></a></li>
<li><a href='#rnonRLII'><p>Type II Non-Random Labeling of a Given Set of Points</p></a></li>
<li><a href='#rnonRLIII'><p>Type III Non-Random Labeling of a Given Set of Points</p></a></li>
<li><a href='#rnonRLIV'><p>Type IV Non-Random Labeling of a Given Set of Points</p></a></li>
<li><a href='#rrot.clust'><p>Generation of Points with Rotational Clusters</p></a></li>
<li><a href='#rseg'><p>Generation of Points under Segregation of Two Classes</p></a></li>
<li><a href='#rself.ref'><p>Generation of Points from Self Correspondence Pattern</p></a></li>
<li><a href='#runif.circ'><p>Generation of Uniform Points in a Circle</p></a></li>
<li><a href='#seg.ind'><p>Dixon's Segregation Indices for NNCTs</p></a></li>
<li><a href='#sharedNNmc'><p>The Shared NN Vectors for Multiple Classes</p></a></li>
<li><a href='#SkewTk'><p>Skewness of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#summary.Clusters'><p>Return a summary of a <code>Clusters</code> object</p></a></li>
<li><a href='#summary.SpatPatterns'><p>Return a summary of a <code>SpatPatterns</code> object</p></a></li>
<li><a href='#swamptrees'><p>Tree Species in a Swamp Forest</p></a></li>
<li><a href='#Tcomb'><p>Cuzick &amp; Edwards Tcomb Test Statistic</p></a></li>
<li><a href='#tct'><p><code class="reqn">T</code> Contingency Table (TCT)</p></a></li>
<li><a href='#tocher.cor'><p>Tocher's randomized correction to the exact <code class="reqn">p</code>-value</p></a></li>
<li><a href='#Tval'><p><code class="reqn">T</code> value in NN structure</p></a></li>
<li><a href='#var.nnct'><p>Variances of Cell Counts in an NNCT</p></a></li>
<li><a href='#var.nnsym'><p>Variances of Differences of Off-Diagonal Entries in an NNCT</p></a></li>
<li><a href='#var.seg.coeff'><p>Variances of Segregation Coefficients in a Multi-class Case</p></a></li>
<li><a href='#var.tct'><p>Variances of Entries in a TCT</p></a></li>
<li><a href='#varPseg.coeff'><p>Variance of Pielou's Segregation Coefficient for 2 Classes</p></a></li>
<li><a href='#varTkinv.sim'><p>Simulated Variance of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</p></a></li>
<li><a href='#Wmat'><p>The incidence matrix <code>W</code> for the NN digraph</p></a></li>
<li><a href='#Xsq.ceTk'><p>Chi-square Approximation to Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</p></a></li>
<li><a href='#Xsq.nnsym'><p>Overall NN Symmetry Test with Chi-square Approximation</p></a></li>
<li><a href='#ZceTk'><p><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_k</code> statistic</p></a></li>
<li><a href='#Znnsym'><p>NN Symmetry Test with Normal Approximation</p></a></li>
<li><a href='#Znnsym2cl'><p>NN Symmetry Test with Normal Approximation for Two Classes</p></a></li>
<li><a href='#ZTcomb'><p><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_{comb}</code> statistic</p></a></li>
<li><a href='#ZTrun'><p><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_{run}</code> statistic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nearest Neighbor Methods for Spatial Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Elvan Ceyhan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elvan Ceyhan &lt;elvanceyhan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains the functions for testing the spatial patterns (of segregation, spatial symmetry, 
      association, disease clustering, species correspondence, and reflexivity) based on nearest neighbor relations, 
      especially using contingency tables such as 
      nearest neighbor contingency tables (Ceyhan (2010) &lt;<a href="https://doi.org/10.1007%2Fs10651-008-0104-x">doi:10.1007/s10651-008-0104-x</a>&gt; and 
      Ceyhan (2017) &lt;<a href="https://doi.org/10.1016%2Fj.jkss.2016.10.002">doi:10.1016/j.jkss.2016.10.002</a>&gt; and references therein),
      nearest neighbor symmetry contingency tables (Ceyhan (2014) &lt;<a href="https://doi.org/10.1155%2F2014%2F698296">doi:10.1155/2014/698296</a>&gt;),
      species correspondence contingency tables and reflexivity contingency tables (Ceyhan (2018) 
      &lt;<a href="https://doi.org/10.2436%2F20.8080.02.72">doi:10.2436/20.8080.02.72</a>&gt; for two (or higher) dimensional data. 
      The package also contains functions for generating patterns of segregation, association,
      uniformity in a multi-class setting (Ceyhan (2014) &lt;<a href="https://doi.org/10.1007%2Fs00477-013-0824-9">doi:10.1007/s00477-013-0824-9</a>&gt;), 
      and various non-random labeling patterns for disease clustering 
      in two dimensional cases (Ceyhan (2014)
      &lt;<a href="https://doi.org/10.1002%2Fsim.6053">doi:10.1002/sim.6053</a>&gt;), and for visualization of all these patterns 
      for the two dimensional data.
      The tests are usually (asymptotic) normal z-tests or chi-square tests.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, stats, graphics, pcds, Rdpack (&ge; 0.7)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 16:41:15 UTC; ezc0066</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 17:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='nnspat-package'>nnspat: A package for NN Methods and Their Use in Testing Spatial Patterns</h2><span id='topic+nnspat'></span><span id='topic+nnspat-package'></span>

<h3>Description</h3>

<p><code>nnspat</code> is a package for computation of spatial pattern tests based on NN relations and 
generation of various spatial patterns.
</p>


<h3>Details</h3>

<p>The <code>nnspat</code> package contains the functions for segregation/association tests based on nearest neighbor contingency
tables (NNCTs), and tests for species correspondence, NN symmetry and reflexivity based on the corresponding
contingency tables and functions for generating patterns of segregation, association, uniformity, and various
non-random labeling (non-RL) patterns for data in two (or more) dimensions. Applications include plant ecology, disease clustering in epidemiology, and so on.
#' See (Dixon (1994); Ceyhan (2010, 2017)).
</p>


<h3>The <code>nnspat</code> functions</h3>

<p>The <code>nnspat</code> functions can be grouped as 
Auxiliary Functions, 
NNCT Functions, 
SCCT Functions, 
RCT Functions,
NN-Symmetry Functions,
and the Pattern (Generation) Functions.
</p>


<h3>Auxiliary Functions</h3>

<p>Contains the auxiliary functions used in NN methods, such as indices of NNs, number of shared NNs, 
Q, R and T values, and so on. 
In all these functions the data sets are either matrices or data frames.
</p>


<h3>NNCT Functions</h3>

<p>Contains the functions for testing segregation/association using the NNCT. 
The types of the tests are cell-specific tests, class-specific tests, and 
overall tests of segregation.
See (Ceyhan (2009, 2010)).
</p>


<h3>SCCT Functions</h3>

<p>Contains the functions used for testing species correspondence using the NNCT. 
The types are NN self and self-sum tests
and the overall test of species correspondence.
See (Ceyhan (2018)).
</p>


<h3>RCT Functions</h3>

<p>Contains the functions for testing reflexivity using the reflexivity contingency table (RCT). 
The types are NN 
self reflexivity and NN mixed-non reflexivity.
See (Ceyhan and Bahadir (2017); Bahadir and Ceyhan (2018)).
</p>


<h3>Symmetry Functions</h3>

<p>Contains the functions for testing NN symmetry using the NNCT 
and <code class="reqn">Q</code>-symmetry contingency table. The types are NN 
symmetry and symmetry in shared NN structure.
See (Ceyhan (2014)).
</p>


<h3>Pattern Functions</h3>

<p>Contains the functions for generating and visualization of spatial patterns of segregation, 
association, uniformity clustering and non-RL.
See (Ceyhan (2014, 2014)).
</p>


<h3>References</h3>

<p>Bahadir S, Ceyhan E (2018).
&ldquo;On the Number of reflexive and shared nearest neighbor pairs in one-dimensional uniform data.&rdquo;
<em>Probability and Mathematical Statistics</em>, <b>38(1)</b>, 123-137.<br /><br /> Ceyhan E (2009).
&ldquo;Class-Specific Tests of Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Statistica Neerlandica</em>, <b>63(2)</b>, 149-182.<br /><br /> Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2010).
&ldquo;Exact Inference for Testing Spatial Patterns by Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of Probability and Statistical Science</em>, <b>8(1)</b>, 45-68.<br /><br /> Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.<br /><br /> Ceyhan E (2010).
&ldquo;Directional clustering tests based on nearest neighbour contingency tables.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>22(5)</b>, 599-616.<br /><br /> Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.<br /><br /> Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>

<hr>
<h2 id='.onAttach'>.onAttach start message</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>.onAttach start message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>defunct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>

<hr>
<h2 id='.onLoad'>.onLoad getOption package settings</h2><span id='topic+.onLoad'></span>

<h3>Description</h3>

<p>.onLoad getOption package settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onLoad(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onLoad_+3A_libname">libname</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id=".onLoad_+3A_pkgname">pkgname</code></td>
<td>
<p>defunct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getOption("nnspat.name")
</code></pre>

<hr>
<h2 id='aij.theta'>Closeness or Proximity Matrix for Tango's Spatial Clustering Tests</h2><span id='topic+aij.theta'></span>

<h3>Description</h3>

<p>This function computes the <code class="reqn">A=a_{ij}(\theta)</code> matrix useful in calculations for Tango's test <code class="reqn">T(\theta)</code> 
for spatial (disease) clustering (see Eqn (2) of Tango (2007).
Here, <code class="reqn">A=a_{ij}(\theta)</code> is any matrix of a measure of the closeness between two points <code class="reqn">i</code> and <code class="reqn">j</code> with <code class="reqn">aii = 0</code> for all
<code class="reqn">i = 1, \ldots,n</code>, and <code class="reqn">\theta = (\theta_1,\ldots,\theta_p)^t</code> denotes the unknown parameter vector related 
to cluster size and <code class="reqn">\delta = (\delta_1,\ldots,\delta_n)^t</code>, where <code class="reqn">\delta_i=1</code> if <code class="reqn">z_i</code> is a case and 0 
otherwise.
The test is then
</p>
<p style="text-align: center;"><code class="reqn">T(\theta)=\sum_{i=1}^n\sum_{j=1}^n\delta_i \delta_j a_{ij}(\theta)=\delta^t A(\theta) \delta</code>
</p>

<p>where <code class="reqn">A=a_{ij}(\theta)</code>.
</p>
<p><code class="reqn">T(\theta)</code> becomes Cuzick and Edwards <code class="reqn">T_k</code> tests statistic (Cuzick and Edwards (1990)),
if <code class="reqn">a_{ij}=1</code> if <code class="reqn">z_j</code> is among the <code>k</code>NNs of <code class="reqn">z_i</code> and 0 otherwise.
In this case <code class="reqn">\theta=k</code> and <code>aij.theta</code> becomes <code>aij.mat</code> (more specifically,
<code>aij.mat(dat,k)</code> and <code>aij.theta(dat,k,model="NN")</code>.
</p>
<p>In Tango's exponential clinal model (Tango (2000)),
<code class="reqn">a_{ij}=\exp\left(-4 \left(\frac{d_{ij}}{\theta}\right)^2\right)</code> if <code class="reqn">i \ne j</code>  and 0 otherwise,
where <code class="reqn">\theta</code> is a predetermined scale of cluster such that any pair of cases far apart beyond the distance 
<code class="reqn">\theta</code> cannot be considered as a cluster and <code class="reqn">d_{ij}</code> denote the Euclidean distance between 
two points <code class="reqn">i</code> and <code class="reqn">j</code>. 
</p>
<p>In the exponential model (Tango (2007)),
<code class="reqn">a_{ij}=\exp\left(-\frac{d_{ij}}{\theta}\right)</code> if <code class="reqn">i \ne j</code>  and 0 otherwise,
where <code class="reqn">\theta</code> and <code class="reqn">d_{ij}</code> are as above.
</p>
<p>In the hot-spot model (Tango (2007)),
<code class="reqn">a_{ij}=1</code> if <code class="reqn">d_{ij} \le \theta</code> and <code class="reqn">i \ne j</code>  and 0 otherwise,
where <code class="reqn">\theta</code> and <code class="reqn">d_{ij}</code> are as above.
</p>
<p>The argument <code>model</code> has four options, <code>NN</code>, <code>exp.clinal</code>, <code>exponential</code>, and 
<code>hot.spot</code>, with <code>exp.clinal</code> being the default.
And the <code>theta</code> argument specifies the scale of clustering or the clustering parameter in the particular
spatial disease clustering model.
</p>
<p>See also (Tango (2007)) and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aij.theta(dat, theta, model = "exp.clinal", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aij.theta_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="aij.theta_+3A_theta">theta</code></td>
<td>
<p>A predetermined cluster scale so that any pair of cases farther apart then the distance 
<code class="reqn">\theta</code> is unlikely to be cluster.</p>
</td></tr>
<tr><td><code id="aij.theta_+3A_model">model</code></td>
<td>
<p>Type of Tango's spatial clustering model with four options: 
<code>NN</code>, <code>exp.clinal</code> (default), <code>exponential</code>, and <code>hot.spot</code>.</p>
</td></tr>
<tr><td><code id="aij.theta_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">A=a_{ij}(\theta)</code> matrix useful in calculations for Tango's test <code class="reqn">T(\theta)</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.<br /><br /> Tango T (2000).
&ldquo;A test for spatial disease clustering adjusted for multiple testing.&rdquo;
<em>Statistics in Medicine</em>, <b>19</b>, 191-204.<br /><br /> Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aij.mat">aij.mat</a></code>, <code><a href="#topic+aij.nonzero">aij.nonzero</a></code> and <code><a href="#topic+ceTk">ceTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
k&lt;-3#1 #try also 2,3

#aij for CE's Tk
Aij&lt;-aij.theta(Y,k,model = "NN")
Aij2&lt;-aij.mat(Y,k)
sum(abs(Aij-Aij2)) #check equivalence of aij.theta and aij.mat with model="NN"

Aij&lt;-aij.theta(Y,k,method="max")
Aij2&lt;-aij.mat(Y,k)
range(Aij-Aij2)

theta=.2
aij.theta(Y,theta,model = "exp.clinal")
aij.theta(Y,theta,model = "exponential")
aij.theta(Y,theta,model = "hot.spot")

</code></pre>

<hr>
<h2 id='asycovTkTl'>Asymptotic Covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> Values</h2><span id='topic+asycovTkTl'></span>

<h3>Description</h3>

<p>This function computes the asymptotic covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values
which is used in the computation of the asymptotic variance
of Cuzick and Edwards <code class="reqn">T_{comb}</code> test, which is a linear combination of some <code class="reqn">T_k</code> tests. 
The limit is as <code class="reqn">n_1</code> goes to infinity.
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>See page 80 of (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asycovTkTl(dat, n1, k, l, nonzero.mat = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asycovTkTl_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="asycovTkTl_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="asycovTkTl_+3A_k">k</code>, <code id="asycovTkTl_+3A_l">l</code></td>
<td>
<p>Integers specifying the number of NNs (of subjects <code class="reqn">i</code> and <code class="reqn">m</code> in <code class="reqn">a_{ij}(k) a_{mj}(l)</code>).</p>
</td></tr>
<tr><td><code id="asycovTkTl_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="asycovTkTl_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the asymptotic covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covTkTl">covTkTl</a></code>, <code><a href="#topic+covTcomb">covTcomb</a></code>, and <code><a href="#topic+Ntkl">Ntkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)

k&lt;-1 #try also 2,3 or sample(1:5,1)
l&lt;-1 #try also 2,3 or sample(1:5,1)
c(k,l)

asycovTkTl(Y,n1,k,l)
asycovTkTl(Y,n1,k,l,nonzero.mat = FALSE)
asycovTkTl(Y,n1,k,l,method="max")

</code></pre>

<hr>
<h2 id='asyvarTk'>Asymptotic Variance of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+asyvarTk'></span>

<h3>Description</h3>

<p>This function computes the asymptotic variance of Cuzick and Edwards <code class="reqn">T_k</code> test statistic based on the number
of cases within <code>k</code>NNs of the cases in the data. 
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) for computing <code class="reqn">N_s</code> and <code class="reqn">N_t</code>, which are required in the computation of the
asymptotic variance. <code class="reqn">N_s</code> and <code class="reqn">N_t</code> are defined on page 78 of (Cuzick and Edwards (1990)) as follows.
<code class="reqn">N_s=\sum_i\sum_j a_{ij} a_{ji}</code> (i.e., number of ordered pairs for which <code>k</code>NN relation is symmetric)
and <code class="reqn">N_t= \sum \sum_{i \ne l}\sum a_{ij} a_{lj}</code> (i.e, number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">l</code>).
For the <code class="reqn">A</code> matrix, see the description of the functions <code>aij.mat</code> and <code>aij.nonzero</code>.
</p>
<p>See (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asyvarTk(dat, n1, k, nonzero.mat = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asyvarTk_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="asyvarTk_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="asyvarTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>)</p>
</td></tr>
<tr><td><code id="asyvarTk_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="asyvarTk_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>asy.var</code></td>
<td>
<p>The asymptotic variance of Cuzick and Edwards <code class="reqn">T_k</code> test statistic for disease clustering</p>
</td></tr>
<tr><td><code>Ns</code></td>
<td>
<p>The <code class="reqn">N_s</code> value standing for the number of ordered pairs for which <code>k</code>NN relation is symmetric,
see the description.</p>
</td></tr>
<tr><td><code>Nt</code></td>
<td>
<p>The <code class="reqn">N_t</code> value standing for the number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">l</code> see the description.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+varTk">varTk</a></code>, and <code><a href="#topic+varTkaij">varTkaij</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)
k&lt;-3 #try also 2,3

asyvarTk(Y,n1,k)
asyvarTk(Y,n1,k,nonzero.mat=FALSE)
asyvarTk(Y,n1,k,method="max")

</code></pre>

<hr>
<h2 id='bvnorm.pdf'>pdf of the Bivariate Normal Distribution</h2><span id='topic+bvnorm.pdf'></span>

<h3>Description</h3>

<p>Computes the value of the probability density function (i.e., density) of the bivariate normal distribution
at the specified point <code>X</code>, with mean <code>mu</code> and standard deviations of the first and second components being <code class="reqn">s_1</code>
and <code class="reqn">s_2</code> (denoted as <code>s1</code> and <code>s2</code> in the arguments of the function, respectively) 
and correlation between them being <code>rho</code> (i.e., the covariance matrix is <code class="reqn">\Sigma=S</code> where <code class="reqn">S_{11}=s_1^2</code>,
<code class="reqn">S_{22}=s_2^2</code>, <code class="reqn">S_{12}=S_{21}=s_1 s_2 rho</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bvnorm.pdf(X, mu = c(0, 0), s1 = 1, s2 = 1, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bvnorm.pdf_+3A_x">X</code></td>
<td>
<p>A set of 2D points of size <code class="reqn">n</code> (i.e an <code class="reqn">n \times 2</code> matrix or array) at which the density of the bivariate normal distribution
is to be computed.</p>
</td></tr>
<tr><td><code id="bvnorm.pdf_+3A_mu">mu</code></td>
<td>
<p>A <code class="reqn">1 \times 2</code> <code>vector</code> of real numbers representing the mean of the bivariate normal distribution,
default=<code class="reqn">(0,0)</code>.</p>
</td></tr>
<tr><td><code id="bvnorm.pdf_+3A_s1">s1</code>, <code id="bvnorm.pdf_+3A_s2">s2</code></td>
<td>
<p>The standard deviations of the first and second components of the bivariate normal distribution,
with default is <code>1</code> for both</p>
</td></tr>
<tr><td><code id="bvnorm.pdf_+3A_rho">rho</code></td>
<td>
<p>The correlation between the first and second components of the bivariate normal distribution
with default=0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the probability density function (i.e., density) of the bivariate normal distribution
at the specified point <code>X</code>, with mean <code>mu</code> and standard deviations of the first and second components being <code class="reqn">s_1</code>
and <code class="reqn">s_2</code> and correlation between them being <code>rho</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><a href="MASS.html#topic+mvrnorm">mvrnorm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu&lt;-c(0,0)
s1&lt;-1
s2&lt;-1
rho&lt;-.5

n&lt;-5
Xp&lt;-cbind(runif(n),runif(n))
bvnorm.pdf(Xp,mu,s1,s2,rho)
</code></pre>

<hr>
<h2 id='cellsTij'>Entries for the Types I-IV cell-specific tests</h2><span id='topic+cellsTij'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the values
of the Types I-IV cell-specific test statistics, 
<code class="reqn">T^I_{ij}-T^{IV}_{ij}</code>. 
The row and column names are inherited from <code>ct</code>. 
The type argument specifies the type
of the cell-specific test among the types I-IV tests. 
Equivalent to the function <code><a href="#topic+tct">tct</a></code> in this package.
</p>
<p>See also (Ceyhan (2017)) 
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cellsTij(ct, type = "III")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellsTij_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="cellsTij_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, default=<code>"III"</code>. 
Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the values of Type I-IV cell-specific tests
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tct">tct</a></code> and <code><a href="#topic+nnct">nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

type.lab&lt;-c("I","II","III","IV")
for (i in 1:4)
{ print(paste("T_ij values for cell specific tests for type",type.lab[i]))
  print(cellsTij(ct,i))
}

cellsTij(ct,"II")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)
cellsTij(ct,2)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
cellsTij(ct,2)

ct&lt;-matrix(c(0,10,5,5),ncol=2)
cellsTij(ct,2)

</code></pre>

<hr>
<h2 id='ceTk'>Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+ceTk'></span>

<h3>Description</h3>

<p>This function computes Cuzick and Edwards <code class="reqn">T_k</code> test statistic based on the number of cases within <code>k</code>NNs of the cases
in the data.
</p>
<p>For disease clustering, Cuzick and Edwards (1990) suggested a <code>k</code>-NN test based on number of cases
among <code>k</code> NNs of the case points. 
Let <code class="reqn">z_i</code> be the <code class="reqn">i^{th}</code> point and <code class="reqn">d_i^k</code> be the number cases among <code>k</code> NNs of <code class="reqn">z_i</code>.
Then Cuzick-Edwards' <code>k</code>-NN test is <code class="reqn">T_k=\sum_{i=1}^n \delta_i d_i^k</code>, where <code class="reqn">\delta_i=1</code> 
if <code class="reqn">z_i</code> is a case, and 0 if <code class="reqn">z_i</code> is a control.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly.
Also, <code class="reqn">T_1</code> is identical to the count for cell <code class="reqn">(1,1)</code> in the nearest neighbor contingency table (NNCT)
(See the function <code><a href="#topic+nnct">nnct</a></code> for more detail on NNCTs).
</p>
<p>See also (Ceyhan (2014); Cuzick and Edwards (1990))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceTk(dat, cc.lab, k = 1, case.lab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceTk_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ceTk_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ceTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>), default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ceTk_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ceTk_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cuzick and Edwards <code class="reqn">T_k</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tcomb">Tcomb</a></code>, <code><a href="#topic+seg.ind">seg.ind</a></code>, <code><a href="#topic+Pseg.coeff">Pseg.coeff</a></code> and <code><a href="#topic+ceTkinv">ceTkinv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))

ceTk(Y,cls)
ceTk(Y,cls,method="max")
ceTk(Y,cls,k=3)
ceTk(Y,cls+1,case.lab = 2)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ceTk(Y,fcls,case.lab="a") #try also ceTk(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  # here ceTk(Y,cls) gives an error message

</code></pre>

<hr>
<h2 id='ceTkinv'>Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</h2><span id='topic+ceTkinv'></span>

<h3>Description</h3>

<p>This function computes Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic based on the sum of number of cases closer to 
each case than the <code>k</code>-th nearest control to the case.
</p>
<p><code class="reqn">T_k^{inv}</code> test statistic is an extension of the run length test allowing a fixed number of controls in the run 
sequence. 
</p>
<p><code class="reqn">T_k^{inv}</code> test statistic is defined as <code class="reqn">T_k^{inv}=\sum_{i=1}^n \delta_i \nu_i^k</code> where <code class="reqn">\delta_i=1</code> 
if <code class="reqn">z_i</code> is a case, and 0 if <code class="reqn">z_i</code> is a control and <code class="reqn">\nu_i^k</code> is the number of cases closer
to the index case than the <code>k</code> nearest control, i.e., number of cases encountered beginning
at <code class="reqn">z_i</code> until <code>k</code>-th control is encountered. 
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>,
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's and 1's
accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceTkinv(dat, k, cc.lab, case.lab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceTkinv_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ceTkinv_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of the closest controls to subject <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="ceTkinv_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ceTkinv_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ceTkinv_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>Tkinv</code></td>
<td>
<p>Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic for disease clustering</p>
</td></tr>
<tr><td><code>run.vec</code></td>
<td>
<p>The <code>vector</code> of number of cases till the <code>k</code>-th control for each point in the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTrun">ceTrun</a></code>, <code><a href="#topic+ceTk">ceTk</a></code>, and <code><a href="#topic+Tcomb">Tcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
cls
k&lt;-2 #also try 3,4

ceTkinv(Y,k,cls)
ceTkinv(Y,k,cls+1,case.lab = 2)
ceTkinv(Y,k,cls,method="max")

ceTrun(Y,cls)
ceTkinv(Y,k=1,cls)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ceTkinv(Y,k,fcls,case.lab="a") #try also ceTrun(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #here ceTkinv(Y,k,cls) #gives error

</code></pre>

<hr>
<h2 id='ceTrun'>Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</h2><span id='topic+ceTrun'></span>

<h3>Description</h3>

<p>This function computes Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic based on the sum of the number of successive 
cases from each cases until a control is encountered in the data for detecting rare large clusters.
</p>
<p><code class="reqn">T_{run}</code> test statistic is defined as <code class="reqn">T_{run}=\sum_{i=1}^n \delta_i d_i^r</code> where <code class="reqn">\delta_i=1</code> 
if <code class="reqn">z_i</code> is a case, and 0 if <code class="reqn">z_i</code> is a control and <code class="reqn">d_i^r</code> is the number successive cases encountered beginning
at <code class="reqn">z_i</code> until a control is encountered. 
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>,
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's and 1's
accordingly.
</p>
<p>See also (Cuzick and Edwards (1990)) and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceTrun(dat, cc.lab, case.lab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceTrun_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ceTrun_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ceTrun_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ceTrun_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>Trun</code></td>
<td>
<p>Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic for disease clustering</p>
</td></tr>
<tr><td><code>run.vec</code></td>
<td>
<p>The <code>vector</code> of number of consecutive cases till the first control for each point in the data set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+Tcomb">Tcomb</a></code> and <code><a href="#topic+ceTkinv">ceTkinv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))

ceTrun(Y,cls)
ceTrun(Y,cls,method="max")
ceTrun(Y,cls+1,case.lab = 2)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ceTrun(Y,fcls,case.lab="a") #try also ceTrun(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #here ceTrun(Y,cls) #gives an error message

</code></pre>

<hr>
<h2 id='cov.nnct'>Covariance Matrix of the Cell Counts in an NNCT</h2><span id='topic+cov.nnct'></span>

<h3>Description</h3>

<p>Returns the covariance matrix of 
cell counts <code class="reqn">N_{ij}</code> for <code class="reqn">i,j=1,\ldots,k</code> 
in the NNCT, <code>ct</code>. 
The covariance matrix is of dimension <code class="reqn">k^2 \times k^2</code> 
and its entries are <code class="reqn">cov(N_{ij},N_{kl})</code> 
when <code class="reqn">N_{ij}</code> values are
by default corresponding to the row-wise vectorization of <code>ct</code>. 
If <code>byrow=FALSE</code>, the column-wise 
vectorization of <code>ct</code> is used.
These covariances are valid under RL 
or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010, 2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.nnct(ct, varN, Q, R, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.nnct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="cov.nnct_+3A_varn">varN</code></td>
<td>
<p>The <code class="reqn">k \times k</code> variance matrix of 
cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
<tr><td><code id="cov.nnct_+3A_q">Q</code></td>
<td>
<p>The number of shared NNs</p>
</td></tr>
<tr><td><code id="cov.nnct_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs (i.e.,
twice the number of reflexive NN pairs)</p>
</td></tr>
<tr><td><code id="cov.nnct_+3A_byrow">byrow</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). 
If <code>TRUE</code>, rows of <code>ct</code> are appended to obtain the vector
and if <code>FALSE</code> columns of <code>ct</code> are appended to obtain the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of 
cell counts <code class="reqn">N_{ij}</code> for <code class="reqn">i,j=1,\ldots,k</code> in the NNCT, <code>ct</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covNrow2col">covNrow2col</a></code>, <code><a href="#topic+cov.tct">cov.tct</a></code>,
and <code><a href="#topic+cov.nnsym">cov.nnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

cov.nnct(ct,varN,Qv,Rv)
cov.nnct(ct,varN,Qv,Rv,byrow=FALSE)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

cov.nnct(ct,varN,Qv,Rv)
cov.nnct(ct,varN,Qv,Rv,byrow=FALSE)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
cov.nnct(ct,varN,Qv,Rv)

</code></pre>

<hr>
<h2 id='cov.nnsym'>Covariance Matrix of the Differences of the Off-Diagonal Cell Counts in an NNCT</h2><span id='topic+cov.nnsym'></span>

<h3>Description</h3>

<p>Returns the covariance matrix of the differences of the cell counts, <code class="reqn">N_{ij}-N_{ji}</code> 
for <code class="reqn">i,j=1,\ldots,k</code> and <code class="reqn">i \ne j</code>, in the NNCT, <code>ct</code>.
The covariance matrix is of dimension <code class="reqn">k(k-1)/2 \times k(k-1)/2</code> and its entries are
<code class="reqn">cov(N_{ij}-N_{ji}, N_{kl}-N_{lk})</code> where the order of <code class="reqn">i,j</code> for <code class="reqn">N_{ij}-N_{ji}</code> is as
in the output of <code><a href="#topic+ind.nnsym">ind.nnsym</a>(k)</code>. 
These covariances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>The argument <code>covN</code> is the covariance matrix of <code class="reqn">N_{ij}</code> (concatenated rowwise).
</p>
<p>See also (Dixon (1994); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.nnsym(covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.nnsym_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k(k-1)/2 \times k(k-1)/2</code> covariance matrix of the differences of the off-diagonal cell counts <code class="reqn">N_{ij}-N_{ji}</code> 
for <code class="reqn">i,j=1,\ldots,k</code> and <code class="reqn">i \ne j</code> in the NNCT, <code>ct</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.nnsym">var.nnsym</a></code>, <code><a href="#topic+cov.tct">cov.tct</a></code>, <code><a href="#topic+cov.nnct">cov.nnct</a></code> and <code><a href="#topic+cov.seg.coeff">cov.seg.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

cov.nnsym(covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.nnsym(covN)

</code></pre>

<hr>
<h2 id='cov.seg.coeff'>Covariance Matrix of Segregation Coefficients in a Multi-class Case</h2><span id='topic+cov.seg.coeff'></span>

<h3>Description</h3>

<p>Returns the covariance matrix of the segregation coefficients in a multi-class case based on
the NNCT, <code>ct</code>. The covariance matrix is of dimension <code class="reqn">k(k+1)/2 \times k(k+1)/2</code> and its entry <code class="reqn">i,j</code> correspond to the
entries in the rows <code class="reqn">i</code> and <code class="reqn">j</code> of the output of <code><a href="#topic+ind.seg.coeff">ind.seg.coeff</a>(k)</code>. 
The segregation coefficients in the multi-class case are the extension of Pielou's segregation coefficient
for the two-class case.
These covariances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>The argument <code>covN</code> is the covariance matrix of <code class="reqn">N_{ij}</code> (concatenated rowwise).
</p>
<p>See also (Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.seg.coeff(ct, covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.seg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="cov.seg.coeff_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k(k+1)/2</code> x <code class="reqn">k(k+1)/2</code> covariance matrix of the segregation coefficients for the multi-class case
based on the NNCT, <code>ct</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.coeff">seg.coeff</a></code>, <code><a href="#topic+var.seg.coeff">var.seg.coeff</a></code>, <code><a href="#topic+cov.nnct">cov.nnct</a></code>
and <code><a href="#topic+cov.nnsym">cov.nnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.seg.coeff(ct,covN)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

cov.seg.coeff(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.seg.coeff(ct,covN)

</code></pre>

<hr>
<h2 id='cov.tct'>Covariance Matrix of the Entries of the Type I-IV TCTs</h2><span id='topic+cov.tct'></span>

<h3>Description</h3>

<p>Returns the covariance matrix of the entries <code class="reqn">T_{ij}</code> 
for <code class="reqn">i,j=1,\ldots,k</code> in the TCT for the types I, III, 
and IV cell-specific tests. 
The covariance matrix is of dimension <code class="reqn">k^2 \times k^2</code> 
and its entries are <code class="reqn">cov(T_{ij},T_{kl})</code>
when <code class="reqn">T_{ij}</code> values are by default corresponding 
to the row-wise vectorization of TCT. 
The argument <code>covN</code> must be the covariance matrix of 
<code class="reqn">N_{ij}</code> values which are obtained from the NNCT by row-wise
vectorization.
The functions <code>cov.tctIII</code> and <code>cov.tct3</code> are equivalent.
These covariances are valid under RL 
or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Ceyhan (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.tct(ct, covN, type = "III")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="cov.tct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
<tr><td><code id="cov.tct_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, default=<code>"III"</code>. Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of
the entries <code class="reqn">T_{ij}</code> for <code class="reqn">i,j=1,\ldots,k</code> in the Type I-IV TCTs
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.nnct">cov.nnct</a></code> and <code><a href="#topic+cov.nnsym">cov.nnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.tct(ct,covN,type=1)
cov.tct(ct,covN,type="I")
cov.tct(ct,covN,type="II")
cov.tct(ct,covN,type="III")
cov.tct(ct,covN,type="IV")
cov.tctI(ct,covN)

cov.tct(ct,covN)
cov.tctIII(ct,covN)
cov.tct3(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.tct(ct,covN,type=3)
cov.tct(ct,covN,type="III")

cov.tctIII(ct,covN)
cov.tct3(ct,covN)

</code></pre>

<hr>
<h2 id='covNrow2col'>Conversion of the Covariance Matrix of the Row-wise Vectorized Cell Counts 
to Column-wise Vectorized Cell Counts in an NNCT</h2><span id='topic+covNrow2col'></span>

<h3>Description</h3>

<p>Converts the <code class="reqn">k^2 \times k^2</code> covariance matrix 
of row-wise vectorized cell counts <code class="reqn">N_{ij}</code> for <code class="reqn">i,j=1,\ldots,k</code> 
in the NNCT, <code>ct</code> to the covariance matrix 
of column-wise vectorized cell counts.
In the output, the covariance matrix entries are <code class="reqn">cov(N_{ij},N_{kl})</code>
when <code class="reqn">N_{ij}</code> values are
corresponding to the column-wise vectorization of <code>ct</code>.
These covariances are valid under RL or 
conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010, 2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covNrow2col(covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covNrow2col_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise 
vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of column-wise 
vectorized cell counts <code class="reqn">N_{ij}</code> for 
<code class="reqn">i,j=1,\ldots,k</code> in the NNCT, <code>ct</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.nnct">cov.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

covNrow&lt;-cov.nnct(ct,varN,Qv,Rv)
covNcol1&lt;-cov.nnct(ct,varN,Qv,Rv,byrow=FALSE)
covNcol2&lt;-covNrow2col(covNrow)

covNrow
covNcol1
covNcol2

all.equal(covNcol1,covNcol2)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

covNrow&lt;-cov.nnct(ct,varN,Qv,Rv)
covNcol1&lt;-cov.nnct(ct,varN,Qv,Rv,byrow=FALSE)
covNcol2&lt;-covNrow2col(covNrow)

covNrow
covNcol1
covNcol2

all.equal(covNcol1,covNcol2)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
cov.nnct(ct,varN,Qv,Rv)

</code></pre>

<hr>
<h2 id='covTcomb'>Covariance matrix for <code class="reqn">T_k</code> values in <code>Tcomb</code></h2><span id='topic+covTcomb'></span>

<h3>Description</h3>

<p>This function computes the covariance matrix for the <code class="reqn">T_k</code> values used in the <code class="reqn">T_{comb}</code> test statistics,
which is a linear combination of some <code class="reqn">T_k</code> tests. 
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases is denoted as <code class="reqn">n_1</code> to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The argument <code>klist</code> is the <code>vector</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used
in obtaining the <code class="reqn">T_{comb}</code>.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>The logical argument <code>asy.cov</code> (default=<code>FALSE</code>) is for using the asymptotic covariance or the exact (i.e., finite
sample) covariance for the vector of <code class="reqn">T_k</code> values used in <code>Tcomb</code>.
If <code>asy.cov=TRUE</code>, the asymptotic covariance is used, otherwise the exact covariance is used.
</p>
<p>See page 87 of (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covTcomb(dat, n1, klist, nonzero.mat = TRUE, asy.cov = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covTcomb_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="covTcomb_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="covTcomb_+3A_klist">klist</code></td>
<td>
<p><code>list</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used in obtaining the <code class="reqn">T_{comb}</code>.</p>
</td></tr>
<tr><td><code id="covTcomb_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="covTcomb_+3A_asy.cov">asy.cov</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether asymptotic or exact (i.e., finite
sample) covariances between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values are to be used to obtain the entries of the covariance matrix.
If <code>TRUE</code> the asymptotic covariance values are used, otherwise exact covariance values are used.</p>
</td></tr>
<tr><td><code id="covTcomb_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the covariance matrix for the <code class="reqn">T_k</code> values used in <code>Tcomb</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asycovTkTl">asycovTkTl</a></code>, <code><a href="#topic+covTcomb">covTcomb</a></code>, and <code><a href="#topic+Ntkl">Ntkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)

kl&lt;-sample(1:5,3) #try also sample(1:5,2)
kl
covTcomb(Y,n1,kl)
covTcomb(Y,n1,kl,method="max")
covTcomb(Y,n1,kl,nonzero.mat = FALSE)

covTcomb(Y,n1,kl,asy=TRUE)

</code></pre>

<hr>
<h2 id='covTkTl'>Finite Sample Covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> Values</h2><span id='topic+covTkTl'></span>

<h3>Description</h3>

<p>This function computes the exact (i.e., finite sample) covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values
which is used in the computation of the exact variance
of Cuzick and Edwards <code class="reqn">T_{comb}</code> test, which is a linear combination of some <code class="reqn">T_k</code> tests.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>See page 80 of (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covTkTl(dat, n1, k, l, nonzero.mat = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covTkTl_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="covTkTl_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="covTkTl_+3A_k">k</code>, <code id="covTkTl_+3A_l">l</code></td>
<td>
<p>Integers specifying the number of NNs (of subjects <code class="reqn">i</code> and <code class="reqn">m</code> in <code class="reqn">a_{ij}(k) a_{mj}(l)</code>).</p>
</td></tr>
<tr><td><code id="covTkTl_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="covTkTl_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the exact covariance between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asycovTkTl">asycovTkTl</a></code>, <code><a href="#topic+covTcomb">covTcomb</a></code>, and <code><a href="#topic+Ntkl">Ntkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)

k&lt;-1 #try also 2,3 or sample(1:5,1)
l&lt;-1 #try also 2,3 or sample(1:5,1)
c(k,l)

covTkTl(Y,n1,k,l)
covTkTl(Y,n1,k,l,method="max")
asycovTkTl(Y,n1,k,l)

covTkTl(Y,n1,k,l,nonzero.mat = FALSE)
asycovTkTl(Y,n1,k,l,nonzero.mat = FALSE)

</code></pre>

<hr>
<h2 id='dist.std.data'>Interpoint Distance Matrix for Standardized Data</h2><span id='topic+dist.std.data'></span>

<h3>Description</h3>

<p>This function computes and returns the distance matrix computed by using the specified distance measure 
to compute the distances between the rows of a data matrix which is standardized row or column-wise.
That is, the output is the interpoint distance (IPD) matrix of the rows of the given set of points <code>x</code>
<code><a href="stats.html#topic+dist">dist</a></code> function in the <code>stats</code> package of the standard R distribution.
The argument column is the logical argument (default=<code>TRUE</code>) to determine row-wise or column-wise standardization.
If <code>TRUE</code> each column is divided by its standard deviation, else each row is divided by its standard deviation.
This function is different from the <code><a href="stats.html#topic+dist">dist</a></code> function in the <code>stats</code> package.
<code>dist</code> returns the distance matrix in a lower triangular form, and dist.std.data returns in a full matrix
of distances of standardized data set.
... are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.std.data(x, column = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist.std.data_+3A_x">x</code></td>
<td>
<p>A set of points in matrix or data frame form where points correspond to the rows.</p>
</td></tr>
<tr><td><code id="dist.std.data_+3A_column">column</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether standardization is row-wise or
column-wise. If <code>TRUE</code> it is column-wise else row-wise standardization.</p>
</td></tr>
<tr><td><code id="dist.std.data_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on the <code>dist</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix whose  <code class="reqn">i,j</code>-th entry is the distance between rows <code class="reqn">i</code> and <code class="reqn">j</code> of <code>x</code>, which is
standardized row-wise or column-wise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+ipd.mat">ipd.mat</a></code>, and <code><a href="#topic+ipd.mat.euc">ipd.mat.euc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
range(ipd)

ipd2&lt;-dist.std.data(Y) #distance of standardized data
range(ipd2)

ipd2&lt;-dist.std.data(Y,method="max") #distance of standardized data
range(ipd2)

#############
Y&lt;-matrix(runif(60,0,100),ncol=3)
ipd&lt;-ipd.mat(Y)
range(ipd)

ipd2&lt;-dist.std.data(Y) #distance of standardized data
range(ipd2)

</code></pre>

<hr>
<h2 id='dist2full'>Converts a lower triangular distance matrix to a full distance matrix</h2><span id='topic+dist2full'></span>

<h3>Description</h3>

<p>Converts a lower triangular distance matrix to a full distance matrix
with zeroes in the diagonal.
The input is usually the result of the <code><a href="stats.html#topic+dist">dist</a></code> function 
in the <code>stats</code> package.
This function is adapted from Everitt's book 
(Everitt (2004))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2full(dis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2full_+3A_dis">dis</code></td>
<td>
<p>A lower triangular matrix, 
resulting from the <code><a href="stats.html#topic+dist">dist</a></code> 
function in the <code>stats</code> package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square (symmetric) distance matrix with zeroes in the diagonal.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Everitt BS (2004).
<em>An R and S-Plus Companion to Multivariate Analysis</em>.
Springer-Verlag, London, UK.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-3
X&lt;-matrix(runif(3*n),ncol=3)
dst&lt;-dist(X)
dist2full(dst)

</code></pre>

<hr>
<h2 id='euc.dist'>The Euclidean distance between two vectors, matrices, or data frames</h2><span id='topic+euc.dist'></span>

<h3>Description</h3>

<p>Returns the Euclidean distance between <code>x</code> and <code>y</code> 
which can be vectors #' or matrices or data frames of
any dimension (<code>x</code> and <code>y</code> should be of same dimension).
</p>
<p>This function is equivalent to <code><a href="pcds.html#topic+Dist">Dist</a></code> function 
in the <code>pcds</code> package but is 
different from the <code><a href="stats.html#topic+dist">dist</a></code> function 
in the <code>stats</code> package of the standard R distribution.
<code>dist</code> requires its argument to be a data matrix and 
<code><a href="stats.html#topic+dist">dist</a></code> computes and returns 
he distance matrix computed by using the specified distance measure 
to compute the distances between the rows of a data matrix
(Becker et al. (1988)),
while <code>euc.dist</code> needs two arguments to find the distances between. 
For two data matrices <code>A</code> and <code>B</code>,
<code>dist(rbind(as.vector(A),as.vector(B)))</code> and 
<code>euc.dist(A,B)</code> yield the same result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euc.dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euc.dist_+3A_x">x</code>, <code id="euc.dist_+3A_y">y</code></td>
<td>
<p>Vectors, matrices or data frames 
(both should be of the same type).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Euclidean distance between <code>x</code> and <code>y</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Becker RA, Chambers JM, Wilks AR (1988).
<em>The New S Language</em>.
Wadsworth &amp;amp Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code> from the base package <code>stats</code> and
<code><a href="pcds.html#topic+Dist">Dist</a></code> from the package <code>pcds</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B&lt;-c(1,0); C&lt;-c(1/2,sqrt(3)/2);
euc.dist(B,C);
euc.dist(B,B);

x&lt;-runif(10)
y&lt;-runif(10)
euc.dist(x,y)

xm&lt;-matrix(x,ncol=2)
ym&lt;-matrix(y,ncol=2)
euc.dist(xm,ym)

euc.dist(xm,xm)

dat.fr&lt;-data.frame(b=B,c=C)
euc.dist(dat.fr,dat.fr)
euc.dist(dat.fr,cbind(B,C))

</code></pre>

<hr>
<h2 id='EV.Nii'>Expected Values of the Self Entries in a Species Correspondence Contingency Table (SCCT)</h2><span id='topic+EV.Nii'></span>

<h3>Description</h3>

<p>Returns a <code>vector</code> of length <code class="reqn">k</code> of expected values of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the expected values of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT.
These expected values are valid under RL or CSR.
</p>
<p>The argument <code>ct</code> can be either the NNCT or SCCT.
</p>
<p>See also (Ceyhan (2018)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.Nii(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.Nii_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length <code class="reqn">k</code> whose entries are the expected values of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or of the diagonal entries in an NNCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scct">scct</a></code> and <code><a href="#topic+EV.nnct">EV.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

EV.Nii(ct)
ct&lt;-scct(ipd,cls)
EV.Nii(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

EV.Nii(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.Nii(ct)
ct&lt;-scct(ipd,cls)
EV.Nii(ct)

</code></pre>

<hr>
<h2 id='EV.nnct'>Expected Values of the Cell Counts in NNCT</h2><span id='topic+EV.nnct'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the expected cell counts of
the NNCT under RL or CSR. The class sizes given as 
the row sums of <code>ct</code> and the row and column names are
inherited from <code>ct</code>.
</p>
<p>See also (Dixon (1994); Ceyhan (2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.nnct(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.nnct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the expected values of cell counts in the NNCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct">nnct</a></code> and <code><a href="#topic+EV.tct">EV.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.nnct(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)
EV.nnct(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.nnct(ct)

ct&lt;-matrix(c(0,10,5,5),ncol=2)
EV.nnct(ct)

</code></pre>

<hr>
<h2 id='EV.rct'>Expected Values of the Cell Counts in RCT</h2><span id='topic+EV.rct'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> of same dimension as the RCT, <code>rfct</code>, 
whose entries are the expected cell counts of
the RCT under RL or CSR.
</p>
<p>See also (Ceyhan and Bahadir (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.rct(rfct, nvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.rct_+3A_rfct">rfct</code></td>
<td>
<p>An RCT</p>
</td></tr>
<tr><td><code id="EV.rct_+3A_nvec">nvec</code></td>
<td>
<p>The <code>vector</code> of class sizes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the expected values of cell counts in the RCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rct">rct</a></code>, <code><a href="#topic+EV.nnct">EV.nnct</a></code> and <code><a href="#topic+EV.tct">EV.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)
EV.rct(rfct,nvec)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nvec&lt;-as.numeric(table(fcls))
rfct&lt;-rct(ipd,fcls)
EV.rct(rfct,nvec)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

rfct&lt;-rct(ipd,cls)
EV.rct(rfct,nvec)

</code></pre>

<hr>
<h2 id='EV.Tcomb'>Expected Value for Cuzick &amp; Edwards <code class="reqn">T_{comb}</code> Test Statistic</h2><span id='topic+EV.Tcomb'></span>

<h3>Description</h3>

<p>This function computes the expected value of Cuzick &amp; Edwards <code class="reqn">T_{comb}</code> test statistic in disease clustering,
where <code class="reqn">T_{comb}</code> is a linear combination of some <code class="reqn">T_k</code> tests. 
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases is denoted as <code class="reqn">n_1</code> to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The argument <code>klist</code> is the <code>vector</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used
in obtaining the <code class="reqn">T_{comb}</code>.
</p>
<p>The argument <code>sig</code> is the covariance matrix of the vector of <code class="reqn">T_k</code> values used in <code>Tcomb</code>, and can be computed
via the the <code><a href="#topic+covTcomb">covTcomb</a></code> function.
</p>
<p>See page 87 of (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.Tcomb(n1, n, klist, sig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.Tcomb_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="EV.Tcomb_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points in the data set</p>
</td></tr>
<tr><td><code id="EV.Tcomb_+3A_klist">klist</code></td>
<td>
<p><code>list</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used in obtaining the <code class="reqn">T_{comb}</code>.</p>
</td></tr>
<tr><td><code id="EV.Tcomb_+3A_sig">sig</code></td>
<td>
<p>The covariance matrix of the vector of <code class="reqn">T_k</code> values used in <code>Tcomb</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the expected value of the <code class="reqn">T_{comb}</code> test statistic
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tcomb">Tcomb</a></code>, and <code><a href="#topic+ZTcomb">ZTcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1) #try also n&lt;-50, 100
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)

kl&lt;-sample(1:5,3) #try also sample(1:5,2)
kl
sig&lt;-covTcomb(Y,n1,kl)
EV.Tcomb(n1,n,kl,sig)

</code></pre>

<hr>
<h2 id='EV.tct'>Expected Values of the Types I-IV cell-specific tests</h2><span id='topic+EV.tct'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the expected values
of the <code class="reqn">T_{ij}</code> values which are the Types I-IV cell-specific 
test statistics (i.e., <code class="reqn">T^I_{ij}-T^{IV}_{ij}</code>)
under RL or CSR. 
The row and column names are inherited from <code>ct</code>.
The type argument specifies the type
of the cell-specific test among the types I-IV tests.
</p>
<p>See also (Ceyhan (2017)) 
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.tct(ct, type = "III")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="EV.tct_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, default=<code>"III"</code>. 
Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the expected values of 
Type I-IV cell-specific tests.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EV.tctI">EV.tctI</a></code>, <code><a href="#topic+tct">tct</a></code>, and <code><a href="#topic+EV.nnct">EV.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.tct(ct,2)
EV.tct(ct,"II")
EV.tctI(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)
EV.tct(ct,2)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.tct(ct,2)

ct&lt;-matrix(c(0,10,5,5),ncol=2)
EV.tct(ct,2)

</code></pre>

<hr>
<h2 id='EV.tctI'>Expected Values of the Type I cell-specific tests</h2><span id='topic+EV.tctI'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the expected values
of the Type I cell-specific test statistics, <code class="reqn">T^I_{ij}</code>. 
The row and column names are inherited from <code>ct</code>. 
These expected values are valid under RL or CSR.
</p>
<p>See also (Ceyhan (2017)) 
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.tctI(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.tctI_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the expected values of Type I cell-specific tests.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EV.tct">EV.tct</a></code>, <code><a href="#topic+tct">tct</a></code> and <code><a href="#topic+EV.nnct">EV.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

EV.tctI(ct)

</code></pre>

<hr>
<h2 id='EV.Tkinv'>Expected Value of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</h2><span id='topic+EV.Tkinv'></span>

<h3>Description</h3>

<p>This function computes the expected value of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic which is based on the 
sum of number of cases closer to each case than the <code>k</code>-th nearest control to the case.
</p>
<p>The number of cases are denoted as <code class="reqn">n_1</code> (denoted as <code>n1</code> as an argument)
and number of controls as <code class="reqn">n_0</code> for both functions (denoted as <code>n0</code> as an argument),
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>See the function <code><a href="#topic+ceTkinv">ceTkinv</a></code> for the details of the <code class="reqn">T_k^{inv}</code> test.
</p>
<p>See (Cuzick and Edwards (1990)) and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.Tkinv(n1, n0, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EV.Tkinv_+3A_n1">n1</code>, <code id="EV.Tkinv_+3A_n0">n0</code></td>
<td>
<p>The number of cases and controls</p>
</td></tr>
<tr><td><code id="EV.Tkinv_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of the closest controls to subject <code class="reqn">i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTkinv">ceTkinv</a></code>, <code><a href="#topic+ceTrun">ceTrun</a></code>, and <code><a href="#topic+EV.Trun">EV.Trun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20
n0&lt;-25
k&lt;-2 #try also 2, 3

EV.Tkinv(n1,n0,k)

EV.Tkinv(n1,n0,k=1)
EV.Trun(n1,n0)

</code></pre>

<hr>
<h2 id='exact.nnct'>Exact version of Pearson's chi-square test on NNCTs</h2><span id='topic+exact.nnct'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> performing exact version of Pearson's chi-square test on nearest neighbor contingency
tables (NNCTs) for the RL or CSR independence for 2 classes.
Pearson's <code class="reqn">\chi^2</code> test is based on the test statistic 
<code class="reqn">\mathcal X^2=\sum_{j=1}^2\sum_{i=1}^2 (N_{ij}-\mu_{ij})^2/\mu_{ij}</code>,
which has <code class="reqn">\chi^2_1</code> distribution in the limit provided
that the contingency table is constructed under the independence null hypothesis.
The exact version of Pearson's test uses the exact distribution of <code class="reqn">\mathcal X^2</code> rather than large sample 
<code class="reqn">\chi^2</code> approximation.
That is, for the one-sided alternative, we calculate
the <code class="reqn">p</code>-values as in the function <code><a href="#topic+exact.pval1s">exact.pval1s</a></code>;
and for the two-sided alternative, we calculate
the <code class="reqn">p</code>-values as in the function <code><a href="#topic+exact.pval2s">exact.pval2s</a></code> with double argument determining
the type of the correction. 
</p>
<p>This test would be equivalent to Fisher's exact test <code><a href="stats.html#topic+fisher.test">fisher.test</a></code> if the odds ratio=1
(which can not be specified in the current version), and the odds ratio for the RL or CSR independence null
hypothesis is <code class="reqn">\theta_0=(n_1-1)(n_2-1)/(n_1 n_2)</code> which is used in the function and
the <code class="reqn">p</code>-value and confidence interval computations are are adapted from <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>.
</p>
<p>See Ceyhan (2014) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact.nnct(
  ct,
  alternative = "two.sided",
  conf.level = 0.95,
  pval.type = "inc",
  double = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact.nnct_+3A_ct">ct</code></td>
<td>
<p>A <code class="reqn">2 \times 2</code> NNCT</p>
</td></tr>
<tr><td><code id="exact.nnct_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="exact.nnct_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the odds ratio</p>
</td></tr>
<tr><td><code id="exact.nnct_+3A_pval.type">pval.type</code></td>
<td>
<p>The type of the <code class="reqn">p</code>-value correction for the exact test on the NNCT, default=<code>"inc"</code>.
Takes on values <code>"inc"</code>, <code>"exc"</code>, <code>"mid"</code>, <code>"tocher"</code> (or equivalently <code>1-4</code>, respectively) for table inclusive,
table-exclusive, mid-<code class="reqn">p</code>-value, and Tocher corrected <code class="reqn">p</code>-value, respectively.</p>
</td></tr>
<tr><td><code id="exact.nnct_+3A_double">double</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether type I or II correction should be 
applied to the two-sided <code class="reqn">p</code>-value. Used only when <code>alternative="two.sided"</code>. 
If <code>TRUE</code> type I correction (for doubling the minimum of the one-sided <code class="reqn">p</code>-value) 
is applied, otherwise, type II correction (using the probabilities for the more extreme tables) is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The test statistic, it is <code>NULL</code> for this function</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the odds ratio in the <code class="reqn">2 \times 2</code> NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate, i.e., the observed odds ratio the <code class="reqn">2 \times 2</code> NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the odds ratio in the <code class="reqn">2 \times 2</code> NNCT, which is
<code class="reqn">\theta_0=(n_1-1)(n_2-1)/(n_1 n_2)</code> for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fisher.test">fisher.test</a></code>, <code><a href="#topic+exact.pval1s">exact.pval1s</a></code>, and <code><a href="#topic+exact.pval2s">exact.pval2s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

exact.nnct(ct)
fisher.test(ct)

exact.nnct(ct,alt="g")
fisher.test(ct,alt="g")

exact.nnct(ct,alt="l",pval.type = "mid")

#############
ct&lt;-matrix(sample(10:20,9),ncol=3)
fisher.test(ct) #here exact.nnct(ct) gives error message, since number of classes &gt; 2

</code></pre>

<hr>
<h2 id='exact.pval1s'><code class="reqn">p</code>-value correction to the one-sided version of exact NNCT test</h2><span id='topic+exact.pval1s'></span>

<h3>Description</h3>

<p>In using Fisher's exact test on the <code class="reqn">2 \times 2</code> nearest neighbor contingency tables (NNCTs) a correction
may be needed for the <code class="reqn">p</code>-value. For the one-sided alternatives, the probabilities of 
more extreme tables are summed up, including or excluding the 
probability of the table itself (or some middle way). 
Let the probability of the contingency table itself be <code class="reqn">p_t=f(n_{11}|n_1,n_2,c_1;\theta_0)</code>
where <code class="reqn">\theta_0=(n_1-1)(n_2-1)/(n_1 n_2)</code> which is the odds ratio
under RL or CSR independence and
<code class="reqn">f</code> is the probability mass function of the hypergeometric distribution.
For testing the one-sided alternative <code class="reqn">H_o:\,\theta=\theta_0</code> versus <code class="reqn">H_a:\,\theta&gt;\theta_0</code>,
we consider the following four methods in calculating the <code class="reqn">p</code>-value:
</p>

<ul>
<li><p> [(i)] with <code class="reqn">S=\{t:\,t \geq n_{11}\}</code>, we get the
<em>table-inclusive version</em> which is denoted as <code class="reqn">p^&gt;_{inc}</code>,
</p>
</li>
<li><p> [(ii)] with <code class="reqn">S=\{t:\,t&gt; n_{11}\}</code>, we get the
<em>table-exclusive version</em>, denoted as <code class="reqn">p^&gt;_{exc}</code>.
</p>
</li>
<li><p> [(iii)] Using <code class="reqn">p=p^&gt;_{exc}+p_t/2</code>, we get the <em>mid-<code class="reqn">p</code> version</em>, denoted as <code class="reqn">p^&gt;_{mid}</code>.
</p>
</li>
<li><p> [(iv)] We can also use <em>Tocher corrected version</em> which is denoted as <code class="reqn">p^&gt;_{Toc}</code>
(see <code><a href="#topic+tocher.cor">tocher.cor</a></code> for details).
</p>
</li></ul>

<p>See (Ceyhan (2010)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact.pval1s(ptable, pval, type = "inc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact.pval1s_+3A_ptable">ptable</code></td>
<td>
<p>Probability of the observed <code class="reqn">2 \times 2</code> NNCT under the null hypothesis using the hypergeometric distribution
for Fisher's exact test.</p>
</td></tr>
<tr><td><code id="exact.pval1s_+3A_pval">pval</code></td>
<td>
<p>Table inclusive <code class="reqn">p</code>-value for Fisher's exact test on the NNCT.</p>
</td></tr>
<tr><td><code id="exact.pval1s_+3A_type">type</code></td>
<td>
<p>The type of the <code class="reqn">p</code>-value correction for the one-sided exact test on the NNCT, default=<code>"inc"</code>.
Takes on values <code>"inc"</code>, <code>"exc"</code>, <code>"mid"</code>, <code>"tocher"</code> (or equivalently <code>1-4</code>, respectively) for table inclusive,
table-exclusive, mid-<code class="reqn">p</code>-value, and Tocher corrected <code class="reqn">p</code>-value, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code class="reqn">p</code>-value based on the correction specified in <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Exact Inference for Testing Spatial Patterns by Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of Probability and Statistical Science</em>, <b>8(1)</b>, 45-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exact.pval2s">exact.pval2s</a></code> and <code><a href="#topic+tocher.cor">tocher.cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct&lt;-matrix(sample(20:40,4),ncol=2)
ptab&lt;-prob.nnct(ct)
pv&lt;-.3
exact.pval1s(ptab,pv)
exact.pval1s(ptab,pv,type="exc")
exact.pval1s(ptab,pv,type="mid")

</code></pre>

<hr>
<h2 id='exact.pval2s'><code class="reqn">p</code>-value correction to the two-sided version of exact NNCT test</h2><span id='topic+exact.pval2s'></span>

<h3>Description</h3>

<p>In using Fisher's exact test on the <code class="reqn">2 \times 2</code> nearest neighbor contingency tables (NNCTs) a correction may be needed
for the <code class="reqn">p</code>-value. For the one-sided alternatives, the probabilities of 
more extreme tables are summed up, including or excluding the 
probability of the table itself (or some middle way). 
</p>
<p>There is additional complexity in <code class="reqn">p</code>-values for the two-sided alternatives.
A recommended method is adding up probabilities of the same
size and smaller than the probability associated with the current table.
Alternatively, one can double the one-sided <code class="reqn">p</code>-value (see (Agresti (1992)).
</p>
<p>Let the probability of the contingency table itself be <code class="reqn">p_t=f(n_{11}|n_1,n_2,c_1;\theta_0)</code>
where <code class="reqn">\theta_0=(n_1-1)(n_2-1)/(n_1 n_2)</code> which is the odds ratio
under RL or CSR independence and
<code class="reqn">f</code> is the probability mass function of the hypergeometric distribution.
</p>
<p>**Type (I):** For double the one-sided <code class="reqn">p</code>-value, we propose the following four variants:
</p>

<ul>
<li><p> [(i)] twice the minimum of <code class="reqn">p_{inc}</code> for the one-sided tests, which is
table-inclusive version for this type of two-sided test, and denoted as <code class="reqn">p^I_{inc}</code>,
</p>
</li>
<li><p> [(ii)] twice the minimum of <code class="reqn">p_{inc}</code> minus twice the table
probability <code class="reqn">p_t</code>, which is table-exclusive version of this type of
two-sided test, and denoted as <code class="reqn">p^I_{exc}</code>,
</p>
</li>
<li><p> [(iii)] table-exclusive version of this type of
two-sided test plus <code class="reqn">p_t</code>, which is mid-<code class="reqn">p</code>-value for
this test, and denoted as <code class="reqn">p^I_{midd}</code>,
</p>
</li>
<li><p> [(iv)]Tocher corrected version (see <code><a href="#topic+tocher.cor">tocher.cor</a></code> for details).
</p>
</li></ul>

<p>**Type (II):** For summing the <code class="reqn">p</code>-values of more extreme &mdash;than that of the table&mdash; cases
in both directions, the following variants are obtained.
The <code class="reqn">p</code>-value is <code class="reqn">p=\sum_S f(t|n_1,n_2,c_1;\theta=1)</code> with
</p>

<ul>
<li><p> [(i)] <code class="reqn">S=\{t:\,f(t|n_1,n_2,c_1;\theta=1) \leq p_t\}</code>, which is
called <em>table-inclusive version</em>, <code class="reqn">p^{II}_{inc}</code>,
</p>
</li>
<li><p> [(ii)] the probability of the observed table is included twice, once for each side;
that is <code class="reqn">p=p^{II}_{inc}+p_t</code>, which is called <em>twice-table-inclusive version</em>, <code class="reqn">p^{II}_{tinc}</code>,
</p>
</li>
<li><p> [(iii)] table-inclusive minus <code class="reqn">p_t</code>, which is referred as <em>table-exclusive version</em>, <code class="reqn">p^{II}_{exc}</code>,
</p>
</li>
<li><p> [(iv)] table-exclusive plus one-half
the <code class="reqn">p_t</code>, which is called <em>mid-<code class="reqn">p</code> version</em>, <code class="reqn">p^{II}_{mid}</code> and,
</p>
</li>
<li><p> [(v)]<em>Tocher corrected version</em>, <code class="reqn">p^{II}_{Toc}</code>, is obtained as before.
</p>
</li></ul>

<p>See (Ceyhan (2010)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact.pval2s(ptable, pval, type = "inc", double = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exact.pval2s_+3A_ptable">ptable</code></td>
<td>
<p>Probability of the observed <code class="reqn">2 \times 2</code> NNCT under the null hypothesis using the hypergeometric
distribution for Fisher's exact test.</p>
</td></tr>
<tr><td><code id="exact.pval2s_+3A_pval">pval</code></td>
<td>
<p>Table inclusive <code class="reqn">p</code>-value for Fisher's exact test on the NNCT.</p>
</td></tr>
<tr><td><code id="exact.pval2s_+3A_type">type</code></td>
<td>
<p>The type of the <code class="reqn">p</code>-value correction for the two-sided exact test on the NNCT, default=<code>"inc"</code>.
Takes on values <code>"inc"</code>, <code>"exc"</code>, <code>"mid"</code>, <code>"tocher"</code> (or equivalently <code>1-4</code>, respectively) for table inclusive,
table-exclusive, mid-<code class="reqn">p</code>-value, and Tocher corrected <code class="reqn">p</code>-value, respectively.</p>
</td></tr>
<tr><td><code id="exact.pval2s_+3A_double">double</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether type I or II correction should be 
applied to the two-sided <code class="reqn">p</code>-value. If <code>TRUE</code> type I correction (for doubling the minimum of the one-sided <code class="reqn">p</code>-value) 
is applied, otherwise, type II correction (using the probabilities for the more extreme tables) is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code class="reqn">p</code>-value based on the correction specified in <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Agresti A (1992).
&ldquo;A Survey of Exact Inference for Contingency Tables.&rdquo;
<em>Statistical Science</em>, <b>7(1)</b>, 131-153.<br /><br /> Ceyhan E (2010).
&ldquo;Exact Inference for Testing Spatial Patterns by Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of Probability and Statistical Science</em>, <b>8(1)</b>, 45-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exact.pval1s">exact.pval1s</a></code> and <code><a href="#topic+tocher.cor">tocher.cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct&lt;-matrix(sample(20:40,4),ncol=2)
ptab&lt;-prob.nnct(ct)
pv&lt;-.23
exact.pval2s(ptab,pv)
exact.pval2s(ptab,pv,type="exc")
exact.pval2s(ptab,pv,type="mid")

</code></pre>

<hr>
<h2 id='funs.auxcovtct'>Auxiliary Functions for Computing Covariances 
Between Cell Counts in the TCT</h2><span id='topic+funs.auxcovtct'></span><span id='topic+cov.2cells'></span><span id='topic+cov.cell.col'></span><span id='topic+covNijCk'></span><span id='topic+cov.2cols'></span><span id='topic+covCiCj'></span>

<h3>Description</h3>

<p>Five functions: <code>cov.2cells</code>, <code>cov.cell.col</code>, <code>covNijCk</code>, <code>cov2cols</code>
and <code>covCiCj</code>
</p>
<p>These are auxiliary functions for computing covariances 
between entries in the TCT for the types I-IV
cell-specific tests. 
The covariances between <code class="reqn">T_{ij}</code> values for <code class="reqn">i,j=1,\ldots,k</code> 
in the TCT require covariances
between two cells in the NNCT, between a cell and column sum, 
and between two column sums in the NNCT.
<code>cov.2cells</code> computes the covariance 
between two cell counts <code class="reqn">N_{ij}</code> and <code class="reqn">N_{kl}</code> in an NNCT,
<code>cov.cell.col</code> and <code>covNijCk</code> are equivalent 
and they compute the covariance between cell count <code class="reqn">N_{ij}</code>
and sum of column <code class="reqn">k</code>, <code class="reqn">C_k</code>,
<code>cov2cols</code> and <code>covCiCj</code> are equivalent 
and they compute the covariance between sums of two columns, 
<code class="reqn">C_i</code> and <code class="reqn">C_j</code>.
The index arguments refer to which entry or 
column sum is intended in the NNCT. 
The argument <code>covN</code> must be the covariance 
between <code class="reqn">N_{ij}</code> values which are obtained 
from NNCT by row-wise vectorization.
These covariances are valid under RL or 
conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.2cells(i, j, k, l, ct, covN)

cov.cell.col(i, j, k, ct, covN)

covNijCk(i, j, k, ct, covN)

cov.2cols(i, j, ct, covN)

covCiCj(i, j, ct, covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.auxcovtct_+3A_i">i</code>, <code id="funs.auxcovtct_+3A_j">j</code>, <code id="funs.auxcovtct_+3A_k">k</code>, <code id="funs.auxcovtct_+3A_l">l</code></td>
<td>
<p>Indices of the cell counts or 
column sums whose covariance is to be computed. 
All four are needed for <code>cov.2cells</code> 
referring to cells <code class="reqn">(i,j)</code> and <code class="reqn">(k,l)</code>; 
only three indices <code class="reqn">i,j,k</code> are needed for
<code>cov.cell.col</code> and <code>covNijCk</code> 
referring to cell <code class="reqn">(i,j)</code> and column <code class="reqn">k</code>;
only two indices <code class="reqn">i,j</code> are needed for <code>cov2cols</code> 
and <code>covCiCj</code> referring to columns <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="funs.auxcovtct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="funs.auxcovtct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of 
row-wise vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cov.2cells</code> returns the covariance 
between two cell counts <code class="reqn">N_{ij}</code> and <code class="reqn">N_{kl}</code> in an NNCT,
<code>cov.cell.col</code> and <code>covNijCk</code> 
return the covariance between cell count <code class="reqn">N_{ij}</code>
and sum of column <code class="reqn">k</code>, <code class="reqn">C_k</code>,
<code>cov2cols</code> and <code>covCiCj</code> 
return the covariance between sums of two columns, 
<code class="reqn">C_i</code> and <code class="reqn">C_j</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.tct">cov.tct</a></code> and <code><a href="#topic+cov.nnct">cov.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.2cells(1,1,1,2,ct,covN)

cov.cell.col(2,2,1,ct,covN)
covNijCk(2,2,1,ct,covN)

cov.2cols(2,1,ct,covN)
covCiCj(2,1,ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.2cells(2,3,1,2,ct,covN)

cov.cell.col(1,1,2,ct,covN)
covNijCk(1,1,2,ct,covN)

cov.2cols(3,4,ct,covN)
covCiCj(3,4,ct,covN)

</code></pre>

<hr>
<h2 id='funs.base.class.spec'>Base Class-specific Chi-square Tests based on NNCTs</h2><span id='topic+funs.base.class.spec'></span><span id='topic+base.class.spec.ct'></span><span id='topic+base.class.spec'></span>

<h3>Description</h3>

<p>Two functions: <code>base.class.spec.ct</code> and <code>base.class.spec</code>.
</p>
<p>Both functions are objects of class <code>"classhtest"</code> but with different arguments (see the parameter list below).
Each one performs class specific segregation tests due to Dixon for <code class="reqn">k \ge 2</code> classes. That is,
each one performs hypothesis tests of deviations of 
entries in each row of NNCT from the expected values under RL or CSR for each row. 
Recall that row labels in the NNCT are base class labels.
The test for each row <code class="reqn">i</code> is based on the chi-squared approximation of the corresponding quadratic form
and are due to Dixon (2002).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> for each base class <code class="reqn">i</code>, description of the 
alternative with the corresponding null values (i.e., expected values) for the row <code class="reqn">i</code>, estimates for the entries in row <code class="reqn">i</code>
for <code class="reqn">i=1,\ldots,k</code>. The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis for each row is that the corresponding <code class="reqn">N_{ij}</code> entries in row <code class="reqn">i</code> are equal to their 
expected values under RL or CSR.
</p>
<p>See also (Dixon (2002); Ceyhan (2009))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base.class.spec.ct(ct, covN)

base.class.spec(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.base.class.spec_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>base.class.spec.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.base.class.spec_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>base.class.spec.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.base.class.spec_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>base.class.spec</code> only</p>
</td></tr>
<tr><td><code id="funs.base.class.spec_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>base.class.spec</code> only</p>
</td></tr>
<tr><td><code id="funs.base.class.spec_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>base.class.spec</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Type of the class-specific test, which is <code>"base"</code> for this function</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>vector</code> of base class-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>vector</code> of <code class="reqn">p</code>-values for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k-1</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT, i.e., matrix of the observed <code class="reqn">N_{ij}</code> values
which is the NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of 
the <code class="reqn">N_{ij}</code> values in the NNCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>base.class.spec.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>base.class.spec</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2009).
&ldquo;Class-Specific Tests of Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Statistica Neerlandica</em>, <b>63(2)</b>, 149-182.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NN.class.spec.ct">NN.class.spec.ct</a></code>, <code><a href="#topic+NN.class.spec">NN.class.spec</a></code>, <code><a href="#topic+class.spec.ct">class.spec.ct</a></code> 
and <code><a href="#topic+class.spec">class.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

base.class.spec(Y,cls)
base.class.spec.ct(ct,covN)
base.class.spec(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

base.class.spec(Y,fcls)
base.class.spec.ct(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

base.class.spec(Y,cls)
base.class.spec.ct(ct,covN)

</code></pre>

<hr>
<h2 id='funs.cell.spec.ss'>Pielou's Cell-specific Segregation Test with Normal Approximation (for Sparse Sampling)</h2><span id='topic+funs.cell.spec.ss'></span><span id='topic+cell.spec.ss.ct'></span><span id='topic+cell.spec.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>cell.spec.ss.ct</code> and <code>cell.spec.ss</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the 
cell counts (i.e., entries) in the NNCT for <code class="reqn">k \ge 2</code> classes.
Each test is appropriate (i.e., have the appropriate asymptotic sampling distribution)
when that data is obtained by sparse sampling.
</p>
<p>Each cell-specific segregation test is based on the normal approximation of the entries
in the NNCT and are due to Pielou (1961).
</p>
<p>Each function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values, lower and upper confidence levels, sample estimates (i.e., observed values)
and null value(s) (i.e., expected values) for the <code class="reqn">N_{ij}</code> values for <code class="reqn">i,j=1,2,\ldots,k</code> and also names of the test
statistics, estimates, null values, the description of the test, and the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=n_i c_j /n</code> where <code class="reqn">n_i</code> is the sum of row <code class="reqn">i</code> (i.e., size of class <code class="reqn">i</code>)
<code class="reqn">c_j</code> is the sum of column <code class="reqn">j</code> in the <code class="reqn">k \times k</code> NNCT for <code class="reqn">k \ge 2</code>.
In the output, the test statistic, <code class="reqn">p</code>-value and the lower and upper confidence limits are valid only 
for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Ceyhan (2010))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.spec.ss.ct(
  ct,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

cell.spec.ss(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.cell.spec.ss_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>cell.spec.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.cell.spec.ss_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funs.cell.spec.ss_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the entries, <code class="reqn">N_{ij}</code> in the NNCT</p>
</td></tr>
<tr><td><code id="funs.cell.spec.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>cell.spec.ss</code> only</p>
</td></tr>
<tr><td><code id="funs.cell.spec.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>cell.spec.ss</code> only</p>
</td></tr>
<tr><td><code id="funs.cell.spec.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>cell.spec.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">Z</code> test statistics for cell-specific tests</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels for the entries <code class="reqn">N_{ij}</code> in the NNCT 
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits (i.e., conf.level) of the NNCT entries.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., matrix of the NNCT entries of the <code class="reqn">k \times k</code> NNCT, Nij
for i,j=1,2,...,k.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected values of the NNCT entries, 
E(Nij) for i,j=1,2,...,k.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>cell.spec.ss.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>cell.spec.ss</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cell.spec.ct">cell.spec.ct</a></code> and <code><a href="#topic+cell.spec">cell.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

cell.spec.ss(Y,cls)
cell.spec.ss.ct(ct)
cell.spec.ss.ct(ct,alt="g")

cell.spec.ss(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

cell.spec.ss(Y,fcls)
cell.spec.ss.ct(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

cell.spec.ss(Y,cls,alt="l")
cell.spec.ss.ct(ct)
cell.spec.ss.ct(ct,alt="l")

</code></pre>

<hr>
<h2 id='funs.class.spec'>Class-specific Chi-square Tests based on NNCTs</h2><span id='topic+funs.class.spec'></span><span id='topic+class.spec.ct'></span><span id='topic+class.spec'></span>

<h3>Description</h3>

<p>Two functions: <code>class.spec.ct</code> and <code>class.spec</code>.
</p>
<p>Both functions are objects of class <code>"classhtest"</code> but with different arguments (see the parameter list below).
Each one performs class specific segregation tests for the rows if <code>type="base"</code> and 
columns if <code>type="NN"</code> for <code class="reqn">k \ge 2</code> classes.
That is,
each one performs hypothesis tests of deviations of 
entries in each row (column) of NNCT from the expected values under RL or CSR for each row (column)
if <code>type="base"</code> (<code>"NN"</code>). 
Recall that row labels of the NNCT are base class labels and
column labels in the NNCT are NN class labels.
The test for each row (column) <code class="reqn">i</code> is based on the chi-squared approximation of the corresponding quadratic form
and are due to Dixon (2002) 
(Ceyhan (2009)).
</p>
<p>The argument <code>covN</code> must be covariance of row-wise (column-wise) vectorization of NNCT if <code>type="base"</code>
(<code>type="NN"</code>).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> for each base class <code class="reqn">i</code>, description of the 
alternative with the corresponding null values (i.e., expected values) for the row (column) <code class="reqn">i</code>, estimates for the entries in 
row (column) <code class="reqn">i</code> for <code class="reqn">i=1,\ldots,k</code> if <code>type="base"</code> (<code>type="NN"</code>).
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis for each row (column) is that the corresponding <code class="reqn">N_{ij}</code> entries in row (column) <code class="reqn">i</code> are 
equal to their expected values under RL or CSR.
</p>
<p>See also (Dixon (2002); Ceyhan (2009))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class.spec.ct(ct, covN, type = "base")

class.spec(dat, lab, type = "base", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.class.spec_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>class.spec.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.class.spec_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>class.spec.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.class.spec_+3A_type">type</code></td>
<td>
<p>The type of the class-specific tests with default=<code>"base"</code>. 
Takes on values<code>"base"</code> for (Dixon's) base class-specific test
and<code>"NN"</code> for NN class-specific test.</p>
</td></tr>
<tr><td><code id="funs.class.spec_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>class.spec</code> only</p>
</td></tr>
<tr><td><code id="funs.class.spec_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>class.spec</code> only</p>
</td></tr>
<tr><td><code id="funs.class.spec_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>class.spec</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Type of the class-specific test, which is <code>"base"</code> or <code>"NN"</code> for this function</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>vector</code> of class-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>vector</code> of <code class="reqn">p</code>-values for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k-1</code> for base class-specific test
and <code class="reqn">k</code> for NN class-specific test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT, i.e., the matrix of the 
observed <code class="reqn">N_{ij}</code> values for base class-specific test and transpose of the NNCT for
the NN class-specific test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The <code>matrix</code> of hypothesized null values for the parameters which are expected values
of the <code class="reqn">N_{ij}</code> values for the base class-specific test and transpose of this
matrix for the NN-class specific test.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>class.spec.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>class.spec</code> only</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ceyhan E (2009).
&ldquo;Class-Specific Tests of Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Statistica Neerlandica</em>, <b>63(2)</b>, 149-182.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+base.class.spec.ct">base.class.spec.ct</a></code>, <code><a href="#topic+base.class.spec">base.class.spec</a></code>, <code><a href="#topic+NN.class.spec.ct">NN.class.spec.ct</a></code> 
and <code><a href="#topic+NN.class.spec">NN.class.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

class.spec(Y,cls)
class.spec(Y,cls,type="NN")

class.spec.ct(ct,covN)
class.spec.ct(ct,covN,type="NN")

class.spec(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

class.spec(Y,fcls)
class.spec(Y,fcls,type="NN")

class.spec.ct(ct,covN)
class.spec.ct(ct,covN,type="NN")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

class.spec(Y,cls)
class.spec(Y,cls,type="NN")

class.spec.ct(ct,covN)
class.spec.ct(ct,covN,type="NN")

</code></pre>

<hr>
<h2 id='funs.covNii'>Covariance Matrix of the Self Entries in a Species Correspondence Contingency Table (SCCT)</h2><span id='topic+funs.covNii'></span><span id='topic+covNii.ct'></span><span id='topic+covNii'></span>

<h3>Description</h3>

<p>Two functions: <code>covNii.ct</code> and <code>covNii</code>.
</p>
<p>Both functions return the covariance matrix of the self entries (i.e., first column entries) in a
species correspondence contingency table (SCCT)
but have different arguments (see the parameter list below).
The covariance matrix is of dimension <code class="reqn">k \times k</code> and its entries are <code class="reqn">cov(S_i,S_j)</code> where <code class="reqn">S_i</code> values are
the entries in the first column of SCCT (recall that <code class="reqn">S_i</code> equals diagonal entry <code class="reqn">N_{ii}</code> in the NNCT).
These covariances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>The argument <code>ct</code> which is used in <code>covNii.ct</code> only, can be either the NNCT or SCCT.
And the argument <code>Vsq</code> is the vector of variances of the diagonal entries <code class="reqn">N_{ii}</code> in the NNCT or the self entries
(i.e., the first column) in the SCCT.
</p>
<p>See also (Ceyhan (2018)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covNii.ct(ct, Vsq, Q, R)

covNii(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.covNii_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT, used in <code>covNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_vsq">Vsq</code></td>
<td>
<p>The <code>vector</code> of variances of the diagonal entries <code class="reqn">N_{ii}</code> in the NNCT or the self entries
(i.e., the first column) in the SCCT, used in <code>covNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_q">Q</code></td>
<td>
<p>The number of shared NNs, used in <code>covNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs (i.e., twice the number of reflexive NN pairs), used in <code>covNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>covNii</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>covNii</code> only</p>
</td></tr>
<tr><td><code id="funs.covNii_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>covNii</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length <code class="reqn">k</code> whose entries are the variances of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT).
</p>
<p>The <code class="reqn">k \times k</code> covariance matrix of cell counts <code class="reqn">S_i</code> in the self (i.e., first) column of the SCCT
or of the diagonal cell counts <code class="reqn">N_{ii}</code> for <code class="reqn">i=1,\ldots,k</code> in the NNCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scct">scct</a></code>, <code><a href="#topic+cov.nnct">cov.nnct</a></code>, <code><a href="#topic+cov.tct">cov.tct</a></code> and <code><a href="#topic+cov.nnsym">cov.nnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
covNii(Y,cls)
covNii.ct(ct,vsq,Qv,Rv)

covNii(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

covNii(Y,fcls)
covNii.ct(ct,vsq,Qv,Rv)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
covNii(Y,cls)
covNii.ct(ct,vsq,Qv,Rv)

</code></pre>

<hr>
<h2 id='funs.covtct'>Functions for Covariances of the Entries of the 
Types I, III and IV TCTs</h2><span id='topic+funs.covtct'></span><span id='topic+cov.tctI'></span><span id='topic+cov.tctIII'></span><span id='topic+cov.tct3'></span><span id='topic+cov.tctIV'></span>

<h3>Description</h3>

<p>Four functions: <code>cov.tctI</code>, <code>cov.tctIII</code>, <code>cov.tct3</code>,
and <code>cov.tctIV</code>.
</p>
<p>These functions return the covariances 
between entries in the TCT for the types I, III, and IV
cell-specific tests in matrix form 
which is of dimension <code class="reqn">k^2 \times k^2</code>.
The covariance matrix entries are <code class="reqn">cov(T_{ij},T_{kl})</code>
when <code class="reqn">T_{ij}</code> values are by default corresponding to 
the row-wise vectorization of TCT. 
The argument <code>CovN</code> must be the covariance 
between <code class="reqn">N_{ij}</code> values which are obtained from the NNCT by row-wise
vectorization.
The functions <code>cov.tctIII</code> and <code>cov.tct3</code> are equivalent.
These covariances are valid under RL or 
conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Ceyhan (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.tctI(ct, CovN)

cov.tctIII(ct, CovN)

cov.tct3(ct, CovN)

cov.tctIV(ct, CovN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.covtct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="funs.covtct_+3A_covn">CovN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of 
row-wise vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each of these functions returns 
a <code class="reqn">k^2 \times k^2</code> covariance matrix, 
whose entries are the covariances of
the entries in the TCTs for the corresponding 
type I-IV cell-specific test.
The row and column names are inherited from <code>ct</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.tct">cov.tct</a></code> and <code><a href="#topic+cov.nnct">cov.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cov.tctI(ct,covN)
cov.tctIII(ct,covN)
cov.tctIV(ct,covN)

</code></pre>

<hr>
<h2 id='funs.kNNdist'>Functions for the <code class="reqn">k^{th}</code> and <code>k</code> NN distances</h2><span id='topic+funs.kNNdist'></span><span id='topic+kthNNdist'></span><span id='topic+kNNdist'></span>

<h3>Description</h3>

<p>Two functions: <code>kthNNdist</code> and <code>kNNdist</code>.
</p>
<p><code>kthNNdist</code> returns the distances between subjects and their <code class="reqn">k^{th}</code> NNs. The output is an <code class="reqn">n \times 2</code> matrix where 
<code class="reqn">n</code> is the data size and first column is the subject index and second column contains the corresponding 
distances to <code class="reqn">k^{th}</code> NN subjects. 
</p>
<p><code>kNNdist</code> returns the distances between subjects and their <code>k</code> NNs.
The output is an <code class="reqn">n \times (k+1)</code> matrix where 
<code class="reqn">n</code> is the data size and first column is the subject index and the remaining <code>k</code> columns contain the corresponding 
distances to <code>k</code> NN subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kthNNdist(x, k, is.ipd = TRUE, ...)

kNNdist(x, k, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.kNNdist_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="funs.kNNdist_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subjects).</p>
</td></tr>
<tr><td><code id="funs.kNNdist_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix, otherwise, <code>x</code> is taken as the data set with rows representing the data points.</p>
</td></tr>
<tr><td><code id="funs.kNNdist_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kthNNdist</code> returns an <code class="reqn">n \times 2</code> matrix where <code class="reqn">n</code> is data size (i.e., number of subjects) and
first column is the subject index and second column is the <code class="reqn">k^{th}</code> NN distances.
</p>
<p><code>kNNdist</code> returns an <code class="reqn">n \times (k+1)</code> matrix where <code class="reqn">n</code> is data size (i.e., number of subjects) and
first column is the subject index and the remaining <code>k</code> columns contain the corresponding 
distances to <code>k</code> NN subjects.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NNdist">NNdist</a></code> and <code><a href="#topic+NNdist2cl">NNdist2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for kthNNdist
#3D data points, gives NAs when n&lt;=k
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
kthNNdist(ipd,3)
kthNNdist(Y,3,is.ipd = FALSE)
kthNNdist(ipd,5)
kthNNdist(Y,5,is.ipd = FALSE)
kthNNdist(Y,3,is.ipd = FALSE,method="max")

#1D data points
X&lt;-as.matrix(runif(5)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
kthNNdist(ipd,3)

#Examples for kNNdist
#3D data points, gives NAs if n&lt;=k for n,n+1,...,kNNs
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
kNNdist(ipd,3)
kNNdist(ipd,5)
kNNdist(Y,5,is.ipd = FALSE)

kNNdist(Y,5,is.ipd = FALSE,method="max")

kNNdist(ipd,1)
kthNNdist(ipd,1)

#1D data points
X&lt;-as.matrix(runif(5)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
kNNdist(ipd,3)

</code></pre>

<hr>
<h2 id='funs.kNNdist2cl'>Functions for the <code class="reqn">k^{th}</code> and <code>k</code> NN distances</h2><span id='topic+funs.kNNdist2cl'></span><span id='topic+kthNNdist2cl'></span><span id='topic+kNNdist2cl'></span>

<h3>Description</h3>

<p>Two functions: <code>kthNNdist2cl</code> and <code>kNNdist2cl</code>.
</p>
<p><code>kthNNdist2cl</code> returns the distances between subjects from 
class <code class="reqn">i</code> and their <code class="reqn">k^{th}</code> NNs from class <code class="reqn">j</code>.
The output is a <code>list</code> with first entry (<code>kth.nndist</code>) 
is an <code class="reqn">n_i \times 3</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>
and first column is the subject index for class <code class="reqn">i</code>,
second column is the index of the <code class="reqn">k^{th}</code> NN of 
class <code class="reqn">i</code> subjects among class <code class="reqn">j</code> subjects and third column 
contains the corresponding <code class="reqn">k^{th}</code> NN distances. 
The other entries in the <code>list</code> are labels of base class 
and NN class and the value of <code>k</code>, respectively.
</p>
<p><code>kNNdist2cl</code> returns the distances between subjects from class <code class="reqn">i</code> 
and their <code>k</code> NNs from class <code class="reqn">j</code>.
The output is a <code>list</code> with first entry (<code>ind.knndist</code>) is 
an <code class="reqn">n_i \times (k+1)</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>,
first column is the indices of class <code class="reqn">i</code> subjects, 
second to <code class="reqn">(k+1)</code>-st  columns are the indices of 
<code>k</code> NNs of class <code class="reqn">i</code> subjects among class <code class="reqn">j</code> subjects. 
The second <code>list</code> entry (<code>knndist</code>) is 
an <code class="reqn">n_i \times k</code> matrix where <code class="reqn">n_i</code> is the 
size of class <code class="reqn">i</code> and the columns are
the <code>k</code>NN distances of class <code class="reqn">i</code> subjects 
to class <code class="reqn">j</code> subjects. 
The other entries in the <code>list</code> are labels of base class 
and NN class and the value of <code>k</code>, respectively. 
</p>
<p>The argument <code>within.class.ind</code> is a logical argument 
(default=<code>FALSE</code>) to determine the indexing of 
the class <code class="reqn">i</code> subjects. 
If <code>TRUE</code>, index numbering of subjects is within the class, 
from 1 to class size (i.e., <code>1:n_i</code>), 
according to their order in the original data; otherwise, 
index numbering within class is just the indices
in the original data.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) 
to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, 
<code>x</code> is taken to be the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kthNNdist2cl(x, k, i, j, lab, within.class.ind = FALSE, is.ipd = TRUE, ...)

kNNdist2cl(x, k, i, j, lab, within.class.ind = FALSE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.kNNdist2cl_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subjects).</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_i">i</code>, <code id="funs.kNNdist2cl_+3A_j">j</code></td>
<td>
<p>class label of base class and NN classes, respectively.</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_within.class.ind">within.class.ind</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). 
If <code>TRUE</code>, index numbering of subjects is within the class, 
from 1 to class size (i.e., <code>1:n_i</code>), 
according to their order in the original data; 
otherwise, index numbering within class is just the indices
in the original data.</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix, otherwise, <code>x</code> is taken as the data set with rows 
representing the data points.</p>
</td></tr>
<tr><td><code id="funs.kNNdist2cl_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kthNNdist2cl</code> returns the <code>list</code> of elements
</p>
<table>
<tr><td><code>kth.nndist</code></td>
<td>
<p><code class="reqn">n_i \times 3</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>
and first column is the subject index for class <code class="reqn">i</code>, 
second column is the index of the <code>k</code>-th NN of class <code class="reqn">i</code> 
subjects among class <code class="reqn">j</code> subjects and third column contains 
the corresponding <code>k</code>-th NN distances,
, returned by <code>Zseg.ind.ct</code> only</p>
</td></tr> 
<tr><td><code>base.class</code></td>
<td>
<p>label of base class</p>
</td></tr> 
<tr><td><code>nn.class</code></td>
<td>
<p>label of NN class</p>
</td></tr> 
<tr><td><code>k</code></td>
<td>
<p>value of <code>k</code> in <code>k</code>NN</p>
</td></tr>
</table>
<p><code>kNNdist2cl</code> returns the <code>list</code> of elements
</p>
<table>
<tr><td><code>ind.knndist</code></td>
<td>
<p><code class="reqn">n_i \times (k+1)</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>, 
first column is the indices of class <code class="reqn">i</code>
subjects, 2nd to <code class="reqn">(k+1)</code>-st  columns are 
the indices of <code class="reqn">k</code> NNs of class <code class="reqn">i</code> subjects 
among class <code class="reqn">j</code> subjects.</p>
</td></tr>
<tr><td><code>knndist</code></td>
<td>
<p><code class="reqn">n_i \times k</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and 
the columns are the <code class="reqn">k</code>NN distances of class <code class="reqn">i</code>
subjects to class <code class="reqn">j</code> subjects.</p>
</td></tr>
<tr><td><code>base.class</code></td>
<td>
<p>label of base class</p>
</td></tr> 
<tr><td><code>nn.class</code></td>
<td>
<p>label of NN class</p>
</td></tr> 
<tr><td><code>k</code></td>
<td>
<p>value of <code>k</code> in <code>k</code>NN</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NNdist2cl">NNdist2cl</a></code>, <code><a href="#topic+kthNNdist">kthNNdist</a></code>,
and <code><a href="#topic+kNNdist">kNNdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for kthNNdist2cl
#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)
kthNNdist2cl(ipd,3,1,2,clab)
kthNNdist2cl(Y,3,1,2,clab,is.ipd = FALSE)
kthNNdist2cl(ipd,3,1,2,clab,within = TRUE)

#three class case
clab&lt;-sample(1:3,n,replace=TRUE) #class labels
table(clab)
kthNNdist2cl(ipd,3,2,3,clab)

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)
kthNNdist2cl(ipd,3,1,2,clab) # here kthNNdist2cl(ipd,3,1,12,clab) 
#gives an error message

kthNNdist2cl(ipd,3,"1",2,clab)

#Examples for kNNdist2cl
#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)
kNNdist2cl(ipd,3,1,2,clab)
kNNdist2cl(Y,3,1,2,clab,is.ipd = FALSE)

kNNdist2cl(ipd,3,1,2,clab,within = TRUE)

#three class case
clab&lt;-sample(1:3,n,replace=TRUE) #class labels
table(clab)
kNNdist2cl(ipd,3,1,2,clab)

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)

kNNdist2cl(ipd,3,1,2,clab)
kNNdist2cl(ipd,3,"1",2,clab) #here kNNdist2cl(ipd,3,"a",2,clab) 
#gives an error message

</code></pre>

<hr>
<h2 id='funs.overall.nnct'>Dixon's Overall Test of Segregation for NNCT</h2><span id='topic+funs.overall.nnct'></span><span id='topic+overall.nnct.ct'></span><span id='topic+overall.nnct'></span>

<h3>Description</h3>

<p>Two functions: <code>overall.nnct.ct</code> and <code>overall.nnct</code>.
</p>
<p>Both functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
cell counts from the expected values under RL or CSR for all cells (i.e., entries) combined in the NNCT.
That is, each test is Dixon's overall test of segregation based on NNCTs for <code class="reqn">k \ge 2</code> classes.
This overall test is based on the chi-squared approximation of the corresponding quadratic form
and are due to Dixon (1994, 2002).
Both functions exclude the last column of the NNCT (in fact any column will do and last column
is chosen without loss of generality), to avoid ill-conditioning of the covariance matrix (for its inversion
in the quadratic form).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of NNCT entries, sample estimates (i.e., observed values) of the entries in NNCT.
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">N_{ij}</code> entries are equal to their expected values under RL or CSR.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010, 2017))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.nnct.ct(ct, covN)

overall.nnct(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.overall.nnct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>overall.nnct.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.nnct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>overall.nnct.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.overall.nnct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>overall.nnct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.nnct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>overall.nnct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.nnct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>overall.nnct</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The overall chi-squared statistic</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT, i.e., matrix of the observed <code class="reqn">N_{ij}</code> values
which is the NNCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a longer description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of the
the <code class="reqn">N_{ij}</code> values in the NNCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>overall.nnct.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>overall.nnct</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overall.seg.ct">overall.seg.ct</a></code>, <code><a href="#topic+overall.seg">overall.seg</a></code>, <code><a href="#topic+overall.tct.ct">overall.tct.ct</a></code>
and <code><a href="#topic+overall.tct">overall.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

overall.nnct(Y,cls)
overall.nnct.ct(ct,covN)

overall.nnct(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

overall.nnct(Y,fcls)
overall.nnct.ct(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

overall.nnct(Y,cls)
overall.nnct.ct(ct,covN)

</code></pre>

<hr>
<h2 id='funs.overall.seg'>Overall Segregation Tests for NNCTs</h2><span id='topic+funs.overall.seg'></span><span id='topic+overall.seg.ct'></span><span id='topic+overall.seg'></span>

<h3>Description</h3>

<p>Two functions: <code>overall.seg.ct</code> and <code>overall.seg</code>.
</p>
<p>All functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
cell counts from the expected values under RL or CSR for all cells (i.e., entries) combined in the NNCT or TCT.
That is, each test is one of Dixon's or Types I-IV overall test of segregation based on NNCTs or TCTs
for <code class="reqn">k \ge 2</code> classes.
Each overall test is based on the chi-squared approximation of the corresponding quadratic form
and are due to Dixon (1994, 2002)
and to Ceyhan (2010, 2017), respectively.
All functions exclude some row and/or column of the TCT, to avoid ill-conditioning of the covariance matrix
of the NNCT (for its inversion in the quadratic form), see the relevant functions under See also section below.
</p>
<p>The <code>type="dixon"</code> or <code>"nnct"</code> refers to Dixon's overall test of segregation, and
<code>type="I"</code>-<code>"IV"</code> refers to types I-IV overall tests, respectively.
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)</code> for type II and Dixon's test 
and <code class="reqn">(k-1)^2</code> for the other types, description of the 
alternative with the corresponding null values (i.e., expected values) of TCT entries, sample estimates (i.e., observed values) of the entries in TCT.
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> entries for the specified type are equal to their expected values
under RL or CSR, respectively.
</p>
<p>See also
(Dixon (1994, 2002); Ceyhan (2010, 2010))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.seg.ct(ct, covN, type)

overall.seg(dat, lab, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.overall.seg_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>overall.seg.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.seg_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>overall.seg.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.overall.seg_+3A_type">type</code></td>
<td>
<p>The type of the overall test with no default.
Takes on values <code>"dixon"</code> or <code>"nnct"</code> for Dixon's overall test and <code>"I"</code>-<code>"IV"</code> for types I-IV cell-specific
test (or equivalently <code>1-6</code>, respectively).</p>
</td></tr>
<tr><td><code id="funs.overall.seg_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>overall.seg</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.seg_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>overall.seg</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.seg_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>overall.seg</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The overall chi-squared statistic for the specified type</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)</code> for type II and Dixon's tests
and <code class="reqn">(k-1)^2</code> for others.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT for Dixon's test and type I-IV TCT for others.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a longer description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of the
the <code class="reqn">N_{ij}</code> values in the NNCT or <code class="reqn">T_{ij}</code> values in the TCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>overall.seg.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>overall.seg</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.<br /><br /> Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overall.nnct.ct">overall.nnct.ct</a></code>, <code><a href="#topic+overall.nnct">overall.nnct</a></code>, <code><a href="#topic+overall.tct.ct">overall.tct.ct</a></code>
and <code><a href="#topic+overall.tct">overall.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

type&lt;-"dixon" #try also "nnct", I", "II", "III", and "IV"
overall.seg(Y,cls,type)
overall.seg(Y,cls,type,method="max")
overall.seg(Y,cls,type="I")

overall.seg.ct(ct,covN,type)
overall.seg.ct(ct,covN,type="I")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

overall.seg(Y,fcls,type="I")
overall.seg.ct(ct,covN,type)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

overall.seg(Y,cls,type="I")
overall.seg.ct(ct,covN,type)

</code></pre>

<hr>
<h2 id='funs.overall.tct'>Types I-IV Overall Tests of Segregation for NNCT</h2><span id='topic+funs.overall.tct'></span><span id='topic+overall.tct.ct'></span><span id='topic+overall.tct'></span>

<h3>Description</h3>

<p>Two functions: <code>overall.tct.ct</code> and <code>overall.tct</code>.
</p>
<p>All functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
cell counts from the expected values under RL or CSR for all cells (i.e., entries) combined in the TCT.
That is, each test is one of Types I-IV overall test of segregation based on TCTs for <code class="reqn">k \ge 2</code> classes.
This overall test is based on the chi-squared approximation of the corresponding quadratic form
and are due to Ceyhan (2010, 2017).
Both functions exclude some row and/or column of the TCT, to avoid ill-conditioning of the covariance matrix
of the NNCT (for its inversion in the quadratic form).
In particular, type-II removes the last column, and all other types remove the last row and column.
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)</code> for type II test and <code class="reqn">(k-1)^2</code> 
for the other types, description of the 
alternative with the corresponding null values (i.e., expected values) of TCT entries, sample estimates (i.e., observed values) of the entries in TCT.
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all Tij entries for the specified type are equal to their expected values
under RL or CSR.
</p>
<p>See also 
(Ceyhan (2010, 2017))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall.tct.ct(ct, covN, type = "III")

overall.tct(dat, lab, type = "III", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.overall.tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>overall.tct.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.tct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>overall.tct.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.overall.tct_+3A_type">type</code></td>
<td>
<p>The type of the overall segregation test, default=<code>"III"</code>.
Takes on values <code>"I"</code>-<code>"IV"</code> (or equivalently <code>1-4</code>, respectively.</p>
</td></tr>
<tr><td><code id="funs.overall.tct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>overall.tct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.tct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>overall.tct</code> only</p>
</td></tr>
<tr><td><code id="funs.overall.tct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>overall.tct</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The overall chi-squared statistic for the specified type</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)</code> for type=<code>"II"</code> and <code class="reqn">(k-1)^2</code> for others.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, TCT, i.e., matrix of the observed <code class="reqn">T_{ij}</code> values
which is the TCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a longer description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of the
the <code class="reqn">T_{ij}</code> values in the TCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>overall.tct.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>overall.tct</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overall.seg.ct">overall.seg.ct</a></code>, <code><a href="#topic+overall.seg">overall.seg</a></code>, <code><a href="#topic+overall.nnct.ct">overall.nnct.ct</a></code>
and <code><a href="#topic+overall.nnct">overall.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

overall.tct(Y,cls)
overall.tct(Y,cls,type="I")
overall.tct(Y,cls,type="II")
overall.tct(Y,cls,type="III")
overall.tct(Y,cls,type="IV")

overall.tct(Y,cls,method="max")

overall.tct.ct(ct,covN)
overall.tct.ct(ct,covN,type="I")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

overall.tct(Y,fcls)
overall.tct.ct(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

overall.tct(Y,cls)
overall.tct.ct(ct,covN)

</code></pre>

<hr>
<h2 id='funs.pijPij'>The functions for probability of selecting a number of points 
from respective classes</h2><span id='topic+funs.pijPij'></span><span id='topic+p11'></span><span id='topic+P11'></span><span id='topic+p12'></span><span id='topic+P12'></span><span id='topic+p111'></span><span id='topic+P111'></span><span id='topic+p1111'></span><span id='topic+P1111'></span><span id='topic+p112'></span><span id='topic+P112'></span><span id='topic+p122'></span><span id='topic+p123'></span><span id='topic+P123'></span><span id='topic+p1234'></span><span id='topic+P1234'></span><span id='topic+p1223'></span><span id='topic+p1123'></span><span id='topic+P1123'></span><span id='topic+p1122'></span><span id='topic+P1122'></span><span id='topic+p1112'></span><span id='topic+P1112'></span>

<h3>Description</h3>

<p>The ancillary probability functions used in computation of
the variance-covariance matrices
of various NN spatial tests such as NNCT tests and 
tests based on other contingency tables.
These functions can be classified as <code>pij</code> 
and <code>Pij</code> type functions. 
The <code>pij</code> functions are for individual 
probabilities and the corresponding <code>Pij</code> functions are 
the summed <code>pij</code> values.
For example <code class="reqn">p_{iijk}</code>
is the probability of any 4 points with 2 from class <code class="reqn">i</code>, 
and others are from classes <code class="reqn">j</code> and <code class="reqn">k</code>. 
These probabilities are for data from RL or CSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p11(k, n)

P11(nvec)

p12(k, l, n)

P12(nvec)

p111(k, n)

P111(nvec)

p1111(k, n)

P1111(nvec)

p112(k, l, n)

P112(nvec)

p122(k, l, n)

p123(k, l, m, n)

P123(nvec)

p1234(k, l, m, p, n)

P1234(nvec)

p1223(k, l, m, n)

p1123(k, l, m, n)

P1123(nvec)

p1122(k, l, n)

P1122(nvec)

p1112(k, l, n)

P1112(nvec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.pijPij_+3A_k">k</code>, <code id="funs.pijPij_+3A_l">l</code>, <code id="funs.pijPij_+3A_m">m</code>, <code id="funs.pijPij_+3A_p">p</code></td>
<td>
<p>Positive integers, usually representing the class sizes, 
used in <code>pij</code> type functions only.
Number of these arguments required depends on the number of 
distinct indices of <code class="reqn">p</code>, e.g. <code class="reqn">p_{ij}</code> requires
<code>k,l,n</code> and <code class="reqn">p_{iijk}</code> requires <code>k,l,m,n</code> as input.</p>
</td></tr>
<tr><td><code id="funs.pijPij_+3A_n">n</code></td>
<td>
<p>A positive integer representing the size of the data set 
(i.e., number of observations in the data
set).</p>
</td></tr>
<tr><td><code id="funs.pijPij_+3A_nvec">nvec</code></td>
<td>
<p>A <code>vector</code> of positive integers representing 
the sizes of classes in the data set, used in 
<code>Pij</code> type functions only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Probability values for the selected points being 
from the indicated classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pk">pk</a></code>
</p>

<hr>
<h2 id='funs.scct'>Species Correspondence Contingency Table (SCCT)</h2><span id='topic+funs.scct'></span><span id='topic+scct.ct'></span><span id='topic+scct'></span>

<h3>Description</h3>

<p>Two functions: <code>scct.ct</code> and <code>scct</code>.
</p>
<p>Both functions return the <code class="reqn">k \times 2</code> species correspondence contingency table (SCCT) 
but have different arguments (see the parameter list below).
</p>
<p>SCCT is constructed by categorizing the NN pairs according to pair type as self or mixed. 
A base-NN pair is called a self pair, if the elements of the pair are from the same class;
a mixed pair, if the elements of the pair are from different classes.
Row labels in the RCT are the class labels and the column labels are <code>"self"</code> and <code>"mixed"</code>.
The <code class="reqn">k \times 2</code> SCCT (whose first column is self column with entries <code class="reqn">S_i</code> and second column is mixed with entries <code class="reqn">M_i</code>)
is closely related to the <code class="reqn">k \times k</code> nearest neighbor contingency table (NNCT) whose entries are <code class="reqn">N_{ij}</code>,
where <code class="reqn">S_i=N_{ii}</code> and <code class="reqn">M_i=n_i-N_{ii}</code> with <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>.
</p>
<p>The function <code>scct.ct</code> returns the SCCT given the inter-point distance (IPD) matrix or data set <code>x</code>,
and the  function <code>scct</code> returns the SCCT given the IPD matrix. SCCT is a <code class="reqn">k \times 2</code> matrix where <code class="reqn">k</code> is 
number of classes in the data set.
(See Ceyhan (2018) for more detail,
where SCCT is labeled as CCT for correspondence contingency table).
</p>
<p>The argument <code>ties</code> is a logical argument (default=<code>FALSE</code> for both functions) to take ties into account or not.
If <code>TRUE</code> a NN contributes <code class="reqn">1/m</code> to the NN count if it is one of the <code class="reqn">m</code> tied NNs of a subject.
</p>
<p>The argument nnct is a logical argument for <code>scct.ct</code> only (default=<code>FALSE</code>) to determine the structure of the
argument <code>x</code>. If <code>TRUE</code>, <code>x</code> is taken to be the <code class="reqn">k \times k</code> NNCT, and if <code>FALSE</code>, <code>x</code> is taken to be the IPD matrix.
</p>
<p>The argument lab is the <code>vector</code> of class labels (default=<code>NULL</code> when <code>nnct=TRUE</code> in the function <code>scct.ct</code> and no default
specified for scct).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scct.ct(x, lab = NULL, ties = FALSE, nnct = FALSE)

scct(dat, lab, ties = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.scct_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>nnct=FALSE</code>) or the NNCT (if <code>nnct=TRUE</code>), used in <code>scct.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.scct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), default=<code>NULL</code> when <code>nnct=FALSE</code> in the function <code>scct.ct</code> and no default
specified for scct.</p>
</td></tr>
<tr><td><code id="funs.scct_+3A_ties">ties</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>) to take ties into account or not. If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count if it is one of the <code class="reqn">m</code> tied NNs of a subject.</p>
</td></tr>
<tr><td><code id="funs.scct_+3A_nnct">nnct</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). If <code>TRUE</code>, <code>x</code> is taken to be the <code class="reqn">k \times k</code> NNCT, 
and if <code>FALSE</code>, <code>x</code> is taken to be the IPD matrix, used in <code>scct.ct</code> only.</p>
</td></tr>
<tr><td><code id="funs.scct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>scct</code> only</p>
</td></tr>
<tr><td><code id="funs.scct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>scct</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">k \times 2</code> SCCT where <code class="reqn">k</code> is the number of classes in the data set.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct">nnct</a></code>, <code><a href="#topic+tct">tct</a></code>, <code><a href="#topic+rct">rct</a></code> and <code><a href="#topic+Qsym.ct">Qsym.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
NNCT&lt;-nnct(ipd,cls)
NNCT

scct(Y,cls)
scct(Y,cls,method="max")

scct.ct(ipd,cls)
scct.ct(ipd,cls,ties = TRUE)
scct.ct(NNCT,nnct=TRUE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
scct.ct(ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
NNCT&lt;-nnct(ipd,cls)
NNCT

scct(Y,cls)

scct.ct(ipd,cls)
scct.ct(NNCT,nnct=TRUE)

</code></pre>

<hr>
<h2 id='funs.seg.coeff'>Pielou's Segregation Coefficients for NNCTs</h2><span id='topic+funs.seg.coeff'></span><span id='topic+Pseg.coeff'></span><span id='topic+seg.coeff'></span>

<h3>Description</h3>

<p>Two functions: <code>Pseg.coeff</code> and <code>seg.coeff</code>.
</p>
<p>Each function computes segregation coefficients based on NNCTs.
The function <code>Pseg.coeff</code> computes Pielou's segregation coefficient (Pielou (1961))
for the two-class case (i.e., based on <code class="reqn">2 \times 2</code> NNCTs)
and <code>seg.coeff</code> is the extension of <code>Pseg.coeff</code> to the multi-class case (i.e., for <code class="reqn">k \times k</code> NNCTs with <code class="reqn">k \ge 2</code>)
and provides a <code class="reqn">k \times k</code> matrix of segregation coefficients
(Ceyhan (2014)).
Both functions use the same argument, <code>ct</code>, for NNCT.
</p>
<p>Pielou's segregation coefficient (for two classes) is <code class="reqn">S_P = 1-(N_{12} + N_{21})/(E[N_{12}] + E[N_{21}])</code>
and the extended segregation coefficents (for <code class="reqn">k \ge 2</code> classes) are 
<code class="reqn">S_c = 1 -(N_{ii})/(E[N_{ii}])</code> for the diagonal cells in the NNCT
and
<code class="reqn">S_c = 1 -(N_{ij} + N_{ji})/(E[N_{ij}] + E[N_{ji}])</code> for the off-diagonal cells in the NNCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pseg.coeff(ct)

seg.coeff(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.seg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in both functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Pseg.coeff</code> returns Pielou's segregation coefficient for <code class="reqn">2 \times 2</code> NNCT
<code>seg.coeff</code> returns a <code class="reqn">k \times k</code> matrix of segregation coefficients (which are extended versions
of Pielou's segregation coefficient)
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.ind">seg.ind</a></code>, <code><a href="#topic+Zseg.coeff.ct">Zseg.coeff.ct</a></code> and <code><a href="#topic+Zseg.coeff">Zseg.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for Pseg.coeff
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct
Pseg.coeff(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Pseg.coeff(ct)

#############
ct&lt;-matrix(sample(1:25,9),ncol=3)
#Pseg.coeff(ct)

#Examples for seg.coeff
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct
seg.coeff(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

seg.coeff(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-nnct(ipd,cls)

seg.coeff(ct)

</code></pre>

<hr>
<h2 id='funs.varNii'>Variances of the Self Entries in a Species Correspondence Contingency Table (SCCT)</h2><span id='topic+funs.varNii'></span><span id='topic+varNii.ct'></span><span id='topic+varNii'></span>

<h3>Description</h3>

<p>Two functions: <code>varNii.ct</code> and <code>varNii</code>.
</p>
<p>Both functions return a <code>vector</code> of length <code class="reqn">k</code> of variances of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the variances of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT,
but have different arguments (see the parameter list below).
These variances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>The argument <code>ct</code> which is used in <code>varNii.ct</code> only, can be either the NNCT or SCCT.
</p>
<p>See also (Ceyhan (2018)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varNii.ct(ct, Q, R)

varNii(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.varNii_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT, used in <code>varNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.varNii_+3A_q">Q</code></td>
<td>
<p>The number of shared NNs, used in <code>varNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.varNii_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs (i.e., twice the number of reflexive NN pairs), used in <code>varNii.ct</code> only</p>
</td></tr>
<tr><td><code id="funs.varNii_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>varNii</code> only</p>
</td></tr>
<tr><td><code id="funs.varNii_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>varNii</code> only</p>
</td></tr>
<tr><td><code id="funs.varNii_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>varNii</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length <code class="reqn">k</code> whose entries are the variances of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or of the diagonal entries in an NNCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scct">scct</a></code>, <code><a href="#topic+var.nnct">var.nnct</a></code>, <code><a href="#topic+var.tct">var.tct</a></code>, <code><a href="#topic+var.nnsym">var.nnsym</a></code>
and <code><a href="#topic+covNii">covNii</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

varNii(Y,cls)
varNii.ct(ct,Qv,Rv)

varNii(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

varNii(Y,fcls)
varNii.ct(ct,Qv,Rv)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

varNii(Y,cls)
varNii.ct(ct,Qv,Rv)

</code></pre>

<hr>
<h2 id='funs.vartct'>Functions for Variances of Cell Counts 
in the Types I, III and IV TCTs</h2><span id='topic+funs.vartct'></span><span id='topic+var.tctI'></span><span id='topic+var.tctIII'></span><span id='topic+var.tctIV'></span>

<h3>Description</h3>

<p>Three functions: <code>var.tctI</code>, <code>var.tctIII</code>, and <code>var.tctIV</code>.
</p>
<p>These functions return the variances of <code class="reqn">T_{ij}</code> values 
for <code class="reqn">i,j=1,\ldots,k</code> in the TCT in matrix form which
is of the same dimension as TCT for types I, III and IV tests. 
The argument <code>covN</code> must be the covariance 
between <code class="reqn">N_{ij}</code> values which are obtained 
from the NNCT by row-wise vectorization.
These variances are valid under RL or 
conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Ceyhan (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.tctI(ct, covN)

var.tctIII(ct, covN)

var.tctIV(ct, covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funs.vartct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="funs.vartct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of 
row-wise vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each of these functions returns a <code>matrix</code> of 
same dimension as, <code>ct</code>, whose entries are the variances of
the entries in the TCT for the corresponding type of cell-specific test.
The row and column names are inherited from <code>ct</code>.
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.tct">var.tct</a></code> and <code><a href="#topic+var.nnct">var.nnct</a></code>
</p>

<hr>
<h2 id='funsAijmat'>Aij matrices for computation of Moments of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+funsAijmat'></span><span id='topic+aij.mat'></span><span id='topic+aij.nonzero'></span>

<h3>Description</h3>

<p>Two functions: <code>aij.mat</code> and <code>aij.nonzero</code>.
</p>
<p>The function <code>aij.mat</code> yields the <code class="reqn">A=(a_{ij}(k))</code> matrix where <code class="reqn">a_{ij}(k) = 1</code> if <code class="reqn">z_j</code> is among the <code>k</code>NNs of <code class="reqn">z_i</code>
and 0 otherwise due to Tango (2007).
This matrix is useful in calculation of the moments of Cuzick-Edwards <code class="reqn">T_k</code> tests.
</p>
<p>The function <code>aij.nonzero</code> keeps only nonzero entries, i.e., row and column entries where 
in each row, for the entry <code class="reqn">(r_1,c_1)</code> <code class="reqn">r_1</code> is the row entry and <code class="reqn">c_1</code> is the column entry. Rows are from
1 to n, which stands for the data point or observation, and column entries are from 1 to <code>k</code>, where <code>k</code> is specifying
the number of <code>k</code>NNs (of each observation) considered. This function saves in storage memory, but needs to be
carefully unfolded in the functions to represent the actual the <code class="reqn">A</code> matrix.
</p>
<p>See also (Tango (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aij.mat(dat, k, ...)

aij.nonzero(dat, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsAijmat_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="funsAijmat_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>), default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="funsAijmat_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>aij.mat</code> returns the <code class="reqn">A_{ij}</code> matrix for computation of moments of Cuzick and Edwards <code class="reqn">T_k</code>
Test statistic while the function <code>aij.nonzero</code> returns the (locations of the) non-zero entries in the <code class="reqn">A_{ij}</code>
matrix
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aij.theta">aij.theta</a></code> and <code><a href="#topic+EV.Tkaij">EV.Tkaij</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
k&lt;-3 #try also 2,3

Aij&lt;-aij.mat(Y,k)
Aij
Aij2&lt;-aij.mat(Y,k,method="max")
range(Aij,Aij2)

apply(Aij,2,sum) #row sums of Aij

aij.nonzero(Y,k)
aij.nonzero(Y,k,method="max")

</code></pre>

<hr>
<h2 id='funsC_MI_II'>Correction Matrices for the Covariance Matrix of NNCT entries</h2><span id='topic+funsC_MI_II'></span><span id='topic+correct.cf1'></span><span id='topic+correct.cf2'></span>

<h3>Description</h3>

<p>Two functions: <code>correct.cf1</code> and <code>correct.cf1</code>.
</p>
<p>Each function yields matrices which are used in obtaining covariance matrices of <code class="reqn">T_{ij}</code> values for 
types I and II tests from the usual Chi-Square test of contingency tables (i.e., Pielou's test) applied
on NNCTs.
The output matrices are to be term-by-term multiplied with the covariance matrix of 
the entries of NNCT. See Sections 3.1 and 3.2 in 
(Ceyhan (2010))
or
Sections 3.5.1 and 3.5.2 in 
(Ceyhan (2008)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct.cf1(ct)

correct.cf2(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsC_MI_II_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a correction matrix which is to be multiplied with the covariance matrix of
entries of the NNCT so as to obtain types I and II overall tests from Pielou's test of segregation.
See the description above for further detail.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2008).
&ldquo;New Tests for Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<a href="https://arxiv.org/abs/0808.1409v3">https://arxiv.org/abs/0808.1409v3</a> [stat.ME].
Technical Report # KU-EC-08-6, Koç University, Istanbul, Turkey.<br /><br /> Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct.cr1">nnct.cr1</a></code> and <code><a href="#topic+nnct.cr2">nnct.cr2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

#correction type 1
CM1&lt;-correct.cf1(ct)
CovN.cf1&lt;-covN*CM1

#correction type 2
CM2&lt;-correct.cf2(ct)
CovN.cf2&lt;-covN*CM2

covN
CovN.cf1
CovN.cf2

</code></pre>

<hr>
<h2 id='funsExpTk'>Expected Value for Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+funsExpTk'></span><span id='topic+EV.Tk'></span><span id='topic+EV.Tkaij'></span>

<h3>Description</h3>

<p>Two functions: <code>EV.Tk</code> and <code>EV.Tkaij</code>.
</p>
<p>Both functions compute the expected value of Cuzick and Edwards <code class="reqn">T_k</code> test statistic based on the number of cases 
within <code>k</code>NNs of the cases in the data under RL or CSR independence.
</p>
<p>The number of cases are denoted as <code class="reqn">n_1</code> (denoted as <code>n1</code> as an argument)
for both functions and number of controls as <code class="reqn">n_0</code> (denoted as <code>n0</code> as an argument) in <code>EV.Tk</code>,
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The function <code>EV.Tkaij</code> uses Toshiro Tango's moments formulas based on the <code class="reqn">A=(a_{ij})</code> matrix
(and is equivalent to the function <code>EV.Tk</code>, see Tango (2007),
where <code class="reqn">a_{ij}(k) = 1</code> if <code class="reqn">z_j</code> is among the <code>k</code>NNs of <code class="reqn">z_i</code> and 0 otherwise.
</p>
<p>See also (Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.Tk(k, n1, n0)

EV.Tkaij(k, n1, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsExpTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>).</p>
</td></tr>
<tr><td><code id="funsExpTk_+3A_n1">n1</code>, <code id="funsExpTk_+3A_n0">n0</code></td>
<td>
<p>The number of cases and controls, <code class="reqn">n_1</code> used for both functions, and <code class="reqn">n_0</code> used in <code>EV.Tk</code> only.</p>
</td></tr>
<tr><td><code id="funsExpTk_+3A_a">a</code></td>
<td>
<p>The <code class="reqn">A=(a_{ij})</code> matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of Cuzick and Edwards <code class="reqn">T_k</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.<br /><br /> Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code> and <code><a href="#topic+EV.Tcomb">EV.Tcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20
n0&lt;-25
k&lt;-1 #try also 3, 5, sample(1:5,1)

EV.Tk(k,n1,n0)

###
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)
n1&lt;-sum(cls==1)
n0&lt;-sum(cls==0)
a&lt;-aij.mat(Y,k)

EV.Tk(k,n1,n0)
EV.Tkaij(k,n1,a)

</code></pre>

<hr>
<h2 id='funsExpTrun'>Expected Value for Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</h2><span id='topic+funsExpTrun'></span><span id='topic+EV.Trun'></span><span id='topic+EV.Trun.alt'></span>

<h3>Description</h3>

<p>Two functions: <code>EV.Trun</code> and <code>EV.Trun.alt</code>.
</p>
<p>Both functions compute the expected value of Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic based on the number of 
consecutive cases from the cases in the data under RL or CSR independence.
</p>
<p>The number of cases are denoted as <code class="reqn">n_1</code> (denoted as <code>n1</code> as an argument)
and number of controls as <code class="reqn">n_0</code> for both functions (denoted as <code>n0</code> as an argument),
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The function <code>EV.Trun.alt</code> uses a loop and takes slightly longer than the function <code>EV.Trun</code>,
hence <code>EV.Trun</code> is used in other functions. 
</p>
<p>See also (Cuzick and Edwards (1990)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EV.Trun(n1, n0)

EV.Trun.alt(n1, n0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsExpTrun_+3A_n1">n1</code>, <code id="funsExpTrun_+3A_n0">n0</code></td>
<td>
<p>The number of cases and controls used as arguments for both functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTrun">ceTrun</a></code> and <code><a href="#topic+EV.Tk">EV.Tk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20
n0&lt;-25

EV.Trun(n1,n0)

</code></pre>

<hr>
<h2 id='funsN_I_II'>Correction Matrices for the NNCT entries</h2><span id='topic+funsN_I_II'></span><span id='topic+nnct.cr1'></span><span id='topic+nnct.cr2'></span>

<h3>Description</h3>

<p>Two functions: <code>nnct.cr1</code> and <code>nnct.cr1</code>.
</p>
<p>Each function yields matrices which are used in obtaining the correction term to be added to 
the usual Chi-Square test of contingency tables (i.e., Pielou's test) applied
on NNCTs to obtain types I and II overall tests.
The output contingency tables are to be row-wise vectorized to obtain <code class="reqn">N_I</code> and <code class="reqn">N_{II}</code> vectors. 
See Sections 3.1 and 3.2 in 
(Ceyhan (2010))
or
Sections 3.5.1 and 3.5.2 in 
(Ceyhan (2008)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnct.cr1(ct)

nnct.cr2(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsN_I_II_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a <code class="reqn">k \times k</code> contingency table which is to be row-wise vectorized to obtain <code class="reqn">N_I</code> and <code class="reqn">N_{II}</code>
vectors which are used in the correction summands to obtain types I and II overall tests from Pielou's 
test of segregation.
See the description above for further detail.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2008).
&ldquo;New Tests for Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<a href="https://arxiv.org/abs/0808.1409v3">https://arxiv.org/abs/0808.1409v3</a> [stat.ME].
Technical Report # KU-EC-08-6, Koç University, Istanbul, Turkey.<br /><br /> Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correct.cf1">correct.cf1</a></code> and <code><a href="#topic+correct.cf2">correct.cf2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

#correction type 1
ct1&lt;-nnct.cr1(ct)

#correction type 2
ct2&lt;-nnct.cr2(ct)

ct
ct1
ct2

</code></pre>

<hr>
<h2 id='funsNNclass.spec'>NN Class-specific Chi-square Tests based on NNCTs</h2><span id='topic+funsNNclass.spec'></span><span id='topic+NN.class.spec.ct'></span><span id='topic+NN.class.spec'></span>

<h3>Description</h3>

<p>Two functions: <code>NN.class.spec.ct</code> and <code>NN.class.spec</code>.
</p>
<p>Both functions are objects of class <code>"classhtest"</code> but with different arguments (see the parameter list below).
Each one performs class specific segregation tests for the columns, i.e., NN categories for <code class="reqn">k \ge 2</code> classes.
That is,
each one performs hypothesis tests of deviations of 
entries in each column of NNCT from the expected values under RL or CSR for each column. 
Recall that column labels in the NNCT are NN class labels.
The test for each column <code class="reqn">i</code> is based on the chi-squared approximation of the corresponding quadratic form
and are due to Ceyhan (2009).
</p>
<p>The argument <code>covN</code> must be covariance of column-wise vectorization of NNCT if the logical argument <code>byrow=FALSE</code>
otherwise the function converts <code>covN</code> (which is done row-wise) to columnwise version with <code><a href="#topic+covNrow2col">covNrow2col</a></code>
function.
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> for each base class <code class="reqn">i</code>, description of the 
alternative with the corresponding null values (i.e., expected values) for the column <code class="reqn">i</code>, estimates for the entries in column <code class="reqn">i</code>
for <code class="reqn">i=1,\ldots,k</code>. The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis for each column is that the corresponding <code class="reqn">N_{ij}</code> entries in column <code class="reqn">i</code> are equal to their 
expected values under RL or CSR.
</p>
<p>See also (Dixon (2002); Ceyhan (2009))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NN.class.spec.ct(ct, covN, byrow = TRUE)

NN.class.spec(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsNNclass.spec_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>NN.class.spec.ct</code> only</p>
</td></tr>
<tr><td><code id="funsNNclass.spec_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of column-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>NN.class.spec.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsNNclass.spec_+3A_byrow">byrow</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). If <code>TRUE</code>, rows of <code>ct</code> are appended to obtain the vector
of <code class="reqn">N_{ij}</code> values and <code>covN</code> is the covariance matrix for this vector and if <code>FALSE</code> columns of <code>ct</code> are appended 
to obtain the <code class="reqn">N_{ij}</code> vector and <code>covN</code> is converted to the row-wise version by covNrow2col function;used in <code>NN.class.spec.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsNNclass.spec_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>NN.class.spec</code> only</p>
</td></tr>
<tr><td><code id="funsNNclass.spec_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>NN.class.spec</code> only</p>
</td></tr>
<tr><td><code id="funsNNclass.spec_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>NN.class.spec</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>Type of the class-specific test, which is <code>"NN"</code> for this function</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>vector</code> of NN class-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>vector</code> of <code class="reqn">p</code>-values for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, transpose of the NNCT, i.e., transpose of the matrix of the 
observed <code class="reqn">N_{ij}</code> values which is the transpose of NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Transpose of the matrix of hypothesized null values for the parameters which are expected
values of the <code class="reqn">N_{ij}</code> values in the NNCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>NN.class.spec.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>NN.class.spec</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2009).
&ldquo;Class-Specific Tests of Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Statistica Neerlandica</em>, <b>63(2)</b>, 149-182.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+base.class.spec.ct">base.class.spec.ct</a></code>, <code><a href="#topic+base.class.spec">base.class.spec</a></code>, <code><a href="#topic+class.spec.ct">class.spec.ct</a></code> 
and <code><a href="#topic+class.spec">class.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covNrow&lt;-cov.nnct(ct,varN,Qv,Rv)
covNcol&lt;-covNrow2col(covNrow)

NN.class.spec(Y,cls)
NN.class.spec(Y,cls,method="max")

NN.class.spec.ct(ct,covNrow)
NN.class.spec.ct(ct,covNcol,byrow = FALSE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

NN.class.spec(Y,fcls)
NN.class.spec.ct(ct,covNrow)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covNrow&lt;-cov.nnct(ct,varN,Qv,Rv)
covNcol&lt;-covNrow2col(covNrow)

NN.class.spec(Y,cls)

NN.class.spec.ct(ct,covNrow)
NN.class.spec.ct(ct,covNcol,byrow = FALSE)

</code></pre>

<hr>
<h2 id='funsOnevsRest'>Functions for one versus rest type labeling</h2><span id='topic+funsOnevsRest'></span><span id='topic+lab.onevsrest'></span><span id='topic+classirest'></span>

<h3>Description</h3>

<p>Two functions: <code>lab.onevsrest</code> and <code>classirest</code>.
</p>
<p>Both functions relabel the points, 
keeping class <code class="reqn">i</code> label as is and 
relabeling the other classes as &quot;rest&quot;.
Used in the one-vs-rest type comparisons after 
the overall segregation test is found to be significant.
</p>
<p>See also (Ceyhan (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lab.onevsrest(i, lab)

classirest(i, lab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsOnevsRest_+3A_i">i</code></td>
<td>
<p>label of the class that is to be retained in the post-hoc comparison.</p>
</td></tr>
<tr><td><code id="funsOnevsRest_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return the data relabeled 
as class <code class="reqn">i</code> label is retained and the remaining is
relabeled as &quot;rest&quot;.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairwise.lab">pairwise.lab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
lab.onevsrest(1,cls)
classirest(2,cls)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
lab.onevsrest("a",fcls)
lab.onevsrest("b",fcls)
classirest("b",fcls)

#cls as a factor
fcls&lt;-rep(letters[1:4],rep(10,4))
lab.onevsrest("b",fcls)
classirest("b",fcls)

</code></pre>

<hr>
<h2 id='funsPseg.ss'>Pielou's Overall Test of Segregation for NNCT (for Sparse Sampling)</h2><span id='topic+funsPseg.ss'></span><span id='topic+Pseg.ss.ct'></span><span id='topic+Pseg.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>Pseg.ss.ct</code> and <code>Pseg.ss</code>.
</p>
<p>Both functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
cell counts from the expected values under independence for all cells (i.e., entries) combined in the NNCT.
That is, each test is Pielou's overall test of segregation based on NNCTs for <code class="reqn">k \ge 2</code> classes.
This overall test is based on the chi-squared approximation,
is equivalent to Pearson's chi-squared test on NNCT and
is due to Pielou (1961).
Each test is appropriate (i.e., have the appropriate asymptotic sampling distribution)
when that data is obtained by sparse sampling.
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">(k-1)^2</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of NNCT entries,
sample estimates (i.e., observed values) of the entries in NNCT.
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{ij})=n_i c_j /n</code> for all entries in the NNCT
where <code class="reqn">n_i</code> is the sum of row <code class="reqn">i</code> (i.e., size of class <code class="reqn">i</code>), <code class="reqn">c_j</code> is the sum of column <code class="reqn">j</code> in the <code class="reqn">k \times k</code> NNCT for <code class="reqn">k \ge 2</code>.
In the output, the test statistic and the <code class="reqn">p</code>-value are valid only 
for (properly) sparsely sampled data.
</p>
<p>See also (Pielou (1961); Ceyhan (2010))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pseg.ss.ct(ct, yates = TRUE, sim = FALSE, Nsim = 2000)

Pseg.ss(dat, lab, yates = TRUE, sim = FALSE, Nsim = 2000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsPseg.ss_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Pseg.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_yates">yates</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, Yates continuity correction is applied,
and if <code>FALSE</code> the continuity correction is not applied. 
Equivalent to the <code>correct</code> argument in the base function <code><a href="stats.html#topic+chisq.test">chisq.test</a></code></p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_sim">sim</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). If <code>TRUE</code>, <code class="reqn">p</code>-values are computed by Monte Carlo simulation
and if <code>FALSE</code> the <code class="reqn">p</code>-value is based on the chi-squared approximation.
Equivalent to the <code>simulate.p.value</code> argument in the base function <code><a href="stats.html#topic+chisq.test">chisq.test</a></code></p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_nsim">Nsim</code></td>
<td>
<p>A positive integer specifying the number of replicates used in the Monte Carlo test.
Equivalent to the <code>B</code> argument in the base function <code><a href="stats.html#topic+chisq.test">chisq.test</a></code></p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Pseg.ss</code> only</p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Pseg.ss</code> only</p>
</td></tr>
<tr><td><code id="funsPseg.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. 
used in <code>Pseg.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The overall chi-squared statistic</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is (k-1)^2 for this function. 
Yields <code>NA</code> if <code>sim=TRUE</code> and <code>NSim</code> is provided.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT, i.e., matrix of the observed <code class="reqn">N_{ij}</code> values
which is the NNCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of the
the <code class="reqn">N_{ij}</code> values in the NNCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Pseg.ss.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Pseg.ss</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overall.nnct.ct">overall.nnct.ct</a></code>, <code><a href="#topic+overall.nnct">overall.nnct</a></code>, <code><a href="#topic+overall.seg.ct">overall.seg.ct</a></code>,
<code><a href="#topic+overall.seg">overall.seg</a></code> and <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

Pseg.ss(Y,cls)

Pseg.ss.ct(ct)
Pseg.ss.ct(ct,yates=FALSE)

Pseg.ss.ct(ct,yates=FALSE,sim=TRUE)
Pseg.ss.ct(ct,yates=FALSE,sim=TRUE,Nsim=10000)

Pseg.ss(Y,cls,method="max")
Pseg.ss(Y,cls,yates=FALSE,sim=TRUE,Nsim=10000,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Pseg.ss(Y,fcls)
Pseg.ss.ct(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

Pseg.ss(Y,cls)
Pseg.ss.ct(ct,yates=FALSE)

Pseg.ss(Y,cls, sim = TRUE, Nsim = 2000)
Pseg.ss.ct(ct,yates=FALSE) 

</code></pre>

<hr>
<h2 id='funsQandR'>Functions for the number of shared NNs, 
shared NN vector, and the number of reflexive NNs</h2><span id='topic+funsQandR'></span><span id='topic+Qval'></span><span id='topic+Qvec'></span><span id='topic+sharedNN'></span><span id='topic+Rval'></span>

<h3>Description</h3>

<p>Four functions: <code>Qval</code>, <code>Qvec</code>, <code>sharedNN</code> and <code>Rval</code>.
</p>
<p><code>Qval</code> returns the <code class="reqn">Q</code> value, the number of points with 
shared nearest neighbors (NNs), which occurs when two or 
more points share a NN, for data in any dimension. 
</p>
<p><code>Qvec</code> returns the Q-value and also yields 
the <code class="reqn">Qv</code> vector <code class="reqn">Qv=(Q_0,Q_1,\ldots)</code> as well 
for data in any dimension, 
where <code class="reqn">Q_j</code> is the number of points shared as 
a NN by <code class="reqn">j</code> other points. 
</p>
<p><code>sharedNN</code> returns the <code>vector</code> of number of points 
with shared NNs, <code class="reqn">Q=(Q_0,Q_1,\ldots)</code> 
where <code class="reqn">Q_i</code> is the number of points that are NN to <code class="reqn">i</code> points, 
and if a point is a NN of <code class="reqn">i</code> points, 
then there are <code class="reqn">i(i-1)</code> points that share a NN. 
So, <code class="reqn">Q=\sum_{i&gt;1} i(i-1)Q_i</code>.
</p>
<p><code>Rval</code> returns the number of reflexive NNs, 
<code class="reqn">R</code> (i.e., twice the number of reflexive NN pairs).
</p>
<p>These quantities are used, e.g., in computing the variances 
and covariances of the entries of the
nearest neighbor contingency tables used for Dixon's tests 
and other NNCT tests. 
The input must be the incidence matrix, <code class="reqn">W</code>, of the NN digraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qval(W)

Qvec(W)

sharedNN(W)

Rval(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsQandR_+3A_w">W</code></td>
<td>
<p>The incidence matrix, <code class="reqn">W</code>, for the NN digraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>Qval</code> returns the <code class="reqn">Q</code> value
</p>
<p>The function <code>Qvec</code> returns a <code>list</code> with two elements
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>the <code class="reqn">Q</code> value, the number of shared NNs</p>
</td></tr>
<tr><td><code>qvec</code></td>
<td>
<p>the <code>vector</code> of <code class="reqn">Q_j</code> values</p>
</td></tr> 
</table>
<p>The function <code>sharedNN</code> returns a <code>matrix</code> with 2 rows, 
where first row is the <code class="reqn">j</code> values and second row is
the corresponding vector of <code class="reqn">Q_j</code> values
</p>
<p>The function <code>Rval</code> returns the <code class="reqn">R</code> value, 
the number of reflexive NNs.
</p>
<p>See the description above for the details of these quantities.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tval">Tval</a></code>, <code><a href="#topic+QRval">QRval</a></code>, <code><a href="#topic+sharedNNmc">sharedNNmc</a></code>,
and <code><a href="#topic+Ninv">Ninv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Examples for Qval
#3D data points
n&lt;-10
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qval(W)

#1D data points
X&lt;-as.matrix(runif(10)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(10) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
Qval(W)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(15)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
Qval(W)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(15)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
Qval(W)

#Examples for Qvec
#3D data points
n&lt;-10
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qvec(W)

#2D data points
n&lt;-15
Y&lt;-matrix(runif(2*n),ncol=2)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qvec(W)

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(15) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
Qvec(W)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(15)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
Qvec(W)

#Examples for sharedNN
#3D data points
n&lt;-10
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)

#2D data points
n&lt;-15
Y&lt;-matrix(runif(2*n),ncol=2)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
sharedNN(W)

#Examples for Rval
#3D data points
n&lt;-10
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Rval(W)

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
Rval(W)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
Rval(W)

</code></pre>

<hr>
<h2 id='funsRowColSums'>Functions for row and column sums of a matrix</h2><span id='topic+funsRowColSums'></span><span id='topic+row.sum'></span><span id='topic+col.sum'></span>

<h3>Description</h3>

<p>Two functions: <code>row.sum</code> and <code>col.sum</code>.
</p>
<p><code>row.sum</code> returns the row sums of a given matrix 
(in particular a contingency table) as a vector and 
<code>col.sum</code> returns the column sums of a given matrix as a vector. 
<code>row.sum</code> is equivalent to 
<code><a href="base.html#topic+rowSums">rowSums</a></code> function and 
<code>col.sum</code> is equivalent to <code><a href="base.html#topic+colSums">colSums</a></code>
function in the <code>base</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row.sum(ct)

col.sum(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsRowColSums_+3A_ct">ct</code></td>
<td>
<p>A matrix, in particular a contingency table</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>row.sum</code> returns the row sums of <code>ct</code> as a vector
<code>col.sum</code> returns the column sums of <code>ct</code> as a vector
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rowSums">rowSums</a></code> and <code><a href="base.html#topic+colSums">colSums</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

row.sum(ct)
rowSums(ct)

col.sum(ct)
colSums(ct)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

row.sum(ct)
rowSums(ct)

col.sum(ct)
colSums(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

row.sum(ct)
rowSums(ct)

col.sum(ct)
colSums(ct)

</code></pre>

<hr>
<h2 id='funsVarTk'>Variance of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+funsVarTk'></span><span id='topic+varTk'></span><span id='topic+varTkaij'></span>

<h3>Description</h3>

<p>Two functions: <code>VarTk</code> and <code>VarTkaij</code>.
</p>
<p>Both functions compute the (finite sample) variance of Cuzick and Edwards <code class="reqn">T_k</code> test statistic based on the 
number of cases within <code>k</code>NNs of the cases in the data under RL or CSR independence.
</p>
<p>The common arguments for both functions are <code>n1</code>, representing the number of cases and <code>k</code>.
The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) for computing <code class="reqn">N_s</code> and <code class="reqn">N_t</code>, which are required in the computation of the
variance. <code class="reqn">N_s</code> and <code class="reqn">N_t</code> are defined on page 78 of (Cuzick and Edwards (1990)) as follows.
<code class="reqn">N_s=\sum_i\sum_j a_{ij} a_{ji}</code> (i.e., number of ordered pairs for which <code>k</code>NN relation is symmetric)
and <code class="reqn">N_t= \sum \sum_{i \ne l}\sum a_{ij} a_{lj}</code> (i.e, number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">l</code>).
</p>
<p>The function <code>VarTkaij</code> uses Toshiro Tango's moments formulas based on the <code class="reqn">A=(a_{ij})</code> matrix
(and is equivalent to the function <code>VarTk</code>, see Tango (2007),
where <code class="reqn">a_{ij}(k) = 1</code> if <code class="reqn">z_j</code> is among the <code>k</code>NNs of <code class="reqn">z_i</code> and 0 otherwise.
</p>
<p>The function <code>varTkaij</code> is equivalent to <code>varTk</code> (with <code>$var</code> extension).
</p>
<p>See (Cuzick and Edwards (1990); Tango (2007)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTk(dat, n1, k, nonzero.mat = TRUE, ...)

varTkaij(n1, k, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsVarTk_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point, used in <code>VarTk</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTk_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="funsVarTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>)</p>
</td></tr>
<tr><td><code id="funsVarTk_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used. Used in <code>VarTk</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTk_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. Used in <code>VarTk</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTk_+3A_a">a</code></td>
<td>
<p>The <code class="reqn">A=(a_{ij})</code> matrix, used in <code>VarTkaij</code> only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>VarTk</code> returns a <code>list</code> with the elements
</p>
<table>
<tr><td><code>var.Tk</code></td>
<td>
<p>The (finite sample) variance of Cuzick and Edwards <code class="reqn">T_k</code> test statistic for disease clustering</p>
</td></tr>
<tr><td><code>Ns</code></td>
<td>
<p>The <code class="reqn">N_s</code> value standing for the number of ordered pairs for which <code>k</code>NN relation is symmetric,
see the description.</p>
</td></tr>
<tr><td><code>Nt</code></td>
<td>
<p>The <code class="reqn">N_t</code> value standing for the number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code>k</code>NNs of <code class="reqn">l</code> see the description.</p>
</td></tr>
</table>
<p>The function <code>VarTkaij</code> returns only <code>var.Tk</code> as above.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.<br /><br /> Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asyvarTk">asyvarTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)
k&lt;-2 #try also 2,3

a&lt;-aij.mat(Y,k)

varTk(Y,n1,k)
varTk(Y,n1,k,nonzero.mat=FALSE)
varTk(Y,n1,k,method="max")

n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)
k&lt;-1 #try also 2,3, sample(1:5,1)

a&lt;-aij.mat(Y,k)

varTkaij(n1,k,a)
varTk(Y,n1,k)$var

</code></pre>

<hr>
<h2 id='funsVarTrun'>Variance of Cuzick and Edwards <code class="reqn">T_{run}</code> Test statistic</h2><span id='topic+funsVarTrun'></span><span id='topic+varTrun'></span><span id='topic+varTrun.sim'></span>

<h3>Description</h3>

<p>Two functions: <code>varTrun</code> and <code>varTrun.sim</code>.
</p>
<p>The function <code>varTrun</code> computes the (finite sample) variance of Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic 
which is based on the number of consecutive cases from the cases in the data under RL or CSR independence.
And the function <code>varTrun.sim</code> estimates this variance based on simulations under the RL hypothesis.
</p>
<p>The only common argument for both functions is <code>dat</code>, the data set used in the functions.
</p>
<p><code class="reqn">n_1</code> is an argument for <code>varTrun</code> and is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. The argument <code>Nsim</code> represents the number of resamplings (without replacement) in the
RL scheme, with default being <code>1000</code>. <code>cc.lab</code>, <code>case.lab</code> and <code>Nsim</code> are arguments for <code>varTrun.sim</code> only.
</p>
<p>The function <code>varTrun</code> might take a very long time when data size is large (even larger than 50),
hence the need for the <code>varTrun.sim</code> function. 
</p>
<p>See (Cuzick and Edwards (1990)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTrun(dat, n1, ...)

varTrun.sim(dat, cc.lab, Nsim = 1000, case.lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsVarTrun_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point, 
used in both functions.</p>
</td></tr>
<tr><td><code id="funsVarTrun_+3A_n1">n1</code></td>
<td>
<p>Number of cases, used in <code>varTrun</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTrun_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
Used in <code>varTrun</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTrun_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control, used in <code>varTrun.sim</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTrun_+3A_nsim">Nsim</code></td>
<td>
<p>The number of simulations, i.e., the number of resamplings under the RL scheme to estimate the 
variance of <code class="reqn">T_{run}</code>, used in <code>varTrun.sim</code> only.</p>
</td></tr>
<tr><td><code id="funsVarTrun_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>, used in <code>varTrun.sim</code> only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>varTrun</code> returns the variance of Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic
under RL or CSR independence.
And the function <code>varTrun.sim</code> estimates the same variance based on simulations under the RL hypothesis.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTrun">ceTrun</a></code> and <code><a href="#topic+EV.Trun">EV.Trun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1) #try also 40, 50, 60
set.seed(123)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)
n1&lt;-sum(cls==1)
n0&lt;-sum(cls==0)
c(n1,n0)

varTrun(Y,n1)
varTrun(Y,n1,method="max")

n&lt;-15  #or try sample(1:20,1) #try also 40, 50, 60
set.seed(123)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)
n1&lt;-sum(cls==1)
varTrun(Y,n1) #the actual value (might take a long time if n is large)

Nmc&lt;-1000
varTrun.sim(Y,cls,Nsim=Nmc)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
varTrun.sim(Y,fcls,Nsim=Nmc,case.lab="a")

</code></pre>

<hr>
<h2 id='funsW345values'><code class="reqn">W_k</code> values for Tango's <code class="reqn">T</code> test statistic</h2><span id='topic+funsW345values'></span><span id='topic+W3val'></span><span id='topic+W4val'></span><span id='topic+W5val'></span>

<h3>Description</h3>

<p>Three functions: <code>W3val</code>, <code>W4val</code> and <code>W5val</code>, each of which is needed to compute <code class="reqn">E[T^3]</code>
(i.e., for the skewness of <code class="reqn">T</code>)
where <code class="reqn">T=T(\theta)</code> which is defined in Equation (2) of Tango (2007) as follows:
Let <code class="reqn">(z_1,\ldots,z_n )</code>, <code class="reqn">n = n_0 + n_1</code>, denote the locations of the points in the combined sample 
when the indices have been randomly permuted so that the <code class="reqn">z_i</code> contain no information about group membership.
</p>
<p style="text-align: center;"><code class="reqn">T(\theta)=\sum_{i=1}^{n}\sum_{j=1}^{n}\delta_i \delta_j a_{ij}(\theta)=
\boldsymbol \delta^t \boldsymbol A(\theta)) \boldsymbol \delta</code>
</p>
<p> where <code class="reqn">\delta_i=1</code> if <code class="reqn">z_i</code> is a case,
and 0 if <code class="reqn">z_i</code> is a control,  <code class="reqn">\boldsymbol A(\theta) = (a_{ij} (\theta))</code> could be any matrix of a measure of
the closeness between two points <code class="reqn">i</code> and <code class="reqn">j</code> with <code class="reqn">a_{ii} = 0</code> for all <code class="reqn">i = 1,\ldots,n</code>, and <code class="reqn">\boldsymbol \theta = 
(\theta_1,\ldots,\theta_p)^t</code> denotes the unknown parameter vector related to cluster size and 
<code class="reqn">\boldsymbol \delta = (\delta_1,\ldots,\delta_n)^t</code>. 
Here the number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code>  to match the case-control class
labeling, which is just the reverse of the labeling in Tango (2007).
</p>
<p>If <code class="reqn">\theta=k</code> in the nearest neighbors model with <code class="reqn">a_{ij}(k) = 1</code> if <code class="reqn">z_j</code> is among the <code class="reqn">k</code>NNs of <code class="reqn">z_i</code> and 0 
otherwise, then the test statistic <code class="reqn">T(\theta) = T_k</code> is the Cuzick and Edwards <code class="reqn">k</code>NN test statistic, <code class="reqn">T_k</code>
Cuzick and Edwards (1990), see also <code><a href="#topic+ceTk">ceTk</a></code>.
</p>
<p><code class="reqn">W_k</code> values are used for Tango's correction to Cuzick and Edwards <code class="reqn">k</code>NN test statistic, <code class="reqn">T_k</code> and
<code class="reqn">W_k</code> here corresponds to <code class="reqn">W_{k-1}</code> in Tango (2007)
(defined for consistency with <code class="reqn">p_k</code>'s and <code class="reqn">alpha_r</code> having <code class="reqn">r</code> distinct elements).
</p>
<p>The argument of the function is the <code class="reqn">A_{ij}</code> matrix, <code>a</code>, which is the output of the function <code><a href="#topic+aij.mat">aij.mat</a></code>.
However, inside the function we symmetrize the matrix <code>a</code> as <code>b &lt;- (a+a^t)/2</code>, to facilitate the formulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W3val(a)

W4val(a)

W5val(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsW345values_+3A_a">a</code></td>
<td>
<p><code class="reqn">A_{ij}</code> matrix which is the output of the function <code><a href="#topic+aij.mat">aij.mat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each function <code>Wkval</code> returns the <code class="reqn">W_k</code> value for <code class="reqn">k=3,4,5</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.<br /><br /> Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+EV.Tk">EV.Tk</a></code>, <code><a href="#topic+varTk">varTk</a></code>, <code><a href="#topic+Xsq.ceTk">Xsq.ceTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
k&lt;-sample(1:5,1) # try also 3, 5, sample(1:5,1)
k
a&lt;-aij.mat(Y,k)
W3val(a)
W4val(a)
W5val(a)

a&lt;-aij.mat(Y,k,method="max")
W3val(a)
W4val(a)
W5val(a)

</code></pre>

<hr>
<h2 id='funsXsq.nnref'>Reflexivity Test with Chi-square Approximation</h2><span id='topic+funsXsq.nnref'></span><span id='topic+Xsq.nnref.ct'></span><span id='topic+Xsq.nnref'></span>

<h3>Description</h3>

<p>Two functions: <code>Xsq.nnref.ct</code> and <code>Xsq.nnref</code>.
</p>
<p>Both functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the
diagonal cell counts (i.e., entries) under RL or CSR in the RCT for <code class="reqn">k \ge 2</code> classes.
That is, each test performs an overall NN reflexivity test (for the vector of entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code>,
respectively, in the RCT) which is
appropriate (i.e., have the appropriate asymptotic sampling distribution) for completely mapped data.
(See Ceyhan and Bahadir (2017) for more detail).
</p>
<p>Each reflexivity test is based on the chi-squared approximation of the corresponding quadratic form
for the vector of diagonal entries 
in the RCT and are due to Ceyhan and Bahadir (2017).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is 2, description of the 
alternative with the corresponding null values (i.e., expected values) of the diagonal entries
and also the sample estimates (i.e., observed values) of the diagonal entries of RCT (as a vector).
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{11},N_{22})=(R P_{aa},R P_{ab})</code> in the RCT, where <code class="reqn">R</code> is the number of reflexive
NNs and <code class="reqn">P_{aa}</code> is the probability of any two points selected are being from the same class
and <code class="reqn">P_{ab}</code> is the probability of any two points selected are being from two different classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.nnref.ct(rfct, nvec, Qv, Tv)

Xsq.nnref(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsXsq.nnref_+3A_rfct">rfct</code></td>
<td>
<p>An RCT, used in <code>Xsq.nnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_nvec">nvec</code></td>
<td>
<p>The <code>vector</code> of class sizes, used in <code>Xsq.nnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_qv">Qv</code></td>
<td>
<p>The number of shared NNs, used in <code>Xsq.nnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_tv">Tv</code></td>
<td>
<p><code class="reqn">T</code> value, which is the number of triplets <code class="reqn">(z_i, z_j, z_k)</code> with 
<code class="reqn">NN(z_i) = NN(z_j) = z_k</code> and <code class="reqn">NN(z_k) = z_j</code> where <code class="reqn">NN(\cdot)</code> is the nearest neighbor function, used in <code>Xsq.nnref.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Xsq.nnref</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Xsq.nnref</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnref_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>Xsq.nnref</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for overall NN reflexivity test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is 2 for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., the observed diagonal entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code>
in the RCT, <code>rfct</code>.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the diagonal entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code> in the RCT, 
which are <code class="reqn">E(N_{11})=R P_{aa}</code> and <code class="reqn">E(N_{22})=R P_{ab}</code>, respectively).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>rfct</code>, returned by <code>Xsq.nnref.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Xsq.nnref</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnref.ct">Znnref.ct</a></code>, <code><a href="#topic+Znnref">Znnref</a></code>, <code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code>,
<code><a href="#topic+Zself.ref">Zself.ref</a></code>, <code><a href="#topic+Zmixed.nonref.ct">Zmixed.nonref.ct</a></code> and <code><a href="#topic+Zmixed.nonref">Zmixed.nonref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
R&lt;-Rval(W)
Tv&lt;-Tval(W,R)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Xsq.nnref(Y,cls)
Xsq.nnref.ct(rfct,nvec,Qv,Tv)

Xsq.nnref(Y,cls,method="max")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
R&lt;-Rval(W)
Tv&lt;-Tval(W,R)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Xsq.nnref(Y,cls)
Xsq.nnref.ct(rfct,nvec,Qv,Tv)

</code></pre>

<hr>
<h2 id='funsXsq.nnsym.dx'>Dixon's NN Symmetry Test with Chi-square Approximation for multiple classes</h2><span id='topic+funsXsq.nnsym.dx'></span><span id='topic+Xsq.nnsym.dx.ct'></span><span id='topic+Xsq.nnsym.dx'></span>

<h3>Description</h3>

<p>Two functions: <code>Xsq.nnsym.dx.ct</code> and <code>Xsq.nnsym.dx</code>.
</p>
<p>Both functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs the hypothesis test of equality of the expected value of the off-diagonal 
cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k \ge 2</code> classes.
That is, each performs Dixon's overall NN symmetry test.
The test is appropriate (i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the chi-squared approximation of the corresponding quadratic form
and is an extension of Dixon's NN symmetry test, which is extended by
Ceyhan (2014).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)/2</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of differences of the off-diagonal entries,(which is
0 for this function) and also the sample estimates (i.e., observed values) of absolute differences of the off-diagonal entries of 
NNCT (in the upper-triangular form).
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=E(N_{ji})</code> entries for all <code class="reqn">i \ne j</code> (i.e., symmetry in the 
mixed NN structure).
</p>
<p>See also
(Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.nnsym.dx.ct(ct, covS)

Xsq.nnsym.dx(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsXsq.nnsym.dx_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Xsq.nnsym.dx.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.dx_+3A_covs">covS</code></td>
<td>
<p>The <code class="reqn">k(k-1)/2 \times k(k-1)/2</code> covariance matrix of the differences of the off-diagonal entries in the NNCT,
<code>ct</code>, usually the output of the function <code><a href="#topic+cov.nnsym">cov.nnsym</a></code>.</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.dx_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Xsq.nnsym.dx</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.dx_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Xsq.nnsym.dx</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.dx_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Xsq.nnsym.dx</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for Dixon's overall NN symmetry test</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)/2</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates, i.e., absolute differences of the off-diagonal entries of 
NNCT (in the upper-triangular form).</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the differences between the expected values of the off-diagonal 
entries, which is 0 for this function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Xsq.nnsym.dx.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Xsq.nnsym.dx</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>, <code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code>, <code><a href="#topic+Znnsym">Znnsym</a></code>,
<code><a href="#topic+Xsq.nnsym">Xsq.nnsym</a></code>, <code><a href="#topic+Xsq.nnsym.ss.ct">Xsq.nnsym.ss.ct</a></code>, <code><a href="#topic+Xsq.nnsym.ss">Xsq.nnsym.ss</a></code>
and <code><a href="#topic+Qsym.test">Qsym.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow
covS&lt;-cov.nnsym(covN)

Xsq.nnsym.dx(Y,cls)
Xsq.nnsym.dx.ct(ct,covS)

Xsq.nnsym.dx(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Xsq.nnsym.dx(Y,fcls)
Xsq.nnsym.dx.ct(ct,covS)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)
covS&lt;-cov.nnsym(covN)

Xsq.nnsym.dx(Y,cls)
Xsq.nnsym.dx.ct(ct,covS)

</code></pre>

<hr>
<h2 id='funsXsq.nnsym.ss'>Pielou's First Type of NN Symmetry Test with Chi-square Approximation for multiple classes
(for Sparse Sampling)</h2><span id='topic+funsXsq.nnsym.ss'></span><span id='topic+Xsq.nnsym.ss.ct'></span><span id='topic+Xsq.nnsym.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>Xsq.nnsym.ss.ct</code> and <code>Xsq.nnsym.ss</code>.
</p>
<p>Both functions are objects of class <code>"Chisqtest"</code> but with different arguments (see the parameter list below).
Each one performs the hypothesis test of equality of the expected value of the off-diagonal 
cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k \ge 2</code> classes.
That is, each performs Pielou's first type of NN symmetry test which is also equivalent to McNemar's
test on the NNCT. The test is appropriate (i.e., have the appropriate asymptotic sampling distribution)
provided that data is obtained by sparse sampling.
(See Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the chi-squared approximation of the corresponding quadratic form
and are due to Pielou (1961).
</p>
<p>The argument cont.corr is a logical argument (default=<code>TRUE</code>) for continuity correction to this test.
If <code>TRUE</code> the continuity correction to McNemar's test is implemented, 
and if <code>FALSE</code> such a correction is not implemented. 
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)/2</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of differences of the off-diagonal entries,(which is
0 for this function) and also the sample estimates (i.e., observed values) of absolute differences of th
off-diagonal entries of NNCT (in the upper-triangular form).
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{ij})=E(N_{ji})</code> for all entries for <code class="reqn">i \ne j</code> (i.e., symmetry in the 
mixed NN structure).
In the output, the test statistic, <code class="reqn">p</code>-value and <code>df</code> are valid only for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.nnsym.ss.ct(ct, cont.corr = TRUE)

Xsq.nnsym.ss(dat, lab, cont.corr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsXsq.nnsym.ss_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Xsq.nnsym.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.ss_+3A_cont.corr">cont.corr</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). 
If <code>TRUE</code> the continuity correction to McNemar's test is implemented, 
and if <code>FALSE</code> such a correction is not implemented.</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Xsq.nnsym.ss</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Xsq.nnsym.ss</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.nnsym.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Xsq.nnsym.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for Pielou's first type of NN symmetry test</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)/2</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates, i.e., absolute differences of the off-diagonal entries of 
NNCT (in the upper-triangular form).</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the differences between the expected values of the off-diagonal 
entries, which is 0 for this function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Xsq.nnsym.ss.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Xsq.nnsym.ss</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym2cl.ss.ct">Znnsym2cl.ss.ct</a></code>, <code><a href="#topic+Znnsym2cl.ss">Znnsym2cl.ss</a></code>, <code><a href="#topic+Znnsym.ss.ct">Znnsym.ss.ct</a></code>,
<code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>, <code><a href="#topic+Xsq.nnsym.dx.ct">Xsq.nnsym.dx.ct</a></code>, <code><a href="#topic+Xsq.nnsym.dx">Xsq.nnsym.dx</a></code>
and <code><a href="#topic+Qsym.test">Qsym.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

Xsq.nnsym.ss(Y,cls)
Xsq.nnsym.ss.ct(ct)

Xsq.nnsym.ss(Y,cls,method="max")

Xsq.nnsym.ss(Y,cls,cont.corr=FALSE)
Xsq.nnsym.ss.ct(ct,cont.corr=FALSE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Xsq.nnsym.ss(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

Xsq.nnsym.ss(Y,cls)
Xsq.nnsym.ss.ct(ct)
Xsq.nnsym.ss.ct(ct,cont.corr = FALSE)

</code></pre>

<hr>
<h2 id='funsXsq.seg.coeff'>Chi-square Test for Segregation Coefficients</h2><span id='topic+funsXsq.seg.coeff'></span><span id='topic+Xsq.seg.coeff.ct'></span><span id='topic+Xsq.seg.coeff'></span>

<h3>Description</h3>

<p>Two functions: <code>Xsq.seg.coeff.ct</code> and <code>Xsq.seg.coeff</code>.
</p>
<p>Each one performs hypothesis tests of (simultaneous) equality of the segregation coefficients in an NNCT
to the ones under RL or CSR.
That is, each performs the combined Chi-square test for segregation coefficients which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2014) for more detail).
</p>
<p>Each test is based on the Chi-square approximation of the corresponding quadratic form for the segregation
coefficients in an NNCT.
The segregation coefficients in the multi-class case are the extension of Pielou's segregation coefficient
for the two-class case.
(See Ceyhan (2014) for more detail).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k+1)/2-1</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of the segregation coefficients in the NNCT
(which are 0 for this function) and also the sample estimates (i.e., observed values) of the segregation
coefficients. The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis for all cells <code class="reqn">(i,j)</code> is that the corresponding segregation coefficients are all 
equal to the expected value (which is 0) under RL or CSR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.seg.coeff.ct(ct, covSC)

Xsq.seg.coeff(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsXsq.seg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Xsq.seg.coeff.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.seg.coeff_+3A_covsc">covSC</code></td>
<td>
<p>The covariance matrix for the segregation coefficients in the NNCT, used in <code>Xsq.seg.coeff.ct</code> only.
Usually output of the function <code><a href="#topic+cov.seg.coeff">cov.seg.coeff</a></code></p>
</td></tr>
<tr><td><code id="funsXsq.seg.coeff_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Xsq.seg.coeff</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.seg.coeff_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Xsq.seg.coeff</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.seg.coeff_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Xsq.seg.coeff</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for the combined segregation coefficients</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k+1)/2-1</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The <code>vector</code> of estimates of the parameters, i.e., observed values of segregation coefficients 
in the NNCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The null value of the parameters, i.e., expected values of segregation coefficients
in the NNCT under RL or CSR (which is 0).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Xsq.seg.coeff.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Xsq.seg.coeff</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.coeff">seg.coeff</a></code>, <code><a href="#topic+Zseg.coeff.ct">Zseg.coeff.ct</a></code> and <code><a href="#topic+Zseg.coeff">Zseg.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

covSC&lt;-cov.seg.coeff(ct,covN)

Xsq.seg.coeff(Y,cls)
Xsq.seg.coeff.ct(ct,covSC)

Xsq.seg.coeff(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Xsq.seg.coeff.ct(ct,covSC)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

covSC&lt;-cov.seg.coeff(ct,covN)

Xsq.seg.coeff(Y,cls)
Xsq.seg.coeff.ct(ct,covSC)

</code></pre>

<hr>
<h2 id='funsXsq.spec.cor'>Overall Species Correspondence Test with Chi-square Approximation</h2><span id='topic+funsXsq.spec.cor'></span><span id='topic+Xsq.spec.cor.ct'></span><span id='topic+Xsq.spec.cor'></span>

<h3>Description</h3>

<p>Two functions: <code>Xsq.spec.cor.ct</code> and <code>Xsq.spec.cor</code>.
</p>
<p>Each one performs hypothesis tests of (simultaneous) equality of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the expected values of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT
to the ones under RL or CSR.
That is, each performs the overall species correspondence test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2018) for more detail).
</p>
<p>Each test is based on the Chi-square approximation of the corresponding quadratic form for the first column
in a species correspondence contingency table (SCCT) or the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT and
are due to (Ceyhan 2018).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of the self entries (i.e., first column) in the SCCT
or the diagonal entries in the NNCT and also the sample estimates (i.e., observed values) of these entries.
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all 
<code class="reqn">E[S_1,S_2,\ldots,S_k] = E[N_{11},N_{22},\ldots,N_{kk}] = ((n_1(n_1 - 1)/(n - 1),(n_2(n_2 - 1)/(n - 1),\ldots,(n_k(n_k - 1)/(n - 1) )</code>
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and <code class="reqn">n</code> is the data size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.spec.cor.ct(ct, covSC, nnct = FALSE)

Xsq.spec.cor(dat, lab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsXsq.spec.cor_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT, used in <code>Xsq.spec.cor.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.spec.cor_+3A_covsc">covSC</code></td>
<td>
<p>The covariance matrix for the self entries (i.e., first column) in the SCCT
or the diagonal entries in the NNCT, used in <code>Xsq.spec.cor.ct</code> only. Usually output of the functions 
<code><a href="#topic+covNii.ct">covNii.ct</a></code> or <code><a href="#topic+covNii">covNii</a></code>.</p>
</td></tr>
<tr><td><code id="funsXsq.spec.cor_+3A_nnct">nnct</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). If <code>TRUE</code>, <code>x</code> is taken to be the <code class="reqn">k \times k</code> NNCT, 
and if <code>FALSE</code>, <code>x</code> is taken to be the IPD matrix, used in <code>Xsq.spec.cor.ct</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.spec.cor_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Xsq.spec.cor</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.spec.cor_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Xsq.spec.cor</code> only</p>
</td></tr>
<tr><td><code id="funsXsq.spec.cor_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Xsq.spec.cor</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for overall species correspondence test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The <code>vector</code> of estimates of the parameters, i.e., observed values of self entries 
in the SCCT or diagonal entries in the NNCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The <code>vector</code> of null values of the parameters, i.e., expected values of self entries 
in the SCCT or diagonal entries in the NNCT under RL or CSR.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Xsq.spec.cor.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Xsq.spec.cor</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code>, <code><a href="#topic+Zself.ref">Zself.ref</a></code>, <code><a href="#topic+Xsq.nnref.ct">Xsq.nnref.ct</a></code> and <code><a href="#topic+Xsq.nnref">Xsq.nnref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-scct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
cv&lt;-covNii.ct(ct,vsq,Qv,Rv)
Xsq.spec.cor.ct(ct,cv)
Xsq.spec.cor(Y,cls)
Xsq.spec.cor(Y,cls,method="max")

ct&lt;-nnct(ipd,cls)
Xsq.spec.cor.ct(ct,cv,nnct = TRUE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-scct(ipd,fcls)
Xsq.spec.cor.ct(ct,cv)
Xsq.spec.cor(Y,fcls)

ct&lt;-nnct(ipd,fcls)
Xsq.spec.cor.ct(ct,cv,nnct=TRUE)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-scct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
cv&lt;-covNii.ct(ct,vsq,Qv,Rv)
Xsq.spec.cor.ct(ct,cv)

ct&lt;-nnct(ipd,cls)
Xsq.spec.cor.ct(ct,cv,nnct = TRUE)
Xsq.spec.cor(Y,cls)

</code></pre>

<hr>
<h2 id='funsZcell.nnct'>Dixon's Cell-specific Z Tests of Segregation for NNCT</h2><span id='topic+funsZcell.nnct'></span><span id='topic+Zcell.nnct.ct'></span><span id='topic+Zcell.nnct'></span>

<h3>Description</h3>

<p>Two functions: <code>Zcell.nnct.ct</code> and <code>Zcell.nnct</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> 
but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
cell counts from the expected values under RL 
or CSR for each cell (i.e., entry) in the NNCT.
The test for each cell <code class="reqn">i,j</code> is based on
the normal approximation of the corresponding cell count, <code class="reqn">N_{ij}</code>
and are due to Dixon (1994, 2002).
</p>
<p>Each function yields a contingency table of the test statistics, 
<code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), 
lower and upper confidence levels, 
sample estimates (i.e., observed values)
for the cell counts and also names of the test statistics, 
estimates, null values, the description of the test, 
and the data set used.
</p>
<p>The null hypothesis for each cell <code class="reqn">i,j</code> is that 
the corresponding cell count is equal to the expected value
under RL or CSR, that is <code class="reqn">E[N_{ii}] = n_i(n_i - 1)/(n - 1)</code> 
and <code class="reqn">E[N_{ij}] = n_i n_j/(n - 1)</code>
where <code class="reqn">n_i</code> is the size of 
class <code class="reqn">i</code> and <code class="reqn">n</code> is the size of the data set.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zcell.nnct.ct(
  ct,
  varN,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zcell.nnct(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZcell.nnct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, 
used in <code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code> only</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_varn">varN</code></td>
<td>
<p>The variance matrix for cell counts in the NNCT, <code>ct</code>; 
used in <code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code> only</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, 
default is <code>0.95</code>, for the cell counts, i.e.
<code class="reqn">N_{ij}</code> values</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions,
each row corresponds to a data point,
used in <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> only</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical),
used in <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> only</p>
</td></tr>
<tr><td><code id="funsZcell.nnct_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function,
used in <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of Dixon's cell-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for 
the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels 
for the cell counts at the given confidence
level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, 
it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and 
lower confidence limits of the cell counts,
provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., 
matrix of the observed cell counts which is the NNCT</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, 
both are same in this function</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values 
for the parameters which are expected values of 
the cell counts.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, 
returned by <code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, 
returned by <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> only </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zcell.nnct.2s">Zcell.nnct.2s</a></code>, <code><a href="#topic+Zcell.nnct.rs">Zcell.nnct.rs</a></code>, 
<code><a href="#topic+Zcell.nnct.ls">Zcell.nnct.ls</a></code>, <code><a href="#topic+Zcell.nnct.pval">Zcell.nnct.pval</a></code>,
and <code><a href="#topic+Zcell.tct">Zcell.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
varN

Zcell.nnct(Y,cls)
Zcell.nnct(Y,cls,alt="g")

Zcell.nnct.ct(ct,varN)
Zcell.nnct.ct(ct,varN,alt="g")

Zcell.nnct(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Zcell.nnct(Y,cls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

Zcell.nnct(Y,cls)
Zcell.nnct.ct(ct,varN)

</code></pre>

<hr>
<h2 id='funsZcell.nnct.pval'><code class="reqn">p</code>-values for Cell-specific Z Test Statistics for NNCT</h2><span id='topic+funsZcell.nnct.pval'></span><span id='topic+Zcell.nnct.pval'></span><span id='topic+Zcell.nnct.2s'></span><span id='topic+Zcell.nnct.ls'></span><span id='topic+Zcell.nnct.rs'></span>

<h3>Description</h3>

<p>Four functions: <code>Zcell.nnct.2s</code>, <code>Zcell.nnct.rs</code>, 
<code>Zcell.nnct.ls</code> and <code>Zcell.nnct.pval</code>.
</p>
<p>These functions yield a contingency table (i.e., a matrix) of 
the <code class="reqn">p</code>-values for the cell-specific <code class="reqn">Z</code>
test statistics for the NNCT 
and take the cell-specific <code class="reqn">Z</code> test statistics 
in matrix form as their argument.
<code>Zcell.nnct.pval</code> yields an array of size 
<code class="reqn">k \times k \times 3</code> 
where 1st entry of the array is the matrix of <code class="reqn">p</code>-values for the
two-sided alternative, 
2nd entry of the array is the matrix of <code class="reqn">p</code>-values 
for the left-sided alternative
and 3rd entry of the array is the matrix of <code class="reqn">p</code>-values 
for the right-sided alternative.
And each of <code>Zcell.nnct.2s</code>, <code>Zcell.nnct.rs</code> 
and <code>Zcell.nnct.ls</code> yield a <code class="reqn">k \times k</code> matrix of 
<code class="reqn">p</code>-values for the two-sided, 
right-sided and left-sided alternative, respectively. 
</p>
<p>The functions <code>Zcell.nnct.2s</code>, <code>Zcell.nnct.rs</code> 
and <code>Zcell.nnct.ls</code> are equivalent to
<code><a href="#topic+Zcell.nnct">Zcell.nnct</a>(...,alt)$p.val</code> 
where <code>alt="two-sided"</code>, <code>"greater"</code> and <code>"less"</code>, 
respectively, with the appropriate
arguments for the function <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> 
(see the examples below).
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zcell.nnct.pval(zt)

Zcell.nnct.2s(zt)

Zcell.nnct.ls(zt)

Zcell.nnct.rs(zt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZcell.nnct.pval_+3A_zt">zt</code></td>
<td>
<p>A <code class="reqn">k \times k</code> matrix of 
the cell-specific <code class="reqn">Z</code> test statistics</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Zcell.nnct.pval</code> returns a <code class="reqn">k \times k \times 3</code> array 
whose 1st entry is the matrix of <code class="reqn">p</code>-values for the
two-sided alternative, 
2nd entry is the matrix of <code class="reqn">p</code>-values 
for the left-sided alternative
and 3rd entry is the matrix of <code class="reqn">p</code>-values 
for the right-sided alternative
<code>Zcell.nnct.2s</code> returns a <code class="reqn">k \times k</code> 
matrix of <code class="reqn">p</code>-values for the two-sided alternative
<code>Zcell.nnct.rs</code> returns a <code class="reqn">k \times k</code> 
matrix of <code class="reqn">p</code>-values for the right-sided alternative
<code>Zcell.nnct.ls</code> returns a <code class="reqn">k \times k</code> 
matrix of <code class="reqn">p</code>-values for the left-sided alternative
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code> and <code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
TS&lt;-Zcell.nnct(Y,cls)$statistic
TS
pv&lt;-Zcell.nnct.pval(TS)
pv

Zcell.nnct(Y,cls,alt="t")$p.val
Zcell.nnct(Y,cls,alt="l")$p.val
Zcell.nnct(Y,cls,alt="g")$p.val

Zcell.nnct.2s(TS)

Zcell.nnct.ls(TS)

Zcell.nnct.rs(TS)

</code></pre>

<hr>
<h2 id='funsZcell.spec'>Cell-specific Z Tests of Segregation for NNCTs</h2><span id='topic+funsZcell.spec'></span><span id='topic+cell.spec.ct'></span><span id='topic+cell.spec'></span>

<h3>Description</h3>

<p>Two functions: <code>Zcell.spec.ct</code> and <code>Zcell.spec</code>.
</p>
<p>All functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
entries of NNCT or types I-IV TCTs from the expected values under RL or CSR for each entry.
The test for each entry <code class="reqn">i,j</code> is based on the normal approximation of the corresponding <code class="reqn">T_{ij}</code> value
and are due to Dixon (2002)
and Ceyhan (2017), respectively.
</p>
<p>The <code>type="dixon"</code> or <code>"nnct"</code> refers to Dixon's cell-specific test of segregation, and
<code>type="I"</code>-<code>"IV"</code> refers to types I-IV cell-specific tests, respectively.
</p>
<p>Each function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), lower and upper confidence levels and sample estimates (i.e., observed values)
for the <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> values and also names of the test statistics, estimates, null values, the description of the test, and
the data set used.
</p>
<p>The null hypothesis for each entry <code class="reqn">i,j</code> is that the corresponding value <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> is equal to the 
expected value under RL or CSR.
</p>
<p>See also
(Dixon (1994, 2002); Ceyhan (2010, 2017))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.spec.ct(
  ct,
  covN,
  type,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

cell.spec(
  dat,
  lab,
  type,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZcell.spec_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Zcell.spec.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT, <code>ct</code>;
used in <code>Zcell.spec.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test with no default.
Takes on values <code>"dixon"</code> or <code>"nnct"</code> for Dixon's cell-specific tests and <code>"I"</code>-<code>"IV"</code> for types I-IV cell-specific
tests (or equivalently <code>1-6</code>, respectively).</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, for the <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> values</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zcell.spec</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zcell.spec</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.spec_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>Zcell.spec</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of cell-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels for the <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> values at the given confidence
level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits of the entries, provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, NNCT or TCT, i.e., matrix of the observed <code class="reqn">N_{ij}</code> or <code class="reqn">T_{ij}</code> values
which is NNCT or TCT, respectively.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, both are same in this function</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values for the parameters which are expected values of the 
the null <code class="reqn">N_{ij}</code> values in an NNCT or <code class="reqn">T_{ij}</code> values in an TCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Zcell.spec.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zcell.spec</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code>, <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code>, <code><a href="#topic+Zcell.tct.ct">Zcell.tct.ct</a></code> 
and <code><a href="#topic+Zcell.tct">Zcell.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

type&lt;-"IV" #"dixon" #try also "nnct", "I", "II", "III", and "IV"
cell.spec(Y,cls,type)
cell.spec(Y,cls,type,alt="g")

cell.spec.ct(ct,covN,type)
cell.spec.ct(ct,covN,type="II",alt="g")

cell.spec(Y,cls,type,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
cell.spec(Y,cls,type="I")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

cell.spec(Y,cls,type)
cell.spec.ct(ct,covN,type)

</code></pre>

<hr>
<h2 id='funsZcell.tct'>Types I-IV Cell-specific Z Tests of Segregation based on NNCTs</h2><span id='topic+funsZcell.tct'></span><span id='topic+Zcell.tct.ct'></span><span id='topic+Zcell.tct'></span>

<h3>Description</h3>

<p>Two functions: <code>Zcell.tct.ct</code> and <code>Zcell.tct</code>.
</p>
<p>All functions are objects of class <code>"cellhtest"</code> 
but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
entries of types I-IV TCT, <code class="reqn">T_{ij}</code>, 
from their expected values under RL 
or CSR for each entry.
The test for each entry <code class="reqn">i,j</code> is based on 
the normal approximation of the corresponding <code class="reqn">T_{ij}</code> value
and are due to Ceyhan (2017).
</p>
<p>Each function yields a contingency table of the test statistics, 
<code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), 
lower and upper confidence levels, and sample estimates
(i.e., observed values) for the <code class="reqn">T_{ij}</code> values 
and also names of the test statistics, estimates, 
null values, the description of the test, 
and the data set used.
</p>
<p>The null hypothesis for each entry <code class="reqn">i,j</code> is that 
the corresponding value <code class="reqn">T_{ij}</code> is equal to 
the expected value under RL or CSR, 
see Ceyhan (2017)
for more detail.
</p>
<p>See also (Ceyhan (2017)) 
and references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zcell.tct.ct(
  ct,
  covN,
  type = "III",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zcell.tct(
  dat,
  lab,
  type = "III",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZcell.tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, 
used in <code>Zcell.tct.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of 
row-wise vectorized cell counts of NNCT, <code>ct</code>;
used in <code>Zcell.tct.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, 
default=<code>"III"</code>. 
Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, 
default is <code>0.95</code>, for the <code class="reqn">T_{ij}</code> values</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, 
each row corresponds to a data point,
used in <code>Zcell.tct</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), 
used in <code>Zcell.tct</code> only</p>
</td></tr>
<tr><td><code id="funsZcell.tct_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, 
used in <code>Zcell.tct</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of Types I-IV cell-specific test statistics</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values 
for the hypothesis test 
for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels for 
the <code class="reqn">T_{ij}</code> values at the given confidence
level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, 
it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and 
lower confidence limits of the entries,
provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, 
i.e., matrix of the observed <code class="reqn">T_{ij}</code> values which is the TCT</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, 
both are same in this function</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Matrix of hypothesized null values 
for the parameters which are expected values of 
<code class="reqn">T_{ij}</code> values in the TCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, 
returned by <code>Zcell.tct.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, 
returned by <code>Zcell.tct</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zcell.nnct.ct">Zcell.nnct.ct</a></code> and <code><a href="#topic+Zcell.nnct">Zcell.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

type&lt;-"I" #try also "II", "III", and "IV"
Zcell.tct(Y,cls,type)
Zcell.tct(Y,cls,type,alt="g")
Zcell.tct(Y,cls,type,method="max")

Zcell.tct.ct(ct,covN)
Zcell.tct.ct(ct,covN,type)
Zcell.tct.ct(ct,covN,type,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Zcell.tct(Y,cls,type)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

Zcell.tct(Y,cls,type)
Zcell.tct.ct(ct,covN,type)

</code></pre>

<hr>
<h2 id='funsZdir.nnct'>Directional Segregation Test for Two Classes with Normal Approximation</h2><span id='topic+funsZdir.nnct'></span><span id='topic+Zdir.nnct.ct'></span><span id='topic+Zdir.nnct'></span>

<h3>Description</h3>

<p>Two functions: <code>Zdir.nnct.ct</code> and <code>Zdir.nnct</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected value of the the difference between the
phat estimates in a <code class="reqn">2 \times 2</code> NNCT to the one under RL or CSR (which is <code class="reqn">-1/(n-1)</code>) where
phat estimates are <code class="reqn">N_{11}/n_1</code> and <code class="reqn">N_{21}/n_2</code>.
That is, each performs directional (i.e., one-sided) tests based on the <code class="reqn">2 \times 2</code> NNCT 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2010) for more detail).
</p>
<p>The one-sided (or directional) test has two types, specified with the type argument, with default
<code>type="II"</code>. The second type is 
<code class="reqn">Z_{II}=(T_n-E T_n)/\sqrt{Var(T_n)}</code> where <code class="reqn">T_n=N_{11}/n_1 - N_{21}/n_2</code>
(which is the difference between
phat values) and the first type is <code class="reqn">Z_I=U_n T_n</code> where <code class="reqn">U_n=\sqrt{n_1 n_2/(C_1 C_2)}</code>.
Each test is based on the normal approximation of the <code class="reqn">Z_I</code> and <code class="reqn">Z_{II}</code> based on the <code class="reqn">2 \times 2</code> NNCT and
are due to (Ceyhan 2010).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, sample estimate (i.e., observed value) and null
(i.e., expected) value for the difference in phat values which is <code class="reqn">-1/(n-1)</code> for this function 
and method and name of the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E[Z_{II}] = 0</code> and <code class="reqn">E[Z_I]</code> converges to 0 as class sizes go to infinity (or
<code class="reqn">T_n</code> has mean equal to <code class="reqn">-1/(n-1)</code> where <code class="reqn">n</code> is the data size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zdir.nnct.ct(
  ct,
  covN,
  type = "II",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zdir.nnct(
  dat,
  lab,
  type = "II",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZdir.nnct_+3A_ct">ct</code></td>
<td>
<p>The NNCT, used in <code>Zdir.nnct.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_type">type</code></td>
<td>
<p>The type of the directional (i.e., one-sided) test with default=<code>"II"</code>.
Takes on values <code>"I"</code> and <code>"II"</code> for types I and II directional tests (see the description above).</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference in phat estimates in the NNCT</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zdir.nnct</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zdir.nnct</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Zdir.nnct</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the directional (i.e., one-sided) test of segregation based on
the NNCT</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the difference in phat values in an NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the observed difference in phat values in an NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the difference in phat values in an NNCT
which is <code class="reqn">-1/(n-1)</code> for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Zdir.nnct.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zdir.nnct</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Directional clustering tests based on nearest neighbour contingency tables.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>22(5)</b>, 599-616.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zdir.nnct.ss.ct">Zdir.nnct.ss.ct</a></code>, <code><a href="#topic+Zdir.nnct.ss">Zdir.nnct.ss</a></code>, <code><a href="#topic+overall.nnct.ct">overall.nnct.ct</a></code>
and <code><a href="#topic+overall.nnct">overall.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

Zdir.nnct(Y,cls)
Zdir.nnct.ct(ct,covN)

Zdir.nnct(Y,cls,alt="g")
Zdir.nnct.ct(ct,covN,type="I",alt="l")

Zdir.nnct(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Zdir.nnct(Y,fcls)
Zdir.nnct.ct(ct,covN)

#############
ct&lt;-matrix(1:4,ncol=2) 
Zdir.nnct.ct(ct,covN) #gives an error message if ct is defined as ct&lt;-matrix(1:9,ncol=3)

</code></pre>

<hr>
<h2 id='funsZdir.nnct.ss'>Directional Segregation Test for Two Classes with Normal Approximation (for Sparse Sampling)</h2><span id='topic+funsZdir.nnct.ss'></span><span id='topic+Zdir.nnct.ss.ct'></span><span id='topic+Zdir.nnct.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>Zdir.nnct.ss.ct</code> and <code>Zdir.nnct.ss</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of independence in the <code class="reqn">2 \times 2</code> NNCT which implies <code class="reqn">Z_P=0</code>
or equivalently <code class="reqn">N_{11}/n_1=N_{21}/n_2</code>.
<code class="reqn">Z_P=(N_{11}/n_1-N_{21}/n_2)\sqrt{n_1 n_2 n/(C_1 C_2)}</code> 
where <code class="reqn">N_{ij}</code> is the cell count in entry <code class="reqn">i,j</code>, <code class="reqn">n_i</code> is the sum of row <code class="reqn">i</code> (i.e., size of class <code class="reqn">i</code>),
<code class="reqn">c_j</code> is the sum of column <code class="reqn">j</code> in the <code class="reqn">2 \times 2</code> NNCT;
<code class="reqn">N_{11}/n_1</code> and <code class="reqn">N_{21}/n_2</code> are also referred to as the phat estimates in row-wise binomial framework
for <code class="reqn">2 \times 2</code> NNCT (see Ceyhan (2010)).
</p>
<p>That is, each performs directional (i.e., one-sided) tests based on the <code class="reqn">2 \times 2</code> NNCT and is appropriate
(i.e., have the appropriate asymptotic sampling distribution)
when that data is obtained by sparse sampling.
(See Ceyhan (2010) for more detail).
</p>
<p>Each test is based on the normal approximation of <code class="reqn">Z_P</code> which is the directional <code class="reqn">Z</code>-tests for the chi-squared
tests of independence for the contingency tables (Bickel and Doksum 1977).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, sample estimate (i.e., observed value) and
null (i.e., expected) value for the difference in the phat values (which is 0 for this test) in an NNCT, 
and method and name of the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E[Z_P] = 0</code> or equivalently <code class="reqn">N_{11}/n_1 = N_{21}/n_2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zdir.nnct.ss.ct(
  ct,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zdir.nnct.ss(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZdir.nnct.ss_+3A_ct">ct</code></td>
<td>
<p>The NNCT, used in <code>Zdir.nnct.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct.ss_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZdir.nnct.ss_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the confidence limits, default is <code>0.95</code>, 
for the difference in phat values in the NNCT</p>
</td></tr>
<tr><td><code id="funsZdir.nnct.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zdir.nnct.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zdir.nnct.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZdir.nnct.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Zdir.nnct.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the directional (i.e., one-sided) test of segregation based on
the NNCT</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the difference in phat values in the NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the observed difference in phat values in the NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the difference in phat values in the NNCT
which is 0 for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Zdir.nnct.ss.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zdir.nnct.ss</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Bickel PJ, Doksum AK (1977).
<em>Mathematical Statistics, Basic Ideas and Selected Topics</em>.
Prentice Hall, Englewood Cliffs, NJ.<br /><br /> Ceyhan E (2010).
&ldquo;Directional clustering tests based on nearest neighbour contingency tables.&rdquo;
<em>Journal of Nonparametric Statistics</em>, <b>22(5)</b>, 599-616.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zdir.nnct.ct">Zdir.nnct.ct</a></code>, <code><a href="#topic+Zdir.nnct">Zdir.nnct</a></code>, <code><a href="#topic+Pseg.ss.ct">Pseg.ss.ct</a></code> and <code><a href="#topic+Pseg.ss">Pseg.ss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

Zdir.nnct.ss(Y,cls)
Zdir.nnct.ss.ct(ct)
Zdir.nnct.ss(Y,cls,alt="g")

Zdir.nnct.ss(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Zdir.nnct.ss(Y,fcls)
Zdir.nnct.ss.ct(ct)

#############
ct&lt;-matrix(1:4,ncol=2)
Zdir.nnct.ss.ct(ct) #gives an error message if ct&lt;-matrix(1:9,ncol=3)

</code></pre>

<hr>
<h2 id='funsZmixed.nonref'>Mixed-Non-Reflexivity Test with Normal Approximation</h2><span id='topic+funsZmixed.nonref'></span><span id='topic+Zmixed.nonref.ct'></span><span id='topic+Zmixed.nonref'></span>

<h3>Description</h3>

<p>Two functions: <code>Zmixed.nonref.ct</code> and <code>Zmixed.nonref</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of mixed non-reflexivity in the NN structure using the
number of mixed-non-reflexive NN pairs (i.e., the second diagonal entry, <code class="reqn">(2,2)</code>) in the RCT for <code class="reqn">k \ge 2</code> classes.
That is, each test performs a test of mixed non-reflexivity corresponding to entry <code class="reqn">(2,2)</code> in the RCT)
which is appropriate (i.e., have the appropriate asymptotic sampling distribution) for completely mapped data.
(See Ceyhan and Bahadir (2017) for more detail).
</p>
<p>The mixed non-reflexivity test is based on the normal approximation of the diagonal entry <code class="reqn">(2,2)</code>
in the RCT and are due to Ceyhan and Bahadir (2017).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, sample estimate (i.e., observed value) and null (i.e., expected) value for the
mixed non-reflexivity value (i.e., diagonal entry <code class="reqn">(2,2)</code> value, respectively) in the RCT, 
and method and name of the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{22})=R P_{ab}</code> in the RCT, where <code class="reqn">R</code> is the number of reflexive
NNs and <code class="reqn">P_{ab}</code> is the probability of any two points selected are being from two different classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zmixed.nonref.ct(
  rfct,
  nvec,
  Qv,
  Tv,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zmixed.nonref(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZmixed.nonref_+3A_rfct">rfct</code></td>
<td>
<p>An RCT, used in <code>Zmixed.nonref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_nvec">nvec</code></td>
<td>
<p>The <code>vector</code> of class sizes, used in <code>Zmixed.nonref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_qv">Qv</code></td>
<td>
<p>The number of shared NNs, used in <code>Zmixed.nonref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_tv">Tv</code></td>
<td>
<p><code class="reqn">T</code> value, which is the number of triplets <code class="reqn">(z_i, z_j, z_k)</code> with 
&quot;<code class="reqn">NN(z_i) = NN(z_j) = z_k</code> and <code class="reqn">NN(z_k) = z_j</code> where <code class="reqn">NN(\cdot)</code> is the nearest neighbor function, used in <code>Zmixed.nonref.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zmixed.nonref</code> only</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zmixed.nonref</code> only</p>
</td></tr>
<tr><td><code id="funsZmixed.nonref_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Zmixed.nonref</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for mixed non-reflexivity corresponding to entry <code class="reqn">(2,2)</code> in the RCT</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the mixed non-reflexivity value (i.e., diagonal entry <code class="reqn">(2,2)</code> value)
in the RCT at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the observed diagonal entry <code class="reqn">(2,2)</code> in the RCT, <code>rfct</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the mixed non-reflexivity value (i.e., expected value of the 
diagonal entry <code class="reqn">(2,2)</code> which is <code class="reqn">E(N_{22})=R P_{ab}</code>) in the RCT.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>rfct</code>, returned by <code>Zmixed.nonref.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zmixed.nonref</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code>, <code><a href="#topic+Zself.ref">Zself.ref</a></code>, <code><a href="#topic+Znnref.ct">Znnref.ct</a></code> and
<code><a href="#topic+Znnref">Znnref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
R&lt;-Rval(W)
Tv&lt;-Tval(W,R)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Zmixed.nonref(Y,cls)
Zmixed.nonref.ct(rfct,nvec,Qv,Tv)
Zmixed.nonref(Y,cls,alt="g")

Zmixed.nonref(Y,cls,method="max")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
R&lt;-Rval(W)
Tv&lt;-Tval(W,R)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Zmixed.nonref(Y,cls,alt="g")

Zmixed.nonref.ct(rfct,nvec,Qv,Tv)
Zmixed.nonref.ct(rfct,nvec,Qv,Tv,alt="l")

</code></pre>

<hr>
<h2 id='funsZnnref'>Z Tests for NN Reflexivity</h2><span id='topic+funsZnnref'></span><span id='topic+Znnref.ct'></span><span id='topic+Znnref'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnref.ct</code> and <code>Znnref</code>.
</p>
<p>Both functions are objects of class <code>"refhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the
diagonal cell counts (i.e., entries) under RL or CSR in the RCT for <code class="reqn">k \ge 2</code> classes.
That is, each test performs NN reflexivity test (i.e., a test of self reflexivity and a test of
mixed non-reflexivity, corresponding to entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code>, respectively, in the RCT) which is
appropriate (i.e., have the appropriate asymptotic sampling distribution) for completely mapped data.
(See Ceyhan and Bahadir (2017) for more detail).
</p>
<p>The reflexivity test is based on the normal approximation of the diagonal entries
in the RCT and are due to Ceyhan and Bahadir (2017).
</p>
<p>Each function yields the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), confidence intervals and sample estimates (i.e., observed values)for the
self reflexivity and mixed non-reflexivity values (i.e., entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code> values, respectively)
in the RCT. Each function also gives names of the test statistics, null values, the description of the test, and the data
set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{11})=R P_{aa}</code> and <code class="reqn">E(N_{22})=R P_{ab}</code> in the RCT, where <code class="reqn">R</code> is the number of reflexive
NNs and <code class="reqn">P_{aa}</code> is the probability of any two points selected are being from the same class
and <code class="reqn">P_{ab}</code> is the probability of any two points selected are being from two different classes.
</p>
<p>The <code>Znnref</code> functions (i.e., <code>Znnref.ct</code> and <code>Znnref</code>) are different from 
the <code>Znnself</code> functions (i.e., <code><a href="#topic+Znnself.ct">Znnself.ct</a></code> and <code><a href="#topic+Znnself">Znnself</a></code>) and 
from <code>Zself.ref</code> functions (i.e., <code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code> and <code><a href="#topic+Zself.ref">Zself.ref</a></code>), and also
from <code>Znnself.sum</code> functions (i.e., <code>Znnself.sum.ct</code> and <code>Znnself.sum</code>).
<code>Znnref</code> functions are for testing the self reflexivity and mixed non-reflexivity
using the diagonal entries in the RCT while <code>Znnself</code> functions are testing the self reflexivity at a
class-specific level (i.e., for each class) using the first column in the SCCT, and
<code>Zself.ref</code> functions are for testing the self reflexivity for the entire data set
using entry <code class="reqn">(1,1)</code> in RCT, and <code>Znnself.sum</code> functions are testing the cumulative species correspondence using
the sum of the self column (i.e., the first column) in the SCCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnref.ct(
  rfct,
  nvec,
  Qv,
  Tv,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnref(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnref_+3A_rfct">rfct</code></td>
<td>
<p>An RCT, used in <code>Znnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_nvec">nvec</code></td>
<td>
<p>The <code>vector</code> of class sizes, used in <code>Znnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_qv">Qv</code></td>
<td>
<p>The number of shared NNs, used in <code>Znnref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_tv">Tv</code></td>
<td>
<p><code class="reqn">T</code> value, which is the number of triplets <code class="reqn">(z_i, z_j, z_k)</code> with 
&quot;<code class="reqn">NN(z_i) = NN(z_j) = z_k</code> and <code class="reqn">NN(z_k) = z_j</code> where <code class="reqn">NN(\cdot)</code> is the nearest neighbor function, used in <code>Znnref.ct</code> only.</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnref</code> only</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnref</code> only</p>
</td></tr>
<tr><td><code id="funsZnnref_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>Znnref</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistics for self reflexivity and mixed non-reflexivity, corresponding to entries
<code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code> in the RCT</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-values for self reflexivity and mixed non-reflexivity tests</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence intervals for the self reflexivity and mixed non-reflexivity values
(i.e., diagonal entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code> values, respectively) in the RCT at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the onfidence intervals of the diagonal entries, provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., the observed diagonal entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code>
in the RCT, <code>rfct</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the self reflexivity and mixed non-reflexivity values
(i.e., expected values of the diagonal entries <code class="reqn">(1,1)</code> and <code class="reqn">(2,2)</code> values, 
which are <code class="reqn">E(N_{11})=R P_{aa}</code> and <code class="reqn">E(N_{22})=R P_{ab}</code>, respectively) in the RCT.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>rfct</code>, returned by <code>Znnref.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Znnref</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnself.ct">Znnself.ct</a></code>, <code><a href="#topic+Znnself">Znnself</a></code>, <code><a href="#topic+Zmixed.nonref.ct">Zmixed.nonref.ct</a></code>,
<code><a href="#topic+Zmixed.nonref">Zmixed.nonref</a></code>, <code><a href="#topic+Xsq.nnref.ct">Xsq.nnref.ct</a></code> and <code><a href="#topic+Xsq.nnref">Xsq.nnref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
Tv&lt;-Tval(W,Rv)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Znnref(Y,cls)
Znnref(Y,cls,method="max")

Znnref.ct(rfct,nvec,Qv,Tv)
Znnref.ct(rfct,nvec,Qv,Tv,alt="g")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
R&lt;-Rval(W)
Tv&lt;-Tval(W,R)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Znnref(Y,cls,alt="g")

Znnref.ct(rfct,nvec,Qv,Tv)
Znnref.ct(rfct,nvec,Qv,Tv,alt="l")

</code></pre>

<hr>
<h2 id='funsZnnself'>Self-Reflexivity Tests with Normal Approximation</h2><span id='topic+funsZnnself'></span><span id='topic+Znnself.ct'></span><span id='topic+Znnself'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnself.ct</code> and <code>Znnself</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the self entries (i.e., first column)
in a species correspondence contingency table (SCCT) or the expected values of the diagonal entries <code class="reqn">N_{ii}</code> in
an NNCT to the ones under RL or CSR.
That is, each performs NN self reflexivity for each class test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
NN self reflexivity is for each class can be viewed as a decomposition of species correspondence for
each class.
(See Ceyhan (2018) for more detail).
</p>
<p>Each test is based on the normal approximation of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT and
are due to (Ceyhan 2018).
</p>
<p>Each function yields a <code>vector</code> of length <code class="reqn">k</code> of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, null values (i.e., expected values), sample estimates (i.e., observed values) of self entries 
in the SCCT or diagonal entries in the NNCT, a <code class="reqn">k \times 2</code> matrix of confidence intervals (where each row is the
confidence interval for self entry <code class="reqn">S_i</code> in the SCCT or diagonal entry <code class="reqn">N_{ii}</code> in the NNCT) and
also names of the test statistics, estimates, null values, the description of the test, and the data
set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E[S_i] = E[N_{ii}] = n_i(n_i - 1)/(n - 1)</code> where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and
<code class="reqn">n</code> is the data size.
</p>
<p>The <code>Znnself</code> functions (i.e., <code>Znnself.ct</code> and <code>Znnself</code>) are different from the <code>Znnref</code> functions 
(i.e., <code><a href="#topic+Znnref.ct">Znnref.ct</a></code> and <code><a href="#topic+Znnref">Znnref</a></code>) and from <code>Zself.ref</code> functions (i.e., <code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code> and <code><a href="#topic+Zself.ref">Zself.ref</a></code>) and also from
<code>Znnself.sum</code> functions (i.e., <code>Znnself.sum.ct</code> and <code>Znnself.sum</code>).
<code>Znnself</code> functions are testing the self reflexivity at a class-specific level (i.e., for each class) using the
first column in the SCCT, while <code>Zself.ref</code> functions are for testing the self reflexivity for the entire data set
using entry <code class="reqn">(1,1)</code> in RCT, and <code>Znnref</code> functions are for testing the self reflexivity and mixed non-reflexivity
using the diagonal entries in the RCT, and
<code>Znnself.sum</code> functions are testing the cumulative species correspondence using the sum of the self column (i.e.,
the first column) in the SCCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnself.ct(
  ct,
  VarNii,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnself(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnself_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT, used in <code>Znnself.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_varnii">VarNii</code></td>
<td>
<p>The variance vector of differences of self entries in the SCCT or diagonal entries in the NNCT,
used in <code>Znnself.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the self entries in the SCCT or diagonal entries in the NNCT</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnself</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnself</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnself</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>vector</code> (of length k) of <code class="reqn">Z</code> test statistics for NN self reflexivity test</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>vector</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Lower and Upper Confidence Levels, it is <code>NULL</code> here since we provide confidence intervals
as a <code class="reqn">k \times 2</code> matrix.</p>
</td></tr> 
<tr><td><code>conf.int</code></td>
<td>
<p>The <code class="reqn">k \times 2</code> matrix of confidence intervals for the estimates, (where each row is the
confidence interval for self entry <code class="reqn">S_i</code> in the SCCT or diagonal entry <code class="reqn">N_{ii}</code> in the NNCT).</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the confidence intervals (i.e., conf.level) for the self entries in the SCCT or
diagonal entries in the NNCT.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The <code>vector</code> of estimates of the parameters, i.e., observed values of self entries 
in the SCCT or diagonal entries in the NNCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, both are same in this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>The <code>vector</code> of null values of the parameters, i.e., expected values of self entries 
in the SCCT or diagonal entries in the NNCT under RL or CSR.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Znnself.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Znnself</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code>, <code><a href="#topic+Zself.ref">Zself.ref</a></code>, <code><a href="#topic+Znnref.ct">Znnref.ct</a></code>,
<code><a href="#topic+Znnref">Znnref</a></code>, <code><a href="#topic+Xsq.spec.cor">Xsq.spec.cor</a></code> and <code><a href="#topic+Xsq.spec.cor.ct">Xsq.spec.cor.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
VarN.diag&lt;-varNii.ct(ct,Qv,Rv)

Znnself(Y,cls)
Znnself(Y,cls,alt="g")

Znnself.ct(ct,VarN.diag)
Znnself.ct(ct,VarN.diag,alt="g")

Znnself(Y,cls,method="max")

ct&lt;-scct(ipd,cls)
Znnself.ct(ct,VarN.diag)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Znnself(Y,fcls)
Znnself.ct(ct,VarN.diag)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
VarN.diag&lt;-varNii.ct(ct,Qv,Rv)

Znnself(Y,cls,alt="l")
Znnself.ct(ct,VarN.diag)
Znnself.ct(ct,VarN.diag,alt="l")

</code></pre>

<hr>
<h2 id='funsZnnself.sum'>Cumulative Species Correspondence Test with Normal Approximation</h2><span id='topic+funsZnnself.sum'></span><span id='topic+Znnself.sum.ct'></span><span id='topic+Znnself.sum'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnself.sum.ct</code> and <code>Znnself.sum</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected value of the sum of the self entries (i.e.
first column) in a species correspondence contingency table (SCCT) or the expected values of the sum of the 
diagonal entries <code class="reqn">N_{ii}</code> in an NNCT to the one under RL or CSR.
That is, each performs a cumulative species correspondence test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2018) for more detail).
</p>
<p>Each test is based on the normal approximation of the sum of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the sum of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT and
are due to (Ceyhan 2018).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, sample estimate (i.e., observed value) and null (i.e., expected) value for the
sum of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the sum of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT, 
and method and name of the data set used.
</p>
<p>The null hypothesis is that all 
<code class="reqn">E[S] = \sum_{i=1}^k n_i(n_i - 1)/(n - 1)</code> where <code class="reqn">S</code> is the sum of the self column
in the SCCT, <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and <code class="reqn">n</code> is the data size. 
</p>
<p>The <code>Znnself.sum</code> functions (i.e., <code>Znnself.sum.ct</code> and <code>Znnself.sum</code>) are different from the Znnself
functions (i.e., <code>Znnself.ct</code> and <code>Znnself</code>), and from the <code>Znnref</code> functions 
(i.e., <code><a href="#topic+Znnref.ct">Znnref.ct</a></code> and <code><a href="#topic+Znnref">Znnref</a></code>) and also from <code>Zself.ref</code> functions (i.e., <code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code> and <code><a href="#topic+Zself.ref">Zself.ref</a></code>).
<code>Znnself.sum</code> functions are testing the cumulative species correspondence using the sum of the self column (i.e.,
the first column) in the SCCT, while <code>Znnself</code> functions are testing the self reflexivity at a class-specific level (i.e., for each class) using the
first column in the SCCT, while <code>Zself.ref</code> functions are for testing the self reflexivity for the entire data set
using entry <code class="reqn">(1,1)</code> in RCT, and <code>Znnref</code> functions are for testing the self reflexivity and mixed non-reflexivity
using the diagonal entries in the RCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnself.sum.ct(
  ct,
  covSC,
  nnct = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnself.sum(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnself.sum_+3A_ct">ct</code></td>
<td>
<p>The NNCT or SCCT, used in <code>Znnself.sum.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_covsc">covSC</code></td>
<td>
<p>The covariance matrix for the self entries (i.e., first column) in the SCCT
or the diagonal entries in the NNCT, used in <code>Znnself.sum.ct</code> only. Usually output of the functions 
<code><a href="#topic+covNii.ct">covNii.ct</a></code> or <code><a href="#topic+covNii">covNii</a></code>.</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_nnct">nnct</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). If <code>TRUE</code>, <code>x</code> is taken to be the <code class="reqn">k \times k</code> NNCT, 
and if <code>FALSE</code>, <code>x</code> is taken to be the IPD matrix, used in <code>Znnself.sum.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the self entries in the SCCT or diagonal entries in the NNCT</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnself.sum</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnself.sum</code> only</p>
</td></tr>
<tr><td><code id="funsZnnself.sum_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnself.sum</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the overall species correspondence test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the sum of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the sum of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the observed sum of the self entries (i.e., first column)
in a species correspondence contingency table (SCCT) or the sum of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the sum of the self entries (i.e., first column) in a
species correspondence contingency table (SCCT) or the sum of the diagonal entries <code class="reqn">N_{ii}</code> in an NNCT
which is <code class="reqn">E[S] = \sum_{i=1}^k n_i(n_i - 1)/(n - 1)</code> where <code class="reqn">S</code> is the sum of the self column
in the SCCT, <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and <code class="reqn">n</code> is the data size.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Znnself.sum.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Znnself.sum</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2018).
&ldquo;A contingency table approach based on nearest neighbor relations for testing self and mixed correspondence.&rdquo;
<em>SORT-Statistics and Operations Research Transactions</em>, <b>42(2)</b>, 125-158.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnself.ct">Znnself.ct</a></code>, <code><a href="#topic+Znnself">Znnself</a></code>, <code><a href="#topic+Znnref.ct">Znnref.ct</a></code>, <code><a href="#topic+Znnref">Znnref</a></code>,
<code><a href="#topic+Zself.ref.ct">Zself.ref.ct</a></code> and <code><a href="#topic+Zself.ref">Zself.ref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-scct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
cv&lt;-covNii.ct(ct,vsq,Qv,Rv)

Znnself.sum(Y,cls)

Znnself.sum.ct(ct,cv)
Znnself.sum.ct(ct,cv,alt="g")

Znnself.sum(Y,cls,method="max")

ct&lt;-nnct(ipd,cls)
Znnself.sum.ct(ct,cv,nnct = TRUE)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-scct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

vsq&lt;-varNii.ct(ct,Qv,Rv)
cv&lt;-covNii.ct(ct,vsq,Qv,Rv)

Znnself.sum(Y,cls)

Znnself.sum.ct(ct,cv)
Znnself.sum.ct(ct,cv,alt="g")

ct&lt;-nnct(ipd,cls)
Znnself.sum.ct(ct,cv,nnct = TRUE)

Znnself.sum(Y,cls,alt="g")

</code></pre>

<hr>
<h2 id='funsZnnsym.dx'>Dixon's Pairwise NN Symmetry Test with Normal Approximation</h2><span id='topic+funsZnnsym.dx'></span><span id='topic+Znnsym.dx.ct'></span><span id='topic+Znnsym.dx'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnsym.dx.ct</code> and <code>Znnsym.dx</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the off-diagonal 
cell counts (i.e., entries) for each pair <code class="reqn">i,j</code> of classes under RL or CSR in the NNCT for <code class="reqn">k \ge 2</code> classes.
That is, each performs Dixon's NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Dixon (1994); Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the normal approximation of the difference of the off-diagonal entries
in the NNCT and are due to Dixon (1994).
</p>
<p>Each function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), lower and upper confidence levels and sample estimates (i.e., observed values)
for the <code class="reqn">N_{ij}-N_{ji}</code> values for <code class="reqn">i \ne j</code> (all in the upper-triangular form except for the null value, which is 0
for all pairs) and also names of the test statistics, estimates, null values, the description of the test, and the data
set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT (i.e., symmetry in the 
mixed NN structure) for <code class="reqn">k \ge 2</code>.
In the output, the test statistic, <code class="reqn">p</code>-value and the lower and upper confidence limits are valid  
for completely mapped data.
</p>
<p>See also
(Dixon (1994); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym.dx.ct(
  ct,
  varS,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnsym.dx(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnsym.dx_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Znnsym.dx.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_vars">varS</code></td>
<td>
<p>The variance vector of differences of off-diagonal cell counts in NNCT, <code>ct</code> , usually output 
of var.nnsym function.</p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{ij}-N_{ji}</code></p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnsym.dx</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnsym.dx</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.dx_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnsym.dx</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">Z</code> test statistics for Dixon's NN symmetry test
(in the upper-triangular form)</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative
(in the upper-triangular form)</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of Lower and Upper Confidence Levels (in the upper-triangular form) for the <code class="reqn">N_{ij}-N_{ji}</code>
values for <code class="reqn">i \ne j</code> at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits (i.e., conf.level) of the differences of the
off-diagonal entries.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., matrix of the difference of the off-diagonal entries
(in the upper-triangular form) of the <code class="reqn">k \times k</code> NNCT, <code class="reqn">N_{ij}-N_{ji}</code> for <code class="reqn">i \ne j</code>.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{ij})-E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Znnsym.dx.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Znnsym.dx</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym2cl.dx.ct">Znnsym2cl.dx.ct</a></code>, <code><a href="#topic+Znnsym2cl.dx">Znnsym2cl.dx</a></code>, <code><a href="#topic+Znnsym.ss.ct">Znnsym.ss.ct</a></code>,
<code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>, <code><a href="#topic+Xsq.nnsym.dx.ct">Xsq.nnsym.dx.ct</a></code> and <code><a href="#topic+Xsq.nnsym.dx">Xsq.nnsym.dx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

varS&lt;-var.nnsym(covN)

Znnsym.dx(Y,cls)
Znnsym.dx.ct(ct,varS)

Znnsym.dx(Y,cls,method="max")

Znnsym.dx(Y,cls,alt="g")
Znnsym.dx.ct(ct,varS,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Znnsym.dx(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

varS&lt;-var.nnsym(covN)

Znnsym.dx(Y,cls)
Znnsym.dx.ct(ct,varS)

</code></pre>

<hr>
<h2 id='funsZnnsym.ss'>Pielou's Pairwise NN Symmetry Test with Normal Approximation (for Sparse Sampling)</h2><span id='topic+funsZnnsym.ss'></span><span id='topic+Znnsym.ss.ct'></span><span id='topic+Znnsym.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnsym.ss.ct</code> and <code>Znnsym.ss</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected values of the off-diagonal 
cell counts (i.e., entries) for each pair <code class="reqn">i,j</code> of classes under RL or CSR in the NNCT for <code class="reqn">k \ge 2</code> classes.
That is, each performs Pielou's first type of NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
provided that data is obtained by sparse sampling.
(See Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the normal approximation of the differences of the off-diagonal entries
in the NNCT and are due to Pielou (1961).
</p>
<p>Each function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values, lower and upper confidence levels, sample estimates (i.e., observed values)
and null value(s) (i.e., expected values) for the
<code class="reqn">N_{ij}-N_{ji}</code> values for <code class="reqn">i \ne j</code> (all in the upper-triangular form except for the null value, which is 0 for all
pairs) and also names of the test statistics, estimates, null values, the description of the test, and the data
set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT (i.e., symmetry in the 
mixed NN structure) for <code class="reqn">k \ge 2</code>.
In the output, the test statistic, <code class="reqn">p</code>-value and the lower and upper confidence limits are valid only 
for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym.ss.ct(
  ct,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnsym.ss(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnsym.ss_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Znnsym.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.ss_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnsym.ss_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{ij}-N_{ji}</code></p>
</td></tr>
<tr><td><code id="funsZnnsym.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnsym.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnsym.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnsym.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">Z</code> test statistics for Pielou's first type of NN symmetry test
(in the upper-triangular form)</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative
(in the upper-triangular form)</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of Lower and Upper Confidence Levels (in the upper-triangular form) for the <code class="reqn">N_{ij}-N_{ji}</code>
values for <code class="reqn">i \ne j</code> at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits (i.e., conf.level) of the differences of the
off-diagonal entries.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., matrix of the difference of the off-diagonal entries 
(in the upper-triangular form) of the <code class="reqn">k \times k</code> NNCT, <code class="reqn">N_{ij}-N_{ji}</code> for <code class="reqn">i \ne j</code>.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{ij})-E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Znnsym.ss.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Znnsym.ss</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>, <code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code>, <code><a href="#topic+Znnsym2cl.ss.ct">Znnsym2cl.ss.ct</a></code> and
<code><a href="#topic+Znnsym2cl.ss">Znnsym2cl.ss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

Znnsym.ss(Y,cls)
Znnsym.ss.ct(ct)

Znnsym.ss(Y,cls,method="max")

Znnsym.ss(Y,cls,alt="g")
Znnsym.ss.ct(ct,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Znnsym.ss(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

Znnsym.ss(Y,cls)
Znnsym.ss.ct(ct)

</code></pre>

<hr>
<h2 id='funsZnnsym2cl.dx'>Dixon's NN Symmetry Test with Normal Approximation for Two Classes</h2><span id='topic+funsZnnsym2cl.dx'></span><span id='topic+Znnsym2cl.dx.ct'></span><span id='topic+Znnsym2cl.dx'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnsym2cl.dx.ct</code> and <code>Znnsym2cl.dx</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs the hypothesis test of equality of the expected value of the off-diagonal 
cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k=2</code> classes.
That is, each performs Dixon's NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
(See Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the normal approximation of the difference of the off-diagonal entries
in the NNCT and are due to Dixon (1994).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, estimate and null value for the parameter of interest
(which is the difference of the off-diagonal entries in the NNCT), and method and name of the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{12})=E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT (i.e., symmetry in the 
mixed NN structure).
</p>
<p>See also
(Dixon (1994); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym2cl.dx.ct(
  ct,
  Q,
  R,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnsym2cl.dx(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnsym2cl.dx_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Znnsym2cl.dx.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_q">Q</code></td>
<td>
<p>The number of shared NNs, used in <code>Znnsym2cl.dx.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs (i.e., twice the number of reflexive NN pairs),
used in <code>Znnsym2cl.dx.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnsym2cl.dx</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnsym2cl.dx</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.dx_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnsym2cl.dx</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for Pielou's first type of NN symmetry test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code> in the <code class="reqn">2 \times 2</code> NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate, i.e., the difference of the off-diagonal entries of the <code class="reqn">2 \times 2</code> NNCT, <code class="reqn">N_{12}-N_{21}</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{12})-E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, or name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym2cl.ss.ct">Znnsym2cl.ss.ct</a></code>, <code><a href="#topic+Znnsym2cl.ss">Znnsym2cl.ss</a></code>, <code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>,
<code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code>, <code><a href="#topic+Xsq.nnsym.dx.ct">Xsq.nnsym.dx.ct</a></code> and <code><a href="#topic+Xsq.nnsym.dx">Xsq.nnsym.dx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)

Znnsym2cl.dx(Y,cls)
Znnsym2cl.dx.ct(ct,Qv,Rv)

Znnsym2cl.dx(Y,cls,method="max")

Znnsym2cl.dx(Y,cls,alt="g")
Znnsym2cl.dx.ct(ct,Qv,Rv,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Znnsym2cl.dx(Y,fcls)

#############
ct&lt;-matrix(sample(1:20,4),ncol=2)
Znnsym2cl.dx.ct(ct,Qv,Rv) #gives an error message if ct&lt;-matrix(sample(1:20,9),ncol=3)
#here, Qv and Rv values are borrowed from above, to highlight a point

</code></pre>

<hr>
<h2 id='funsZnnsym2cl.ss'>Pielou's First Type of NN Symmetry Test with Normal Approximation for Two Classes
(for Sparse Sampling)</h2><span id='topic+funsZnnsym2cl.ss'></span><span id='topic+Znnsym2cl.ss.ct'></span><span id='topic+Znnsym2cl.ss'></span>

<h3>Description</h3>

<p>Two functions: <code>Znnsym2cl.ss.ct</code> and <code>Znnsym2cl.ss</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of equality of the expected value of the off-diagonal 
cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k=2</code> classes.
That is, each performs Pielou's first type of NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
provided that data is obtained by sparse sampling.
(See Ceyhan (2014) for more detail).
</p>
<p>Each symmetry test is based on the normal approximation of the difference of the off-diagonal entries
in the NNCT and are due to Pielou (1961).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, estimate and null value for the parameter of interest
(which is the difference of the off-diagonal entries in the NNCT), and method and name of the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{12})=E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT (i.e., symmetry in the 
mixed NN structure).
In the output, the test statistic, <code class="reqn">p</code>-value and the confidence interval are valid only 
for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym2cl.ss.ct(
  ct,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Znnsym2cl.ss(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZnnsym2cl.ss_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Znnsym2cl.ss.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.ss_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.ss_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.ss_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Znnsym2cl.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.ss_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Znnsym2cl.ss</code> only</p>
</td></tr>
<tr><td><code id="funsZnnsym2cl.ss_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Znnsym2cl.ss</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for Pielou's first type of NN symmetry test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code> in the <code class="reqn">2 \times 2</code> NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate, i.e., the difference of the off-diagonal entries of the <code class="reqn">2 \times 2</code> NNCT, <code class="reqn">N_{12}-N_{21}</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{12})-E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, or name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Xsq.nnsym.ss.ct">Xsq.nnsym.ss.ct</a></code>, <code><a href="#topic+Xsq.nnsym.ss">Xsq.nnsym.ss</a></code>, <code><a href="#topic+Znnsym.ss.ct">Znnsym.ss.ct</a></code> and
<code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

Znnsym2cl.ss(Y,cls)
Znnsym2cl.ss.ct(ct)

Znnsym2cl.ss(Y,cls,method="max")

Znnsym.ss.ct(ct)

Znnsym2cl.ss(Y,cls,alt="g")
Znnsym2cl.ss.ct(ct,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Znnsym2cl.ss(Y,fcls)

#############
ct&lt;-matrix(sample(1:20,4),ncol=2)
Znnsym2cl.ss.ct(ct) #gives an error message if ct&lt;-matrix(sample(1:20,9),ncol=3)

</code></pre>

<hr>
<h2 id='funsZseg.coeff'>Z Tests for Segregation Coefficients</h2><span id='topic+funsZseg.coeff'></span><span id='topic+Zseg.coeff.ct'></span><span id='topic+Zseg.coeff'></span>

<h3>Description</h3>

<p>Two functions: <code>Zseg.coeff.ct</code> and <code>Zseg.coeff</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
segregation coefficients from their expected values under RL or CSR for each segregation coefficient
in the NNCT.
</p>
<p>The test for each cell <code class="reqn">i,j</code> is based on the normal approximation of the corresponding segregation coefficient.
That is, each performs the segregation coefficient tests which are appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data.
The segregation coefficients in the multi-class case are the extension of Pielou's segregation coefficient
for the two-class case.
(See Ceyhan (2014) for more detail).
</p>
<p>Each function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, lower and upper confidence levels, sample estimates (i.e., observed values) and null value
(i.e., expected value, which is 0) for the segregation coefficients
and also names of the test statistics, estimates, null value, the description of the test, and the data set used.
</p>
<p>The null hypothesis for each cell <code class="reqn">i,j</code> is that the corresponding segregation coefficient equal to the expected value
(which is 0) under RL or CSR.
</p>
<p>See also (Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zseg.coeff.ct(
  ct,
  VarSC,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zseg.coeff(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZseg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, used in <code>Zseg.coeff.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_varsc">VarSC</code></td>
<td>
<p>The variance matrix for the segregation coefficients in the NNCT, <code>ct</code>; used in <code>Zseg.coeff.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, for the segregation 
coefficients</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zseg.coeff</code> only</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zseg.coeff</code> only</p>
</td></tr>
<tr><td><code id="funsZseg.coeff_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
used in <code>Zseg.coeff</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of test statistics for the segregation coefficients</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels for the segregation coefficients at the given
confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for segregation coefficients, it is <code>NULL</code> here since we provide the upper 
and lower confidence limits as <code class="reqn">k \times k</code> matrices.</p>
</td></tr> 
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits of the segregation coefficients,
provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., matrix of the observed segregation coefficients</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, both are same in this function</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the parameters, i.e., expected values of the segregation 
coefficients, which are all 0 under RL or CSR.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null value</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, returned by <code>Zseg.coeff.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zseg.coeff</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.coeff">seg.coeff</a></code> and <code><a href="#topic+Zseg.ind">Zseg.ind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

varT&lt;-var.seg.coeff(ct,covN)

Zseg.coeff(Y,cls)
Zseg.coeff.ct(ct,varT)

Zseg.coeff(Y,cls,method="max")

Zseg.coeff(Y,cls,alt="g")
Zseg.coeff.ct(ct,varT,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

Zseg.coeff.ct(ct,varT)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

varT&lt;-var.seg.coeff(ct,covN)

Zseg.coeff(Y,cls)
Zseg.coeff.ct(ct,varT)

Zseg.coeff(Y,cls,alt="g")
Zseg.coeff.ct(ct,varT,alt="g")

</code></pre>

<hr>
<h2 id='funsZsegind'>Z Tests for Segregation Indices</h2><span id='topic+funsZsegind'></span><span id='topic+Zseg.ind.ct'></span><span id='topic+Zseg.ind'></span>

<h3>Description</h3>

<p>Two functions: <code>Zseg.ind.ct</code> and <code>Zseg.ind</code>.
</p>
<p>Both functions are objects of class <code>"cellhtest"</code> 
but with different arguments (see the parameter list below).
Each one performs hypothesis tests of deviations of 
segregation indices from their expected values 
under RL or CSR for each segregation index in the NNCT.
The test for each cell <code class="reqn">i,j</code> is based on the normal approximation 
of the corresponding segregation index.
</p>
<p>Each function yields a contingency table of the test statistics, 
<code class="reqn">p</code>-values for the corresponding 
alternative, lower and upper confidence levels, 
sample estimates (i.e., observed values) and 
null value(s) (i.e., expected values) for the segregation indices
and also names of the test statistics, estimates, 
null value, the description of the test, and the data set used.
</p>
<p>The null hypothesis for each cell <code class="reqn">i,j</code> is 
that the corresponding segregation index 
equal to the expected value (which is 0) under RL or CSR.
</p>
<p>See also (Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zseg.ind.ct(
  ct,
  varN,
  inf.corr = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zseg.ind(
  dat,
  lab,
  inf.corr = FALSE,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZsegind_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table, 
used in <code>Zseg.ind.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_varn">varN</code></td>
<td>
<p>The variance matrix for cell counts in the NNCT, 
<code>ct</code>; used in <code>Zseg.ind.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_inf.corr">inf.corr</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>). 
If <code>TRUE</code>, indices are modified so that 
they are finite and 
if <code>FALSE</code> the above definition in the description is used.</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, 
default is <code>0.95</code>, for the segregation indices</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, 
each row corresponds to a data point,
used in <code>Zseg.ind</code> only</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), 
used in <code>Zseg.ind</code> only</p>
</td></tr>
<tr><td><code id="funsZsegind_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function,
used in <code>Zseg.ind</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of test statistics 
for the segregation indices</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values 
for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of lower and upper confidence levels for 
the segregation indices at the given confidence
level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper 
and lower confidence limits of the segregation indices,
provided in <code>conf.level</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, 
i.e., matrix of the observed segregation indices</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates,
both are same in this function</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized values for the parameters, 
i.e., the null values of the segregation indices, 
which are all 0 under RL or CSR.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null value</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, 
one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>ct</code>, 
returned by <code>Zseg.ind.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, 
returned by <code>Zseg.ind</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.ind">seg.ind</a></code> and <code><a href="#topic+Zseg.coeff">Zseg.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

seg.ind(ct)
seg.ind(ct,inf.corr=TRUE)
W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
varN

Zseg.ind(Y,cls)
Zseg.ind(Y,cls,inf.corr=TRUE)
Zseg.ind.ct(ct,varN)

Zseg.ind(Y,cls,alt="g")
Zseg.ind.ct(ct,varN,alt="g")

Zseg.ind(Y,cls,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Zseg.ind(Y,cls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
varN

Zseg.ind(Y,cls)
Zseg.ind(Y,cls,inf.corr = TRUE)

Zseg.ind.ct(ct,varN)
Zseg.ind.ct(ct,varN,inf.corr = TRUE)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

Zseg.ind(X,cls)
Zseg.ind.ct(ct,varN)
Zseg.ind.ct(ct,varN,inf.corr=TRUE)

</code></pre>

<hr>
<h2 id='funsZself.ref'>Self-Reflexivity Test with Normal Approximation</h2><span id='topic+funsZself.ref'></span><span id='topic+Zself.ref.ct'></span><span id='topic+Zself.ref'></span>

<h3>Description</h3>

<p>Two functions: <code>Zself.ref.ct</code> and <code>Zself.ref</code>.
</p>
<p>Both functions are objects of class <code>"htest"</code> but with different arguments (see the parameter list below).
Each one performs hypothesis tests of self reflexivity in the NN structure using the
number of self-reflexive NN pairs (i.e., the first diagonal entry, <code class="reqn">(1,1)</code>) in the RCT for <code class="reqn">k \ge 2</code> classes.
That is, each test performs a test of self reflexivity corresponding to entry <code class="reqn">(1,1)</code> in the RCT)
which is appropriate (i.e., have the appropriate asymptotic sampling distribution) for completely mapped data.
(See Ceyhan and Bahadir (2017) for more detail).
</p>
<p>The self reflexivity test is based on the normal approximation of the diagonal entry <code class="reqn">(1,1)</code>
in the RCT and are due to Ceyhan and Bahadir (2017).
</p>
<p>Each function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, sample estimate (i.e., observed value) and null (i.e., expected) value for the
self reflexivity value (i.e., diagonal entry <code class="reqn">(1,1)</code> value, respectively) in the RCT, 
and method and name of the data set used.
</p>
<p>The null hypothesis is that <code class="reqn">E(N_{11})=R P_{aa}</code> in the RCT, where <code class="reqn">R</code> is the number of reflexive
NNs and <code class="reqn">P_{aa}</code> is the probability of any two points selected are being from the same class.
</p>
<p>The <code>Zself.ref</code> functions (i.e., <code>Zself.ref.ct</code> and <code>Zself.ref</code>) are different from the <code>Znnref</code>
functions (i.e., <code><a href="#topic+Znnref.ct">Znnref.ct</a></code> and <code><a href="#topic+Znnref">Znnref</a></code>) and from <code>Znnself</code> functions (i.e., <code><a href="#topic+Znnself.ct">Znnself.ct</a></code> and <code><a href="#topic+Znnself">Znnself</a></code>), and also
from <code>Znnself.sum</code> functions (i.e., <code>Znnself.sum.ct</code> and <code>Znnself.sum</code>).
<code>Zself.ref</code> functions are for testing the self reflexivity for the entire data set
using entry <code class="reqn">(1,1)</code> in RCT while <code>Znnself</code> functions are testing the self reflexivity at a class-specific level
(i.e., for each class) using the first column in the SCCT, <code>Znnref</code> functions are for testing the self
reflexivity and mixed non-reflexivity using the diagonal entries in the RCT, and
<code>Znnself.sum</code> functions are testing the cumulative species correspondence using the sum of the self column (i.e.,
the first column) in the SCCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zself.ref.ct(
  rfct,
  nvec,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)

Zself.ref(
  dat,
  lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZself.ref_+3A_rfct">rfct</code></td>
<td>
<p>An RCT, used in <code>Zself.ref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_nvec">nvec</code></td>
<td>
<p>The <code>vector</code> of class sizes, used in <code>Zself.ref.ct</code> only</p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,
used in <code>Zself.ref</code> only</p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical), used in <code>Zself.ref</code> only</p>
</td></tr>
<tr><td><code id="funsZself.ref_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function, used in <code>Zself.ref</code> only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for self reflexivity corresponding to entry <code class="reqn">(1,1)</code> in the RCT</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the self reflexivity value (i.e., diagonal entry <code class="reqn">(1,1)</code> value)
in the RCT at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the observed diagonal entry <code class="reqn">(1,1)</code> in the RCT, <code>rfct</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the self reflexivity value (i.e., expected value of the 
diagonal entry <code class="reqn">(1,1)</code> which is <code class="reqn">E(N_{11})=R P_{aa}</code>) in the RCT.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>ct.name</code></td>
<td>
<p>Name of the contingency table, <code>rfct</code>, returned by <code>Zself.ref.ct</code> only</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, returned by <code>Zself.ref</code> only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnref.ct">Znnref.ct</a></code>, <code><a href="#topic+Znnref">Znnref</a></code>, <code><a href="#topic+Zmixed.nonref.ct">Zmixed.nonref.ct</a></code> and
<code><a href="#topic+Zmixed.nonref">Zmixed.nonref</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Zself.ref(Y,cls)
Zself.ref(Y,cls,method="max")

Zself.ref.ct(rfct,nvec)
Zself.ref.ct(rfct,nvec,alt="g")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

nvec&lt;-as.numeric(table(cls))
rfct&lt;-rct(ipd,cls)

Zself.ref(Y,cls,alt="g")

Zself.ref.ct(rfct,nvec)
Zself.ref.ct(rfct,nvec,alt="l")

</code></pre>

<hr>
<h2 id='funsZTkinv'>Z-Test for Cuzick and Edwards <code class="reqn">T_k^{inv}</code> statistic</h2><span id='topic+funsZTkinv'></span><span id='topic+ZTkinv'></span><span id='topic+ZTkinv.sim'></span>

<h3>Description</h3>

<p>Two functions: <code>ZTkinv</code> and <code>ZTkinv.sim</code>, each of which is an object of class <code>"htest"</code> performing a
<code class="reqn">z</code>-test for Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic. See <code><a href="#topic+ceTkinv">ceTkinv</a></code> for a description of 
<code class="reqn">T_k^{inv}</code> test statistic.
</p>
<p>The function <code>ZTkinv</code> performs a <code class="reqn">Z</code>-test for <code class="reqn">T_k^{inv}</code> using asymptotic normality with a simulation estimated
variance under RL of cases and controls to the given points.
And the function <code>ZTkinv.sim</code> performs test for<code class="reqn">T_k^{inv}</code> based on MC simulations under the RL hypothesis.
</p>
<p>Asymptotic normality for the <code class="reqn">T_k^{inv}</code> is not established yet, but this seems likely according to 
Cuzick and Edwards (1990). 
If asymptotic normality holds, it seems a larger sample size would be needed before this becomes
an effective approximation.
Hence the simulation-based test <code>ZTkinv.sim</code> is recommended for use to be safe. 
When <code>ZTkinv</code> is used, this is also highlighted with the warning &quot;asymptotic normality of <code class="reqn">T_k^{inv}</code> is not yet established, 
so, simulation-based test is recommended&quot;.
</p>
<p>All arguments are common for both functions, except for ..., Nvar.sim which are used in <code>ZTkinv</code> only,
and <code>Nsim</code>, which is used in <code>ZTkinv.sim</code> only.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly.
The argument <code>Nvar.sim</code> represents the number of resamplings (without replacement) in the
RL scheme, with default being <code>1000</code> for estimating the variance of <code class="reqn">T_k^{inv}</code> statistic in <code>ZTkinv</code>.
The argument <code>Nsim</code> represents the number of resamplings (without replacement) in the
RL scheme, with default being <code>1000</code> for estimating the <code class="reqn">T_k^{inv}</code> values in <code>ZTkinv.sim</code>.
</p>
<p>Both functions might take a very long time when data size is large or <code>Nsim</code> is large.
</p>
<p>See also (Cuzick and Edwards (1990)) and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZTkinv(
  dat,
  k,
  cc.lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  case.lab = NULL,
  Nvar.sim = 1000,
  ...
)

ZTkinv.sim(
  dat,
  k,
  cc.lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  case.lab = NULL,
  Nsim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funsZTkinv_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point, 
used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of the closest controls to subject <code class="reqn">i</code>, used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control, used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>,
used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for Cuzick and Edwards <code class="reqn">T_k^{inv}</code> statistic. Used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>, used in both functions.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_nvar.sim">Nvar.sim</code></td>
<td>
<p>The number of simulations, i.e., the number of resamplings under the RL scheme to estimate the 
variance of Tkinv, used in <code>ZTkinv</code> only.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function. Used in <code>ZTkinv</code> only.</p>
</td></tr>
<tr><td><code id="funsZTkinv_+3A_nsim">Nsim</code></td>
<td>
<p>The number of simulations, i.e., the number of resamplings under the RL scheme to estimate the 
<code class="reqn">T_k^{inv}</code> values, used in <code>ZTkinv.sim</code> only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative. In <code>ZTkinv</code>
this is computed using the standard normal distribution, while in <code>ZTkinv.sim</code>, it is based on which percentile
the observed <code class="reqn">T_k^{inv}</code> value is among the generated <code class="reqn">T_k^{inv}</code> values.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the Cuzick and Edwards <code class="reqn">T_k^{inv}</code> value
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
</table>
<p><code class="reqn">z</code>-critical values are used in the construction of the confidence interval in <code>ZTkinv</code>, 
while the percentile values are used in the generated sample of <code class="reqn">T_k^{inv}</code> values in <code>ZTkinv.sim</code> 
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the Cuzick and Edwards <code class="reqn">T_k^{inv}</code> value.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the Cuzick and Edwards <code class="reqn">T_k^{inv}</code> value
which is <code class="reqn">k n_1 (n_1-1)/(n_0+1)</code> under RL, where the number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code>.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTkinv">ceTkinv</a></code> and <code><a href="#topic+EV.Tkinv">EV.Tkinv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-10 #try also 20, 50, 100
set.seed(123)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
k&lt;-2

ZTkinv(Y,k,cls)
ZTkinv(Y,k,cls+1,case.lab = 2,alt="l")
#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ZTkinv(Y,k,fcls,case.lab="a")

n&lt;-10 #try also 20, 50, 100
set.seed(123)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
k&lt;-2 # try also 3,5

ZTkinv.sim(Y,k,cls)
ZTkinv.sim(Y,k,cls,conf=.9,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ZTkinv.sim(Y,k,fcls,case.lab="a")

#with k=1
ZTkinv.sim(Y,k=1,cls)
ZTrun(Y,cls)

</code></pre>

<hr>
<h2 id='ind.nnsym'>Index Matrix for Computing the Covariance of Dixon's Overall NN Symmetry Test</h2><span id='topic+ind.nnsym'></span>

<h3>Description</h3>

<p>Returns the index matrix for choosing the entries in the covariance matrix for NNCT 
used for computing the covariance for Dixon's NN symmetry test.
The matrix is <code class="reqn">k(k-1)/2 \times 2</code> with each row is the <code class="reqn">i,j</code> 
corresponding to <code class="reqn">N_{ij}</code> in the NNCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.nnsym(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.nnsym_+3A_k">k</code></td>
<td>
<p>An integer specifying the number of classes in the data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k(k-1)/2 \times 2</code> index matrix with each row is the <code class="reqn">i,j</code> 
corresponding to <code class="reqn">N_{ij}</code> in the NNCT
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.nnsym">cov.nnsym</a></code> and <code><a href="#topic+ind.seg.coeff">ind.seg.coeff</a></code>
</p>

<hr>
<h2 id='ind.seg.coeff'>Index Matrix for Computing the Covariance of Segregation Coefficients</h2><span id='topic+ind.seg.coeff'></span>

<h3>Description</h3>

<p>Returns the index matrix for choosing the entries in the covariance matrix for NNCT 
used for computing the covariance for the extension of Pielou's segregation coefficient to the multi-class
case. The matrix is <code class="reqn">k(k+1)/2 \times 2</code> with each row is the <code class="reqn">i,j</code> 
corresponding to <code class="reqn">N_{ij}</code> in the NNCT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.seg.coeff(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.seg.coeff_+3A_k">k</code></td>
<td>
<p>An integer specifying the number of classes in the data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code class="reqn">k(k+1)/2 \times 2</code> index matrix with each row is the <code class="reqn">i,j</code> 
corresponding to <code class="reqn">N_{ij}</code> in the NNCT
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cov.seg.coeff">cov.seg.coeff</a></code>, <code><a href="#topic+seg.coeff">seg.coeff</a></code> and <code><a href="#topic+ind.nnsym">ind.nnsym</a></code>
</p>

<hr>
<h2 id='ipd.mat'>Interpoint Distance Matrix</h2><span id='topic+ipd.mat'></span>

<h3>Description</h3>

<p>This function computes and returns the distance matrix computed 
by using the specified distance measure to
compute the distances between the rows of 
the set of points <code>x</code> and <code>y</code> using the 
<code><a href="stats.html#topic+dist">dist</a></code> function 
in the <code>stats</code> package of the standard R distribution.
If <code>y</code> is provided (default=<code>NULL</code>) it yields 
a matrix of distances between the rows of <code>x</code> and 
rows of <code>y</code>. Otherwise, it provides a square matrix 
with  <code class="reqn">i,j</code>-th entry being the distance between row 
<code class="reqn">i</code> and row <code class="reqn">j</code> of <code>x</code>.
This function is different from the <code><a href="stats.html#topic+dist">dist</a></code> function 
in the <code>stats</code> package.
<code>dist</code> returns the distance matrix in a lower triangular form, 
and <code>ipd.mat</code> returns in a full matrix.
... are for further arguments, such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipd.mat(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipd.mat_+3A_x">x</code></td>
<td>
<p>A set of points in matrix or data frame form 
where points correspond to the rows.</p>
</td></tr>
<tr><td><code id="ipd.mat_+3A_y">y</code></td>
<td>
<p>A set of points in matrix or data frame form 
where points correspond to the rows (default=<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="ipd.mat_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on the <code>dist</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix whose  <code class="reqn">i,j</code>-th entry is the distance 
between row <code class="reqn">i</code> of <code>x</code> and row <code class="reqn">j</code> of <code>y</code> 
if <code>y</code> is provided,
otherwise  <code class="reqn">i,j</code>-th entry is the distance between 
rows <code class="reqn">i</code> and <code class="reqn">j</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+ipd.mat.euc">ipd.mat.euc</a></code>, 
and <code><a href="#topic+dist.std.data">dist.std.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-3
X&lt;-matrix(runif(3*n),ncol=3)
mtd&lt;-"euclidean" #try also "maximum", "manhattan", "canberra", "binary"
ipd.mat(X,method=mtd)
ipd.mat(X,method="minkowski",p=6)

n&lt;-5
Y&lt;-matrix(runif(3*n),ncol=3)
ipd.mat(X,Y,method=mtd)
ipd.mat(X[1,],Y,method=mtd)
ipd.mat(c(.1,.2,.3),Y,method=mtd)
ipd.mat(X[1,],Y[3,],method=mtd)

#1D data points
X&lt;-as.matrix(runif(3)) # need to be entered as a matrix with one column 
#(i.e., a column vector), hence X&lt;-runif(3) would not work
ipd.mat(X)

Y&lt;-as.matrix(runif(5))
ipd.mat(X,Y)
ipd.mat(X[1,],Y)
ipd.mat(X[1,],Y[3,])

</code></pre>

<hr>
<h2 id='ipd.mat.euc'>Euclidean Interpoint Distance Matrix</h2><span id='topic+ipd.mat.euc'></span>

<h3>Description</h3>

<p>Returns the Euclidean interpoint distance (IPD) matrix of 
a given the set of points <code>x</code> and <code>y</code> using two for loops 
with the <code><a href="#topic+euc.dist">euc.dist</a></code> function of the current package.
If <code>y</code> is provided (default=<code>NULL</code>) 
it yields a matrix of Euclidean distances 
between the rows of <code>x</code> and rows of <code>y</code>,
otherwise it provides a square matrix with <code class="reqn">i,j</code>-th entry 
being the Euclidean distance between row <code class="reqn">i</code> and row <code class="reqn">j</code> of <code>x</code>. 
This function is different from 
the <code><a href="#topic+ipd.mat">ipd.mat</a></code> function in this package.
<code><a href="#topic+ipd.mat">ipd.mat</a></code> returns the full distance matrix 
for a variety of distance metrics (including the Euclidean metric),
while <code><a href="#topic+ipd.mat.euc">ipd.mat.euc</a></code> uses the Euclidean distance metric only.
<code>ipd.mat.euc(X)</code> and <code>ipd.mat(X)</code> yield 
the same output for a set of points <code>X</code>,
as the default metric in <code><a href="#topic+ipd.mat">ipd.mat</a></code> is also <code>"euclidean"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipd.mat.euc(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipd.mat.euc_+3A_x">x</code></td>
<td>
<p>A set of points in matrix or data frame form 
where points correspond to the rows.</p>
</td></tr>
<tr><td><code id="ipd.mat.euc_+3A_y">y</code></td>
<td>
<p>A set of points in matrix or data frame form 
where points correspond to the rows (default=<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A distance matrix whose  <code class="reqn">i,j</code>-th entry is 
the Euclidean distance between row <code class="reqn">i</code> of <code>x</code> and
row <code class="reqn">j</code> of <code>y</code> if <code>y</code> is provided, 
otherwise  <code class="reqn">i,j</code>-th entry is 
the Euclidean distance between rows <code class="reqn">i</code> and <code class="reqn">j</code> of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+ipd.mat.euc">ipd.mat.euc</a></code>, 
and <code><a href="#topic+dist.std.data">dist.std.data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-3
X&lt;-matrix(runif(3*n),ncol=3)
ipd.mat.euc(X)

n&lt;-5
Y&lt;-matrix(runif(3*n),ncol=3)
ipd.mat.euc(X,Y)
ipd.mat.euc(X[1,],Y)
ipd.mat.euc(c(.1,.2,.3),Y)
ipd.mat.euc(X[1,],Y[3,])

#1D data points
X&lt;-as.matrix(runif(3)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(3) would not work
ipd.mat.euc(X)

Y&lt;-as.matrix(runif(5))
ipd.mat.euc(X,Y)
ipd.mat.euc(X[1,],Y)
ipd.mat.euc(X[1,],Y[3,])

</code></pre>

<hr>
<h2 id='kNN'>Finding the indices of the <code>k</code> NNs of a given point</h2><span id='topic+kNN'></span>

<h3>Description</h3>

<p>Returns the indices of the <code>k</code> nearest neighbors of 
subject <code class="reqn">i</code> given data set or IPD matrix <code>x</code>.
Subject indices correspond to rows (i.e., rows <code>1:n</code> ) 
if <code>x</code> is the data set and to rows or columns
if <code>x</code> is the IPD matrix.  
</p>
<p>The argument <code>is.ipd</code> is a logical argument 
(default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kNN(x, i, k, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kNN_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or 
data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="kNN_+3A_i">i</code></td>
<td>
<p>index of (i.e., row number for) the subject 
whose NN is to be found.</p>
</td></tr>
<tr><td><code id="kNN_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>).</p>
</td></tr>
<tr><td><code id="kNN_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="kNN_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the indices (i.e., row numbers) of 
the <code>k</code> NNs of subject <code class="reqn">i</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NN">NN</a></code>, <code><a href="#topic+NNdist">NNdist</a></code>,
and <code><a href="#topic+NNdist2cl">NNdist2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
k&lt;-sample(1:5,1)
k
NN(ipd,1)
kNN(ipd,1,k)
kNN(Y,1,k,is.ipd = FALSE)
kNN(Y,1,k,is.ipd = FALSE,method="max")

NN(ipd,5)
kNN(ipd,5,k)
kNN(Y,5,k,is.ipd = FALSE)

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
kNN(ipd,3,k)

#with possible ties in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ny&lt;-nrow(Y)
ipd&lt;-ipd.mat(Y)
for (i in 1:ny)
  cat(i,":",kNN(ipd,i,k),"\n")

</code></pre>

<hr>
<h2 id='mat2vec'>Conversion of a Matrix to a Vector</h2><span id='topic+mat2vec'></span>

<h3>Description</h3>

<p>Converts the contingency table (or any matrix) <code>ct</code> to a <code>vector</code> 
by default row-wise (i.e., by appending
each row one after the other) or column-wise, 
and also returns the entry indices (in the original matrix <code>ct</code>)
in a <code class="reqn">k^2 \times 2</code> matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2vec(ct, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2vec_+3A_ct">ct</code></td>
<td>
<p>A matrix, in particular a contingency table</p>
</td></tr>
<tr><td><code id="mat2vec_+3A_byrow">byrow</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). 
If <code>TRUE</code>, rows of <code>ct</code> are appended to obtain the vector
and if <code>FALSE</code> columns of <code>ct</code> are appended to obtain the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>vec</code></td>
<td>
<p>The <code>vector</code>ized form the matrix <code>ct</code>, 
by default appending the rows of <code>ct</code></p>
</td></tr>
<tr><td><code>ind</code></td>
<td>
<p>The <code class="reqn">k^2 \times 2</code> matrix of 
entry indices (in the original matrix <code>ct</code>) 
whose i-th row corresponds to the i-th entry in <code>vec</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ind.nnsym">ind.nnsym</a></code> and <code><a href="#topic+ind.seg.coeff">ind.seg.coeff</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct
mat2vec(ct)
mat2vec(ct,byrow=FALSE)

#an arbitrary 3x3 matrix
M&lt;-matrix(sample(10:20,9),ncol=3)
M
mat2vec(M)
mat2vec(M,byrow=FALSE)

</code></pre>

<hr>
<h2 id='matrix.sqrt'>Square root of a matrix</h2><span id='topic+matrix.sqrt'></span>

<h3>Description</h3>

<p>Computes the square root of the matrix <code class="reqn">A</code>, where <code class="reqn">A</code> does not have to be a square matrix, 
when the square root exists.
See https://people.orie.cornell.edu/davidr/SDAFE2/Rscripts/SDAFE2.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.sqrt(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.sqrt_+3A_a">A</code></td>
<td>
<p>A matrix, not necessarily square</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the square root of <code class="reqn">A</code>, if exists, otherwise gives an error message.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(sample(20:40,4),ncol=2)
matrix.sqrt(A)

A&lt;-matrix(sample(20:40,16),ncol=4)
matrix.sqrt(A)
#sqrt of inverse of A, or sqrt inverse of A
matrix.sqrt(solve(A))

#non-square matrix
A&lt;-matrix(sample(20:40,20),ncol=4)
matrix.sqrt(A)

</code></pre>

<hr>
<h2 id='Ninv'>Vector of Shared NNs and Number of Reflexive NNs</h2><span id='topic+Ninv'></span>

<h3>Description</h3>

<p>Returns the <code>Qvec</code> and <code>R</code> 
where <code class="reqn">Qvec=(Q_0,Q_1,\ldots)</code> with
<code class="reqn">Q_j</code> is the number of points shared as a NN
by <code class="reqn">j</code> other points i.e., number of points 
that are NN of <code class="reqn">i</code> points, for <code class="reqn">i=0,1,2,\ldots</code>
and <code>R</code> is the number of reflexive pairs 
where points A and B are reflexive 
iff they are NN to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ninv(x, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ninv_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Ninv_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix, otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="Ninv_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with two elements
</p>
<table>
<tr><td><code>Qvec</code></td>
<td>
<p>vector of <code class="reqn">Q_j</code> values</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>number of reflexive points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qval">Qval</a></code>, <code><a href="#topic+Qvec">Qvec</a></code>, <code><a href="#topic+sharedNN">sharedNN</a></code>, 
<code><a href="#topic+Rval">Rval</a></code>, and <code><a href="#topic+QRval">QRval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)
Ninv(ipd)
Ninv(Y,is.ipd = FALSE)
Ninv(Y,is.ipd = FALSE,method="max")

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column 
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)
Ninv(ipd)

#with possible ties in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ny&lt;-nrow(Y)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
sharedNN(W)
Qvec(W)
Ninv(ipd)

</code></pre>

<hr>
<h2 id='NN'>Finding the index of the NN of a given point</h2><span id='topic+NN'></span>

<h3>Description</h3>

<p>Returns the index (or indices) of the nearest neighbor(s) of 
subject <code class="reqn">i</code> given data set or IPD matrix <code>x</code>.
It will yield a <code>vector</code> if there are ties, 
and subject indices correspond to rows 
(i.e., rows <code>1:n</code> ) if <code>x</code> 
is the data set and to rows or columns 
if <code>x</code> is the IPD matrix.  
</p>
<p>The argument <code>is.ipd</code> is a logical argument 
(default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, 
<code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NN(x, i, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NN_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or 
data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="NN_+3A_i">i</code></td>
<td>
<p>index of (i.e., row number for) the subject 
whose NN is to be found.</p>
</td></tr>
<tr><td><code id="NN_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="NN_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the index (indices) i.e., 
row number(s) of the NN of subject <code class="reqn">i</code>
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kNN">kNN</a></code> and <code><a href="#topic+NNsub">NNsub</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
NN(ipd,1)
NN(Y,1,is.ipd = FALSE)
NN(ipd,5)
NN(Y,5,is.ipd = FALSE)
NN(Y,5,is.ipd = FALSE,method="max")

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
NN(ipd,1)
NN(ipd,5)

#with possible ties in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ny&lt;-nrow(Y)
ipd&lt;-ipd.mat(Y)
for (i in 1:ny)
  cat(i,":",NN(ipd,i),"|",NN(Y,i,is.ipd = FALSE),"\n")

</code></pre>

<hr>
<h2 id='nnct'>Nearest Neighbor Contingency Table (NNCT)</h2><span id='topic+nnct'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT given the IPD matrix or data set <code>x</code> 
where <code class="reqn">k</code> is the number of classes in the data set.
Rows and columns of the NNCT are labeled with the corresponding class labels.
</p>
<p>The argument <code>ties</code> is a logical argument 
(default=<code>FALSE</code>) to take ties into account or not.
If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) 
to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010, 2017))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnct(x, lab, ties = FALSE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnct_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>)
or a data set of points in matrix 
or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="nnct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="nnct_+3A_ties">ties</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>) 
to take ties into account or not. 
If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.</p>
</td></tr>
<tr><td><code id="nnct_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, 
<code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set with rows 
representing the data points.</p>
</td></tr>
<tr><td><code id="nnct_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT 
where <code class="reqn">k</code> is the number of classes in the data set.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct.sub">nnct.sub</a></code>, <code><a href="#topic+scct">scct</a></code>, <code><a href="#topic+rct">rct</a></code>, 
and <code><a href="#topic+tct">tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)
nnct(ipd,cls,ties = TRUE)

nnct(Y,cls,is.ipd = FALSE)
nnct(Y,cls,is.ipd = FALSE,method="max")
nnct(Y,cls,is.ipd = FALSE,method="mink",p=6)

#with one class, it works but really uninformative
cls&lt;-rep(1,n)
nnct(ipd,cls)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nnct(ipd,fcls)

#cls as an unsorted factor
fcls1&lt;-sample(c("a","b"),n,replace = TRUE)
nnct(ipd,fcls1)

fcls2&lt;-sort(fcls1)
nnct(ipd,fcls2) 
#ipd needs to be sorted as well, otherwise this result will not agree with fcls1

nnct(Y,fcls1,ties = TRUE,is.ipd = FALSE)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)
nnct(Y,cls,is.ipd = FALSE)

#cls as a factor
fcls&lt;-rep(letters[1:4],rep(10,4))
nnct(ipd,fcls)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nnct(ipd,fcls)

#with possible ties in the data
Y&lt;-matrix(round(runif(3*n)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)
nnct(ipd,cls,ties = TRUE)

</code></pre>

<hr>
<h2 id='nnct.boot.dis'>Bootstrap Nearest Neighbor Contingency Table (NNCT)</h2><span id='topic+nnct.boot.dis'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT with sampling replacement of 
the points for each base point. 
That is, for each base point, 
the rows in the IPD matrix are sampled with replacement 
and the NN counts are updated accordingly.
Row and columns of the NNCT are labeled 
with the corresponding class labels.
</p>
<p>The argument self is a logical argument (default=<code>TRUE</code>) 
for including the base point in the resampling or not.
If <code>TRUE</code>, 
for each base point all entries in the row are sampled (with replacement) so, 
the point itself can
also be sampled multiple times and 
if <code>FALSE</code> the point is excluded from the resampling 
(i.e., other points are sampled with replacement).
</p>
<p>The argument <code>ties</code> is a logical argument (default=<code>FALSE</code>) 
to take ties into account or not. If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.
</p>
<p>The argument <code>is.ipd</code> is a logical argument 
(default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnct.boot.dis(x, lab, self = TRUE, ties = TRUE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnct.boot.dis_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>)
or a data set of points in matrix 
or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="nnct.boot.dis_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="nnct.boot.dis_+3A_self">self</code></td>
<td>
<p>A logical argument (default=<code>TRUE</code>). 
If <code>TRUE</code>, for each base point, 
all entries in the row are sampled (with replacement) 
and if <code>FALSE</code> the point is excluded from 
the resampling (i.e., other points
are sampled with replacement).</p>
</td></tr>
<tr><td><code id="nnct.boot.dis_+3A_ties">ties</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>) 
to take ties into account or not. 
If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.</p>
</td></tr>
<tr><td><code id="nnct.boot.dis_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, 
<code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set with rows 
representing the data points.</p>
</td></tr>
<tr><td><code id="nnct.boot.dis_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT 
where <code class="reqn">k</code> is the number of classes in the data set 
with sampling replacement of the rows of the IPD matrix.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct">nnct</a></code> and <code><a href="#topic+nnct.sub">nnct.sub</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct.boot.dis(ipd,cls)
nnct.boot.dis(Y,cls,is.ipd = FALSE) 
#may give different result from above due to random sub-sampling
nnct.boot.dis(ipd,cls,self = FALSE)
nnct.boot.dis(ipd,cls,ties = FALSE) 
#differences are due to ties and resampling of distances

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nnct.boot.dis(ipd,fcls)

#cls as an unsorted factor
fcls&lt;-sample(c("a","b"),n,replace = TRUE)
nnct.boot.dis(ipd,fcls)

fcls&lt;-sort(fcls)
nnct.boot.dis(ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct.boot.dis(ipd,cls)

#cls as a factor
fcls&lt;-rep(letters[1:4],rep(10,4))
nnct.boot.dis(ipd,fcls)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct.boot.dis(ipd,cls)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nnct.boot.dis(ipd,fcls)

#with possible ties in the data
Y&lt;-matrix(round(runif(3*n)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct.boot.dis(ipd,cls)
nnct.boot.dis(ipd,cls,self = FALSE)
nnct.boot.dis(ipd,cls,ties = FALSE) 
#differences are due to ties and resampling of distances

</code></pre>

<hr>
<h2 id='nnct.sub'>Nearest Neighbor Contingency Table (NNCT) with (only) 
base points restricted to a subsample</h2><span id='topic+nnct.sub'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT with (only) base points are restricted 
to be in the subset of indices <code>ss</code> using
the IPD matrix or data set <code>x</code> where <code class="reqn">k</code> is 
the number of classes in the data set. 
That is, the base points
are the points with indices in <code>ss</code> 
but for the NNs the function checks all the points in the data set 
(including the points in <code>ss</code>). 
Row and columns of the NNCT are labeled with 
the corresponding class labels.
</p>
<p>The argument <code>ties</code> is a logical argument 
(default=<code>FALSE</code>) to take ties into account or not. 
If <code>TRUE</code> a NN contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) 
to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnct.sub(ss, x, lab, ties = FALSE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnct.sub_+3A_ss">ss</code></td>
<td>
<p>indices of subjects (i.e., row indices in the data set) 
chosen to be the base points</p>
</td></tr>
<tr><td><code id="nnct.sub_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>)
or a data set of points in matrix 
or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="nnct.sub_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="nnct.sub_+3A_ties">ties</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>) 
to take ties into account or not. 
If <code>TRUE</code> a NN 
contributes <code class="reqn">1/m</code> to the NN count 
if it is one of the <code class="reqn">m</code> tied NNs of a subject.</p>
</td></tr>
<tr><td><code id="nnct.sub_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, 
<code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set with rows 
representing the data points.</p>
</td></tr>
<tr><td><code id="nnct.sub_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">k \times k</code> NNCT 
where <code class="reqn">k</code> is the number of classes in the data set with (only) base points
restricted to a subsample <code>ss</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct">nnct</a></code> and <code><a href="#topic+nnct.boot.dis">nnct.boot.dis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)

#subsampling indices
ss&lt;-sample(1:n,floor(n/2))
nnct.sub(ss,ipd,cls)
nnct.sub(ss,Y,cls,is.ipd = FALSE)
nnct.sub(ss,ipd,cls,ties = TRUE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
nnct.sub(ss,ipd,fcls)

#cls as an unsorted factor
fcls&lt;-sample(c("a","b"),n,replace = TRUE)
nnct(ipd,fcls)
nnct.sub(ss,ipd,fcls)

fcls&lt;-sort(fcls)
nnct.sub(ss,ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ss&lt;-sample(1:40,30)
nnct.sub(ss,ipd,cls)

#cls as a factor
fcls&lt;-rep(letters[1:4],rep(10,4))
nnct.sub(ss,ipd,cls)

#1D data points
n&lt;-20  #or try sample(1:20,1)
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
nnct(ipd,cls)

#subsampling indices
ss&lt;-sample(1:n,floor(n/2))
nnct.sub(ss,ipd,cls)

#with possible ties in the data
Y&lt;-matrix(round(runif(120)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ss&lt;-sample(1:40,30)
nnct.sub(ss,ipd,cls)
nnct.sub(ss,ipd,cls,ties = TRUE)

</code></pre>

<hr>
<h2 id='NNdist'>Distances between subjects and their NNs</h2><span id='topic+NNdist'></span>

<h3>Description</h3>

<p>Returns the distances between subjects and their NNs. 
The output is an <code class="reqn">n \times 2</code> matrix 
where <code class="reqn">n</code> is the data size
and first column is the subject index and 
second column contains the corresponding distances to NN subjects.
</p>
<p>The argument <code>is.ipd</code> is a logical argument 
(default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNdist(x, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNdist_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="NNdist_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="NNdist_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">n \times 2</code> matrix where <code class="reqn">n</code> is data size 
(i.e., number of subjects) and first column is the subject
index and second column is the NN distances.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kthNNdist">kthNNdist</a></code>, <code><a href="#topic+kNNdist">kNNdist</a></code>, 
and <code><a href="#topic+NNdist2cl">NNdist2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
NNdist(ipd)
NNdist(Y,is.ipd = FALSE)
NNdist(Y,is.ipd = FALSE,method="max")

#1D data points
X&lt;-as.matrix(runif(5)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
NNdist(ipd)
NNdist(X,is.ipd = FALSE)

</code></pre>

<hr>
<h2 id='NNdist2cl'>Distances between subjects from class <code class="reqn">i</code> 
and their NNs from class <code class="reqn">j</code></h2><span id='topic+NNdist2cl'></span>

<h3>Description</h3>

<p>Returns the distances between subjects from class <code class="reqn">i</code> 
and their nearest neighbors (NNs) from class <code class="reqn">j</code>. 
The output is a <code>list</code> with first entry (<code>nndist</code>) 
being an <code class="reqn">n_i \times 3</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code>
and first column is the subject index in class <code class="reqn">i</code>, 
second column is the subject index in NN class <code class="reqn">j</code>,  
and third column contains the corresponding distances 
of each class <code class="reqn">i</code> subject to its NN among class <code class="reqn">j</code>
subjects. Class <code class="reqn">i</code> is labeled as base class 
and class <code class="reqn">j</code> is labeled as NN class.
</p>
<p>The argument <code>within.class.ind</code> is a logical argument 
(default=<code>FALSE</code>) to determine the indexing of 
the class <code class="reqn">i</code> subjects. 
If <code>TRUE</code>, 
index numbering of subjects is within the class, 
from 1 to class size (i.e., <code>1:n_i</code>), 
according to their order in the original data;
otherwise, index numbering within class is just 
the indices in the original data.
</p>
<p>The argument <code>is.ipd</code> is a logical argument 
(default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNdist2cl(x, i, j, lab, within.class.ind = FALSE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNdist2cl_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="NNdist2cl_+3A_i">i</code>, <code id="NNdist2cl_+3A_j">j</code></td>
<td>
<p>class label of base class and NN classes, respectively.</p>
</td></tr>
<tr><td><code id="NNdist2cl_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="NNdist2cl_+3A_within.class.ind">within.class.ind</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>). 
If <code>TRUE</code>, index numbering of subjects 
is within the class, from 1 to class size (i.e., <code>1:n_i</code>), 
according to their order in the original data;
otherwise, index numbering within class is just 
the indices in the original data.</p>
</td></tr>
<tr><td><code id="NNdist2cl_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="NNdist2cl_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with three elements
</p>
<table>
<tr><td><code>nndist</code></td>
<td>
<p><code class="reqn">n_i \times 3</code> matrix 
where <code class="reqn">n_i</code> is the size of class <code class="reqn">i</code> and 
first column is the subject index in 
class <code class="reqn">i</code>, second column is the subject index in NN class <code class="reqn">j</code>, 
and third column contains the corresponding
distances of each class <code class="reqn">i</code> subject to its NN among class <code class="reqn">j</code> subjects.</p>
</td></tr>
<tr><td><code>base.class</code></td>
<td>
<p>label of base class</p>
</td></tr> 
<tr><td><code>nn.class</code></td>
<td>
<p>label of NN class</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kthNNdist">kthNNdist</a></code>, <code><a href="#topic+kNNdist">kNNdist</a></code>, 
and <code><a href="#topic+NNdist2cl">NNdist2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)
NNdist2cl(ipd,1,2,clab)
NNdist2cl(Y,1,2,clab,is.ipd = FALSE)

NNdist2cl(ipd,1,2,clab,within = TRUE)

#three class case
clab&lt;-sample(1:3,n,replace=TRUE) #class labels
table(clab)
NNdist2cl(ipd,2,1,clab)

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
table(clab)
NNdist2cl(ipd,1,2,clab)
NNdist2cl(X,1,2,clab,is.ipd = FALSE)

</code></pre>

<hr>
<h2 id='NNsub'>Finding the index of the NN of a given point among a subset of points</h2><span id='topic+NNsub'></span>

<h3>Description</h3>

<p>Returns the index (indices) of the nearest neighbor(s) of subject <code class="reqn">i</code> 
(other than subject <code class="reqn">i</code>) among the indices of points 
provided in the subsample <code>ss</code> using 
the given data set or IPD matrix <code>x</code>. 
The indices in <code>ss</code> determine the
columns of the IPD matrix to be used in this function. 
It will yield a <code>vector</code> if there are ties, 
and subject indices correspond to rows 
(i.e., rows <code>1:n</code> ) if <code>x</code> 
is the data set and to rows or columns 
if <code>x</code> is the IPD matrix.  
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) 
to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNsub(ss, x, i, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNsub_+3A_ss">ss</code></td>
<td>
<p>indices of subjects (i.e., row indices in the data set) 
among with the NN of subject is to be found</p>
</td></tr>
<tr><td><code id="NNsub_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or 
data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="NNsub_+3A_i">i</code></td>
<td>
<p>index of (i.e., row number for) the subject 
whose NN is to be found.</p>
</td></tr>
<tr><td><code id="NNsub_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="NNsub_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with the elements
</p>
<table>
<tr><td><code>base.ind</code></td>
<td>
<p>index of the base subject</p>
</td></tr>
<tr><td><code>ss.ind</code></td>
<td>
<p>the index (indices) i.e., 
row number(s) of the NN of subject <code class="reqn">i</code> 
among the subjects with indices
provided in <code>ss</code></p>
</td></tr>
<tr><td><code>ss.dis</code></td>
<td>
<p>distance from subject <code class="reqn">i</code> 
to its NN among the subjects in <code>ss</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NN">NN</a></code> and <code><a href="#topic+kNN">kNN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points 
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
#indices of the subsample ss
ss&lt;-sample(1:n,floor(n/2),replace=FALSE)
NNsub(ss,ipd,2)
NNsub(ss,Y,2,is.ipd = FALSE)
NNsub(ss,ipd,5)

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
#two class case
clab&lt;-sample(1:2,n,replace=TRUE) #class labels
#indices of the subsample ss
ss&lt;-sample(1:n,floor(n/2),replace=FALSE)
NNsub(ss,ipd,2)
NNsub(ss,ipd,5)

#with possible ties in the data
Y&lt;-matrix(round(runif(60)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
ss&lt;-sample(1:20,10,replace=FALSE) #class labels
NNsub(ss,ipd,2)
NNsub(ss,ipd,5)

</code></pre>

<hr>
<h2 id='Nt.def'><code class="reqn">N_t</code> Value (found with the definition formula)</h2><span id='topic+Nt.def'></span>

<h3>Description</h3>

<p>This function computes the <code class="reqn">N_t</code> value which is required in the computation of the asymptotic variance
of Cuzick and Edwards <code class="reqn">T_k</code> test. Nt is defined on page 78 of (Cuzick and Edwards (1990)) as follows.
<code class="reqn">N_t= \sum \sum_{i \ne l}\sum a_{ij} a_{lj}</code> (i.e, number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code class="reqn">k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code class="reqn">k</code>NNs of <code class="reqn">l</code>).
</p>
<p>This function yields the same result as the <code>asyvarTk</code> and <code>varTk</code> functions with <code>$Nt</code> inserted at the
end.
</p>
<p>See (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nt.def(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nt.def_+3A_a">a</code></td>
<td>
<p>The <code class="reqn">A=(a_{ij})</code> matrix. The argument <code>a</code> is the <code class="reqn">A</code> matrix, obtained as output fromm <code>aij.mat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">N_t</code> value standing for the number of triplets <code class="reqn">(i,j,l)</code> <code class="reqn">i,j</code>, and <code class="reqn">l</code> distinct so that
<code class="reqn">j</code> is among <code class="reqn">k</code>NNs of <code class="reqn">i</code> and <code class="reqn">j</code> is among <code class="reqn">k</code>NNs of <code class="reqn">l</code>. See the description.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asyvarTk">asyvarTk</a></code>, <code><a href="#topic+varTk">varTk</a></code>, and <code><a href="#topic+varTkaij">varTkaij</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
k&lt;-2 #try also 2,3
a&lt;-aij.mat(Y,k)
Nt.def(a)

</code></pre>

<hr>
<h2 id='Ntkl'><code class="reqn">N_{tkl}</code> Value</h2><span id='topic+Ntkl'></span>

<h3>Description</h3>

<p>This function computes the <code class="reqn">N_{tkl}</code> value which is required in the computation of the exact and asymptotic variance
of Cuzick and Edwards <code class="reqn">T_{comb}</code> test, which is a linear combination of some <code class="reqn">T_k</code> tests. 
<code class="reqn">N_{tkl}</code> is defined on page 80 of (Cuzick and Edwards (1990)) as follows.
Let <code class="reqn">a_{ij}(k)</code> be 1 if <code class="reqn">j</code> is a <code>k</code> NN of <code class="reqn">i</code> and zero otherwise and 
<code class="reqn">N_t(k,l) = \sum \sum_{i \ne m}\sum a_{ij}(k) a_{mj}(l)</code>.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>See (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ntkl(dat, k, l, nonzero.mat = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ntkl_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Ntkl_+3A_k">k</code>, <code id="Ntkl_+3A_l">l</code></td>
<td>
<p>Integers specifying the number of NNs (of subjects <code class="reqn">i</code> and <code class="reqn">m</code> in <code class="reqn">a_{ij}(k) a_{mj}(l)</code>).</p>
</td></tr>
<tr><td><code id="Ntkl_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code> (argument is passed on to
<code>asycovTkTl</code> and <code>covTkTl</code>).
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="Ntkl_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">N_{tkl}</code> value. See the description.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+asycovTkTl">asycovTkTl</a></code>, and <code><a href="#topic+covTkTl">covTkTl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
k&lt;-1 #try also 2,3 or sample(1:5,1)
l&lt;-1 #try also 2,3 or sample(1:5,1)
c(k,l)

Ntkl(Y,k,l)
Ntkl(Y,k,l,nonzero.mat = FALSE)
Ntkl(Y,k,l,method="max")

</code></pre>

<hr>
<h2 id='pairwise.lab'>Keeping the pair of the specified labels in the data</h2><span id='topic+pairwise.lab'></span>

<h3>Description</h3>

<p>Keeps only the specified labels <code class="reqn">i</code> and <code class="reqn">j</code> 
and returns the data from classes with these labels and also
the corresponding label vector having 
class labels <code class="reqn">i</code> and <code class="reqn">j</code> only.
</p>
<p>See also (Ceyhan (2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.lab(dat, lab, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.lab_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions,
each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="pairwise.lab_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="pairwise.lab_+3A_i">i</code>, <code id="pairwise.lab_+3A_j">j</code></td>
<td>
<p>Label of the classes that are to be retained 
in the post-hoc comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>data.pair</code></td>
<td>
<p>The type of the pattern 
from which points are to be generated</p>
</td></tr>
<tr><td><code>lab.pair</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lab.onevsrest">lab.onevsrest</a></code> and <code><a href="#topic+classirest">classirest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
pairwise.lab(Y,cls,1,2)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
pairwise.lab(Y,cls,2,3)

#cls as a factor
fcls&lt;-rep(letters[1:4],rep(10,4))
pairwise.lab(Y,fcls,"b","c")

</code></pre>

<hr>
<h2 id='pick.min.max'>Smallest and Largest Distances in a Distance Matrix</h2><span id='topic+pick.min.max'></span>

<h3>Description</h3>

<p>This function finds and returns the <code>k</code> smallest and <code>k</code> largest distances in a distance matrix or distance object,
and also provides pairs of objects these distances correspond to.
The code is adapted from 
<a href="http://people.stat.sc.edu/Hitchcock/chapter1_R_examples.txt">http://people.stat.sc.edu/Hitchcock/chapter1_R_examples.txt</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick.min.max(ds, k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick.min.max_+3A_ds">ds</code></td>
<td>
<p>A distance matrix or a distance object</p>
</td></tr>
<tr><td><code id="pick.min.max_+3A_k">k</code></td>
<td>
<p>A positive integer representing the number of (min and max) distances to be presented, default is <code class="reqn">k=1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>min.dis</code></td>
<td>
<p>The <code>k</code> smallest distances in <code>ds</code></p>
</td></tr>
<tr><td><code>ind.min.dis</code></td>
<td>
<p>The indices (i.e., row numbers) of the <code>k</code> pairs of object which has the
<code>k</code> smallest distances in <code>ds</code></p>
</td></tr>
<tr><td><code>max.dis</code></td>
<td>
<p>The <code>k</code> largest distances in <code>ds</code></p>
</td></tr>
<tr><td><code>ind.max.dis</code></td>
<td>
<p>The indices (i.e., row numbers) of the <code>k</code> pairs of object which has the
<code>k</code> largest distances in <code>ds</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+ipd.mat">ipd.mat</a></code>, and <code><a href="#topic+ipd.mat.euc">ipd.mat.euc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
pick.min.max(ipd)
#or
pick.min.max(dist(Y))

pick.min.max(ipd,2)

</code></pre>

<hr>
<h2 id='pk'>Probability of <code>k</code> items selected from the class with size <code class="reqn">n_1</code></h2><span id='topic+pk'></span>

<h3>Description</h3>

<p>Returns the ratio <code class="reqn">n_1(n_1-1) \cdots (n_1-(k-1))/(n(n-1) \cdots (n-(k-1))</code>, 
which is the probability that the <code>k</code> selected
objects are from class 1 with size <code class="reqn">n_1</code> (denoted as <code>n1</code> as an argument)
and the total data size is <code>n</code>.
This probability is valid under RL or CSR.
</p>
<p>This function computes the <code class="reqn">p_k</code> value which is required in the computation of the variance
of Cuzick and Edwards <code class="reqn">T_k</code> test. 
<code class="reqn">p_k</code> is defined as the ratio <code class="reqn">n_1(n_1-1)\cdots (n_1-(k-1))/(n(n-1)\cdots (n-(k-1))</code>.
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument).
The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>
<p>See (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pk(n, n1, k)

pk(n, n1, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pk_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points in the data set</p>
</td></tr>
<tr><td><code id="pk_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="pk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the probability of <code>k</code> items selected 
from <code>n</code> items are from the class of interest
(i.e., from the class whose size is <code class="reqn">n_1</code>)
</p>
<p>Returns the <code class="reqn">p_k</code> value. See the description.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p11">p11</a></code> and <code><a href="#topic+p12">p12</a></code> etc.
</p>
<p><code><a href="#topic+asyvarTk">asyvarTk</a></code>, <code><a href="#topic+varTk">varTk</a></code>, and <code><a href="#topic+varTkaij">varTkaij</a></code>
</p>

<hr>
<h2 id='plot.Clusters'>Plot a <code>Clusters</code> object</h2><span id='topic+plot.Clusters'></span>

<h3>Description</h3>

<p>Plots the points generated from the pattern (color coded for each class) together with the
study window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Clusters'
plot(x, asp = NA, xlab = "x", ylab = "y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Clusters_+3A_x">x</code></td>
<td>
<p>Object of class <code>Clusters</code>.</p>
</td></tr>
<tr><td><code id="plot.Clusters_+3A_asp">asp</code></td>
<td>
<p>A numeric value, giving the aspect ratio for y axis to x-axis y/x (default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;? asp&quot;.</p>
</td></tr>
<tr><td><code id="plot.Clusters_+3A_xlab">xlab</code>, <code id="plot.Clusters_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the x and y axes, respectively (default is <code>xlab</code>=&quot;x&quot; and <code>ylab</code>=&quot;y&quot;).</p>
</td></tr>
<tr><td><code id="plot.Clusters_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF

</code></pre>

<hr>
<h2 id='plot.SpatPatterns'>Plot a <code>SpatPatterns</code> object</h2><span id='topic+plot.SpatPatterns'></span>

<h3>Description</h3>

<p>Plots the points generated from the pattern (color coded for each class) together with the
study window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatPatterns'
plot(x, asp = NA, xlab = "x", ylab = "y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SpatPatterns_+3A_x">x</code></td>
<td>
<p>Object of class <code>SpatPatterns</code>.</p>
</td></tr>
<tr><td><code id="plot.SpatPatterns_+3A_asp">asp</code></td>
<td>
<p>A numeric value, giving the aspect ratio for y axis to x-axis y/x (default is <code>NA</code>),
see the official help for <code>asp</code> by typing &quot;? asp&quot;.</p>
</td></tr>
<tr><td><code id="plot.SpatPatterns_+3A_xlab">xlab</code>, <code id="plot.SpatPatterns_+3A_ylab">ylab</code></td>
<td>
<p>Titles for the x and y axes, respectively (default is <code>xlab</code>=&quot;x&quot; and <code>ylab</code>=&quot;y&quot;).</p>
</td></tr>
<tr><td><code id="plot.SpatPatterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF

</code></pre>

<hr>
<h2 id='print.cellhtest'>Print a summary of a <code>cellhtest</code> object</h2><span id='topic+print.cellhtest'></span>

<h3>Description</h3>

<p>Printing objects of class &quot;<code>cellhtest</code>&quot; by simple <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cellhtest'
print(x, digits = getOption("digits"), prefix = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cellhtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.cellhtest</code>&quot;</p>
</td></tr>
<tr><td><code id="print.cellhtest_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.cellhtest_+3A_prefix">prefix</code></td>
<td>
<p>string, passed to <code><a href="base.html#topic+strwrap">strwrap</a></code> for displaying the method component 
of the <code>classhtest</code> object.</p>
</td></tr>
<tr><td><code id="print.cellhtest_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='print.Chisqtest'>Print a summary of a <code>Chisqtest</code> object</h2><span id='topic+print.Chisqtest'></span>

<h3>Description</h3>

<p>Printing objects of class &quot;<code>Chisqtest</code>&quot; by simple <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Chisqtest'
print(x, digits = getOption("digits"), prefix = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Chisqtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.Chisqtest</code>&quot;</p>
</td></tr>
<tr><td><code id="print.Chisqtest_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.Chisqtest_+3A_prefix">prefix</code></td>
<td>
<p>string, passed to <code><a href="base.html#topic+strwrap">strwrap</a></code> for displaying the method component 
of the <code>classhtest</code> object.</p>
</td></tr>
<tr><td><code id="print.Chisqtest_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='print.classhtest'>Print a summary of a <code>classhtest</code> object</h2><span id='topic+print.classhtest'></span>

<h3>Description</h3>

<p>Printing objects of class &quot;<code>classhtest</code>&quot; by simple <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classhtest'
print(x, digits = getOption("digits"), prefix = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.classhtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.classhtest</code>&quot;</p>
</td></tr>
<tr><td><code id="print.classhtest_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.classhtest_+3A_prefix">prefix</code></td>
<td>
<p>string, passed to <code><a href="base.html#topic+strwrap">strwrap</a></code> for displaying the method component 
of the <code>classhtest</code> object.</p>
</td></tr>
<tr><td><code id="print.classhtest_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='print.Clusters'>Print a <code>Clusters</code> object</h2><span id='topic+print.Clusters'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the object of class '<code>Clusters</code>'
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Clusters'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Clusters_+3A_x">x</code></td>
<td>
<p>A <code>Clusters</code> object.</p>
</td></tr>
<tr><td><code id="print.Clusters_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method '<code>print</code>'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the object of class '<code>Clusters</code>'
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Clusters">summary.Clusters</a></code>, <code><a href="#topic+print.summary.Clusters">print.summary.Clusters</a></code>, and <code><a href="#topic+plot.Clusters">plot.Clusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF (to be filled)

</code></pre>

<hr>
<h2 id='print.refhtest'>Print a summary of a <code>refhtest</code> object</h2><span id='topic+print.refhtest'></span>

<h3>Description</h3>

<p>Printing objects of class &quot;<code>refhtest</code>&quot; by simple <code><a href="base.html#topic+print">print</a></code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'refhtest'
print(x, digits = getOption("digits"), prefix = "\t", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.refhtest_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.refhtest</code>&quot;</p>
</td></tr>
<tr><td><code id="print.refhtest_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.refhtest_+3A_prefix">prefix</code></td>
<td>
<p>string, passed to <code><a href="base.html#topic+strwrap">strwrap</a></code> for displaying the method component 
of the <code>classhtest</code> object.</p>
</td></tr>
<tr><td><code id="print.refhtest_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='print.SpatPatterns'>Print a <code>SpatPatterns</code> object</h2><span id='topic+print.SpatPatterns'></span>

<h3>Description</h3>

<p>Prints the <code>call</code> of the object of class '<code>SpatPatterns</code>'
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatPatterns'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SpatPatterns_+3A_x">x</code></td>
<td>
<p>A <code>SpatPatterns</code> object.</p>
</td></tr>
<tr><td><code id="print.SpatPatterns_+3A_...">...</code></td>
<td>
<p>Additional arguments for the S3 method '<code>print</code>'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the object of class '<code>SpatPatterns</code>'
and also the <code>type</code> (or description) of the pattern).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.SpatPatterns">summary.SpatPatterns</a></code>, <code><a href="#topic+print.summary.SpatPatterns">print.summary.SpatPatterns</a></code>, and <code><a href="#topic+plot.SpatPatterns">plot.SpatPatterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF (to be filled)

</code></pre>

<hr>
<h2 id='print.summary.Clusters'>Print a summary of a <code>Clusters</code> object</h2><span id='topic+print.summary.Clusters'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.Clusters'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.Clusters_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.Clusters</code>&quot;, generated by <code>summary.Clusters</code>.</p>
</td></tr>
<tr><td><code id="print.summary.Clusters_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.Clusters">print.Clusters</a></code>, <code><a href="#topic+summary.Clusters">summary.Clusters</a></code>, and <code><a href="#topic+plot.Clusters">plot.Clusters</a></code>
</p>

<hr>
<h2 id='print.summary.SpatPatterns'>Print a summary of a <code>SpatPatterns</code> object</h2><span id='topic+print.summary.SpatPatterns'></span>

<h3>Description</h3>

<p>Prints some information about the <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.SpatPatterns'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.SpatPatterns_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.SpatPatterns</code>&quot;, generated by <code>summary.SpatPatterns</code>.</p>
</td></tr>
<tr><td><code id="print.summary.SpatPatterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.SpatPatterns">print.SpatPatterns</a></code>, <code><a href="#topic+summary.SpatPatterns">summary.SpatPatterns</a></code>, and <code><a href="#topic+plot.SpatPatterns">plot.SpatPatterns</a></code>
</p>

<hr>
<h2 id='prob.nnct'>Probability of the current nearest neighbor contingency table</h2><span id='topic+prob.nnct'></span>

<h3>Description</h3>

<p>Computes the probability of the observed <code class="reqn">2 \times 2</code> nearest neighbor contingency table (NNCT) 
<code class="reqn">p_t=f(n_{11}|n_1,n_2,c_1;\theta)</code> where <code class="reqn">\theta=(n_1-1)(n_2-1)/(n_1 n_2)</code> which is the odds ratio
under RL or CSR independence and
<code class="reqn">f</code> is the probability mass function of the hypergeometric distribution.
That is, given the margins of the current NNCT, the probability of obtaining the current table with the odds
ratio <code class="reqn">\theta</code> being the value under the null hypothesis.
This value is used to compute the table-inclusive and exclusive <code class="reqn">p</code>-values for the exact inference on NNCTs.
</p>
<p>See (Ceyhan (2010)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.nnct(ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prob.nnct_+3A_ct">ct</code></td>
<td>
<p>A NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The probability of getting the observed NNCT, <code>ct</code> , under the null hypothesis.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Exact Inference for Testing Spatial Patterns by Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of Probability and Statistical Science</em>, <b>8(1)</b>, 45-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exact.pval1s">exact.pval1s</a></code> and <code><a href="#topic+exact.pval2s">exact.pval2s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ct&lt;-matrix(sample(20:40,4),ncol=2)
prob.nnct(ct)

ct&lt;-matrix(sample(20:40,4),ncol=2)
prob.nnct(ct)

</code></pre>

<hr>
<h2 id='QRval'>Number of Shared and Reflexive NNs</h2><span id='topic+QRval'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">Q</code> and <code class="reqn">R</code> values 
where <code class="reqn">Q</code> is the number of points shared as a NN
by other points i.e., number of points 
that are NN of other points (which occurs when two or 
more points share a NN, for data in any dimension) and <code class="reqn">R</code> is 
the number of reflexive pairs
where A and B are reflexive iff they are NN to each other.
</p>
<p>These quantities are used, e.g., 
in computing the variances and covariances of the entries of the
nearest neighbor contingency tables used for Dixon's tests 
and other NNCT tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QRval(njr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QRval_+3A_njr">njr</code></td>
<td>
<p>A <code>list</code> that is the output of <code><a href="#topic+Ninv">Ninv</a></code> 
(with first entry in the <code>list</code> is <code>vector</code> of number of shared NNs
and second is the <code class="reqn">R</code> value, number of reflexive points)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with two elements
</p>
<table>
<tr><td><code>Q</code></td>
<td>
<p>the <code class="reqn">Q</code> value, the number of shared NNs</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>the <code class="reqn">R</code> value, the number of reflexive NNs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qval">Qval</a></code>, <code><a href="#topic+Qvec">Qvec</a></code>, <code><a href="#topic+sharedNN">sharedNN</a></code>, 
<code><a href="#topic+Rval">Rval</a></code>, and <code><a href="#topic+Ninv">Ninv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
ninv&lt;-Ninv(ipd)
QRval(ninv)
W&lt;-Wmat(ipd)
Qvec(W)$q

#1D data points
n&lt;-15
X&lt;-as.matrix(runif(n))# need to be entered as a matrix with one column 
#(i.e., a column vector), hence X&lt;-runif(n) would not work
ipd&lt;-ipd.mat(X)
ninv&lt;-Ninv(ipd)
QRval(ninv)
W&lt;-Wmat(ipd)
Qvec(W)$q

#with possible ties in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ny&lt;-nrow(Y)
ipd&lt;-ipd.mat(Y)
ninv&lt;-Ninv(ipd)
QRval(ninv)
W&lt;-Wmat(ipd)
Qvec(W)$q

</code></pre>

<hr>
<h2 id='Qsym.ct'><code class="reqn">Q</code>-symmetry Contingency Table (QCT)</h2><span id='topic+Qsym.ct'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">k \times 3</code> contingency table for <code class="reqn">Q</code>-symmetry (i.e., <code class="reqn">Q</code>-symmetry contingency table (QCT)) given the 
IPD matrix or data set <code>x</code> where <code class="reqn">k</code> is the number of classes in the data set.
Each row in the QCT is the vector of number of points with shared NNs,
<code class="reqn">Q_i=(Q_{i0},Q_{i1},Q_{i2})</code> where <code class="reqn">Q_{ij}</code> is the number of class <code class="reqn">i</code> points that are NN to class <code class="reqn">j</code> points
for <code class="reqn">j=0,1</code> and <code class="reqn">Q_{i2}</code> is the number of class <code class="reqn">i</code> points that are NN to class <code class="reqn">j</code> or more points.
That is, this function pools the cells 3 or larger together for <code class="reqn">k</code> classes, so, <code class="reqn">Q_2</code>, <code class="reqn">Q_3</code> etc. are pooled,
so, the column labels are <code class="reqn">Q_0</code>, <code class="reqn">Q_1</code> and <code class="reqn">Q_2</code> with the last one is actually sum of <code class="reqn">Q_j</code> for <code class="reqn">j \ge 2</code>.
Rows the QCT are labeled with the corresponding class labels.
</p>
<p><code class="reqn">Q</code>-symmetry is also equivalent to Pielou's second type of NN symmetry
or the symmetry in the shared NN structure for all classes.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be the inter-point distance (IPD) matrix, and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qsym.ct(x, lab, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qsym.ct_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Qsym.ct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="Qsym.ct_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix, otherwise, <code>x</code> is taken as the data set with rows representing the data points.</p>
</td></tr>
<tr><td><code id="Qsym.ct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">k \times 3</code> QCT where <code class="reqn">k</code> is the number of classes in the data set.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sharedNNmc">sharedNNmc</a></code>, <code><a href="#topic+Qsym.test">Qsym.test</a></code> and <code><a href="#topic+scct">scct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(n*3),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

Qsym.ct(ipd,cls)
Qsym.ct(Y,cls,is.ipd = FALSE)
Qsym.ct(Y,cls,is.ipd = FALSE,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Qsym.ct(ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

Qsym.ct(ipd,cls)

</code></pre>

<hr>
<h2 id='Qsym.test'>Pielou's Second Type of NN Symmetry Test with Chi-square Approximation</h2><span id='topic+Qsym.test'></span>

<h3>Description</h3>

<p>An object of class <code>"Chisqtest"</code> performing the hypothesis test of equality of the probabilities for the rows
in the <code class="reqn">Q</code>-symmetry contingency table (QCT).
Each row of the QCT is the vector of Qi<code class="reqn">j</code> values where <code class="reqn">Q_{ij}</code> is the number of class <code class="reqn">i</code> points that are NN
to <code class="reqn">j</code> points.
That is, the test performs Pielou's second type of NN symmetry test which is also equivalent to Pearson's
test on the QCT (Pielou (1961)).
Pielou's second type of NN symmetry is the symmetry in the shared NN structure for all classes, which is also 
called <code class="reqn">Q</code>-symmetry.
The test is appropriate (i.e., have the appropriate asymptotic sampling distribution)
provided that data is obtained by sparse sampling, although simulations suggest it seems to work for
completely mapped data as well.
(See Ceyhan (2014) for more detail).
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be the inter-point distance (IPD) matrix, and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>
<p>The argument combine is a logical argument (default=<code>TRUE</code>) to determine whether to combine the 3rd column 
and the columns to the left.
If <code>TRUE</code>, this function pools the cells 3 or larger together for <code class="reqn">k</code> classes in the QCT, 
so, <code class="reqn">Q_2</code>, <code class="reqn">Q_3</code> etc. are pooled, so, the column
labels are <code class="reqn">Q_0</code>, <code class="reqn">Q_1</code> and <code class="reqn">Q_2</code> with the last one is actually sum of <code class="reqn">Q_j</code> for <code class="reqn">j \ge 2</code> in the QCT.
If <code>FALSE</code>, the function does not perform the pooling of the cells.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">(k-1)(n_c-1)</code> where <code class="reqn">n_c</code> is the number of
columns in QCT (which reduces to <code class="reqn">2(k-1)</code>, if <code>combine=TRUE</code>). It also provides the description of
the alternative with the corresponding null values (i.e., expected values) of the entries of the QCT and also the sample estimates 
of the entries of QCT (i.e., the observed QCT).
The function also provides names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is the symmetry in the shared NN structure for each class, that is,
all <code class="reqn">E(Q_{ij})=n_i Q_j/n</code> where <code class="reqn">n_i</code> the size of class <code class="reqn">i</code> and <code class="reqn">Q_j</code> is the sum of column <code class="reqn">j</code> 
in the QCT (i.e., the total number of points serving as NN to class <code class="reqn">j</code> other points). (i.e., symmetry in the 
mixed NN structure).
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qsym.test(x, lab, is.ipd = TRUE, combine = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qsym.test_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Qsym.test_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="Qsym.test_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix (IPD matrix), otherwise, <code>x</code> is taken as the data set with rows representing the data points.</p>
</td></tr>
<tr><td><code id="Qsym.test_+3A_combine">combine</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, 
the cells in column 3 or columns to the left are merged in the QCT, so, <code class="reqn">Q_2</code>, <code class="reqn">Q_3</code> etc. are pooled, so, the column
labels are <code class="reqn">Q_0</code>, <code class="reqn">Q_1</code> and <code class="reqn">Q_2</code> with the last one is actually sum of <code class="reqn">Q_j</code> for <code class="reqn">j \ge 2</code> in the QCT. 
If <code>FALSE</code>, the function does not perform the pooling of the cells.</p>
</td></tr>
<tr><td><code id="Qsym.test_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for Pielou's second type of NN symmetry test (i.e., <code class="reqn">Q</code>-symmetry 
which is equivalent to symmetry in the shared NN structure)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">(k-1)(n_c-1)</code> where <code class="reqn">n_c</code> is the number of
columns in QCT (which reduces to <code class="reqn">2(k-1)</code> if <code>combine=TRUE</code>).</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates, i.e., the observed QCT.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the entries of the QCT, i.e., the matrix with entries 
<code class="reqn">E(Q_{ij})=n_i Q_j/n</code> where <code class="reqn">n_i</code> the size of class <code class="reqn">i</code> and <code class="reqn">Q_j</code> is the sum of column <code class="reqn">j</code> in the QCT (i.e., the total
number of points serving as NN to class <code class="reqn">j</code> other points).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>x</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym">Znnsym</a></code> and <code><a href="#topic+Xsq.nnsym">Xsq.nnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
Qsym.ct(ipd,cls)

Qsym.test(ipd,cls)
Qsym.test(Y,cls,is.ipd = FALSE)
Qsym.test(Y,cls,is.ipd = FALSE,method="max")

Qsym.test(ipd,cls,combine = FALSE)

#cls as a faqctor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Qsym.test(ipd,fcls)
Qsym.test(Y,fcls,is.ipd = FALSE)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Qsym.test(ipd,cls)
Qsym.test(Y,cls,is.ipd = FALSE)

</code></pre>

<hr>
<h2 id='rassoc'>Generation of Points Associated with a Given Set of Points</h2><span id='topic+rassoc'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_2</code> 2D points associated with the given set of points (i.e., reference points) <code class="reqn">X_1</code> in the
<code>type=type</code> fashion with the parameter=asc.par which specifies the level of association.
The generated points are intended to be from a different class, say class 2 (or <code class="reqn">X_2</code> points) 
than the reference (i.e., <code class="reqn">X_1</code> points, say class 1 points, denoted as <code>X1</code> as an argument 
of the function), say class 1 points). 
</p>
<p>To generate <code class="reqn">n_2</code> (denoted as <code>n2</code> as an argument of the function)<code class="reqn">X_2</code> points, 
<code class="reqn">n_2</code> of <code class="reqn">X_1</code> points are randomly selected (possibly with replacement) and
for a selected <code>X1</code> point, say <code class="reqn">x_{1ref}</code>,
a new point from the class 2, say <code class="reqn">x_{2new}</code>, is generated from a distribution specified
by the type argument.
</p>
<p>In type I association, i.e., if <code>type="I"</code>, first a <code class="reqn">Uniform(0,1)</code> number, <code class="reqn">U</code>, is generated.
If <code class="reqn">U \le p</code>, <code class="reqn">x_{2new}</code> is generated (uniform in the polar coordinates) within a
circle with radius equal to the distance to the closest <code class="reqn">X_1</code> point,
else it is generated uniformly within the smallest bounding box containing <code class="reqn">X_1</code> points.
</p>
<p>In the type C association pattern
the new point from the class 2, <code class="reqn">x_{2new}</code>, is generated (uniform in the polar coordinates) within a circle
centered at <code class="reqn">x_{1ref}</code> with radius equal to <code class="reqn">r_0</code>,
in type U association pattern <code class="reqn">x_{2new}</code> is generated similarly except it is uniform in the circle.
</p>
<p>In type G association, <code class="reqn">x_{2new}</code> is generated from the bivariate normal distribution centered at <code class="reqn">x_{1ref}</code> with covariance
<code class="reqn">\sigma I_2</code> where <code class="reqn">I_2</code> is <code class="reqn">2 \times 2</code> identity matrix.
</p>
<p>See Ceyhan (2014) for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassoc(X1, n2, asc.par, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassoc_+3A_x1">X1</code></td>
<td>
<p>A set of 2D points representing the reference points, also referred as class 1 points.
The generated points are associated in a type=type sense with these points.</p>
</td></tr>
<tr><td><code id="rassoc_+3A_n2">n2</code></td>
<td>
<p>A positive integer representing the number of class 2 points to be generated.</p>
</td></tr>
<tr><td><code id="rassoc_+3A_asc.par">asc.par</code></td>
<td>
<p>A positive real number representing the association parameter. For <code>type="I"</code>,
it is attraction probability, <code>p</code>, of class 2 points associated with a randomly selected class 1 point; 
for <code>type="C"</code> or <code>"U"</code>, it is the radius of association, <code>r0</code>, of class 2 points associated with a
randomly selected class 1 point;
for <code>type="G"</code>, it is the variance of the Gaussian marginals, where
the bivariate normal distribution has covariance <code class="reqn">\sigma I_2</code> with <code class="reqn">I_2</code> being the <code class="reqn">2 \times 2</code> identity matrix.</p>
</td></tr>
<tr><td><code id="rassoc_+3A_type">type</code></td>
<td>
<p>The type of the association pattern. Takes on values <code>"I"</code>, <code>"C"</code>, <code>"U"</code> and <code>"G"</code> 
for types I, C, U and G association patterns (see the description above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p>=<code>"ref.gen"</code> for the bivariate pattern of association of class 2 points with the reference points
(i.e., <code class="reqn">X_1</code>), indicates reference points are required to be entered as an argument in the function</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The <code>asc.par</code> value specifying the level of association</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code class="reqn">X_1</code>, i.e., points with which generated class 2 points
are associated.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 2 points and
the number of reference (i.e., <code class="reqn">X_1</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassocI">rassocI</a></code>, <code><a href="#topic+rassocC">rassocC</a></code>, <code><a href="#topic+rassocU">rassocU</a></code>, and <code><a href="#topic+rassocG">rassocG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20; n2&lt;-1000;  #try also n1&lt;-10; n2&lt;-1000;

#with default bounding box (i.e., unit square)
X1&lt;-cbind(runif(n1),runif(n1))

Xdat&lt;-rassoc(X1,n2,asc.par=.05,type="G") #try other types as well
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#with type U association
Xdat&lt;-rassoc(X1,n2,asc.par=.1,type="U")
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#with type C association
Xdat&lt;-rassoc(X1,n2,asc.par=.1,type=2) #2 is for "C"
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rassocC'>Generation of Points Associated in the Type C Sense with a Given Set of Points</h2><span id='topic+rassocC'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_2</code> 2D points associated with the given set of points (i.e., reference points) <code class="reqn">X_1</code> in the
type C fashion with a radius of association <code class="reqn">r_0</code> (denoted as <code>r0</code> as
an argument of the function) which is a positive real number.
The generated points are intended to be from a different class, say class 2 (or <code class="reqn">X_2</code> points) than the reference
(i.e., <code class="reqn">X_1</code> points, say class 1 points, denoted as <code>X1</code> as an argument of the function), say class 1 points). 
To generate <code class="reqn">n_2</code> <code class="reqn">X_2</code> points, <code class="reqn">n_2</code> of <code class="reqn">X_1</code> points are randomly selected (possibly with replacement) and
for a selected <code>X1</code> point, say <code class="reqn">x_{1ref}</code>,
a new point from the class 2, say <code class="reqn">x_{2new}</code>, is generated within a
circle with radius equal to <code class="reqn">r_0</code> (uniform in the polar coordinates).
That is, <code class="reqn">x_{2new} = x_{1ref}+r_u c(\cos(t_u),\sin(t_u))</code>
where <code class="reqn">r_u \sim U(0,r_0)</code> and <code class="reqn">t_u \sim U(0, 2\pi)</code>.
Note that, the level of association increases as <code class="reqn">r_0</code> decreases, and the association vanishes when <code class="reqn">r_0</code> is 
sufficiently large.
</p>
<p>For type C association, it is recommended to take <code class="reqn">r_0 \le 0.25</code> times length of the shorter
edge of a rectangular study region, or take <code class="reqn">r_0 = 1/(k \sqrt{\hat \rho})</code> with the appropriate choice of <code class="reqn">k</code> 
to get an association pattern more robust to differences in relative abundances
(i.e., the choice of <code class="reqn">k</code> implies <code class="reqn">r_0 \le 0.25</code> times length of the shorter edge to have alternative patterns more 
robust to differences in sample sizes).
Here <code class="reqn">\hat \rho</code> is the 
estimated intensity of points in the study region (i.e., # of points divided by the area of the region). 
</p>
<p>Type C association is closely related to Type U association, see the function <code><a href="#topic+rassocC">rassocC</a></code>
and the other association types.
In the type U association pattern
the new point from the class 2, <code class="reqn">x_{2new}</code>, is generated uniformly within a circle
centered at <code class="reqn">x_{1ref}</code> with radius equal to <code class="reqn">r_0</code>.
In type G association, <code class="reqn">x_{2new}</code> is generated from the bivariate normal distribution centered at <code class="reqn">x_{1ref}</code> with covariance
<code class="reqn">\sigma I_2</code> where <code class="reqn">I_2</code> is <code class="reqn">2 \times 2</code> identity matrix. 
In type I association, first a <code class="reqn">Uniform(0,1)</code> number, <code class="reqn">U</code>, is generated.
If <code class="reqn">U \le p</code>, <code class="reqn">x_{2new}</code> is generated (uniform in the polar coordinates) within a
circle with radius equal to the distance to the closest <code class="reqn">X_1</code> point,
else it is generated uniformly within the smallest bounding box containing <code class="reqn">X_1</code> points.
</p>
<p>See Ceyhan (2014) for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassocC(X1, n2, r0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassocC_+3A_x1">X1</code></td>
<td>
<p>A set of 2D points representing the reference points, also referred as class 1 points.
The generated points are associated in a type C sense (in a circular/radial fashion) with these points.</p>
</td></tr>
<tr><td><code id="rassocC_+3A_n2">n2</code></td>
<td>
<p>A positive integer representing the number of class 2 points to be generated.</p>
</td></tr>
<tr><td><code id="rassocC_+3A_r0">r0</code></td>
<td>
<p>A positive real number representing the radius of association of class 2 points associated with a
randomly selected class 1 point (see the description below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p>=<code>"ref.gen"</code> for the bivariate pattern of association of class 2 points with the reference points
(i.e., <code class="reqn">X_1</code>), indicates reference points are required to be entered as an argument in the function</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radius of association controlling the level of association</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points (i.e., class 2 points) associated with reference (i.e.
<code class="reqn">X_1</code> points)</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code class="reqn">X_1</code>, i.e., points with which generated class 2 points
are associated.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 2 points and
the number of reference (i.e., <code class="reqn">X_1</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassocI">rassocI</a></code>, <code><a href="#topic+rassocG">rassocG</a></code>, <code><a href="#topic+rassocU">rassocU</a></code>, and <code><a href="#topic+rassoc">rassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20; n2&lt;-1000;  #try also n1&lt;-10; n2&lt;-1000;

r0&lt;-.15 #try also .10 and .20, runif(1)
#with default bounding box (i.e., unit square)
X1&lt;-cbind(runif(n1),runif(n1))  #try also X1&lt;-1+cbind(runif(n1),runif(n1))

Xdat&lt;-rassocC(X1,n2,r0)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#radius adjusted with the expected NN distance
x&lt;-range(X1[,1]); y&lt;-range(X1[,2])
ar&lt;-(y[2]-y[1])*(x[2]-x[1]) #area of the smallest rectangular window containing X1 points
rho&lt;-n1/ar
r0&lt;-1/(2*sqrt(rho)) #r0=1/(2rho) where \code{rho} is the intensity of X1 points
Xdat&lt;-rassocC(X1,n2,r0)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rassocG'>Generation of Points Associated in the Type G Sense with a Given Set of Points</h2><span id='topic+rassocG'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_2</code> 2D points associated with the given set of points (i.e., reference points) <code class="reqn">X_1</code> in the
type G fashion with the parameter sigma which is a positive real number representing the variance of the
Gaussian marginals.
The generated points are intended to be from a different class, say class 2 (or <code class="reqn">X_2</code> points) than the reference
(i.e., <code class="reqn">X_1</code> points, say class 1 points, denoted as <code>X1</code> as an argument of the function), say class 1 points). 
To generate <code class="reqn">n_2</code> (denoted as <code>n2</code> as an argument of the function)<code class="reqn">X_2</code> points, <code class="reqn">n_2</code> of <code class="reqn">X_1</code> points are randomly selected (possibly with replacement) and
for a selected <code>X1</code> point, say <code class="reqn">x_{1ref}</code>,
a new point from the class 2, say <code class="reqn">x_{2new}</code>, is generated from a bivariate normal distribution centered at <code class="reqn">x_{1ref}</code>
where the covariance matrix of the bivariate normal is a diagonal matrix with sigma in the diagonals.
That is, <code class="reqn">x_{2new} = x_{1ref}+V</code> where <code class="reqn">V \sim BVN((0,0),\sigma I_2)</code> with <code class="reqn">I_2</code> being the <code class="reqn">2 \times 2</code> identity matrix.
Note that, the level of association increases as <code>sigma</code> decreases, and the association vanishes when <code>sigma</code> 
goes to infinity.
</p>
<p>For type G association, it is recommended to take <code class="reqn">\sigma \le 0.10</code>  times length of the shorter
edge of a rectangular study region, or take <code class="reqn">r_0 = 1/(k \sqrt{\hat \rho})</code> with the appropriate choice of <code class="reqn">k</code> 
to get an association pattern more robust to differences in relative abundances
(i.e., the choice of <code class="reqn">k</code> implies <code class="reqn">\sigma \le 0.10</code> times length of the shorter edge to have alternative patterns more 
robust to differences in sample sizes).
Here <code class="reqn">\hat \rho</code> is the 
estimated intensity of points in the study region (i.e., # of points divided by the area of the region). 
</p>
<p>Type G association is closely related to Types C and U association,
see the functions <code><a href="#topic+rassocC">rassocC</a></code> and <code><a href="#topic+rassocU">rassocU</a></code> and
the other association types.
In the type C association pattern
the new point from the class 2, <code class="reqn">x_{2new}</code>, is generated (uniform in the polar coordinates) within a circle
centered at <code class="reqn">x_{1ref}</code> with radius equal to <code class="reqn">r_0</code>,
in type U association pattern <code class="reqn">x_{2new}</code> is generated similarly except it is uniform in the circle.
In type I association, first a <code class="reqn">Uniform(0,1)</code> number, <code class="reqn">U</code>, is generated.
If <code class="reqn">U \le p</code>, <code class="reqn">x_{2new}</code> is generated (uniform in the polar coordinates) within a
circle with radius equal to the distance to the closest <code class="reqn">X_1</code> point,
else it is generated uniformly within the smallest bounding box containing <code class="reqn">X_1</code> points.
</p>
<p>See Ceyhan (2014) for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassocG(X1, n2, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassocG_+3A_x1">X1</code></td>
<td>
<p>A set of 2D points representing the reference points, also referred as class 1 points.
The generated points are associated in a type G sense with these points.</p>
</td></tr>
<tr><td><code id="rassocG_+3A_n2">n2</code></td>
<td>
<p>A positive integer representing the number of class 2 points to be generated.</p>
</td></tr>
<tr><td><code id="rassocG_+3A_sigma">sigma</code></td>
<td>
<p>A positive real number representing the variance of the Gaussian marginals, where
the bivariate normal distribution has covariance <code>BVN((0,0),sigma*I_2)</code> with <code class="reqn">I_2</code> being the <code class="reqn">2 \times 2</code> identity matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p>=<code>"ref.gen"</code> for the bivariate pattern of association of class 2 points with the reference points
(i.e., <code class="reqn">X_1</code>), indicates reference points are required to be entered as an argument in the function</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The variance of the Gaussian marginals controlling the level of association, where
the bivariate normal distribution has covariance <code class="reqn">\sigma I_2</code> with <code class="reqn">I_2</code> being the <code class="reqn">2 \times 2</code> identity matrix.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points (i.e., class 2 points) associated with reference (i.e.
<code class="reqn">X_1</code> points)</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code class="reqn">X_1</code>, i.e., points with which generated class 2 points
are associated.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 2 points and
the number of reference (i.e., <code class="reqn">X_1</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassocI">rassocI</a></code>, <code><a href="#topic+rassocG">rassocG</a></code>, <code><a href="#topic+rassocC">rassocC</a></code>, and <code><a href="#topic+rassoc">rassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20; n2&lt;-1000;  #try also n1&lt;-10; n2&lt;-1000;

stdev&lt;-.05  #try also .075 and .15
#with default bounding box (i.e., unit square)
X1&lt;-cbind(runif(n1),runif(n1))   #try also X1&lt;-1+cbind(runif(n1),runif(n1))

Xdat&lt;-rassocG(X1,n2,stdev)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#sigma adjusted with the expected NN distance
x&lt;-range(X1[,1]); y&lt;-range(X1[,2])
ar&lt;-(y[2]-y[1])*(x[2]-x[1]) #area of the smallest rectangular window containing X1 points
rho&lt;-n1/ar
stdev&lt;-1/(4*sqrt(rho)) #r0=1/(2rho) where \code{rho} is the intensity of X1 points
Xdat&lt;-rassocG(X1,n2,stdev)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rassocI'>Generation of Points Associated in the Type I Sense with a Given Set of Points</h2><span id='topic+rassocI'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_2</code> 2D points associated with the given set of points (i.e., reference points) <code class="reqn">X_1</code> in the
type I fashion with circular (or radial) between class attraction parameter <code>p</code>, which is a probability value between 0 and 1.
The generated points are intended to be from a different class, say class 2 (or <code class="reqn">X_2</code> points) than the reference
(i.e., <code class="reqn">X_1</code> points, say class 1 points, denoted as <code>X1</code> as an argument of the function). 
To generate <code class="reqn">n_2</code> (denoted as <code>n2</code> as an argument of the function) <code class="reqn">X_2</code> points, <code class="reqn">n_2</code> of <code class="reqn">X_1</code> points are randomly selected (possibly with replacement) and
for a selected <code>X1</code> point, say <code class="reqn">x_{1ref}</code>, a <code class="reqn">Uniform(0,1)</code> number, <code class="reqn">U</code>, is generated.
If <code class="reqn">U \le p</code>, a new point from the class 2, say <code class="reqn">x_{2new}</code>, is generated within a
circle with radius equal to the distance to the closest <code class="reqn">X_1</code> point (uniform in the polar coordinates),
else the new point is generated uniformly
within the smallest bounding box containing <code class="reqn">X_1</code> points.
That is, if <code class="reqn">U \le p</code>, <code class="reqn">x_{2new} = x_{1ref}+r_u c(\cos(t_u),\sin(t_u))</code>
where <code class="reqn">r_u \sim U(0,rad)</code> and <code class="reqn">t_u \sim U(0, 2\pi)</code> with <code class="reqn">rad=\min(d(x_{1ref},X_1\setminus \{x_{1ref}\}))</code>,
else <code class="reqn">x_{2new} \sim rect(X_1)</code> where <code class="reqn">rect(X_1)</code> is the smallest bounding box containing <code class="reqn">X_1</code> points.
Note that, the level of association increases as <code>p</code> increases, and the association vanishes
when <code>p</code> approaches to 0.
</p>
<p>Type I association is closely related to Type C association in
Ceyhan (2014), see the function <code><a href="#topic+rassocC">rassocC</a></code>
and also other association types.
In the type C association pattern
the new point from the class 2, <code class="reqn">x_{2new}</code>, is generated (uniform in the polar coordinates) within a circle
centered at <code class="reqn">x_{1ref}</code> with radius equal to <code class="reqn">r_0</code>,
in type U association pattern <code class="reqn">x_{2new}</code> is generated similarly except it is uniform in the circle.
In type G association, <code class="reqn">x_{2new}</code> is generated from the bivariate normal distribution centered at <code class="reqn">x_{1ref}</code> with covariance
<code class="reqn">\sigma I_2</code> where <code class="reqn">I_2</code> is <code class="reqn">2 \times 2</code> identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassocI(X1, n2, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassocI_+3A_x1">X1</code></td>
<td>
<p>A set of 2D points representing the reference points, also referred as class 1 points.
The generated points are associated in a type I sense (in a circular/radial fashion) with these points.</p>
</td></tr>
<tr><td><code id="rassocI_+3A_n2">n2</code></td>
<td>
<p>A positive integer representing the number of class 2 (i.e., <code class="reqn">X_2</code>) points to be generated.</p>
</td></tr>
<tr><td><code id="rassocI_+3A_p">p</code></td>
<td>
<p>A real number between 0 and 1 representing the attraction probability of class 2 points associated
with a randomly selected class 1 point (see the description below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements 
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p>equals <code>"ref.gen"</code> for the bivariate pattern of association of class 2 (i.e., <code class="reqn">X_2</code>) points with the reference
points (i.e., <code class="reqn">X_1</code>), indicates reference points are required to be entered as an argument in the function</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radial (i.e., circular) between class attraction parameter controlling the level of association</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points (i.e., class 2 points) associated with reference (i.e.
<code class="reqn">X_1</code> points)</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code class="reqn">X_1</code>, i.e., points with which generated class 2
points are associated.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The class labels of the generated points, it is <code>NULL</code> for this function, since only class 2
points are generated in this pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 2 points and
the number of reference (i.e., <code class="reqn">X_1</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and
the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassocC">rassocC</a></code>, <code><a href="#topic+rassocG">rassocG</a></code>, <code><a href="#topic+rassocU">rassocU</a></code>, and <code><a href="#topic+rassoc">rassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20; n2&lt;-1000;  #try also n1&lt;-10; n2&lt;-1000;

p&lt;- .75 #try also .25, .5, .9, runif(1)
#with default bounding box (i.e., unit square)
X1&lt;-cbind(runif(n1),runif(n1))  #try also X1&lt;-1+cbind(runif(n1),runif(n1))

Xdat&lt;-rassocI(X1,n2,p)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rassocU'>Generation of Points Associated in the Type U Sense with a Given Set of Points</h2><span id='topic+rassocU'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_2</code> 2D points associated with the given set of points (i.e., reference points) <code class="reqn">X_1</code> in the
type U fashion with a radius of association <code class="reqn">r_0</code> (denoted as <code>r0</code> as an argument of the function) which is a positive real number.
The generated points are intended to be from a different class, say class 2 (or <code class="reqn">X_2</code> points) than the reference
(i.e., <code class="reqn">X_1</code> points, say class 1 points, denoted as <code>X1</code> as an argument of the function), say class 1 points). 
To generate <code class="reqn">n_2</code> (denoted as <code>n2</code> as an argument of the function)<code class="reqn">X_2</code> points, <code class="reqn">n_2</code> of <code class="reqn">X_1</code> points are randomly selected (possibly with replacement) and
for a selected <code>X1</code> point, say <code class="reqn">x_{1ref}</code>,
a new point from the class 2, say <code class="reqn">x_{2new}</code>, is generated uniformly within a
circle with radius equal to <code class="reqn">r_0</code>.
That is, <code class="reqn">x_{2new} = x_{1ref}+r_u c(\cos(t_u),\sin(t_u))</code>
where<code class="reqn">r_u=sqrt(U)*r_0</code> with <code class="reqn">U \sim U(0,1)</code> and <code class="reqn">t_u \sim U(0, 2\pi)</code>.
Note that, the level of association increases as <code class="reqn">r_0</code> decreases, and the association vanishes when <code class="reqn">r_0</code> is 
sufficiently large.
</p>
<p>For type U association, it is recommended to take <code class="reqn">r_0 \le 0.10</code> times length of the shorter
edge of a rectangular study region, or take <code class="reqn">r_0 = 1/(k \sqrt{\hat \rho})</code> with the appropriate choice of <code class="reqn">k</code> 
to get an association pattern more robust to differences in relative abundances
(i.e., the choice of <code class="reqn">k</code> implies <code class="reqn">r_0 \le 0.10</code> times length of the shorter edge to have alternative patterns more 
robust to differences in sample sizes).
Here <code class="reqn">\hat \rho</code> is the 
estimated intensity of points in the study region (i.e., # of points divided by the area of the region). 
</p>
<p>Type U association is closely related to Type C association, see the function <code><a href="#topic+rassocC">rassocC</a></code>
and the other association types.
In the type C association pattern
the new point from the class 2, <code class="reqn">x_{2new}</code>, is generated (uniform in the polar coordinates) within a circle
centered at <code class="reqn">x_{1ref}</code> with radius equal to <code class="reqn">r_0</code>.
In type G association, <code class="reqn">x_{2new}</code> is generated from the bivariate normal distribution centered at <code class="reqn">x_{1ref}</code> with covariance
<code class="reqn">\sigma I_2</code> where <code class="reqn">I_2</code> is <code class="reqn">2 \times 2</code> identity matrix.
In type I association, first a <code class="reqn">Uniform(0,1)</code> number, <code class="reqn">U</code>, is generated.
If <code class="reqn">U \le p</code>, <code class="reqn">x_{2new}</code> is generated (uniform in the polar coordinates) within a
circle with radius equal to the distance to the closest <code class="reqn">X_1</code> point,
else it is generated uniformly within the smallest bounding box containing <code class="reqn">X_1</code> points.  
</p>
<p>See Ceyhan (2014) for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rassocU(X1, n2, r0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rassocU_+3A_x1">X1</code></td>
<td>
<p>A set of 2D points representing the reference points, also referred as class 1 points.
The generated points are associated in a type U sense (in a circular/radial fashion) with these points.</p>
</td></tr>
<tr><td><code id="rassocU_+3A_n2">n2</code></td>
<td>
<p>A positive integer representing the number of class 2 points to be generated.</p>
</td></tr>
<tr><td><code id="rassocU_+3A_r0">r0</code></td>
<td>
<p>A positive real number representing the radius of association of class 2 points associated with a
randomly selected class 1 point (see the description below).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p>=<code>"ref.gen"</code> for the bivariate pattern of association of class 2 points with the reference points
(i.e., <code class="reqn">X_1</code>), indicates reference points are required to be entered as an argument in the function</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radius of association controlling the level of association</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points (i.e., class 2 points) associated with reference (i.e.
<code class="reqn">X_1</code> points)</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points <code class="reqn">X_1</code>, i.e., points with which generated class 2 points
are associated.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 2 points and
the number of reference (i.e., <code class="reqn">X_1</code>) points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Simulation and characterization of multi-class spatial patterns from stochastic point processes of randomness, clustering and regularity.&rdquo;
<em>Stochastic Environmental Research and Risk Assessment (SERRA)</em>, <b>38(5)</b>, 1277-1306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassocI">rassocI</a></code>, <code><a href="#topic+rassocG">rassocG</a></code>, <code><a href="#topic+rassocC">rassocC</a></code>, and <code><a href="#topic+rassoc">rassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20; n2&lt;-1000;  #try also n1&lt;-10; n2&lt;-1000;

r0&lt;-.15 #try also .10 and .20
#with default bounding box (i.e., unit square)
X1&lt;-cbind(runif(n1),runif(n1))  #try also X1&lt;-1+cbind(runif(n1),runif(n1))

Xdat&lt;-rassocU(X1,n2,r0)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#radius adjusted with the expected NN distance
x&lt;-range(X1[,1]); y&lt;-range(X1[,2])
ar&lt;-(y[2]-y[1])*(x[2]-x[1]) #area of the smallest rectangular window containing X1 points
rho&lt;-n1/ar
r0&lt;-1/(2*sqrt(rho)) #r0=1/(2rho) where \code{rho} is the intensity of X1 points
Xdat&lt;-rassocU(X1,n2,r0)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rct'>Reflexivity Contingency Table (RCT)</h2><span id='topic+rct'></span>

<h3>Description</h3>

<p>Returns the RCT given the IPD matrix or data set <code>x</code>, the RCT is <code class="reqn">2 \times 2</code> regardless of the 
number of classes in the data set.
</p>
<p>RCT is constructed by categorizing the NN pairs according to pair type as self or mixed and whether
the pair is reflexive or non-reflexive. 
A base-NN pair is called a reflexive pair, if the elements of the pair are NN to each other;
a non-reflexive pair, if the elements of the pair are not NN to each other;
a self pair, if the elements of the pair are from the same class; a mixed pair, if the
elements of the pair are from different classes.
Row labels in the RCT are <code>"ref"</code> for reflexive and <code>"non-ref"</code> for non-reflexive and 
column labels are <code>"self"</code> and <code>"mixed"</code>.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be the inter-point distance (IPD) matrix, and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>
<p>See also (Ceyhan and Bahadir (2017); Bahadir and Ceyhan (2018))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rct(x, lab, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rct_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="rct_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="rct_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix, otherwise, <code>x</code> is taken as the data set with rows representing the data points.</p>
</td></tr>
<tr><td><code id="rct_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">2 \times 2</code> RCT, see the description above for more detail.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Bahadir S, Ceyhan E (2018).
&ldquo;On the Number of reflexive and shared nearest neighbor pairs in one-dimensional uniform data.&rdquo;
<em>Probability and Mathematical Statistics</em>, <b>38(1)</b>, 123-137.<br /><br /> Ceyhan E, Bahadir S (2017).
&ldquo;Nearest Neighbor Methods for Testing Reflexivity.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>24(1)</b>, 69-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnct">nnct</a></code>, <code><a href="#topic+tct">tct</a></code> and <code><a href="#topic+scct">scct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

rct(ipd,cls)
rct(Y,cls,is.ipd = FALSE)
rct(Y,cls,is.ipd = FALSE,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
rct(ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

rct(ipd,cls)

</code></pre>

<hr>
<h2 id='rdiag.clust'>Generation of Points with Clusters along the First Diagonal</h2><span id='topic+rdiag.clust'></span>

<h3>Description</h3>

<p>An object of class <code>"Clusters"</code>.
</p>
<p>Generates <code>n</code> 2D points with <code>k</code> (<code class="reqn">k \ge 2</code>) clusters along the first diagonal 
where about <code class="reqn">n/k</code> points belongs to each cluster.
</p>
<p>If <code>distribution="uniform"</code>, the points are uniformly generated in their square
supports where one square is the unit square (i.e., with vertices <code class="reqn">(0,0), (1,0), (1,1),(0,1)</code>), and 
the others are unit squares translated <code class="reqn">j \sqrt{2} d</code>  units along the first diagonal for <code class="reqn">j=1,2,\ldots,k-1</code>
(i.e., with vertices <code class="reqn">(j d,j d), (1+j d,j d), (1+j d,1+j d),(j d,1+j d)</code>). 
</p>
<p>If <code>distribution="bvnormal"</code>, the points are generated from the bivariate normal distribution with means equal to the
centers of the above squares (i.e., for each cluster with <code>mean=</code><code class="reqn">((1+j d)/2,(1+j d)/2)</code> for <code class="reqn">j=0,1,\ldots,k-1</code>
and the covariance matrix <code class="reqn">sd I_2</code>, where <code class="reqn">I_2</code> is the <code class="reqn">2 \times 2</code> identity matrix.
</p>
<p>Notice that the clusters are more separated, i.e., generated data indicates more clear clusters as <code class="reqn">d</code> increases
in either positive or negative direction with <code class="reqn">d=0</code> indicating one cluster in the data. For a fixed <code class="reqn">d</code>, when <code>distribution="bvnormal"</code>,
the clustering gets stronger if the variance of each component, <code class="reqn">sd^2</code>, gets smaller, and clustering gets weaker
as the variance of each component gets larger where default is <code class="reqn">sd=1/6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdiag.clust(n, k, d, sd = 1/6, distribution = c("uniform", "bvnormal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdiag.clust_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points to be generated from the two clusters</p>
</td></tr>
<tr><td><code id="rdiag.clust_+3A_k">k</code></td>
<td>
<p>A positive integer representing the number of clusters to be generated</p>
</td></tr>
<tr><td><code id="rdiag.clust_+3A_d">d</code></td>
<td>
<p>Shift in the first diagonal indicating the level of clustering in the data. Larger absolute values in
either direction (i.e., positive or negative) would yield stronger clustering.</p>
</td></tr>
<tr><td><code id="rdiag.clust_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the components of the bivariate normal distribution with default <code class="reqn">sd=1/6</code>, 
used only when <code>distribution="bvnormal"</code>.</p>
</td></tr>
<tr><td><code id="rdiag.clust_+3A_distribution">distribution</code></td>
<td>
<p>The argument determining the distribution of each cluster. Takes on values <code>"uniform"</code> and
<code>"bvnormal"</code> whose centers are <code class="reqn">d</code> units apart along the first diagonal direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the clustering pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The number of clusters, <code>k</code>, the diagonal shift d representing the level of clustering
(for both distribution types) and standard deviation, <code>sd</code>, for the bivariate normal distribution only</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points from the clusters.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the clustering pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of generated points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhor.clust">rhor.clust</a></code> and <code><a href="#topic+rrot.clust">rrot.clust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1);  #try also n&lt;-50; n&lt;-1000;
d&lt;-.5 #try also -75,.75, 1
k&lt;-3 #try also 5

#data generation
Xdat&lt;-rdiag.clust(n,k,d)
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#data generation (bvnormal)
n&lt;-20  #or try sample(1:20,1);  #try also n&lt;-50; n&lt;-1000;
d&lt;-.5 #try also -.75,.75, 1
k&lt;-3 #try also 5
Xdat&lt;-rdiag.clust(n,k,d,distr="bvnormal") #try also Xdat&lt;-rdiag.clust(n,k,d,sd=.09,distr="bvnormal")
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rhor.clust'>Generation of Points with Clusters along the Horizontal Axis</h2><span id='topic+rhor.clust'></span>

<h3>Description</h3>

<p>An object of class <code>"Clusters"</code>.
</p>
<p>Generates <code>n</code> 2D points with <code>k</code> (<code class="reqn">k \ge 2</code>) clusters along the horizontal axis
where about <code class="reqn">n/k</code> points belongs to each cluster.
</p>
<p>If <code>distribution="uniform"</code>, the points are uniformly generated in their square
supports where one square is the unit square (i.e., with vertices <code class="reqn">(0,0), (1,0), (1,1),(0,1)</code>), and 
the others are <code class="reqn">d</code> units shifted horizontally from each other so that their lower end vertices are
<code class="reqn">(j-1)+(j-1) d</code> for <code class="reqn">j=1,2,\ldots,k</code>.
</p>
<p>If <code>distribution="bvnormal"</code>, the points are generated from the bivariate normal distribution with means equal to the
centers of the above squares (i.e., for each cluster with mean=(j+(j-1)d-1/2,1/2) for <code class="reqn">j=1,2,\ldots,k</code>
and the covariance matrix <code class="reqn">sd I_2</code>, where <code class="reqn">I_2</code> is the <code class="reqn">2 \times 2</code> identity matrix.
</p>
<p>Notice that the clusters are more separated, i.e., generated data indicates more clear clusters as <code class="reqn">d</code> increases
in either direction with <code class="reqn">d=0</code> indicating one cluster in the data. For a fixed <code class="reqn">d</code>, when <code>distribution="bvnormal"</code>,
the clustering gets stronger if the variance of each component, <code class="reqn">sd^2</code>, gets smaller, and clustering gets weaker
as the variance of each component gets larger where default is <code class="reqn">sd=1/6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhor.clust(n, k, d, sd = 1/6, distribution = c("uniform", "bvnormal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhor.clust_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points to be generated from all the clusters</p>
</td></tr>
<tr><td><code id="rhor.clust_+3A_k">k</code></td>
<td>
<p>A positive integer representing the number of clusters to be generated</p>
</td></tr>
<tr><td><code id="rhor.clust_+3A_d">d</code></td>
<td>
<p>Horizontal shift indicating the level of clustering in the data. Larger absolute values in either
direction (i.e., positive or negative) would yield stronger clustering.</p>
</td></tr>
<tr><td><code id="rhor.clust_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the components of the bivariate normal distribution with default <code class="reqn">sd=1/6</code>, 
used only when <code>distribution="bvnormal"</code>.</p>
</td></tr>
<tr><td><code id="rhor.clust_+3A_distribution">distribution</code></td>
<td>
<p>The argument determining the distribution of each cluster. Takes on values <code>"uniform"</code> and
<code>"bvnormal"</code> whose centers are <code class="reqn">d</code> units apart along the horizontal direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the clustering pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The number of clusters, <code>k</code>, and the horizontal shift, <code>d</code>, representing the level of clustering
(for both distribution types) and standard deviation, <code>sd</code>, for the bivariate normal distribution only.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points from the <code>k</code> clusters.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the clustering pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of generated points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdiag.clust">rdiag.clust</a></code> and <code><a href="#topic+rrot.clust">rrot.clust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-100;  #try also n&lt;-50; or n&lt;-1000;
d&lt;-.5 #try also -.5,.75, 1
k&lt;-3 #try also 5

#data generation
Xdat&lt;-rhor.clust(n,k,d)
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#data generation (bvnormal)
n&lt;-100;  #try also n&lt;-50; n&lt;-1000;
d&lt;-.1 #try also -.1, .75, 1
k&lt;-3 #try also 5
Xdat&lt;-rhor.clust(n,k,d,distr="bvnormal") #try also Xdat&lt;-rhor.clust(n,k,d,sd=.15,distr="bvnormal")
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rnonRL'>Non-Random Labeling of a Given Set of Points</h2><span id='topic+rnonRL'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Given the set of <code class="reqn">n</code> points, <code>dat</code>, in a region, this function assigns some of them as cases,
and the rest as controls in a non-RL <code>type=type</code> fashion. 
</p>
<p>Type I nonRL pattern assigns <code class="reqn">n_1=</code><code>round(n*prop,0)</code> of the data points as cases,
and the rest as controls with first selecting a point, <code class="reqn">Z_i</code>, as a case and assigning the
label case to the remaining points with infection probabilities <code>prob=c(prop+((1-prop)*rho)/(1:k))</code> where <code>rho</code> is a
parameter adjusting the NN dependence of infection probabilities.
</p>
<p>Type II nonRL pattern assigns <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> of them as cases,
and the rest as controls with first selecting <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> as cases initially, then selecting
a contagious case and then assigning the label case to the remaining points with infection probabilities 
inversely proportional to their position in the <code>k</code>NNs.
</p>
<p>Type III nonRL pattern assigns <code class="reqn">n_1=</code><code>round(n*prop,0)</code> of them as cases,
and the rest as controls with first selecting a point, <code class="reqn">Z_i</code>, as a case and assigning the
label case to the remaining points with infection probabilities <code class="reqn">prob=rho (1-d_{ij}/d_{\max})^{pow}</code> where <code class="reqn">d_{ij}</code> is the
distance from <code class="reqn">Z_j</code> to <code class="reqn">Z_i</code> for <code class="reqn">j \ne i</code>, <code class="reqn">d_{\max}</code> is the maximum of  <code class="reqn">d_{ij}</code>  values, <code>rho</code> is a scaling parameter for
the infection probabilities and <code>pow</code> is a parameter in the power adjusting the distance dependence.
</p>
<p>Type IV nonRL pattern assigns <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> of them as cases,
and the rest as controls with first selecting <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> as cases initially and assigning the
label case to the remaining points with infection probabilities equal to the scaled bivariate normal density values
at those points.
</p>
<p>The number of cases in Types I and III will be <code class="reqn">n_1</code> on the average if the argument <code>poisson=TRUE</code>
(i.e., <code class="reqn">n_1=</code><code>rpois(1,round(n*prop,0))</code> ), otherwise <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.
The initial and ultimate number of cases in Types II and IV will be <code class="reqn">k_0</code> and <code class="reqn">n_1</code> on the average if the argument
<code>poisson=TRUE</code> (i.e., <code class="reqn">k_0=</code><code>rpois(1,round(n*init.prop,0)</code>) and <code class="reqn">n_1=</code><code>rpois(1,round(n*ult.prop,0))</code>), otherwise
they will be exactly equal to <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> and <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code>.
</p>
<p>At each type, we stop when we first exceed <code class="reqn">n_1</code> cases. That is, the procedure ends when number of cases <code class="reqn">n_c</code>
exceed <code class="reqn">n_1</code>, and <code class="reqn">n_c-n_1</code> of the cases (other than the initial case(s)) are randomly selected and relabeled as
controls, i.e., 0s, so that the number of cases is exactly <code class="reqn">n_1</code>.
</p>
<p>In the output cases are labeled as 1 and controls as 0, and initial contagious case is marked with a red cross
in the plot of the pattern.
</p>
<p>See Ceyhan (2014) and the functions <code><a href="#topic+rnonRLI">rnonRLI</a></code>,
<code><a href="#topic+rnonRLII">rnonRLII</a></code>, <code><a href="#topic+rnonRLIII">rnonRLIII</a></code>, and <code><a href="#topic+rnonRLIV">rnonRLIV</a></code> for more detail on each type of
non-RL pattern.
</p>
<p>Although the non-RL pattern is described for the case-control setting, it can be adapted for any two-class
setting when it is appropriate to treat one of the classes as cases or one of the classes behave like cases
and other class as controls.
</p>
<p>The parameters of the non-RL patterns are specified in the argument <code>par.vec</code>, and the logical arguments <code>rand.init</code>
and poisson pass on to the types where required. <code>rand.init</code> is not used in type I but used in all other types,
poisson is used in all types, and init.from.cases is used in type I non-RL only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnonRL(
  dat,
  par.vec,
  type,
  rand.init = TRUE,
  poisson = FALSE,
  init.from.cases = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnonRL_+3A_dat">dat</code></td>
<td>
<p>A set of points the non-RL procedure is applied to obtain cases and controls randomly in the 
<code>type=type</code> fashion (see the description).</p>
</td></tr>
<tr><td><code id="rnonRL_+3A_par.vec">par.vec</code></td>
<td>
<p>The parameter vector. It is <code>c(prop,k,rho)</code> for type I, <code>c(k,rho,pow,init.prop,ult.prop)</code>
for type II, <code>c(prop,rho,pow)</code> for type III, and <code>c(init.prop,ult.prop,s1,s2,rho)</code> for type IV non-RL patterns.
The parameters must be entered in this order in <code>par.vec</code> as a vector.
See the respective functions for more detail on the parameters.</p>
</td></tr>
<tr><td><code id="rnonRL_+3A_type">type</code></td>
<td>
<p>The type of the non-RL pattern. Takes on values <code>"I"</code>-<code>"IV"</code> for types I-IV non-RL
patterns (see the description above).</p>
</td></tr>
<tr><td><code id="rnonRL_+3A_rand.init">rand.init</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine the choice of the initial case(s)
in the data set, <code>dat</code> for types II-IV non-RL pattern. If <code>rand.init=TRUE</code> then the initial case(s) is (are)
selected randomly from the data points, and if <code>rand.init=FALSE</code>, the first one is labeled as a case for type III
and the first <code>init.prop*n</code> entries in the data set, <code>dat</code>, are labeled as the cases types II and IV.</p>
</td></tr>
<tr><td><code id="rnonRL_+3A_poisson">poisson</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the number of cases is random or fixed.
In types II and IV initial and ultimate number of cases, <code class="reqn">k_0</code> and <code class="reqn">n_1</code>, will be random if <code>poisson=TRUE</code> and fixed
otherwise. In types I and III the number of cases, <code class="reqn">n_1</code>, will be random if poisson=TRUEURE and fixed otherwise.
See the description.</p>
</td></tr>
<tr><td><code id="rnonRL_+3A_init.from.cases">init.from.cases</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the initial cases at each
round will be take from cases or controls in type I non-RL pattern. 
The initial cases are taken from cases if <code>init.from.cases=TRUE</code>, and from controls otherwise.
See the function <code><a href="#topic+rnonRLI">rnonRLI</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>="cc"</code> for the case-control patterns for RL or non-RL of the given data points, <code>dat</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p><code>par.vec</code>, the parameters required for each type of non-RL pattern. See the description
in the parameter list.</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The labels of the points as 1 for cases and 0 for controls after the nonRL procedure is
applied to the data set, <code>dat</code>. Cases are denoted as red dots and controls as black circles in the plot.</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial cases in the data set, <code>dat</code>. Marked with red crosses in the plot of the points.</p>
</td></tr>
<tr><td><code>cont.cases</code></td>
<td>
<p>The contagious cases in the data set, <code>dat</code> in type II non-RL pattern.
Denoted as blue points in the plot of the points.</p>
</td></tr>
<tr><td><code>gen.points</code>, <code>ref.points</code></td>
<td>
<p>Both are <code>NULL</code> for this function, as initial set of points, <code>dat</code>, are provided
for all of the non-RL procedures.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of cases and controls.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnonRLI">rnonRLI</a></code>, <code><a href="#topic+rnonRLII">rnonRLII</a></code>, <code><a href="#topic+rnonRLIII">rnonRLIII</a></code>, and <code><a href="#topic+rnonRLIV">rnonRLIV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data generation
n&lt;-40;  #try also n&lt;-20; n&lt;-100;
dat&lt;-cbind(runif(n,0,1),runif(n,0,1))

#Type I non-RL pattern
#c(prop,k,rho) for type I
prop&lt;-.5; knn&lt;-3; rho&lt;- .3
prv&lt;-c(prop,knn,rho)

Xdat&lt;-rnonRL(dat,type="I",prv) #labeled data 
# or try Xdat&lt;-rnonRL(dat,type="I",prv) for type I non-RL
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#Type II non-RL pattern
#c(k,rho,pow,init.prop,ult.prop) for type II
rho&lt;-.8; pow&lt;-2; knn&lt;-5; ip&lt;-.3; up&lt;-.5
prv&lt;-c(knn,rho,pow,ip,up)

Xdat&lt;-rnonRL(dat,type="II",prv) #labeled data 
# or try Xdat&lt;-rnonRL(dat,type="I",prv) for type I non-RL
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#Type III non-RL pattern
#c(prop,rho,pow) for type III
prop&lt;- .5; rho&lt;-.8; pow&lt;-2
prv&lt;-c(prop,rho,pow)

Xdat&lt;-rnonRL(dat,type="III",prv) #labeled data 
# or try Xdat&lt;-rnonRL(dat,type="I",prv) for type I non-RL
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#Type IV non-RL pattern
#c(init.prop,ult.prop,s1,s2,rho) for type IV
ult&lt;-.5; int&lt;- .1; s1&lt;-s2&lt;-.4; rho&lt;- .1
prv&lt;-c(int,ult,s1,s2,rho)

Xdat&lt;-rnonRL(dat,type="IV",prv) #labeled data 
# or try Xdat&lt;-rnonRL(dat,type="I",prv) for type I non-RL
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat) 
  
</code></pre>

<hr>
<h2 id='rnonRLI'>Type I Non-Random Labeling of a Given Set of Points</h2><span id='topic+rnonRLI'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Given the set of <code class="reqn">n</code> points, <code>dat</code>, in a region, this function assigns <code class="reqn">n_1=</code><code>round(n*prop,0)</code> of them as cases,
and the rest as controls with first selecting a point, <code class="reqn">Z_i</code>, as a case and assigning the
label case to the remaining points with infection probabilities 
<code>prob=c(prop+((1-prop)*rho)/(1:k))</code> where <code>rho</code> is a
parameter adjusting the NN dependence of infection probabilities.
The number of cases will be <code class="reqn">n_1</code> on the average if the argument <code>poisson=TRUE</code>
(i.e., <code class="reqn">n_1=</code><code>rpois(1,round(n*prop,0))</code>), otherwise <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.
We stop when we first exceed <code class="reqn">n_1</code> cases. <code>rho</code> must be between <code>-prop/(1-prop)</code> and 1 for the infection
probabilities to be valid.
The <code>init.from.cases</code> is a logical argument (with default=<code>TRUE</code>) to determine the initial cases are from the
cases or controls (the first initial case is always from controls), so, if <code>TRUE</code>, initial cases (other than
the first initial case) are selected randomly among the cases (as if they are contagious), otherwise,
they are selected from controls as new cases infecting their <code>k</code>NNs.
otherwise first entry is chosen as the case (or case is recorded as the first entry) in the data set, <code>dat</code>.  
</p>
<p>Algorithmically, first all dat points are treated as non-cases (i.e., controls or healthy subjects).
Then the function follows the following steps for labeling of the points:  
</p>
<p>step 0: <code class="reqn">n_1</code> is generated randomly from a Poisson distribution with <code>mean = n*prop</code>, so that the 
average number of cases is <code>n*prop</code>. 
</p>
<p>step 0: <code class="reqn">n_1</code> is generated randomly from a Poisson distribution with <code>mean = round(n*prop,0)</code>, so that the 
average number of cases will be <code>round(n*prop,0)</code>
if the argument <code>poisson=TRUE</code>, else <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.
</p>
<p>step 1: Initially, one point from dat is selected randomly as a case. In the first round this point is selected
from the controls, and the subsequent rounds, it is selected from cases if the argument <code>init.from.cases=TRUE</code>,
and from controls otherwise. Then it assigns the label case to the <code>k</code>NNs among controls of the initial case
selected in step 1 with infection probabilities <code>prob=c(prop+((1-prop)*rho)/(1:k))</code>, see the description for the details
of the parameters in the <code>prob</code>.
</p>
<p>step 2: Then this initial case and cases among its <code>k</code>NNs (possibly all <code class="reqn">k+1</code> points) in step 2 are removed from
the data, and for the remaining control points step 1 is applied where initial point is from cases or control
based on the argument init.from.cases.
</p>
<p>step 3: The procedure ends when number of cases <code class="reqn">n_c</code> exceeds <code class="reqn">n_1</code>, and <code class="reqn">n_c-n_1</code> of the cases (other than the
initial cases) are randomly selected and relabeled as controls, i.e., 0s,
so that the number of cases is exactly <code class="reqn">n_1</code>.
</p>
<p>In the output cases are labeled as 1 and controls as 0.
Note that the infection probabilities of the <code>k</code>NNs of each initial case increase
with increasing rho, and infection probability decreases for increasing k in the <code>k</code>NNs. 
</p>
<p>See Ceyhan (2014) for more detail where type I non-RL pattern is the 
case 1 of non-RL pattern considered in Section 6 with <code class="reqn">n_1</code> is
fixed as a parameter rather than being generated from a Poisson distribution and <code>init=FALSE</code>.
</p>
<p>Although the non-RL pattern is described for the case-control setting, it can be adapted for any two-class
setting when it is appropriate to treat one of the classes as cases or one of the classes behave like cases
and other class as controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnonRLI(dat, prop = 0.5, k, rho, poisson = FALSE, init.from.cases = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnonRLI_+3A_dat">dat</code></td>
<td>
<p>A set of points the non-RL procedure is applied to obtain cases and controls randomly in the 
type I fashion (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLI_+3A_prop">prop</code></td>
<td>
<p>A real number between 0 and 1 (inclusive) representing the proportion of new cases (on the average)
infected by the initial cases, i.e., number of newly infected cases (in addition to the initial cases) is
Poisson with <code>mean=round(n*prop)</code> where <code class="reqn">n</code> is the number of points in <code>dat</code>, if the argument <code>poisson=TRUE</code>,
else it is <code>round(n*prop)</code>.</p>
</td></tr>
<tr><td><code id="rnonRLI_+3A_k">k</code></td>
<td>
<p>An integer representing the number of NNs considered for each initial case, i.e., <code>k</code>NNs of each
initial case are candidates to be infected to become cases.</p>
</td></tr>
<tr><td><code id="rnonRLI_+3A_rho">rho</code></td>
<td>
<p>A parameter for labeling the <code>k</code>NNs of each initial case as cases such that <code>k</code>NNs of each initial case
is infected with decreasing probabilities <code>prob=c(prop+((1-prop)*rho)/(1:k))</code> where
<code>rho</code> has to be between <code>-prop/(1-prop)</code> and 1 for <code>prob</code> to be a <code>vector</code> of probabilities.</p>
</td></tr>
<tr><td><code id="rnonRLI_+3A_poisson">poisson</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the number of cases <code class="reqn">n_1</code>,
will be random or fixed. If <code>poisson=TRUE</code> then the <code class="reqn">n_1</code> is from a Poisson distribution, 
<code class="reqn">n_1=</code><code>rpois(1,round(n*prop,0))</code> 
otherwise it is fixed, <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.</p>
</td></tr>
<tr><td><code id="rnonRLI_+3A_init.from.cases">init.from.cases</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the initial cases at each
round will be take from cases or controls. At first round, the initial cases are taken from controls.
And in the subsequent rounds, the initial cases are taken from cases if <code>init.from.cases=TRUE</code>,
and from controls otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements 
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>="cc"</code> for the case-control patterns for RL or non-RL of the given data points, <code>dat</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p><code>prop</code>, <code>rho</code>, and <code>k</code> values for this non-RL pattern, see the description for these
parameters.</p>
</td></tr>
<tr><td><code>dat.points</code></td>
<td>
<p>The set of points non-RL procedure is applied to obtain cases and controls randomly in the 
type I fashion</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The labels of the points as 1 for cases and 0 for controls after the type I nonRL procedure is
applied to the data set, <code>dat</code>. Cases are denoted as red dots and controls as black circles in the plot.</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial cases in the data set, <code>dat</code>. Marked with red crosses in the plot of the points.</p>
</td></tr>
<tr><td><code>gen.points</code>, <code>ref.points</code></td>
<td>
<p>Both are <code>NULL</code> for this function, as initial set of points, <code>dat</code>, are provided
for the non-RL procedure.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of cases and controls.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnonRLII">rnonRLII</a></code>, <code><a href="#topic+rnonRLIII">rnonRLIII</a></code>, <code><a href="#topic+rnonRLIV">rnonRLIV</a></code>, and <code><a href="#topic+rnonRL">rnonRL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-40;  #try also n&lt;-20; n&lt;-100;
#data generation
dat&lt;-cbind(runif(n,0,1),runif(n,0,1))

prop&lt;-.5; #try also .25, .75
rho&lt;- .3
knn&lt;-3 #try 2 or 5

Xdat&lt;-rnonRLI(dat,prop,knn,rho,poisson=FALSE,init=FALSE) 
#labeled data try also poisson=TRUE or init=FALSE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#normal original data
n&lt;-40;  #try also n&lt;-20; n&lt;-100;
#data generation
dat&lt;-cbind(rnorm(n,0,1),rnorm(n,0,1))

prop&lt;-.50; #try also .25, .75
rho&lt;- .3
knn&lt;-5 #try 2 or 3

Xdat&lt;-rnonRLI(dat,prop,knn,rho,poisson=FALSE) #labeled data try also poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rnonRLII'>Type II Non-Random Labeling of a Given Set of Points</h2><span id='topic+rnonRLII'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Given the set of <code class="reqn">n</code> points, <code>dat</code>, in a region, this function assigns <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> of them as cases,
and the rest as controls with first selecting <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> as cases initially, then selecting
a contagious case and then assigning the label case to the remaining points with infection probabilities 
inversely proportional to their position among the <code>k</code>NNs.
</p>
<p>The initial and ultimate number of cases will be <code class="reqn">k_0</code> and <code class="reqn">n_1</code> on the average if the argument <code>poisson=TRUE</code>
(i.e., <code class="reqn">k_0=</code><code>rpois(1,round(n*init.prop,0)</code>) and <code class="reqn">n_1=</code><code>rpois(1,round(n*ult.prop,0))</code> ), otherwise
they will be exactly equal to <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> and <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code>.
More specifically, let <code class="reqn">z_1,\ldots,z_{k_0}</code> be the initial cases. Then one of the cases is selected as a
contagious case, say <code class="reqn">z_j</code> and then its <code>k</code>NNs (among the non-cases) are found.
Then label these <code>k</code>NN non-case points as cases with infection probabilities <code>prob</code> equal to the value
of the <code>rho*(1/(1:k))^pow</code> values at these points, where <code>rho</code> is a scaling parameter for
the infection probabilities and <code>pow</code> is a parameter in the power adjusting the <code>k</code>NN dependence.
We stop when we first exceed <code class="reqn">n_1</code> cases. <code>rho</code> has to be in <code class="reqn">(0,1)</code> for <code>prob</code> to be a <code>vector</code> of probabilities,
and for a given <code>rho</code>, <code>pow</code> must be <code class="reqn">&gt;  \ln(rho)/\ln(k)</code>.
If <code>rand.init=TRUE</code>, first <code class="reqn">k_0</code> entries are chosen as the initial cases in the data set,
<code>dat</code>, otherwise, <code class="reqn">k_0</code> initial cases are selected randomly among the data points.
</p>
<p>Algorithmically, first all dat points are treated as non-cases (i.e., controls or healthy subjects).
Then the function follows the following steps for labeling of the points: 
</p>
<p>step 0: <code class="reqn">n_1</code> is generated randomly from a Poisson distribution with <code>mean = round(n*ult.prop,0)</code>, so that the 
average number of ultimate cases will be <code>round(n*ult.prop,0)</code> if the argument <code>poisson=TRUE</code>, else <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code>.
And <code class="reqn">k_0</code> is generated randomly from a Poisson distribution with <code>mean = round(n*init.prop,0)</code>, so that the 
average number of initial cases will be <code>round(n*init.prop,0)</code> if the argument <code>poisson=TRUE</code>, else <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code>.
</p>
<p>step 1: Initially, <code class="reqn">k_0</code> many points from dat are selected as cases.
The selection of initial cases are determined based on the argument <code>rand.init</code> (with default=<code>TRUE</code>)
where if <code>rand.init=TRUE</code> then the initial cases are selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first <code class="reqn">k_0</code> entries in the data set, <code>dat</code>, are selected as the cases.
</p>
<p>step 2: Then it selects a contagious case among the cases, and randomly labels its <code>k</code> control NNs as cases with
decreasing infection probabilities <code>prob=rho*(1/(1:k))^pow</code>. See the description for the details
of the parameters in the <code>prob</code>.
</p>
<p>step 3: The procedure ends when number of cases <code class="reqn">n_c</code> exceeds <code class="reqn">n_1</code>, and <code class="reqn">n_c-n_1</code> of the cases (other than the
initial cases) are randomly selected and relabeled as controls, i.e., 0s,
so that the number of cases is exactly <code class="reqn">n_1</code>.
</p>
<p>Note that the infection probabilities of the <code>k</code>NNs of each initial case increase
with increasing rho; and probability of infection decreases as further NNs are considered from 
a contagious case (i.e., as <code>k</code> increases in the <code>k</code>NNs).
</p>
<p>See Ceyhan (2014) for more detail where type II non-RL pattern is the 
case 2 of non-RL pattern considered in Section 6 with <code class="reqn">n_1</code> is
fixed as a parameter rather than being generated from a Poisson distribution and <code>pow=1</code>.
</p>
<p>Although the non-RL pattern is described for the case-control setting, it can be adapted for any two-class
setting when it is appropriate to treat one of the classes as cases or one of the classes behave like cases
and other class as controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnonRLII(
  dat,
  k,
  rho,
  pow,
  init.prop,
  ult.prop,
  rand.init = TRUE,
  poisson = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnonRLII_+3A_dat">dat</code></td>
<td>
<p>A set of points the non-RL procedure is applied to obtain cases and controls randomly in the 
type II fashion (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_k">k</code></td>
<td>
<p>An integer representing the number of NNs considered for each contagious case, i.e., 
<code>k</code>NNs of each contagious case are candidates to be infected to become cases.</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_rho">rho</code></td>
<td>
<p>A scaling parameter for the probabilities of labeling the points as cases
(see the description).</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_pow">pow</code></td>
<td>
<p>A parameter in the power adjusting the <code>k</code>NN dependence in the probabilities of labeling the
points as cases (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_init.prop">init.prop</code></td>
<td>
<p>A real number between 0 and 1 representing the initial proportion of cases in the data set,
<code>dat</code>. The selection of the initial cases depends on the parameter <code>rand.init</code> (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_ult.prop">ult.prop</code></td>
<td>
<p>A real number between 0 and 1 representing the ultimate proportion of cases in the data set,
<code>dat</code> after the non-RL assignment.</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_rand.init">rand.init</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine the choice of the initial cases in the data set, <code>dat</code>.
If <code>rand.init=TRUE</code> then the initial cases are selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first <code>init.prop*n</code> entries in the data set, <code>dat</code>, are labeled as the cases.</p>
</td></tr>
<tr><td><code id="rnonRLII_+3A_poisson">poisson</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the number of initial and ultimate
cases, <code class="reqn">k_0</code> and <code class="reqn">n_1</code>, will be random or fixed. If <code>poisson=TRUE</code> then the <code class="reqn">k_0</code> and <code class="reqn">n_1</code> are from a Poisson distribution,
<code class="reqn">k_0=</code><code>rpois(1,round(n*init.prop,0)</code>) and <code class="reqn">n_1=</code><code>rpois(1,round(n*ult.prop,0))</code>
otherwise they are fixed, <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> and <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>="cc"</code> for the case-control patterns for RL or non-RL of the given data points, <code>dat</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Number of NNs, <code>k</code>, a scaling parameter for the infection probabilities of <code>k</code>NNs, rho,
a parameter in the power adjusting the <code>k</code>NN dependence of the infection probabilities, initial proportion
of cases, <code>init.prop</code>, and the ultimate proportion of cases, <code>ult.prop</code>.</p>
</td></tr>
<tr><td><code>dat.points</code></td>
<td>
<p>The set of points non-RL procedure is applied to obtain cases and controls randomly in the 
type II fashion</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The labels of the points as 1 for cases and 0 for controls after the type II nonRL procedure is
applied to the data set, <code>dat</code>. Cases are denoted as red dots and controls as black circles in the plot.</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial cases in the data set, <code>dat</code>. Denoted as red crosses in the plot of the points.</p>
</td></tr>
<tr><td><code>cont.cases</code></td>
<td>
<p>The contagious cases in the data set, <code>dat</code>. Denoted as blue points in the plot of the points.</p>
</td></tr>
<tr><td><code>gen.points</code>, <code>ref.points</code></td>
<td>
<p>Both are <code>NULL</code> for this function, as initial set of points, <code>dat</code>, are provided
for the non-RL procedure.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of cases and controls.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnonRLI">rnonRLI</a></code>, <code><a href="#topic+rnonRLIII">rnonRLIII</a></code>, <code><a href="#topic+rnonRLIV">rnonRLIV</a></code>, and <code><a href="#topic+rnonRL">rnonRL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-40;  #try also n&lt;-20; n&lt;-100;
#data generation
dat&lt;-cbind(runif(n,0,1),runif(n,0,1))

rho&lt;-.8
pow&lt;-2
knn&lt;-5 #try 2 or 3
ip&lt;-.3 #initial proportion
up&lt;-.5 #ultimate proportion

Xdat&lt;-rnonRLII(dat,knn,rho,pow,ip,up,poisson=FALSE) #labeled data, try poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#normal original data
n&lt;-40;  #try also n&lt;-20; n&lt;-100;
#data generation
dat&lt;-cbind(rnorm(n,0,1),rnorm(n,0,1))

rho&lt;-0.8
pow&lt;-2
knn&lt;-5 #try 2 or 3
ip&lt;-.3 #initial proportion
up&lt;-.5 #ultimate proportion

Xdat&lt;-rnonRLII(dat,knn,rho,pow,ip,up,poisson=FALSE) #labeled data, try poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rnonRLIII'>Type III Non-Random Labeling of a Given Set of Points</h2><span id='topic+rnonRLIII'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Given the set of <code class="reqn">n</code> points, <code>dat</code>, in a region, this function assigns <code class="reqn">n_1=</code><code>round(n*prop,0)</code> of them as cases,
and the rest as controls with first selecting a point, <code class="reqn">Z_i</code>, as a case and assigning the
label case to the remaining points with infection probabilities <code class="reqn">prob=rho (1-d_{ij}/d_{\max})^{pow}</code> where <code class="reqn">d_{ij}</code> is the
distance from <code class="reqn">Z_j</code> to <code class="reqn">Z_i</code> for <code class="reqn">j \ne i</code>, <code class="reqn">d_{\max}</code> is the maximum of  <code class="reqn">d_{ij}</code>  values, <code>rho</code> is a scaling parameter for
the infection probabilities and <code>pow</code> is a parameter in the power adjusting the distance dependence.
The number of cases will be <code class="reqn">n_1</code> on the average if the argument <code>poisson=TRUE</code>
(i.e., <code class="reqn">n_1=</code><code>rpois(1,round(n*prop,0))</code> ), otherwise <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.
We stop when we first exceed <code class="reqn">n_1</code> cases. <code>rho</code> has to be positive for <code>prob</code> to be a <code>vector</code> of probabilities,
and for a given <code>rho</code>, <code>pow</code> must be <code class="reqn">&gt; - \ln(rho)/\ln(1-d_{ij}/d_{\max})</code>,
also when <code>pow</code> is given, <code>rho</code> must be <code class="reqn">&lt; (1-d_{ij}/d_{\max})^{-pow}</code>.
If <code>rand.init=TRUE</code>, initial case is selected randomly among the data points,
otherwise first entry is chosen as the case (or case is recorded as the first entry) in the data set, <code>dat</code>. 
</p>
<p>Algorithmically, first all dat points are treated as non-cases (i.e., controls or healthy subjects).
Then the function follows the following steps for labeling of the points: 
</p>
<p>step 0: <code class="reqn">n_1</code> is generated randomly from a Poisson distribution with <code>mean = round(n*prop,0)</code>, so that the 
average number of cases will be round(n*prop,0) if the argument <code>poisson=TRUE</code>, else <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.
</p>
<p>step 1: Initially, one point from dat is selected as a case.
The selection of initial case is determined based on the argument <code>rand.init</code> (with default=<code>TRUE</code>)
where if <code>rand.init=TRUE</code> then the initial case is selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first entry in the data set, <code>dat</code>, is selected as the case.
</p>
<p>step 2: Then it assigns the label case to the remaining points
with infection probabilities <code class="reqn">prob=rho (1-d_{ij}/d_{\max})^{pow}</code>, see the description for the details
of the parameters in the <code>prob</code>.
</p>
<p>step 3: The procedure ends when number of cases <code class="reqn">n_c</code> exceeds <code class="reqn">n_1</code>, and <code class="reqn">n_c-n_1</code> of the cases (other than the
initial contagious case) are randomly selected and relabeled as controls, i.e., 0s,
so that the number of cases is exactly <code class="reqn">n_1</code>.
</p>
<p>In the output cases are labeled as 1 and controls as 0, and initial contagious case is marked with a red cross
in the plot of the pattern.
Note that the infection probabilities of the points is inversely proportional to their distances to the
initial case and increase with increasing <code>rho</code>. 
This function might take a long time for certain choices of the arguments. For example, if <code>pow</code> is taken to be
too large, the infection probabilities would be too small, and case assignment will take a rather long time. 
</p>
<p>See Ceyhan (2014) for more detail where type III non-RL pattern is the 
case 3 of non-RL pattern considered in Section 6 with <code class="reqn">n_1</code> is
fixed as a parameter rather than being generated from a Poisson distribution and <code class="reqn">k_{den}=1</code> and pow
is represented as <code class="reqn">k_{pow}</code>.
</p>
<p>Although the non-RL pattern is described for the case-control setting, it can be adapted for any two-class
setting when it is appropriate to treat one of the classes as cases or one of the classes behave like cases
and other class as controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnonRLIII(dat, prop, rho, pow, rand.init = TRUE, poisson = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnonRLIII_+3A_dat">dat</code></td>
<td>
<p>A set of points the non-RL procedure is applied to obtain cases and controls randomly in the 
type III fashion (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIII_+3A_prop">prop</code></td>
<td>
<p>A real number between 0 and 1 (inclusive) representing the proportion of new cases (on the average)
infected by the initial case, i.e., number of newly infected cases (in addition to the first case) is Poisson
with <code>mean=round(n*prop)</code> where <code class="reqn">n</code> is the number of points in <code>dat</code>, if the argument <code>poisson=TRUE</code>, else it is <code>round(n*prop)</code>.</p>
</td></tr>
<tr><td><code id="rnonRLIII_+3A_rho">rho</code></td>
<td>
<p>A scaling parameter for the probabilities of labeling the points as cases
(see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIII_+3A_pow">pow</code></td>
<td>
<p>A parameter in the power adjusting the distance dependence in the probabilities of labeling the
points as cases (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIII_+3A_rand.init">rand.init</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine the choice of the initial case in the data set, <code>dat</code>.
If <code>rand.init=TRUE</code> then the initial case is selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first entry in the data set, <code>dat</code>, is labeled as the initial case.</p>
</td></tr>
<tr><td><code id="rnonRLIII_+3A_poisson">poisson</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the number of cases <code class="reqn">n_1</code>,
will be random or fixed. If <code>poisson=TRUE</code> then the <code class="reqn">n_1</code> is from a Poisson distribution, 
<code class="reqn">n_1=</code><code>rpois(1,round(n*prop,0))</code> otherwise it is fixed, <code class="reqn">n_1=</code><code>round(n*prop,0)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>="cc"</code> for the case-control patterns for RL or non-RL of the given data points, <code>dat</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>rho and pow, where <code>rho</code> is the scalign parameter and <code>pow</code> is the parameter in the power
adjusting the distance dependence in probabilities of labeling the points as cases.</p>
</td></tr>
<tr><td><code>dat.points</code></td>
<td>
<p>The set of points non-RL procedure is applied to obtain cases and controls randomly in the 
type III fashion</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The labels of the points as 1 for cases and 0 for controls after the type III nonRL procedure is
applied to the data set, <code>dat</code>. Cases are denoted as red dots and controls as black circles in the plot.</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial case in the data set, <code>dat</code>. Marked with a red cross in the plot of the points.</p>
</td></tr>
<tr><td><code>cont.cases</code></td>
<td>
<p>The contagious cases in the data set, <code>dat</code>. Denoted as blue points in the plot of the points.</p>
</td></tr>
<tr><td><code>gen.points</code>, <code>ref.points</code></td>
<td>
<p>Both are <code>NULL</code> for this function, as initial set of points, <code>dat</code>, are provided
for the non-RL procedure.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of cases and controls.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnonRLI">rnonRLI</a></code>, <code><a href="#topic+rnonRLII">rnonRLII</a></code>, <code><a href="#topic+rnonRLIV">rnonRLIV</a></code>, and <code><a href="#topic+rnonRL">rnonRL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-40;  #try also n&lt;-20; n&lt;-100;
prop&lt;- .5; #try also .25, .75
#data generation
dat&lt;-cbind(runif(n,0,1),runif(n,0,1))

rho&lt;-.8
pow&lt;-2

Xdat&lt;-rnonRLIII(dat,prop,rho,pow,poisson=FALSE) #labeled data, try also poisson=TRUE

Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#normal original data
n&lt;-40;  #try also n&lt;-20; n&lt;-100;
dat&lt;-cbind(rnorm(n,0,1),rnorm(n,0,1))

prop&lt;- .5; #try also .25, .75
rho&lt;-.8
pow&lt;-2

Xdat&lt;-rnonRLIII(dat,prop,rho,pow,poisson=FALSE) #labeled data, try also poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rnonRLIV'>Type IV Non-Random Labeling of a Given Set of Points</h2><span id='topic+rnonRLIV'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Given the set of <code class="reqn">n</code> points, <code>dat</code>, in a region, this function assigns <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> of them as cases,
and the rest as controls with first selecting <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> as cases initially and assigning the
label case to the remaining points with infection probabilities equal to the scaled bivariate normal density values
at those points.
The initial and ultimate number of cases will be <code class="reqn">k_0</code> and <code class="reqn">n_1</code> on the average if the argument <code>poisson=TRUE</code>
(i.e., <code class="reqn">k_0=</code><code>rpois(1,round(n*init.prop,0)</code>) and <code class="reqn">n_1=</code><code>rpois(1,round(n*ult.prop,0))</code> ), otherwise
they will be exactly equal to <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code> and <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code>.
More specifically, let <code class="reqn">z_1,\ldots,z_{k_0}</code> be the initial cases and for <code class="reqn">j=1,2,\ldots,k_0</code>
let <code class="reqn">\phi_{G,j}(z_i)</code> be the value of the pdf of the <code class="reqn">BVN(z_j,s_1,s_2,rho)</code>, which is the bivariate normal 
distribution mean=z_j and standard deviations of the first and second components being <code class="reqn">s_1</code>
and <code class="reqn">s_2</code> (denoted as <code>s1</code> and <code>s2</code> as arguments of the function) and 
correlation between them being <code class="reqn">\rho</code> (denoted as <code>rho</code> as an argument of the function)
(i.e., the covariance matrix is <code class="reqn">\Sigma=S</code> where <code class="reqn">S_{11}=s_1^2</code>,
<code class="reqn">S_{22}=s_2^2</code>, <code class="reqn">S_{12}=S_{21}=s_1 s_2 \rho</code>). Add these pdf values as
<code class="reqn">p_j=\sum_{j=1}^{k_0} \phi_{G,j}(z_i)</code> for each <code class="reqn">i=1,2,\ldots,n</code> and find <code class="reqn">p_{\max}=\max p_j</code>. 
Then label the points (other than the initial cases) as cases with infection probabilities <code>prob</code> equal to the value
of the <code class="reqn">p_j/p_{\max}</code> values at these points. 
We stop when we first exceed <code class="reqn">n_1</code> cases. <code class="reqn">\rho</code> has to be in (-1,1) for <code>prob</code> to be
a valid probability and <code class="reqn">s_1</code> and <code class="reqn">s_2</code> must be positive (actually these are required for the BVN density
to be nondegenerately defined).
If <code>rand.init=TRUE</code>, first <code class="reqn">k_0</code> entries are chosen as the initial cases in the data set,
<code>dat</code>, otherwise, <code class="reqn">k_0</code> initial cases are selected randomly among the data points.
</p>
<p>Algorithmically, first all dat points are treated as non-cases (i.e., controls or healthy subjects).
Then the function follows the following steps for labeling of the points: 
</p>
<p>step 0: <code class="reqn">n_1</code> is generated randomly from a Poisson distribution with <code>mean = round(n*ult.prop,0)</code>, so that the 
average number of ultimate cases will be <code>round(n*ult.prop,0)</code> if the argument <code>poisson=TRUE</code>, else <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code>.
And <code class="reqn">k_0</code> is generated randomly from a Poisson distribution with <code>mean = round(n*init.prop,0)</code>, so that the 
average number of initial cases will be round(n*init.prop,0) if the argument <code>poisson=TRUE</code>, else <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code>. 
</p>
<p>step 1: Initially, <code class="reqn">k_0</code> many points from dat are selected as cases.
The selection of initial cases are determined based on the argument <code>rand.init</code> (with default=<code>TRUE</code>)
where if <code>rand.init=TRUE</code> then the initial cases are selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first <code class="reqn">k_0</code> entries in the data set, <code>dat</code>, are selected as the cases.
</p>
<p>step 2: Then it assigns the label case to the remaining points
with infection probabilities <code class="reqn">prob=\sum_{j=1}^{k_0} \phi_{G,j}(z_i)/p_{\max}</code>,
which is the sum of the BVN densities scaled by the maximum of such sums.
See the description for the details of the parameters in the <code>prob</code>.
</p>
<p>step 3: The procedure ends when number of cases <code class="reqn">n_c</code> exceed <code class="reqn">n_1</code>, and <code class="reqn">n_c-n_1</code> of the cases (other than the initial
cases) are randomly selected and relabeled as controls, i.e., 0s, so that the number of cases is
exactly <code class="reqn">n_1</code>.
</p>
<p>In the output cases are labeled as 1 and controls as 0, and initial contagious case is marked with a red cross
in the plot of the pattern.
</p>
<p>See Ceyhan (2014) for more detail where type IV non-RL pattern is the 
case 4 of non-RL pattern considered in Section 6 with <code class="reqn">n_1</code> and <code class="reqn">k_0</code> are
fixed as parameters and <code>rho</code> is represented as <code class="reqn">k_{pow}</code> and <code class="reqn">rho/k_{den}=1</code> in the article.
</p>
<p>Although the non-RL pattern is described for the case-control setting, it can be adapted for any two-class
setting when it is appropriate to treat one of the classes as cases or one of the classes behave like cases
and other class as controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnonRLIV(
  dat,
  init.prop,
  ult.prop,
  s1,
  s2,
  rho,
  rand.init = TRUE,
  poisson = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnonRLIV_+3A_dat">dat</code></td>
<td>
<p>A set of points the non-RL procedure is applied to obtain cases and controls randomly in the 
type IV fashion (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_init.prop">init.prop</code></td>
<td>
<p>A real number between 0 and 1 representing the initial proportion of cases in the data set,
<code>dat</code>. The selection of the initial cases depends on the parameter <code>rand.init</code> and the number of initial cases
depends on the parameter poisson (see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_ult.prop">ult.prop</code></td>
<td>
<p>A real number between 0 and 1 representing the ultimate proportion of cases in the data set,
<code>dat</code> after the non-RL assignment. The number of ultimate cases depends on the parameter poisson
(see the description).</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_s1">s1</code>, <code id="rnonRLIV_+3A_s2">s2</code></td>
<td>
<p>Positive real numbers representing the standard deviations of the first and second components
of the bivariate normal distribution.</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_rho">rho</code></td>
<td>
<p>A real number between -1 and 1 representing the correlation between the first and second components
of the bivariate normal distribution.</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_rand.init">rand.init</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine the choice of the initial case in the data set, <code>dat</code>.
If <code>rand.init=TRUE</code> then the initial case is selected randomly from the data points, and if <code>rand.init=</code>
<code>FALSE</code>, the first <code class="reqn">k_0</code> entries in the data set, <code>dat</code>, is labeled as the initial case.</p>
</td></tr>
<tr><td><code id="rnonRLIV_+3A_poisson">poisson</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the number of initial and ultimate
cases, <code class="reqn">k_0</code> and <code class="reqn">n_1</code>, will be random or fixed. If <code>poisson=TRUE</code> then the <code class="reqn">k_0</code> and <code class="reqn">n_1</code> are from a Poisson distribution,
<code class="reqn">k_0=</code><code>rpois(1,round(n*init.prop,0))</code> and <code class="reqn">n_1=</code><code>rpois(1,round(n*ult.prop,0))</code>
otherwise they are fixed, <code class="reqn">k_0=</code><code>round(n*init.prop,0)</code> and <code class="reqn">n_1=</code><code>round(n*ult.prop,0)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>="cc"</code> for the case-control patterns for RL or non-RL of the given data points, <code>dat</code></p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>initial and ultimate proportion of cases after the non-RL procedure is applied to the data,
<code>s1</code>, <code>s2</code> and <code>rho</code> which are standard deviations and the correlation for the components of
the bivariate normal distribution.</p>
</td></tr>
<tr><td><code>dat.points</code></td>
<td>
<p>The set of points non-RL procedure is applied to obtain cases and controls randomly in the 
type IV fashion</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The labels of the points as 1 for cases and 0 for controls after the type IV nonRL procedure is
applied to the data set, <code>dat</code>. Cases are denoted as red dots and controls as black circles in the plot.</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial cases in the data set, <code>dat</code>. Marked with red crosses in the plot of the points.</p>
</td></tr>
<tr><td><code>gen.points</code>, <code>ref.points</code></td>
<td>
<p>Both are <code>NULL</code> for this function, as initial set of points, <code>dat</code>, are provided
for the non-RL procedure.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of cases and controls.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and the reference points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnonRLI">rnonRLI</a></code>, <code><a href="#topic+rnonRLII">rnonRLII</a></code>, <code><a href="#topic+rnonRLIII">rnonRLIII</a></code>, and <code><a href="#topic+rnonRL">rnonRL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-40;  #try also n&lt;-20; n&lt;-100;
ult&lt;-.5; #try also .25, .75
#data generation
dat&lt;-cbind(runif(n,0,1),runif(n,0,1))

int&lt;-.1
s1&lt;-s2&lt;-.4
rho&lt;- .1

Xdat&lt;-rnonRLIV(dat,int,ult,s1,s2,rho,poisson=FALSE) #labeled data, try also with poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#normal original data
n&lt;-40;  #try also n&lt;-20; n&lt;-100;
dat&lt;-cbind(rnorm(n,0,1),rnorm(n,0,1))
ult&lt;-.5; #try also .25, .75

int&lt;-.1
s1&lt;-s2&lt;-.4
rho&lt;-0.1

Xdat&lt;-rnonRLIV(dat,int,ult,s1,s2,rho,poisson=FALSE) #labeled data, try also with poisson=TRUE
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)
 
</code></pre>

<hr>
<h2 id='rrot.clust'>Generation of Points with Rotational Clusters</h2><span id='topic+rrot.clust'></span>

<h3>Description</h3>

<p>An object of class <code>"Clusters"</code>.
</p>
<p>Generates <code>n</code> 2D points with <code>k</code> (<code class="reqn">k \ge 2</code>) clusters with centers d unit away from origin and angles
between the rays joining successive centers and origin is <code class="reqn">2 \pi/k</code> where about <code class="reqn">n/k</code> points belongs to each cluster.
</p>
<p>If <code>distribution="uniform"</code>, the points are uniformly generated in their square
supports with unit edge lengths and centers at <code class="reqn">(d \cos(j 2 \pi/k),d \cos(j 2\pi/k))</code> for <code class="reqn">j=1,2,\ldots,k</code>.
</p>
<p>If <code>distribution="bvnormal"</code>, the points are generated from the bivariate normal distribution with means equal to the
centers of the above squares (i.e., for each cluster with <code>mean=</code><code class="reqn">(d \cos(j 2 \pi/k),d \cos(j 2\pi/k))</code>
for <code class="reqn">j=1,2,\ldots,k</code> and the covariance matrix <code class="reqn">sd I_2</code>, where <code class="reqn">sd=d\sqrt{2 (1-cos(2 \pi/k))}/3</code>
and <code class="reqn">I_2</code> is the <code class="reqn">2 \times 2</code> identity matrix.
</p>
<p>Notice that the clusters are more separated, i.e., generated data indicates more clear clusters as <code class="reqn">d</code> increases
in either direction with <code class="reqn">d=0</code> indicating one cluster in the data. For a fixed <code class="reqn">d</code>, when <code>distribution="bvnormal"</code>,
the clustering gets stronger if the variance of each component, <code class="reqn">sd^2</code>, gets smaller, and clustering gets weaker
as the variance of each component gets larger where default is <code class="reqn">sd=d\sqrt{2 (1-cos(2 \pi/k))}/3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrot.clust(
  n,
  k,
  d,
  sd = d * sqrt(2 * (1 - cos(2 * pi/k)))/3,
  distribution = c("uniform", "bvnormal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrot.clust_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points to be generated from all the clusters</p>
</td></tr>
<tr><td><code id="rrot.clust_+3A_k">k</code></td>
<td>
<p>A positive integer representing the number of clusters to be generated</p>
</td></tr>
<tr><td><code id="rrot.clust_+3A_d">d</code></td>
<td>
<p>Radial shift indicating the level of clustering in the data. Larger absolute values in either
direction (i.e., positive or negative) would yield stronger clustering.</p>
</td></tr>
<tr><td><code id="rrot.clust_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the components of the bivariate normal distribution with default 
<code class="reqn">sd=d\sqrt{2 (1-cos(2 \pi/k))}/3</code>, used only when <code>distribution="bvnormal"</code>.</p>
</td></tr>
<tr><td><code id="rrot.clust_+3A_distribution">distribution</code></td>
<td>
<p>The argument determining the distribution of each cluster. Takes on values <code>"uniform"</code> and
<code>"bvnormal"</code> whose centers are <code class="reqn">d</code> units apart along the horizontal direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The type of the clustering pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The number of clusters, <code>k</code>, and the radial shift, <code>d</code>, representing the level of clustering
(for both distribution types) and standard deviation, <code>sd</code>, for the bivariate normal distribution only.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points from the <code>k</code> clusters.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the clustering pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of generated points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdiag.clust">rdiag.clust</a></code> and <code><a href="#topic+rhor.clust">rhor.clust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-100;  #try also n&lt;-50; n&lt;-1000;
d&lt;- 1.5 #try also -1, 1, 1.5, 2
k&lt;-3 #try also 5
#data generation
Xdat&lt;-rrot.clust(n,k,d)
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#data generation (bvnormal)
n&lt;-100;  #try also n&lt;-50; n&lt;-1000;
d&lt;- 1.5 #try also -1, 1, 1.5, 2
k&lt;-3 #try also 5
Xdat&lt;-rrot.clust(n,k,d,distr="bvnormal") #also try Xdat&lt;-rrot.clust(n,k,d,sd=.5,distr="bvnormal")
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='rseg'>Generation of Points under Segregation of Two Classes</h2><span id='topic+rseg'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n_i</code> 2D points from class <code class="reqn">j</code> with parameters  <code class="reqn">r_j</code> for <code class="reqn">j=1,2</code>.
The generated points are from two different classes which are segregated from each other.
The pattern generation starts with the initial points <code>X1.init</code> and <code>X2.init</code> (with default=<code>NULL</code> for both).
If both <code>X1.init=NULL</code> and <code>X2.init=NULL</code>, both <code>X1.init</code> and <code>X2.init</code> are generated uniformly in the unit square.
If only <code>X1.init=NULL</code>, <code>X1.init</code> is the sum of a point uniformly generated in the unit square and <code>X2.init</code> and
if only <code>X2.init=NULL</code>, <code>X2.init</code> is the sum of a point uniformly generated in the unit square and <code>X1.init</code>.
After the initial points from each class are available, <code class="reqn">n_j</code> points from class <code class="reqn">j</code> are generated
as <code>Xj[i,]&lt;-Xj[(i-1),]+ru*c(cos(tu),sin(tu))</code>  
where <code>ru&lt;-runif(1,0,rj)</code> and <code>tu&lt;-runif(1,0,2*pi)</code> for <code class="reqn">i=2,\ldots,n_j</code>
with <code>Xj[1,]=Xj.init</code> for <code class="reqn">j=1,2</code>.
That is, at each step the new point in class <code class="reqn">j</code> is generated within a circle with radius equal to <code class="reqn">r_j</code>
(uniform in the polar coordinates).
Note that, the level of segregation is stronger if the initial points are further apart, and the level
of segregation increases as the radius values gets smaller.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rseg(n1, n2, r1, r2, X1.init = NULL, X2.init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rseg_+3A_n1">n1</code>, <code id="rseg_+3A_n2">n2</code></td>
<td>
<p>Positive integers representing the number of class 1 and class 2 (i.e., <code class="reqn">X_1</code> and <code class="reqn">X_2</code>) points
to be generated under the segregation pattern.</p>
</td></tr>
<tr><td><code id="rseg_+3A_r1">r1</code>, <code id="rseg_+3A_r2">r2</code></td>
<td>
<p>Positive real numbers representing the radius of attraction within class, i.e., radius of the
circle center and generated points are from the same class.</p>
</td></tr>
<tr><td><code id="rseg_+3A_x1.init">X1.init</code>, <code id="rseg_+3A_x2.init">X2.init</code></td>
<td>
<p>2D points representing the initial points for the segregated classes, default=<code>NULL</code>
for both. If both <code>X1.init=NULL</code> and <code>X2.init=NULL</code>, both <code>X1.init</code> and <code>X2.init</code> are generated uniformly in the
unit square.
If only <code>X1.init=NULL</code>, <code>X1.init</code> is the sum of a point uniformly generated in the unit square and <code>X2.init</code> and
if only <code>X2.init=NULL</code>, <code>X2.init</code> is the sum of a point uniformly generated in the unit square and <code>X1.init</code>.
The initial points are
marked with crosses in the plot of the points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>"2c"</code> for the 2-class pattern of segregation of the two classes</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Radial (i.e., circular) within class radii of segregation, <code>r1</code> and <code>r2</code>,
controlling the level of segregation</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The class labels of the generated points, it is 1 class 1 or <code class="reqn">X_1</code> points and 
2 for class 2 or <code class="reqn">X_2</code> points</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial points for class 1 and class 2, one initial point for each class.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points (i.e., class 1 and class 2 points) segregated 
from each other.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points, it is <code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The <code>vector</code> of two numbers, which are the number of generated class 1 and class 2 points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated and
the initial points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rassoc">rassoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-20;  #try also n1&lt;-10; n1&lt;-100;
n2&lt;-20; #try also n1&lt;-40; n2&lt;-50

r1&lt;-.3; r2&lt;-.2

#data generation
Xdat&lt;-rseg(n1,n2,r1,r2) #labeled data
Xdat

table(Xdat$lab)

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#with one initial point
X1init&lt;-c(3,2)

Xdat&lt;-rseg(n1,n2,r1,r2,X1.init=X1init)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#with two initial points
X1init&lt;-c(3,2)
X2init&lt;-c(4,2)

Xdat&lt;-rseg(n1,n2,r1,r2,X1init,X2init)
Xdat
summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat) 

</code></pre>

<hr>
<h2 id='rself.ref'>Generation of Points from Self Correspondence Pattern</h2><span id='topic+rself.ref'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code class="reqn">n_1</code> 2D points from class 1 and  <code class="reqn">n_2</code> (denoted as <code>n2</code> as an argument)
2D points from class 2 in such a way that
self-reflexive pairs are more frequent than expected under CSR independence.
</p>
<p>If <code>distribution="uniform"</code>, the points from class 1, say <code class="reqn">X_i</code> are generated as follows: 
<code class="reqn">X_i \stackrel{iid}{\sim} Uniform(S_1)</code> for <code class="reqn">S_1=(c1r[1],c1r[2])^2</code> for <code class="reqn">i=1,2,\ldots,n_{1h}</code>
where <code class="reqn">n_{1h}=\lfloor n_1/2 \rfloor</code>,
and for <code class="reqn">k=n_{1h},+1,\ldots,n_1</code>, <code class="reqn">X_k=X_{k-n_{1h}}+r (\cos(T_k), \sin(T_k))</code> where <code class="reqn">r \sim Uniform(0,r_0)</code>
and <code class="reqn">T_k</code> are iid <code class="reqn">\sim Uniform(0,2 \pi)</code>.
Similarly, the points from class 2, say <code class="reqn">Y_j</code> are generated as follows: 
<code class="reqn">Y_j \stackrel{iid}{\sim} Uniform(S_2)</code> for <code class="reqn">S_2=(c2r[1],c2r[2])^2</code> for <code class="reqn">j=1,2,\ldots,n_{2h}</code> where <code class="reqn">n_{2h}=\lfloor n_2/2\rfloor)</code>,
and for <code class="reqn">l=n_{2h},+1,\ldots,n_2</code>, <code class="reqn">Y_l=Y_{l-n_{2h}}+r (\cos(T_l), \sin(T_l))</code> where <code class="reqn">r \sim Uniform(0,r_0)</code> and
<code class="reqn">T_l \stackrel{iid}{\sim} Uniform(0,2 \pi)</code>.
This version is the case IV in the article (Ceyhan (2018)).
</p>
<p>If <code>distribution="bvnormal"</code>, the points from class 1, 
say <code class="reqn">X_i</code> are generated as follows: 
<code class="reqn">X_i \stackrel{iid}{\sim} BVN(CM(S_1),I_{2x})</code> 
where <code class="reqn">CM(S_1)</code> is the center of mass of <code class="reqn">S_1</code> 
and <code class="reqn">I_{2x}</code> is a <code class="reqn">2 \times 2</code> matrix with diagonals
equal to <code class="reqn">s_1^2</code> with <code class="reqn">s_1=(c1r[2]-c1r[1])/3</code> 
and off-diagonals are 0 for <code class="reqn">i=1,2,\ldots,n_{1h}</code> 
where <code class="reqn">n_{1h}=\lfloor{n_1/2\rfloor}</code>,
and for <code class="reqn">k=n_{1h}+1,\ldots,n_1</code>, <code class="reqn">X_k = Z_k+r (\cos(T_k), \sin(T_k))</code> 
where <code class="reqn">Z_k \sim BVN(X_{k-n_{1h}}, I_2(r_0))</code>
with <code class="reqn">I_2(r_0)</code> being the <code class="reqn">2 \times 2</code> matrix 
with diagonals <code class="reqn">r_0/3</code> and 0 off-diagonals, <code class="reqn">r \sim Uniform(0,r_0)</code> and
<code class="reqn">T_k</code> are iid <code class="reqn">\sim Uniform(0,2 \pi)</code>.
Similarly, the points from class 2, say <code class="reqn">Y_j</code> are generated as follows: 
<code class="reqn">Y_j \stackrel{iid}{\sim} BVN(CM(S_2),I_{2y})</code> 
where <code class="reqn">CM(S_1)</code> is the center of mass of <code class="reqn">S_1</code> and 
<code class="reqn">I_{2y}</code> is a <code class="reqn">2 \times 2</code> matrix with diagonals
equal to <code class="reqn">s_2^2</code> with <code class="reqn">s_2=(c2r[2]-c2r[1])/3</code> and 
off-diagonals are 0 for <code class="reqn">j=1,2,\ldots,n_{2h}</code> 
where <code class="reqn">n_{2h}=\lfloor n_2/2\rfloor)</code>,
and for <code class="reqn">l=n_{2h},+1,\ldots,n_2</code>, <code class="reqn">Y_l = W_k+r (\cos(T_l), \sin(T_l))</code> 
where <code class="reqn">W_l \sim BVN(Y_{l-n_{2h}}, I_2(r_0))</code>
with <code class="reqn">I_2(r_0)</code> being the <code class="reqn">2 \times 2</code> matrix 
with diagonals <code class="reqn">r_0/3</code> and 0 off-diagonals, <code class="reqn">r \sim Uniform(0,r_0)</code> and
<code class="reqn">T_l \stackrel{iid}{\sim} Uniform(0,2 \pi)</code>.
</p>
<p>Notice that the classes will be segregated 
if the supports <code class="reqn">S_1</code> and <code class="reqn">S_2</code> are separated, with more separation
implying stronger segregation. Furthermore, <code class="reqn">r_0</code> 
(denoted as <code>r0</code> as an argument) determines 
the level of self-reflexivity or self correspondence,
i.e., smaller <code class="reqn">r_0</code> implies a higher level of self correspondence 
and vice versa for higher <code class="reqn">r_0</code> .
</p>
<p>See also (Ceyhan (2018))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rself.ref(n1, n2, c1r, c2r, r0, distribution = c("uniform", "bvnormal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rself.ref_+3A_n1">n1</code>, <code id="rself.ref_+3A_n2">n2</code></td>
<td>
<p>Positive integers representing the numbers of points to be generated from the two classes</p>
</td></tr>
<tr><td><code id="rself.ref_+3A_c1r">c1r</code>, <code id="rself.ref_+3A_c2r">c2r</code></td>
<td>
<p>Ranges of the squares which constitute the supports of the two classes</p>
</td></tr>
<tr><td><code id="rself.ref_+3A_r0">r0</code></td>
<td>
<p>The radius of attraction which determines the level of self-reflexivity (or self correspondence) in 
both the uniform and bvnormal distributions for the two classes</p>
</td></tr>
<tr><td><code id="rself.ref_+3A_distribution">distribution</code></td>
<td>
<p>The argument determining the distribution of each class. Takes on values <code>"uniform"</code> and
<code>"bvnormal"</code> (see the description for the details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>"2c"</code> for the 2-class pattern of self-correspondence of the two classes</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the spatial pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The radius of attraction <code class="reqn">r_0</code> which determines the level of self-correspondence.</p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The class labels of the generated points, it is 1 class 1 or X1 points and 
2 for class 2 or <code class="reqn">X_2</code> points</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial points for class 1 and class 2, one initial point for each class, marked
with a cross in the plot.</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points from the self-correspondence pattern.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points, it is <code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the species correspondence pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of generated points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Zself.ref">Zself.ref</a></code> and <code><a href="#topic+Xsq.spec.cor">Xsq.spec.cor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1&lt;-50;  #try also n1&lt;-50; n1&lt;-1000;
n2&lt;-50;  #try also n2&lt;-50; n2&lt;-1000;

c1r&lt;-c(0,1) #try also c(0,5/6), C(0,3/4), c(0,2/3)
c2r&lt;-c(0,1) #try also c(1/6,1), c(1/4,1), c(1/3,1)
r0&lt;-1/9 #try also 1/7, 1/8

#data generation
Xdat&lt;-rself.ref(n1,n2,c1r,c2r,r0)
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

#data generation (bvnormal)
Xdat&lt;-rself.ref(n1,n2,c1r,c2r,r0,distr="bvnormal")
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='runif.circ'>Generation of Uniform Points in a Circle</h2><span id='topic+runif.circ'></span>

<h3>Description</h3>

<p>An object of class <code>"SpatPatterns"</code>.
</p>
<p>Generates <code>n</code> 2D points uniformly in the circle with center=<code>cent</code> and radius=<code>rad</code> using the rejection 
sampling approach (i.e., the function generates points in the smallest square containing the circle, keeping
only the points inside the circle until <code class="reqn">n</code> points are generated).
The defaults for <code>cent=c(0,0)</code> and <code>rad=1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif.circ(n, cent = c(0, 0), rad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif.circ_+3A_n">n</code></td>
<td>
<p>A positive integer representing the number of points to be generated uniformly in the circle</p>
</td></tr>
<tr><td><code id="runif.circ_+3A_cent">cent</code></td>
<td>
<p>A 2D point representing the center of the circle, with default=<code>c(0,0)</code></p>
</td></tr>
<tr><td><code id="runif.circ_+3A_rad">rad</code></td>
<td>
<p>A positive real number representing the radius of the circle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>pat.type</code></td>
<td>
<p><code>"1c"</code> for the 1-class pattern of the uniform data in the circle</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of the point pattern</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>center of the circle, <code>cent</code>, and the radius of the circle, <code>rad</code></p>
</td></tr>
<tr><td><code>lab</code></td>
<td>
<p>The class labels of the generated points, <code>NULL</code> for this function, since points belong to the same 
class</p>
</td></tr>
<tr><td><code>init.cases</code></td>
<td>
<p>The initial points, <code>NULL</code> for this function</p>
</td></tr>
<tr><td><code>gen.points</code></td>
<td>
<p>The output set of generated points uniform in the circle.</p>
</td></tr>
<tr><td><code>ref.points</code></td>
<td>
<p>The input set of reference points, it is <code>NULL</code> for this function.</p>
</td></tr>
<tr><td><code>desc.pat</code></td>
<td>
<p>Description of the point pattern</p>
</td></tr>
<tr><td><code>mtitle</code></td>
<td>
<p>The <code>"main"</code> title for the plot of the point pattern</p>
</td></tr>
<tr><td><code>num.points</code></td>
<td>
<p>The number of generated points.</p>
</td></tr>
<tr><td><code>xlimit</code>, <code>ylimit</code></td>
<td>
<p>The possible ranges of the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the generated points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1);  #try also 10, 100, or 1000;
r&lt;-.1; #try also r&lt;-.3 or .5
cent&lt;-c(1,2)

#data generation
Xdat&lt;-runif.circ(n,cent,r) #generated data
Xdat

summary(Xdat)
plot(Xdat,asp=1)
plot(Xdat)

</code></pre>

<hr>
<h2 id='seg.ind'>Dixon's Segregation Indices for NNCTs</h2><span id='topic+seg.ind'></span>

<h3>Description</h3>

<p>Returns Dixon's segregation indices in matrix form based on 
entries of the NNCT, <code>ct</code>. 
Segregation index for cell <code class="reqn">i,j</code> is defined as 
<code class="reqn">log(N_{ii}(n-n_i)/((n_i-N_{ii})(n_i-1))</code> if <code class="reqn">i=j</code>
and
as <code class="reqn">log(N_{ij}(n-n_j-1)/((n_i-N_{ij})(n_j))</code> 
if <code class="reqn">i \ne j</code>. 
See (Dixon (2002); Ceyhan (2014)).
</p>
<p>The argument <code>inf.corr</code> is a logical argument 
(default=<code>FALSE</code>) to avoid <code class="reqn">\pm \infty</code> 
for the segregation indices. 
If <code>TRUE</code> indices are modified so that 
they are finite and if <code>FALSE</code> the above definition is used. 
(See Ceyhan (2014) for more detail).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg.ind(ct, inf.corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seg.ind_+3A_ct">ct</code></td>
<td>
<p>A contingency table, in particular an NNCT</p>
</td></tr>
<tr><td><code id="seg.ind_+3A_inf.corr">inf.corr</code></td>
<td>
<p>A logical argument (default=<code>FALSE</code>). 
If <code>TRUE</code>, indices are modified so that 
they are finite and 
if <code>FALSE</code> the above definition in the description is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>matrix</code> of segregation indices 
which is of the same dimension as <code>ct</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pseg.coeff">Pseg.coeff</a></code>, <code><a href="#topic+seg.coeff">seg.coeff</a></code>,
<code><a href="#topic+Zseg.ind">Zseg.ind</a></code>, and <code><a href="#topic+Zseg.ind.ct">Zseg.ind.ct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct
seg.ind(ct)
seg.ind(ct,inf.corr = TRUE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

seg.ind(ct)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

seg.ind(ct)
seg.ind(ct,inf.corr = TRUE)

ct&lt;-matrix(c(0,10,5,5),ncol=2)
seg.ind(ct)

seg.ind(ct,inf.corr = TRUE)

</code></pre>

<hr>
<h2 id='sharedNNmc'>The Shared NN Vectors for Multiple Classes</h2><span id='topic+sharedNNmc'></span>

<h3>Description</h3>

<p>Returns a <code>matrix</code> with <code class="reqn">k</code> rows 
where each row is the vector of number of points with shared NNs,
<code class="reqn">Q_i=(Q_{i0},Q_{i1},\ldots)</code> 
where <code class="reqn">Q_{ij}</code> is the number of class <code class="reqn">i</code> points 
that are NN to class <code class="reqn">j</code> points.
The function also returns the indices of columns with nonzero sums as a vector.
</p>
<p>The output matrix of shared NNs is used in testing symmetry 
in shared NN structure (i.e., <code class="reqn">Q</code>-symmetry
or Pielou's second type of symmetry), 
e.g., in functions <code><a href="#topic+Qsym.ct">Qsym.ct</a></code> and <code><a href="#topic+Qsym.test">Qsym.test</a></code>.
</p>
<p>See also
(Pielou (1961); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharedNNmc(x, lab, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharedNNmc_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="sharedNNmc_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="sharedNNmc_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance
matrix (IPD matrix), otherwise, 
<code>x</code> is taken as the data set with rows representing the data points.</p>
</td></tr>
<tr><td><code id="sharedNNmc_+3A_...">...</code></td>
<td>
<p>are for further arguments, 
such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>Qval</code> returns the <code class="reqn">Q</code> value
</p>
<p>The function <code>Qvec</code> returns a <code>list</code> with two elements
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>the <code class="reqn">Q</code> value, the number of shared NNs</p>
</td></tr>
<tr><td><code>qvec</code></td>
<td>
<p>the <code>vector</code> of <code class="reqn">Q_j</code> values</p>
</td></tr> 
</table>
<p>The function <code>sharedNN</code> returns a <code>matrix</code> with 2 rows, 
where first row is the <code class="reqn">j</code> values and second row is
the corresponding vector of <code class="reqn">Q_j</code> values
</p>
<p>The function <code>Rval</code> returns the <code class="reqn">R</code> value, the number of reflexive NNs.
</p>
<p>Returns a <code>list</code> with two elements
</p>
<table>
<tr><td><code>Nv</code></td>
<td>
<p>A <code class="reqn">k</code>-row matrix of shared NNs by class 
where each row of the matrix is the vector of number of
points with shared NNs <code class="reqn">Q_i=(Q_{i0},Q_{i1},\ldots)</code> 
where <code class="reqn">Q_{ij}</code> is the number of class <code class="reqn">i</code> points that are NN
to <code class="reqn">j</code> points.</p>
</td></tr>
<tr><td><code>col.ind</code></td>
<td>
<p>The <code>vector</code> of indices of columns with nonzero sums</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qval">Qval</a></code>, <code><a href="#topic+Qvec">Qvec</a></code> and <code><a href="#topic+sharedNN">sharedNN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

sharedNNmc(ipd,cls)
sharedNNmc(Y,cls,is.ipd = FALSE)
sharedNNmc(Y,cls,is.ipd = FALSE,method="max")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
sharedNNmc(ipd,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)

sharedNNmc(ipd,cls) 

</code></pre>

<hr>
<h2 id='SkewTk'>Skewness of Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+SkewTk'></span>

<h3>Description</h3>

<p>This function estimates the skewness of Cuzick and Edwards <code class="reqn">T_k</code> test statistic under the RL hypothesis.
Skewness of a random variable <code class="reqn">T</code> is defined as <code class="reqn">E(T-\mu)^3/(E(T-\mu)^2)^{1.5}</code> where <code class="reqn">\mu=E T</code>.
</p>
<p>Skewness is used for Tango's correction to Cuzick and Edwards <code>k</code>NN test statistic, <code class="reqn">T_k</code>.
Tango's correction is a chi-square approximation, and its degrees of freedom is estimated using the skewness
estimate (see page 121 of Tango (2007)).
</p>
<p>The argument, <code class="reqn">n_1</code>, is the number of cases (denoted as <code>n1</code> as an argument) 
and <code>k</code> is the number of NNs considered in <code class="reqn">T_k</code> test statistic.
The argument of the function is the <code class="reqn">A_{ij}</code> matrix, <code>a</code>, which is the output of the function <code><a href="#topic+aij.mat">aij.mat</a></code>.
However, inside the function we symmetrize the matrix <code>a</code> as <code>b &lt;- (a+a^t)/2</code>, to facilitate the formulation.
</p>
<p>The number of cases are denoted as <code class="reqn">n_1</code> and number of controls as <code class="reqn">n_0</code> in this function
to match the case-control class labeling,
which is just the reverse of the labeling in Cuzick and Edwards (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SkewTk(n1, k, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SkewTk_+3A_n1">n1</code></td>
<td>
<p>Number of cases</p>
</td></tr>
<tr><td><code id="SkewTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>)</p>
</td></tr>
<tr><td><code id="SkewTk_+3A_a">a</code></td>
<td>
<p><code class="reqn">A_{ij}</code> matrix which is the output of the function <code><a href="#topic+aij.mat">aij.mat</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The skewness of Cuzick and Edwards <code class="reqn">T_k</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.<br /><br /> Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+EV.Tk">EV.Tk</a></code>, and <code><a href="#topic+varTk">varTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)
n1&lt;-sum(cls==1)

k&lt;-sample(1:5,1) # try also 3, 5, sample(1:5,1)
k
a&lt;-aij.mat(Y,k)

SkewTk(n1,k,a)

</code></pre>

<hr>
<h2 id='summary.Clusters'>Return a summary of a <code>Clusters</code> object</h2><span id='topic+summary.Clusters'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>, the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern, reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Clusters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Clusters_+3A_object">object</code></td>
<td>
<p>Object of class <code>Clusters</code>.</p>
</td></tr>
<tr><td><code id="summary.Clusters_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the object of class '<code>Clusters</code>', the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern, reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF
</code></pre>

<hr>
<h2 id='summary.SpatPatterns'>Return a summary of a <code>SpatPatterns</code> object</h2><span id='topic+summary.SpatPatterns'></span>

<h3>Description</h3>

<p>Returns the below information about the <code>object</code>:
</p>
<p><code>call</code> of the function defining the <code>object</code>, the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern, reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatPatterns'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SpatPatterns_+3A_object">object</code></td>
<td>
<p>Object of class <code>SpatPatterns</code>.</p>
</td></tr>
<tr><td><code id="summary.SpatPatterns_+3A_...">...</code></td>
<td>
<p>Additional parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>call</code> of the object of class '<code>SpatPatterns</code>', the <code>type</code> of the pattern, <code>parameters</code> of the pattern,
study window, some sample points from the generated pattern, reference points (if any for the bivariate pattern),
and number of points for each class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#TBF
</code></pre>

<hr>
<h2 id='swamptrees'>Tree Species in a Swamp Forest</h2><span id='topic+swamptrees'></span>

<h3>Description</h3>

<p>Locations and species classification of trees
in a plot in the Savannah River, SC, USA.
Locations are given in meters, rounded to the nearest 0.1 decimal.
The data come from a one-hectare (200-by-50m) plot in the Savannah River Site.
The 734 mapped stems included 156 Carolina ashes (Fraxinus caroliniana),
215 water tupelos (Nyssa aquatica), 205 swamp tupelos (Nyssa sylvatica),
98 bald cypresses (Taxodium distichum)
and 60 stems from 8 additional three species (labeled as Others (OT)).
The plots were set up by Bill Good and their spatial patterns described
in (Good and Whipple (1982)),
the plots have been maintained and resampled by Rebecca Sharitz and
her colleagues of the Savannah River Ecology Laboratory.
The data and some of its description are borrowed
from the swamp data entry in the <code>dixon</code>
package in the CRAN repository.
</p>
<p>See also (Good and Whipple (1982); Jones et al. (1994); Dixon (2002)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swamptrees)
</code></pre>


<h3>Format</h3>

<p>A data frame with 734 rows and 4 variables
</p>


<h3>Details</h3>

<p>Text describing the variable (i.e., column) names in the data set.
</p>

<ul>
<li><p> x,y:  x and y (i.e., Cartesian) coordinates of the trees
</p>
</li>
<li><p> live: a categorical variable that indicates the tree is alive (labeled as 1) or dead (labeled as 0)
</p>
</li>
<li><p> sp: species label of the trees:
</p>

<dl>
<dt>FX: </dt><dd><p>Carolina ash (Fraxinus caroliniana)</p>
</dd>
<dt>NS: </dt><dd><p>Swamp tupelo (Nyssa sylvatica)</p>
</dd>
<dt>NX: </dt><dd><p>Water tupelo (Nyssa aquatica)</p>
</dd>
<dt>TD: </dt><dd><p>Bald cypress (Taxodium distichum)</p>
</dd>
<dt>OT: </dt><dd><p>Other species</p>
</dd>
</dl>

</li></ul>



<h3>Source</h3>

<p><a href="https://pdixon.stat.iastate.edu/datasets/goodplot1.txt">Prof. Philip Dixon's website</a>
</p>


<h3>References</h3>

<p>Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.<br /><br /> Good BJ, Whipple SA (1982).
&ldquo;Tree spatial patterns: South Carolina bottomland and swamp forests.&rdquo;
<em>Bulletin of the Torrey Botanical Club</em>, <b>109(4)</b>, 529-536.<br /><br /> Jones RH, Sharitz RR, James SM, Dixon PM (1994).
&ldquo;Tree population dynamics in seven South Carolina mixed-species forests.&rdquo;
<em>Bulletin of the Torrey Botanical Club</em>, <b>121(4)</b>, 360-368.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swamptrees)
plot(swamptrees$x,swamptrees$y, col=as.numeric(swamptrees$sp),pch=19,
xlab='',ylab='',main='Swamp Trees')

</code></pre>

<hr>
<h2 id='Tcomb'>Cuzick &amp; Edwards Tcomb Test Statistic</h2><span id='topic+Tcomb'></span>

<h3>Description</h3>

<p>This function computes the value of Cuzick &amp; Edwards <code class="reqn">T_{comb}</code> test statistic in disease clustering, where <code class="reqn">T_{comb}</code>
is a linear combination of some <code class="reqn">T_k</code> tests.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. 
</p>
<p>The argument <code>klist</code> is the <code>vector</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used
in obtaining the <code class="reqn">T_{comb}</code>.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>The logical argument <code>asy.cov</code> (default=<code>FALSE</code>) is for using the asymptotic covariance or the exact (i.e., finite
sample) covariance for the vector of <code class="reqn">T_k</code> values used in <code>Tcomb</code> in the standardization of <code class="reqn">T_{comb}</code>.
If <code>asy.cov=TRUE</code>, the asymptotic covariance is used, otherwise the exact covariance is used. 
</p>
<p>See page 87 of (Cuzick and Edwards (1990)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tcomb(
  dat,
  cc.lab,
  klist,
  case.lab = NULL,
  nonzero.mat = TRUE,
  asy.cov = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tcomb_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_klist">klist</code></td>
<td>
<p><code>list</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used in obtaining the <code class="reqn">T_{comb}</code>.</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code>.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_asy.cov">asy.cov</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether asymptotic or exact (i.e., finite
sample) covariances between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values are to be used to obtain the entries of the covariance matrix.
If <code>TRUE</code> the asymptotic covariance values are used, otherwise exact covariance values are used.</p>
</td></tr>
<tr><td><code id="Tcomb_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the value of the <code class="reqn">T_{comb}</code> test statistic
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+EV.Tcomb">EV.Tcomb</a></code>, and <code><a href="#topic+ZTcomb">ZTcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1) #try also n&lt;-50, 100
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
n1&lt;-sum(cls==1)

kl&lt;-sample(1:5,3) #try also sample(1:5,2)
kl
Tcomb(Y,cls,kl)
Tcomb(Y,cls,kl,method="max")
Tcomb(Y,cls+1,kl,case.lab=2)
Tcomb(Y,cls,kl,nonzero.mat = FALSE)
Tcomb(Y,cls,kl,asy.cov = TRUE)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Tcomb(Y,fcls,kl,case.lab="a")

</code></pre>

<hr>
<h2 id='tct'><code class="reqn">T</code> Contingency Table (TCT)</h2><span id='topic+tct'></span>

<h3>Description</h3>

<p>Returns the <code>T</code> contingency table (TCT), 
which is a matrix of same dimension as, <code>ct</code>, 
whose entries are the values of 
the Types I-IV cell-specific test statistics, 
<code class="reqn">T^I_{ij}-T^{IV}_{ij}</code>. 
The row and column names are inherited from <code>ct</code>. 
The type argument specifies the type
of the cell-specific test among the types I-IV tests. 
</p>
<p>See also (Ceyhan (2017)) 
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tct(ct, type = "III")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="tct_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, default=<code>"III"</code>. 
Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of the values of Type I-IV cell-specific tests
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellsTij">cellsTij</a></code> and <code><a href="#topic+nnct">nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

type.lab&lt;-c("I","II","III","IV")
for (i in 1:4)
{ print(paste("T_ij values for cell specific tests for type",type.lab[i]))
  print(tct(ct,i))
}

tct(ct,"II")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)
tct(ct,2)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
tct(ct,2)

ct&lt;-matrix(c(0,10,5,5),ncol=2)
tct(ct,2)

</code></pre>

<hr>
<h2 id='tocher.cor'>Tocher's randomized correction to the exact <code class="reqn">p</code>-value</h2><span id='topic+tocher.cor'></span>

<h3>Description</h3>

<p>Tocher's modification is used for the Fisher's exact test on the contingency tables making it less conservative,
by including the probability for the current table based on a randomized test
(Tocher (1950)). It is applied When table-inclusive version of the <code class="reqn">p</code>-value,
<code class="reqn">p^&gt;_{inc}</code>, is larger, but table-exclusive version, <code class="reqn">p^&gt;_{exc}</code>, is less than the level of the test <code class="reqn">\alpha</code>,
a random number, <code class="reqn">U</code>, is generated from uniform distribution in <code class="reqn">(0,1)</code>, and if <code class="reqn">U \leq (\alpha-p^&gt;_{exc})/p_t</code>,
<code class="reqn">p^&gt;_{exc}</code> is used, otherwise <code class="reqn">p_{inc}</code> is used as the <code class="reqn">p</code>-value.
</p>
<p>Table-inclusive and exclusive <code class="reqn">p</code>-values are defined as follows. 
Let the probability of the contingency table itself
be <code class="reqn">p_t=f(n_{11}|n_1,n_2,c_1;\theta)</code> where <code class="reqn">\theta</code> is the odds ratio
under the null hypothesis (e.g. <code class="reqn">\theta=1</code> under independence) and 
<code class="reqn">f</code> is the probability mass function of the hypergeometric distribution.
In testing the one-sided alternative <code class="reqn">H_o:\,\theta=1</code> versus <code class="reqn">H_a:\,\theta&gt;1</code>,
let <code class="reqn">p=\sum_S f(t|n_1,n_2,c_1;\theta=1)</code>, then
with <code class="reqn">S=\{t:\,t \geq n_{11}\}</code>, we get the <em>table-inclusive version</em> which is denoted as <code class="reqn">p^&gt;_{inc}</code>
and with <code class="reqn">S=\{t:\,t&gt; n_{11}\}</code>, we get the <em>table-exclusive version</em>, denoted as <code class="reqn">p^&gt;_{exc}</code>.
</p>
<p>See (Ceyhan (2010)) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tocher.cor(ptable, pval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tocher.cor_+3A_ptable">ptable</code></td>
<td>
<p>Probability of the contingency table under the null hypothesis using the hypergeometric 
distribution for Fisher's exact test.</p>
</td></tr>
<tr><td><code id="tocher.cor_+3A_pval">pval</code></td>
<td>
<p>Table inclusive <code class="reqn">p</code>-value for Fisher's exact test on the contingency table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code class="reqn">p</code>-value based on the Tocher's randomized correction.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;Exact Inference for Testing Spatial Patterns by Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of Probability and Statistical Science</em>, <b>8(1)</b>, 45-68.<br /><br /> Tocher KD (1950).
&ldquo;Extension of the Neyman-Pearson theory of tests to discontinuous variates.&rdquo;
<em>Biometrika</em>, <b>37</b>, 130-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prob.nnct">prob.nnct</a></code>, <code><a href="#topic+exact.pval1s">exact.pval1s</a></code>, and <code><a href="#topic+exact.pval2s">exact.pval2s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ptab&lt;-.03
pval&lt;-.06
tocher.cor(ptab,pval)

</code></pre>

<hr>
<h2 id='Tval'><code class="reqn">T</code> value in NN structure</h2><span id='topic+Tval'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">T</code> value, 
which is the number of triplets <code class="reqn">(z_i, z_j, z_k)</code> with 
&quot;<code class="reqn">NN(z_i) = NN(z_j) = z_k</code> and <code class="reqn">NN(z_k) = z_j</code>&quot; 
where <code class="reqn">NN(\cdot)</code> is the nearest neighbor function.
Note that in the NN digraph, 
<code class="reqn">T+R</code> is the sum of the indegrees of the points in the reflexive pairs.
</p>
<p>This quantity (together with <code class="reqn">Q</code> and <code class="reqn">R</code>) is used in 
computing the variances and covariances of the entries of the
reflexivity contingency table. 
See (Ceyhan and Bahadir (2017)) 
for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tval(W, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tval_+3A_w">W</code></td>
<td>
<p>The incidence matrix, <code class="reqn">W</code>, for the NN digraph</p>
</td></tr>
<tr><td><code id="Tval_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs 
(i.e., twice the number of reflexive NN pairs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code class="reqn">T</code> value. 
See the description above for the details of this quantity.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Qval">Qval</a></code>, <code><a href="#topic+Qvec">Qvec</a></code>, <code><a href="#topic+sharedNN">sharedNN</a></code>,
and <code><a href="#topic+Rval">Rval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#3D data points
n&lt;-10
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd)
R&lt;-Rval(W)
Tval(W,R)

#1D data points
X&lt;-as.matrix(runif(15)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
W&lt;-Wmat(ipd)
R&lt;-Rval(W)
Tval(W,R)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(30)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
W&lt;-Wmat(ipd,ties=TRUE)
R&lt;-Rval(W)
Tval(W,R)

</code></pre>

<hr>
<h2 id='var.nnct'>Variances of Cell Counts in an NNCT</h2><span id='topic+var.nnct'></span>

<h3>Description</h3>

<p>Returns the variances of cell counts <code class="reqn">N_{ij}</code> 
for <code class="reqn">i,j=1,\ldots,k</code> in the NNCT, <code>ct</code> in matrix form which
is of the same dimension as <code>ct</code>. 
These variances are valid under RL or 
conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also 
(Dixon (1994, 2002); Ceyhan (2010, 2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.nnct(ct, Q, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.nnct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="var.nnct_+3A_q">Q</code></td>
<td>
<p>The number of shared NNs</p>
</td></tr>
<tr><td><code id="var.nnct_+3A_r">R</code></td>
<td>
<p>The number of reflexive NNs (i.e., 
twice the number of reflexive NN pairs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the variances of the cell counts 
in the NNCT with class sizes given as the row sums of <code>ct</code>. 
The row and column names are inherited from <code>ct</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;On the use of nearest neighbor contingency tables for testing spatial segregation.&rdquo;
<em>Environmental and Ecological Statistics</em>, <b>17(3)</b>, 247-282.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Dixon PM (2002).
&ldquo;Nearest-neighbor contingency table analysis of spatial segregation for several species.&rdquo;
<em>Ecoscience</em>, <b>9(2)</b>, 142-151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.tct">var.tct</a></code>, <code><a href="#topic+var.nnsym">var.nnsym</a></code>,
and <code><a href="#topic+cov.nnct">cov.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)
ct

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
var.nnct(ct,Qv,Rv)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)
var.nnct(ct,Qv,Rv)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
var.nnct(ct,Qv,Rv)

</code></pre>

<hr>
<h2 id='var.nnsym'>Variances of Differences of Off-Diagonal Entries in an NNCT</h2><span id='topic+var.nnsym'></span>

<h3>Description</h3>

<p>Returns the variances of differences of off-diagonal cell counts <code class="reqn">N_{ij}-N_{ji}</code> for <code class="reqn">i,j=1,\ldots,k</code> and <code class="reqn">i \ne j</code>
in the NNCT, <code>ct</code> in a vector of length <code class="reqn">k(k-1)/2</code>, the order of <code class="reqn">i,j</code> for <code class="reqn">N_{ij}-N_{ji}</code>
is as in the output of <code><a href="#topic+ind.nnsym">ind.nnsym</a>(k)</code>.
These variances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Dixon (1994); Ceyhan (2014)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.nnsym(covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.nnsym_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length <code class="reqn">k(k-1)/2</code>, whose entries are the variances of differences of off-diagonal 
cell counts <code class="reqn">N_{ij}-N_{ji}</code> for <code class="reqn">i,j=1,\ldots,k</code> and <code class="reqn">i \ne j</code> in the NNCT.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.nnct">var.nnct</a></code>, <code><a href="#topic+var.tct">var.tct</a></code> and <code><a href="#topic+cov.nnct">cov.nnct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv) #default is byrow

var.nnsym(covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

var.nnsym(covN)

</code></pre>

<hr>
<h2 id='var.seg.coeff'>Variances of Segregation Coefficients in a Multi-class Case</h2><span id='topic+var.seg.coeff'></span>

<h3>Description</h3>

<p>Returns the variances of segregation coefficients in a multi-class case based on the NNCT, <code>ct</code> 
in a <code>vector</code> of length <code class="reqn">k(k+1)/2</code>, the order of the variances are as in the order of rows output of 
<code><a href="#topic+ind.seg.coeff">ind.seg.coeff</a>(k)</code>. These variances are valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Ceyhan (2014)).
</p>
<p>The argument <code>covN</code> is the covariance matrix of <code class="reqn">N_{ij}</code> (concatenated rowwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.seg.coeff(ct, covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.seg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="var.seg.coeff_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of length <code class="reqn">k(k+1)/2</code>, whose entries are the variances of segregation coefficients for the
entry <code class="reqn">i,j</code> in the NNCT, where the order of the variances are as in the order of rows output of 
<code><a href="#topic+ind.seg.coeff">ind.seg.coeff</a>(k)</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seg.coeff">seg.coeff</a></code>, <code><a href="#topic+cov.seg.coeff">cov.seg.coeff</a></code>, <code><a href="#topic+var.nnsym">var.nnsym</a></code>
and <code><a href="#topic+var.nnct">var.nnct</a></code> and
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

var.seg.coeff(ct,covN)
varPseg.coeff(ct,covN)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

var.seg.coeff(ct,covN)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ipd&lt;-ipd.mat(Y)
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

var.seg.coeff(ct,covN)

</code></pre>

<hr>
<h2 id='var.tct'>Variances of Entries in a TCT</h2><span id='topic+var.tct'></span>

<h3>Description</h3>

<p>Returns the variances of <code class="reqn">T_{ij}</code> values 
for <code class="reqn">i,j=1,\ldots,k</code> in the TCT in matrix form which
is of the same dimension as TCT for types I-IV tests. 
The argument <code>covN</code> must be the covariance 
between <code class="reqn">N_{ij}</code> values which are obtained 
from the NNCT by row-wise
vectorization. type determines the type of the test
for which variances are to be computed, with default=<code>"III"</code>.
These variances are valid under RL 
or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also 
(Ceyhan (2010, 2017)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.tct(ct, covN, type = "III")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.tct_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="var.tct_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized cell counts of NNCT, <code>ct</code>.</p>
</td></tr>
<tr><td><code id="var.tct_+3A_type">type</code></td>
<td>
<p>The type of the cell-specific test, default=<code>"III"</code>. Takes on values <code>"I"</code>-<code>"IV"</code> (or 
equivalently <code>1-4</code>, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of same dimension as, <code>ct</code>, 
whose entries are the variances of
the entries in the TCT for the corresponding type of cell-specific test.
The row and column names are inherited from <code>ct</code>.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2010).
&ldquo;New Tests of Spatial Segregation Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>37(1)</b>, 147-165.<br /><br /> Ceyhan E (2017).
&ldquo;Cell-Specific and Post-hoc Spatial Clustering Tests Based on Nearest Neighbor Contingency Tables.&rdquo;
<em>Journal of the Korean Statistical Society</em>, <b>46(2)</b>, 219-245.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.nnct">var.nnct</a></code>, <code><a href="#topic+var.tctI">var.tctI</a></code>, 
<code><a href="#topic+var.tctIII">var.tctIII</a></code>, <code><a href="#topic+var.tctIV">var.tctIV</a></code> ,
and <code><a href="#topic+cov.tct">cov.tct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

var.tct(ct,covN,"I")
var.tct(ct,covN,2)
var.tct(ct,covN,"III")
var.tct(ct,covN,"IV")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)

covN&lt;-cov.nnct(ct,varN,Qv,Rv)

var.tct(ct,covN,"I")
var.tct(ct,covN,2)

</code></pre>

<hr>
<h2 id='varPseg.coeff'>Variance of Pielou's Segregation Coefficient for 2 Classes</h2><span id='topic+varPseg.coeff'></span>

<h3>Description</h3>

<p>Returns the variance of Pielou's coefficient of segregation for the two-class case
(i.e., based on <code class="reqn">2 \times 2</code> NNCTs)in a <code class="reqn">2 \times 2</code> NNCT. 
This variance is valid under RL or conditional on <code class="reqn">Q</code> and <code class="reqn">R</code> under CSR.
</p>
<p>See also (Ceyhan (2014)) for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varPseg.coeff(ct, covN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varPseg.coeff_+3A_ct">ct</code></td>
<td>
<p>A nearest neighbor contingency table</p>
</td></tr>
<tr><td><code id="varPseg.coeff_+3A_covn">covN</code></td>
<td>
<p>The <code class="reqn">k^2 \times k^2</code> covariance matrix of row-wise vectorized entries of NNCT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance of Pielou's coefficient of segregation for the two-class case.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Pseg.coeff">Pseg.coeff</a></code>, <code><a href="#topic+seg.coeff">seg.coeff</a></code> and <code><a href="#topic+var.seg.coeff">var.seg.coeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))
ct&lt;-nnct(ipd,cls)

W&lt;-Wmat(ipd)
Qv&lt;-Qvec(W)$q
Rv&lt;-Rval(W)
varN&lt;-var.nnct(ct,Qv,Rv)
covN&lt;-cov.nnct(ct,varN,Qv,Rv)

varPseg.coeff(ct,covN)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ct&lt;-nnct(ipd,fcls)

varPseg.coeff(ct,covN)

#############
ct&lt;-matrix(sample(1:25,9),ncol=3)
#varPseg.coeff(ct,covN)

</code></pre>

<hr>
<h2 id='varTkinv.sim'>Simulated Variance of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> Test statistic</h2><span id='topic+varTkinv.sim'></span>

<h3>Description</h3>

<p>This function estimates the variance of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic by Monte Carlo simulations
under the RL hypothesis.
</p>
<p>The exact variance of <code class="reqn">T_k^{inv}</code> is currently not available and (Cuzick and Edwards (1990)) say
that &quot;The permutational variance of <code class="reqn">T_k^{inv}</code> becomes unwieldy for <code class="reqn">k &gt; 1</code> and is more easily simulated&quot;, hence
we estimate the variance of <code class="reqn">T_k^{inv}</code> by RL of cases and controls to the given point data.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. The argument <code>Nsim</code> represents the number of resamplings (without replacement) in the
RL scheme, with default being <code>1000</code>. 
</p>
<p>See (Cuzick and Edwards (1990)).
</p>
<p>See the function <code><a href="#topic+ceTkinv">ceTkinv</a></code> for the details of the <code class="reqn">T_k^{inv}</code> test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varTkinv.sim(dat, k, cc.lab, Nsim = 1000, case.lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varTkinv.sim_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point,</p>
</td></tr>
<tr><td><code id="varTkinv.sim_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of the closest controls to subject <code class="reqn">i</code>.</p>
</td></tr>
<tr><td><code id="varTkinv.sim_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="varTkinv.sim_+3A_nsim">Nsim</code></td>
<td>
<p>The number of simulations, i.e., the number of resamplings under the RL scheme to estimate the 
variance of <code class="reqn">T_k^{inv}</code></p>
</td></tr>
<tr><td><code id="varTkinv.sim_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The simulation estimated variance of Cuzick and Edwards <code class="reqn">T_k^{inv}</code> test statistic for disease clustering
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTkinv">ceTkinv</a></code> and <code><a href="#topic+EV.Tkinv">EV.Tkinv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)
n1&lt;-sum(cls==1)
k&lt;-2

Nmc&lt;-1000
varTkinv.sim(Y,k,cls,Nsim=Nmc)

set.seed(1)
varTrun.sim(Y,cls,Nsim=Nmc)
set.seed(1)
varTkinv.sim(Y,k=1,cls,Nsim=Nmc)

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
varTkinv.sim(Y,k,fcls,Nsim=Nmc,case.lab="a")

</code></pre>

<hr>
<h2 id='Wmat'>The incidence matrix <code>W</code> for the NN digraph</h2><span id='topic+Wmat'></span>

<h3>Description</h3>

<p>Returns the <code class="reqn">W=(w_ij)</code> matrix which is used to compute 
<code class="reqn">Q</code>, <code class="reqn">R</code> and <code class="reqn">T</code> values in the NN structure.
<code class="reqn">w_{ij}=I(</code> point <code class="reqn">j</code> is a NN of point <code class="reqn">i))</code> 
i.e., <code class="reqn">w_{ij}=1</code> if point <code class="reqn">j</code> is a NN of
point <code class="reqn">i</code> and 0 otherwise.
</p>
<p>The argument <code>ties</code> is a logical argument (default=<code>FALSE</code>) 
to take ties into account or not. If <code>TRUE</code> the function
takes ties into account by making <code class="reqn">w_{ij}=1/m</code> 
if point <code class="reqn">j</code> is a NN of point <code class="reqn">i</code>
and there are <code class="reqn">m</code> tied NNs and 0 otherwise. 
If <code>FALSE</code>, <code class="reqn">w_{ij}=1</code> if point <code class="reqn">j</code> is 
a NN of point <code class="reqn">i</code> and 0 otherwise.
The matrix <code class="reqn">W</code> is equivalent to 
<code class="reqn">A=(a_{ij})</code> matrix with <code class="reqn">k=1</code>, 
i.e., <code>Wmat(X)=aij.mat(X,k=1)</code>.
</p>
<p>The argument <code>is.ipd</code> is a logical argument (default=<code>TRUE</code>) 
to determine the structure of the argument <code>x</code>.
If <code>TRUE</code>, <code>x</code> is taken to be 
the inter-point distance (IPD) matrix, 
and if <code>FALSE</code>, <code>x</code> is taken to be the data set
with rows representing the data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wmat(x, ties = FALSE, is.ipd = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wmat_+3A_x">x</code></td>
<td>
<p>The IPD matrix (if <code>is.ipd=TRUE</code>) 
or a data set of points in matrix or data frame form where points
correspond to the rows (if <code>is.ipd = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Wmat_+3A_ties">ties</code></td>
<td>
<p>A logical parameter (default=<code>FALSE</code>) 
to take ties into account in computing the <code class="reqn">W</code> matrix,
so, if it is <code>TRUE</code>, <code class="reqn">w_{ij}=1/m</code> if point <code class="reqn">j</code> is 
a NN of point <code class="reqn">i</code> and there are <code class="reqn">m</code> tied NNs and 0 otherwise
and if <code>FALSE</code>, <code class="reqn">w_{ij}=1</code> 
if point <code class="reqn">j</code> is a NN of point <code class="reqn">i</code> and 0 otherwise.</p>
</td></tr>
<tr><td><code id="Wmat_+3A_is.ipd">is.ipd</code></td>
<td>
<p>A logical parameter (default=<code>TRUE</code>). 
If <code>TRUE</code>, <code>x</code> is taken as the inter-point distance matrix, 
otherwise, <code>x</code> is taken as the data set 
with rows representing the data points.</p>
</td></tr>
<tr><td><code id="Wmat_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, 
passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incidence matrix <code class="reqn">W=(w_ij)</code> 
where <code class="reqn">w_{ij}=I(</code> point <code class="reqn">j</code> is a NN of point <code class="reqn">i))</code>,
i.e., <code class="reqn">w_{ij}=1</code> if point <code class="reqn">j</code> is a NN of 
point <code class="reqn">i</code> and 0 otherwise.
</p>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aij.mat">aij.mat</a></code>, <code><a href="#topic+aij.nonzero">aij.nonzero</a></code>, 
and <code><a href="#topic+aij.theta">aij.theta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-3
X&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(X)
Wmat(ipd)
Wmat(X,is.ipd = FALSE)

n&lt;-5
Y&lt;-matrix(runif(3*n),ncol=3)
ipd&lt;-ipd.mat(Y)
Wmat(ipd)
Wmat(Y,is.ipd = FALSE)
Wmat(Y,is.ipd = FALSE,method="max")

Wmat(Y,is.ipd = FALSE)
aij.mat(Y,k=1)

#1D data points
X&lt;-as.matrix(runif(5)) # need to be entered as a matrix with one column
#(i.e., a column vector), hence X&lt;-runif(5) would not work
ipd&lt;-ipd.mat(X)
Wmat(ipd)
Wmat(X,is.ipd = FALSE)

#with ties=TRUE in the data
Y&lt;-matrix(round(runif(15)*10),ncol=3)
ipd&lt;-ipd.mat(Y)
Wmat(ipd,ties=TRUE)
Wmat(Y,ties=TRUE,is.ipd = FALSE)

</code></pre>

<hr>
<h2 id='Xsq.ceTk'>Chi-square Approximation to Cuzick and Edwards <code class="reqn">T_k</code> Test statistic</h2><span id='topic+Xsq.ceTk'></span>

<h3>Description</h3>

<p>An object of class <code>"Chisqtest"</code> performing  a chi-square approximation for Cuzick and Edwards <code class="reqn">T_k</code> test statistic
based on the number of cases within <code>k</code>NNs of the cases in the data.
</p>
<p>This approximation is suggested by Tango (2007) since <code class="reqn">T_k</code> statistic had high 
skewness rendering the normal approximation less efficient. The chi-square approximation is as follows:
<code class="reqn">\frac{T_k- ET_k}{\sqrt{Var T_k}} \approx \frac{\chi^2_\nu-\nu}{\sqrt{2 \nu}}</code> where <code class="reqn">\chi^2_\nu</code> is a chi-square
random variable with <code class="reqn">\nu</code> df, and <code class="reqn">\nu=8/skewnees(T_k)</code> (see <code><a href="#topic+SkewTk">SkewTk</a></code> for the skewness).
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>FALSE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>).
</p>
<p>The logical argument <code>asy.var</code> (default=<code>FALSE</code>) is for using the asymptotic variance or the exact (i.e., finite
sample) variance for the variance of <code class="reqn">T_k</code> in its standardization.
If <code>asy.var=TRUE</code>, the asymptotic variance is used for <code class="reqn">Var[T_k]</code> (see <code>asyvarTk</code>), otherwise the exact
variance (see <code>varTk</code>) is used.
</p>
<p>See also (Tango (2007)) and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.ceTk(
  dat,
  cc.lab,
  k,
  case.lab = NULL,
  nonzero.mat = TRUE,
  asy.var = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xsq.ceTk_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>).</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computations.
If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_asy.var">asy.var</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the asymptotic variance or 
the exact (i.e., finite sample) variance for the variance of <code class="reqn">T_k</code> in its standardization. 
If <code>TRUE</code>, the asymptotic variance is used for <code class="reqn">Var[T_k]</code>, otherwise the exact variance is used.</p>
</td></tr>
<tr><td><code id="Xsq.ceTk_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for Tango's chi-square approximation to Cuzick &amp; Edwards' <code class="reqn">T_k</code>
test for disease clustering.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">8/</code>skewness where skewness is the output of
<code><a href="#topic+SkewTk">SkewTk</a></code> function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates, i.e., the observed <code class="reqn">T_k</code> value.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, they are almost identical for this function.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for Cuzick &amp; Edwards' <code class="reqn">T_k</code>, which is <code class="reqn">ET_k</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Tango T (2007).
&ldquo;A class of multiplicity adjusted tests for spatial clustering based on case-control point data.&rdquo;
<em>Biometrics</em>, <b>63</b>, 119-127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+ZceTk">ZceTk</a></code> and <code><a href="#topic+SkewTk">SkewTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n&lt;-20
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)

k&lt;-sample(1:5,1) # try also 1, 3, 5,
k

Xsq.ceTk(Y,cls,k)
Xsq.ceTk(Y,cls,k,nonzero.mat=FALSE)
Xsq.ceTk(Y,cls+1,k,case.lab = 2)
Xsq.ceTk(Y,cls,k,method="max")

Xsq.ceTk(Y,cls,k,asy.var=TRUE)

</code></pre>

<hr>
<h2 id='Xsq.nnsym'>Overall NN Symmetry Test with Chi-square Approximation</h2><span id='topic+Xsq.nnsym'></span>

<h3>Description</h3>

<p>An object of class <code>"Chisqtest"</code> performing the hypothesis test of equality of the expected
values of the off-diagonal cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k \ge 2</code> classes.
That is, the test performs Dixon's or Pielou's (first type of) overall NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data or for sparsely sample data, respectively.
(See Pielou (1961); Dixon (1994); Ceyhan (2014) for more detail).
</p>
<p>The <code>type="dixon"</code> refers to Dixon's overall NN symmetry test and 
<code>type="pielou"</code> refers to Pielou's first type of overall NN symmetry test.
The symmetry test is based on the chi-squared approximation of the corresponding quadratic form
and <code>type="dixon"</code> yields an extension of Dixon's NN symmetry test, which is extended by
Ceyhan (2014) and <code>type="pielou"</code> yields
Pielou's overall NN symmetry test.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value and <code>df</code> which is <code class="reqn">k(k-1)/2</code>, description of the 
alternative with the corresponding null values (i.e., expected values) of differences of the off-diagonal entries,(which is
0 for this function) and also the sample estimates (i.e., observed values) of absolute differences of the off-diagonal entries of 
NNCT (in the upper-triangular form).
The functions also provide names of the test statistics, the description of the test and the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT (i.e., symmetry in the 
mixed NN structure) for <code class="reqn">k \ge 2</code>.
In the output, if if <code>type="pielou"</code>, 
the test statistic, <code class="reqn">p</code>-value and the df are valid only for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Dixon (1994); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xsq.nnsym(dat, lab, type = "dixon", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Xsq.nnsym_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Xsq.nnsym_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="Xsq.nnsym_+3A_type">type</code></td>
<td>
<p>The type of the overall NN symmetry test with default=<code>"dixon"</code>.
Takes on values <code>"dixon"</code> and <code>"pielou"</code> for Dixon's and Pielou's (first type) overall NN symmetry test</p>
</td></tr>
<tr><td><code id="Xsq.nnsym_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The chi-squared test statistic for Dixon's or Pielou's (first type of)
overall NN symmetry test</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the chi-squared test, which is <code class="reqn">k(k-1)/2</code> for this function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates, i.e., absolute differences of the off-diagonal entries of 
NNCT (in the upper-triangular form).</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null values for the differences between the expected values of the off-diagonal 
entries, which is 0 for this function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, or name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>, <code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code> and <code><a href="#topic+Znnsym2cl">Znnsym2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Xsq.nnsym(Y,cls)
Xsq.nnsym(Y,cls,method="max")
Xsq.nnsym(Y,cls,type="pielou")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))

Xsq.nnsym(Y,fcls)
Xsq.nnsym(Y,fcls,type="pielou")

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Xsq.nnsym(Y,cls)
Xsq.nnsym(Y,cls,type="pielou")

</code></pre>

<hr>
<h2 id='ZceTk'><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_k</code> statistic</h2><span id='topic+ZceTk'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> performing a <code class="reqn">z</code>-test for Cuzick and Edwards <code class="reqn">T_k</code> test statistic based on the 
number of cases within <code>k</code>NNs of the cases in the data.
</p>
<p>For disease clustering, Cuzick and Edwards (1990) suggested a <code>k</code>-NN test <code class="reqn">T_k</code> based on number of cases
among <code>k</code> NNs of the case points.
Under RL of <code class="reqn">n_1</code> cases and <code class="reqn">n_0</code> controls to the given locations in the study region,
<code class="reqn">T_k</code> approximately has <code class="reqn">N(E[T_k],Var[T_k]/n_1)</code> distribution for large <code class="reqn">n_1</code>.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. 
Also, <code class="reqn">T_1</code> is identical to the count for cell <code class="reqn">(1,1)</code> in the nearest neighbor contingency table (NNCT)
(See the function <code><a href="#topic+nnct">nnct</a></code> for more detail on NNCTs).
Thus, the <code class="reqn">z</code>-test for <code class="reqn">T_k</code> is same as the cell-specific <code class="reqn">z</code>-test for cell <code class="reqn">(1,1)</code> in the NNCT (see
<code><a href="#topic+cell.spec">cell.spec</a></code>).
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>The logical argument <code>asy.var</code> (default=<code>FALSE</code>) is for using the asymptotic variance or the exact (i.e., finite
sample) variance for the variance of <code class="reqn">T_k</code> in its standardization.
If <code>asy.var=TRUE</code>, the asymptotic variance is used for <code class="reqn">Var[T_k]</code> (see <code>asyvarTk</code>), otherwise the exact
variance (see <code>varTk</code>) is used.
</p>
<p>See also (Ceyhan (2014); Cuzick and Edwards (1990))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZceTk(
  dat,
  cc.lab,
  k,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  case.lab = NULL,
  nonzero.mat = TRUE,
  asy.var = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZceTk_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of NNs (of subject <code class="reqn">i</code>).</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for Cuzick and Edwards <code class="reqn">T_k</code> statistic</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="ZceTk_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of <code class="reqn">N_s</code> and <code class="reqn">N_t</code> (argument is passed on to
<code>asyvarTk</code>). If <code>TRUE</code> the nonzero location matrix is used, otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_asy.var">asy.var</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the asymptotic variance or 
the exact (i.e., finite sample) variance for the variance of <code class="reqn">T_k</code> in its standardization. 
If <code>TRUE</code>, the asymptotic variance is used for <code class="reqn">Var[T_k]</code>, otherwise the exact variance is used.</p>
</td></tr>
<tr><td><code id="ZceTk_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the Cuzick and Edwards <code class="reqn">T_k</code> test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the Cuzick and Edwards <code class="reqn">T_k</code> value
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the Cuzick and Edwards <code class="reqn">T_k</code> value.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the Cuzick and Edwards <code class="reqn">T_k</code> value
which is <code class="reqn">k n_1 (n_1-1)/(n-1)</code> for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTk">ceTk</a></code>, <code><a href="#topic+cell.spec">cell.spec</a></code>, and <code><a href="#topic+Xsq.ceTk">Xsq.ceTk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))
k&lt;-1 #try also 2,3, sample(1:5,1)

ZceTk(Y,cls,k)
ZceTk(Y,cls,k,nonzero.mat=FALSE)
ZceTk(Y,cls,k,method="max")

ZceTk(Y,cls+1,k,case.lab = 2,alt="l")
ZceTk(Y,cls,k,asy.var=TRUE,alt="g")

</code></pre>

<hr>
<h2 id='Znnsym'>NN Symmetry Test with Normal Approximation</h2><span id='topic+Znnsym'></span>

<h3>Description</h3>

<p>An object of class <code>"cellhtest"</code> performing hypothesis test of equality of the expected values of the
off-diagonal cell counts (i.e., entries) for each pair <code class="reqn">i,j</code> of classes under RL or CSR in the NNCT
for <code class="reqn">k \ge 2</code> classes.
That is, the test performs Dixon's or Pielou's (first type of) NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data or for sparsely sample data, respectively.
(See Pielou (1961); Dixon (1994); Ceyhan (2014) for more detail).
</p>
<p>The <code>type="dixon"</code> refers to Dixon's NN symmetry test and 
<code>type="pielou"</code> refers to Pielou's first type of NN symmetry test.
The symmetry test is based on the normal approximation of the difference of the off-diagonal entries
in the NNCT and are due to Pielou (1961); Dixon (1994).
</p>
<p>The function yields a contingency table of the test statistics, <code class="reqn">p</code>-values for the corresponding 
alternative, expected values (i.e., null value(s)), lower and upper confidence levels and sample estimate
for the <code class="reqn">N_{ij}-N_{ji}</code> values for <code class="reqn">i \ne j</code> (all in the upper-triangular form except for the null value, which is 0
for all pairs) and also names of the test statistics, estimates, null values, the description of the test, and the data
set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{ij})=E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT (i.e., symmetry in the 
mixed NN structure) for <code class="reqn">k \ge 2</code>.
In the output, if if <code>type="pielou"</code>, 
the test statistic, <code class="reqn">p</code>-value and the lower and upper confidence limits are valid only 
for (properly) sparsely sampled data.
</p>
<p>See also
(Pielou (1961); Dixon (1994); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym(
  dat,
  lab,
  type = "dixon",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Znnsym_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Znnsym_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="Znnsym_+3A_type">type</code></td>
<td>
<p>The type of the NN symmetry test with default=<code>"dixon"</code>.
Takes on values <code>"dixon"</code> and <code>"pielou"</code> for Dixon's and Pielou's (first type) NN symmetry test</p>
</td></tr>
<tr><td><code id="Znnsym_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="Znnsym_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
<tr><td><code id="Znnsym_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">Z</code> test statistics for the NN symmetry test (in the upper-triangular form)</p>
</td></tr>
<tr><td><code>stat.names</code></td>
<td>
<p>Name of the test statistics</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code>matrix</code> of <code class="reqn">p</code>-values for the hypothesis test for the corresponding alternative
(in the upper-triangular form)</p>
</td></tr>
<tr><td><code>LCL</code>, <code>UCL</code></td>
<td>
<p>Matrix of Lower and Upper Confidence Levels (in the upper-triangular form) for the <code class="reqn">N_{ij}-N_{ji}</code>
values for <code class="reqn">i \ne j</code> at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>conf.int</code></td>
<td>
<p>The confidence interval for the estimates, it is <code>NULL</code> here, since we provide the <code>UCL</code> and <code>LCL</code>
in <code>matrix</code> form.</p>
</td></tr>
<tr><td><code>cnf.lvl</code></td>
<td>
<p>Level of the upper and lower confidence limits (i.e., conf.level) of the differences of the
off-diagonal entries.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimates of the parameters, i.e., matrix of the difference of the off-diagonal entries
(in the upper-triangular form) of the <code class="reqn">k \times k</code> NNCT, <code class="reqn">N_{ij}-N_{ji}</code> for <code class="reqn">i \ne j</code>.</p>
</td></tr>
<tr><td><code>est.name</code>, <code>est.name2</code></td>
<td>
<p>Names of the estimates, former is a shorter description of the estimates
than the latter.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{ij})-E(N_{ji})</code> for <code class="reqn">i \ne j</code> in the <code class="reqn">k \times k</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>null.name</code></td>
<td>
<p>Name of the null values</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, or name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym.ss.ct">Znnsym.ss.ct</a></code>, <code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>, <code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>,
<code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code> and <code><a href="#topic+Znnsym2cl">Znnsym2cl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Znnsym(Y,cls)
Znnsym(Y,cls,method="max")
Znnsym(Y,cls,type="pielou")
Znnsym(Y,cls,type="pielou",method="max")

Znnsym(Y,cls,alt="g")
Znnsym(Y,cls,type="pielou",alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
Znnsym(Y,fcls)

#############
n&lt;-40
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:4,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Znnsym(Y,cls)
Znnsym(Y,cls,type="pielou")

</code></pre>

<hr>
<h2 id='Znnsym2cl'>NN Symmetry Test with Normal Approximation for Two Classes</h2><span id='topic+Znnsym2cl'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> performing hypothesis test of equality of the expected value of the off-diagonal 
cell counts (i.e., entries) under RL or CSR in the NNCT for <code class="reqn">k=2</code> classes.
That is, the test performs Dixon's or Pielou's (first type of) NN symmetry test which is appropriate 
(i.e., have the appropriate asymptotic sampling distribution)
for completely mapped data and for sparsely sample data, respectively.
(See Ceyhan (2014) for more detail).
</p>
<p>The symmetry test is based on the normal approximation of the difference of the off-diagonal entries
in the NNCT and are due to Pielou (1961); Dixon (1994).
</p>
<p>The <code>type="dixon"</code> refers to Dixon's NN symmetry test and 
<code>type="pielou"</code> refers to Pielou's first type of NN symmetry test.
</p>
<p>The function yields the test statistic, <code class="reqn">p</code>-value for the
corresponding alternative, the confidence interval, estimate and null value for the parameter of interest
(which is the difference of the off-diagonal entries in the NNCT), and method and name of the data set used.
</p>
<p>The null hypothesis is that all <code class="reqn">E(N_{12})=E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT (i.e., symmetry in the 
mixed NN structure).
</p>
<p>See also
(Pielou (1961); Dixon (1994); Ceyhan (2014))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Znnsym2cl(
  dat,
  lab,
  type = "dixon",
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Znnsym2cl_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="Znnsym2cl_+3A_lab">lab</code></td>
<td>
<p>The <code>vector</code> of class labels (numerical or categorical)</p>
</td></tr>
<tr><td><code id="Znnsym2cl_+3A_type">type</code></td>
<td>
<p>The type of the NN symmetry test with default=<code>"dixon"</code>.
Takes on values <code>"dixon"</code> and <code>"pielou"</code> for Dixon's and Pielou's (first type) NN symmetry test</p>
</td></tr>
<tr><td><code id="Znnsym2cl_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="Znnsym2cl_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for Pielou's first type of NN symmetry test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the difference of the off-diagonal entries, <code class="reqn">N_{12}-N_{21}</code> in the <code class="reqn">2 \times 2</code> NNCT
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate, i.e., the difference of the off-diagonal entries of the <code class="reqn">2 \times 2</code> NNCT, <code class="reqn">N_{12}-N_{21}</code>.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the expected difference between the off-diagonal entries, 
<code class="reqn">E(N_{12})-E(N_{21})</code> in the <code class="reqn">2 \times 2</code> NNCT, which is 0 for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code>, or name of the contingency table, <code>ct</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Testing Spatial Symmetry Using Contingency Tables Based on Nearest Neighbor Relations.&rdquo;
<em>The Scientific World Journal</em>, <b>Volume 2014</b>, Article ID 698296.<br /><br /> Dixon PM (1994).
&ldquo;Testing spatial segregation using a nearest-neighbor contingency table.&rdquo;
<em>Ecology</em>, <b>75(7)</b>, 1940-1948.<br /><br /> Pielou EC (1961).
&ldquo;Segregation and symmetry in two-species populations as studied by nearest-neighbor relationships.&rdquo;
<em>Journal of Ecology</em>, <b>49(2)</b>, 255-269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Znnsym2cl.ss.ct">Znnsym2cl.ss.ct</a></code>, <code><a href="#topic+Znnsym2cl.ss">Znnsym2cl.ss</a></code>, <code><a href="#topic+Znnsym2cl.dx.ct">Znnsym2cl.dx.ct</a></code>,
<code><a href="#topic+Znnsym2cl.dx">Znnsym2cl.dx</a></code>, <code><a href="#topic+Znnsym.ss.ct">Znnsym.ss.ct</a></code>, <code><a href="#topic+Znnsym.ss">Znnsym.ss</a></code>, <code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>,
<code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code>, <code><a href="#topic+Znnsym.dx.ct">Znnsym.dx.ct</a></code>, <code><a href="#topic+Znnsym.dx">Znnsym.dx</a></code> and <code><a href="#topic+Znnsym">Znnsym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(1:2,n,replace = TRUE)  #or try cls&lt;-rep(1:2,c(10,10))

Znnsym2cl(Y,cls)
Znnsym2cl(Y,cls,type="pielou")

Znnsym2cl(Y,cls,alt="g")
Znnsym2cl(Y,cls,type="pielou",alt="g")

</code></pre>

<hr>
<h2 id='ZTcomb'><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_{comb}</code> statistic</h2><span id='topic+ZTcomb'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> performing a <code class="reqn">z</code>-test for Cuzick and Edwards <code class="reqn">T_{comb}</code> test statisticin disease clustering,
where <code class="reqn">T_{comb}</code> is a linear combination of some <code class="reqn">T_k</code> tests. 
</p>
<p>For disease clustering, Cuzick and Edwards (1990) developed a <code class="reqn">k</code>-NN test <code class="reqn">T_k</code> based on 
number of cases among <code class="reqn">k</code> NNs of the case points, and also proposed a test combining various <code class="reqn">T_k</code> tests,
denoted as <code class="reqn">T_{comb}</code>.
</p>
<p>See page 87 of (Cuzick and Edwards (1990)) for more details.
</p>
<p>Under RL of <code class="reqn">n_1</code> cases and <code class="reqn">n_0</code> controls to the given locations in the study region,
<code class="reqn">T_{comb}</code> approximately has <code class="reqn">N(E[T_{comb}],Var[T_{comb}])</code> distribution for large <code class="reqn">n_1</code>.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. 
</p>
<p>The argument <code>klist</code> is the <code>vector</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used
in obtaining the <code class="reqn">T_{comb}</code>.
</p>
<p>The logical argument <code>nonzero.mat</code> (default=<code>TRUE</code>) is for using the <code class="reqn">A</code> matrix if <code>FALSE</code> or just the matrix of nonzero
locations in the <code class="reqn">A</code> matrix (if <code>TRUE</code>) in the computations.
</p>
<p>The logical argument <code>asy.cov</code> (default=<code>FALSE</code>) is for using the asymptotic covariance or the exact (i.e., finite
sample) covariance for the vector of <code class="reqn">T_k</code> values used in <code>Tcomb</code> in the standardization of <code class="reqn">T_{comb}</code>.
If <code>asy.cov=TRUE</code>, the asymptotic covariance is used, otherwise the exact covariance is used.
</p>
<p>See also (Ceyhan (2014); Cuzick and Edwards (1990))
and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZTcomb(
  dat,
  cc.lab,
  klist,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  case.lab = NULL,
  nonzero.mat = TRUE,
  asy.cov = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZTcomb_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_klist">klist</code></td>
<td>
<p><code>list</code> of integers specifying the indices of the <code class="reqn">T_k</code> values used in obtaining the <code class="reqn">T_{comb}</code>.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for Cuzick and Edwards <code class="reqn">T_{comb}</code> statistic</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_nonzero.mat">nonzero.mat</code></td>
<td>
<p>A logical argument (default is <code>TRUE</code>) to determine whether the <code class="reqn">A</code> matrix or the matrix of
nonzero locations of the <code class="reqn">A</code> matrix will be used in the computation of covariance of <code class="reqn">T_k</code> values forming the
<code>T_{comb}</code> statistic (argument is passed on to <code>covTcomb</code>). If <code>TRUE</code> the nonzero location matrix is used,
otherwise the <code class="reqn">A</code> matrix itself is used.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_asy.cov">asy.cov</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether asymptotic or exact (i.e., finite
sample) covariances between <code class="reqn">T_k</code> and <code class="reqn">T_l</code> values are to be used to obtain the entries of the covariance matrix.</p>
</td></tr>
<tr><td><code id="ZTcomb_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the Cuzick and Edwards <code class="reqn">T_{comb}</code> test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the Cuzick and Edwards <code class="reqn">T_{comb}</code> value
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the Cuzick and Edwards <code class="reqn">T_{comb}</code> value.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the Cuzick and Edwards <code class="reqn">T_{comb}</code> value
which is <code class="reqn">E[T_{comb}]</code> for this function, which is the output of <code>EV.Tcomb</code> function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Ceyhan E (2014).
&ldquo;Segregation indices for disease clustering.&rdquo;
<em>Statistics in Medicine</em>, <b>33(10)</b>, 1662-1684.<br /><br /> Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Tcomb">Tcomb</a></code>, <code><a href="#topic+EV.Tcomb">EV.Tcomb</a></code>, and <code><a href="#topic+covTcomb">covTcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))

kl&lt;-sample(1:5,3) #try also sample(1:5,2)
ZTcomb(Y,cls,kl)
ZTcomb(Y,cls,kl,method="max")

ZTcomb(Y,cls,kl,nonzero.mat=FALSE)
ZTcomb(Y,cls+1,kl,case.lab = 2,alt="l")
ZTcomb(Y,cls,kl,conf=.9,alt="g")
ZTcomb(Y,cls,kl,asy=TRUE,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ZTcomb(Y,fcls,kl,case.lab="a")

</code></pre>

<hr>
<h2 id='ZTrun'><code class="reqn">Z</code>-test for Cuzick and Edwards <code class="reqn">T_{run}</code> statistic</h2><span id='topic+ZTrun'></span>

<h3>Description</h3>

<p>An object of class <code>"htest"</code> performing a <code class="reqn">z</code>-test for Cuzick and Edwards <code class="reqn">T_{run}</code> test statistic 
which is based on the number of consecutive cases from the cases in the data under RL or CSR independence.
</p>
<p>Under RL of <code class="reqn">n_1</code> cases and <code class="reqn">n_0</code> controls to the given locations in the study region,
<code class="reqn">T_{run}</code> approximately has <code class="reqn">N(E[T_{run}],Var[T_{run}])</code> distribution for large <code class="reqn">n</code>.
</p>
<p>The argument <code>cc.lab</code> is case-control label, 1 for case, 0 for control, if the argument <code>case.lab</code> is <code>NULL</code>, 
then <code>cc.lab</code> should be provided in this fashion, if <code>case.lab</code> is provided, the labels are converted to 0's 
and 1's accordingly. 
</p>
<p>The logical argument var.sim (default=<code>FALSE</code>) is for using the simulation estimated variance or the exact 
variance for the variance of <code class="reqn">T_{run}</code> in its standardization.
If <code>var.sim=TRUE</code>, the simulation estimated variance is used for <code class="reqn">Var[T_{run}]</code> (see <code>varTrun.sim</code>), 
otherwise the exact variance (see <code>varTrun</code>) is used.
Moreover, when <code>var.sim=TRUE</code>, the argument <code>Nvar.sim</code> represents the number of resamplings 
(without replacement) in the RL scheme, with default being <code>1000</code>.
</p>
<p>The function <code>varTrun</code> might take a very long time when data size is large (even larger than 50);
in this case, it is recommended to use <code>var.sim=TRUE</code> in this function.
</p>
<p>See also (Cuzick and Edwards (1990)) and the references therein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZTrun(
  dat,
  cc.lab,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  case.lab = NULL,
  var.sim = FALSE,
  Nvar.sim = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZTrun_+3A_dat">dat</code></td>
<td>
<p>The data set in one or higher dimensions, each row corresponds to a data point.</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_cc.lab">cc.lab</code></td>
<td>
<p>Case-control labels, 1 for case, 0 for control</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_alternative">alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code> or <code>"greater"</code>.</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of the upper and lower confidence limits, default is <code>0.95</code>, 
for Cuzick and Edwards <code class="reqn">T_{run}</code> statistic</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_case.lab">case.lab</code></td>
<td>
<p>The label used for cases in the <code>cc.lab</code> (if <code>cc.lab</code> is not provided then the labels are converted
such that cases are 1 and controls are 0), default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_var.sim">var.sim</code></td>
<td>
<p>A logical argument (default is <code>FALSE</code>) to determine whether the simulation estimated variance or
the exact variance be used for the variance of <code class="reqn">T_{run}</code> in its standardization.
If <code>var.sim=TRUE</code>, the simulation estimated variance is used for <code class="reqn">Var[T_{run}]</code> (see <code>varTrun.sim</code>), 
otherwise the exact variance (see <code>varTrun</code>) is used.</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_nvar.sim">Nvar.sim</code></td>
<td>
<p>The number of simulations, i.e., the number of resamplings under the RL scheme to estimate the 
variance of <code class="reqn">T_{run}</code>, used only when <code>var.sim=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ZTrun_+3A_...">...</code></td>
<td>
<p>are for further arguments, such as <code>method</code> and <code>p</code>, passed to the <code><a href="stats.html#topic+dist">dist</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the elements
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The <code class="reqn">Z</code> test statistic for the Cuzick and Edwards <code class="reqn">T_{run}</code> test</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the hypothesis test for the corresponding alternative</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>Confidence interval for the Cuzick and Edwards <code class="reqn">T_{run}</code> value
at the given confidence level <code>conf.level</code> and depends on the type of <code>alternative</code>.</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>Estimate of the parameter, i.e., the Cuzick and Edwards <code class="reqn">T_{run}</code> value.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Hypothesized null value for the Cuzick and Edwards <code class="reqn">T_{run}</code> value
which is <code class="reqn">n_1 (n_1-1)/(n_0+1)</code> for this function.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>Type of the alternative hypothesis in the test, one of <code>"two.sided"</code>, <code>"less"</code>, <code>"greater"</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Description of the hypothesis test</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>Name of the data set, <code>dat</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvan Ceyhan
</p>


<h3>References</h3>

<p>Cuzick J, Edwards R (1990).
&ldquo;Spatial clustering for inhomogeneous populations (with discussion).&rdquo;
<em>Journal of the Royal Statistical Society, Series B</em>, <b>52</b>, 73-104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ceTrun">ceTrun</a></code>, <code><a href="#topic+ZceTk">ZceTk</a></code>, and <code><a href="#topic+ZTcomb">ZTcomb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-20  #or try sample(1:20,1) #try also 40, 50, 60
set.seed(123)
Y&lt;-matrix(runif(3*n),ncol=3)
cls&lt;-sample(0:1,n,replace = TRUE)  #or try cls&lt;-rep(0:1,c(10,10))

ZTrun(Y,cls)
ZTrun(Y,cls,method="max")
ZTrun(Y,cls,var.sim=TRUE)
ZTrun(Y,cls+1,case.lab = 2,alt="l") #try also ZTrun(Y,cls,conf=.9,alt="g")

#cls as a factor
na&lt;-floor(n/2); nb&lt;-n-na
fcls&lt;-rep(c("a","b"),c(na,nb))
ZTrun(Y,fcls,case.lab="a")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
