<!DOCTYPE html><html><head><title>Help for package PST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cmine'><p> Mining contexts</p></a></li>
<li><a href='#cplot'>
<p>Plot single nodes of a probabilistic suffix tree</p></a></li>
<li><a href='#cprob'>
<p>Empirical conditional probability distributions of order <code>L</code></p></a></li>
<li><a href='#generate'>
<p>Generate sequences using a probabilistic suffix tree</p></a></li>
<li><a href='#impute'>
<p>Impute missing values using a probabilistic suffix tree</p></a></li>
<li><a href='#logLik'>
<p>Log-Likelihood of a variable length Markov chain model</p></a></li>
<li><a href='#nobs'>
<p>Extract the number of observations to which a VLMC model is fitted</p></a></li>
<li><a href='#nodenames'>
<p>Retrieve the node labels of a PST</p></a></li>
<li><a href='#pdist'>
<p>Compute probabilistic divergence between two PST</p></a></li>
<li><a href='#plot-PSTr'>
<p>Plot a PST</p></a></li>
<li><a href='#pmine'><p> PST based pattern mining</p></a></li>
<li><a href='#ppplot'>
<p>Plotting a branch of a probabilistic suffix tree</p></a></li>
<li><a href='#pqplot'>
<p>Prediction quality plot</p></a></li>
<li><a href='#predict'>
<p>Compute the probability of categorical sequences using a probabilistic suffix tree</p></a></li>
<li><a href='#print'><p> Print method for objects of class <code>PSTf</code> and <code>PSTr</code></p></a></li>
<li><a href='#prune'>
<p>Prune a probabilistic suffix tree</p></a></li>
<li><a href='#PSTf-class'><p>Flat representation of a probabilistic suffix tree</p></a></li>
<li><a href='#PSTr-class'><p>Nested representation of a probabilistic suffix tree</p></a></li>
<li><a href='#pstree'>
<p>Build a probabilistic suffix tree</p></a></li>
<li><a href='#query'>
<p>Retrieve counts or next symbol probability distribution</p></a></li>
<li><a href='#s1'>
<p>Example sequence data set</p></a></li>
<li><a href='#SRH'>
<p>Longitudinal data on self rated health</p></a></li>
<li><a href='#subtree'><p> Extract a subtree from a segmented PST</p></a></li>
<li><a href='#summary-methods'><p> Summary of variable length Markov chain model</p></a></li>
<li><a href='#tune'>
<p>AIC, AICc or BIC based model selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.94.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Suffix Trees and Variable Length Markov Chains</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Gabadinho [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Gabadinho &lt;alexis.gabadinho@wanadoo.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), TraMineR, RColorBrewer</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for analysing state sequences with probabilistic suffix trees (PST), the construction that stores variable length Markov chains (VLMC). Besides functions for learning and optimizing VLMC models, the PST library includes many additional tools to analyse sequence data with these models: visualization tools, functions for sequence prediction and artificial sequences generation, as well as for context and pattern mining. The package is specifically adapted to the field of social sciences by allowing to learn VLMC models from sets of individual sequences possibly containing missing values, and by accounting for case weights. The  library also allows to compute probabilistic divergence between two models, and to fit segmented VLMC, where sub-models fitted to distinct strata of the learning sample are stored in a single PST. This software results from research work executed within the framework of the Swiss National Centre of Competence in Research LIVES, which is financed by the Swiss National Science Foundation. The authors are grateful to the Swiss National Science Foundation for its financial support.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/pst">https://r-forge.r-project.org/projects/pst</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>pst</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>297</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2017-02-02 16:41:19</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 15:52:30 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 15:49:28 UTC; hornik</td>
</tr>
</table>
<hr>
<h2 id='cmine'> Mining contexts </h2><span id='topic+cmine'></span><span id='topic+cmine+2CPSTf-method'></span><span id='topic++5B+2Ccprobd.list-method'></span><span id='topic++5B+2Ccprobd.list+2CANY+2CANY+2CANY-method'></span><span id='topic+plot+2Ccprobd.list+2CANY-method'></span>

<h3>Description</h3>

<p>Extracting contexts in a PST satisfying user defined criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S4 method for signature 'PSTf'
cmine(object, l, pmin, pmax, state, as.tree=FALSE, delete=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmine_+3A_object">object</code></td>
<td>

<p>A probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_l">l</code></td>
<td>

<p>length of the context to search for.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_pmin">pmin</code></td>
<td>

<p>numeric. Minimal probability for selecting the (sub)sequence.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_pmax">pmax</code></td>
<td>

<p>numeric. Maximal probability for selecting the (sub)sequence.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_state">state</code></td>
<td>

<p>character. One or several states of the alphabet for which the (cumulated) probability is greater than <code>pmin</code> or less than <code>pmax</code>.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_as.tree">as.tree</code></td>
<td>

<p>logical. If <code>TRUE</code> the <code>cmine</code> method returns a subtree of the PST given as input with selected contexts (including their parent nodes, even if these don't statistify the defined criterion). If <code>FALSE</code> the output is the list of selected contexts. See value.
</p>
</td></tr>
<tr><td><code id="cmine_+3A_delete">delete</code></td>
<td>

<p>Logical. If <code>as.tree=TRUE</code> and <code>delete=FALSE</code>, the pruned nodes are not removed from the tree but tagged as pruned=FALSE, so that when plotting the pruned tree these nodes wil appear surrounded with red (can be set to another color) lines.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.tree=TRUE</code> a PST, that is an object of class <code>PSTf</code> which can be printed and plotted; if <code>as.tree=FALSE</code> a list of contexts with their associated next symbol probability distribution, that is an object of class <code>cprobd.list</code> for which a <code>plot</code> method is available. Subscripts can be used to select subsets of the contexts, see examples. 
</p>


<h3>details</h3>

<p>The <code>cmine</code> function searches in the tree for nodes fulfilling certain characteristics, for example contexts that are highly likely to be followed by a given state (see example 1). One can also mine for contexts corresponding to a minimum or maximum probability for several states together (see example 2). For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the SRH.seq sequence object
data(SRH)

## Learning the model
SRH.pst &lt;- pstree(SRH.seq, nmin=30, ymin=0.001)

## Example 1: searching for all contexts yielding a probability of the 
## state G1 (very good health) of at least pmin=0.5
cm1 &lt;- cmine(SRH.pst, pmin=0.5, state="G1")
cm1[1:10]

## Example 2: contexts associated with a high probability of 
## medium or lower self rated health 
cm2 &lt;- cmine(SRH.pst, pmin=0.5, state=c("B1", "B2", "M"))
plot(cm2, tlim=0, main="(a) p(B1,B2,M)&gt;0.5")
</code></pre>

<hr>
<h2 id='cplot'>
Plot single nodes of a probabilistic suffix tree
</h2><span id='topic+cplot'></span><span id='topic+cplot+2CPSTf-method'></span>

<h3>Description</h3>

<p>Plot the next symbol probability distribution associated with a particular node in a PST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S4 method for signature 'PSTf'
cplot(object, context, state, main=NULL, all=FALSE, x.by=1, y.by=0.2, by.state=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplot_+3A_object">object</code></td>
<td>
<p>A probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.</p>
</td></tr>
<tr><td><code id="cplot_+3A_context">context</code></td>
<td>
<p>character. Label of the node to plot, provided as a string where states are separated by '-', see examples.</p>
</td></tr>
<tr><td><code id="cplot_+3A_state">state</code></td>
<td>
<p>logical. Under development.</p>
</td></tr>
<tr><td><code id="cplot_+3A_main">main</code></td>
<td>
<p>character. Main title for the plot. By default, the title is the node label.</p>
</td></tr>
<tr><td><code id="cplot_+3A_all">all</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="cplot_+3A_x.by">x.by</code></td>
<td>
<p>numeric. Interval for the ticks on the x axis (segments).</p>
</td></tr>
<tr><td><code id="cplot_+3A_y.by">y.by</code></td>
<td>
<p>numeric. Interval for the ticks on the y axis (probability).</p>
</td></tr>
<tr><td><code id="cplot_+3A_by.state">by.state</code></td>
<td>
<p>logical. If <code>TRUE</code>, the representation of the probability distribution is done separately for each state of the alphabet.</p>
</td></tr>
<tr><td><code id="cplot_+3A_...">...</code></td>
<td>
<p> arguments to be passed to the plot function or other graphical parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cplot()</code> function displays a single node labelled with <code>context</code> of the tree where one or mode barplots (if <code>object</code> is a segmented PST) represent the probability distribution(s) stored in the node. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppplot">ppplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)
S1 &lt;- pstree(s1, L=3)

cplot(S1, "a-b")
</code></pre>

<hr>
<h2 id='cprob'>
Empirical conditional probability distributions of order <code>L</code>
</h2><span id='topic+cprob'></span><span id='topic+cprob+2Cstslist-method'></span>

<h3>Description</h3>

<p>Compute the empirical conditional probability distributions of order L from a set of sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stslist'
cprob(object, L, cdata=NULL, context, stationary=TRUE, nmin=1, prob=TRUE, 
weighted=TRUE, with.missing=FALSE, to.list=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cprob_+3A_object">object</code></td>
<td>

<p>a sequence object, that is an object of class stslist as created by TraMineR <code><a href="TraMineR.html#topic+TraMineR">seqdef</a></code> function.
</p>
</td></tr>
<tr><td><code id="cprob_+3A_l">L</code></td>
<td>
 
<p>integer. Context length.
</p>
</td></tr>
<tr><td><code id="cprob_+3A_cdata">cdata</code></td>
<td>
 
<p>under development 
</p>
</td></tr>
<tr><td><code id="cprob_+3A_context">context</code></td>
<td>

<p>character. An optional subsequence (a character string where symbols are separated by '-') for which the conditional probability distribution is to be computed.
</p>
</td></tr>
<tr><td><code id="cprob_+3A_stationary">stationary</code></td>
<td>

<p>logical. If <code>FALSE</code> probability distributions are computed for each sequence position L+1 ... l where l is the maximum sequence length. If <code>TRUE</code> the probability distributions are  stationary that is time homogenous. 
</p>
</td></tr>
<tr><td><code id="cprob_+3A_nmin">nmin</code></td>
<td>

<p>integer. Minimal frequency of a context. See details.
</p>
</td></tr>
<tr><td><code id="cprob_+3A_prob">prob</code></td>
<td>

<p>logical. If <code>TRUE</code> the probability distributions are returned. If <code>FALSE</code> the function returns the empirical counts on which the probability distributions are computed.
</p>
</td></tr>
<tr><td><code id="cprob_+3A_weighted">weighted</code></td>
<td>

<p>logical. If <code>TRUE</code> case weights attached to the sequence object are used in the computation of the probabilities. 
</p>
</td></tr>
<tr><td><code id="cprob_+3A_with.missing">with.missing</code></td>
<td>

<p>logical. If <code>FALSE</code> only contexts contining no missing status are considered. 
</p>
</td></tr>
<tr><td><code id="cprob_+3A_to.list">to.list</code></td>
<td>

<p>logical. If <code>TRUE</code> and <code>stationary=TRUE</code>, a list instead of a matrix is returned. See <code>value</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical conditional probability <code class="reqn">\hat{P}(\sigma | c)</code> of observing a symbol <code class="reqn">\sigma \in A</code> after the subsequence <code class="reqn">c=c_{1}, \ldots, c_{k}</code> of length <code class="reqn">k=L</code> is computed as 
</p>
<p style="text-align: center;"><code class="reqn">
\hat{P}(\sigma | c) = \frac{N(c\sigma)}{\sum_{\alpha \in A} N(c\alpha)}
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
N(c)=\sum_{i=1}^{\ell} 1 \left[x_{i}, \ldots, x_{i+|c|-1}=c \right], \; x=x_{1}, \ldots, x_{\ell}, \; c=c_{1}, \ldots, c_{k}
</code>
</p>

<p>is the number of occurrences of the subsequence <code class="reqn">c</code> in the sequence <code class="reqn">x</code> and <code class="reqn">c\sigma</code> is the concatenation of the subsequence <code class="reqn">c</code> and the symbol <code class="reqn">\sigma</code>.  
</p>
<p>Considering a - possibly weighted - sample of <code class="reqn">m</code> sequences having weights <code class="reqn">w^{j}, \; j=1 \ldots m</code>, the function <code class="reqn">N(c)</code> is replaced by
</p>
<p style="text-align: center;"><code class="reqn">
N(c)=\sum_{j=1}^{m} w^{j} \sum_{i=1}^{\ell} 1 \left[x_{i}^{j}, \ldots, x_{i+|c|-1}^{j}=c \right], \; c=c_{1}, \ldots, c_{k}
</code>
</p>

<p>where <code class="reqn">x^{j}=x_{1}^{j}, \ldots, x_{\ell}^{j}</code> is the <code class="reqn">j</code>th sequence in the sample. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>If <code>stationary=TRUE</code> a matrix  with one row for each subsequence of length <code class="reqn">L</code> and minimal frequency <code class="reqn">nmin</code> appearing in <code>object</code>.  If <code>stationary=FALSE</code> a list where each element corresponds to one subsequence and contains a matrix whith the probability distribution at each position <code class="reqn">p</code> where a state is preceded by the subsequence.  
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with the single sequence s1
data(s1)
s1 &lt;- seqdef(s1)
cprob(s1, L=0, prob=FALSE)
cprob(s1, L=1, prob=TRUE)

## Preparing a sequence object with the SRH data set
data(SRH)
state.list &lt;- levels(SRH$p99c01)
## sequential color palette
mycol5 &lt;- rev(brewer.pal(5, "RdYlGn"))
SRH.seq &lt;- seqdef(SRH, 5:15, alphabet=state.list, states=c("G1", "G2", "M", "B2", "B1"), 
	labels=state.list, weights=SRH$wp09lp1s, right=NA, cpal=mycol5)
names(SRH.seq) &lt;- 1999:2009

## Example 1: 0th order: weighted and unweigthed counts
cprob(SRH.seq, L=0, prob=FALSE, weighted=FALSE)
cprob(SRH.seq, L=0, prob=FALSE, weighted=TRUE)

## Example 2: 2th order: weighted and unweigthed probability distrib.
cprob(SRH.seq, L=2, prob=TRUE, weighted=FALSE)
cprob(SRH.seq, L=2, prob=TRUE, weighted=TRUE)
</code></pre>

<hr>
<h2 id='generate'>
Generate sequences using a probabilistic suffix tree
</h2><span id='topic+generate'></span><span id='topic+generate+2CPSTf-method'></span>

<h3>Description</h3>

<p>Generate sequences using a probabilistic suffix tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
generate(object, l, n, s1, p1, method, L, cnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="generate_+3A_l">l</code></td>
<td>

<p>integer. Length of the sequence(s) to generate.
</p>
</td></tr>
<tr><td><code id="generate_+3A_n">n</code></td>
<td>

<p>integer. Number of the sequence(s) to generate.
</p>
</td></tr>
<tr><td><code id="generate_+3A_s1">s1</code></td>
<td>

<p>character. The first state in the sequences. The length of the vector should equal <code>n</code>. If specified, the first state in the sequence(s) is not randomly generated but taken from <code>s1</code>. 
</p>
</td></tr>
<tr><td><code id="generate_+3A_p1">p1</code></td>
<td>

<p>numeric. An optional probability vector for generating the first position state in the sequence(s). If specified, the first state in the sequence(s) is randomly generated using the probability distribution in <code>p1</code> instead of the probability distribution taken fron the root node of <code>object</code>. 
</p>
</td></tr>
<tr><td><code id="generate_+3A_method">method</code></td>
<td>

<p>character. If <code>method=pmax</code>, at each position the state having the highest probability is chosen. If <code>method=prob</code>, at each position the state is generated using the corresponding probability distribution taken from <code>object</code>.
</p>
</td></tr>
<tr><td><code id="generate_+3A_l">L</code></td>
<td>

<p>integer: Maximal depth used to extract the probability distributions from the PST object.  
</p>
</td></tr>
<tr><td><code id="generate_+3A_cnames">cnames</code></td>
<td>

<p>character: Optional column (position) names for the returned state sequence object. By default, the names of the sequence object to which the model was fitted are used (slot &quot;data&quot; of the PST).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a probabilistic suffix tree (PST) represents a generating model, it can be used to generate artificial sequence data sets. Sequences are built by generating the states at each successive position. The process is similar to sequence prediction (see <code><a href="#topic+predict">predict</a></code>), except that the retrieved conditional probability distributions provided by the PST are used to generate a symbol instead of computing the probability of an existing state. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>A state sequence object (an object of class <code>stslist</code>) containing <code>n</code> sequences. This object can be passed as argument to all the functions for visualization and analysis provided by the <code><a href="TraMineR.html#topic+TraMineR">TraMineR</a></code> package. 
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1.seq &lt;- seqdef(s1)
S1 &lt;- pstree(s1.seq, L=3)

## Generating 10 sequences
generate(S1, n=10, l=10, method="prob")

## First state is generated with p(a)=0.9 and p(b)=0.1
generate(S1, n=10, l=10, method="prob", p1=c(0.9, 0.1))
</code></pre>

<hr>
<h2 id='impute'>
Impute missing values using a probabilistic suffix tree
</h2><span id='topic+impute'></span><span id='topic+impute+2CPSTf+2Cstslist-method'></span>

<h3>Description</h3>

<p>Missing states in a set of sequences are imputed by using the probability distributions stored in a probabilistic suffix tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf,stslist'
impute(object, data, method="pmax")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="impute_+3A_data">data</code></td>
<td>

<p>a sequence object, i.e., an object of class <code>'stslist'</code> as created by TraMineR <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function, containing the sequences to impute. See details.
</p>
</td></tr>
<tr><td><code id="impute_+3A_method">method</code></td>
<td>

<p>character. If <code>method='pmax'</code> the state having the highest probability according to the probability distribution associated with the context preceding the missing status is imputed. If <code>method='prob'</code> the imputation is done randomly by using this probability distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A probabilistic suffix tree (PST) can be used to impute missing states in sequences built on the same alphabet. When a missing state occurs in a sequence the procedure searches in the PST for the context preceding the missing state and impute the state according to the conditional distribution associated with the context. The imputation can be done either randomly (method=&quot;prob&quot;) or with the state having the highest probability. However, more sophisticated modelling taking account of the non response mechanism could be required for imputing missing states. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>A sequence object (of class <code>stslist</code>) containing original sequences in <code>data</code> with missing states imputed.  
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, 2016, <b>72</b>(3), 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the SRH.seq sequence object
data(SRH)

## working with a sub-sample of 500 sequences
## to reduce computing time
subs &lt;- sample(nrow(SRH.seq), size=500)
SRH.sub.seq &lt;- SRH.seq[subs,]

## Learning the model (missing state is not included)
SRH.pst.L10 &lt;- pstree(SRH.sub.seq, nmin=2, ymin=0.001)

## Pruning
C99 &lt;- qchisq(0.99,5-1)/2
SRH.pst.L10.C99 &lt;- prune(SRH.pst.L10, gain="G2", C=C99)

## Imputing missing values in the SRH sequences
SRH.sub.iseq &lt;- impute(SRH.pst.L10, SRH.sub.seq, method="prob")

## locating sequences having missing values
## in sequence object missing states are identified by '*'
have.miss &lt;- which(rowSums(SRH.sub.seq=='*')&gt;0)

## plotting non imputed vs imputed sequence
## (first 10 sequences in the set) 
par(mfrow=c(1,2))
seqiplot(SRH.sub.seq[have.miss,], withlegend=FALSE)
seqiplot(SRH.sub.iseq[have.miss,], withlegend=FALSE)
</code></pre>

<hr>
<h2 id='logLik'>
Log-Likelihood of a variable length Markov chain model
</h2><span id='topic+logLik'></span><span id='topic+logLik+2CPSTf-method'></span>

<h3>Description</h3>

<p>Retrieve the log-likelihood of a fitted VLMC. This is the <code><a href="#topic+logLik">logLik</a></code> method for objects of class <code>PSTf</code> returned by the <code><a href="#topic+pstree">pstree</a></code> and <code><a href="#topic+prune">prune</a></code> functions.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood of a learning sample containing <code class="reqn">n</code> sequences, given a model <code class="reqn">S</code> fitted to it, is
</p>
<p style="text-align: center;"><code class="reqn">
L(S)=\prod_{i=1}^{n} P^{S}(x^{i})
</code>
</p>

<p>where <code class="reqn">P^{S}(x^{i})</code> is the probability of the <code class="reqn">i</code>th observed sequence predicted by <code class="reqn">S</code>.
Note that the log-likelihood of a VLMC model is not used in the estimation of the model's parameters (see <code><a href="#topic+pstree">pstree</a></code>). It is obtained once the model is estimated by calling the <code><a href="#topic+predict">predict</a></code> function. The value is stored in the <code>logLik</code> slot of the probabilistic suffix tree representing the model (a <code>PSTf</code> object returned by the <code>pstree</code> or <code>prune</code> function). 
The <code>AIC</code> and <code>BIC</code> values can also be obtained with the corresponding generic functions, which call <code>logLik</code> and use its result. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>logLik</code>, a negative numeric value with the <code>df</code> (degrees of freedom) attribute containing the number of free parameters of the model.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+stats4">AIC</a></code>, <code><a href="stats4.html#topic+stats4">BIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## activity calendar for year 2000
## from the Swiss Household Panel
## see ?actcal
data(actcal)

## selecting individuals aged 20 to 59
actcal &lt;- actcal[actcal$age00&gt;=20 &amp; actcal$age00 &lt;60,]

## defining a sequence object
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## building a PST
actcal.pst &lt;- pstree(actcal.seq, nmin=2, ymin=0.001)
logLik(actcal.pst)

## Cut-offs for 5% and 1% (see ?prune)
C99 &lt;- qchisq(0.99,4-1)/2

## pruning
actcal.pst.C99 &lt;- prune(actcal.pst, gain="G2", C=C99)

## Comparing AIC
AIC(actcal.pst, actcal.pst.C99)
</code></pre>

<hr>
<h2 id='nobs'>
Extract the number of observations to which a VLMC model is fitted
</h2><span id='topic+lnobs'></span><span id='topic+nobs+2CPSTf-method'></span>

<h3>Description</h3>

<p>The number of observations to which a VLMC model is fitted is notably used for computing the Bayesian information criterion <code>BIC</code> or the Akaike information criterion with correction for finite sample sizes <code>AICc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
nobs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs_+3A_object">object</code></td>
<td>

<p>A PST, that is an object of class <code>PSTf</code> as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method for the generic <code>nobs</code> function provided by the <code>stats4</code> package. The number of observations to which a VLMC model is fitted is the total number of symbols in the learning sample. If the learning sample contains missing values and the model is learned without including missing values (see <code><a href="#topic+pstree">pstree</a></code>), the total number of symbols is the number of non-missing states in the sequence(s). This information is used to compute the Bayesian information criterion of a fitted VLMC model. The <code>BIC</code> generic function calls the <code><a href="#topic+logLik">logLik</a></code> and <code>nobs</code> methods for class <code>PSTf</code>. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>An integer containing the number of symbols in the learning sample.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+stats4">BIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1.seq &lt;- seqdef(s1)
S1 &lt;- pstree(s1.seq, L=3)
nobs(S1)

## Self rated health sequences
## Loading the 'SRH' data frame and 'SRH.seq' sequence object
data(SRH)

## model without considering missing states
## model with max. order 2 to reduce computing time
## nobs is the same whatever L and nmin
m1 &lt;- pstree(SRH.seq, L=2, nmin=30, ymin=0.001)
nobs(m1)

## considering missing states, hence nobs is higher
m2 &lt;- pstree(SRH.seq, L=2, nmin=30, ymin=0.001, with.missing=TRUE)
nobs(m2)
</code></pre>

<hr>
<h2 id='nodenames'>
Retrieve the node labels of a PST
</h2><span id='topic+nodenames'></span><span id='topic+nodenames+2CPSTf-method'></span>

<h3>Description</h3>

<p>Retrieve the node labels of a PST 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
nodenames(object, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodenames_+3A_object">object</code></td>
<td>

<p>A PST, that is an object of class <code>PSTf</code> as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
<tr><td><code id="nodenames_+3A_l">L</code></td>
<td>

<p>integer. Depth of the tree for which the node names are retrieved. If missing the names of all the nodes in the tree are returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the node labels (i.e. contexts).
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)
S1 &lt;- pstree(s1, L=3)

nodenames(S1, L=3)
nodenames(S1)
</code></pre>

<hr>
<h2 id='pdist'>
Compute probabilistic divergence between two PST
</h2><span id='topic+pdist'></span><span id='topic+pdist+2CPSTf+2CPSTf-method'></span>

<h3>Description</h3>

<p>Compute probabilistic divergence between two PST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf,PSTf'
pdist(x,y, method="cp", l, ns=5000, symetric=FALSE, output="all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="pdist_+3A_y">y</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr> 
<tr><td><code id="pdist_+3A_method">method</code></td>
<td>

<p>character. Method for computing distances. So far only one method is available.
</p>
</td></tr>
<tr><td><code id="pdist_+3A_l">l</code></td>
<td>

<p>integer. Length of the sequence(s) to generate.
</p>
</td></tr>
<tr><td><code id="pdist_+3A_ns">ns</code></td>
<td>

<p>integer. Number sequences to generate.
</p>
</td></tr>
<tr><td><code id="pdist_+3A_symetric">symetric</code></td>
<td>

<p>logical. If <code>TRUE</code>, the symetric version of the measure is returned, see details.
</p>
</td></tr>
<tr><td><code id="pdist_+3A_output">output</code></td>
<td>

<p>character. See <code>value</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes a probabilistic divergence measure between PST <code class="reqn">S_{A}</code> and <code class="reqn">S_{B}</code> based on the measure originally proposed in <cite>Juang-1985</cite> and <cite>Rabiner-1989</cite> for the comparison of two (hidden) Markov models <code class="reqn">S_{A}</code> and <code class="reqn">S_{B}</code>
</p>
<p style="text-align: center;"><code class="reqn">
d(S_{A}, S_{B})=\frac{1}{\ell} [\log P^{S_{A}}(x)-\log P^{S_{B}}(x)]=\frac{1}{\ell}\log \frac{P^{S_{A}}(x)}{P^{S_{B}}(x)}
</code>
</p>

<p>where <code class="reqn">x=x_{1}, \ldots, x_{\ell}</code> is a sequence generated by model <code class="reqn">S_{A}</code>, <code class="reqn">P^{S_{A}}(x)</code> is the probability of <code class="reqn">x</code> given model <code class="reqn">S_{A}</code> and <code class="reqn">P^{S_{B}}(x)</code> is the probability of <code class="reqn">x</code> given model <code class="reqn">S_{B}</code>. The ratio between the two sequence likelihoods measures how many times the sequence <code class="reqn">x</code> is more likely to have been generated by <code class="reqn">S_{A}</code> than by <code class="reqn">S_{2}</code>. 
</p>
<p>As the number <code class="reqn">n</code> of generated sequences on which the measure is computed (or the length of a single sequence) approaches infinity, the expected value of <code class="reqn">d(S_{A}, S_{B})</code> converges to <code class="reqn">d_{KL}(S_{A}, S_{B})</code> <cite>Falkhausen-1995, He-2000</cite>, the Kullback-Leibler (KL) divergence (also called information gain) used in information theory to measure the difference between two probability distributions.
</p>
<p>The <code>pdist</code> function uses the following procedure to compute the divergence between two PST:
</p>

<ul>
<li><p> generate a ransom sample of <code class="reqn">n</code> sequences (of length <code class="reqn">\ell</code>) with model <code class="reqn">S_{A}</code> using the <code><a href="#topic+generate">generate</a></code> method
</p>
</li>
<li><p> predict the sequences with <code class="reqn">S_{A}</code> and with <code class="reqn">S_{B}</code>
</p>
</li>
<li><p> compute 
</p>
<p style="text-align: center;"><code class="reqn">
d_{i}(S_{A}, S_{B})=\frac{1}{\ell} [\log P^{S_{A}}(x_{i})-\log P^{S_{B}}(x_{i}))], \; i=1, \ldots, n
</code>
</p>

</li>
<li><p> the expected value 
</p>
<p style="text-align: center;"><code class="reqn">
E(d(S_{A}, S_{B}))
</code>
</p>

<p>is the divergence between models <code class="reqn">S_{A}</code> and <code class="reqn">S_{B}</code> and is estimated as 
</p>
<p style="text-align: center;"><code class="reqn">
\hat{E}(d(S_{A}, S_{B}))=\frac{1}{n} \sum_{i=1}^{n} d_{i}(S_{A}, S_{B})
</code>
</p>

</li></ul>

<p>For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>If <code>ouput="all"</code>, a vector containing the divergence value for each generated sequence, if <code>output="mean"</code>, the mean, i.e. expected value which is the divergence between models.
</p>


<h3>Author(s)</h3>

<p>Alexis gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>
<p>Juang, B. H. and Rabiner, L. R. (1985). A probabilistic distance measure for hidden Markov models. <em>ATT Technical Journal</em>, <b>64</b>(2), pp. 391-408.
</p>
<p>Rabiner, L. R. (1989). A tutorial on hidden Markov models and selected applications in speech recognition. <em>Proceedings of the IEEE</em>, <b>77</b>(2), pp. 257-286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## activity calendar for year 2000
## from the Swiss Household Panel
## see ?actcal
data(actcal)

## selecting individuals aged 20 to 59
actcal &lt;- actcal[actcal$age00&gt;=20 &amp; actcal$age00 &lt;60,]

## defining a sequence object
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## building a PST segmented by age group
gage10 &lt;- cut(actcal$age00, c(20,30,40,50,60), right=FALSE,
	labels=c("20-29","30-39", "40-49", "50-59"))

actcal.pstg &lt;- pstree(actcal.seq, nmin=2, ymin=0.001, group=gage10)

## pruning
C99 &lt;- qchisq(0.99,4-1)/2
actcal.pstg.opt &lt;- prune(actcal.pstg, gain="G2", C=C99)

## extracting PST for age group 20-39 and 30-39
g1.pst &lt;- subtree(actcal.pstg.opt, group=1)
g2.pst &lt;- subtree(actcal.pstg.opt, group=2)

## generating 5000 sequences with g1.pst 
## and computing 5000 distances
dist.g1_g2 &lt;- pdist(g1.pst, g2.pst, l=11)
hist(dist.g1_g2)

## the probabilistic distance is the mean
## of the 5000 distances
mean(dist.g1_g2)
</code></pre>

<hr>
<h2 id='plot-PSTr'>
Plot a PST
</h2><span id='topic+plot+2CPSTf+2CANY-method'></span><span id='topic+plot+2CPSTr+2CANY-method'></span>

<h3>Description</h3>

<p>Plot a PST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S4 method for signature 'PSTf,ANY'
plot(x, y=missing, max.level=NULL,
		nodePar = list(), edgePar = list(),
		axis=FALSE, xlab = NA, ylab = if (axis) { "L" } else {NA}, 
		horiz = FALSE, xlim, ylim, 
		withlegend=TRUE, ltext=NULL, cex.legend=1, 
		use.layout=withlegend!=FALSE, legend.prop=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-PSTr_+3A_x">x</code></td>
<td>

<p>A PST, that is an object of class <code>PSTf</code> as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_y">y</code></td>
<td>

<p>not applicable
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_max.level">max.level</code></td>
<td>
 
<p>integer. The maximal depth for the display of the tree.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_nodepar">nodePar</code></td>
<td>
 
<p>list. A list of parameters for tuning the node representation. Possible parameters are
</p>

<ul>
<li><p> node.size. numeric. The size of the node, in fraction of a unit of the x axis (or y axis if horiz=TRUE).
</p>
</li>
<li><p> gratio. The ratio between horizontal and vertical dimensions of the node. usefull if the horizontal and vertical dimensions of the plot are not equal. If not provided, it is estimated as a function of the number of leaves represented in the plot and the depth of the tree.
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot-PSTr_+3A_edgepar">edgePar</code></td>
<td>
 
<p>list. A list of parameters for tuning the edges representation. Possible paramters are
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_axis">axis</code></td>
<td>
 
<p>logical. If TRUE the axes are displayed on the plot.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_xlab">xlab</code></td>
<td>
 
<p>character. Label for the x axis.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_ylab">ylab</code></td>
<td>
 
<p>character. Label for the y axis representing the tree depth.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_horiz">horiz</code></td>
<td>
 
<p>logical. If FALSE, the tree is represented vertically. The root node at depth L=0 is plotted on the top, and the nodes of maximal depth are plotted on the bottom of the plot. If TRUE, the tree is represented horizontally. The root node at depth L=0 is plotted on the right, and the nodes of maximal depth are plotted on the left of the plot.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_xlim">xlim</code></td>
<td>

<p>numeric. Vector of length 2 giving the x limits for the plot. By default the limits are 1 .. number of terminal nodes (at max.level if specified). This may be usefull to facilitate comparison if several trees are plotted on the same figure.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_ylim">ylim</code></td>
<td>

<p>numeric. Vector of length 2 giving the y limits for the plot. By default the limits are 0 .. max. depth of the tree (max.level if specified). This may be usefull to facilitate comparison if several trees are plotted on the same figure.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_withlegend">withlegend</code></td>
<td>
 
<p>defines if and where the legend of the state colors is plotted. The default value <code>TRUE</code> sets the position of the legend automatically. Other possible value is <code>"right"</code>.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_ltext">ltext</code></td>
<td>

<p>optional description of the states to appear in the legend. Must be a vector of character strings with number of elements equal to the size of the alphabet. If unspecified, the <code>label</code> attribute of the <code>seqdata</code> sequence object is used (see <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code>).
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_cex.legend">cex.legend</code></td>
<td>

<p>expansion factor for setting the size of the font for the labels in the legend. The default value is 1. Values lesser than 1 will reduce the size of the font, values greater than 1 will increase the size.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_use.layout">use.layout</code></td>
<td>

<p>if <code>TRUE</code>, <code><a href="graphics.html#topic+layout">layout</a></code> is used to arrange plots when using the group option or plotting a legend. When layout is activated, the standard '<code><a href="graphics.html#topic+par">par</a>(mfrow=....)</code>' for arranging plots does not work. With <code>withlegend=FALSE</code> and <code>group=NULL</code>, layout is automatically deactivated and '<code>par(mfrow=....)</code>' can be used.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_legend.prop">legend.prop</code></td>
<td>

<p>sets the proportion of the graphic area used for plotting the legend when <code>use.layout=TRUE</code> and <code>withlegend=TRUE</code>. Default value is set according to the place (bottom or right of the graphic area) where the legend is plotted. Values from 0 to 1.
</p>
</td></tr>
<tr><td><code id="plot-PSTr_+3A_...">...</code></td>
<td>

<p>arguments to be passed to the plot function or graphical parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function for graphical representation of a PST uses is recursive. The main argument of the function is a tree represented as a nested list (an object of class <code>PSTr</code>). See also <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho, based on code from <code>plot.dendrogram</code> 
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)
S1 &lt;- pstree(s1, L=3)
plot(S1)
plot(S1, horiz=TRUE)
plot(S1, nodePar=list(node.type="path", lab.type="prob", lab.pos=1, lab.offset=2, lab.cex=0.7), 
	edgePar=list(type="triangle"), withlegend=FALSE)
</code></pre>

<hr>
<h2 id='pmine'> PST based pattern mining </h2><span id='topic+pmine'></span><span id='topic+pmine+2CPSTf+2Cstslist-method'></span>

<h3>Description</h3>

<p>Mine for (sub)sequences satisfying user defined criteria in a state sequence object 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf,stslist'
pmine(object, data, l, pmin=0, pmax=1, prefix, lag, average=FALSE,
output="sequences", with.prefix=TRUE, sorted=TRUE, decreasing=TRUE, score.norm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmine_+3A_object">object</code></td>
<td>

<p>A fitted PST, that is an object of class PSTf as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_data">data</code></td>
<td>

<p>A sequence object of class 'stslist' as defined with the <code>seqdef</code> function of the <code><a href="TraMineR.html#topic+TraMineR">TraMineR</a></code> library.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_l">l</code></td>
<td>

<p>integer. Length of the subsequence to search for.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_pmin">pmin</code></td>
<td>

<p>numeric. (Sub)-sequences having average or per state probability greater or equal than <code>pmin</code> are selected. Default to 1, meaning no lower threshold for the probability.  
</p>
</td></tr>
<tr><td><code id="pmine_+3A_pmax">pmax</code></td>
<td>

<p>numeric. (Sub)-sequences having average or per state probability less or equal than <code>pmax</code> are selected. Default to 1, meaning no upper threshold for the probability.  
</p>
</td></tr>
<tr><td><code id="pmine_+3A_prefix">prefix</code></td>
<td>

<p>character. Subsequences are searched in sequences starting with <code>'prefix'</code>, where <code>'prefix'</code> is a string representing a subsequence with states separated by <code>'-'</code>. This option can be used to search for -most- likely patterns in sequences starting with 'prefix'. 
</p>
</td></tr>
<tr><td><code id="pmine_+3A_lag">lag</code></td>
<td>

<p>integer. The <code>lag</code> first states in the sequence are omitted. If <code>prefix</code> is 
</p>
</td></tr>
<tr><td><code id="pmine_+3A_average">average</code></td>
<td>

<p>logical. If <code>TRUE</code>, the <code>pmin</code> or <code>pmax</code> probability is supposed to be the average state probability in the (sub)sequence. If <code>FALSE</code> (sub)sequences having every state probability less than <code>pmax</code> or greater than <code>pmin</code> are selected.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_output">output</code></td>
<td>

<p>character. If <code>output='sequences'</code> the whole sequence(s) where the user defined criteria is satisfied are returned. If <code>output='patterns'</code> only the (sub)sequences satisfying the user defined criteria are returned.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_with.prefix">with.prefix</code></td>
<td>

<p>logical. If <code>'output=patterns'</code>, should the patterns in the output be preceeded by their prefix, that is by the whole sub-sequence preceding the pattern. 
</p>
</td></tr>
<tr><td><code id="pmine_+3A_sorted">sorted</code></td>
<td>

<p>logical. If <code>'sorted=TRUE'</code>, selected patterns or sequences are sorted according to their score, i.e., their average probability.
</p>
</td></tr>
<tr><td><code id="pmine_+3A_decreasing">decreasing</code></td>
<td>

<p>logical. If <code>'sorted=TRUE'</code>, should sort order be decreasing or increasing ?
</p>
</td></tr>
<tr><td><code id="pmine_+3A_score.norm">score.norm</code></td>
<td>

<p>logical. If <code>TRUE</code>, the score attached to each selected pattern or (sub)-sequence (the weights in the returned sequence object) is the average per state probability, and is thus normalized by the length of the pattern. If <code>FALSE</code>, the score is the whole (sub)-sequence probability.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood <code class="reqn">P^{S}(x)</code> of a whole sequence <code class="reqn">x</code> is computed from the state probabilities at each position in the sequence. However, the likelihood of the first states is usually lower than at higher position due to a reduced memory available for prediction. A sequence may not appear as very likely if its first state has a low relative frequency, even if the model predicts high probabilities for the states at higher positions. 
</p>
<p>The <code>pmine</code> function allows for advanced pattern mining with user defined parameters. It is controlled by the <code>lag</code> and <code>pmin</code> arguments. For example, by setting <code>lag=2</code> and <code>pmin=0.40</code> (example 1), we select all sequences with average (the geometric mean is used) state probability from position <code class="reqn">lag+1, \ldots, \ell</code> above <code>pmin</code>. Instead of considering the average state probability at positions <code class="reqn">lag+1, \ldots, \ell</code>, it is also possible to select frequent patterns that do not contain any state with probability below the threshold. This prevents from selecting sequences having many states with high probability but one ore several states with a low probability. 
</p>
<p>It is also possible to mine the sequence data for frequent patterns of length <code class="reqn">\ell_{j} &lt; \ell</code>, regardless of the position in the sequence where they occur. By using the <code>output="patterns"</code> argument, the <code>pmine</code> function returns the patterns (as a sequence object) instead of the whole set of distinct sequences containing the patterns. Since the probability of a pattern can be different depending on the context (previous states) the returned subsequences also contain the context preceding the pattern. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>A state sequence object, that is an object of class <code>stslist</code>, where weights are the probability score of (sub)sequences. 
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cmine">cmine</a></code> for context mining
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## activity calendar for year 2000
## from the Swiss Household Panel
## see ?actcal
data(actcal)

## selecting individuals aged 20 to 59
actcal &lt;- actcal[actcal$age00&gt;=20 &amp; actcal$age00 &lt;60,]

## defining a sequence object
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## building a PST
actcal.pst &lt;- pstree(actcal.seq, nmin=2, ymin=0.001)

## pruning
## Cut-offs for 5% and 1% (see ?prune)
C99 &lt;- qchisq(0.99,4-1)/2
actcal.pst.C99 &lt;- prune(actcal.pst, gain="G2", C=C99)

## example 1
pmine(actcal.pst.C99, actcal.seq, pmin=0.4, lag=2)

## example 2: patterns of length 6 having p&gt;=0.6
pmine(actcal.pst.C99, actcal.seq, pmin=0.6, l=6)
</code></pre>

<hr>
<h2 id='ppplot'>
Plotting a branch of a probabilistic suffix tree
</h2><span id='topic+ppplot'></span><span id='topic+ppplot+2CPSTf-method'></span>

<h3>Description</h3>

<p>The <code>ppplot</code> function displays the probability distributions of a node and all its parent nodes (suffixes) in the tree. IF the name of a gain function and a vector of pruning cutoffs are provided, the graphic will display the outcomes of the gain function, i.e., whether a node represents an information gain relative to its parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
ppplot(object, path, gain, C, cex.plot = 1, nsize = 0.3, nlab=TRUE,
	psize = nsize/2, pruned.col = "red", div.col = "green", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppplot_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_path">path</code></td>
<td>
<p> character. Either a character string representing the node label (i.e., the context) where symbols are separated by '-', or a vector where each element is a symbol. See example.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_gain">gain</code></td>
<td>

<p>character or function. Gain function, see <code><a href="#topic+prune">prune</a></code>.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_c">C</code></td>
<td>

<p>numeric. Value of the cutoff used by the gain function, see <code><a href="#topic+prune">prune</a></code>.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_cex.plot">cex.plot</code></td>
<td>
<p>numeric. Expansion factor for setting the size of the font for the axis labels and names. The default value is 1. Values lesser than 1 will reduce the size of the font, values greater than 1 will increase the size.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_nsize">nsize</code></td>
<td>

<p>numeric. Size of the circles representing the nodes.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_nlab">nlab</code></td>
<td>

<p>logical. Should the node label be displayed inside the circle?
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_psize">psize</code></td>
<td>

<p>numeric. Size of the circles representing the outcome of the gain function.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_pruned.col">pruned.col</code></td>
<td>

<p>character. Color used to represent a terminal node which provides no information gain relative to its parent.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_div.col">div.col</code></td>
<td>

<p>character. Color used to represent an internal node which provides information gain relative to its parent.
</p>
</td></tr>
<tr><td><code id="ppplot_+3A_...">...</code></td>
<td>

<p>additional parameters to be passed to the <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplot">cplot</a></code>, <code><a href="#topic+prune">prune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1.seq &lt;- seqdef(s1)
S1 &lt;- pstree(s1.seq, L=5, ymin=0.001)
ppplot(S1, "a-a-b-b-a", gain="G1", C=c(1.1, 1.2))
</code></pre>

<hr>
<h2 id='pqplot'> 
Prediction quality plot
</h2><span id='topic+pqplot'></span><span id='topic+pqplot+2CPSTf+2Cstslist-method'></span>

<h3>Description</h3>

<p>Plot the predicted probability of each state in a sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf,stslist'
pqplot(object, data, cdata, L, stcol, plotseq=FALSE, 
	ptype="b", cex.plot=1, space=0,
	measure="prob", pqmax, seqscale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pqplot_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_data">data</code></td>
<td>

<p>a sequence object, i.e., an object of class <code>'stslist'</code> as created by TraMineR <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function, either subsetted with the index of the sequence to predict or containing one sequence. </p>
</td></tr>
<tr><td><code id="pqplot_+3A_cdata">cdata</code></td>
<td>

<p>Not implemented yet.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_l">L</code></td>
<td>

<p>integer. Maximal context length for sequence prediction. This is the same as pruning the PST by removing all nodes of depth&lt;L before prediction. 
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_stcol">stcol</code></td>
<td>

<p>character. Color to use to plot the prediction qualities. 
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_plotseq">plotseq</code></td>
<td>
 
<p>logical. If TRUE, the sequence is displayed separately, and the prediction plot is plotted above.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_ptype">ptype</code></td>
<td>

<p>character. Type of plot, either <code>'b'</code> for barplot or <code>'l'</code> for line.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_cex.plot">cex.plot</code></td>
<td>

<p>numeric. Expansion factor for setting the size of the font for the axis labels and names. The default value is 1. Values lesser than 1 will reduce the size of the font, values greater than 1 will increase the size.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_space">space</code></td>
<td>
<p>numeric. Space separating each state in the plot.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_measure">measure</code></td>
<td>

<p>character. Measure used for prediction quality. Either <code>'prob'</code> or <code>'logloss'</code>.$
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_pqmax">pqmax</code></td>
<td>

<p>numeric. Maximum coordinate for the prediction quality plot, i.e. the max of the y axis.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_seqscale">seqscale</code></td>
<td>

<p>numeric. If <code>plotseq=TRUE</code>, width of the bar representing the sequence as a proportion of the y axis range.
</p>
</td></tr>
<tr><td><code id="pqplot_+3A_...">...</code></td>
<td>

<p>optional graphical parameters to be passed to the plot function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pqplot()</code> function displays either the predicted probabilities or the log-loss for each position of a single sequence as a series of barplots. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016) Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)
S1 &lt;- pstree(s1, L=3)

z &lt;- seqdef("a-b-a-a-b")
pqplot(S1, z)
pqplot(S1, z, measure="logloss", plotseq=TRUE)
</code></pre>

<hr>
<h2 id='predict'>
Compute the probability of categorical sequences using a probabilistic suffix tree
</h2><span id='topic+predict'></span><span id='topic+predict+2CPSTf-method'></span>

<h3>Description</h3>

<p>Compute the probability (likelihood) of categorical sequences using a Probabilistic Suffix Tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
predict(object, data, cdata, group, L=NULL, p1=NULL, output="prob", decomp=FALSE, base=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="predict_+3A_data">data</code></td>
<td>

<p>a sequence object, i.e., an object of class <code>'stslist'</code> as created by TraMineR <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function, containing the sequences to predict.
</p>
</td></tr>
<tr><td><code id="predict_+3A_cdata">cdata</code></td>
<td>

<p>not implemented yet.
</p>
</td></tr>
<tr><td><code id="predict_+3A_group">group</code></td>
<td>
<p>if <code>object</code> is a segmented PST, providing a vector of group membership so that each sequence probability will be predicted with the conditional probability distributions for the group it belongs to. If <code>object</code> is a segmented PST and <code>group</code> is not provided, each sequence will be predicted by each of the submodel, and the output will be a matrix with <code>nbgroup</code> columns, where <code>nbgroup</code> is the number of segments in the PST.
</p>
</td></tr>
<tr><td><code id="predict_+3A_l">L</code></td>
<td>

<p>integer. Maximal context length for sequence prediction. This is the same as pruning the PST by removing all nodes of depth&lt;L before prediction.
</p>
</td></tr>
<tr><td><code id="predict_+3A_p1">p1</code></td>
<td>

<p>vector. A probability distribution for the first position in the sequence that will be used instead of the root node of the tree.
</p>
</td></tr>
<tr><td><code id="predict_+3A_output">output</code></td>
<td>

<p>character. One of <code>'prob'</code>, <code>'logloss'</code>,  <code>'SIMn'</code> or <code>'SIMo'</code>. See details.
</p>
</td></tr>
<tr><td><code id="predict_+3A_decomp">decomp</code></td>
<td>

<p>logical. If <code>TRUE</code> the predicted probability for each state in the sequence(s) is returned instead of the whole sequence probability.
</p>
</td></tr>
<tr><td><code id="predict_+3A_base">base</code></td>
<td>

<p>integer. Base for the logarithm if a logarithm is used in the used prediction measure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A probabilistic suffix tree (PST) allows to compute the likelihood of any sequence built on the alphabet of the learning sample. This feature is called sequence prediction. The likelihood of the sequence <code>a-b-a-a-b</code> given a PST <code>S1</code> fitted to the example sequence <code>s1</code> (see example) is
</p>
<p style="text-align: center;"><code class="reqn">
P^{S1}(abaab)= P^{S1}(a) \times P^{S1}(b|a) \times P^{S1}(a|ab) \times P^{S1}(a|aba) \times P^{S1}(b|abaa)
</code>
</p>

<p>The probability of each of the state is retrieved from the PST. To get for example <code>P(a|a-b-a)</code>, the tree is scanned for the node labelled with the string <code>a-b-a</code>, and if this node does not exist, it is scanned for the node labelled with the longest suffix of this string, that is <code>b-a</code>, and so on. The node <code>a-b-a</code> is not found in the tree (it has been removed during the pruning stage), and the longest suffix of <code>a-b-a</code> found is <code>b-a</code>. The probability <code>P(a|b-a)</code> is then used instead of <code>P(a|a-b-a)</code>. <br />
</p>
<p>The sequence likelihood is returned by the <code>predict</code> function. By setting <code>decomp=TRUE</code> the output is a matrix containing the probability of each of the symbol composing the sequence. The score <code class="reqn">P^S(x)</code> of a sequence <code class="reqn">x</code> represents the probability that the VLMC model stored by the PST <code class="reqn">S</code> generates <code class="reqn">x</code>. It can be turned into a more readable prediction quality measure such as the <em>average log-loss</em>
</p>
<p style="text-align: center;"><code class="reqn">
logloss(S,x)=-\frac{1}{\ell} \sum_{i=1}^{\ell} \log_{2} P^{S}(x_{i}| x_{1}, \ldots, x_{i-1})=-\frac{1}{\ell} \log_{2} P^{S}(x)
</code>
</p>

<p>by using <code>'output=logloss'</code>.
The returned value is the average log-loss of each state in the sequence, which allows to compare the prediction for sequences of unequal lengths. The average log-loss can be interpreted as a residual, that is the distance between the prediction of a sequence by a PST <code class="reqn">S</code> and the perfect prediction  <code class="reqn">P(x)=1</code> yielding <code class="reqn">logloss(P^{S},x)=0</code>. The lower the value of <code class="reqn">logloss(P^{S},s)</code> the better the sequence is predicted. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>Either a vector of sequence probabilities (decomp=FALSE) or a matrix (if decomp=FALSE) containing for each sequence (row) the probability of each state in columns.   
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016) Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)

S1 &lt;- pstree(s1, L=3, nmin=2, ymin=0.001)
S1 &lt;- prune(S1, gain="G1", C=1.20, delete=FALSE)

predict(S1, s1, decomp=TRUE)
predict(S1, s1)
</code></pre>

<hr>
<h2 id='print'> Print method for objects of class <code>PSTf</code> and <code>PSTr</code> </h2><span id='topic+print'></span><span id='topic+print+2CPSTf-method'></span><span id='topic+print+2CPSTr-method'></span>

<h3>Description</h3>

<p>Display a probabilistic suffix tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTr'
print(x, max.level = NULL, digits = 1, give.attr = FALSE, 
    nest.lev = 0, indent.str = "", stem = "--")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>A PST, that is an object of class <code>PSTf</code> as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
<tr><td><code id="print_+3A_max.level">max.level</code></td>
<td>
<p> integer. The maximal depth for the display of the tree.
</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p> integer specifying the precision for printing.
</p>
</td></tr>
<tr><td><code id="print_+3A_give.attr">give.attr</code></td>
<td>
<p> logical. If <code>TRUE</code> the attributes of each node (an object of class <code>PSTr</code>) are displayed.
</p>
</td></tr>
<tr><td><code id="print_+3A_nest.lev">nest.lev</code></td>
<td>
<p> integer. Parameter used internally by the function. 
</p>
</td></tr>
<tr><td><code id="print_+3A_indent.str">indent.str</code></td>
<td>
<p> character. String used to indent each line when displaying the tree. Default to &rdquo;.
</p>
</td></tr>
<tr><td><code id="print_+3A_stem">stem</code></td>
<td>
<p> character. String used to display the stems. Default to '&ndash;'.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd>
</dd>
<dt><code>signature(x = "PSTf")</code></dt><dd>
</dd>
<dt><code>signature(x = "PSTr")</code></dt><dd>
</dd>
</dl>

<hr>
<h2 id='prune'>
Prune a probabilistic suffix tree
</h2><span id='topic+prune'></span><span id='topic+prune+2CPSTf-method'></span>

<h3>Description</h3>

<p>Prune a PST, using either a gain function, a maximal depth or a list of nodes to keep or remove. Optionally, nodes are not removed from the tree but tagged as deleted, helping to visualize the pruning process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
prune(object, nmin, L, gain, C, keep, drop, state, delete = TRUE, lik =TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="prune_+3A_nmin">nmin</code></td>
<td>

<p>integer. All strings having counts less than nmin are removed.
</p>
</td></tr>
<tr><td><code id="prune_+3A_l">L</code></td>
<td>

<p>integer. If specified the the tree is cut at depth L., that is all nodes with depth &gt; L are removed.
</p>
</td></tr>
<tr><td><code id="prune_+3A_gain">gain</code></td>
<td>

<p>character. Function for measuring information gain. See <code>details</code>.
</p>
</td></tr>
<tr><td><code id="prune_+3A_c">C</code></td>
<td>

<p>numeric. Cutoff value to use with the gain function
</p>
</td></tr>
<tr><td><code id="prune_+3A_keep">keep</code></td>
<td>

<p>character. A vector of character strings containing the names of the nodes to keep in the tree. All nodes that are not a suffix of contexts in keep are removed from the tree.
</p>
</td></tr>
<tr><td><code id="prune_+3A_drop">drop</code></td>
<td>

<p>character. A vector of character strings containing the names of the nodes to remove from the tree. All nodes that are a suffix of contexts in drop are removed from the tree as weel.
</p>
</td></tr>
<tr><td><code id="prune_+3A_state">state</code></td>
<td>

<p>character. All nodes corresponding to contexts which include <code>state</code> are pruned.	
</p>
</td></tr>
<tr><td><code id="prune_+3A_delete">delete</code></td>
<td>

<p>Logical. If FALSE, the pruned nodes are not removed from the tree but tagged as pruned=FALSE, so that when plotting the pruned tree these nodes wil appear surrounded with red (can be set to another color) lines.
</p>
</td></tr>
<tr><td><code id="prune_+3A_lik">lik</code></td>
<td>
<p>Logical. If TRUE, the log-likelihood of the pruned model, i.e. the likelihood of the training sequences given the model, is computed and stored in the 'logLik' slot of the PST. Setting to FALSE will spare the time required to compute the likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial tree returned by the <code><a href="#topic+pstree">pstree</a></code> function may yield an overly complex model containing all contexts of maximal length <code class="reqn">L</code> and frequency <code class="reqn">N(c) \geq nmin</code> found in the learning sample. The pruning stage potentially reduces the number of nodes in the tree, and thus the model complexity. It compares the conditional probabilities associated to a node labelled by a subsequence <code class="reqn">c=c_{1},c_{2}, \ldots, c_{k}</code> to the conditional probabilities of its parent node labelled by the longest suffix of <code class="reqn">c</code>, <code class="reqn">suf(c)=c_{2}, \ldots, c_{k}</code>. The general idea is to remove a node if it does not contribute additional information with respect to its parent in predicting the next symbol, that is if <code class="reqn">\hat{P}(\sigma | c)</code> is not <em>significantly</em> different from <code class="reqn">\hat{P}(\sigma | suf(c))</code> for all <code class="reqn">\sigma \in A</code>. 
</p>
<p>The pruning procedure starts from the terminal nodes and is applied recursively until all terminal nodes remaining in the tree represent an information gain relative to their parent. 
A gain function,  whose outcome will determine the pruning decision, is used to compare the two probability distributions. The gain function is driven by a cut-off, and different values of this parameter will yield more or less complex trees. A method for selecting the pruning cut-off is described in the <code><a href="#topic+tune">tune</a></code> help page.
</p>
<p>A first implemented gain function, which is used by the <em>Learn-PSA</em> algorithm, is based on the ratio between <code class="reqn">\hat{P}(\sigma|c)</code> and <code class="reqn">hat{P}(\sigma|suf(c))</code> for each <code class="reqn">\sigma \in A</code>. A node represents an information gain if for any symbol <code class="reqn">\sigma \in A</code> the ratio is greater than the cut-off <code class="reqn">C</code> or lower than <code class="reqn">1/C</code>, that is if
</p>
<p style="text-align: center;"><code class="reqn">
G_{1}(c)=\sum_{\sigma \in A} 1 \left[ \frac{\hat{P}(\sigma |c)}{\hat{P}(\sigma | suf(c))} \geq C \; \cup \; 
\frac{\hat{P}(\sigma |c)}{\hat{P}(\sigma | suf(c))} \leq \frac{1}{C} \right] \geq 1
</code>
</p>

<p>where <code class="reqn">C</code> is a user defined cut-off value. Nodes that do not satisfy the above condition are pruned. For <code class="reqn">C=1</code> no node is removed since even a node having a next probability distribution similar to the one of its parent does not satisfy the pruning condition.
</p>
<p>The <em>context</em> algorithm uses another gain function, namely
</p>
<p style="text-align: center;"><code class="reqn">
G_{2}(c)=\sum_{\sigma \in A} \hat{P}(\sigma|c)\log \left( \frac{\hat{P}(\sigma|c)}{\hat{P}(\sigma|suf(c))} \right) N(c) &gt; C
</code>
</p>

<p>where <code class="reqn">c</code> is the context labelling the terminal node, <code class="reqn">N(c)</code> is the number of occurrences of <code class="reqn">c</code> in the data. The cutoff <code class="reqn">C</code> is specified on the scale of <code class="reqn">\chi^{2}</code>-quantiles <cite>Maechler-2004</cite>
</p>
<p style="text-align: center;"><code class="reqn">
C=C(\alpha)=\frac{1}{2}qchisq(1-\alpha,v), v=|A|-1
</code>
</p>

<p>where <code class="reqn">qchisq(p=1-\alpha,v)</code> is the quantile function of a <code class="reqn">\chi^{2}</code> distribution with <code class="reqn">v</code> degrees of freedom. The cutoff <code class="reqn">C</code> is a threshold for the difference of deviances between a tree <code class="reqn">S^{1}</code> and its subtree <code class="reqn">S^{2}</code> obtained by pruning the terminal node <code class="reqn">c</code>. Typical values for <code class="reqn">\alpha</code> are <code class="reqn">5\%</code> and <code class="reqn">1\%</code>, yielding <code class="reqn">p=0.95</code> and <code class="reqn">p=0.99</code> respectively. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>A probabilistic suffix tree, i.e., an object of class <code><a href="#topic+PSTf-class">PSTf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Bejerano, G. &amp; Yona, G. (2001). Variations on probabilistic suffix trees: statistical modeling and prediction of protein families. <em>Bioinformatics</em>, 17, pp. 23-43.
</p>
<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>
<p>Maechler, M. &amp; Buehlmann, P. (2004). Variable Length Markov Chains: Methodology, Computing, and Software <em>Journal of Computational and Graphical Statistics</em>, 13, pp. 435-455.
</p>
<p>Ron, D.; Singer, Y. &amp; Tishby, N. (1996). The power of amnesia: Learning probabilistic automata with variable memory length <em>Machine Learning</em>, 25, pp. 117-149.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tune">tune</a></code>, <code><a href="#topic+ppplot">ppplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1.seq &lt;- seqdef(s1)
S1 &lt;- pstree(s1.seq, L=3, nmin=2, ymin=0.001)

## --
S1.p1 &lt;- prune(S1, gain="G1", C=1.20, delete=FALSE)
summary(S1.p1)
plot(S1.p1)

## --
C95 &lt;- qchisq(0.95,1)/2
S1.p2 &lt;- prune(S1, gain="G2", C=C95, delete=FALSE)
plot(S1.p2)
</code></pre>

<hr>
<h2 id='PSTf-class'>Flat representation of a probabilistic suffix tree</h2><span id='topic+PSTf-class'></span>

<h3>Description</h3>

<p>The class <code>"PSTf"</code> is the flat representation of a probabilistic suffix tree (PST) storing a variable length Markov chain model. The flat representation is a list where each element corresponds to a given depth. It is the prefered representation and is used by all functions for model fitting and sequence analysis with PST. The nested representation <code>"<a href="#topic+PSTr-class">PSTr</a>"</code> is used only for printing and plotting PSTs. 
</p>


<h3>Objects from the Class</h3>

<p>Objects of class <code>"PSTf"</code> are returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> and <code><a href="#topic+tune">tune</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>, a list where each element corresponds to one level of the tree and is itself a list of nodes, i.e., objects of class <code>"<a href="#topic+PSTr-class">PSTr</a>"</code>.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"stslist"</code>. The learning sample to which the PST is fitted, i.e., a sequence object created with the <code><a href="TraMineR.html#topic+TraMineR">seqdef</a></code> function.</p>
</dd>
<dt><code>cdata</code>:</dt><dd><p>Object of class <code>"stslist"</code>  </p>
</dd>
<dt><code>alphabet</code>:</dt><dd><p>Object of class <code>"character"</code>. Alphabet on which the sequences, and the PST are built.</p>
</dd>
<dt><code>labels</code>:</dt><dd><p>Object of class <code>"character"</code> containing the long state labels.</p>
</dd>
<dt><code>cpal</code>:</dt><dd><p>Object of class <code>"character"</code>. Color palette used to represent each state of the alphabet.</p>
</dd>
<dt><code>segmented</code>:</dt><dd><p>Object of class <code>"logical"</code> indicating whether the tree is segmented. See <code><a href="#topic+pstree">pstree</a></code>.</p>
</dd>
<dt><code>group</code>:</dt><dd><p>Object of class <code>"factor"</code> containing the group membership for each sequence in <code>data</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>.</p>
</dd>
<dt><code>logLik</code>:</dt><dd><p>Object of class <code>"numeric"</code>, containing the log-likelihood of the VLMC model represented by the PST.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>cmine</dt><dd><p><code>signature(object = "PSTf")</code>: context mining, see <code><a href="#topic+cmine+2CPSTf-method">cmine,PSTf-method</a></code>.</p>
</dd>
<dt>cplot</dt><dd><p><code>signature(object = "PSTf")</code>: plot single nodes of a PST, see <code><a href="#topic+cplot+2CPSTf-method">cplot,PSTf-method</a></code>.</p>
</dd>
<dt>generate</dt><dd><p><code>signature(object = "PSTf")</code>: generate artificial sequences, see <code><a href="#topic+generate+2CPSTf-method">generate,PSTf-method</a></code>. </p>
</dd>
<dt>impute</dt><dd><p><code>signature(object = "PSTf", data = "stslist")</code>: impute missing values in sequence data, see<code><a href="#topic+impute+2CPSTf+2Cstslist-method">impute,PSTf,stslist-method</a></code>.</p>
</dd>
<dt>logLik</dt><dd><p><code>signature(object = "PSTf")</code>: extract log-likelihood of the VLMC model represented by a PST, see <code><a href="#topic+logLik+2CPSTf-method">logLik,PSTf-method</a></code>.</p>
</dd>
<dt>nobs</dt><dd><p><code>signature(object = "PSTf")</code>: number of observations (symbols) in the learning sample to which a VLMC model is fitted, see <code><a href="#topic+nobs+2CPSTf-method">nobs,PSTf-method</a></code>.</p>
</dd>
<dt>nodenames</dt><dd><p><code>signature(object = "PSTf")</code>: retrieve the node labels of a PST, see see <code><a href="#topic+nodenames+2CPSTf-method">nodenames,PSTf-method</a></code>. </p>
</dd>
<dt>pdist</dt><dd><p><code>signature(x = "PSTf", y = "PSTf")</code>: compute probabilistic divergence between two PSTs, see <code><a href="#topic+pdist+2CPSTf+2CPSTf-method">pdist,PSTf,PSTf-method</a></code>. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "PSTf", y = "ANY")</code>: plot a PST, see <code><a href="#topic+plot+2CPSTf+2CANY-method">plot,PSTf,ANY-method</a></code>.</p>
</dd>
<dt>pmine</dt><dd><p><code>signature(object = "PSTf", data = "stslist")</code>: pattern mining, see see <code><a href="#topic+pmine+2CPSTf+2Cstslist-method">pmine,PSTf,stslist-method</a></code>.</p>
</dd>
<dt>ppplot</dt><dd><p><code>signature(object = "PSTf")</code>: plotting a branch of a PST, see <code><a href="#topic+ppplot+2CPSTf-method">ppplot,PSTf-method</a></code>.</p>
</dd>
<dt>pqplot</dt><dd><p><code>signature(object = "PSTf", data = "stslist")</code>: plot the predicted probability of each state in a sequence, see <code><a href="#topic+pqplot+2CPSTf+2Cstslist-method">pqplot,PSTf,stslist-method</a></code>. </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "PSTf")</code>: predict the likelihood of sequences, see <code><a href="#topic+predict+2CPSTf-method">predict,PSTf-method</a></code>. </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "PSTf")</code>: print a PST, see <code><a href="#topic+print+2CPSTf-method">print,PSTf-method</a></code>.</p>
</dd>
<dt>prune</dt><dd><p><code>signature(object = "PSTf")</code>: prune a PST, see <code><a href="#topic+prune+2CPSTf-method">prune,PSTf-method</a></code>. </p>
</dd>
<dt>query</dt><dd><p><code>signature(object = "PSTf")</code>: retrieve counts or next symbol probability distribution from a node in a Probabilistic Suffix Tree, see <code><a href="#topic+query+2CPSTf-method">query,PSTf-method</a></code>. </p>
</dd>
<dt>subtree</dt><dd><p><code>signature(object = "PSTf")</code>: extract a subtree from a segmented PST, see <code><a href="#topic+subtree+2CPSTf-method">subtree,PSTf-method</a></code>. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "PSTf")</code>: see <code><a href="#topic+summary+2CPSTf-method">summary,PSTf-method</a></code>. </p>
</dd>
<dt>tune</dt><dd><p><code>signature(object = "PSTf")</code>: AIC, AICc and BIC based model selection, see <code><a href="#topic+tune+2CPSTf-method">tune,PSTf-method</a></code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSTr-class">PSTr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PSTf")
</code></pre>

<hr>
<h2 id='PSTr-class'>Nested representation of a probabilistic suffix tree</h2><span id='topic+PSTr-class'></span><span id='topic++5B+5B+2CPSTr-method'></span>

<h3>Description</h3>

<p>An object of class <code>"PSTr"</code> is a node of a probabilistic suffix tree (PST). The slot <code>prob</code> contains one or several probability distributions (if the PST is segmented) and the slot <code>counts</code> contains the empirical - possibly weighted - counts from which the probabilities are computed. The slot <code>leaf</code> indicates whether the node (segment) is a terminal node (segment).
The 'flat' representation of a PST is an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code>), that is a list that contains one element for each level of the tree. Each element of the list is itself a list whose elements are nodes, that is objects of class <code>PSTr</code>.
The 'nested' representation of a probabilistic suffix tree (PST) is a nested list whose elements are children nodes of class <code>"PSTr"</code>. This representation is used for printing and plotting PST, in which case the flat representation of a PST, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> is turned into an object of class <code>"PSTr"</code> by using the <code>as</code> function.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created when calling the <code><a href="#topic+pstree">pstree</a></code> function. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>. In the nested representation of a PST, the elements of the list are the children nodes. Otherwise the list is empty.</p>
</dd>
<dt><code>alphabet</code>:</dt><dd><p>Object of class <code>"character"</code>. Alphabet on which the sequences, and the PST are built. This slot is non-empty only for the root node of the nested representation of a PST. </p>
</dd>
<dt><code>labels</code>:</dt><dd><p>Object of class <code>"character"</code> containing the long state labels. This slot is non-empty only for the root node of the nested representation of a PST.</p>
</dd>
<dt><code>cpal</code>:</dt><dd><p>Object of class <code>"character"</code>. Color palette used to represent each state of the alphabet. This slot is non-empty only for the root node of the nested representation of a PST.</p>
</dd>
<dt><code>index</code>:</dt><dd><p>Object of class <code>"matrix"</code>. When the PST is segmented, indicates the id of the segment corresponding to each group.</p>
</dd>
<dt><code>counts</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The counts to which the probability distributions are computed. </p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The number of occurrences of the context in the learning sample, see <code><a href="#topic+cprob">cprob</a></code>.</p>
</dd>
<dt><code>prob</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The probability distributions computed from the counts. </p>
</dd>
<dt><code>path</code>:</dt><dd><p>Object of class <code>"character"</code>. The node label, i.e. the context which is the  path from the node to the root node of the tree. </p>
</dd>
<dt><code>order</code>:</dt><dd><p>Object of class <code>"integer"</code>. The depth of the node in the tree, i.e., the order of the probability distribution(s) stored in the node. </p>
</dd>
<dt><code>leaf</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Indicates whether the node (segment) is a terminal node (segment).</p>
</dd>
<dt><code>pruned</code>:</dt><dd><p>Object of class <code>"matrix"</code>. If the PST was pruned with the <code>delete=FALSE</code> option, indicates whether the node (segment) is actually pruned. See <code><a href="#topic+prune">prune</a></code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>[[</dt><dd><p><code>signature(x = "PSTr")</code>: extract sub-branches of a nested representation of a PST.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "PSTr", y = "ANY")</code>: plot a PST, see <code><a href="#topic+plot+2CPSTr+2CANY-method">plot,PSTr,ANY-method</a></code>.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "PSTr")</code>: print a PST, see <code><a href="#topic+print+2CPSTr-method">print,PSTr-method</a></code>.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "PSTr")</code>: see <code><a href="#topic+summary+2CPSTr-method">summary,PSTr-method</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PSTf-class">PSTf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("PSTr")
</code></pre>

<hr>
<h2 id='pstree'>
Build a probabilistic suffix tree
</h2><span id='topic+pstree'></span><span id='topic+pstree+2Cstslist-method'></span>

<h3>Description</h3>

<p>Build a probabilistic suffix tree that stores a variable length Markov chain (VLMC) model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stslist'
pstree(object, group, L, cdata=NULL, stationary=TRUE, 
	nmin = 1, ymin=NULL, weighted = TRUE, with.missing = FALSE, lik = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pstree_+3A_object">object</code></td>
<td>

<p>a sequence object, i.e., an object of class <code>'stslist'</code> as created by TraMineR <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function.
</p>
</td></tr>
<tr><td><code id="pstree_+3A_group">group</code></td>
<td>

<p>a vector giving the group membership for each observation in x. If specified, a segmented PST is produced containing one PST for each group. 
</p>
</td></tr>
<tr><td><code id="pstree_+3A_cdata">cdata</code></td>
<td>
 
<p>Not implemented yet.
</p>
</td></tr>
<tr><td><code id="pstree_+3A_stationary">stationary</code></td>
<td>
 
<p>Not implemented yet.
</p>
</td></tr>
<tr><td><code id="pstree_+3A_l">L</code></td>
<td>

<p>Integer. Maximal depth of the PST. Default to maximum length of the sequence(s) in object minus 1.
</p>
</td></tr>
<tr><td><code id="pstree_+3A_nmin">nmin</code></td>
<td>

<p>Integer. Minimum number of occurences of a string to add it in the tree 
</p>
</td></tr>
<tr><td><code id="pstree_+3A_ymin">ymin</code></td>
<td>

<p>Numeric. Smoothing parameter for conditional probabilities, assuring that no symbol, and hence no sequence, is predicted to have a null probability. The parameter $ymin$ sets a lower bound for a symbol's probability.  
</p>
</td></tr>
<tr><td><code id="pstree_+3A_weighted">weighted</code></td>
<td>

<p>Logical. If TRUE, weights attached to the sequence object are used in the estimation of probabilities.
</p>
</td></tr>
<tr><td><code id="pstree_+3A_with.missing">with.missing</code></td>
<td>

<p>Logical. If TRUE, the missing state is added to the alphabet
</p>
</td></tr>
<tr><td><code id="pstree_+3A_lik">lik</code></td>
<td>
<p>Logical. If TRUE, the log-likelihood of the model, i.e. the likelihood of the training sequences given the model, is computed and stored in the 'logLik' slot of the PST. Setting to FALSE will spare the time required to compute the likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A probabilistic suffix tree (PST) is built from a learning sample of <code class="reqn">n, \; n \geq 1</code> sequences by successively adding nodes labelled with subsequences (contexts) <code class="reqn">c</code> of length <code class="reqn">L,  \; 0 \leq L \leq L_{max}</code> found in the data. When the value <code class="reqn">L_{max}</code> is not defined by the user it is set to its theorectical maximum <code class="reqn">\ell-1</code> where <code class="reqn">\ell</code> is the maximum sequence length in the learning sample. The <code>nmin</code> argument specifies the minimum frequency of a subsequence required to add it to te tree.<br />
Each node of the tree is labelled with a context <code class="reqn">c</code> and stores the next symbol empirical probability distribution <code class="reqn">\hat{P}(\sigma|c), \; \sigma \in A</code>, where <code class="reqn">A</code> is an alphabet of finite size. The root node labelled with the empty string <code class="reqn">e</code> stores the <code class="reqn">0th</code> order probability <code class="reqn">\hat{P}(\sigma), \; \sigma \in A</code> of oberving each symbol of the alphabet in the whole learning sample.<br />
The building algorithm calls the <code><a href="#topic+cprob">cprob</a></code> function which returns the empirical next symbol counts observed after each context <code class="reqn">c</code> and computes the corresponding empirical probability distribution. Each node in the tree is connected to its longest suffix, where the longest suffix of a string <code class="reqn">c=c_{1},c_{2}, \ldots, c_{k}</code> of length <code class="reqn">k</code> is <code class="reqn">suffix(c)=c_{2}, \ldots, c_{k}</code>.<br />
Once an initial PST is built it can be pruned to reduce its complexity by removing nodes that do not provide significant information (see <code><a href="#topic+prune">prune</a></code>). A model selection procedure based on information criteria is also available (see <code><a href="#topic+tune">tune</a></code>). For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Bejerano, G. &amp; Yona, G. (2001) Variations on probabilistic suffix trees: statistical modeling and prediction of protein families. <em>Bioinformatics</em> 17, 23-43.
</p>
<p>Gabadinho, A. &amp; Ritschard, G. (2016) Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em> <b>72</b>(3), 1-39.
</p>
<p>Maechler, M. &amp; Buehlmann, P. (2004) Variable Length Markov Chains: Methodology, Computing, and Software. <em>Journal of Computational and Graphical Statistics</em> 13, pp. 435-455.
</p>
<p>Ron, D.; Singer, Y. &amp; Tishby, N. (1996) The power of amnesia: Learning probabilistic automata with variable memory length. <em>Machine Learning</em> 25, 117-149.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune">prune</a></code>, <code><a href="#topic+tune">tune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build a PST on one single sequence
data(s1)
s1.seq &lt;- seqdef(s1)
s1.seq
S1 &lt;- pstree(s1.seq, L = 3)
print(S1, digits = 3)
S1
</code></pre>

<hr>
<h2 id='query'>
Retrieve counts or next symbol probability distribution
</h2><span id='topic+query'></span><span id='topic+query+2CPSTf-method'></span><span id='topic+round+2Ccprobd-method'></span>

<h3>Description</h3>

<p>Retrieve counts or next symbol probability distribution from a node of a probabilistic suffix tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
query(object, context, state, output = "prob", exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_object">object</code></td>
<td>

<p>A probabilistic suffix tree, i.e an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code>) as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="query_+3A_context">context</code></td>
<td>

<p>Character. The string labelling the node to retrieve. States must be separated by '-' as for example in 'a-a-b'. If the node labelled with this string does not exist in the tree, the node labelled with the longest suffix is searched for, and so on until an existing node is  found.
</p>
</td></tr>
<tr><td><code id="query_+3A_state">state</code></td>
<td>

<p>character. If specified the probability of the specified state is returned instead of the whole distribution.
</p>
</td></tr>
<tr><td><code id="query_+3A_output">output</code></td>
<td>

<p>character. If output=&quot;prob&quot; the probability distribution (or a single symbol distribution if state is specified) is returned. If output=&quot;counts&quot; the counts on which the probability distribution is calculated are returned. If output=&quot;all&quot; the node itself is returned, that is an object of class PSTr.
</p>
</td></tr>
<tr><td><code id="query_+3A_exact">exact</code></td>
<td>

<p>logical. If TRUE, the information is returned only if the node labelled with context is present in the tree. That is, the longest suffix of context is not searched for if context is not in the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PST is searched for the node labelled with <code>context</code>. If <code>exact=FALSE</code>, when the node does not exist the PST is searched for the longest suffix of <code>context</code>, and so on until a node corresponding to a suffix of <code>context</code> is found or the root node is reached. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>An object of class <code>cprobd</code>, with available <code>round</code> method.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplot">cplot</a></code>, <code><a href="#topic+ppplot">ppplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1 &lt;- seqdef(s1)
S1 &lt;- pstree(s1, L=3)
## Retrieving from the node labelled 'a-a-a'
query(S1, "a-a-a")

## The node 'a-b-b-a' is not presetnin the tree, and the next symbol
## probability is retrieved from the node labelled 'b-b-a' (the longest
## suffix
query(S1, "a-b-b-a")
</code></pre>

<hr>
<h2 id='s1'>
Example sequence data set
</h2><span id='topic+s1'></span>

<h3>Description</h3>

<p>Example data set containing one single sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(s1)</code></pre>


<h3>Format</h3>

<p>A character string representing a sequence of 27 symbols separated with '-'.
</p>


<h3>Details</h3>

<p>A sequence object can be created with the dedicated <code>TraMineR</code> <code><a href="TraMineR.html#topic+seqdef">seqdef</a></code> function. State sequence objects are the main argument for the <code><a href="#topic+pstree">pstree</a></code> method that creates probabilistic suffix trees. See example below. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loading the data
data(s1)

## Creating a state sequence object
s1.seq &lt;- seqdef(s1)

## Building and plotting a PST
S1 &lt;- pstree(s1.seq, L = 3)
plot(S1)
</code></pre>

<hr>
<h2 id='SRH'>
Longitudinal data on self rated health
</h2><span id='topic+SRH'></span><span id='topic+SRH.seq'></span>

<h3>Description</h3>

<p>Longitudinal data on self rated health from waves 1-11 of the Swiss household panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SRH)
</code></pre>


<h3>Format</h3>

<p><code>SRH</code> is a data frame with 2612 observations on the following 15 variables.
</p>

<dl>
<dt><code>idpers</code></dt><dd><p>personal identification number</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>man</code> <code>woman</code></p>
</dd>
<dt><code>birthy</code></dt><dd><p>birth year of the respondent</p>
</dd>
<dt><code>wp09lp1s</code></dt><dd><p>longitudinal weight</p>
</dd>
<dt><code>p99c01</code> ... <code>p09c01</code></dt><dd><p>factors with levels:<br />
<code> very well; well; so, so (average); not very well; not well at all</code>
</p>
</dd>
</dl>

<p><code>SRH.seq</code> is a <code>TraMineR</code> sequence object created from the <code>SRH</code> data frame using the code in <code>example</code>. States are coded as follows:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>G1</code> </td><td style="text-align: left;"> (very well) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>G2</code> </td><td style="text-align: left;"> (well)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>M</code>  </td><td style="text-align: left;"> (so, so (average)) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>B2</code> </td><td style="text-align: left;"> (not very well) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>B1</code> </td><td style="text-align: left;"> (not well at all) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Respondant's self rated health is collected at each yearly wave of the SHP with the following question: <em>How do you feel right now?</em>. Possible answers are: very well; well; so, so (average), not very well and not well at all. The sequences are made of an individual's responses over 11 yearly waves of the SHP, starting with wave 1 in 1999. Variable p99c01 contains the self rated health at wave 1, p00c01 contains the self rated health at wave 2, etc... Note that sequences may contain missing values due to wave or item non response. 
</p>


<h3>Source</h3>

<p>Swiss Household Panel: <a href="https://forscenter.ch/projects/swiss-household-panel/">https://forscenter.ch/projects/swiss-household-panel/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Preparing a sequence object with the SRH data set
data(SRH)

## Long state labels
state.list &lt;- levels(SRH$p99c01)

## Sequential color palette
mycol5 &lt;- rev(brewer.pal(5, "RdYlGn"))

## Creating the sequence object
SRH.seq &lt;- seqdef(SRH, 5:15, alphabet=state.list, 
	states=c("G1", "G2", "M", "B2", "B1"), labels=state.list, 
	weights=SRH$wp09lp1s, right=NA, cpal=mycol5)
names(SRH.seq) &lt;- 1999:2009
</code></pre>

<hr>
<h2 id='subtree'> Extract a subtree from a segmented PST </h2><span id='topic+subtree'></span><span id='topic+subtree+2CPSTf-method'></span>

<h3>Description</h3>

<p>Extract a subtree from a segmented PST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
subtree(object, group=NULL, position=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtree_+3A_object">object</code></td>
<td>

<p>A segmented probabilistic suffix tree, i.e an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code>) as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="subtree_+3A_group">group</code></td>
<td>
 
<p>integer. Segment of the PST
</p>
</td></tr>
<tr><td><code id="subtree_+3A_position">position</code></td>
<td>
 
<p>Not implemented yet. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also <cite>Gabadinho 2016</cite>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## activity calendar for year 2000
## from the Swiss Household Panel
## see ?actcal
data(actcal)

## selecting individuals aged 20 to 59
actcal &lt;- actcal[actcal$age00&gt;=20 &amp; actcal$age00 &lt;60,]

## defining a sequence object
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## building a PST segmented by age group
gage10 &lt;- cut(actcal$age00, c(20,30,40,50,60), right=FALSE,
	labels=c("20-29","30-39", "40-49", "50-59"))

actcal.pstg &lt;- pstree(actcal.seq, nmin=2, ymin=0.001, group=gage10)

## pruning
C99 &lt;- qchisq(0.99,4-1)/2
actcal.pstg.opt &lt;- prune(actcal.pstg, gain="G2", C=C99)

## extracting PST for age group 20-39 and 30-39
g1.pst &lt;- subtree(actcal.pstg.opt, group=1)
g2.pst &lt;- subtree(actcal.pstg.opt, group=2)

## plotting the two PST
par(mfrow=c(1,2))
plot(g1.pst, withlegend=FALSE, max.level=4, main="20-29")
plot(g2.pst, withlegend=FALSE, max.level=4, main="30-39")

</code></pre>

<hr>
<h2 id='summary-methods'> Summary of variable length Markov chain model </h2><span id='topic+summary+2CPSTf-method'></span><span id='topic+summary+2CPSTr-method'></span>

<h3>Description</h3>

<p>Summary of a variable length Markov chain model stored in a probabilistic suffix tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
summary(object, max.level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>

<p>A PST, that is an object of class <code>PSTf</code> as returned by the <code><a href="#topic+pstree">pstree</a></code> or <code><a href="#topic+prune">prune</a></code> method.
</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_max.level">max.level</code></td>
<td>
<p> integer. If specified, the summary is computed for the <code>max.level</code> levels of the tree only. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>PST.summary</code> with following attributes:
</p>

<dl>
<dt>alphabet</dt><dd><p> list of symbols in the alphabet </p>
</dd> 
<dt>labels</dt><dd><p> long labels for symbols in the alphabet </p>
</dd>
<dt>cpal</dt><dd><p> color palette used to represent each state of the alphabet </p>
</dd>
<dt>ns</dt><dd><p>number of symbols in the data to which the model was fitted </p>
</dd>
<dt>depth</dt><dd><p> maximum depth (order) of the tree </p>
</dd>
<dt>nodes</dt><dd><p> number of internal nodes in the PST </p>
</dd>	
<dt>leaves</dt><dd><p> number of leaves in the PST </p>
</dd>
<dt>freepar</dt><dd><p> number of free parameters in the mode, i.e., (nodes+leaves)*(|A|-1) where |A| is the size of the alphabet </p>
</dd>
</dl>

<p>A <code>show</code> method is available for displaying objects of class <code>PST.summary</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(s1)
s1.seq &lt;- seqdef(s1)
S1 &lt;- pstree(s1.seq, L=3)
summary(S1)
summary(S1, max.level=2)
</code></pre>

<hr>
<h2 id='tune'>
AIC, AICc or BIC based model selection 
</h2><span id='topic+tune'></span><span id='topic+tune+2CPSTf-method'></span>

<h3>Description</h3>

<p>Prune a probabilistic suffix tree with a series of cut-offs and select the model having the lowest value of the selected information criterion. Available information criterion are Akaike information criterion (AIC), AIC with a correction for finite sample sizes (AICc) and Bayesian information criterion (BIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PSTf'
tune(object, gain="G2", C, criterion = "AIC", output = "PST")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_+3A_object">object</code></td>
<td>

<p>a probabilistic suffix tree, i.e., an object of class <code>"<a href="#topic+PSTf-class">PSTf</a>"</code> as returned by the <code><a href="#topic+pstree">pstree</a></code>, <code><a href="#topic+prune">prune</a></code> or <code><a href="#topic+tune">tune</a></code> function.
</p>
</td></tr>
<tr><td><code id="tune_+3A_gain">gain</code></td>
<td>
 
<p>character. The gain function used for pruning decisions. See <code><a href="#topic+prune">prune</a></code> for details.
</p>
</td></tr>
<tr><td><code id="tune_+3A_c">C</code></td>
<td>
 
<p>numeric. A vector of cutoff values. See <code><a href="#topic+prune">prune</a></code> for details.
</p>
</td></tr>
<tr><td><code id="tune_+3A_criterion">criterion</code></td>
<td>

<p>The criterion used to select the model, either AIC, AICc or BIC. AICc should be used when the ratio between the number of observations and the number of estimated parameters is low, which is often the case with VLMC models. <cite>Burnham et al 2004</cite> suggest to use AICc instead of AIC when the ratio is lower than 40.
</p>
</td></tr>
<tr><td><code id="tune_+3A_output">output</code></td>
<td>

<p>If <code>output='PST'</code> the PST (an object of class <code>"<a href="#topic+PSTr-class">PSTr</a>"</code>) having the lowest AIC, AICc or BIC value. If <code>output='stats'</code>, a table with the statistics for each model obtained by pruning <code>object</code> with the cut-offs in <code>C</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tune</code> function selects among a series of PST pruned with different values of the <code class="reqn">C</code> cutoff the model having the lowest <code class="reqn">AIC</code> or <code class="reqn">AIC_{c}</code> value. The function can return either the selected PST or a data frame containing the statistics for each model. For more details, see <cite>Gabadinho 2016</cite>.
</p>


<h3>Value</h3>

<p>If <code>output="PST"</code> a PST that is an object of class <code>PSTf</code>. If <code>output="stats"</code> a matrix with the results of the tuning procedure.<br /> 
The selected model is tagged with <code>***</code>, while models with <code class="reqn">IC &lt; min(IC)+2</code> are tagged with <code>**</code>, and models with <code class="reqn">IC &lt; min(IC)+10</code> are tagged with <code>**</code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Gabadinho
</p>


<h3>References</h3>

<p>Burnham, K. P. &amp; Anderson, D. R. (2004). Multimodel Inference <em>Sociological Methods &amp; Research</em>, 33, pp. 261-304.
</p>
<p>Gabadinho, A. &amp; Ritschard, G. (2016). Analyzing State Sequences with Probabilistic Suffix Trees: The PST R Package. <em>Journal of Statistical Software</em>, <b>72</b>(3), pp. 1-39.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prune">prune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## activity calendar for year 2000
## from the Swiss Household Panel
## see ?actcal
data(actcal)

## selecting individuals aged 20 to 59
actcal &lt;- actcal[actcal$age00&gt;=20 &amp; actcal$age00 &lt;60,]

## defining a sequence object
actcal.lab &lt;- c("&gt; 37 hours", "19-36 hours", "1-18 hours", "no work")
actcal.seq &lt;- seqdef(actcal,13:24,labels=actcal.lab)

## building a PST
actcal.pst &lt;- pstree(actcal.seq, nmin=2, ymin=0.001)

## Cut-offs for 5% and 1% (see ?prune)
C95 &lt;- qchisq(0.95,4-1)/2
C99 &lt;- qchisq(0.99,4-1)/2

## selecting the optimal PST using AIC criterion
actcal.pst.opt &lt;- tune(actcal.pst, gain="G2", C=c(C95,C99))

## plotting the tree
plot(actcal.pst.opt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
