<!DOCTYPE html><html lang="en"><head><title>Help for package IncDTW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IncDTW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IncDTW-package'>
<p>Incremental Dynamic Time Warping</p></a></li>
<li><a href='#dba'>
<p>Dynamic Time Warping Barycenter Averaging</p></a></li>
<li><a href='#dec_dm'>
<p>Decrement the Warping Path</p></a></li>
<li><a href='#drink_glass'>
<p>Accelerometer: drink a glass, walk, brush teeth.</p></a></li>
<li><a href='#dtw'>
<p>Dynamic Time Warping</p></a></li>
<li><a href='#dtw_dismat'>
<p>DTW Distance Matrix/ Distance Vector</p></a></li>
<li><a href='#dtw_partial'>
<p>Partial Dynamic Time Warping</p></a></li>
<li><a href='#dtw2vec'>
<p>Fast vector-based Dynamic Time Warping</p></a></li>
<li><a href='#find_peaks'><p>find_peaks</p></a></li>
<li><a href='#idtw'>
<p>Incremental DTW</p></a></li>
<li><a href='#idtw2vec'>
<p>Incremental vector-based DTW</p></a></li>
<li><a href='#initialize_plane'>
<p>Initialize and navigate in the plane of possible fits</p></a></li>
<li><a href='#lowerbound'>
<p>lowerbound</p></a></li>
<li><a href='#plot.dba'>
<p>Plot the results from Dynamic Time Warping Barycenter Averaging</p></a></li>
<li><a href='#plot.idtw'>
<p>Plot the results from Dynamic Time Warping</p></a></li>
<li><a href='#plot.rundtw'>
<p>Plot</p></a></li>
<li><a href='#rundtw'>
<p>rundtw</p></a></li>
<li><a href='#scale'>
<p>Time Series Scaling</p></a></li>
<li><a href='#simulate_timewarp'>
<p>Simulate time warp</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Incremental Calculation of Dynamic Time Warping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4.4</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Leodolter</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Leodolter &lt;maximilian.leodolter@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Dynamic Time Warping (DTW) distance measure for time series allows non-linear alignments of time series to match  similar patterns in time series of different lengths and or different speeds. IncDTW is characterized by (1) the incremental calculation of DTW (reduces runtime complexity to a linear level for updating the DTW distance) - especially for life data streams or subsequence matching, (2) the vector based implementation of DTW which is faster because no matrices are allocated (reduces the space complexity from a quadratic to a linear level in the number of observations) - for all runtime intensive DTW computations, (3) the subsequence matching algorithm runDTW, that efficiently finds the k-NN to a query pattern in a long time series, and (4) C++ in the heart. For details about DTW see the original paper "Dynamic programming algorithm optimization for spoken word recognition" by Sakoe and Chiba (1978) &lt;<a href="https://doi.org/10.1109%2FTASSP.1978.1163055">doi:10.1109/TASSP.1978.1163055</a>&gt;. For details about this package, Dynamic Time Warping and Incremental Dynamic Time Warping please see "IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping" by Leodolter et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v099.i09">doi:10.18637/jss.v099.i09</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8), RcppParallel, ggplot2, scales, parallel,
stats, data.table</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-12 10:44:06 UTC; leodolter</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, dtw, rmarkdown, gridExtra, testthat, dtwclust,
parallelDist, microbenchmark, rucrdtw, proxy, R.rsp,
dendextend, reshape2, colorspace, fastcluster</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-16 15:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='IncDTW-package'>
Incremental Dynamic Time Warping
</h2><span id='topic+IncDTW-package'></span>

<h3>Description</h3>

<p>The Dynamic Time Warping (DTW) distance for time series allows non-linear alignments of time series to match  similar patterns in time series of different lengths and or different speeds. Beside the traditional implementation of the DTW algorithm, the specialties of this package are, (1) the incremental calculation, which is specifically useful for life data streams due to computationally efficiency, (2) the vector based implementation of the traditional DTW algorithm which is faster because no matrices are allocated and is especially useful for computing distance matrices of pairwise DTW distances for many time series  and (3) the combination of incremental and vector-based calculation.
</p>


<h3>Details</h3>

<p>Main features:
</p>

<ul>
<li>
<p>Incremental Calculation, <code><a href="#topic+idtw">idtw</a></code>, <code><a href="#topic+idtw2vec">idtw2vec</a></code> and <code><a href="#topic+increment">increment</a></code>

</p>
</li>
<li>
<p>Detect k-nearest subsequences in longer time series, <code><a href="#topic+rundtw">rundtw</a></code>

</p>
</li>
<li>
<p>Matrix-based <code><a href="#topic+dtw">dtw</a></code> and Vector-based <code><a href="#topic+dtw2vec">dtw2vec</a></code> implementation of the DTW algorithm

</p>
</li>
<li>
<p>Sakoe Chiba warping window

</p>
</li>
<li>
<p>Early abandoning and lower bounding

</p>
</li>
<li>
<p>Support for multivariate time series

</p>
</li>
<li>
<p>Fast calculation of a distance matrix of pairwise DTW distances for clustering or classification of many multivariate time series, <code><a href="#topic+dtw_dismat">dtw_dismat</a></code>

</p>
</li>
<li>
<p>Aggregate cluster members with <code><a href="#topic+dba">dba</a></code> or get the centroid with <code><a href="#topic+centroid">centroid</a></code>

</p>
</li>
<li>
<p>C++ in the heart thanks to Rcpp

</p>
</li></ul>



<h3>Author(s)</h3>

<p>Maximilian Leodolter
</p>
<p>Maintainer: Maximilian Leodolter &lt;maximilian.leodolter@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a> 
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://ieeexplore.ieee.org/document/1163055/">https://ieeexplore.ieee.org/document/1163055/</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Dynamic_time_warping">https://en.wikipedia.org/wiki/Dynamic_time_warping</a>
</p>

<hr>
<h2 id='dba'>
Dynamic Time Warping Barycenter Averaging
</h2><span id='topic+dba'></span><span id='topic+DBA'></span><span id='topic+centroid'></span><span id='topic+print.dba'></span><span id='topic+summary.dba'></span><span id='topic+is.dba'></span>

<h3>Description</h3>

<p>Average multiple time series that are non-linearly aligned by Dynamic Time Warping. Find the centroid of a list of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dba(lot, m0 = NULL, iterMax = 10, eps = NULL, 
                dist_method = c("norm1", "norm2", "norm2_square"),
                step_pattern = c("symmetric2", "symmetric1"),
                ws = NULL,
                iter_dist_method = c("dtw_norm1", "dtw_norm2",
                                     "norm1","norm2", "max", "min"), 
                plotit = FALSE)
                
# deprecated
DBA(lot, m0 = NULL, iterMax = 10, eps = NULL, 
                dist_method = c("norm1", "norm2", "norm2_square"),
                step_pattern = c("symmetric2", "symmetric1"),
                ws = NULL,
                iter_dist_method = c("dtw_norm1", "dtw_norm2",
                                     "norm1","norm2", "max", "min"), 
                plotit = FALSE)
                
centroid(lot, dist_method = c("norm1", "norm2", "norm2_square"),
              step_pattern = c("symmetric2", "symmetric1"),
              normalize = TRUE, ws = NULL, ncores = NULL,
              useRcppParallel = TRUE)


              
## S3 method for class 'dba'
print(x, digits = getOption("digits"),  ...)

## S3 method for class 'dba'
summary(object, ...)              

is.dba(x)             
              
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dba_+3A_lot">lot</code></td>
<td>
<p>List of time series. Each entry of the list is a time series as described in <code><a href="#topic+dtw2vec">dtw2vec</a></code>.</p>
</td></tr>
<tr><td><code id="dba_+3A_m0">m0</code></td>
<td>
<p>time series as vector or matrix. If <code>m0</code> is <code>NULL</code>, the initial time series <code>m0</code> is determined by <code><a href="#topic+centroid">centroid</a></code> as the centroid of <code>lot</code>, which is the one time series of <code>lot</code> with the minimum average DTW distance to all other time series of <code>lot</code>.</p>
</td></tr>
<tr><td><code id="dba_+3A_itermax">iterMax</code></td>
<td>
<p>integer, number of maximum iterations</p>
</td></tr>
<tr><td><code id="dba_+3A_eps">eps</code></td>
<td>
<p>numeric, threshold parameter that causes the algorithm to break if the distance of two consecutive barycenters are closer than eps</p>
</td></tr>
<tr><td><code id="dba_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="dba_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="dba_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="dba_+3A_iter_dist_method">iter_dist_method</code></td>
<td>
<p>character, that describes how the distance between two consecutive barycenter iterations are defined (default = &quot;dtw&quot;)</p>
</td></tr>
<tr><td><code id="dba_+3A_plotit">plotit</code></td>
<td>
<p>logical, if the iterations should be plotted or not (only possible for univariate time series)</p>
</td></tr>
<tr><td><code id="dba_+3A_normalize">normalize</code></td>
<td>
<p>logical, default is TRUE, passed to <code><a href="#topic+dtw_dismat">dtw_dismat</a></code></p>
</td></tr>
<tr><td><code id="dba_+3A_ncores">ncores</code></td>
<td>
<p>integer, default = NULL,  passed to <code><a href="#topic+dtw_dismat">dtw_dismat</a></code></p>
</td></tr>
<tr><td><code id="dba_+3A_usercppparallel">useRcppParallel</code></td>
<td>
<p>logical, default is TRUE, passed to <code><a href="#topic+dtw_dismat">dtw_dismat</a></code></p>
</td></tr>
<tr><td><code id="dba_+3A_x">x</code></td>
<td>

<p>output from <code>dba</code>
</p>
</td></tr>
<tr><td><code id="dba_+3A_object">object</code></td>
<td>

<p>any R object
</p>
</td></tr>
<tr><td><code id="dba_+3A_digits">digits</code></td>
<td>

<p>passed to <code>round</code> and <code>print</code>
</p>
</td></tr>
<tr><td><code id="dba_+3A_...">...</code></td>
<td>

<p>additional arguments, e.g. passed to <code>print</code> or <code>summary</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>iter_dist_method</code> describes the method to measure the progress between two iterations. For two consecutive centroid candidates <code>m1</code> and <code>m2</code> the following methods are implemented:
</p>
<p>'dtw_norm1':
<code>dtw2vec(m1, m2, dist_method = "norm1", step_pattern = "symmetric2")$normalized_distance</code>
</p>
<p>'idm_dtw2':
<code>dtw2vec(m1, m2, dist_method = "norm2", step_pattern = "symmetric2")$normalized_distance</code>
</p>
<p>'idm_norm1':
<code>sum(abs(m1-m2))/(ncol(m1) * 2 * nrow(m1))</code>
</p>
<p>'idm_norm2':
<code>sqrt(sum((m1-m2)^2))/(ncol(m1) * 2 * nrow(m1))</code>
</p>
<p>'idm_max':
<code>max(abs(m1-m2))</code>
</p>
<p>'idm_min':
<code>min(abs(m1-m2))</code>
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>new centroid/ bary center of the list of time series</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>list of time series that are the best centroid of the respective iteration</p>
</td></tr>
<tr><td><code>iterDist_m2lot</code></td>
<td>
<p>list of distances of the iterations to lot</p>
</td></tr>
<tr><td><code>iterDist_m2lot_norm</code></td>
<td>
<p>list of normalized distances of the iterations to lot</p>
</td></tr>
<tr><td><code>iterDist_m2m</code></td>
<td>
<p>vector of distances of the iterations to their ancestors</p>
</td></tr>
<tr><td><code>centroid_index</code></td>
<td>
<p>integer giving the index of the centroid time series of <code>lot</code></p>
</td></tr>
<tr><td><code>dismat_result</code></td>
<td>
<p>list of results of <code><a href="#topic+dtw_dismat">dtw_dismat</a></code> called by <code>centroid</code></p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li>
<li><p> Petitjean, F; Ketterlin, A; Gancarski, P, A global averaging method for dynamic time warping, with applications to clustering, Pattern Recognition, Volume 44, Issue 3, 2011, Pages 678-693, ISSN 0031-3203
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("drink_glass")
# initialize with any time series 
m1 &lt;- dba(lot = drink_glass[1:10], m0 = drink_glass[[1]], 
          dist_method = "norm2", iterMax = 20)

# initialize with the centroid

tmp &lt;- centroid(drink_glass)
cent &lt;- drink_glass[[tmp$centroid_index]]
m1 &lt;- dba(lot = drink_glass[1:10], m0 = cent, 
          dist_method = "norm2", iterMax = 20)

# plot all dimensions of the barycenters m_n per iteration:
plot(m1)

# plot the distances of the barycenter of one iteration m_n
# to the barycenter of the previous iteration m_n-1:
plot(m1, type = "m2m")

# plot the average distances of the barycenter m_n 
# to the list of time series:
plot(m1, type = "m2lot")


## End(Not run)
</code></pre>

<hr>
<h2 id='dec_dm'>
Decrement the Warping Path
</h2><span id='topic+dec_dm'></span>

<h3>Description</h3>

<p>Update the warping path to omit observations of the alignment of two time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dec_dm(dm, Ndec, diffM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dec_dm_+3A_dm">dm</code></td>
<td>
<p>direction matrix, output from dtw(Q=Q, C=C, ws=ws)</p>
</td></tr>
<tr><td><code id="dec_dm_+3A_ndec">Ndec</code></td>
<td>
<p>integer, number of observations (columns) to be reduced</p>
</td></tr>
<tr><td><code id="dec_dm_+3A_diffm">diffM</code></td>
<td>
<p>matrix of differences</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>wp</code></td>
<td>
<p>warping path</p>
</td></tr>
<tr><td><code>ii</code></td>
<td>
<p>indices of Q of the optimal path</p>
</td></tr>
<tr><td><code>jj</code></td>
<td>
<p>indices of C of the optimal path</p>
</td></tr>
<tr><td><code>diffp</code></td>
<td>
<p>path of differences (only returned if diffM is not NULL)</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- cos(1:100)
C &lt;- cumsum(rnorm(80))
# the ordinary calculation
result_base &lt;- dtw(Q=Q, C=C, return_wp = TRUE) 

# the ordinary calculation without the last 4 observations
result_decr &lt;- dtw(Q=Q, C=C[1:(length(C) - 4)], return_wp = TRUE) 
# the decremental step: reduce C for 4 observation
result_decr2 &lt;- dec_dm(result_base$dm, Ndec = 4) 

# compare ii, jj and wp of result_decr and those of 
result_decr$ii
result_decr2$ii
identical(result_decr$ii, result_decr2$ii)

result_decr$jj
result_decr2$jj
identical(result_decr$jj, result_decr2$jj)

result_decr$wp
result_decr2$wp
identical(result_decr$wp, result_decr2$wp)


</code></pre>

<hr>
<h2 id='drink_glass'>
Accelerometer: drink a glass, walk, brush teeth.
</h2><span id='topic+drink_glass'></span><span id='topic+walk'></span><span id='topic+brush_teeth'></span>

<h3>Description</h3>

<p>3-dimensional acceleration time series recorded during the activities of walking, drinking a glass or brushing teeth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("drink_glass")</code></pre>


<h3>Format</h3>

<p>A list of matrices, where each matrix has 3 columns (x, y, and z axis of the accelerometer). The number of rows differ. 
</p>


<h3>Details</h3>

<p>list of 3-dimensional time series stored as matrix. The data is recorded with 32Hz. The data is z-scaled (z-normalized).
</p>


<h3>Source</h3>

<p>UCI Machine Learning Repository
<a href="https://archive.ics.uci.edu/ml/datasets/Dataset+for+ADL+Recognition+with+Wrist-worn+Accelerometer">https://archive.ics.uci.edu/ml/datasets/Dataset+for+ADL+Recognition+with+Wrist-worn+Accelerometer</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(drink_glass)
class(drink_glass)
length(drink_glass)
dim(drink_glass[[1]])
matplot(drink_glass[[1]], type="l")

data(walk)
class(walk)
length(walk)
dim(walk[[1]])
matplot(walk[[1]], type="l")

data(brush_teeth)
class(brush_teeth)
length(brush_teeth)
dim(brush_teeth[[1]])
matplot(brush_teeth[[1]], type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='dtw'>
Dynamic Time Warping
</h2><span id='topic+dtw'></span><span id='topic+cm'></span><span id='topic+print.idtw'></span><span id='topic+summary.idtw'></span><span id='topic+is.idtw'></span>

<h3>Description</h3>

<p>Calculate the DTW distance, cost matrices and direction matrices including the warping path two multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw(Q, C, dist_method = c("norm1", "norm2", "norm2_square"), 
    step_pattern = c("symmetric2", "symmetric1"), ws = NULL,
    return_cm = FALSE,
    return_diffM = FALSE,
    return_wp = FALSE,
    return_diffp = FALSE,
    return_QC = FALSE)
                     
cm(Q, C, dist_method = c("norm1", "norm2", "norm2_square"), 
   ws = NULL, ...)
   
## S3 method for class 'idtw'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'idtw'
summary(object, ...)

is.idtw(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw_+3A_q">Q</code></td>
<td>
<p>Query time series. Q needs to be one of the following: (1) a one dimensional vector, (2) a matrix where each row is one observations and each column is one dimension of the time series, or (3) a matrix of differences/ costs (diffM, cm). If Q and C are matrices they need to have the same number of columns.
</p>
</td></tr>
<tr><td><code id="dtw_+3A_c">C</code></td>
<td>

<p>Candidate time series. C needs to be one of the following: (1) a one dimensional vector, (2) a matrix where each row is one observations and each column is one dimension of the time series, or (3) if Q is a matrix of differences or costs C needs to be the respective character string 'diffM' or 'cm'.
</p>
</td></tr>
<tr><td><code id="dtw_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure for multivariate time series (this parameter is ignored for univariate time series). Currently supported methods are 'norm1' (default, is the Manhattan distance), 'norm2' (is the Euclidean distance) and 'norm2_square'. For the function <code>cm()</code> the parameter <code>dist_method</code> can also be a user defined distance function (see details and examples).
</p>
</td></tr>
<tr><td><code id="dtw_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. Currently implemented are the patterns <code>symmetric1</code> and <code>symmetric2</code>, see details.
</p>
</td></tr>
<tr><td><code id="dtw_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="dtw_+3A_return_cm">return_cm</code></td>
<td>
<p>logical, if TRUE then the Matrix of costs (the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="dtw_+3A_return_diffm">return_diffM</code></td>
<td>

<p>logical, if TRUE then the Matrix of differences (not the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="dtw_+3A_return_wp">return_wp</code></td>
<td>

<p>logical, if TRUE then the warping path is returned. (default = FALSE) If return_diffp == TRUE, then return_wp is set to TRUE as well.
</p>
</td></tr>
<tr><td><code id="dtw_+3A_return_diffp">return_diffp</code></td>
<td>

<p>logical, if TRUE then the path of differences (not the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="dtw_+3A_return_qc">return_QC</code></td>
<td>

<p>logical, if TRUE then the input vectors Q and C are appended to the returned list. This is useful for the <code><a href="#topic+plot.idtw">plot.idtw</a></code> function.  (default = FALSE)
</p>
</td></tr>
<tr><td><code id="dtw_+3A_x">x</code></td>
<td>

<p>output from <code>dtw</code> or <code><a href="#topic+idtw">idtw</a></code>.
</p>
</td></tr>
<tr><td><code id="dtw_+3A_object">object</code></td>
<td>

<p>any R object
</p>
</td></tr>
<tr><td><code id="dtw_+3A_...">...</code></td>
<td>

<p>additional arguments, e.g. passed to <code>print</code>, <code>summary</code>, or a user defined distance function for <code>cm()</code> 
</p>
</td></tr>
<tr><td><code id="dtw_+3A_digits">digits</code></td>
<td>

<p>passed to <code>round</code> and <code>print</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamic time warping distance is the element in the last row and last column of the global cost matrix. 
</p>
<p>For the multivariate case where Q is a matrix of n rows and k columns and C is a matrix of m rows and k columns
the dist_method parameter defines the following distance measures: 
</p>
<p>norm1: </p>
<p style="text-align: center;"><code class="reqn">dist(Q_{i,.}, C_{j,.}) = \sum {l = 1:k}  |Q_{i,l} - C_{j,l}|</code>
</p>

<p>norm2: </p>
<p style="text-align: center;"><code class="reqn">dist(Q_{i,.}, C_{j,.}) = (\sum {l = 1:k} (Q_{i,l} - C_{j,l})^2)^0.5</code>
</p>

<p>norm2_square: </p>
<p style="text-align: center;"><code class="reqn">dist(Q_{i,.}, C_{j,.}) = \sum{l = 1:k} (Q_{i,l} - C_{j,l})^2</code>
</p>

<p>The parameter <code>step_pattern</code> describes how the two time series are aligned. 
If <code>step_pattern == "symmetric1"</code> then  </p>
<p style="text-align: center;"><code class="reqn">gcm_{i,j} = cm{i,j} + min(gcm_{i-1,j}, gcm{i-1, j-1}, gcm{i, i-1} </code>
</p>
<p>.
</p>
<p>If <code>step_pattern == "symmetric2"</code> then  </p>
<p style="text-align: center;"><code class="reqn">gcm_{i,j} = cm{i,j} + min(gcm_{i-1,j}, cm{i,j}+ gcm{i-1, j-1}, gcm{i, i-1} </code>
</p>
<p>.
</p>
<p>To make DTW distances comparable for many time series of different lengths use the <code>normlized_distance</code> with the setting <code>step_method = 'symmetric2'</code>. Please find a more detailed discussion and further references here: <a href="http://dtw.r-forge.r-project.org/">http://dtw.r-forge.r-project.org/</a>.
</p>
<p>User defined distance function:
To calculate the DTW distance measure of two time series a distance function for the local distance of two observations <code>Q[i, ]</code> and <code>C[j, ]</code> of the time series <code>Q</code> and <code>C</code> has to be selected. The predefined distance function are 'norm1', 'norm2' and 'norm2-square'. It is also possible to define a customized distance function and use the cost matrix <code>cm</code> as input for the DTW algorithm, also for the incremental functions. In the following experiment we apply the cosine distance as local distance function:
</p>
<p style="text-align: center;"><code class="reqn">
 d_cos(C_i, Q_j) = 1 - (\sum{o=1:O} Q_{io} * C_{jo})/ ((\sum{o=1:O} Q_{io}^2)^0.5 * (\sum{o=1:O} C_{jo}^2)^0.5).
</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>the DTW distance, that is the element of the last row and last column of gcm</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the normalized DTW distance, that is the distance divided by <code>N+M</code>, where N and M are the lengths of the time series Q and C, respectively. If <code>step_pattern == 'symmetric1'</code> no normalization is performed and <code>NA</code> is returned (see details).</p>
</td></tr>
<tr><td><code>gcm</code></td>
<td>
<p>global cost matrix</p>
</td></tr>
<tr><td><code>dm</code></td>
<td>
<p>direction matrix (3=up, 1=diagonal, 2=left)</p>
</td></tr>
<tr><td><code>wp</code></td>
<td>
<p>warping path</p>
</td></tr>
<tr><td><code>ii</code></td>
<td>
<p>indices of Q of the optimal path</p>
</td></tr>
<tr><td><code>jj</code></td>
<td>
<p>indices of C of the optimal path</p>
</td></tr>
<tr><td><code>cm</code></td>
<td>
<p>Matrix of costs</p>
</td></tr>
<tr><td><code>diffM</code></td>
<td>
<p>Matrix of differences</p>
</td></tr>
<tr><td><code>diffp</code></td>
<td>
<p>path of differences</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>input Q</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>input C</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#--- univariate
Q &lt;- cumsum(rnorm(100))
C &lt;- Q[11:100] + rnorm(90, 0, 0.5)
tmp &lt;- dtw(Q = Q, C = C, ws = 15, return_diffM = FALSE, 
           return_QC = TRUE, return_wp = TRUE)
names(tmp)
print(tmp, digits = 3)
plot(tmp)
plot(tmp, type = "warp")


#--- compare different input variations
dtw_base  &lt;- dtw(Q = Q, C = C, ws = 15, return_diffM = TRUE)
dtw_diffM &lt;- dtw(Q = dtw_base$diffM, C = "diffM", ws = 15, 
                 return_diffM = TRUE)
dtw_cm    &lt;- dtw(Q = abs(dtw_base$diffM), C = "cm", ws = 15, 
                 return_diffM = TRUE)

identical(dtw_base$gcm, dtw_cm$gcm)
identical(dtw_base$gcm, dtw_diffM$gcm)

# of course no diffM is returned in the 'cm'-case
dtw_cm$diffM


#--- multivariate case
Q &lt;- matrix(rnorm(100), ncol=2)
C &lt;- matrix(rnorm(80), ncol=2)
dtw(Q = Q, C = C, ws = 30, dist_method = "norm2")


#--- user defined distance function
# We define the distance function d_cos and use it as input for the cost matrix function cm. 
# We can pass the output from cm() to dtw2vec(), and also to idtw2vec() for the 
# incrermental calculation:

d_cos &lt;- function(x, y){ 
  1 - sum(x * y)/(sqrt(sum(x^2)) * sqrt(sum(y^2)))
}

Q &lt;- matrix(rnorm(100), ncol=5, nrow=20)
C &lt;- matrix(rnorm(150), ncol=5, nrow=30)
cm1 &lt;- cm(Q, C, dist_method = d_cos)
dtw2vec(Q = cm1, C = "cm")$distance

res0 &lt;- idtw2vec(Q = cm1[ ,1:20], newObs =  "cm")
idtw2vec(Q = cm1[ ,21:30], newObs =  "cm", gcm_lc = res0$gcm_lc_new)$distance

# The DTW distances -- based on the customized distance function -- of the 
# incremental calculation and the one from scratch are identical.


</code></pre>

<hr>
<h2 id='dtw_dismat'>
DTW Distance Matrix/ Distance Vector
</h2><span id='topic+dtw_dismat'></span><span id='topic+dtw_disvec'></span>

<h3>Description</h3>

<p>Calculate a matrix of pairwise DTW distances for a set of univariate or multivariate time series. The output matrix (or dist object) of DTW distances can easily be applied for clustering the set of time series. Or calculate a vector of DTW distances of a set of time series all relative to one query time series. Parallel computations are possible.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw_dismat(lot, dist_method = c("norm1", "norm2", "norm2_square"),
         step_pattern = c("symmetric2", "symmetric1"), normalize = TRUE,
         ws = NULL, threshold = NULL,
         return_matrix = FALSE, ncores = NULL, useRcppParallel = TRUE)

dtw_disvec(Q, lot, dist_method = c("norm1", "norm2", "norm2_square"),
         step_pattern = c("symmetric2", "symmetric1"), normalize = TRUE,
         ws = NULL, threshold = NULL, ncores = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw_dismat_+3A_q">Q</code></td>
<td>
<p>time series, vector (univariate) or matrix (multivariate)</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_lot">lot</code></td>
<td>
<p>List of time series. Each entry of the list is a time series as described in <code><a href="#topic+dtw2vec">dtw2vec</a></code>.</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_normalize">normalize</code></td>
<td>
<p>logical, whether to return normalized pairwise distances or not. If <code>step_pattern == 'symmetric1'</code> only non-normalized distances can be returned (default = TRUE)</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_threshold">threshold</code></td>
<td>
<p>numeric, the threshold for early abandoning. In the calculation of the global cost matrix a possible path stops as soon as the threshold is reached. Facilitates faster calculations in case of low threshold. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_return_matrix">return_matrix</code></td>
<td>
<p>logical, If FALSE (default) the distance matrix is returned as <code>dist</code> object. If TRUE a symmetric matrix of differences is returned.  
</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_ncores">ncores</code></td>
<td>
<p>integer, number of cores to be used for parallel computation of the distance matrix. If <code>ncores = NULL</code> (default) then ncores is set to the number of available cores minus 1. If <code>ncores = 0</code> then no parallel computation is performed and standard <code>sapply</code> instead of <code>parallel::parSapply</code> is applied.</p>
</td></tr>
<tr><td><code id="dtw_dismat_+3A_usercppparallel">useRcppParallel</code></td>
<td>
<p>logical, if the package RcppParallel (TRUE, default) or parallel  (FALSE) is used for parallel computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By setting the parameter <code>return_matrix = FALSE</code> (default) the output value <code>dismat</code> of <code>dtw_dismat</code> is a <code>dist</code> object and can easily be passed to standard clustering functions (see examples).
</p>
<p>No matrices are allocated for calculating the pairwise distances.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>input</code></td>
<td>
<p>the function input parameters</p>
</td></tr>
<tr><td><code>dismat</code></td>
<td>
<p>the matrix of pairwise DTW distances, either as matrix or dist object</p>
</td></tr>
<tr><td><code>disvec</code></td>
<td>
<p>the vector DTW distances</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#--- Example for clustering a set of time series by feeding well known 
# clustering methods with DTW-distance objects. First we simulate 
# two prototype random walks and some cluster members. The cluster
# members are simulated by adding noise and randomly stretching and 
# comressing the time series, to get time warped time series of 
# varying lengths. The built clusters are 1:6 and 7:12.
set.seed(123)
N &lt;- 100
rw_a &lt;- cumsum(rnorm(N))
rw_b &lt;- cumsum(rnorm(N))
sth &lt;- sample(seq(0, 0.2, 0.01), size = 10)
cmp &lt;- sample(seq(0, 0.2, 0.01), size = 10)
lot &lt;- c(list(rw_a), 
         lapply(1:5, function(i){ 
           simulate_timewarp(rw_a + rnorm(N), sth[i], cmp[i]) 
         }),
         list(rw_b),
         lapply(6:10, function(i){ 
           simulate_timewarp(rw_b + rnorm(N), sth[i], cmp[i]) 
         }))


# Next get the distance matrix, as dist object. Per default all 
# minus 1 available cores are used:
result &lt;- dtw_dismat(lot = lot, dist_method = "norm2", ws = 50, 
                     return_matrix = FALSE)
class(result$dismat)


# Finally you can cluster the result with the following
#  well known methods:
require(cluster)
myclus &lt;- hclust(result$dismat)
plot(myclus)
summary(myclus)

myclus &lt;- agnes(result$dismat)
plot(myclus)
summary(myclus)

myclus &lt;- pam(result$dismat, k=2)
plot(myclus)
summary(myclus)
myclus$medoids



## End(Not run)
</code></pre>

<hr>
<h2 id='dtw_partial'>
Partial Dynamic Time Warping
</h2><span id='topic+dtw_partial'></span>

<h3>Description</h3>

<p>Get the cheapest partial open end alignment of two time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw_partial(x, partial_Q = TRUE, partial_C = TRUE, reverse = FALSE)
                     
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw_partial_+3A_x">x</code></td>
<td>
<p>result object of either <code><a href="#topic+dtw">dtw</a>()</code> or <code><a href="#topic+idtw2vec">idtw2vec</a>()</code>
</p>
</td></tr>
<tr><td><code id="dtw_partial_+3A_partial_q">partial_Q</code></td>
<td>

<p>logical (default = TRUE), whether Q is aligned completely to C or open ended.  
</p>
</td></tr>
<tr><td><code id="dtw_partial_+3A_partial_c">partial_C</code></td>
<td>

<p>logical (default = TRUE), whether C is aligned completely to Q or open ended. 
</p>
</td></tr>
<tr><td><code id="dtw_partial_+3A_reverse">reverse</code></td>
<td>

<p>logical (default = FALSE), whether Q and C are in original or reverse order. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Q is the time series that describes the vertical dimension of the global cost matrix, so <code>length(Q)</code> is equal to <code>nrow(x$gcm)</code>. So C describes the horizontal dimension of the global cost matrix, <code>length(C)</code> is equal to <code>ncol(x$gcm)</code>.
</p>
<p><code>dtw_partial()</code> returns the open-end alignment of Q and C with the minimal normalized distance.
If <code>partial_Q</code> and <code>partial_C</code> both are <code>TRUE</code> the partial alignment with the smaller normalized distance is returned.
</p>
<p>If Q and C are in reverse order, then the optimal solution for the reverse problem is found, that is the alignment with minimal normalized distance allowing and open-start alignment.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>rangeQ</code></td>
<td>
<p>Vector of initial and ending index for best alignment</p>
</td></tr>
<tr><td><code>rangeC</code></td>
<td>
<p>Vector of initial and ending index for best alignment</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the normalized DTW distance (see details in <code><a href="#topic+dtw">dtw</a></code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#--- Open-end alignment for multivariate time series.
# First simulate a 2-dim time series Q
Q &lt;- matrix(cumsum(rnorm(50 * 2)), ncol = 2)

# Then simulate C as warped version of Q, 
C &lt;- simulate_timewarp(Q, stretch = 0.2, compress = 0.2, 
                       preserve_length = TRUE)

# add some noise
C &lt;- C + rnorm(prod(dim(C)))

# and append noise at the end
C &lt;- rbind(C, matrix(rnorm(30), ncol = 2))

tmp &lt;- dtw(Q = Q, C = C, ws = 50, return_QC = TRUE, return_wp = TRUE)
par &lt;- dtw_partial(tmp, partial_C = TRUE)
par
plot(tmp, partial = par, type = "QC")
plot(tmp, partial = par, type = "warp")
plot(tmp, partial = par, type = "QC", selDim = 2)


#--- Open-start is possible as well:
Q &lt;- sin(1:100)
C &lt;- c(rnorm(50), Q)
tmp &lt;- dtw(Q = rev(Q), C = rev(C))
dtw_partial(tmp, reverse = TRUE)

</code></pre>

<hr>
<h2 id='dtw2vec'>
Fast vector-based Dynamic Time Warping
</h2><span id='topic+dtw2vec'></span><span id='topic+dtw2vec_cm'></span><span id='topic+dtw2vec_univ'></span><span id='topic+dtw2vec_multiv'></span>

<h3>Description</h3>

<p>Calculates the Dynamic Time Warping distance by hand of a vector-based implementation and is much faster than the traditional method <code>dtw()</code>. Also allows early abandoning and sakoe chiba warping window, both for univariate and multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw2vec(Q, C, dist_method = c("norm1", "norm2", "norm2_square"),
         step_pattern = c("symmetric2", "symmetric1"),
         ws = NULL, threshold = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw2vec_+3A_q">Q</code></td>
<td>
<p>Either Q is (a) a time series (vector or matrix for multivariate time series) or (b) Q is a cost matrix, so a matrix storing the local distances of the time series Q and C. If Q and C are matrices, they need to have the same number of columns. If Q is a cost matrix, C needs to be equal the character string &quot;cm&quot;.</p>
</td></tr>
<tr><td><code id="dtw2vec_+3A_c">C</code></td>
<td>
<p>time series as vector or matrix, or for case (b) C equals &quot;cm&quot;</p>
</td></tr>
<tr><td><code id="dtw2vec_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.  If Q is a cost matrix, the dist_method parameter is not necessary.</p>
</td></tr>
<tr><td><code id="dtw2vec_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="dtw2vec_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="dtw2vec_+3A_threshold">threshold</code></td>
<td>
<p>numeric, the threshold for early abandoning. In the calculation of the global cost matrix a possible path stops as soon as the threshold is reached. Facilitates faster calculations in case of low threshold. The threshold relates to the non-normalized distance measure. (default = NULL, no early abandoning)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>no matrices are allocated, no matrices are returned
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>the DTW distance</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the normalized DTW distance, see also <code><a href="#topic+dtw">dtw</a></code></p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- cumsum(rnorm(100))
C &lt;- Q[11:100] + rnorm(90, 0, 0.5)
dtw2vec(Q = Q, C = C)
dtw2vec(Q = Q, C = C, ws = 30)
dtw2vec(Q = Q, C = C, threshold = 100)
dtw2vec(Q = Q, C = C, ws = 30, threshold = 100)

cm0 &lt;- cm(Q, C)
dtw2vec(Q = cm0, C = "cm", ws = 30, threshold = 100)
</code></pre>

<hr>
<h2 id='find_peaks'>find_peaks</h2><span id='topic+find_peaks'></span>

<h3>Description</h3>

<p>Find negative or positive peaks of a vector in a predefined neighborhood w
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peaks(x, w, get_min = TRUE, strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_peaks_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_w">w</code></td>
<td>
<p>window, at least w-many values need to be in-between two consecutive
peaks to find both, otherwise only the bigger one is returned</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_get_min">get_min</code></td>
<td>
<p>logical (default TRUE) if TRUE, then minima are returned, else maxima</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE (default) then a local minimum needs to be smaller then all neighbors. 
If FALSE, then a local minimum needs to be smaller or equal all neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of indices where x has local extreme values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- Find the peaks (local minima and maxima), 
# and also the border peak at index 29. First the local maxima:
x &lt;- c(1:10, 9:1, 2:11)
peak_indices &lt;- find_peaks(x, w=3, get_min=FALSE)
peak_indices
x[peak_indices]

# and now the local minima
peak_indices &lt;- find_peaks(x, w=3, get_min=TRUE)
peak_indices
x[peak_indices]


#--- What exactly does the neigbohood parameter 'w' mean?
# At least w-many values need to be inbetween two consecutive peaks:
x &lt;- -c(1:10, 9, 9, 11, 9:8, 7)
peak_indices &lt;- find_peaks(x, w=3)
peak_indices
x[peak_indices]

x &lt;- -c(1:10, 9, 9,9, 11, 9:8, 7)
peak_indices &lt;- find_peaks(x, w=3)
peak_indices
x[peak_indices]


#--- What does the parameter 'strict' mean?
# If strict = TRUE, then the peak must be '&lt;' (or '&gt;') 
# then the neighbors, other wise '&lt;=' (or '&gt;=')
x &lt;- c(10:1,  1:10)
peak_indices &lt;-  find_peaks(x, w=3, strict = TRUE)
peak_indices
x[peak_indices]

peak_indices &lt;-  find_peaks(x, w=3, strict = FALSE)
peak_indices
x[peak_indices]
   
</code></pre>

<hr>
<h2 id='idtw'>
Incremental DTW
</h2><span id='topic+idtw'></span>

<h3>Description</h3>

<p>Update the DTW distance, cost matrices and direction matrices including the warping path for new observations of two time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idtw(Q, C, newObs, gcm, dm, 
      dist_method = c("norm1", "norm2", "norm2_square"),
      step_pattern = c("symmetric2", "symmetric1"),
      diffM = NULL, ws = NULL, 
      return_cm = FALSE,
      return_diffM = FALSE,
      return_wp = FALSE,
      return_diffp = FALSE,
      return_QC = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idtw_+3A_q">Q</code></td>
<td>
<p>numeric vector, or matrix (see also <code><a href="#topic+dtw">dtw</a></code>)</p>
</td></tr>
<tr><td><code id="idtw_+3A_c">C</code></td>
<td>
<p>numeric vector, or matrix</p>
</td></tr>
<tr><td><code id="idtw_+3A_newobs">newObs</code></td>
<td>
<p>vector or matrix of new observations to be appended to C</p>
</td></tr>
<tr><td><code id="idtw_+3A_gcm">gcm</code></td>
<td>
<p>global cost matrix, output from <code>dtw(Q, C, ...)</code></p>
</td></tr>
<tr><td><code id="idtw_+3A_dm">dm</code></td>
<td>
<p>direction matrix, output from <code>dtw(Q, C, ...)</code></p>
</td></tr>
<tr><td><code id="idtw_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="idtw_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="idtw_+3A_diffm">diffM</code></td>
<td>
<p>differences matrix, output from <code>dtw(Q, C, ...)</code>. This matrix is an optional input parameter (default = NULL) that is necessary to return the path of differences. Only for univariate time series Q and C.</p>
</td></tr>
<tr><td><code id="idtw_+3A_ws">ws</code></td>
<td>
<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="idtw_+3A_return_cm">return_cm</code></td>
<td>
<p>logical, if TRUE then the Matrix of costs (the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="idtw_+3A_return_diffm">return_diffM</code></td>
<td>
<p>logical, if TRUE then the Matrix of differences (not the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="idtw_+3A_return_wp">return_wp</code></td>
<td>

<p>logical, if TRUE then the warping path is returned. (default = FALSE) If return_diffp == TRUE, then return_wp is set to TRUE as well.
</p>
</td></tr>
<tr><td><code id="idtw_+3A_return_diffp">return_diffp</code></td>
<td>

<p>logical, if TRUE then the path of differences (not the absolute value) is returned. (default = FALSE)
</p>
</td></tr>
<tr><td><code id="idtw_+3A_return_qc">return_QC</code></td>
<td>

<p>logical, if TRUE then the input vectors Q and C are appended to the returned list. This is useful for the <code><a href="#topic+plot.idtw">plot.idtw</a></code> function.  (default = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamic time warping distance is the element in the last row and last column of the global cost matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>the DTW distance, that is the element of the last row and last column of gcm</p>
</td></tr>
<tr><td><code>gcm</code></td>
<td>
<p>global cost matrix</p>
</td></tr>
<tr><td><code>dm</code></td>
<td>
<p>direction matrix (3=up, 1=diagonal, 2=left)</p>
</td></tr>
<tr><td><code>wp</code></td>
<td>
<p>warping path</p>
</td></tr>
<tr><td><code>ii</code></td>
<td>
<p>indices of Q of the optimal path</p>
</td></tr>
<tr><td><code>jj</code></td>
<td>
<p>indices of C of the optimal path</p>
</td></tr>
<tr><td><code>cm</code></td>
<td>
<p>Matrix of costs</p>
</td></tr>
<tr><td><code>diffM</code></td>
<td>
<p>Matrix of differences</p>
</td></tr>
<tr><td><code>diffp</code></td>
<td>
<p>path of differences</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>input Q</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>input C</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the normalized DTW distance, see also <code>link{dtw}</code></p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#--- Compare the incremental calculation with the basic
# calculation from scratch.
Q &lt;- cumsum(rnorm(100))
C &lt;- Q[11:100] + rnorm(90, 0, 0.5)
newObs &lt;-  c(2, 3)# new observation
base &lt;- dtw(Q = Q, C = C, ws = 15, return_diffM = TRUE) 
base

# recalculation from scratch with new observations
result0 &lt;- dtw(Q = Q, C = c(C, newObs), ws = 15,  return_diffM = TRUE)

# the incremental step with new observations
result1 &lt;- idtw(Q, C, ws = 15, newO = newObs, gcm = base$gcm, 
                dm = base$dm, diffM = base$diffM, return_diffp = TRUE,  
                return_diffM = TRUE, return_QC = TRUE) 
print(result1, digits = 2)
plot(result1)


#--- Compare the incremental calculation with external calculated 
# costMatrix cm_add with the basic calculation from scratch.
cm_add &lt;- cm(Q, newObs)
result2 &lt;- idtw(Q = cm_add, C = "cm_add", ws = 15, newO = newObs, 
                gcm = base$gcm, dm = base$dm) 

c(result0$distance, result1$distance, result2$distance)


</code></pre>

<hr>
<h2 id='idtw2vec'>
Incremental vector-based DTW 
</h2><span id='topic+idtw2vec'></span><span id='topic+idtw2vec_cm'></span><span id='topic+idtw2vec_univ'></span><span id='topic+idtw2vec_multiv'></span>

<h3>Description</h3>

<p>Update the DTW distance for new observations of two time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idtw2vec(Q, newObs, dist_method = c("norm1", "norm2", "norm2_square"),
         step_pattern = c("symmetric2", "symmetric1"),
         gcm_lc = NULL, gcm_lr = NULL, nC = NULL, ws = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idtw2vec_+3A_q">Q</code></td>
<td>
<p>Either <code>Q</code> is (a) a time series (vector or matrix for multivariate time series) or (b) <code>Q</code> is a cost matrix, so a matrix storing the local distances of the time series <code>Q</code> and <code>newObs</code>. If <code>Q</code> and <code>newObs</code> are matrices, they need to have the same number of columns. If <code>Q</code> is a cost matrix, see details...
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_newobs">newObs</code></td>
<td>
<p>time series as vector or matrix, or if <code>Q</code> is a cost matrix newObs must equals <code>"cm"</code>. If <code>newObs</code> is a time series, see details... 
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_dist_method">dist_method</code></td>
<td>
<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_step_pattern">step_pattern</code></td>
<td>
<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_gcm_lc">gcm_lc</code></td>
<td>
<p>vector, last column of global cost matrix of previous calculation. If NULL (necessary for the initial calculation), then DTW is calculated and the last column and last row are returned to start upcoming incremental calculations. (default = NULL)
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_gcm_lr">gcm_lr</code></td>
<td>
<p>vector, last row of global cost matrix of previous calculation (default = NULL). 
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_nc">nC</code></td>
<td>

<p>integer, is the length of the original time series C, of which newObs are the new observations. Length of time series C exclusive new observations, such that <code>length(c(C, newObs)) = nC + length(newObs)</code>. Necessary if ws is not NULL.  (default = NULL)
</p>
</td></tr>
<tr><td><code id="idtw2vec_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If new observations are recorded only for C and the only interest is a fast update of the DTW distance, the last row is not required, neither for the current nor for future incremental calculations.
</p>
<p>If <code>Q</code> is a cost matrix, it needs to store either the distances of <code>Q</code> and new observations of <code>C</code> (running calculations, in that case gcm_lc != NULL), or it stores the distances of <code>Q</code> and the entire time series <code>C</code> (initial calculation, in that case gcm_lc = NULL).
</p>
<p>If <code>newObs</code> is a time series, it stores either new Observations of <code>C</code> (running calculations) or the complete time series <code>C</code> (initial calculation).
</p>
<p>no matrices are allocated, no matrices are returned
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>the DTW distance</p>
</td></tr>
<tr><td><code>gcm_lc_new</code></td>
<td>
<p>the last column of the new global cost matrix</p>
</td></tr>
<tr><td><code>gcm_lr_new</code></td>
<td>
<p>the last row of the new global cost matrix. Only if the input vector <code>gcm_lr</code> is not NUll and represents the last row of the previous global cost matrix, <code>gcm_lr_new</code> actually is the last row of the updated global cost matrix. Otherwise, if <code>gcm_lr</code> is NULL then <code>gcm_lr_new</code> is only the last row of the new part (concerning the new observations) of the global cost matrix.  
</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the normalized DTW distance, see also <code><a href="#topic+dtw">dtw</a></code></p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Sakoe, H.; Chiba, S., <em>Dynamic programming algorithm optimization for spoken word recognition, Acoustics, Speech, and Signal Processing</em> [see also IEEE Transactions on Signal Processing], IEEE Transactions on , vol.26, no.1, pp. 43-49, Feb 1978. http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1163055
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#--- Do the vector-based incremental DTW 
# calculation and compare it with the basic
Q &lt;- cumsum(rnorm(100))
C &lt;- Q[11:100] + rnorm(90, 0, 0.5)

# initial calculation
res0 &lt;- idtw2vec(Q = Q, newObs = C, gcm_lc = NULL)

# incremental calculation for new observations
nobs &lt;- rnorm(10)
res1 &lt;- idtw2vec(Q, newObs = nobs, gcm_lc = res0$gcm_lc_new)

# compare with result from scratch
res2 &lt;- dtw2vec(Q, c(C, nobs))
res1$distance - res2$distance



#--- Perform an incremental DTW calculation with a 
#  customized distance function. 
d_cos &lt;- function(x, y){
   1 - sum(x * y)/(sqrt(sum(x^2)) * sqrt(sum(y^2))) 
}

x &lt;- matrix(rnorm(100), ncol = 5, nrow = 20)
y &lt;- matrix(rnorm(150), ncol = 5, nrow = 30)
cm1 &lt;- cm(x, y, dist_method = d_cos)

# initial calculation
res0 &lt;- idtw2vec(Q = cm(x, y[1:20,], dist_method = d_cos), 
                 newObs =  "cm")

# incremental calculation for new observations
res1 &lt;- idtw2vec(Q = cm(x, y[21:30,], d_cos), newObs =  "cm", 
         gcm_lc = res0$gcm_lc_new)$distance

# compare with result from scratch
res2 &lt;- dtw2vec(Q = cm1, C = "cm")$distance
res1 - res2

</code></pre>

<hr>
<h2 id='initialize_plane'>
Initialize and navigate in the plane of possible fits
</h2><span id='topic+initialize_plane'></span><span id='topic+increment'></span><span id='topic+increment.planedtw'></span><span id='topic+decrement'></span><span id='topic+decrement.planedtw'></span><span id='topic+refresh'></span><span id='topic+refresh.planedtw'></span><span id='topic+reverse'></span><span id='topic+reverse.planedtw'></span><span id='topic+print.planedtw'></span><span id='topic+is.planedtw'></span>

<h3>Description</h3>

<p>Initialize and navigate in the plane of possible fits to detect subsequences (of different lengths) in a long time series that are similar (in terms of DTW distance) to a query pattern: Initialize the plane of possible fits as <code>.planedtw</code> object. Increment and decrement the time series observations and respective DTW calculation. Reverse the time order to increment or decrement observations at the other end of the time horizon. Refresh the DTW calculation without changing the time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_plane(Q, C, dist_method = c("norm1", "norm2", "norm2_square"),
                 step_pattern = c("symmetric2", "symmetric1"), ws = NULL)


## S3 method for class 'planedtw'
increment(x, newObs, direction = c("C", "Q"), ...)

## S3 method for class 'planedtw'
decrement(x, direction = c("C", "Q", "both"), 
          refresh_dtw = FALSE, nC = NULL, nQ = NULL, ...)

## S3 method for class 'planedtw'
refresh(x, ...)

## S3 method for class 'planedtw'
reverse(x, ...)

is.planedtw(x)  

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialize_plane_+3A_q">Q</code></td>
<td>

<p>a time series (vector or matrix for multivariate time series) 
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_c">C</code></td>
<td>

<p>a time series (vector or matrix for multivariate time series) 
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_dist_method">dist_method</code></td>
<td>

<p>character, describes the method of distance measure. See also <code><a href="#topic+dtw">dtw</a></code>.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_step_pattern">step_pattern</code></td>
<td>

<p>character, describes the step pattern. See also <code><a href="#topic+dtw">dtw</a></code>.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_ws">ws</code></td>
<td>

<p>integer, describes the window size for the sakoe chiba window. If NULL, then no window is applied. (default = NULL)
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_x">x</code></td>
<td>

<p>object of class planedtw (output from <code>initialize_plane</code>)
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_newobs">newObs</code></td>
<td>

<p>a time series (vector or matrix for multivariate time series). If <code>Q</code> and <code>C</code> are vectors, newObs must be a vector. If <code>Q</code> and <code>C</code> are matrices with <code>nc</code> columns, then <code>newObs</code> must also have <code>nc</code> columns. See details for the correct time order of <code>newObs</code>.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_direction">direction</code></td>
<td>

<p>character, gives the direction of increment or decrement. <code>decrement()</code> is a wrapper for <code><a href="#topic+dtw_partial">dtw_partial</a></code> and the <code>direction</code> parameter is translated to the respective <code>partial_Q</code> and <code>partial_C</code> parameters.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_refresh_dtw">refresh_dtw</code></td>
<td>

<p>logical (default = FALSE), after decrementing the time series, should the DTW calculation be refreshed, or not.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_nc">nC</code></td>
<td>

<p>integer, default = NULL, if not NULL, then <code>decrement</code> subsets the time series <code>C</code> to the range of <code>1:nC</code>, drops invalid interim calculation results, and refreshes if <code>refresh_dtw = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_nq">nQ</code></td>
<td>

<p>analog to <code>nC</code>
</p>
</td></tr>
<tr><td><code id="initialize_plane_+3A_...">...</code></td>
<td>

<p>additional arguments (currently not used)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions are wrapper functions for <code><a href="#topic+idtw2vec">idtw2vec</a></code> and <code><a href="#topic+dtw_partial">dtw_partial</a></code>. 
</p>

<ul>
<li>
<p><code>initialize_plane</code> calculates the DTW distance between Q and C and saves the last column and row of the global cost matrix. It returns an object of class <code>planedtw</code> that contains all necessary information to incrementally update the DTW calculation with new observations. Also for decrementing the calcultions for skipping some observations at the end.

</p>
</li>
<li>
<p><code>increment</code> updates the DTW calculation by appending new observations to C or Q (depends on the parameter <code>direction</code>) and calculating DTW by recycling previous results represented by <code>gcm_lc_new</code> and <code>gcm_lr_new</code>. A wrapper for <code><a href="#topic+idtw2vec">idtw2vec</a></code>

</p>
</li>
<li>
<p><code>decrement</code> is a wrapper for <code><a href="#topic+dtw_partial">dtw_partial</a></code> and also returns a <code>planedtw</code> object.

</p>
</li>
<li>
<p><code>refresh</code> serves to recalculate the <code>gcm_lc_new</code> and <code>gcm_lr_new</code> from scratch, if these objects are <code>NULL</code> (e.g. after decrementing with <code>refresh_dtw = FALSE</code>).

</p>
</li>
<li>
<p><code>reverse</code> reverses the order of Q and C, and refreshes the calculation for the new order. This is useful for appending observations to Q or C at the other end, the beginning. For incrementing in the reverse order also apply the function <code>increment</code>. Then the time series in the parameter <code>newObs</code> also needs to be in reverse order. 
Assent et al. (2009) proved that the DTW distance is reversible for the step pattern &quot;symmetric1&quot;, so <code>dtw(Q, C) = dtw(rev(Q), rev(C))</code>. Also see examples. For the step pattern &quot;symmetric2&quot; DTW is not exactly reversible, but empirical studies showed that the difference is realtive small. For further details please see the appendix A of the vignette &quot;IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping&quot; on  <a href="https://CRAN.R-project.org/package=IncDTW">CRAN</a>.

</p>
</li></ul>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distance</code></td>
<td>
<p>the DTW distance</p>
</td></tr>
<tr><td><code>normalized_distance</code></td>
<td>
<p>the DTW distance devided by the sum of the lengths of Q and C (see also <code><a href="#topic+dtw">dtw</a></code>).</p>
</td></tr>
<tr><td><code>gcm_lc_new</code></td>
<td>
<p>the last column of the new global cost matrix</p>
</td></tr>
<tr><td><code>gcm_lr_new</code></td>
<td>
<p>the last row of the new global cost matrix</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>the time series</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of input parameters and the lengths of the time series</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Leodolter, M.; Pland, C.; Br√§ndle, N; <em>IncDTW: An R Package for Incremental Calculation of Dynamic Time Warping</em>. Journal of Statistical Software, 99(9), 1-23. doi: <a href="https://doi.org/10.18637/jss.v099.i09">10.18637/jss.v099.i09</a>
</p>
</li>
<li><p> Assent, Ira, et al. &quot;Anticipatory DTW for efficient similarity search in time series databases.&quot; Proceedings of the VLDB Endowment 2.1 (2009): 826-837.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#--- 1. example: Increment too far and take a step back:
rw &lt;- function(nn) cumsum(rnorm(nn))
Q &lt;- sin(1:100)
C &lt;- Q[1:90] + rnorm(90, 0, 0.1)
WS &lt;- 40


# start with the initial calculation
x &lt;- initialize_plane(Q, C, ws = WS)

# Then the incremental calculation for new observations
y1 &lt;- Q[91:95] + rnorm(5, 0, 0.1)# new observations
x &lt;- increment(x, newObs = y1)

# Again new observations -&gt; just increment x
y2 &lt;- c(Q[96:100] + rnorm(5, 0, 0.1), rw(10))# new observations
x &lt;- increment(x, newObs = y2)

# Compare the results with the calculation from scratch
from_scratch &lt;- dtw2vec(Q, c(C, y1, y2) , ws = WS)$normalized_distance
x$normalized_distance - from_scratch
plot(x)

# The plot shows alignments of high costs at the end 
# =&gt; attempt a decremtal step to find better partial matching
x &lt;- decrement(x, direction = "C", refresh_dtw = TRUE)
x
plot(x)


#--- 2. example: First increment, then reverse increment
rw &lt;- function(nn) cumsum(rnorm(nn))
Q &lt;- rw(100)
C &lt;- Q[11:90] + rnorm(80, 0, 0.1)
WS &lt;- 40

# initial calculation
x &lt;- initialize_plane(Q, C, ws = WS)
plot(x)

# incremental calculation for new observations that 
# are appened at the end of C
y1 &lt;- Q[91:100] + rnorm(10, 0, 0.1)
x &lt;- increment(x, newObs = y1)

# reverse the order of Q and C
x &lt;- reverse(x)

# append new observations at the beginning: the new
# obervations must be in the same order as Q and C 
# =&gt; so newObs must be in reverse order, so y2 is 
# defined as Q from 10 to 6 (plus noise).
y2 &lt;- Q[10:6] + rnorm(5, 0, 0.1)
x &lt;- increment(x, newObs = y2)

# another incremental step in the reverse direction
y3 &lt;- Q[5:1] + rnorm(5, 0, 0.1)
x &lt;- increment(x, newObs = y3)

# compare with calculations from scratch, and plot x
from_scratch &lt;- dtw2vec(rev(Q), rev(c(rev(y3), rev(y2), C, y1)),
                        ws = WS)$distance
x$distance - from_scratch
print(x)
plot(x)


## End(Not run)
</code></pre>

<hr>
<h2 id='lowerbound'>
lowerbound
</h2><span id='topic+lowerbound'></span><span id='topic+lowerbound_tube'></span>

<h3>Description</h3>

<p>Calculate the lowerbound for the DTW distance measure in linear time.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowerbound(C, ws, scale = c("z", "01", "none"),
           dist_method = c("norm1", "norm2", "norm2_square"), 
           Q = NULL, tube = NULL)
                     
lowerbound_tube(Q, ws, scale = c("z", "01", "none"))
                     
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lowerbound_+3A_q">Q</code></td>
<td>

<p>vector or matrix, the query time series
</p>
</td></tr>
<tr><td><code id="lowerbound_+3A_c">C</code></td>
<td>

<p>vector or matrix, the query time series
</p>
</td></tr>
<tr><td><code id="lowerbound_+3A_dist_method">dist_method</code></td>
<td>

<p>distance method, one of (&quot;norm1&quot;, &quot;norm2&quot;, &quot;norm2_square&quot;)
</p>
</td></tr>
<tr><td><code id="lowerbound_+3A_scale">scale</code></td>
<td>

<p>either &quot;none&quot;, so no scaling is performed, or one of (&quot;z&quot;, &quot;01&quot;) to scale both Q and C. Also see <code><a href="#topic+dtw">dtw</a></code>
</p>
</td></tr>
<tr><td><code id="lowerbound_+3A_ws">ws</code></td>
<td>

<p>see <code><a href="#topic+dtw">dtw</a></code>
</p>
</td></tr>
<tr><td><code id="lowerbound_+3A_tube">tube</code></td>
<td>
<p>tube for lower bounding. &quot;tube&quot; can be the output from lowerbound_tube(). If tube = NULL, then Q must not be NULL, so that tube can be defined. If the tube is passed as argument to lowerbound(), then it is necessary that the scale parameter in the lowerbound() call is identical to the scaling method applied on Q before calculating the tube.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lower Bounding: The following methods are implemented:
</p>

<ul>
<li> <p><code>LB_Keogh</code> for univariate time series (Keogh et al. 2005)
</p>
</li>
<li> <p><code>LB_MV</code> for multivariate time series with the <code>dist_method = "norm2_square"</code>, (Rath et al. 2002)
</p>
</li>
<li><p> Adjusted for different distance methods &quot;norm1&quot; and &quot;norm2&quot;, inspired by (Rath et al. 2002).
</p>
</li></ul>



<h3>Value</h3>

<p>lowerbound distance measure that is proven to be smaller than the DTW distance measure
</p>


<h3>References</h3>


<ul>
<li><p> Keogh, Eamonn, and Chotirat Ann Ratanamahatana. &quot;Exact indexing of dynamic time warping.&quot; Knowledge and information systems 7.3 (2005): 358-386.
</p>
</li>
<li><p> Rath, Toni M., and R. Manmatha. &quot;Lower-bounding of dynamic time warping distances for multivariate time series.&quot; University of Massachusetts Amherst Technical Report MM 40 (2002).
</p>
</li>
<li><p> Sakurai, Yasushi, Christos Faloutsos, and Masashi Yamamuro. &quot;Stream monitoring under the time warping distance.&quot; Data Engineering, 2007. ICDE 2007. IEEE 23rd International Conference on. IEEE, 2007.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

#--- Univariate time series Q and C
ws &lt;- sample(2:40, size = 1)
dist_method &lt;- "norm1"
N &lt;- 50
N &lt;- 50
Q &lt;- cumsum(rnorm(N))
C &lt;- cumsum(rnorm(N))
Q.z &lt;- IncDTW::scale(Q, "z")
C.z &lt;- IncDTW::scale(C, "z")

lb.z &lt;- lowerbound(C = C.z, ws = ws, scale ="none", dist_method = dist_method, Q = Q.z)
lb &lt;- lowerbound(C = C, ws = ws, scale ="z", dist_method = dist_method, Q = Q)
d1 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric1", 
  dist_method = dist_method, ws = ws)$distance
d2 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric2", 
  dist_method = dist_method, ws = ws)$distance

c(lb, lb.z, d1, d2)


#--- with pre-calculated tube
ws &lt;- sample(2:40, size = 1)
dist_method &lt;- "norm1"
N &lt;- 50
N &lt;- 50
Q &lt;- cumsum(rnorm(N))
C &lt;- cumsum(rnorm(N))
Q.z &lt;- IncDTW::scale(Q, "z")
C.z &lt;- IncDTW::scale(C, "z")

tube &lt;- lowerbound_tube(Q, ws, scale = "z")

lb.z &lt;- lowerbound(C = C.z, ws = ws, scale ="none", dist_method = dist_method, tube = tube)
lb &lt;- lowerbound(C = C, ws = ws, scale ="z", dist_method = dist_method, tube = tube)
d1 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric1", 
  dist_method = dist_method, ws = ws)$distance
d2 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric2", 
  dist_method = dist_method, ws = ws)$distance

c(lb, lb.z, d1, d2)



#--- Multivariate time series Q and C
ws &lt;- sample(2:40, size = 1)
dist_method &lt;- sample(c("norm1", "norm2", "norm2_square"), size = 1)
N &lt;- 50
Q &lt;- matrix(cumsum(rnorm(N * 3)), ncol = 3)
C &lt;- matrix(cumsum(rnorm(N * 3)), ncol = 3)
Q.z &lt;- IncDTW::scale(Q, "z")
C.z &lt;- IncDTW::scale(C, "z")

lb.z &lt;- lowerbound(C = C.z, ws = ws, scale ="none", dist_method = dist_method, Q = Q.z)
lb &lt;- lowerbound(C = C, ws = ws, scale ="z", dist_method = dist_method, Q = Q)
d1 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric1", 
  dist_method = dist_method, ws = ws)$distance
d2 &lt;- dtw2vec(Q = Q.z, C = C.z, step_pattern = "symmetric2", 
  dist_method = dist_method, ws = ws)$distance

c(lb, lb.z, d1, d2)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.dba'>
Plot the results from Dynamic Time Warping Barycenter Averaging
</h2><span id='topic+plot_dba'></span><span id='topic+plot.dba'></span><span id='topic+plotBary'></span><span id='topic+plotM2m'></span><span id='topic+plotM2lot'></span>

<h3>Description</h3>

<p>Plot function for objects of type <code>dba</code>, the output of <code>dba()</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dba'
plot(x, type = c("barycenter", "m2m", "m2lot"), ...)
# an alias for plot_dba
plot_dba(x, type = c("barycenter", "m2m", "m2lot"), ...)

plotBary(x, ...)

plotM2m(x, ...)

plotM2lot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dba_+3A_x">x</code></td>
<td>
<p>output from <code>dba()</code></p>
</td></tr>
<tr><td><code id="plot.dba_+3A_type">type</code></td>
<td>
<p>character, one of c('barycenter', 'm2m', 'm2lot')</p>
</td></tr>
<tr><td><code id="plot.dba_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods. Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>'barycenter'</code> plots the iterations of the barycenter per dimension.
</p>
</li>
<li><p><code>'m2m'</code> plots the distances (distance method set by <code>iter_dist_method</code>, see <code><a href="#topic+dba">dba</a></code>) of one barycenter-iteration to the former iteration step.
</p>
</li>
<li><p><code>'m2lot'</code> plots the distances (if <code>step_pattern == 'symmetric2'</code> the normalized distances are plotted) of the barycenter to the list of time series per iteration.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+dba">dba</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see examples of dba()
</code></pre>

<hr>
<h2 id='plot.idtw'>
Plot the results from Dynamic Time Warping
</h2><span id='topic+plot_idtw'></span><span id='topic+plot.idtw'></span><span id='topic+plot_planedtw'></span><span id='topic+plot.planedtw'></span><span id='topic+plotQC'></span><span id='topic+plotWarp'></span>

<h3>Description</h3>

<p>Plot function for objects of type <code>idtw</code>, the output of <code>dtw()</code> and <code>idtw()</code> respectively.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'idtw'
plot(x, type = c("QC", "warp"), partial = NULL, selDim = 1, ...)
        
# an alias for plot_idtw
plot_idtw(x, type = c("QC", "warp"), partial = NULL, selDim = 1, ...)

## S3 method for class 'planedtw'
plot(x, type = c("QC", "warp"), partial = NULL, selDim = 1, ...)

# an alias for plot_planedtw
plot_planedtw(x, type = c("QC", "warp"), partial = NULL, selDim = 1, ...)

plotQC(x, Q, C, partial = NULL, selDim = 1, ...)

plotWarp(x, Q, C, partial = NULL, selDim = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.idtw_+3A_x">x</code></td>
<td>
<p>output from <code>dtw(Q, C)</code></p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_q">Q</code></td>
<td>
<p>one dimensional numeric vector</p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_c">C</code></td>
<td>
<p>one dimensional numeric vector</p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_type">type</code></td>
<td>
<p>character, one of c('QC', 'warp')</p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_partial">partial</code></td>
<td>
<p>list, the return value of <code><a href="#topic+dtw_partial">dtw_partial</a>()</code>. Default = NULL, see <code><a href="#topic+dtw_partial">dtw_partial</a>()</code> for details.</p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_seldim">selDim</code></td>
<td>
<p>integer, gives the column index of the multivariate time series (matrices) to be plotted. (default = 1) If Q and C are univariate time series (vectors) then selDim is neglected. </p>
</td></tr>
<tr><td><code id="plot.idtw_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot function visualizes the time warp and the alignment of the two time series. Also for partial alignments see <code><a href="#topic+dtw_partial">dtw_partial</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Q &lt;- cumsum(rnorm(100))
C &lt;- Q[11:100] + rnorm(90, 0, 0.5)
tmp &lt;- dtw(Q = Q, C = C, ws = 15, return_wp = TRUE, return_QC = TRUE) 

plot(tmp, type = 'QC')
plotQC(tmp)
plot(tmp, type = 'warp')
plotWarp(tmp)


</code></pre>

<hr>
<h2 id='plot.rundtw'>
Plot
</h2><span id='topic+plot_rundtw'></span><span id='topic+plot.rundtw'></span>

<h3>Description</h3>

<p>Plot the results from <code><a href="#topic+rundtw">rundtw</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rundtw'
plot(x, knn = TRUE, minima = TRUE, 
     scale = c("none", "01", "z"), 
     selDim = 1, lix = 1, Q = NULL, C = NULL, normalize = c("none", "01", "z"),  ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rundtw_+3A_x">x</code></td>
<td>

<p>output from <code><a href="#topic+rundtw">rundtw</a></code>
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_knn">knn</code></td>
<td>

<p>logical, if TRUE ( = default) and the k nearest neighbors were found by <code><a href="#topic+rundtw">rundtw</a></code>, then they are plotted. See details.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_minima">minima</code></td>
<td>

<p>logical, if TRUE ( = default) and <code>Q</code> is either passed or also returned by <code><a href="#topic+rundtw">rundtw</a></code> then the local (with window size of the lengh of <code>Q</code>) minima of the vector of distances is plotted. See details. 
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_scale">scale</code></td>
<td>

<p>character, one of c(&quot;none&quot;, &quot;01&quot;, &quot;z&quot;). If &quot;01&quot; or &quot;z&quot; then the detected minima and knn are normed and plotted.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_seldim">selDim</code></td>
<td>

<p>integer vector, default = 1. Set the dimensions to be plotted for multivariate time series <code>Q</code> and <code>C</code>.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_lix">lix</code></td>
<td>

<p>list index, integer, default = 1. If <code>C</code> is a list of time series, set with <code>lix</code> the list entry of <code>C</code> to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_q">Q</code></td>
<td>

<p>time series, default = NULL, either passed as list entry of <code>x</code> (when the parameter <code>return_QC</code> of <code><a href="#topic+rundtw">rundtw</a></code> is set to TRUE) or passed manually. Necessary for plotting the minima.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_c">C</code></td>
<td>

<p>time series, default = NULL, either passed as list entry of <code>x</code> (when the parameter <code>return_QC</code> or <code><a href="#topic+rundtw">rundtw</a></code> is set to TRUE) or passed manually. Necessary for plotting the minima and knn.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_normalize">normalize</code></td>
<td>
<p>deprecated, use <code>scale</code> instead. If <code>normalize</code> is set, then <code>scale</code> is overwritten by <code>normalize</code> for compatibility.
</p>
</td></tr>
<tr><td><code id="plot.rundtw_+3A_...">...</code></td>
<td>

<p>additional arguments passed to ggplot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only for those subsequences for which the calculations were finished by  <code>rundtw</code>, the distances  are plotted (see the parameters <code>threshold</code>, <code>k</code> and <code>early_abandon</code> of <code><a href="#topic+rundtw">rundtw</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rundtw">rundtw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- Simulate a query pattern Q and a longer time series C,
# and detect rescaled versions of Q in C
set.seed(123)
Q &lt;- sin(seq(0, 2*pi, length.out = 20))
Q_rescaled &lt;- Q * abs(rnorm(1)) + rnorm(1)
C &lt;- c(rnorm(20), Q_rescaled , rnorm(20))

# Force rundtw to finish all calculations and plot the vector of DTW distances
ret &lt;- rundtw(Q, C, threshold = NULL, lower_bound = FALSE)
ret
plot(ret)

# Allow early abandoning and lower bounding, and also plot C
ret &lt;- rundtw(Q, C, return_QC = TRUE, ws = 5)
ret
plot(ret)

# Get 1 nearest neighbor -&gt; allow early abandon and lower bounding,
# and plot C and also plot the scaled detected nearest neighbors
ret &lt;- rundtw(Q, C, ws = 5, k = 1, return_QC = TRUE)
ret
plot(ret, scale = "01")


#--- See the help page of rundtw() for further examples.

</code></pre>

<hr>
<h2 id='rundtw'>
rundtw
</h2><span id='topic+rundtw'></span><span id='topic+print.rundtw'></span><span id='topic+summary.rundtw'></span><span id='topic+is.rundtw'></span>

<h3>Description</h3>

<p>Detect recurring patterns similar to given query pattern by measuring the distance with DTW. A window of the length of the query pattern slides along the longer time series and calculates computation-time-efficiently the DTW distance for each point of time. The function incrementally updates the scaling of the sliding window, incrementally updates the cost matrix, applies the vector-based implementation of the DTW algorithm, early abandons and applies lower bounding methods to decrease the calculation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rundtw(Q, C, dist_method = c("norm1", "norm2", "norm2_square"), 
      step_pattern = c("symmetric1", "symmetric2"), k = NULL, 
      scale = c("01", "z", "none"), ws = NULL, threshold = NULL, 
      lower_bound = TRUE, overlap_tol = 0, return_QC = FALSE,
      normalize = c("01", "z", "none"))
      
## S3 method for class 'rundtw'
print(x, ...)

## S3 method for class 'rundtw'
summary(object, ...)

is.rundtw(x) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rundtw_+3A_q">Q</code></td>
<td>

<p>vector or matrix, the query time series
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_c">C</code></td>
<td>

<p>vector or matrix (equal number of columns as Q), the longer time series which is scanned for multiple fits of the query time series. C can also be a list of time series (either all vectors, or all matrices of equal number of columns) with varying lengths. See Details.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_dist_method">dist_method</code></td>
<td>

<p>see <code><a href="#topic+dtw">dtw</a></code>
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_step_pattern">step_pattern</code></td>
<td>

<p>see <code><a href="#topic+dtw">dtw</a></code>, only for &quot;symmetric1&quot; the lower bounding is implemented yet
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_k">k</code></td>
<td>

<p>integer &gt;= 0. If <code>k &gt; 0</code>, then the k-nearest neighbors to the query pattern that are found in all possible sub-sequences of the long time series C are returned. Per default the found fits don't overlap, except the <code>overlap_tol</code> parameter is adjusted (this should be done with care!). If <code>k &gt; 0</code> then <code>lowerbound</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_scale">scale</code></td>
<td>

<p>character, one of c(&quot;01&quot;, &quot;z&quot;, &quot;none&quot;) (default = &quot;01&quot;), if not &quot;none&quot; then <code>Q</code> (once at the start) and <code>C</code> (running scaling) are scaled. Either min-max (&quot;01&quot;) or the z-scaling (&quot;z&quot;)  is applied. TRUE (identical to '01') and FALSE (identical to 'none') are deprecated and will be dropped in the next package version.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_ws">ws</code></td>
<td>

<p>see <code><a href="#topic+dtw">dtw</a></code>
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_threshold">threshold</code></td>
<td>

<p>numeric &gt;= 0, global threshold for early abandoning DTW calculation if this threshold is hit. (also see <code><a href="#topic+dtw">dtw</a></code>). If NULL (default) no early abandoning is applied.  
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_lower_bound">lower_bound</code></td>
<td>

<p>logical, (default = TRUE) If TRUE (default) then lower bounding is applied (see Details).
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_overlap_tol">overlap_tol</code></td>
<td>

<p>integer between 0 and length of Q, (default = 0) gives the number of observations that two consecutive fits are accepted to overlap. 
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_return_qc">return_QC</code></td>
<td>
<p>logical, default = FALSE. If TRUE then <code>Q</code> and <code>C</code> are appended to the return list.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_normalize">normalize</code></td>
<td>
<p>deprecated, use <code>scale</code> instead. If <code>normalize</code> is set, then <code>scale</code> is overwritten by <code>normalize</code> for compatibility.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_x">x</code></td>
<td>
<p>the output object from <code><a href="#topic+rundtw">rundtw</a></code>.
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_object">object</code></td>
<td>
<p>any R object
</p>
</td></tr>
<tr><td><code id="rundtw_+3A_...">...</code></td>
<td>
<p>further arguments passed to print or summary.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function and algorithm was inspired by the work of Sakurai et al. (2007) and refined for running min-max scaling and lower bounding.
</p>
<p>Lower Bounding: The following methods are implemented:
</p>

<ul>
<li> <p><code>LB_Keogh</code> for univariate time series (Keogh et al. 2005)
</p>
</li>
<li> <p><code>LB_MV</code> for multivariate time series with the <code>dist_method = "norm2_square"</code>, (Rath et al. 2002)
</p>
</li>
<li><p> Adjusted for different distance methods &quot;norm1&quot; and &quot;norm2&quot;, inspired by (Rath et al. 2002).
</p>
</li></ul>

<p>Counter vector:
</p>

<ul>
<li><p> &quot;scale_reset&quot; counts how many times the min and max of the sliding window and the scaling need to be reset completely
</p>
</li>
<li><p> &quot;scale_new_extreme&quot; how many times the min or max of the sliding window are adjusted incrementally and the scaling need to be reset completely
</p>
</li>
<li><p> &quot;scale_1step&quot; how many times only the new observation in the sliding window needs to be scaled based on the current min and max
</p>
</li>
<li><p> &quot;cm_reset&quot; how many times the cost matrix for the sliding window needs to be recalculated completely
</p>
</li>
<li><p> &quot;cm_1step&quot; how many times only the front running column of the cost matrix is calculated
</p>
</li>
<li><p> &quot;early_abandon&quot; how many times the early abandon method aborts the DTW calculation before finishing
</p>
</li>
<li><p> &quot;lower_bound&quot; how many times the lower bounding stops the initialization of the DTW calculation
</p>
</li>
<li><p> &quot;completed&quot; for how many subsequences the DTW calculation finished
</p>
</li></ul>

<p>C is a list of time series:
If C is a list of time series, the algorithm concatenates the list to one long time series to apply the logic of early abandoning, lower bounding, and finding the kNN. Finally the results are split to match the input. The 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>dist</code></td>
<td>
<p>vector of DTW distances</p>
</td></tr>
<tr><td><code>counter</code></td>
<td>
<p>named vector of counters. Gives information how the algorithm proceeded. see Details</p>
</td></tr>
<tr><td><code>knn_indices</code></td>
<td>
<p>indices of the found kNN</p>
</td></tr>
<tr><td><code>knn_values</code></td>
<td>
<p>DTW distances of the found kNN</p>
</td></tr>
<tr><td><code>knn_list_indices</code></td>
<td>
<p>indices of list entries of C, where to find the kNN. Only returned if C is a list of time series. See examples.</p>
</td></tr>
<tr><td><code>Q</code>, <code>C</code></td>
<td>
<p>input time series</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Keogh, Eamonn, and Chotirat Ann Ratanamahatana. &quot;Exact indexing of dynamic time warping.&quot; Knowledge and information systems 7.3 (2005): 358-386.
</p>
</li>
<li><p> Rath, Toni M., and R. Manmatha. &quot;Lower-bounding of dynamic time warping distances for multivariate time series.&quot; University of Massachusetts Amherst Technical Report MM 40 (2002).
</p>
</li>
<li><p> Sakurai, Yasushi, Christos Faloutsos, and Masashi Yamamuro. &quot;Stream monitoring under the time warping distance.&quot; Data Engineering, 2007. ICDE 2007. IEEE 23rd International Conference on. IEEE, 2007.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#--- Simulate a query pattern Q and a longer time series C with
# distorted instances of Q within C. Apply rundtw() do detect 
# these instances of C. 

rw &lt;- function(nr) cumsum(rnorm(nr))
noise &lt;- function(nr) rnorm(nr)
set.seed(1234)
nC &lt;- 500
nQ &lt;- 40
nfits &lt;- 5

nn &lt;- nC - nfits * nQ # length of noise
nn &lt;- nn/nfits + 1

Q &lt;- sin(seq(from = 1, to = 4 * pi, length.out = nQ))
Qscale &lt;- IncDTW::scale(Q, type = "01")
C &lt;- rw(0)
for(i in 1:nfits){
   C &lt;- c(C, rw(nn)  , 
          Q * abs(rnorm(1, 10, 10)) + 
            rnorm(1, 0, 10) + noise(nQ))
}

# Apply running min-max scaling and allow lower 
# bounding to find the 3 NN
x &lt;- rundtw(Q, C, scale = '01', ws = 10, k = 3, 
            lower_bound = TRUE, return_QC = TRUE)

# Have a look at the result and get the best indices 
# with lowest distance.
x
summary(x)
find_peaks(x$dist, nQ)
plot(x, scale = "01")

# The fourth and fifth simuated fits are not returned, 
# since the DTW distances are higher than the other found 3 NN. 
# The algorithm early abandons and returns NA for these 
# indices. Get all distances by the following command:
x_all &lt;- rundtw(Q, C, scale = '01', ws = 10, 
                k = 0, lower_bound = FALSE)
plot(x_all)

# Do min-max-scaling and lower bound
rundtw(Q, C, scale = '01', ws = 10, lower_bound = TRUE)

# Do z-scaling and lower bound
rundtw(Q, C, scale = 'z', ws = 10, lower_bound = TRUE)

# Don't scaling and don't lower bound
rundtw(Q, C, scale = 'none', ws = 10, lower_bound = FALSE)

# kNN: Do z-scaling and lower bound 
rundtw(Q, C, scale = 'z', ws = 10, k = 3)



#--- For multivariate time series
rw &lt;- function(nr, nco) {
        matrix(cumsum(rnorm(nr * nco)), nrow = nr, ncol = nco)
}

nC &lt;- 500
nQ &lt;- 50
nco &lt;- 2
nfits &lt;- 5

nn &lt;- nC - nfits * nQ# length of noise
nn &lt;- nn/nfits

Q &lt;- rw(nQ, nco)
Qscale &lt;- IncDTW::scale(Q, type="01")
C &lt;- matrix(numeric(), ncol=nco)
for(i in 1:nfits){
   C &lt;- rbind(C, rw(nn, nco), Q)
}

# Do min-max-scaling and lower bound
rundtw(Q, C, scale = '01', ws = 10, threshold = Inf, 
       lower_bound = TRUE)

# Do z-scaling and lower bound
rundtw(Q, C, scale = 'z', ws = 10, threshold = NULL, 
       lower_bound = TRUE)

# Don't scale and don't lower bound
rundtw(Q, C, scale = 'none', ws = 10, threshold = NULL, 
       lower_bound = FALSE)



#--- C can also be a list of (multivariate) time series. 
# So rundtw() detects the closest fits of a query pattern
# across all time series in C.
nC &lt;- 500
nQ &lt;- 50
nco &lt;- 2
rw &lt;- function(nr, nco){
        matrix(cumsum(rnorm(nr * nco)), nrow = nr, ncol = nco)
}

Q &lt;- rw(nQ, nco)
C1 &lt;- rbind(rw(100, nco), Q, rw(20, nco))
C2 &lt;- rbind(rw(10, nco), Q, rw(50, nco))
C3 &lt;- rbind(rw(200, nco), Q, rw(30, nco))
C_list &lt;- list(C1, C2, C3)

# Do min-max-scaling and lower bound
x &lt;- rundtw(Q, C_list, scale = '01', ws = 10, threshold = Inf, 
            lower_bound = TRUE, k = 3, return_QC = TRUE)
x
# Plot the kNN fit of the 2nd or 3rd list entry of C
plot(x, lix = 2)
plot(x, lix = 3)

# Do z-scaling and lower bound
rundtw(Q, C_list, scale = 'z', ws = 10, threshold = Inf, 
       lower_bound = TRUE, k = 3)

# Don't scale and don't lower bound
x &lt;- rundtw(Q, C_list, scale = 'none', ws = 10, 
            lower_bound = FALSE, k = 0, return_QC = TRUE)
x
plot(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='scale'>
Time Series Scaling
</h2><span id='topic+scale'></span><span id='topic+norm'></span>

<h3>Description</h3>

<p>scales a time series per dimension/column. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale(x, type = c('z', '01'), threshold = 1e-5,
     xmean = NULL, xsd = NULL, xmin = NULL, xmax = NULL)

# deprecated
norm(x, type = c('z', '01'), threshold = 1e-5,
     xmean = NULL, xsd = NULL, xmin = NULL, xmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>time series as vector or matrix
</p>
</td></tr>
<tr><td><code id="scale_+3A_type">type</code></td>
<td>
<p>character, describes the method how to scale (or normalize) the time series (per column if x is multivariate). The parameter type is either 'z' for z-scaling or '01' for max-min scaling.
</p>
</td></tr>
<tr><td><code id="scale_+3A_threshold">threshold</code></td>
<td>

<p>double, defines the minimum value of the standard deviation, or difference of minimum and maximum. If this value is smaller than the threshold, then no scaling is performed, only shifting by the mean or minimum, respectively. Default value = <code>1e-5</code>.
</p>
</td></tr>
<tr><td><code id="scale_+3A_xmean">xmean</code></td>
<td>
<p>mean used for z-scaling. See details.
</p>
</td></tr>
<tr><td><code id="scale_+3A_xsd">xsd</code></td>
<td>
<p>standard deviation used for z-scaling. See details.
</p>
</td></tr>
<tr><td><code id="scale_+3A_xmin">xmin</code></td>
<td>
<p>minimum used for 0-1 scaling. See details.
</p>
</td></tr>
<tr><td><code id="scale_+3A_xmax">xmax</code></td>
<td>
<p>maximum used for 0-1 scaling. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a vector <code>x</code> the z-scaling subtracts the mean and devides by the standard deviation:  of <code>(x-mean(x))/sd(x)</code>. The min-max scaling performs <code>(x-min(x))/(max(x)-min(x))</code>.
</p>
<p>The parameters <code>xmean</code>, <code>xsd</code>, <code>xmin</code>, can be set <code>xmax</code> or passed as <code>NULL</code> (= default value). If these values are NULL, they are calculated based on x.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the scaled vector or matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# min-max scaling or z-scaling for a vector 
x &lt;- cumsum(rnorm(100, 10, 5))
y &lt;- scale(x, "01")
z &lt;- scale(x, "z")
par(mfrow = c(1, 3))
plot(x, type="l")
plot(y, type="l")
plot(z, type="l")
par(mfrow = c(1, 1))


# columnwise for matrices
x &lt;- matrix(c(1:10, sin(1:10)), ncol = 2)
y &lt;- scale(x, "01")
z &lt;- scale(x, "z")
par(mfrow = c(1, 3))
matplot(x, type="l")
matplot(y, type="l")
matplot(z, type="l")
par(mfrow = c(1, 1))


# IncDTW::scale() and base::scale() perform same z-scaling
x &lt;- cumsum(rnorm(100))
xi &lt;- IncDTW::scale(x, type = "z")
xb &lt;- base::scale(x, TRUE, TRUE)
sum(abs(xi-xb))
</code></pre>

<hr>
<h2 id='simulate_timewarp'>
Simulate time warp
</h2><span id='topic+simulate_timewarp'></span><span id='topic+insert_const'></span><span id='topic+insert_linear_interp'></span><span id='topic+insert_norm'></span><span id='topic+insert_linear_norm'></span>

<h3>Description</h3>

<p>Simulate a time warp for a given time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_timewarp(x, stretch = 0, compress = 0, 
                  stretch_method = insert_linear_interp,
                  p_index = "rnorm", p_number = "rlnorm", 
                  p_index_list = NULL, p_number_list = NULL, 
                  preserve_length = FALSE, seed = NULL, ...) 


insert_const(x, ix, N, const = NULL)

insert_linear_interp(x, ix, N)

insert_norm(x, ix, N, mean = 0, sd = 1)

insert_linear_norm(x, ix, N, mean = 0, sd = 1)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_timewarp_+3A_x">x</code></td>
<td>
<p>time series, vector or matrix</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_stretch">stretch</code></td>
<td>
<p>numeric parameter for stretching the time series. <code>stretch &gt;= 0</code>, see details</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_compress">compress</code></td>
<td>
<p>numeric parameter for compressing the time series. <code>compress &gt;= 0 &amp; compress &lt; 1</code>, see details</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_stretch_method">stretch_method</code></td>
<td>
<p>function, either one of (insert_const, insert_linear_interp,
insert_norm, insert_linear_norm), or any user defined function that needs the parameters <code>x</code> (univariate time series as vector), <code>ix</code> (index where to insert), <code>N</code> (number of observations to insert) and any other arguments required for that function. See Details. </p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_p_index">p_index</code></td>
<td>
<p>string, distribution for simulating the indices where to insert simulated observations, e.g. &quot;rnorm&quot;, &quot;runif&quot;, etc.</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_p_number">p_number</code></td>
<td>
<p>string, distribution for simulating the number of observations to insert per index, e.g. &quot;rnorm&quot;, &quot;runif&quot;, etc.</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_p_index_list">p_index_list</code></td>
<td>
<p>list of named parameters for the distribution <code>p_index</code></p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_p_number_list">p_number_list</code></td>
<td>
<p>list of named parameters for the distribution <code>p_number</code></p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_preserve_length">preserve_length</code></td>
<td>
<p>logical, if TRUE (default = FALSE) then the length of the return time series is the same as before the warping, so the compression and stretching do not change the length of the time series, nevertheless perform local warpings</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_seed">seed</code></td>
<td>
<p>set a seed for reproducible results</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_...">...</code></td>
<td>
<p>named parameters for the <code>stretch_method</code></p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_ix">ix</code></td>
<td>
<p>index of x where after which to insert</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_n">N</code></td>
<td>
<p>number of simulated observations to insert at index ix</p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_const">const</code></td>
<td>
<p>the constant to be inserted, if NULL (default), then <code>const &lt;- x[ix]</code></p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_mean">mean</code></td>
<td>
<p>mean for <code>rnorm</code></p>
</td></tr>
<tr><td><code id="simulate_timewarp_+3A_sd">sd</code></td>
<td>
<p>sd for <code>rnorm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different distributions <code>p_index</code> and <code>p_number</code> also determine the behavior of the warp. A uniform distribution for <code>p_number</code> more likely draws high number than e.g. log-normal distributions with appropriate parameters. So, a uniform distribution more likely simulates fewer, but longer warps, that is points of time where the algorithm inserts simulations.
</p>
<p>The algorithm stretches by randomly selecting an index between 1 and the length of the time series. Then a number of observations to be inserted is drawn out of the range 1 to the remaining number of observations to be inserted. These observations are inserted. Then the algorithm starts again with drawing an index, drawing a number of observations to be inserted, and proceeds until the requested time series length is achieved.
</p>
<p>The algorithm for compressing works analogous, except it simply omits observations instead of linear interpolation.
</p>
<p>The parameter <code>stretch</code> describes the ratio how much the time series <code>x</code> is stretched:
e.g. if <code>compress = 0</code> and ...
</p>

<ul>
<li> <p><code>stretch = 0</code> then <code>length(x_new) = length(x)</code>, or
</p>
</li>
<li> <p><code>stretch = 0.1</code> then <code>length(x_new) = length(x) * 1.1</code>, or             
</p>
</li>
<li> <p><code>stretch = 1</code> then <code>length(x_new) = length(x) * 2</code>                        
</p>
</li></ul>

<p>The parameter <code>compress</code> describes the ratio how much the time series <code>x</code> is compressed:
e.g. if <code>stretch = 0</code> and ...
</p>

<ul>
<li> <p><code>compress = 0</code> then <code>length(x_new) = length(x)</code>, or
</p>
</li>
<li> <p><code>compress = 0.2</code> then <code>length(x_new) = length(x) * 0.8</code>
</p>
</li></ul>

<p>There are four functions to chose from to insert new simulated observations. You can also define your own function and apply this one. The four functions to chose from are:
</p>

<ul>
<li><p> insert a constant, either a constant defined by the user via the input parameter <code>const</code>, or if <code>const = NULL</code>, then the last observation of the time series where the insertion starts is set as <code>const</code>
</p>
</li>
<li><p> insert linear interpolated observations (default)
</p>
</li>
<li><p> insert a constant with gaussian noise 
</p>
</li>
<li><p> insert linear interpolated observations and add gaussian noise.
</p>
</li></ul>

<p>For the methods with Gaussian noise the parameters <code>mean</code> and <code>sd</code> for <code>rnorm</code> can be set at the function call of <code>simulate_timewarp()</code>.
</p>


<h3>Value</h3>

<p>A time warped time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#--- Simulate a time warped version of a time series x
set.seed(123)
x &lt;- cumsum(rnorm(100))
x_warp &lt;- simulate_timewarp(x, stretch = 0.1, compress = 0.2, seed = 123) 
plot(x, type = "l")
lines(x_warp, col = "red")


#--- Simulate a time warp of a multivariate time series
y &lt;- matrix(cumsum(rnorm(10^3)), ncol = 2)
y_warp &lt;- simulate_timewarp(y, stretch = 0.1, compress = 0.2, seed = 123) 
plot(y[,1], type = "l")
lines(y_warp[,1], col = "red")


#--- Stretchings means to insert at new values at randomly 
# selected points of time. Next the new values are set as constant NA,
# and the points of time simulated uniformly:
y_warp &lt;- simulate_timewarp(y, stretch = 0.2, p_number = "runif", p_index = "runif",
                            stretch_method = insert_const, 
                            const = NA)
matplot(y_warp, type = "l")


# insert NA and simulate the points of time by log normal
y_warp &lt;- simulate_timewarp(y, stretch = 0.2, p_number = "rlnorm", 
                            p_number_list = list(meanlog = 0, sdlog = 1),
                            stretch_method = insert_const, 
                            const = NA)
matplot(y_warp, type = "l")


# insert linear interpolation
y_warp &lt;- simulate_timewarp(y, stretch = 0.2, p_number = "rlnorm", 
                            stretch_method = insert_linear_interp)
matplot(y_warp, type = "l")


# insert random walk with gaussian noise
y_warp &lt;- simulate_timewarp(y, stretch = 0.2, p_number = "rlnorm", 
                            stretch_method = insert_norm,
                            sd = 1, mean = 0)
matplot(y_warp, type = "l")


# insert constant, only 1 observation per random index
y_warp &lt;- simulate_timewarp(y, stretch = 0.2, p_number = "runif", p_index = "runif",
                            p_number_list = list(min = 1, max = 1),   
                            stretch_method = insert_const)
matplot(y_warp, type = "l")


# insert by customized insert function
my_stretch_method &lt;- function(x, ix, N, from, to){
   c(x[1:ix], 
     sin(seq(from = from, to = to, length.out = N)) + x[ix],
     x[(ix + 1):length(x)])
}
y_warp &lt;- simulate_timewarp(y, stretch = 0.5, p_number = "rlnorm", 
                            stretch_method = my_stretch_method,
                            from = 0, to = 4 * pi)
matplot(y_warp, type = "l")


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
