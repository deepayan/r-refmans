<!DOCTYPE html><html><head><title>Help for package epinet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epinet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BuildX'><p>Build a dyadic covariate matrix (X)</p></a></li>
<li><a href='#epi2newick'><p>Prints a transmission tree in Newick format.</p></a></li>
<li><a href='#epinet'><p>Uses epidemic data to perform Bayesian inference on a contact network</p></a></li>
<li><a href='#epinet-internal'><p>Internal epinet Objects</p></a></li>
<li><a href='#ess'><p>Calculate the Effective Sample Size</p></a></li>
<li><a href='#Hagelloch'><p>Hagelloch measles data.</p></a></li>
<li><a href='#MCMCcontrol'><p>Set control parameters for epinet MCMC algorithm</p></a></li>
<li><a href='#plot.epidemic'><p>Plot the spread of an epidemic</p></a></li>
<li><a href='#plot.epinet'><p>Plot the spread of an epidemic</p></a></li>
<li><a href='#print.epidemic'><p>Prints an epidemict object</p></a></li>
<li><a href='#print.epinet'><p>Print basic information about an epinet object</p></a></li>
<li><a href='#priorcontrol'><p>Set prior distributions and hyperparameters for epinet MCMC algorithm</p></a></li>
<li><a href='#SEIR.simulator'><p>Simulate an epidemic on a contact network</p></a></li>
<li><a href='#SimulateDyadicLinearERGM'><p>Simulates an ERGM network using given covariate values</p></a></li>
<li><a href='#summary.epidemic'><p>Summarize simulated epidemic</p></a></li>
<li><a href='#summary.epinet'><p>Summarize posterior samples from epinet object</p></a></li>
<li><a href='#write.epinet'><p>Writes posterior samples from an epinet object to an output file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Epidemic/Network-Related Tools</td>
</tr>
<tr>
<td>Imports:</td>
<td>network</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of epidemic/network-related tools. Simulates transmission of diseases through contact networks. Performs Bayesian inference on network and epidemic parameters, given epidemic data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 19:20:48 UTC; groendyke</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Groendyke [aut, cre],
  David Welch [aut],
  David Hunter [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Groendyke &lt;cgroendyke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BuildX'>Build a dyadic covariate matrix (X)</h2><span id='topic+BuildX'></span>

<h3>Description</h3>

<p>Build a dyadic covariate matrix (X) from a given nodal covariate matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildX(nodecov, unaryCol = NULL, unaryFunc = NULL, 
	binaryCol = NULL, binaryFunc = NULL, includeIntercept = TRUE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildX_+3A_nodecov">nodecov</code></td>
<td>
<p>an N x k matrix where N is the number of nodes, column 1 is the node id and columns 2:k are covariate values for the node</p>
</td></tr>
<tr><td><code id="BuildX_+3A_unarycol">unaryCol</code></td>
<td>
<p>a vector of column indices</p>
</td></tr>
<tr><td><code id="BuildX_+3A_unaryfunc">unaryFunc</code></td>
<td>
<p>a vector of the same length as unaryCol of method names for comparing dyads.  Possible method names are &quot;match&quot; and &quot;absdiff&quot;</p>
</td></tr>
<tr><td><code id="BuildX_+3A_binarycol">binaryCol</code></td>
<td>
<p>a list of 2 element vectors of column indices</p>
</td></tr>
<tr><td><code id="BuildX_+3A_binaryfunc">binaryFunc</code></td>
<td>
<p>a vector of the same length as binaryCol of method names for comparing dyads.  Possible method names are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="BuildX_+3A_includeintercept">includeIntercept</code></td>
<td>
<p>logical.  If TRUE, includes a column of all ones.  Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dyadic covariate matrix with <code class="reqn">{N \choose 2}</code> rows, columns 1 and 2 are node ids, column 3 is all ones (if requested) and then one column for each given element of unaryCol and binaryCol.  
</p>
<p>Assigns colnames depending on type of unaryFunc and binaryFunc and colnames of nodecov.
</p>


<h3>Author(s)</h3>

<p>  David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>, Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateDyadicLinearERGM">SimulateDyadicLinearERGM</a></code> for simulating a
contact network based on a dyadic covairate matrix, and <code><a href="#topic+epinet">epinet</a></code> for performing
inference on the network and epidemic model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make some nodal covariates
set.seed(3)
mycov = data.frame(id = 1:5, xpos = rnorm(5), ypos = rnorm(5), 
	house = c(1, 1, 2, 2, 2), gender = c(0, 0, 0, 1, 1))
# make matrix 
dyadCov = BuildX(mycov, unaryCol = c(4, 5), unaryFunc = c("match", "match"), 
	binaryCol = list(c(2, 3)), binaryFunc = "euclidean")
</code></pre>

<hr>
<h2 id='epi2newick'>Prints a transmission tree in Newick format.</h2><span id='topic+epi2newick'></span><span id='topic+epi2newickmcmc'></span>

<h3>Description</h3>

<p>Prints a simulated or inferred transmission tree in Newick format.</p>


<h3>Usage</h3>

<pre><code class='language-R'>epi2newick(epi)

epi2newickmcmc(mcmcoutput, index = dim(mcmcoutput$transtree)[2])</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epi2newick_+3A_epi">epi</code></td>
<td>
<p>a simulated epidemic, in the form of the
output produced by <code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code>.</p>
</td></tr>
<tr><td><code id="epi2newick_+3A_mcmcoutput">mcmcoutput</code></td>
<td>
<p>output from <code><a href="#topic+epinet">epinet</a></code>.</p>
</td></tr>
<tr><td><code id="epi2newick_+3A_index">index</code></td>
<td>
<p>a number indicating which of the MCMC
samples to plot. Defaults to the final sample in the chain.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Converts the epinet epidemic format into a transmssion tree represented as a Newick string which is the standard tree format used in phylogenetics.  There are many packages available to analyse Newick format trees such as the ape package, IcyTree and FigTree. 
</p>


<h3>Value</h3>

<p>A character string representing the epidemic transmission tree in Newick format.  Note that this string contains control characters that can be removed by using <code><a href="base.html#topic+cat">cat</a></code></p>


<h3>Author(s)</h3>

<p> David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>,
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a> </p>


<h3>References</h3>

<p>Rambaut A. 2014. FigTree v1.4. <a href="http://tree.bio.ed.ac.uk/software/figtree/">http://tree.bio.ed.ac.uk/software/figtree/</a>.
Vaughan T. 2015. IcyTree <a href="https://icytree.org">https://icytree.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters, 
<code><a href="#topic+print.epinet">print.epinet</a></code> and <code><a href="#topic+summary.epinet">summary.epinet</a></code> for printing basic
summary information about an epinet object, <code><a href="#topic+write.epinet">write.epinet</a></code> for
writing parameter and transmission tree posterior samples to file, and
<code><a href="#topic+plot.epinet">plot.epinet</a></code> for plotting the posterior samples of the transmission tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist="gamma")
cat(epi2newick(exampleepidemic))

## Not run: 
# Build covariates
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov,binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0, -7)
net &lt;- SimulateDyadicLinearERGM(N = N,dyadiccovmat = dyadCov,eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M=net,N=N,beta=1,ki=3,thetai=7,ke=3,latencydist="gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)
cat(epi2newickmcmc(out))
## End(Not run)
</code></pre>

<hr>
<h2 id='epinet'>Uses epidemic data to perform Bayesian inference on a contact network</h2><span id='topic+epibayesmcmc'></span><span id='topic+epinet'></span>

<h3>Description</h3>

<p>Performs Bayesian inference on parameters
for an SEIR epidemic model and a random graph
model, given recovery (and perhaps also exposure/infective) times
for each individual infected during the course of an epidemic.</p>


<h3>Usage</h3>

<pre><code class='language-R'>epinet(formula, epidata, dyadiccovmat, mcmcinput = MCMCcontrol(), 
	priors = priorcontrol(), verbose = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epinet_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> giving a symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="epinet_+3A_epidata">epidata</code></td>
<td>
<p>input data consisting of exposure, infection, and recovery times.</p>
</td></tr>
<tr><td><code id="epinet_+3A_dyadiccovmat">dyadiccovmat</code></td>
<td>
<p>matrix of dyadic covariates (X).  Can be constructed using <code><a href="#topic+BuildX">BuildX</a></code>.</p>
</td></tr>
<tr><td><code id="epinet_+3A_mcmcinput">mcmcinput</code></td>
<td>
<p>list of control options for MCMC algorithm.  Can be constructed using <code><a href="#topic+MCMCcontrol">MCMCcontrol</a></code>.</p>
</td></tr>
<tr><td><code id="epinet_+3A_priors">priors</code></td>
<td>
<p>list of prior distributions and parameters.  Can be constructed using <code><a href="#topic+priorcontrol">priorcontrol</a></code>.</p>
</td></tr>
<tr><td><code id="epinet_+3A_verbose">verbose</code></td>
<td>
<p>boolean variable specifying whether progress and information messages are
displayed during the course of the MCMC routine.  Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Uses exposed, infective, and removal times from the infected nodes of an epidemic
in order to perform inference on the parameters of the network and epidemic models.   
</p>
<p>The formula will consist of variables (column names) found in the dyadiccovmat parameter.  By default, the model will include an intercept term.
</p>
<p>epidata is an <code class="reqn">N</code> row by 5 column array giving the identity, likely parent, and exposed, infective, 
and removal times for each of the <code class="reqn">N</code> individuals in the population, as well as the values of any nodal 
covariates.  Column 1 gives the ID (an integer) of the node, and column 2 gives the identity of the probable 
parent of the node (if known).  Columns 3, 4, and 5 give the exposed, infective, and removal times.  Individuals who were not infected
during the course of the epidemic should have NA coded in columns 3, 4, and 5; the records for these
individuals should appear AFTER those corresponding to the individuals that were infected during the
epidemic.  Note that if the times are not internally consistent, an error message will be generated and no 
inference will be performed. It is necessary to include data for exposure and infective times, even 
if these values are not known (in this case, set the respective entries to NA).  
</p>
<p>Any data rows corresponding to individuals not infected during the course of the epidemic, if present, 
must occur at the end of the array, after all rows for infected individuals.  These rows must have removal times of NA. 
</p>
<p>dyadiccovmat is an <code class="reqn">{N \choose 2}</code> row by <code class="reqn">(k+2)</code> column matrix containing the dyadic covariates for the population, where <code class="reqn">N</code> is the number of individuals in the population and <code class="reqn">k</code> is the number of dyadic covariates used in the model.  The matrix contains one row for each dyad (pair of nodes).  Columns 1 and 2 give the ID of the two nodes comprising the dyad, and the remaining <code class="reqn">k</code> columns give the covariate values. 
</p>
<p>Uses an algorithm similar to that described in Groendyke and Welch (2018), Groendyke et al. (2010), and Britton and O'Neill (2002).
</p>


<h3>Value</h3>

	
<table>
<tr><td><code>accept</code></td>
<td>
<p>vector containing the number of times a proposed new value was accepted for the parameters 
(P, eta, G, beta, thetai, ki, thetae, ke).</p>
</td></tr>
<tr><td><code>propose</code></td>
<td>
<p>vector containing the number of times a new value was proposed for the parameters 
(P, eta, G, beta, thetai, ki, thetae, ke).</p>
</td></tr>
<tr><td><code>llkd</code></td>
<td>
<p>vector containing the log-likelihood at each iteration of the MCMC algorithm.</p>
</td></tr>    
<tr><td><code>beta</code></td>
<td>
<p>vector containing the sample for parameter beta.</p>
</td></tr>
<tr><td><code>thetai</code></td>
<td>
<p>vector containing the sample for parameter thetai.</p>
</td></tr>
<tr><td><code>thetae</code></td>
<td>
<p>vector containing the sample for parameter thetae.</p>
</td></tr>
<tr><td><code>ki</code></td>
<td>
<p>vector containing the sample for parameter ki.</p>
</td></tr>
<tr><td><code>ke</code></td>
<td>
<p>vector containing the sample for parameter ke.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>2-dimensional array containing the samples for the eta parameters.  The <code class="reqn">i^{th}</code> column contains the 
sample for the <code class="reqn">i^{th}</code> eta parameter.</p>
</td></tr>
<tr><td><code>initexp</code></td>
<td>
<p>vector containing the sample for parameter kappa (identity of initial exposed).
Will only vary when both the exposure and infection times are assumed unknown.</p>
</td></tr>
<tr><td><code>initexptime</code></td>
<td>
<p>vector containing the sample for parameter <code class="reqn">E_{\kappa}</code> (initial exposure time).
Will only vary when the exposure times are assumed unknown.</p>
</td></tr>
<tr><td><code>exptimes</code></td>
<td>
<p>if exposure times are inferred and corresponding posterior samples are returned, this is two-dimensional 
array containing the inferred exposure times (exptimes[<code class="reqn">i</code>, ] contains the sample of exposure times for node <code class="reqn">i</code>). 
Otherwise, this will be NULL.  </p>
</td></tr>
<tr><td><code>inftimes</code></td>
<td>
<p>if infection times are inferred and corresponding posterior samples are returned, this is two-dimensional 
array containing the inferred infection times (inftimes[<code class="reqn">i</code>, ] contains the sample of infection times for node <code class="reqn">i</code>). 
Otherwise, this will be NULL.  </p>
</td></tr>
<tr><td><code>rectimes</code></td>
<td>
<p>vector containing the original recovery times.</p>
</td></tr>
<tr><td><code>nodeid</code></td>
<td>
<p>vector containing the node IDs for the individuals in the population.</p>
</td></tr>
<tr><td><code>transtree</code></td>
<td>
<p>A two-dimensional array containing the sample for inferred transmission tree.  transtree[<code class="reqn">i</code>, ] contains the sample
of parent nodes for node <code class="reqn">i</code>.  A parent node of -999 for <code class="reqn">i</code> designates that <code class="reqn">i</code> is the initial exposed node.  If the transmission tree 
is not inferred and returned, this will be NULL.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula used in the inference routine.</p>
</td></tr>
<tr><td><code>mcmcinfo</code></td>
<td>
<p>input settings for the MCMC chain</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a> </p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	
</p>
<p>Groendyke, C., Welch, D. and Hunter, D.  2012. A Network-based Analysis of the 1861 
Hagelloch Measles Data, <em>Biometrics</em>, <b>68-3</b>.
</p>
<p>Groendyke, C., Welch, D. and Hunter, D.  2010. Bayesian inference for contact networks given
epidemic data, <em>Scandinavian Journal of Statistics</em>, <b>38-3</b>.
</p>
<p>Britton, T. and O'Neill, P.D. 2002. Bayesian inference for stochastic epidemics in populations 
with random social structure, <em>Scandinavian Journal of Statistics</em>, <b>29-3</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BuildX">BuildX</a></code> for building a dyadic covariate matrix, 
<code><a href="#topic+MCMCcontrol">MCMCcontrol</a></code> for specifying control parameters for the MCMC algorithm,
<code><a href="#topic+priorcontrol">priorcontrol</a></code> for specifying prior distributions and their hyperparameters, 
<code><a href="#topic+epi2newick">epi2newick</a></code> and <code><a href="#topic+write.epinet">write.epinet</a></code> for writing the output of the algorithm
to file, and <code><a href="#topic+plot.epinet">plot.epinet</a></code> for plotting the posterior samples of the transmission
tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N,nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat=dcm, eta=-1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist="gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)

## Not run: 
# Note: This may take a few minutes to run.
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M = net, N = N, beta = 1, ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)

## End(Not run)
</code></pre>

<hr>
<h2 id='epinet-internal'>Internal epinet Objects</h2><span id='topic+itimestartvalues'></span><span id='topic+etimestartvalues'></span><span id='topic+CreateCompactMatrix'></span><span id='topic+removesusceptibles'></span><span id='topic+buildepifromoutput'></span><span id='topic+epi2newick.int'></span><span id='topic+plotepitree'></span><span id='topic+epigraphmcmcc'></span>

<h3>Description</h3>

<p>Internal epinet functions.
</p>


<h3>Details</h3>

<p>These are not intended to be called by the user and
are only used by other functions.
</p>

<hr>
<h2 id='ess'>Calculate the Effective Sample Size</h2><span id='topic+ess'></span>

<h3>Description</h3>

<p>Calculate the Effective Sample Size for a marginal posterior sample obtained via MCMC</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess(x, ignoreBurnin = FALSE, burninProportion = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_+3A_x">x</code></td>
<td>
<p>a numeric vector of length N assumed to be samples from a Markov chain</p>
</td></tr>
<tr><td><code id="ess_+3A_ignoreburnin">ignoreBurnin</code></td>
<td>
<p> logical indictating whether or not the first burninProportion of vector x should be ignored</p>
</td></tr>
<tr><td><code id="ess_+3A_burninproportion">burninProportion</code></td>
<td>
<p>if ignoreBurnin == TRUE, the first burninProportion*length(x) samples are removed from x before the ess is calculated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the effective sample size of x based on an estimate of the lag autocorrelation function.  Details of the method are in Section 11.5 of Bayesian Data Analysis, Third Edition, 2013, Andrew Gelman, John B. Carlin, Hal S. Stern, David B. Dunson, Aki Vehtari, Donald B. Rubin.</p>


<h3>Value</h3>

<p> Returns the estimated effective sample size for the last (1-burninProportion) samples in x.
</p>


<h3>Author(s)</h3>

<p>David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>, 
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a></p>


<h3>References</h3>

<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., Rubin, D.B., 2013 <em>Bayesian Data Analysis</em>, Third Edition, (Section 11.5), Boca Raton, Florida: CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	set.seed(8)
	x &lt;- runif(1000)
	# expect ESS of close to 900 as samples are iid
	ess(x, ignoreBurnin = TRUE)
	# no burnin to ignore so ess is actually close to 1000
	ess(x, ignoreBurnin = FALSE)
	
	# ESS is a rough measure at best
	ess(1:1000,ignoreBurnin = FALSE)	
</code></pre>

<hr>
<h2 id='Hagelloch'>Hagelloch measles data.</h2><span id='topic+HagellochTimes'></span><span id='topic+HagellochDyadCov'></span>

<h3>Description</h3>

<p>Epidemic data derived from a measles outbreak in the town of 
Hagelloch, Germany in 1861.  188 individuals were infected over the 
course of the epidemic.  (One individual was removed from this dataset.)
</p>
<p>Consists of two files: HagellochTimes and HagellochDyadCov.  These two
files contain the data necessary to analyze the Hagelloch measles data.
</p>
<p>HagellochTimes contains 187 rows (one for each individual included) and
5 columns: NodeID (a numerical index ranging from 1 to 187); Putative
Parent (the ID of the individual considered most likely to have been
responsible for infecting this person, as determined by Osterle); Exposure 
time, Infectious time, and Removal time (the time index in days at which 
the individual entered the Exposed, Infectious, and Removed states,
respectively).  Note that Exposure times are not known for this data set.
See references below for details regarding the determination of 
Infectious and Removal times.
</p>
<p>HagellochDyadCov is a matrix of dyadic covariates corresponding to
the individuals in the Hagelloch data set.  Contains one row for each
dyad (pair of individuals) in the population.  The first two columns are the
Node IDs for the two individuals in the dyad.  The third column is a column
of all 1 values, used as a baseline or intercept term.  Columns 4, 5, and 6
are indicator variables for whether the two individuals in the dyad are in
the same household, are both in classroom 1, or both in classroom 2,
respectively.  Column 7 is the household distance between the two
individuals in the dyad, measured in units of 2.5m, Columns 8 and 9 are indicator
variables based on whether both individuals in the dyad are male or
female, respectively.  Column 10 is the age difference (in years) between
the two individuals in the dyad. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hagelloch)</code></pre>


<h3>Format</h3>

<p>See above.</p>


<h3>Source</h3>

<p>Thanks to Peter Neal for providing this data set.  This data was 
originally collected by Pfeilsticker:
</p>
<p>Pfeilsticker, A. (1863). Beitrage zur Pathologie der Masern mit besonderer 
Berucksichtigung der statistischen Verhaltnisse, M.D. thesis, Eberhard-Karls 
Universitat, Tubingen.
</p>
<p>and later modified by Osterle:
</p>
<p>Oesterle, H. (1992). Statistiche Reanalyse einer Masernepidemie 1861 in 
Hagelloch, M.D. Thesis, Eberhard-Karls Universitat, Tubingen.
</p>


<h3>References</h3>

<p>Neal, P. and Roberts, G. (2004). Statistical inference and model selection for the 1861 
Hagelloch measles epidemic. <em>Biostatistics</em> <b>5</b> (2), 249.</p>

<hr>
<h2 id='MCMCcontrol'>Set control parameters for epinet MCMC algorithm</h2><span id='topic+MCMCcontrol'></span>

<h3>Description</h3>

<p>Sets parameter values that control the MCMC
algorithm used by epinet to produce posterior samples.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCcontrol(nsamp, thinning, extrathinning = FALSE, burnin = 0, 
	seed = floor(runif(1, 0, 2^30)), etapropsd)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCcontrol_+3A_nsamp">nsamp</code></td>
<td>
<p>number of iterations to run MCMC algorithm.</p>
</td></tr>
<tr><td><code id="MCMCcontrol_+3A_thinning">thinning</code></td>
<td>
<p>thinning interval.</p>
</td></tr>
<tr><td><code id="MCMCcontrol_+3A_extrathinning">extrathinning</code></td>
<td>
<p>set to FALSE unless we want to return inferred values of the
exposure / infective times and the transmission tree, in which case it is an integer
specifying the extra thinning interval.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="MCMCcontrol_+3A_burnin">burnin</code></td>
<td>
<p>number of burn-in iterations to the run the MCMC algorithm.  Defaults to 0.</p>
</td></tr>
<tr><td><code id="MCMCcontrol_+3A_seed">seed</code></td>
<td>
<p>seed for random number generation.  Defaults to a random value.</p>
</td></tr>
<tr><td><code id="MCMCcontrol_+3A_etapropsd">etapropsd</code></td>
<td>
<p>standard deviation of proposal distributions for eta parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Auxiliary function that can be used to set parameter values that control the MCMC
algorithm used by epinet to produce posterior samples.  This function is only used in conjunction
with the <code><a href="#topic+epinet">epinet</a></code> function.
</p>
<p>nsamp is the number of samples that will be produced for each of the model parameters. 
</p>
<p>thinning is the thinning interval, e.g., to return every <code class="reqn">10^{th}</code> sample, use thinning = 10.
</p>
<p>If exposure and / or infective times are being inferred and we wish to return the inferred values of these
times (along with the inferred transmission tree), set extrathinning equal to an integer specifying the
extra thinning interval for these values.  Because returning values for a large number of nodes can be
very space-intensive, an extra thinning interval can be given as a multiple of the thinning interval for
the other parameters.  For example, using thinning = 10 and extrathinning = 20 will return the values
of the inferred exposure and infective times and transmission tree every 200 iterations, and the values
of the other parameters every 10 iterations.  If these inferred values are not desired, set this variable to FALSE.
</p>
<p>burnin controls the number of burn-in iterations to be run by the MCMC algorithm before samples begin
to become recorded.
</p>
<p>etapropsd is a vector of length <code class="reqn">k</code>, where <code class="reqn">k</code> is the number of eta (network) parameters in the model,
including the intercept.  These are tuning parameters for the MCMC algorithm.
</p>


<h3>Value</h3>

<p>A list with arguments as components.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a></p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters, and
<code><a href="#topic+priorcontrol">priorcontrol</a></code> for specifying prior distributions and their hyperparameters.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat=dcm, eta=-1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist="gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)

## Not run: 
# Note: This may take a few minutes to run.
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M = net, N = N, beta = 1, ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.epidemic'>Plot the spread of an epidemic</h2><span id='topic+plot.epidemic'></span>

<h3>Description</h3>

<p>Plot the spread of an epidemic over a contact network.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epidemic'
plot(x, lwd = 1, leaf.labs = TRUE, leaf.cex = 0.75,
    zero.at.start = FALSE, main = "Transmission Tree", xlab = "Time", 
    ylab= "", e.col = "black", i.col = "red", lty.transmission = 3, 
    marktransitions = TRUE, label.trans = "|", cex.trans = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epidemic_+3A_x">x</code></td>
<td>
<p>a simulated epidemic, in the form of the
output produced by <code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code>.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_lwd">lwd</code></td>
<td>
<p>line width for the (horizontal)
line segments representing the exposed and infective 
periods for each individual.  Also controls the line width 
for the (vertical) line segments showing the transmission
pathways.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_leaf.labs">leaf.labs</code></td>
<td>
<p>boolean variable controlling whether the leaf
labels (Node IDs) are displayed to the right of their
infective period.  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_leaf.cex">leaf.cex</code></td>
<td>
<p>Character expansion factor for the leaf
labels, if they are displayed.  Defaults to 0.75.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_zero.at.start">zero.at.start</code></td>
<td>
<p>boolean variable governing whether the
epidemic times are shifted so that the epidemic begins
at time zero.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_main">main</code></td>
<td>
<p>main title for plot.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis on plot.  Defaults to &ldquo;Time&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis on plot.  Defaults to blank.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_e.col">e.col</code></td>
<td>
<p>color to be used to plot the individuals' 
exposed periods on the plot.  Defaults to black.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_i.col">i.col</code></td>
<td>
<p>color to be used to plot the individuals' 
infective periods on the plot.  Defaults to red.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_lty.transmission">lty.transmission</code></td>
<td>
<p>line type used to mark the (vertical)
infection pathway on the plot.  Defaults to 3 (dotted).</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_marktransitions">marktransitions</code></td>
<td>
<p>boolean variable indicating whether
tick marks should be placed at the times where the
individuals move from the exposed to the infective state.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_label.trans">label.trans</code></td>
<td>
<p>character used to mark transition points, if
marktransitions is TRUE.  Defaults to &ldquo;|&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_cex.trans">cex.trans</code></td>
<td>
<p>magnification to be used to for transition labels,
if marktransitions is TRUE.  Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="plot.epidemic_+3A_...">...</code></td>
<td>
<p>other plotting arguments to be passed through to the
call to plot() that draws the axes and titles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a simulated epidemic, or indicating the
path that the infection took during the epidemic (the 
transmission tree) and the times that each node entered 
the Exposed, Infective, and Removed states.  The default 
plotting parameter values work well for epidemics up to
about 50 - 60 infecteds and the function requires at least 
2 infecteds.  For a larger number of infecteds, it is 
recommended to use <code><a href="grDevices.html#topic+pdf">pdf</a></code> and 
adjust plotting dimensions. 
</p>
<p>Only works for full data, i.e., the transmission tree must 
be fully specified and all times for infected individuals
must be known.</p>


<h3>Value</h3>

<p> returns no value.  Strictly invoked for the plotting
side effect.
</p>


<h3>Author(s)</h3>

<p>David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>,
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a></p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> for producing simulated
epidemics.  <code><a href="#topic+plot.epinet">plot.epinet</a></code> produces similar plots
for transmission trees inferred as part of the <code><a href="#topic+epinet">epinet</a></code>
inference routine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")

# Plot the simulated epidemic
plot(exampleepidemic)
</code></pre>

<hr>
<h2 id='plot.epinet'>Plot the spread of an epidemic</h2><span id='topic+plot.epinet'></span>

<h3>Description</h3>

<p>Plot the spread of an epidemic over a contact network.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epinet'
plot(x, index = dim(x$transtree)[2],
    lwd = 1, leaf.labs = TRUE, leaf.cex = 0.75, zero.at.start = FALSE, 
    main = "Transmission Tree", xlab = "Time", ylab= "", 
    e.col = "black", i.col = "red", lty.transmission = 3,
    marktransitions = TRUE, label.trans = "|", cex.trans = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epinet_+3A_x">x</code></td>
<td>
<p>output from <code><a href="#topic+epinet">epinet</a></code>.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_index">index</code></td>
<td>
<p>a number indicating which of the MCMC
samples to plot. Defaults to the final sample in the chain.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_lwd">lwd</code></td>
<td>
<p>line width for the (horizontal) 
line segments representing the exposed and infective 
periods for each individual.  Also controls the line width 
for the (vertical) line segments showing the transmission
pathways.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_leaf.labs">leaf.labs</code></td>
<td>
<p>boolean variable controlling whether the leaf
labels (Node IDs) are displayed to the right of their
infective period.  Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_leaf.cex">leaf.cex</code></td>
<td>
<p>Character expansion factor for the leaf
labels, if they are displayed.  Defaults to 0.75.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_zero.at.start">zero.at.start</code></td>
<td>
<p>boolean variable governing whether the
epidemic times are shifted so that the epidemic begins
at time zero.  Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_main">main</code></td>
<td>
<p>main title for plot.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis on plot.  Defaults to &ldquo;Time&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis on plot.  Defaults to blank.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_e.col">e.col</code></td>
<td>
<p>color to be used to plot the individuals' 
exposed periods on the plot.  Defaults to black.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_i.col">i.col</code></td>
<td>
<p>color to be used to plot the individuals' 
infective periods on the plot.  Defaults to red.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_lty.transmission">lty.transmission</code></td>
<td>
<p>line type used to mark the (vertical)
infection pathway on the plot.  Defaults to 3 (dotted).</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_marktransitions">marktransitions</code></td>
<td>
<p>boolean variable indicating whether
tick marks should be placed at the times where the
individuals move from the exposed to the infective state.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_label.trans">label.trans</code></td>
<td>
<p>character used to mark transition points, if
marktransitions is TRUE.  Defaults to &ldquo;|&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_cex.trans">cex.trans</code></td>
<td>
<p>magnification to be used to for transition labels,
if marktransitions is TRUE.  Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="plot.epinet_+3A_...">...</code></td>
<td>
<p>other plotting arguments to be passed through to the
call to plot() that draws the axes and titles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots the output from the <code>link{epinet}</code> function
indicating the path that the infection took during the
epidemic (the transmission tree) and the times that each
node entered the Exposed, Infective, and Removed states.
The default plotting parameter values work well for
epidemics up to about 50 - 60 infecteds.  For a larger
number of infecteds, it is recommended to use
<code><a href="grDevices.html#topic+pdf">pdf</a></code> and adjust plotting dimensions.
</p>


<h3>Value</h3>

<p> returns no value.  Strictly invoked for the plotting
side effect.
</p>


<h3>Author(s)</h3>

<p>David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>, 
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a></p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	</p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for performing
inference on the network and epidemic model parameters.
The functions <code><a href="#topic+epi2newick">epi2newick</a></code> and 
<code><a href="#topic+write.epinet">write.epinet</a></code> offer other options for outputting
inferred parameter samples and transmission trees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")

# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, extrathinning = 10, 
    etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Delete Exposure and Infection times; will infer these in the MCMC algorithm
exampleepidemic[, 3:4] &lt;- NA
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol,
     verbose = FALSE)

# Plot starting state of epidemic from chain 
plot(examplemcmc, index = 1)

# Plot final state of epidemic from chain 
plot(examplemcmc)
</code></pre>

<hr>
<h2 id='print.epidemic'>Prints an epidemict object</h2><span id='topic+print.epidemic'></span>

<h3>Description</h3>

<p>Prints an object created by the
<code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> simulation routine.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epidemic'
print(x, ...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epidemic_+3A_x">x</code></td>
<td>
<p>an object of class epidemic, produced from the <code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> simulation function.</p>
</td></tr>
<tr><td><code id="print.epidemic_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the print routine.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Prints the epidemic inference object, including the exposure, infectious, and recovery times
of each node in the epidemic.
</p>


<h3>Value</h3>

<p> Strictly invoked for side effect.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a> </p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> for simulating an epidemic, <code><a href="#topic+summary.epidemic">summary.epidemic</a></code>
for the summary method of an epidemic object, and <code><a href="#topic+plot.epidemic">plot.epidemic</a></code> for plotting a
visual display of the epidemic.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
print(exampleepidemic)
</code></pre>

<hr>
<h2 id='print.epinet'>Print basic information about an epinet object</h2><span id='topic+print.epinet'></span>

<h3>Description</h3>

<p>Prints some general information about an object created by the
<code><a href="#topic+epinet">epinet</a></code> inference routine.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epinet'
print(x, ...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epinet_+3A_x">x</code></td>
<td>
<p>an object of class epinet, produced from the <code><a href="#topic+epinet">epinet</a></code> inference function.</p>
</td></tr>
<tr><td><code id="print.epinet_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the print routine.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Prints some basic information about an epinet inference object, including the call, network
parameters in the model, and number of iterations of the MCMC algorithm.
</p>


<h3>Value</h3>

<p> Strictly invoked for side effect.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a> </p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	</p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters, and
<code><a href="#topic+plot.epinet">plot.epinet</a></code> for plotting the posterior samples of the transmission tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)
print(examplemcmc)

## Not run: 
# Note: This may take a few minutes to run.
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M = net, N = N, beta = 1, ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)
print(out)

## End(Not run)

</code></pre>

<hr>
<h2 id='priorcontrol'>Set prior distributions and hyperparameters for epinet MCMC algorithm</h2><span id='topic+priorcontrol'></span>

<h3>Description</h3>

<p>Sets the prior distributions and corresponding hyperparameters
to be used in the epinet MCMC algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorcontrol(bprior, tiprior, teprior, etaprior, kiprior, keprior, 
	priordists = "gamma", betapriordist = priordists, thetaipriordist = priordists, 
	thetaepriordist = priordists, etapriordist = "normal", kipriordist = priordists, 
	kepriordist = priordists, parentprobmult = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorcontrol_+3A_bprior">bprior</code></td>
<td>
<p>parameters for beta prior.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_tiprior">tiprior</code></td>
<td>
<p>parameters for thetai prior.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_teprior">teprior</code></td>
<td>
<p>parameters for thetae prior.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_etaprior">etaprior</code></td>
<td>
<p>parameters for eta priors.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_kiprior">kiprior</code></td>
<td>
<p>parameters for ki prior.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_keprior">keprior</code></td>
<td>
<p>parameters for ke prior.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_priordists">priordists</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_betapriordist">betapriordist</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_thetaipriordist">thetaipriordist</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_thetaepriordist">thetaepriordist</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_etapriordist">etapriordist</code></td>
<td>
<p>prior distribution for the network parameters.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_kipriordist">kipriordist</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_kepriordist">kepriordist</code></td>
<td>
<p>can be &ldquo;uniform&rdquo; or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="priorcontrol_+3A_parentprobmult">parentprobmult</code></td>
<td>
<p>multiplier for prior probability placed on suspected parent node.  Default
is a uniform prior assumption.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Auxiliary function that can be used to set prior distributions and parameter 
values that control the MCMC algorithm used by epinet to produce posterior 
samples.  This function is only used in conjunction with the <code><a href="#topic+epinet">epinet</a></code> 
function.
</p>
<p>The type of prior distribution (default is gamma / inverse gamma) can be specified for all epidemic parameters (i.e., all parameters except the eta network parameters)
using priordists or for each parameter individually.  Either uniform or gamma / inverse gamma priors can be chosen.  (The two theta
parameters use inverse gamma prior distributions, while the other epidemic parameters use gamma priors.)
</p>
<p>The parameters of the epidemic parameter prior distributions are given as vectors of (two) hyper-parameters.  If the uniform
prior is being used for a parameter, then the hyper-parameters are the lower and upper limits of
the distribution.  If the gamma distribution is being used with parameters <code class="reqn">c</code> and <code class="reqn">d</code>, then the prior mean
is <code class="reqn">c \cdot d</code> and the prior variance is <code class="reqn">c \cdot d^2</code>.  If the inverse gamma distribution is being used with parameters
<code class="reqn">c</code> and <code class="reqn">d</code>, then the prior mean is <code class="reqn">\frac{d}{c-1}</code> and the prior variance is 
<code class="reqn">\frac{d^2}{(c-1)^2 \cdot (c-2)}</code>.
</p>
<p>For the network parameters (the eta parameters), the only prior assumption currently implemented is a set of independent normal distributions.
</p>
<p>etaprior contains the hyper-parameters for the prior distributions of the eta parameters.  This is a vector of <code class="reqn">2k</code> values,
giving the mean and standard deviation of each distribution (i.e., the first two entries are the mean and
standard deviation of the prior distribution for the first eta parameter, the next two entries are the mean and
standard deviation of the prior distribution for the second eta parameter, etc.)
</p>
<p>The default prior distribution for the parent of each node is uniform on all of the other nodes.  To specify a
non-uniform distribution, use column 2 of epidata and set parentpriormult to an integer multiplier greater than 1.
</p>


<h3>Value</h3>

<p>A list with arguments as components.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a> </p>


<h3>References</h3>

<p>Groendyke, C. and Welch, D.  2018.  epinet: An R Package to Analyze Epidemics Spread across Contact Networks, <em>Journal of Statistical Software</em>, <b>83-11</b>.	</p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters and
<code><a href="#topic+MCMCcontrol">MCMCcontrol</a></code> for specifying control parameters for the MCMC algorithm.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)
</code></pre>

<hr>
<h2 id='SEIR.simulator'>Simulate an epidemic on a contact network</h2><span id='topic+SEIR.simulator'></span>

<h3>Description</h3>

<p>Simulate the spread of an epidemic across an
(undirected) contact network.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SEIR.simulator(M, N, beta, ki, thetai, ke = ki, thetae = thetai, 
    latencydist = "fixed", latencyperiod = 0) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SEIR.simulator_+3A_m">M</code></td>
<td>
<p>an undirected network, given in edgelist matrix 
format</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_n">N</code></td>
<td>
<p>the number of nodes in the contact network.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_beta">beta</code></td>
<td>
<p>the transmission rate of the virus across an edge
of the network.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_ki">ki</code></td>
<td>
<p>the shape parameter for the removal process for
the epidemic.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_thetai">thetai</code></td>
<td>
<p>the scale parameter for the removal process
for the epidemic.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_ke">ke</code></td>
<td>
<p>the shape parameter for the removal process for
the epidemic.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_thetae">thetae</code></td>
<td>
<p>the scale parameter for the removal process
for the epidemic.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_latencydist">latencydist</code></td>
<td>
<p>type of latency period; can be &ldquo;fixed&rdquo; 
or &ldquo;gamma&rdquo;.</p>
</td></tr>
<tr><td><code id="SEIR.simulator_+3A_latencyperiod">latencyperiod</code></td>
<td>
<p>length of latency period, if using latencydist 
== &ldquo;fixed&rdquo;.  Ignored if latencydist == &ldquo;gamma&rdquo;.  
Set to 0 to get an SIR epidemic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes as input an undirected network, given in
edgelist matrix format, which is the same format returned by
<code><a href="#topic+SimulateDyadicLinearERGM">SimulateDyadicLinearERGM</a></code>. Randomly chooses an initial infective
individual. The infection spreads randomly across edges in the 
network according to exponential infective periods with mean <code class="reqn">\frac{1}{beta}</code>.
An infective individual remains in the exposed state for a either
a fixed period of time given by latencyperiod or a time described by a 
gamma RV with parameters ke and thetae (mean = <code class="reqn">ke \cdot thetae</code>, 
var = <code class="reqn">ke \cdot thetae^2</code>).  After this exposed period, an infected person 
moves to the Infected state, at which point they can infect susceptible individuals.  
The infective individuals are removed after an infective period whose length is governed by 
a gamma RV with parameters ki and thetai (mean = <code class="reqn">ki \cdot thetai</code>, 
var = <code class="reqn">ki \cdot thetai^2</code>).  Once an individual is removed, they cannot be 
re-infected and cannot infect others.</p>


<h3>Value</h3>

<p>matrix consisting of one row for each individual in the 
population.  Each row contains (in columns 1 - 5, respectively):
the node infected, the infecting node, the time of infection,
the time of transition from exposed to infective, and the 
time of removal.  The times are shifted so that the first removal
occurs at time 0.  The rows corresponding to the susceptible 
members of the population (i.e., the individuals that were not 
infected during the course of the epidemic) are placed after 
those for the infected individuals.
</p>


<h3>Author(s)</h3>

<p>Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>, 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimulateDyadicLinearERGM">SimulateDyadicLinearERGM</a></code> for simulating an Erdos-Renyi
contact network, <code><a href="#topic+epinet">epinet</a></code> for performing
inference on the network and epidemic model parameters,
and <code><a href="#topic+plot.epidemic">plot.epidemic</a></code> and <code><a href="#topic+epi2newick">epi2newick</a></code> for plotting functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N,nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
</code></pre>

<hr>
<h2 id='SimulateDyadicLinearERGM'>Simulates an ERGM network using given covariate values</h2><span id='topic+SimulateDyadicLinearERGM'></span>

<h3>Description</h3>

<p>Simulates a random ERGM network using a given matrix of covariate
values and a corresponding vector of parameter values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimulateDyadicLinearERGM(N, dyadiccovmat, eta)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimulateDyadicLinearERGM_+3A_n">N</code></td>
<td>
<p>number of individuals in the population.</p>
</td></tr>
<tr><td><code id="SimulateDyadicLinearERGM_+3A_dyadiccovmat">dyadiccovmat</code></td>
<td>
<p>matrix of dyadic covariates.</p>
</td></tr>
<tr><td><code id="SimulateDyadicLinearERGM_+3A_eta">eta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> dyadiccovmat is an <code class="reqn">{N \choose 2}</code> by <code class="reqn">(k+2)</code> matrix containing the dyadic covariates for the population, where <code class="reqn">N</code> is the number of individuals in the population and <code class="reqn">k</code> is the number of dyadic covariates used in the model.  The matrix contains one row for each dyad (pair of nodes).  Columns 1 and 2 give the ID of the two nodes comprising the dyad, and the remaining <code class="reqn">k</code> columns give the covariate values; eta is the vector of parameters corresponding to the covariates.
</p>
<p>For this class of dyadic independence network, the probability of an edge between individuals <code class="reqn">i</code> and <code class="reqn">j</code> is <code class="reqn">p_{\{i,j\} }</code>, where 
</p>
<p style="text-align: center;"><code class="reqn">\log \left( \frac{p_{\{i,j\} }}{1-p_{\{i,j\} }} \right) = \sum_{k} \eta_k X_{\{i,j\},k}</code>
</p>

<p>More information about this type of model can be found in Groendyke et al. (2012).
</p>


<h3>Value</h3>

<p>a network in edgelist matrix format</p>


<h3>Author(s)</h3>

<p> David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>,
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>  </p>


<h3>References</h3>

<p> Groendyke, C., Welch, D. and Hunter, D.  2012. A Network-based Analysis of the 1861 
Hagelloch Measles Data, <em>Biometrics</em>, <b>68-3</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> for simulating an SEIR epidemic over a network. </p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct a network of 30 individuals
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)

# Another example
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
</code></pre>

<hr>
<h2 id='summary.epidemic'>Summarize simulated epidemic</h2><span id='topic+summary.epidemic'></span>

<h3>Description</h3>

<p>Prints a summary of an epidemic simulated by the
<code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> simulation routine.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epidemic'
summary(object, ...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epidemic_+3A_object">object</code></td>
<td>
<p>an object of class epidemic, produced from the <code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> function.</p>
</td></tr>
<tr><td><code id="summary.epidemic_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the summary routine.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Prints a summary of the simulated epidemic, including the number of individuals infected over the
course of the epidemic, the number remaining susceptible throughout the epidemic, the total size
of the population, and length of the epidemic.
</p>


<h3>Value</h3>

<p>Strictly invoked for side effect.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+SEIR.simulator">SEIR.simulator</a></code> for simulating an epidemic, and
<code><a href="#topic+plot.epidemic">plot.epidemic</a></code> for plotting the simulated epidemic.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
summary(exampleepidemic)
</code></pre>

<hr>
<h2 id='summary.epinet'>Summarize posterior samples from epinet object</h2><span id='topic+summary.epinet'></span>

<h3>Description</h3>

<p>Prints summaries of posterior samples generated by the
<code><a href="#topic+epinet">epinet</a></code> inference routine.</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'epinet'
summary(object, ...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epinet_+3A_object">object</code></td>
<td>
<p>an object of class epinet, produced from the <code><a href="#topic+epinet">epinet</a></code> inference function.</p>
</td></tr>
<tr><td><code id="summary.epinet_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the summary routine.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Prints summaries of the epidemic and network parameters of an epinet inference object.
Epidemic parameters are beta, thetae, ke, thetai, and ki.  Network parameters are specified
in the model formula, and may include an intercept term.
</p>


<h3>Value</h3>

<p>Strictly invoked for side effect.</p>


<h3>Author(s)</h3>

<p> Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a>,
David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters, and
<code><a href="#topic+plot.epinet">plot.epinet</a></code> for plotting the posterior samples of the transmission tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)
summary(examplemcmc)

## Not run: 
# Note: This may take a few minutes to run.
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M = net, N = N, beta = 1, ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)
summary(out)

## End(Not run)

</code></pre>

<hr>
<h2 id='write.epinet'>Writes posterior samples from an epinet object to an output file</h2><span id='topic+write.epinet'></span>

<h3>Description</h3>

<p>Outputs posterior samples of an object created by the
<code><a href="#topic+epinet">epinet</a></code> inference routine; creates two output files.</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.epinet(out, filename)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.epinet_+3A_out">out</code></td>
<td>
<p>an object of class epinet, produced from the <code><a href="#topic+epinet">epinet</a></code> inference function.</p>
</td></tr>
<tr><td><code id="write.epinet_+3A_filename">filename</code></td>
<td>
<p>the name of the output file.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Writes two output files corresponding to the output produced from the <code><a href="#topic+epinet">epinet</a></code> 
inference function.  The first is a .log file, containing the posterior samples from the 
epidemic parameters in tab delimited form.  [This .log file can be read by Tracer, which calculates summary
statististics and diagnostics, and displays trace plots, histograms, etc.]  The second file
(which is only written if the transmission trees are returned from the inference routine),
is a .trees file, containing the inferred transmission trees, output in Newick format. 
</p>


<h3>Value</h3>

<p> Strictly invoked for side effect.</p>


<h3>Author(s)</h3>

<p> David Welch <a href="mailto:david.welch@auckland.ac.nz">david.welch@auckland.ac.nz</a>,
Chris Groendyke <a href="mailto:cgroendyke@gmail.com">cgroendyke@gmail.com</a> </p>


<h3>References</h3>

<p>Rambaut A., Suchard M., Xie D., Drummond A.J. 2014. Tracer v1.6. <a href="http://beast.community/tracer.html">http://beast.community/tracer.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epinet">epinet</a></code> for generating posterior samples of the parameters, 
<code><a href="#topic+print.epinet">print.epinet</a></code> and <code><a href="#topic+summary.epinet">summary.epinet</a></code> for printing basic
summary information about an epinet object, <code><a href="#topic+epi2newickmcmc">epi2newickmcmc</a></code> for
printing an inferred transmission tree to the screen in Newick format, and
<code><a href="#topic+plot.epinet">plot.epinet</a></code> for plotting the posterior samples of the transmission tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate an epidemic through a network of 30
set.seed(3)
N &lt;- 30
# Build dyadic covariate matrix (X)
# Have a single covariate for overall edge density; this is the Erdos-Renyi model
nodecov &lt;- matrix(1:N, nrow = N)
dcm &lt;- BuildX(nodecov)
# Simulate network and then simulate epidemic over network
examplenet &lt;- SimulateDyadicLinearERGM(N, dyadiccovmat = dcm, eta = -1.8)
exampleepidemic &lt;- SEIR.simulator(examplenet, N = 30, 
    beta = 0.3, ki = 2, thetai = 5, latencydist = "gamma")
# Set inputs for MCMC algorithm
mcmcinput &lt;- MCMCcontrol(nsamp = 5000, thinning = 10, etapropsd = 0.2) 
priorcontrol &lt;- priorcontrol(bprior = c(0, 1), tiprior = c(1, 3), teprior = c(1, 3), 
    etaprior = c(0, 10), kiprior = c(2, 8), keprior = c(2, 8), priordists = "uniform")
# Run MCMC algorithm on this epidemic
# Note: Not enough data or iterations for any real inference
examplemcmc &lt;- epinet( ~ 1, exampleepidemic, dcm, mcmcinput, priorcontrol)
## Not run: write.epinet(examplemcmc, "examplemcmc")

## Not run: 
# Note: This may take a few minutes to run.
set.seed(1)
N &lt;- 50
mycov &lt;- data.frame(id = 1:N, xpos = runif(N), ypos = runif(N))
dyadCov &lt;- BuildX(mycov, binaryCol = list(c(2, 3)),binaryFunc = c("euclidean"))
# Build network
eta &lt;- c(0,-7)
net &lt;- SimulateDyadicLinearERGM(N = N, dyadiccovmat = dyadCov, eta = eta)
# Simulate epidemic
epi &lt;- SEIR.simulator(M = net, N = N, beta = 1, ki = 3, thetai = 7, ke = 3, latencydist = "gamma")
# Run MCMC routine on simulated epidemic
mcmcinput &lt;- MCMCcontrol(nsamp = 1000000, thinning = 100, etapropsd = c(1, 1))
priors &lt;- priorcontrol(bprior = c(0, 4), tiprior = c(1, 15), teprior = c(1, 15), 
	etaprior = c(0, 10, 0, 10), kiprior = c(1, 7), keprior = c(1, 7), priordists = "uniform")
out &lt;- epinet(~ xpos.ypos.L2Dist, epidata = epi, dyadiccovmat = dyadCov,
	mcmcinput = mcmcinput, priors = priors)
write.epinet(out, "SampleInferenceOutput")

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
