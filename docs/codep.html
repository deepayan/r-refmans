<!DOCTYPE html><html lang="en"><head><title>Help for package codep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {codep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#codep_PACKAGE'><p>Multiscale Codependence Analysis</p></a></li>
<li><a href='#cdp-class'><p>Class and Methods for Multiscale Codependence Analysis (MCA)</p></a></li>
<li><a href='#cthreshold'><p>Familywise Type I Error Rate</p></a></li>
<li><a href='#Doubs'><p>The Doubs Fish Data</p></a></li>
<li><a href='#eigenmap'><p>Spatial Eigenvector Maps</p></a></li>
<li><a href='#eigenmap-class'><p>Class and Methods for Spatial Eigenvector Maps</p></a></li>
<li><a href='#Euclid'><p>Calculation of the Euclidean Distance</p></a></li>
<li><a href='#geodesics'><p>Calculation of Geodesic Distances</p></a></li>
<li><a href='#LGDat'><p>Legendre and Gallagher Synthetic Example</p></a></li>
<li><a href='#LGTransforms'><p>Transformation for Species Abundance Data</p></a></li>
<li><a href='#MCA'><p>Multiple-descriptors, Multiscale Codependence Analysis</p></a></li>
<li><a href='#minpermute'><p>Number of Permutations for MCA</p></a></li>
<li><a href='#mite'><p>The Oribatid Mite Data Set</p></a></li>
<li><a href='#product-distribution'><p>Frequency Distributions for MCA Parametric Testing</p></a></li>
<li><a href='#salmon'><p>The St. Marguerite River Altantic Salmon Parr Transect</p></a></li>
<li><a href='#weighting-functions'><p>Weighting Functions for Spatial Eigenvector Map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-23</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Codependence Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of Multiscale Codependence Analysis and spatial eigenvector maps.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 18:13:51 UTC; guenardg</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Guénard <a href="https://orcid.org/0000-0003-0761-3072"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pierre Legendre <a href="https://orcid.org/0000-0002-3838-3305"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Bertrand Pages [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 22:00:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='codep_PACKAGE'>Multiscale Codependence Analysis</h2><span id='topic+codep_PACKAGE'></span><span id='topic+codep-package'></span>

<h3>Description</h3>

<p>Computation of Multiscale Codependence Analysis and spatial eigenvector maps.
Multiscale Codependence Analysis (MCA) consists in assessing the coherence of
pairs of variables in space (or time) using the product of their correlation
coefficients with series of spatial (or temporal) eigenfunctions. That
product, which is positive or negative when variables display similar or
opposing trends, respectively, is called a codependence coefficient.
</p>
<p>The eigenfunctions used in the calculation are obtained in three steps: 1) a
distance matrix is calculated from the locations of samples in space (or the
sampling organisation through time). 2) From that distance matrix, a matrix
of Moran spatial weights is obtained; this is the same matrix as used to
calculate Moran's autocorrelation index, hence the name. And 3) the spatial
weight matrix is eigenvalue-decomposed after centring the rows and columns of
the spatial weight matrix.
</p>
<p>The statistical significance of codependence coefficients is tested using
parametric or permutational testing of a tau statistic. The 'tau' statistic
is the product of the Student's 't' statistics obtained from comparison of
the two variables with a given eigenfunction. The 'tau' statistic can take
either positive or negative values, thereby allowing one to perform
one-tailed or two-tailed testing. For multiple response variables, testing is
performed using the 'phi' statistic instead of 'tau'. That statistic follows
the distribution of the product of two Fisher-Snedocor F statistics (see
<a href="#topic+product-distribution">product-distribution</a> for details).
</p>


<h3>Details</h3>

<p>Function <code><a href="#topic+MCA">MCA</a></code> performs Multiscale Codependence Analysis
(MCA). Functions <code><a href="#topic+test.cdp">test.cdp</a></code> and <code><a href="#topic+permute.cdp">permute.cdp</a></code> handle
parametric or permutation testing of the codependence coefficients,
respectively.
</p>
<p>Methods are provided to print and plot <a href="#topic+cdp-class">cdp-class</a> objects
(<code><a href="#topic+print.cdp">print.cdp</a></code> and <code><a href="#topic+plot.cdp">plot.cdp</a></code>, respectively) as well as
summary (<code><a href="#topic+summary.cdp">summary.cdp</a></code>), fitted values
(<code><a href="#topic+fitted.cdp">fitted.cdp</a></code>), residuals (<code><a href="#topic+residuals.cdp">residuals.cdp</a></code>), and for
making predictions (<code><a href="#topic+predict.cdp">predict.cdp</a></code>).
</p>
<p>Function <code><a href="#topic+eigenmap">eigenmap</a></code> calculates spatial eigenvector maps following
the approach outlined in Dray et al. (2006), and which are necessary to
calculate <code><a href="#topic+MCA">MCA</a></code>. It returns a <a href="#topic+eigenmap-class">eigenmap-class</a> object. The
package also features methods to print (<code><a href="#topic+print.eigenmap">print.eigenmap</a></code>) and
plot (<code><a href="#topic+plot.eigenmap">plot.eigenmap</a></code>) these objects. Function
<code><a href="#topic+eigenmap.score">eigenmap.score</a></code> can be used to make predictions for spatial
models built from the eigenfunctions of <code><a href="#topic+eigenmap">eigenmap</a></code> using
distances between one or more target locations and the sampled locations for
which the spatial eigenvector map was built.
</p>
<p>The package also features an exemplary dataset <a href="#topic+salmon">salmon</a> containing 76
sampling site positions along a 1520 m river segment. It also contains
functions <code><a href="#topic+cthreshold">cthreshold</a></code> and <code><a href="#topic+minpermute">minpermute</a></code>, which
compute the testwise type I error rate threshold corresponding to a given
familywise threshold and the minimal number of permutations needed for
testing Multiscale Codependence Analysis given the alpha threshold,
respectively.
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> codep</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-09-23</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Multiscale Codependence Analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Computation of Multiscale Codependence Analysis and spatial eigenvector maps.</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
    person(
      given = "Guillaume",
      family = "Guénard",
      role = c("aut","cre"),
      email = "guillaume.guenard@umontreal.ca",
      comment = c(ORCID = "0000-0003-0761-3072")),
    person(
      given = "Pierre",
      family = "Legendre",
      role = "ctb",
      email = "pierre.legendre@umontreal.ca",
      comment = c(ORCID = "0000-0002-3838-3305")
    ),
    person(
      given = "Bertrand",
      family = "Pages",
      role = "ctb"
    )
  )</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> grDevices, graphics, stats, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Doubs                   The Doubs Fish Data
Euclid                  Calculation of the Euclidean Distance
LGDat                   Legendre and Gallagher Synthetic Example
LGTransforms            Transformation for Species Abundance Data
MCA                     Multiple-descriptors, Multiscale Codependence
                        Analysis
cdp-class               Class and Methods for Multiscale Codependence
                        Analysis (MCA)
codep_PACKAGE           Multiscale Codependence Analysis
cthreshold              Familywise Type I Error Rate
eigenmap                Spatial Eigenvector Maps
eigenmap-class          Class and Methods for Spatial Eigenvector Maps
geodesics               Calculation of Geodesic Distances
minpermute              Number of Permutations for MCA
mite                    The Oribatid Mite Data Set
product-distribution    Frequency Distributions for MCA Parametric
                        Testing
salmon                  The St. Marguerite River Altantic Salmon Parr
                        Transect
weighting-functions     Weighting Functions for Spatial Eigenvector Map
</pre>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to multiscale
codependence analysis: Assessing the drivers of community structure across
spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>See Also</h3>

<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Neatherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mite)
emap &lt;- eigenmap(x = mite.geo, weighting = wf.RBF, wpar = 0.1)
emap

## Organize the environmental variables
mca0 &lt;- MCA(Y = log1p(mite.species), X = mite.env, emobj = emap)
mca0_partest &lt;- test.cdp(mca0, response.tests = FALSE)
summary(mca0_partest)
plot(mca0_partest, las = 2, lwd = 2)
plot(mca0_partest, col = rainbow(1200)[1L:1000], las = 3, lwd = 4,
     main = "Codependence diagram", col.signif = "white")

rng &lt;- list(x = seq(min(mite.geo[,"x"]) - 0.1, max(mite.geo[,"x"]) + 0.1, 0.05),
            y = seq(min(mite.geo[,"y"]) - 0.1, max(mite.geo[,"y"]) + 0.1, 0.05))
grid &lt;- cbind(x = rep(rng[["x"]], length(rng[["y"]])),
              y = rep(rng[["y"]], each = length(rng[["x"]])))
newdists &lt;- matrix(NA, nrow(grid), nrow(mite.geo))
for(i in 1L:nrow(grid)) {
  newdists[i,] &lt;- ((mite.geo[,"x"] - grid[i,"x"])^2 +
                   (mite.geo[,"y"] - grid[i,"y"])^2)^0.5
}

spmeans &lt;- colMeans(mite.species)
pca0 &lt;- svd(log1p(mite.species) - rep(spmeans, each = nrow(mite.species)))

prd0 &lt;- predict(
  mca0_partest,
  newdata = list(target = eigenmap.score(emap, newdists))
)
Uprd0 &lt;- (prd0 - rep(spmeans, each = nrow(prd0))) %*% pca0$v %*%
  diag(pca0$d^-1)

## Printing the response variable
prmat &lt;- Uprd0[,1L]
dim(prmat) &lt;- c(length(rng$x), length(rng$y))
zlim &lt;- c(min(min(prmat), min(pca0$u[,1L])), max(max(prmat), max(pca0$u[,1L])))
image(z = prmat, x = rng$x, y = rng$y, asp = 1, zlim = zlim,
      col = rainbow(1200L)[1L:1000], ylab = "y", xlab = "x")
points(
  x = mite.geo[,"x"], y = mite.geo[,"y"], pch = 21,
  bg = rainbow(1200L)[round(1+(999*(pca0$u[,1L] - zlim[1L])/
                    (zlim[2L] - zlim[1L])),0)]
)

</code></pre>

<hr>
<h2 id='cdp-class'>Class and Methods for Multiscale Codependence Analysis (MCA)</h2><span id='topic+cdp-class'></span><span id='topic+print.cdp'></span><span id='topic+plot.cdp'></span><span id='topic+summary.cdp'></span><span id='topic+fitted.cdp'></span><span id='topic+residuals.cdp'></span><span id='topic+predict.cdp'></span>

<h3>Description</h3>

<p>A class and set of methods to handle the results of Multiscale Codependence
Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdp'
print(x, ...)

## S3 method for class 'cdp'
plot(x, col, col.signif = 2, main = "", ...)

## S3 method for class 'cdp'
summary(object, ...)

## S3 method for class 'cdp'
fitted(object, selection, components = FALSE, ...)

## S3 method for class 'cdp'
residuals(object, selection, ...)

## S3 method for class 'cdp'
predict(object, selection, newdata, components = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdp-class_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+cdp-class">cdp-class</a></code> object.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to other functions or methods.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_col">col</code></td>
<td>
<p>A vector of color values to be used for plotting the multivariate
codependence coefficients.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_col.signif">col.signif</code></td>
<td>
<p>Color of the frame used to mark the statistically
significant codependence coefficients.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_main">main</code></td>
<td>
<p>Text for the main title of the plot.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+cdp-class">cdp-class</a></code> object.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_selection">selection</code></td>
<td>
<p>A numeric vector of indices or character vector variable
names to test or force-use. Mandatory if <code>object</code> is untested.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_components">components</code></td>
<td>
<p>A boolean specifying whether the components of fitted or
predicted values associated with single eigenfunctions in the map should be
returned.</p>
</td></tr>
<tr><td><code id="cdp-class_+3A_newdata">newdata</code></td>
<td>
<p>A list with elements $X, $meanY, and $target that contain the
information needed to make predictions (see details).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>cdp-class objects contain:
</p>

<dl>
<dt>data</dt><dd><p> A list with two elements: the first being a copy of the
response ('Y') and the second being a copy of the explanatory variables
('X'). This is the variables that were given to <code><a href="#topic+MCA">MCA</a></code>. </p>
</dd>
<dt>emobj</dt><dd><p> The <a href="#topic+eigenmap-class">eigenmap-class</a> object that was given to
<code><a href="#topic+MCA">MCA</a></code>. </p>
</dd>
<dt>UpYXcb</dt><dd><p> A list with five elements: the first ('UpY') is a matrix of
the cross-products of structuring variable ('U') and the response
variable 'Y', the second ('UpX') is a matrix of the cross-product of the
structuring variable and the explanatory variables ('X'), the third ('C')
is a 3-dimensional array of the codependence coefficients, the fourth
('B') is a 3-dimensional array of the coregression coefficients, and the
fifth ('CM') is a matrix of the multivariate codependence coefficients. </p>
</dd>
<dt>test</dt><dd><p> Results of statistical testing as performed by
<code><a href="#topic+test.cdp">test.cdp</a></code> or <code><a href="#topic+permute.cdp">permute.cdp</a></code>. <code>NULL</code> if no
testing was performed, such as when only <code><a href="#topic+MCA">MCA</a></code> had been
called. The results of statistical testing is a list containing the
following members:
</p>

<dl>
<dt>$permute</dt><dd><p> The number of randomized permutations used by
<code>permute.cdp</code> for permutation testing. 0 or <code>FALSE</code> for
parametric testing obtained using <code><a href="#topic+test.cdp">test.cdp</a></code>. </p>
</dd>
<dt>$significant</dt><dd><p> The indices of codependence coefficient describing
statistically significant codependence between 'Y' and 'X', in
decreasing order of magnitude. </p>
</dd>
<dt>$global</dt><dd><p> The testing table (a 5-column matrix) with phi
statistics, degrees-of-freedom, and testwise and familywise
probabilities of type I (alpha) error. It contains one line for each
statistically significant global coefficient (if any) in addition to
test results for the first, non-significant coefficient, on which the
testing procedure stopped. </p>
</dd>
<dt>$response</dt><dd><p> Tests of every single response variable (a
3-dimensional array), had such tests been requested while calling the
testing function, <code>NULL</code> otherwise. </p>
</dd>
<dt>$permutations</dt><dd><p> Details about permutation testing not shown in
'test$global' or 'test$response'. <code>NULL</code> for parametric
testing. </p>
</dd>
</dl>

</dd>
</dl>



<h3>Details</h3>

<p>The 'fitted', 'residuals', and 'predict' methods return a matrix of fitted,
residuals, or predicted values, respectively. The 'fitted' and 'predict'
methods return a list a list when argument 'component' is <code>TRUE</code>. The
list contains the 'fitted' or 'predicted' values as a first element and an
array 'components' as a second. That 3-dimensional array has one matrix for
each statistically significant codependence coefficient.
</p>
<p>For making predictions, argument <code>newdata</code> may contain three elements:
'$X', a matrix of new values of the explanatory variables, '$meanY', a vector
of the predicted mean values of the responses, and '$target', a matrix of
target scores for arbitrary locations within the study area. When no '$X' is
supplied, the descriptor given to <code><a href="#topic+MCA">MCA</a></code> is recycled, while when
no '$meanY' is supplied, the mean values of the response variables given to
<code><a href="#topic+MCA">MCA</a></code> are used.
</p>
<p>Finally, when element '$target' is omitted from argument <code>newdata</code>,
predictions are made at the sites were observations were done. When none of
the above is provided, or if <code>newdata</code> is omitted when calling the
prediction method, the behaviour of the 'predict' method is identical to
that of the 'fitted' method.
</p>
<p>From version 0.7-1, <a href="#topic+cdp-class">cdp-class</a> replaces the former class
<code>mca</code> used by <a href="#topic+codep-package">codep-package</a> because the standard package MASS
also had S3 methods for a class named <code>mca</code> that were overwritten by
those of <a href="#topic+codep-package">codep-package</a>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(cdp)</code>: Print method for cdp-class objects.
</p>
</li>
<li> <p><code>plot(cdp)</code>: Plot method for cdp-class objects.
</p>
</li>
<li> <p><code>summary(cdp)</code>: Summary method for cdp-class objects.
</p>
</li>
<li> <p><code>fitted(cdp)</code>: Fitted method for cdp-class objects.
</p>
</li>
<li> <p><code>residuals(cdp)</code>: Residuals method for cdp-class objects.
</p>
</li>
<li> <p><code>predict(cdp)</code>: Predict method for cdp-class objects.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to multiscale
codependence analysis: Assessing the drivers of community structure across
spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>

<hr>
<h2 id='cthreshold'>Familywise Type I Error Rate</h2><span id='topic+cthreshold'></span>

<h3>Description</h3>

<p>Function to calculate the testwise type I error rate threshold corresponding
to a give familywise threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cthreshold(alpha, nbtest)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cthreshold_+3A_alpha">alpha</code></td>
<td>
<p>The familywise type I error threshold.</p>
</td></tr>
<tr><td><code id="cthreshold_+3A_nbtest">nbtest</code></td>
<td>
<p>The number of tests performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type I error rate inflation occurs when a single hypothesis is
tested indirectly using inferences about two or more (i.e., a family of)
sub-hypotheses. In such situation, the probability of type I error (i.e., the
probability of incorrectly rejecting the null hypothesis) of the single,
familywise, hypothesis is higher than the lowest, testwise, probabilities. As
a consequence, the rejection of null hypothesis for one or more individual
tests does not warrant that the correct decision (whether to reject the the
null hypothesis on a familywise basis) was taken properly. This function
allows to obtain correct, familywise, alpha thresholds in the context of
multiple testing. It is base on the Sidak inegality.
</p>


<h3>Value</h3>

<p>The threshold that have to be used for individual tests.
</p>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Sidak, Z. 1967. Rectangular Confidence Regions for Means of Multivariate
Normal Distributions J. Am. Stat. Assoc. 62: 626-633
</p>
<p>Wright, P. S. 1992. Adjusted p-values for simultaneous inference. Biometrics
48: 1005-1013
</p>


<h3>See Also</h3>

<p>Legendre, P. and Legendre, L. 1998. Numerical Ecology. Elsevier
Science B.V., Amsterdam, The Neatherlands. p. 18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For a familywise threshold of 5% with 5 tests:
cthreshold(0.05, 5)   ## The corrected threshold for each test is 0.01020622

</code></pre>

<hr>
<h2 id='Doubs'>The Doubs Fish Data</h2><span id='topic+Doubs'></span><span id='topic+Doubs.fish'></span><span id='topic+Doubs.env'></span><span id='topic+Doubs.geo'></span>

<h3>Description</h3>

<p>Fish community composition of the Doubs River, France.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Doubs)
</code></pre>


<h3>Format</h3>

<p>Contains three matrices:
</p>

<dl>
<dt>Doubs.fish</dt><dd><p> The abundance of 27 fish species. </p>
</dd>
<dt>Doubs.env</dt><dd><p> Nine environmental variables (all quantitative). </p>
</dd>
<dt>Doubs.geo</dt><dd><p> Geographic information of the samples. </p>
</dd>
</dl>



<h3>Details</h3>

<p>Values in 'Doubs.fish' are counts of individuals of each of 27
species observed in a set of 30 sites located along the 453 km long Doubs
River, France (see Verneaux 1973 for further details about fishing methods
and effort).
</p>

<dl>
<dt>Doubs.env</dt><dd><p> contains 11 quantitative variables, namely the slope
('slo'; 1/1000) and mean minimum discharge ('flo' m³/s) of the river, the
pH of the water, its harness (Calcium concentration; 'har'; mg/L),
phosphate ('pho'; mg/L), nitrate ('nit'; mg/L), and ammonium ('amm'; mg/L),
concentration as well as its dissolved oxygen ('oxy'; mg/L) and biological
oxygen demand ('bdo'; mg/L).</p>
</dd>
<dt>Doubs.geo</dt><dd><p> contains geographical information. 'Lon', the longitude and
'Lat', the latitude of the sample (degree) as well as 'DFS', its distance
from the source of the river (km) and 'Alt', altitude (m above see
level). </p>
</dd>
</dl>



<h3>Source</h3>

<p>Verneaux, 1973
</p>


<h3>References</h3>

<p>Verneaux J. 1973. - Cours d'eau de Franche-Comté (Massif du Jura). Recherches
écologiques sur le réseau hydrographique du Doubs. Essai de biotypologie.
Thèse d'état, Besançon. 257 p.)
</p>
<p>Verneaux, J.; Schmitt, V.; Verneaux, V. &amp; Prouteau, C. 2003. Benthic insects
and fish of the Doubs River system: typological traits and the development of
a species continuum in a theoretically extrapolated watercourse.
Hydrobiologia 490: 60-74
</p>


<h3>See Also</h3>

<p>Borcard, D.; Gillet, F. &amp; Legendre, P. 2011. Numerical Ecology with R.
Springer, New-York, NY, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Doubs)
summary(Doubs.fish)
summary(Doubs.env)
summary(Doubs.geo)

</code></pre>

<hr>
<h2 id='eigenmap'>Spatial Eigenvector Maps</h2><span id='topic+eigenmap'></span><span id='topic+eigenmap.score'></span>

<h3>Description</h3>

<p>Function to calculate spatial eigenvector maps of a set of locations
in a space with an arbitrary number of dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenmap(
  x,
  alt.coord = NA,
  weighting = wf.sqrd,
  boundaries,
  wpar,
  tol = .Machine$double.eps^0.5
)

eigenmap.score(emap, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenmap_+3A_x">x</code></td>
<td>
<p>A set of coordinates defined in one (numeric vector) or many (a
coordinate x dimension matrix) dimensions or, alternatively, a distance
matrix provided by <code><a href="stats.html#topic+dist">dist</a></code>.</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_alt.coord">alt.coord</code></td>
<td>
<p>Coordinates to be used when a distance matrix is
provided as x. Used for plotting purposes.</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_weighting">weighting</code></td>
<td>
<p>The function to obtain the edge weighting matrix (see
details).</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_boundaries">boundaries</code></td>
<td>
<p>When required by argument <code>weighting</code>, a two-element
numeric vector containing the lower and upper threshold values used to obtain
the connectivity matrix (see <a href="#topic+weighting-functions">weighting-functions</a>).</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_wpar">wpar</code></td>
<td>
<p>Shape parameter for argument <code>weignting</code> (optional).</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_tol">tol</code></td>
<td>
<p>The smallest absolute eigenvalue for a spatial eigenfunctions to
be considered as a suitable predictor. Default:
<code>.Machine$double.eps^0.5</code> (a machine-dependent value).</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_emap">emap</code></td>
<td>
<p>An <a href="#topic+eigenmap-class">eigenmap-class</a> object.</p>
</td></tr>
<tr><td><code id="eigenmap_+3A_target">target</code></td>
<td>
<p>A (generally rectangular) distance matrix between a set of
target locations for which spatially-explicit predictions are being made
(rows), and the reference locations given to function <code>eigenmap</code>
(columns). See example 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When function <code>eigenmap</code> is given coordinates as its argument
<code>x</code>, they are treated as Cartesian coordinates and the distances between
them are assumed to be Euclidean. Otherwise (e.g., when geodesic distances
are used), distances have to be provided as the argument <code>x</code> and
plotting coordinates have to be supplied as argument <code>alt.coord</code>.
</p>
<p>The weighting function (see <a href="#topic+weighting-functions">weighting-functions</a>) must have the
distances as its first argument, optionally an argument named
<code>boundaries</code> giving the boundaries within which locations are regarded
as neighbours and/or an argument <code>wpar</code> containing any other weighting
function parameters.
</p>
<p>Default values for argument <code>boundaries</code> are 0 for the minimum value and
<code>NA</code> for the maximum. For weighting functions with an argument
<code>bounraries</code>, The upper value <code>NA</code> indicates the function to take
the minimum value that allow every locations to form a single cluster
following single linkage clustering as a maximum value (obtained internally
from a call to <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>eigenmap()</code>: Main function for generating an eigenmap-class object from Cartesian
coordinates or pairwise distances.
</p>
</li>
<li> <p><code>eigenmap.score()</code>: Generate scores for arbitrary locations within the scope of an existing
eigenvector map.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of ecological
data by means of principal coordinates of neighbour matrices. Ecol. Model.
153: 51-68
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example 1: A linear transect.
data(salmon)

## A warning is issued when no boundaries are provided for a function that
## requires them.
## Example:
map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary)
map
## plot(map)

## In the following examples, boundaries are provided; they are needed by the
## functions.
map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf1,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf2,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.Drayf3,
                boundaries = c(0,20), wpar = 2)
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.PCNM,
                boundaries = c(0,20))
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.sqrd)
map
## plot(map)

map &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.RBF, wpar = 0.001)
map
## plot(map)

### Example 2: Using predictor scores

smpl &lt;- c(4,7,10,14,34,56,61,64)  # A sample to be discarded
map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.sqrd)
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[,-smpl]
       )
## Scores of sampling points are the eigenvectors
scr[smpl,]

wh &lt;- 5L   # You can try with other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[5]),
     xlab = "Position along transect")
points(y = scr[smpl,wh], x = salmon[smpl,"Position"], pch = 21L,
       bg = "black")

map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.binary,
                boundaries = c(0,20))
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[smpl,-smpl])

## Plot the 8 prediction sites along particular eigenvectors, here
## eigenvector #1:
wh &lt;- 1L   # One could try the other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[1L]),
     xlab = "Position along transect (m)")
points(y = scr[,wh], x = salmon[smpl,"Position"], pch=21L, bg = "black")

map &lt;- eigenmap(x = salmon[-smpl,"Position"], weighting = wf.PCNM,
                boundaries = c(0,100))
scr &lt;- eigenmap.score(
         map, target = as.matrix(dist(salmon[,"Position"]))[smpl,-smpl]
       )

wh &lt;- 1L   # You can try with other vectors.
plot(map$U[,wh] ~ salmon[-smpl,"Position"], ylab = expression(U[1]),
     xlab = "Position along transect (m)")
points(y = scr[,wh], x = salmon[smpl,"Position"], pch = 21L, bg = "black")

### Example 3: A unevenly sampled surface.

data(mite)

## Example using the principal coordinates of the square root of the
## (Euclidean) distances:
map &lt;- eigenmap(x = as.matrix(mite.geo), weighting = wf.sqrd)
map
## plot(map)

## Example using the radial basis functions (RBF):
map &lt;- eigenmap(x = as.matrix(mite.geo), weighting = wf.RBF)
map
## plot(map)

</code></pre>

<hr>
<h2 id='eigenmap-class'>Class and Methods for Spatial Eigenvector Maps</h2><span id='topic+eigenmap-class'></span><span id='topic+print.eigenmap'></span><span id='topic+plot.eigenmap'></span>

<h3>Description</h3>

<p>Create and handle spatial eigenvector maps of a set of locations a space with
an arbitrary number of dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eigenmap'
print(x, ...)

## S3 method for class 'eigenmap'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenmap-class_+3A_x">x</code></td>
<td>
<p>an 'eigenmap-class' object.</p>
</td></tr>
<tr><td><code id="eigenmap-class_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to other functions or methods
(currently ignored).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>'eigenmap-class' objects contain:
</p>

<dl>
<dt>coordinates</dt><dd><p> A matrix of coordinates. </p>
</dd>
<dt>truncate</dt><dd><p> The interval within which pairs of sites are considered as
neighbours. </p>
</dd>
<dt>D</dt><dd><p> A distance matrix. </p>
</dd>
<dt>weighting</dt><dd><p> The weighting function that had been used. </p>
</dd>
<dt>wpar</dt><dd><p> The weighting function parameter that had been used. </p>
</dd>
<dt>lambda</dt><dd><p> A vector of the eigenvalues obtain from the computation
of the eigenvector map. </p>
</dd>
<dt>U</dt><dd><p> A matrix of the eigenvectors defining the eigenvector map. </p>
</dd>
</dl>



<h3>Details</h3>

<p>The 'print' method provides the number of the number of orthonormal
variables (i.e. basis functions), the number of observations these functions
are spanning, and their associated eigenvalues.
</p>
<p>The 'plot' method provides a plot of the eigenvalues and offers the
possibility to plot the values of variables for 1- or 2-dimensional sets of
coordinates. <code>plot.eigenmap</code> opens the default graphical device driver,
i.e., <code>X11</code>, <code>windows</code>, or <code>quartz</code> and recurses through
variable with a left mouse click on the graphical window. A right mouse click
interrupts recursing on <code>X11</code> and <code>windows</code> (Mac OS X users should
hit <em>Esc</em> on the <code>quartz</code> graphical device driver (Mac OS X users).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(eigenmap)</code>: Print method for eigenmap-class objects
</p>
</li>
<li> <p><code>plot(eigenmap)</code>: Plot method for eigenmap-class objects
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of ecological
data by means of principal coordinates of neighbour matrices. Ecol. Model.
153: 51-68
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Netherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCA">MCA</a></code>
<code><a href="#topic+eigenmap">eigenmap</a></code>
</p>

<hr>
<h2 id='Euclid'>Calculation of the Euclidean Distance</h2><span id='topic+Euclid'></span>

<h3>Description</h3>

<p>Function <code>Euclid</code> carries out the calculation of pairwise Euclidean
distances within a set of coordinates or between two sets thereof, with
optional weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Euclid(x, y, squared = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Euclid_+3A_x">x</code></td>
<td>
<p>A set of coordinates in the form of a <code><a href="base.html#topic+matrix">matrix</a></code> or
<code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="Euclid_+3A_y">y</code></td>
<td>
<p>An optional second set of coordinates in the same dimensions as
argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="Euclid_+3A_squared">squared</code></td>
<td>
<p>Should the squared Euclidean distances be returned (default:
FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only one set of coordinates is given to the function (i.e.,
when argument <code>y</code> is omitted), the function returns the pairwise
distances in the form of a '<a href="stats.html#topic+dist">dist</a>-class' object representing a
lower-triangle matrix. If weights are omitted, the result is identical to
that produced by function <a href="stats.html#topic+dist">dist</a> with argument
<code>method = "euclidean"</code> (the function's default).
</p>
<p>The standard 'R' function used to calculate the Euclidean distance
(<code><a href="stats.html#topic+dist">dist</a></code>), only allows one to calculate pairwise distances between
the rows of a single matrix of Cartesian coordinates and return a
'<a href="stats.html#topic+dist">dist</a>-class' object, which is a one-dimensional array meant to be
interpreted as a lower-triangular matrix. Function <code>Euclid</code> can also be
provided two data matrices (arguments <code>x</code> and <code>y</code>) and output a
rectangular matrix of the Euclidean distances.
</p>


<h3>Value</h3>

<p>A '<a href="stats.html#topic+dist">dist</a>-class' object or, whenever <code>y</code> is provided,
a <code><a href="base.html#topic+matrix">matrix</a></code> with as many rows as the number of rows in <code>x</code>
and as many columns as the number of rows in <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>See Also</h3>

<p>The '<a href="stats.html#topic+dist">dist</a>-class' and associated methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A set of reference points:
x &lt;- cbind(c(1,4,5,2,8,4), c(3,6,7,1,3,2))
dimnames(x) &lt;- list(LETTERS[1:6], c("x", "y"))

## The pairwise Euclidean distances among the reference points: 
d1 &lt;- Euclid(x)
d1

## That result is the same as that obtained from function dist:
d2 &lt;- dist(x, method = "euclidean")
all(d1 == d2)

## A second set of points:
y &lt;- cbind(c(3,5,7), c(3,6,8))
dimnames(y) &lt;- list(LETTERS[7:9], c("x", "y"))

## The distances between the points in y (rows) and x (columns):
Euclid(x, y)

</code></pre>

<hr>
<h2 id='geodesics'>Calculation of Geodesic Distances</h2><span id='topic+geodesics'></span>

<h3>Description</h3>

<p>Function <code>geodesics</code> carries out the calculation of pairwise geodesic
distances within a set of coordinates or between two sets thereof, using one
of two calculation approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesics(
  x,
  y,
  method = c("haversine", "Vincenty"),
  radius = 6371000,
  sma = 6378137,
  flat = 1/298.257223563,
  maxiter = 1024L,
  tol = .Machine$double.eps^0.75
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geodesics_+3A_x">x</code></td>
<td>
<p>A set of geographic coordinates in the form of a two-column
<code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
<tr><td><code id="geodesics_+3A_y">y</code></td>
<td>
<p>An other two-column <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code>
containing an optional second set of coordinates.</p>
</td></tr>
<tr><td><code id="geodesics_+3A_method">method</code></td>
<td>
<p>The calculation method used to obtain the distances (default:
haversine method; see details).</p>
</td></tr>
<tr><td><code id="geodesics_+3A_radius">radius</code></td>
<td>
<p>Radius of the planetary body (when assuming a sphere; default:
6371000 m).</p>
</td></tr>
<tr><td><code id="geodesics_+3A_sma">sma</code></td>
<td>
<p>Length of the semi-major axis of the planetary body (when assuming
a revolution ellipsoid; default: 6378137 m).</p>
</td></tr>
<tr><td><code id="geodesics_+3A_flat">flat</code></td>
<td>
<p>Flattening of the ellipsoid (default: 1/298.257223563).</p>
</td></tr>
<tr><td><code id="geodesics_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations, whenever iterative calculation
is involved (default: 1024).</p>
</td></tr>
<tr><td><code id="geodesics_+3A_tol">tol</code></td>
<td>
<p>Tolerance used when iterative calculation is involved (default:
<code>.Machine$double.eps^0.75</code>; a machine dependent value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When only one set of coordinates is given to the function (i.e.,
when argument <code>y</code> is omitted), the function returns the pairwise
distances in the form of a '<a href="stats.html#topic+dist">dist</a>-class' object representing a
lower-triangle matrix. When the second coordinate set is given, the function
calculates the distances between each coordinate of argument <code>x</code> and
each coordinate of argument <code>y</code>.
</p>
<p>Two calculation methods are implemented. The first is the haversine formula,
which assume the planetary body to be a sphere. The radius of that sphere is
given to the function as its argument <code>radius</code>, with the default value
being the mean radius of planet earth. Of the two methods implemented, the
haversine formula is fastest but its precision depend on how well the
planetary body match the sphericity assumption. The second method implemented
is Vincenty's inverse formula, which assumes the the planetary body is a
revolution ellipsoid, which is expected for rotating semi-fluid such as
planet earth. Argument <code>sma</code>, the length of the semi-major axis,
corresponds to the radius of the circle obtained when the revolution
ellipsoid at the equator, whereas argument <code>flat</code> correspond to the
compression of the sphere, along the diameter joining the poles, to form the
ellipsoid of revolution. Their default values corresponds to parameters for
planet Earth according to WGS84. These values, along with arguments
<code>maxiter</code> and <code>tol</code>, are ignored when using the haversine formula,
whereas the value of argument <code>radius</code> is ignored when using Vincenty's
inverse formula.
</p>
<p>Vincenty's inverse formula is more precise on planet Earth (on the order of
0.5mm) than the haversine formula, but it involves more computation time and
may sometimes fail to converge. This is more likely for pairs of locations
that are nearly antipodal or both (numerically) very close to the equator.
The results returned by the function when using Vincenty's inverse formula
are given a <code>niter</code> attribute that gives the number of iterations that
were necessary to achieve convergence. Numbers greater than argument
<code>maxiter</code> are indicative of failed convergence; a warning is issued in
such a circumstance.
</p>
<p>Geodesic distance matrices are non metric.
</p>


<h3>Value</h3>

<p>A '<a href="stats.html#topic+dist">dist</a>-class' object or, whenever argument <code>y</code> is
provided, a <code><a href="base.html#topic+matrix">matrix</a></code> with as many rows as the number of rows in
argument <code>x</code> and as many columns as the number of rows in argument
<code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Vincenty, T. 1975. Direct and Inverse Solutions of Geodesics on the Ellipsoid 
with application of nested equations. Survey Review XXIII (176): 88-93
doi:10.1179/sre.1975.23.176.88
</p>
<p>Inman, J. 1835. Navigation and Nautical Astronomy: For the Use of British
Seamen (3 ed.). London, UK: W. Woodward, C. &amp; J. Rivington
</p>


<h3>See Also</h3>

<p>The <code><a href="stats.html#topic+dist">dist</a>-class</code> and associated methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
### First example: locations spread throughout the world
##
coords &lt;- cbind(c(43,22,9,12,-40,72,-86,-22),
                c(-135,22,0,1,-45,12,27,-139))
res_hav &lt;- geodesics(coords)  ## Default: the haversine formula
res_hav
res_vif &lt;- geodesics(coords, method = "Vincenty")
res_vif
attr(res_vif,"niter") ## The numbers of iterations
res_vif-res_hav       ## Absolute difference
200*(res_vif-res_hav)/(res_vif+res_hav) ## Large relative difference
##
### Second example: locations nearer from one another
##
coords &lt;- cbind(c(45.01,44.82,45.23,44.74),
                c(72.03,72.34,71.89,72.45))
res_hav &lt;- geodesics(coords)
res_vif &lt;- geodesics(coords, method = "Vincenty")
res_vif-res_hav       ## Absolute difference
200*(res_vif-res_hav)/(res_vif+res_hav) ## Relative difference are smaller
##

</code></pre>

<hr>
<h2 id='LGDat'>Legendre and Gallagher Synthetic Example</h2><span id='topic+LGDat'></span>

<h3>Description</h3>

<p>A data set used as a synthetic example in paper Legendre and Gallagher
(2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LGDat)
</code></pre>


<h3>Format</h3>

<p>A 19 rows by 10 columns <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Details</h3>

<p>This synthetic data set is described by Legendre and Gallagher
(2001) and was used to test species abundance transformations. Its first
column contains geographic locations from 1 to 19 (no particular units are
specified). The five columns that follow contain abundances of five species
with abundances peaking at 7-8 at different locations (site 1, 5, 10, 15, and
19). The latter are considered &quot;abundant species&quot;. For next four columns
contains abundances of &quot;rare species&quot; occurring in between the abundance
species (abundances from 1 to 4).
</p>


<h3>Source</h3>

<p>Legendre, P. &amp; Gallagher E. D. 2001. Ecologically meaningful
transformations for ordination of species data. Oecologia 129: 271-280
doi: 10.1007/s004420100716
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LGDat)
summary(LGDat)

</code></pre>

<hr>
<h2 id='LGTransforms'>Transformation for Species Abundance Data</h2><span id='topic+LGTransforms'></span>

<h3>Description</h3>

<p>Calculates the transformed species abundances following Legendre and
Gallagher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LGTransforms(
  x,
  method = c("chord", "chisq", "profile", "Hellinger"),
  offset = 0,
  power = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LGTransforms_+3A_x">x</code></td>
<td>
<p>A species abundance matrix (rows: sites, columns: species).</p>
</td></tr>
<tr><td><code id="LGTransforms_+3A_method">method</code></td>
<td>
<p>The transformation method, one of &quot;chord&quot; (the default),
&quot;chisq&quot;, &quot;profile&quot;, or &quot;Hellinger&quot; (see details).</p>
</td></tr>
<tr><td><code id="LGTransforms_+3A_offset">offset</code></td>
<td>
<p>Offset value applied to all the columns of <code>x</code> prior to
the other transformations (default: <code>0</code>, see Details).</p>
</td></tr>
<tr><td><code id="LGTransforms_+3A_power">power</code></td>
<td>
<p>Exponent for the power transformation (Box-Cox) applied
to all columns of <code>x</code> after the offset and before the transformation
specified by argument <code>method</code> (default: <code>1</code>, see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These transformations of species abundances values are useful for
multivariate least squares methods for ordination methods, such as the
principal component analysis, or modelling methods, such as the multiscale
codependence analysis (<code><a href="#topic+MCA">MCA</a></code>), the canonical redundancy analysis
(RDA). They allow one to use least squares methods, which operate on the
basis of the Euclidean metric, on species abundance data, for which the
Euclidean metric have generally inadequate properties (see Legendre &amp;
Gallagher 2001 and Legendre &amp; Borcard 2018, in references below, for a
thorough discussion on the topic).
</p>
<p>The power (Box Cox) transformation involves the following equation:
</p>
<p>y' = (y + offset)^power    if power != 0
</p>
<p>y' = log(y + offset)       if power == 0
</p>
<p>The default values for <code>offset</code> (<code>0</code>) and <code>power</code> (<code>1</code>)
correspond to applying no transformation besides that specified by argument
<code>methods</code>.
</p>


<h3>Value</h3>

<p>A matrix of the transformed species abundances.
</p>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Legendre P. &amp; Gallagher E. D. 2001. Ecologically meaningful transformations
for ordination of species data. Oecologia 129: 271-280
doi: 10.1007/s004420100716
</p>
<p>Box G. E. P. &amp; Cox D. R. 1964. An analysis of transformations. Journal of
the Royal Statistical Society Series B 26: 211-243
</p>
<p>Legendre P. &amp; Borcard D. 2018. Box-Cox-chord transformations for community
composition data prior to beta diversity analysis. Ecography 41: 1820-1824.
doi: 0.1111/ecog.03498
</p>
<p>Legendre, P. &amp; Legendre, L. 2012. Numerical Ecology, Third English Edition.
Elsevier B. V. Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Doubs)

## Removing any species that have not been not observed:
Doubs.fish -&gt; x
x[rowSums(x)!=0,] -&gt; x

## Transforming the abundances
LGTransforms(x,"chord") -&gt; chord
LGTransforms(x,"chord",offset=1,power=0) -&gt; log.chord
LGTransforms(x,"chord",power=0.25) -&gt; pow.chord
LGTransforms(x,"chisq") -&gt; chisq
LGTransforms(x,"profile") -&gt; sp_pr
LGTransforms(x,"Hellinger") -&gt; Helli

dist(chord)
dist(log.chord)
dist(pow.chord)
dist(chisq)
dist(sp_pr)
dist(Helli)

## Legendre &amp; Gallagher synthetic examples:

data(LGDat)

## Diastemograms:

as.matrix(dist(LGDat[,1L])) -&gt; geo
geo[upper.tri(geo)] -&gt; geo

## Raw Euclidean distances
par(mfrow=c(1,1), mar=c(5,5,4,2))

as.matrix(dist(LGDat[,-1L])) -&gt; eco
eco[upper.tri(eco)] -&gt; eco

plot(eco~geo, data=data.frame(geo=geo, eco=eco),
     xaxp=c(1,18,17), las=1, ylim=c(0,max(eco)),
     xlab="True geographic distance",
     ylab="Euclidean distance")

## Euclidean distances on the transformed abundances:
par(mfrow=c(3,2), mar=c(3,5,4,2))

LGTransforms(LGDat[,-1L],"chord") -&gt; chord
as.matrix(dist(chord)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Chord distance",ylim=c(0,max(eco)))

LGTransforms(LGDat[,-1L],"chord",offset=1,power=0) -&gt; log.chord
as.matrix(dist(log.chord)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Chord distance (log(x+1))",ylim=c(0,max(eco)))

par(mar=c(4,5,3,2))

LGTransforms(LGDat[,-1L],"chord",power=0.25) -&gt; pow.chord
as.matrix(dist(pow.chord)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Chord distance (power=0.25)",ylim=c(0,max(eco)))

LGTransforms(LGDat[,-1L],"chisq") -&gt; chisq
as.matrix(dist(chisq)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Chi-square distance",ylim=c(0,max(eco)))

par(mar=c(5,5,2,2))

LGTransforms(LGDat[,-1L],"profile") -&gt; sp_pr
as.matrix(dist(sp_pr)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Dist. between profiles",ylim=c(0,max(eco)))

LGTransforms(LGDat[,-1L],"Hellinger") -&gt; Helli
as.matrix(dist(Helli)) -&gt; eco
eco[upper.tri(eco)] -&gt; eco
plot(eco~geo,data=data.frame(geo=geo,eco=eco),
     xaxp=c(1,18,17),las=1,xlab="",ylab="",
     main="Hellinger distance",ylim=c(0,max(eco)))

mtext(text="True geographic distance", side=1, line=-1.5, outer=TRUE)
mtext(text="Ecological distance", side=2, line=-1.5, outer=TRUE)

## Examples from Legendre &amp; Legendre 2012, page 329 (Figure 7.8):

matrix(c(0,0,1,4,1,0,8,1,0),3L,3L) -&gt; LL329

## D1:  Euclidean distance
dist(LL329)

## Chord transformation (D3: chord distance)
LGTransforms(LL329,"chord") -&gt; tr       
tr
dist(tr)

## "Species profile" transformation (D18)
LGTransforms(LL329,"profile") -&gt; tr       
tr
dist(tr)

## Hellinger transformation (D17: Hellinger distance)
LGTransforms(LL329,"Hellinger") -&gt; tr       
tr
dist(tr)

## Chi-square transformation (D16: Chi-square distance)
LGTransforms(LL329,"chisq") -&gt; tr       
tr
dist(tr)

</code></pre>

<hr>
<h2 id='MCA'>Multiple-descriptors, Multiscale Codependence Analysis</h2><span id='topic+MCA'></span><span id='topic+test.cdp'></span><span id='topic+permute.cdp'></span><span id='topic+parPermute.cdp'></span>

<h3>Description</h3>

<p>Class, Functions, and methods to perform Multiscale Codependence Analysis
(MCA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCA(Y, X, emobj)

test.cdp(object, alpha = 0.05, max.step, response.tests = TRUE)

permute.cdp(object, permute, alpha = 0.05, max.step, response.tests = TRUE)

parPermute.cdp(
  object,
  permute,
  alpha = 0.05,
  max.step,
  response.tests = TRUE,
  nnode,
  seeds,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCA_+3A_y">Y</code></td>
<td>
<p>A numeric matrix or vector containing the response variable(s).</p>
</td></tr>
<tr><td><code id="MCA_+3A_x">X</code></td>
<td>
<p>A numeric matrix or vector containing the explanatory variable(s).</p>
</td></tr>
<tr><td><code id="MCA_+3A_emobj">emobj</code></td>
<td>
<p>A <a href="#topic+eigenmap-class">eigenmap-class</a> object.</p>
</td></tr>
<tr><td><code id="MCA_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+cdp-class">cdp-class</a> object.</p>
</td></tr>
<tr><td><code id="MCA_+3A_alpha">alpha</code></td>
<td>
<p>The type I (alpha) error threshold used by the
testing procedure.</p>
</td></tr>
<tr><td><code id="MCA_+3A_max.step">max.step</code></td>
<td>
<p>The maximum number of steps to perform when testing for
statistical significance.</p>
</td></tr>
<tr><td><code id="MCA_+3A_response.tests">response.tests</code></td>
<td>
<p>A boolean specifying whether to test individual
response variables.</p>
</td></tr>
<tr><td><code id="MCA_+3A_permute">permute</code></td>
<td>
<p>The number of random permutations used for testing. When
omitted, the number of permutations is calculated using function
<code><a href="#topic+minpermute">minpermute</a></code>.</p>
</td></tr>
<tr><td><code id="MCA_+3A_nnode">nnode</code></td>
<td>
<p>The number of parallel computation nodes.</p>
</td></tr>
<tr><td><code id="MCA_+3A_seeds">seeds</code></td>
<td>
<p>Seeds for computation nodes' random number generators when using
parallel computation during the permutation test.</p>
</td></tr>
<tr><td><code id="MCA_+3A_verbose">verbose</code></td>
<td>
<p>Whether to return user notifications.</p>
</td></tr>
<tr><td><code id="MCA_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to function <code>parallel::makeCluster</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiscale Codependence Analysis (MCA) allows to calculate
correlation-like (i.e.codependence) coefficients between two variables with
respect to structuring variables (Moran's eigenvector maps). The purpose of
this function is limited to parameter fitting.
</p>
<p>Test procedures are handled through <code>test.cdp</code> (parametric testing) or
<code>permute.cdp</code> (permutation testing). Moreover, methods are provided for
printing (<code>print.cdp</code>), displaying a summary of the tests
(<code>summary.cdp</code>), plotting results (<code>plot.cdp</code>), calculating
fitted (<code>fitted.cdp</code>) and residuals values (<code>redisuals.cdp</code>), and
making predictions (<code>predict.cdp</code>).
</p>
<p>It is noteworthy that the test procedure used by <code>MCA</code> deviates from the
standard R workflow since intermediate testing functions (<code>test.cdp</code> and
<code>permute.cdp</code>) need first to be called before any testing be performed.
</p>
<p>Function <code>parPermute.cdp</code> allows the user to spread the number of
permutation on many computation nodes. It relies on package parallel.
Omitting argument <code>nnode</code> lets function <code>parallel::detectCores</code>
specify the number of node. Similarly, omitting parameter <code>seeds</code> lets
the function define the seeds as a set of values drawn from a uniform random
distribution between with minimum value <code>-.Machine$integer.max</code> and
maximum value <code>.Machine$integer.max</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+cdp-class">cdp-class</a> object.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>MCA()</code>: Main function to compute the multiscale codependence analysis
</p>
</li>
<li> <p><code>test.cdp()</code>: Parametric statistical testing for multiscale codependence analysis
</p>
</li>
<li> <p><code>permute.cdp()</code>: Permutation testing for multiscale codependence analysis.
</p>
</li>
<li> <p><code>parPermute.cdp()</code>: Permutation testing for multiscale codependence analysis using parallel
processing.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to multiscale
codependence analysis: Assessing the drivers of community structure across
spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example 1: St. Marguerite River Salmon Transect
data(salmon)

## Converting the data from data frames to to matrices:
Abundance &lt;- log1p(as.matrix(salmon[,"Abundance",drop = FALSE]))
Environ &lt;- as.matrix(salmon[,3L:5])

## Creating a spatial eigenvector map:
map1 &lt;- eigenmap(x = salmon[,"Position"], weighting = wf.binary,
                 boundaries = c(0,20))

## Case of a single descriptor:
mca1 &lt;- MCA(Y = Abundance, X = Environ[,"Substrate",drop = FALSE],
            emobj = map1)
mca1
mca1_partest &lt;- test.cdp(mca1)
mca1_partest
summary(mca1_partest)
par(mar = c(6,4,2,4))
plot(mca1_partest, las = 3, lwd=2)
mca1_pertest &lt;- permute.cdp(mca1)
## Not run: 
## or:
mca1_pertest &lt;- parPermute.cdp(mca1, permute = 999999)

## End(Not run)
mca1_pertest
summary(mca1_pertest)
plot(mca1_pertest, las = 3)
mca1_pertest$UpYXcb$C # Array containing the codependence coefficients

## With all descriptors at once:
mca2 &lt;- MCA(Y = log1p(as.matrix(salmon[,"Abundance",drop = FALSE])),
            X = as.matrix(salmon[,3L:5]), emobj = map1)
mca2
mca2_partest &lt;- test.cdp(mca2)
mca2_partest
summary(mca2_partest)
par(mar = c(6,4,2,4))
plot(mca2_partest, las = 3, lwd=2)
mca2_pertest &lt;- permute.cdp(mca2)
## Not run: 
## or:
    mca2_pertest &lt;- parPermute.cdp(mca2, permute = 999999)

## End(Not run)
mca2_pertest
summary(mca2_pertest)
plot(mca2_pertest, las = 3, lwd=2)
mca2_pertest$UpYXcb$C # Array containing the codependence coefficients
mca2_pertest$UpYXcb$C[,1L,] # now turned into a matrix.

### Example 2: Doubs Fish Community Transect

data(Doubs)

## Sites with no fish observed are excluded:
excl &lt;- which(rowSums(Doubs.fish) == 0)

## Creating a spatial eigenvector map:
map2 &lt;- eigenmap(x = Doubs.geo[-excl,"DFS"])
## The eigenvalues are in map2$lambda, the MEM eigenvectors in matrix map2$U

## MCA with multivariate response data analyzed on the basis of the Hellinger
## distance:
Y &lt;- LGTransforms(Doubs.fish[-excl,],"Hellinger")

mca3 &lt;- MCA(Y = Y, X=Doubs.env[-excl,], emobj = map2)
mca3_pertest &lt;- permute.cdp(mca3)
## Not run: 
## or:
mca3_pertest &lt;- parPermute.cdp(mca3, permute = 999999)

## End(Not run)

mca3_pertest
summary(mca3_pertest)
par(mar = c(6,4,2,4))
plot(mca3_pertest, las = 2, lwd=2)

## Array containing all the codependence coefficients:
mca3_pertest$UpYXcb$C

## Display the results along the transect
spmeans &lt;- colMeans(Y)
pca1 &lt;- svd(Y - rep(spmeans, each=nrow(Y)))
par(mar = c(5,5,2,5) + 0.1)
plot(y = pca1$u[,1L], x = Doubs.geo[-excl,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA1 loadings", xlab = "Distance from river source (km)")

## A regular transect of sites from 0 to 450 (km) spaced by 1 km intervals
## (451 sites in total). It is used for plotting spatially-explicit
## predictions.

x &lt;- seq(0,450,1)
newdists &lt;- matrix(NA, length(x), nrow(Doubs.geo[-excl,]))
for(i in 1L:nrow(newdists))
  newdists[i,] &lt;- abs(Doubs.geo[-excl,"DFS"] - x[i])

## Calculating predictions for the regular transect under the same set of
## environmental conditions from which the codependence model was built.
prd1 &lt;- predict(mca3_pertest,
                newdata = list(target = eigenmap.score(map2, newdists)))

## Projection of the predicted species abundance on pca1:
Uprd1 &lt;-
  (prd1 - rep(spmeans, each = nrow(prd1))) %*%
  pca1$v %*% diag(pca1$d^-1)
lines(y = Uprd1[,1L], x = x, col=2, lty = 1)

## Projection of the predicted species abundance on pca2:
plot(y = pca1$u[,2L], x = Doubs.geo[-excl,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA2 loadings", xlab = "Distance from river source (km)")
lines(y = Uprd1[,2L], x = x, col = 2, lty = 1)

## Displaying only the observed and predicted abundance for Brown Trout.
par(new = TRUE)
plot(y = Y[,"TRU"], Doubs.geo[-excl,"DFS"], pch = 21L,
     bg = "green", ylab = "", xlab = "", new = FALSE, axes = FALSE)
axis(4)
lines(y = prd1[,"TRU"], x = x, col = 3)
mtext(side = 4, "sqrt(Brown trout rel. abundance)", line = 2.5)

### Example 3: Borcard et al. Oribatid Mite

## Testing the (2-dimensional) spatial codependence between the Oribatid Mite
## community structure and environmental variables, while displaying the
## total effects of the significant variables on the community structure
## (i.e., its first principal component).

data(mite)

map3 &lt;- eigenmap(x = mite.geo)

Y &lt;- LGTransforms(mite.species, "Hellinger")

## Organize the environmental variables
mca4 &lt;- MCA(Y = Y, X = mite.env, emobj = map3)
mca4_partest &lt;- test.cdp(mca4, response.tests = FALSE)
summary(mca4_partest)
plot(mca4_partest, las = 2, lwd = 2)
plot(mca4_partest, col = rainbow(1200)[1L:1000], las = 3, lwd = 4,
     main = "Codependence diagram", col.signif = "white")

## Making a regular point grid for plotting the spatially-explicit
## predictions:
rng &lt;- list(
  x = seq(min(mite.geo[,"x"]) - 0.1, max(mite.geo[,"x"]) + 0.1, 0.05),
  y = seq(min(mite.geo[,"y"]) - 0.1, max(mite.geo[,"y"]) + 0.1, 0.05))
grid &lt;- cbind(x = rep(rng[["x"]], length(rng[["y"]])),
              y = rep(rng[["y"]], each = length(rng[["x"]])))
newdists &lt;- matrix(NA, nrow(grid), nrow(mite.geo))
for(i in 1L:nrow(grid)) {
  newdists[i,] &lt;- ((mite.geo[,"x"] - grid[i,"x"])^2 +
                     (mite.geo[,"y"] - grid[i,"y"])^2)^0.5
}

spmeans &lt;- colMeans(Y)
pca2 &lt;- svd(Y - rep(spmeans, each = nrow(Y)))

prd2 &lt;- predict(mca4_partest,
                newdata = list(target = eigenmap.score(map3, newdists)))
Uprd2 &lt;-
  (prd2 - rep(spmeans, each = nrow(prd2))) %*%
  pca2$v %*% diag(pca2$d^-1)

## Printing the response variable (first principal component of the mite
## community structure).
prmat &lt;- Uprd2[,1L]
dim(prmat) &lt;- c(length(rng$x), length(rng$y))
zlim &lt;- c(min(min(prmat), min(pca2$u[,1L])), max(max(prmat),
                                                 max(pca2$u[,1L])))
image(z = prmat, x = rng$x, y = rng$y, asp = 1, zlim = zlim,
      col = rainbow(1200L)[1L:1000], ylab = "y", xlab = "x")
points(
  x=mite.geo[,"x"], y=mite.geo[,"y"], pch=21L,
  bg = rainbow(1200L)[round(1+(999*(pca2$u[,1L]-zlim[1L])/(zlim[2L]-zlim[1L])),0)])

</code></pre>

<hr>
<h2 id='minpermute'>Number of Permutations for MCA</h2><span id='topic+minpermute'></span>

<h3>Description</h3>

<p>Calculates the number of permutations suitable for testing Multiscale
Codependence Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minpermute(alpha, nbtest, margin = 1, ru = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minpermute_+3A_alpha">alpha</code></td>
<td>
<p>The familywise type I error threshold allowable for the complete
analysis.</p>
</td></tr>
<tr><td><code id="minpermute_+3A_nbtest">nbtest</code></td>
<td>
<p>The number of test performed (the number of eigenvectors in the
'mem' object in the case of <code><a href="#topic+MCA">MCA</a></code>).</p>
</td></tr>
<tr><td><code id="minpermute_+3A_margin">margin</code></td>
<td>
<p>A margin allowed for the number of permutation. Default value:
1.</p>
</td></tr>
<tr><td><code id="minpermute_+3A_ru">ru</code></td>
<td>
<p>The magnitude of the round-up to apply to the number of
permutations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculate the number of permutations for use with
<code><a href="#topic+permute.cdp">permute.cdp</a></code>. Argument <code>margin</code> allows to apply a safe
margin to the number of permutations. The minimal suitable value for this
parameter is 1. Argument <code>ru</code> allows one to round-up the number of
permutations. A value of 0 implies no round-up, a value of 1 a round-up to
the next ten, 2 a round-up to the next hundred, and so on. Function
<code><a href="#topic+minpermute">minpermute</a></code> is called internally by <code><a href="#topic+permute.cdp">permute.cdp</a></code> in
case <code>permute = NA</code>. In that case, the margin is set to 10
(<code>margin = 10</code>) and the outcome is rounded-up to the next thousand
(<code>ru = 3</code>). This function is meant for users that wish to apply their
own margins and round-up factors to calculate the number of permutations for
use with <code><a href="#topic+permute.cdp">permute.cdp</a></code>.
</p>


<h3>Value</h3>

<p>The minimum number of permutation to be used for
<code><a href="#topic+permute.cdp">permute.cdp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>


<h3>See Also</h3>

<p><a href="#topic+permute.cdp">permute.cdp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For a 5\% threshold under 50 tests.
minpermute(alpha = 0.05, nbtest=50)

## Allowing more margin (implies more computation time).
minpermute(alpha = 0.05, nbtest=50, margin=10, ru=3)

</code></pre>

<hr>
<h2 id='mite'>The Oribatid Mite Data Set</h2><span id='topic+mite'></span><span id='topic+mite.species'></span><span id='topic+mite.env'></span><span id='topic+mite.geo'></span>

<h3>Description</h3>

<p>Borcard et al's oribatid mite community composition from Lac Geai, Canada.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mite)
</code></pre>


<h3>Format</h3>

<p>Contains three matrices:
</p>

<dl>
<dt>mite.species</dt><dd><p> The abundance of 35 morpho-species of oribatid mites
(Acari). </p>
</dd>
<dt>mite.env</dt><dd><p> 14 environmental variables (quantitative and binary). </p>
</dd>
<dt>mite.geo</dt><dd><p> The relative coordinates of the samples. </p>
</dd>
</dl>



<h3>Details</h3>

<p>Values in <code>mite.species</code> are counts of individuals of each of
the morpho-species obtained from 5 cm diameter cores going from the surface
of the peat down to a depth of 7 cm. See Bordard &amp; Legendre (1994) and
reference therein for details about sample treatment and species
identification.
</p>
<p>'mite.env' contains two quantitative variables, namely the substratum density
(g/L) and water content (percent wet mass over dry mass), in addition to 12
dummy variables. The first seven represent the composition of the substratum:
<em>Sphagnum magellacinum</em> (with a majority of <em>S. rubellum</em>),
<em>S. rubellum</em>, <em>S. nemorum</em>, (with a majority of
<em>S. augustifollium</em>), <em>S. rubellum</em> + <em>S. magellicum</em> (in
equal proportions), lignous litter, bare peat, and interface between
<em>Sphagnum</em> species. The next three dummy variables represent the
presence and abundance of shrubs (<em>Kalmia polifolia</em>,
<em>K. angustifolia</em>, and <em>Rhododentron groenlandicum</em>): none, few,
and many. The last two dummy variables represent the microtopography of the
peat: blanket (flat) or hummock (raised).
</p>
<p>'mite.geo' contains the location of the samples, in meters, with respect to
the sampling grid. Point (0,0) is the lower left end of the plot for an
observer looking from the shore towards the water. The 'x' coordinate is the
offset along the shore (from left to right) while the 'y' coordinate is the
offset from the shore while moving towards the water (See Borcard &amp;
Legendre, 1994, Fig. 1 for details on the sampling area).
</p>


<h3>Source</h3>

<p>Daniel Borcard, Département de sciences biologiques, Université de
Montréal, Montréal, Québec, Canada.
</p>


<h3>References</h3>

<p>Borcard, D. &amp; Legendre, P. 1994. Environmental control and spatial structure
in ecological communities: an example using Oribatid mites (Acari, Oribatei).
Environ. Ecol. Stat. 1: 37-61
</p>


<h3>See Also</h3>

<p>Borcard, D.; P. Legendre &amp; P. Drapeau. 1992. Partialling out the spatial
component of ecological variation. Ecology 73: 1045-1055
</p>
<p>Legendre, P. 2005. Species associations: the Kendall coefficient of
concordance revisited. Journal of Agricultural, Biological and Environmental
Statistics 10: 226-245
</p>
<p>Borcard, D.; Gillet, F. &amp; Legendre, P. 2011. Numerical Ecology with R.
Springer, New-York, NY, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mite)
summary(mite.species)
summary(mite.env)
summary(mite.geo)

</code></pre>

<hr>
<h2 id='product-distribution'>Frequency Distributions for MCA Parametric Testing</h2><span id='topic+product-distribution'></span><span id='topic+dphi'></span><span id='topic+pphi'></span><span id='topic+dtau'></span><span id='topic+ptau'></span>

<h3>Description</h3>

<p>Density and distribution functions of the phi statistic, which is the product
of two Fisher-Snedecor distributions or the tau statistic, which is the
product of two Student's t distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dphi(x, nu1, nu2, tol = .Machine$double.eps^0.5)

pphi(q, nu1, nu2, lower.tail = TRUE, tol = .Machine$double.eps^0.5)

dtau(x, nu, tol = .Machine$double.eps^0.5)

ptau(q, nu, lower.tail = TRUE, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="product-distribution_+3A_x">x</code>, <code id="product-distribution_+3A_q">q</code></td>
<td>
<p>A vector of quantile.</p>
</td></tr>
<tr><td><code id="product-distribution_+3A_nu1">nu1</code>, <code id="product-distribution_+3A_nu2">nu2</code>, <code id="product-distribution_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom (&gt;0, may be non-integer; <code>Inf</code> is
allowed.</p>
</td></tr>
<tr><td><code id="product-distribution_+3A_tol">tol</code></td>
<td>
<p>The tolerance used during numerical estimation.</p>
</td></tr>
<tr><td><code id="product-distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical; if TRUE (default), probabilities are P[X &lt;= x],
otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density distribution of a variable <code>z</code> that is the product
of two random variables 'x' and 'y' with density distributions f(x) and g(y),
respectively, is the integral f(x) * g(z/x) / abs(x) dx over the intersection
of the domains of 'x' and 'y'.
</p>
<p><code>dphi</code> estimates density values using numerical integration
(<code><a href="stats.html#topic+integrate">integrate</a></code>) the Fisher-Scedecor <code><a href="stats.html#topic+df">df</a></code> density
distribution function. Following the algebra of Multiscale Codependence
Analysis, f(x) has df1 = nu1 and df2 = nu1 * nu2 degrees of freedom and g(x)
has 'df1 = 1' and 'df2 = nu2' degrees of freedom. Hence, that product
distribution has two parameters.
</p>
<p><code>pphi</code> integrates <code>dphi</code> in the interval [0,q] when
<code>lower.tail = TRUE</code> (the default) and on the interval [q,<code>Inf</code>]
when <code>lower.tail = FALSE</code>.
</p>
<p><code>dtau</code> and <code>ptau</code> are similar to <code>dphi</code> and <code>pphi</code>,
respectively. <code>pphi</code> integrates <code>dphi</code>, with f(x) and f(y) being
two Student's t distribution with <code>nu</code> degrees of freedom. It is called
by functions <code><a href="#topic+test.cdp">test.cdp</a></code> and <code><a href="#topic+permute.cdp">permute.cdp</a></code> to perform
hypothesis tests for single response variables, in which case unilateral
tests can be performed.
</p>


<h3>Value</h3>

<p><code>dphi</code> and <code>dtau</code> return the density functions, whereas
<code>pphi</code> and <code>ptau</code> return the distribution functions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dphi()</code>: Probability density function for the phi statistics
</p>
</li>
<li> <p><code>pphi()</code>: Distribution function for the phi statistics
</p>
</li>
<li> <p><code>dtau()</code>: Probability density function for the tau statistics
</p>
</li>
<li> <p><code>ptau()</code>: Distribution function for the tau statistics
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Springer, M. D. 1979. The algebra of random variables. John Wiley and Sons
Inc., Hoboken, NJ, USA.
</p>
<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to multiscale
codependence analysis: Assessing the drivers of community structure across
spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>See Also</h3>

<p><a href="#topic+test.cdp">test.cdp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Displays the phi probability distribution for five different numbers
### of degrees of freedom:
x &lt;- 10^seq(-4, 0.5, 0.05)
plot(y = dphi(x, 1, 10), x = x, type = "l", col = "black", las = 1,
ylab = "pdf", ylim = c(0, 0.5))
lines(y = dphi(x, 3, 10), x = x, col = "purple")
lines(y = dphi(x, 5, 70), x = x, col = "blue")
lines(y = dphi(x, 12, 23), x = x, col = "green")
lines(y = dphi(x, 35, 140), x = x, col = "red")

### Displays the density distribution function for 10 degrees of freedom.
x &lt;- 10^seq(-4, 0.5, 0.05)
y &lt;- dphi(x, 5, 70)
plot(y = y, x = x, type = "l", col = "black", las = 1, ylab = "Density",
     ylim = c(0, 0.5))
polygon(x = c(x[81L:91], x[length(x)], 1), y = c(y[81L:91], 0, 0),
        col = "grey")
text(round(pphi(1, 5, 70, lower.tail=FALSE), 3), x = 1.75, y = 0.05)

## Idem for the tau distribution:
x &lt;- c(-(10^seq(0.5, -4, -0.05)), 10^seq(-4, 0.5, 0.05))
plot(y = dtau(x, 1), x = x, type = "l", col = "black", las = 1,
     ylab = "pdf", ylim = c(0, 0.5))
lines(y = dtau(x, 2), x = x, col = "purple")
lines(y = dtau(x, 5), x = x, col="blue")
lines(y = dtau(x, 10), x = x, col="green")
lines(y = dtau(x, 100), x = x, col="red")

y &lt;- dtau(x, 10)
plot(y = y, x = x, type = "l", col = "black", las = 1, ylab = "Density",
     ylim = c(0, 0.5))
polygon(x = c(x[which(x==1):length(x)], x[length(x)],1),
        y = c(y[which(x==1):length(x)], 0, 0), col = "grey")
text(round(ptau(1, 10, lower.tail = FALSE), 3), x = 1.5, y = 0.03)
polygon(x = c(-1, x[1L], x[1L:which(x==-1)]),
        y = c(0, 0, y[1L:which(x==-1)]), col="grey")
text(round(ptau(-1, 10), 3), x = -1.5, y = 0.03)

</code></pre>

<hr>
<h2 id='salmon'>The St. Marguerite River Altantic Salmon Parr Transect</h2><span id='topic+salmon'></span>

<h3>Description</h3>

<p>Juvenile Atlantic salmon (parr) density in a 1520m transect of the St.
Marguerite River, Québec, Canada.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salmon)
</code></pre>


<h3>Format</h3>

<p>A 76 rows by  5 columns <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Details</h3>

<p>Contains (1) the 76 sampling site positions along a 1520 m river
segment beginning at a location called &lsquo;Bardsville' (Lat: 48°23&rsquo;01.59&rdquo; N ;
Long: 70°12'10.05&rdquo; W), (2) the number of parr (young salmon, ages I+ and
II+) observed at the sampling sites, (3) the mean water depths (m), (4) the
mean current velocity (m/s), and (5) the mean substrate size (mm). Sampling
took place on July 7, 2002, in the 76 sites, each 20 m long. The 'Bardsville'
river segment is located in the upper portion of Sainte-Marguerite River,
Quebec, Canada.
</p>


<h3>Source</h3>

<p>Daniel Boisclair, Département de sciences biologiques, Université de
Montréal, Montréal, Québec, Canada.
</p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010. Multiscale
codependence analysis: an integrated approach to analyse relationships across
scales. Ecology 91: 2952-2964
</p>


<h3>See Also</h3>

<p>Bouchard, J. and Boisclair, D. 2008. The relative importance of local,
lateral, and longitudinal variables on the development of habitat quality
models for a river. Can. J. Fish. Aquat. Sci. 65: 61-73
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(salmon)
summary(salmon)

</code></pre>

<hr>
<h2 id='weighting-functions'>Weighting Functions for Spatial Eigenvector Map</h2><span id='topic+weighting-functions'></span><span id='topic+wf.sqrd'></span><span id='topic+wf.RBF'></span><span id='topic+wf.PCNM'></span><span id='topic+wf.binary'></span><span id='topic+wf.Drayf1'></span><span id='topic+wf.Drayf2'></span><span id='topic+wf.Drayf3'></span>

<h3>Description</h3>

<p>A set of common distance weighting functions to calculate spatial eignevector
maps using function <code><a href="#topic+eigenmap">eigenmap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wf.sqrd(d)

wf.RBF(d, wpar = 1)

wf.PCNM(d, boundaries, wpar = 4)

wf.binary(d, boundaries)

wf.Drayf1(d, boundaries)

wf.Drayf2(d, boundaries, wpar = 1)

wf.Drayf3(d, boundaries, wpar = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighting-functions_+3A_d">d</code></td>
<td>
<p>A triangular ('<a href="stats.html#topic+dist">dist</a>-class') or rectangular geographic
distance matrix produced by <code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+Euclid">Euclid</a></code>, or
<code><a href="#topic+geodesics">geodesics</a></code>.</p>
</td></tr>
<tr><td><code id="weighting-functions_+3A_wpar">wpar</code></td>
<td>
<p>Where applicable, a parameter controlling the shape of the
spatial weighting function.</p>
</td></tr>
<tr><td><code id="weighting-functions_+3A_boundaries">boundaries</code></td>
<td>
<p>Where applicable, a two-element numeric vector containing
the lower and upper threshold values used to obtain the connectivity matrix.
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are meant primarily to be called within functions
<code><a href="#topic+eigenmap">eigenmap</a></code> and <code><a href="#topic+eigenmap.score">eigenmap.score</a></code>. In
<code><a href="#topic+eigenmap">eigenmap</a></code>, argument <code>d</code> is a lower-triangular
'<a href="stats.html#topic+dist">dist</a>-class' object and the resulting lower-triangular weight matrix
is used in calculating the spatial eigenvector map. In
<code><a href="#topic+eigenmap.score">eigenmap.score</a></code>, <code>d</code> is a rectangular matrix of the
distances between a set of arbitrary locations (rows) and reference locations
(columns; the locations for which the the spatial eigenvector map has been
built and the resulting rectangular weight matrix is used to calculate
spatial eigenfunction values. These values allow one to use the spatial
information of a data set for making predictions at arbitrary values.
</p>
<p>'Wf.sqrd' (default value) consists in taking w[i,j] = -0.5*d[i,j] and does
not involve any truncation.
</p>
<p>'Wf.RBF' consists in taking <code>w[i,j] = exp(-wpar*d[i,j]^2)</code> and
does not involve any truncation, where <code>wpar</code> is a non-zero real
positive value (default: 1).
</p>
<p>'Wf.binary' the spatial weighting matrix is simply the connectivity
matrix.
</p>
<p>'Wf.PCNM' is <code>a[i,j] = 1 - (d[i,j] / (wpar*boundaries[2]))^2</code>, where
<code>wpar</code> is a non-zero real positive value (default: 4).
</p>
<p>'Wf.Drayf1' is <code>a[i,j] = 1 - (d[i,j] / dmax)</code> where <code>d_max</code> is the
distance between the two most distant locations in the set.
</p>
<p>'Wf.Drayf2' is <code>a[i,j] = 1 - (d[i,j] / dmax)^wpar</code>, where <code>wpar</code> is
a non-zero real positive value (default: 1).
</p>
<p>'Wf.Drayf3' is <code>a[i,j] = 1 / d[i,j]^wpar</code>, where <code>wpar</code> is a
non-zero real positive value (default: 1).
</p>
<p>Functions <code>Wf.Drayf1</code>, <code>Wf.Drayf2</code>, and <code>Wf.Drayf3</code> were
proposed by Dray et al. (2006) and function <code>PCNM</code> was proposed by
Legendre and Legendre (2012).
</p>
<p>The <code>Wf.sqrd</code> weighting approach is equivalent to submitting the
elementwise square-root of the distance matrix to a principal coordinate
analysis. It was proposed by Diniz-Filho et al. (2013) and is equivalent, for
evenly spaced transect or surfaces (square or rectangle), to using the basis
functions of type II discrete cosine basis transforms; a fact that has gone
unnoticed by Diniz-Filho et al. (2013).
</p>
<p>The radial basis function (RBF) is a widespread kernel method involving sets
of real-valued functions whose values depend on the distance between any
given input coordinate and a set of fixed points (a single fixed point for
each function). It is implemented using function <code>Wf.RBF</code> using all the
sampling points as the fixed points.
</p>
<p>When calculating the connectivity matrix, pairs of location whose distance to
one another are between the boundary values (argument <code>bounraries</code>) are
considered as neighbours (<code>b[i,j]=1</code>) whereas values located below the
minimum and above the maximum are considered as equivalent or distant,
respectively (<code>b[i,j]=0</code> in both cases).
</p>
<p>User may implement custom weighting functions. These functions must at the
very least have an argument <code>d</code>, and can be given arguments
<code>boundaries</code> and <code>wpar</code>. Argument <code>wpar</code> may be a vector with
any number of elements. They should be added to the R-code file
(weighting-functions.R). User-provided weighting functions with an argument
<code>wpar</code> must come with a valid default value for that parameter since
<code><a href="#topic+eigenmap">eigenmap</a></code> may internally call it without a formal value.
</p>


<h3>Value</h3>

<p>A '<a href="stats.html#topic+dist">dist</a>-class' object when argument <code>d</code> is a
'<a href="stats.html#topic+dist">dist</a>-class' object or a rectangular matrix when argument <code>d</code> is
a rectangular matrix, either one with the weights as its values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wf.sqrd()</code>: Principal coordinates of the square-root distance matrix (Diniz-Filho et al.
2013).
</p>
</li>
<li> <p><code>wf.RBF()</code>: Radial basis functions with the observations as the kernels.
</p>
</li>
<li> <p><code>wf.PCNM()</code>: Borcard &amp; Legendre's (2002) principal coordinates of the neighbour matrix
approach.
</p>
</li>
<li> <p><code>wf.binary()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections without continuous weighting of the neighbours).
</p>
</li>
<li> <p><code>wf.Drayf1()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f1).
</p>
</li>
<li> <p><code>wf.Drayf2()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f2).
</p>
</li>
<li> <p><code>wf.Drayf3()</code>: Dray et al. (2006) Moran's eigenvector maps (distance-based binary
connections with continuous weighting of the neighbours: f3).
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Guillaume Guénard [aut, cre] (ORCID:
    &lt;https://orcid.org/0000-0003-0761-3072&gt;),
  Pierre Legendre [ctb] (ORCID: &lt;https://orcid.org/0000-0002-3838-3305&gt;),
  Bertrand Pages [ctb]
Maintainer: Guillaume Guénard &lt;guillaume.guenard@umontreal.ca&gt;
</p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of ecological
data by means of principal coordinates of neighbour matrices. Ecol. Model.
153: 51-68
</p>
<p>Diniz-Filho, J. A. F.; Diniz, J. V. B. P. L.; Rangel, T. F.; Soares, T. F.;
de Campos Telles, M. P.; Garcia Collevatti, R. and Bini, L. M. 2013. A new
eigenfunction spatial analysis describing population genetic structure.
Genetica 141:479-489.
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English edition.
Elsevier Science B.V., Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locations &lt;- c(1,2,4,7,10,14,17,21)
D &lt;- dist(locations)
wf.sqrd(D)
wf.RBF(D, wpar = 0.1)
wf.binary(D, c(0,5))
wf.PCNM(D, c(0,5))
wf.Drayf1(D, c(0,5))
wf.Drayf2(D, c(0,5), 0.5)
wf.Drayf3(D, c(0,5), 0.5)

emap &lt;- eigenmap(D, locations, wf.Drayf2, c(0,5), 0.5)
emap

emap &lt;- eigenmap(D, locations, wf.Drayf3, c(0,5), 0.25)
emap

emap &lt;- eigenmap(D, locations, wf.RBF, wpar = 0.1)
emap

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
