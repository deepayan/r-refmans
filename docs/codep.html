<!DOCTYPE html><html><head><title>Help for package codep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {codep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cdp-class'><p> Class and methods for Multiscale Codependence Analysis involving</p>
multiple descriptors</a></li>
<li><a href='#codep-package'>
<p>Multiscale Codependence Analysis</p></a></li>
<li><a href='#cthreshold'><p> Familywise type I error rate</p></a></li>
<li><a href='#Doubs'><p>The Doubs fish data</p></a></li>
<li><a href='#eigenmap'><p>Spatial eigenvector maps</p></a></li>
<li><a href='#eigenmap-class'><p>Class and methods for spatial eigenvector maps</p></a></li>
<li><a href='#gcd'><p>Great circle distances</p></a></li>
<li><a href='#MCA'><p> Multiple-descriptors, Multiscale Codependence Analysis</p></a></li>
<li><a href='#minpermute'><p> Number of permutations for MCA</p></a></li>
<li><a href='#Mite'><p>Lac Geai oribatid mites community data</p></a></li>
<li><a href='#Product-distribution'><p>Frequency distributions for MCA parametric testing</p></a></li>
<li><a href='#Salmon'><p>Juvenile Atlantic salmon (parr) density in St-Marguerite river,</p>
Québec, Canada</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-16</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiscale Codependence Analysis</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Guenard and Pierre Legendre, Bertrand Pages</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of Multiscale Codependence Analysis and spatial eigenvector maps, as an additional feature.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), grDevices, graphics, stats, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-16 20:04:28 UTC; guenardg</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-16 20:19:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='cdp-class'> Class and methods for Multiscale Codependence Analysis involving
multiple descriptors </h2><span id='topic+cdp'></span><span id='topic+cdp-class'></span><span id='topic+print.cdp'></span><span id='topic+summary.cdp'></span><span id='topic+plot.cdp'></span><span id='topic+fitted.cdp'></span><span id='topic+residuals.cdp'></span><span id='topic+predict.cdp'></span>

<h3>Description</h3>

<p>Class and methods to handle Multiscale Codependence Analysis (mMCA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdp'
print(x, ...)
## S3 method for class 'cdp'
plot(x, col, col.signif=2, main="", ...)
## S3 method for class 'cdp'
summary(object, ...)
## S3 method for class 'cdp'
fitted(object, selection, components=FALSE, ...)
## S3 method for class 'cdp'
residuals(object, selection, ...)
## S3 method for class 'cdp'
predict(object, selection, newdata, components=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdp-class_+3A_x">x</code>, <code id="cdp-class_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+cdp-class">cdp-class</a></code> object. </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_col">col</code></td>
<td>
<p> A vector of color values to be used for plotting the
multivariate codependence coefficients. </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_col.signif">col.signif</code></td>
<td>
<p> Color of the frame used to mark the statistically
significant codependence coefficients . </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_main">main</code></td>
<td>
<p> Text for the main title of the plot. </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_selection">selection</code></td>
<td>
<p> A numeric vector of indices or character vector variable
names to test or force-use. Mandatory if <code>object</code> is
untested. </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_components">components</code></td>
<td>
<p> A boolean specifying whether the components of
fitted or predicted values associated with single eigenfunctions in
the map should be returned. </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_newdata">newdata</code></td>
<td>
<p> A list with elements $X, $meanY, and $target that
contain the information needed to make predictions (see details). </p>
</td></tr>
<tr><td><code id="cdp-class_+3A_...">...</code></td>
<td>
<p> Further parameters to be passed to other functions or
methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fitted</code>, <code>residuals</code>, and <code>predict</code> methods return
a matrix of fitted, residuals, or predicted values, respectively. The
<code>fitted</code> and <code>predict</code> methods return a list a list when the
parameter <code>component</code> is <code>TRUE</code>. The list contains the
<code>fitted</code> or <code>predicted</code> values as a first element and an
array <code>components</code> as a second. That 3-dimensional array has one
matrix for each statistically significant codependence coefficient.
</p>
<p>For making predictions, parameter <code>newdata</code> may contain three
elements: <code>$X</code>, a matrix of new values of the explanatory
variables, <code>$meanY</code>, a vector of the predicted mean values of the
responses, and <code>$target</code>, a matrix of target scores for arbitraty
locations within the study area. When no <code>$X</code> is supplied, the
descriptor given to <code><a href="#topic+MCA">MCA</a></code> is recycled, while when no
<code>$meanY</code> is supplied, the mean values of the response variables
given to <code><a href="#topic+MCA">MCA</a></code> are used. Finally, when element
<code>$target</code> is omitted from <code>newdata</code>, predictions are made at
the sites were observations were done. When none of the above is
provided, or if <code>newdata</code> is omitted when calling the prediction
method, the behaviour of the <code>predict</code> method is identical to
that of the <code>fitted</code> method.
</p>
<p>From version 0.7-1, <code><a href="#topic+cdp-class">cdp-class</a></code> replaces the former class
<code>mca</code> used by <code><a href="#topic+codep-package">codep-package</a></code> because the standard
package <code>MASS</code> also had S3 methods for a class named <code>mca</code>
that were overwritten by those of <code><a href="#topic+codep-package">codep-package</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+cdp-class">cdp-class</a></code> objects contain:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> A list with two elements: the first being a copy of the
response (<code>Y</code>) and the second being a copy of the explanatory
variables (<code>X</code>). This is the variables that were given to
<code><a href="#topic+MCA">MCA</a></code>. </p>
</td></tr>
<tr><td><code>emobj</code></td>
<td>
<p> The <code><a href="#topic+eigenmap-class">eigenmap-class</a></code> object that was given to
<code><a href="#topic+MCA">MCA</a></code>. </p>
</td></tr>
<tr><td><code>UpYXcb</code></td>
<td>
<p> A list with five elements: the first (<code>UpY</code>) is a
matrix of the cross-products of structuring variable (<code>U</code>) and
the response variable <code>Y</code>, the second (<code>UpX</code>) is a matrix
of the cross-product of the structuring variable and the explanatory
variables (<code>X</code>), the third (<code>C</code>) is a 3-dimensional array
of the codependence coefficients, the fourth (<code>B</code>) is a
3-dimensional array of the coregression coefficients, and the fifth
(<code>CM</code>) is a matrix of the multivariate codependence
coefficients. </p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p> Results of statistical testing as performed by
<code><a href="#topic+test.cdp">test.cdp</a></code> or <code><a href="#topic+permute.cdp">permute.cdp</a></code>. <code>NULL</code>
if no testing was performed, such as when only <code><a href="#topic+MCA">MCA</a></code>
had been called. The results of statistical testing is a list
containing the following members: </p>
</td></tr>
<tr><td><code>$permute</code></td>
<td>
<p> The number of randomized permutations used by
<code>permute.cdp</code> for permutation testing. <code>0</code> or <code>FALSE</code>
for parametric testing obtained using <code><a href="#topic+test.cdp">test.cdp</a></code>. </p>
</td></tr>
<tr><td><code>$significant</code></td>
<td>
<p> The indices of codependence coefficient describing
statistically significant codependence between <code>Y</code> and
<code>X</code>, in decreasing order of magnitude. </p>
</td></tr>
<tr><td><code>$global</code></td>
<td>
<p> The testing table (a 5-column matrix) with
<code class="reqn">\phi</code> statistics, degrees-of-freedom, and testwise and
familywise probabilities of type I (<code class="reqn">\alpha</code>) error. It
contains one line for each statistically significant global
coefficient (if any) in addition to test results for the first,
non-significant coefficient, on which the testing procedure
stopped. </p>
</td></tr>
<tr><td><code>$response</code></td>
<td>
<p> Tests of every single response variable (a
3-dimensional array), had such tests been requested while calling
the testing function, <code>NULL</code> otherwise. </p>
</td></tr>
<tr><td><code>$permutations</code></td>
<td>
<p> Details about permutation testing not shown in
<code>test$global</code> or <code>test$response</code>. <code>NULL</code> for parametric
testing. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to
multiscale codependence analysis: Assessing the drivers of community
structure across spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>

<hr>
<h2 id='codep-package'>
Multiscale Codependence Analysis
</h2><span id='topic+codep-package'></span><span id='topic+codep'></span>

<h3>Description</h3>

<p>Computation of Multiscale Codependence Analysis and spatial eigenvector maps, as an additional feature.
</p>
<p>Multiscale Codependence Analysis (MCA) consists in assessing the
coherence of pairs of variables in space (or time) using the product
of their correlation coefficients with series of spatial (or temporal)
eigenfunctions. That product, which is positive or negative when
variables show similar or opposing trends, respectively, are called
codependence coefficients. These eigenfunctions are obtained in three
steps: 1) a distance matrice calculated from the locations of samples
in space (or the organisation of the sampling schedule). 2) from that
distance matrix, a matrix of spatial weights is obtained; the same
matrix as to calculate Moran's autocorrelation index, hence the name,
and 3) the spatial weight matrix is eigenvalue-decomposed after
centering each rows and columns of the spatial weight matrix.
</p>
<p>The statistical significance of the codependence coefficients is
tested using parametric or permutational testing of a <code class="reqn">\tau</code>
statistic. The <code class="reqn">\tau</code> statistic is the product of the two
Student's <code class="reqn">t</code> statistics obtained from each of the two
variables with a given eigenfunction. The <code class="reqn">\tau</code> statistic
can take both positive and negative values, thereby allowing one to
perform one-directional or two-directional testing. For multiple
response variables, testing is performed using the <code class="reqn">phi</code>
statistic instead. That statistics is the distribution of the product
of two Fisher-Snedocor F statistics (see
<code><a href="#topic+Product-distribution">Product-distribution</a></code> for details).
</p>


<h3>Details</h3>

<p>Function <code><a href="#topic+MCA">MCA</a></code> performs Multiscale Codependence Analysis
(MCA).
</p>
<p>Functions <code><a href="#topic+test.cdp">test.cdp</a></code> and <code><a href="#topic+permute.cdp">permute.cdp</a></code> handle
parametric permutational testing of the codependence coefficients,
respectively.
</p>
<p>Methods are provided to print and plot <code><a href="#topic+cdp-class">cdp-class</a></code> objects
(<code><a href="#topic+print.cdp">print.cdp</a></code> and <code><a href="#topic+plot.cdp">plot.cdp</a></code>, respectively) as
well as summary (<code><a href="#topic+summary.cdp">summary.cdp</a></code>), fitted values
(<code><a href="#topic+fitted.cdp">fitted.cdp</a></code>), residuals (<code><a href="#topic+residuals.cdp">residuals.cdp</a></code>),
and to make predictions (<code><a href="#topic+predict.cdp">predict.cdp</a></code>).
</p>
<p>Function <code><a href="#topic+eigenmap">eigenmap</a></code> calculates spatial eigenvector maps
following the approach outlined in Dray et al. (2006), and which are
necessary to calculate <code><a href="#topic+MCA">MCA</a></code>. It returns a
<code><a href="#topic+eigenmap-class">eigenmap-class</a></code> object. The package also features methods
to print (<code><a href="#topic+print.eigenmap">print.eigenmap</a></code>) and plot
(<code><a href="#topic+plot.eigenmap">plot.eigenmap</a></code>) these objects. Function
<code><a href="#topic+eigenmap.score">eigenmap.score</a></code> can be used to make predictions for
spatial models built from the eigenfunctions of <code><a href="#topic+eigenmap">eigenmap</a></code>
using distances between one or more target locations and the sampled
locations for which the spatial eigenvector map was built.
</p>
<p>The package also features an examplary dataset <code><a href="#topic+Salmon">Salmon</a></code>
containing  76 sampling site positions along a 1520 m river segment as
well as functions <code><a href="#topic+cthreshold">cthreshold</a></code> and
<code><a href="#topic+minpermute">minpermute</a></code>, which calculates the testwise type I error
rate threshold corresponding to a given familywise threshold and the
minimal number of permutations needed for testing Multiscale
Codependence Analysis given the alpha threshold, respectively.
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> codep</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-05-16</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Multiscale Codependence Analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Guillaume Guenard and Pierre Legendre, Bertrand Pages</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Computation of Multiscale Codependence Analysis and spatial eigenvector maps, as an additional feature.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0), grDevices, graphics, stats, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> vegan</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
Packaged: </td><td style="text-align: left;"> 2018-04-16 16:47:02 UTC; guenardg</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
Doubs                   The Doubs fish data
MCA                     Multiple-descriptors, Multiscale Codependence
                        Analysis
Mite                    Lac Geai oribatid mites community data
Product-distribution    Frequency distributions for MCA parametric
                        testing
Salmon                  Juvenile Atlantic salmon (parr) density in
                        St-Marguerite river, Québec, Canada
cdp-class               Class and methods for Multiscale Codependence
                        Analysis involving multiple descriptors
codep-package           Multiscale Codependence Analysis
cthreshold              Familywise type I error rate
eigenmap                Spatial eigenvector maps
eigenmap-class          Class and methods for spatial eigenvector maps
gcd.slc                 Great circle distances
minpermute              Number of permutations for MCA
</pre>


<h3>Author(s)</h3>

<p>Guillaume Guenard and Pierre Legendre, Bertrand Pages
</p>
<p>Maintainer: Guillaume Guenard &lt;guillaume.guenard@gmail.com&gt;
</p>


<h3>References</h3>

<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to
multiscale codependence analysis: Assessing the drivers of community
structure across spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>See Also</h3>

<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English
edition. Elsevier Science B.V., Amsterdam, The Neatherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mite)
emap &lt;- eigenmap(x = mite.geo,weighting=Wf.RBF,wpar=0.1)
emap
# Organize the environmental variables
mca0 &lt;- MCA(Y = log1p(mite.species), X = mite.env, emobj = emap)
mca0_partest &lt;- test.cdp(mca0, response.tests = FALSE)
summary(mca0_partest)
plot(mca0_partest, las = 2, lwd = 2)
plot(mca0_partest, col = rainbow(1200)[1L:1000], las = 3, lwd = 4,
     main = "Codependence diagram", col.signif = "white")
#
rng &lt;- list(x = seq(min(mite.geo[,"x"]) - 0.1, max(mite.geo[,"x"]) + 0.1, 0.05),
            y = seq(min(mite.geo[,"y"]) - 0.1, max(mite.geo[,"y"]) + 0.1, 0.05))
grid &lt;- cbind(x = rep(rng[["x"]], length(rng[["y"]])),
              y = rep(rng[["y"]], each = length(rng[["x"]])))
newdists &lt;- matrix(NA, nrow(grid), nrow(mite.geo))
for(i in 1L:nrow(grid)) {
  newdists[i,] &lt;- ((mite.geo[,"x"] - grid[i,"x"])^2 +
                    (mite.geo[,"y"] - grid[i,"y"])^2)^0.5
}
#
spmeans &lt;- colMeans(mite.species)
pca0 &lt;- svd(log1p(mite.species) - rep(spmeans, each = nrow(mite.species)))
#
prd0 &lt;- predict(mca0_partest,
                newdata = list(target = eigenmap.score(emap, newdists)))
Uprd0 &lt;- (prd0 - rep(spmeans, each = nrow(prd0))) 
#
### Printing the response variable
prmat &lt;- Uprd0[,1L]
dim(prmat) &lt;- c(length(rng$x),length(rng$y))
zlim &lt;- c(min(min(prmat),min(pca0$u[,1L])),max(max(prmat),max(pca0$u[,1L])))
image(z = prmat, x = rng$x, y = rng$y, asp = 1, zlim = zlim,
      col = rainbow(1200L)[1L:1000], ylab = "y", xlab = "x")
points(x = mite.geo[,"x"], y = mite.geo[,"y"], pch = 21,
       bg = rainbow(1200L)[round(1+(999*(pca0$u[,1L]-zlim[1L])/(zlim[2L]-zlim[1L])),0)])
#
</code></pre>

<hr>
<h2 id='cthreshold'> Familywise type I error rate </h2><span id='topic+cthreshold'></span>

<h3>Description</h3>

<p>Function to calculate the testwise type I error rate threshold
corresponding to a give familywise threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cthreshold(alpha, nbtest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cthreshold_+3A_alpha">alpha</code></td>
<td>
<p> The familywise type I error threshold. </p>
</td></tr>
<tr><td><code id="cthreshold_+3A_nbtest">nbtest</code></td>
<td>
<p> The number of tests performed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type I error rate inflation occurs when a single hypothesis is tested
indirectly using inferences about two or more (<em>i.e.</em> a family
of) sub-hypotheses. In such situation, the probability of type I error
(<em>i.e.</em> the probability of incorrectly rejecting the null
hypothesis) of the single, familywise, hypothesis is higher than the
lowest, testwise, probabilities. As a consequence, the rejection of
null hypothesis for one or more individual tests does not warrant that
the correct decision (whether to reject the the null hypothesis on a
familywise basis) was taken properly. This function allows to obtain
correct, familywise, alpha thresholds in the context of multiple
testing. It is base on the Sidak inegality.
</p>


<h3>Value</h3>

<p>The threshold that have to be used for individual tests.
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Sidak, Z. 1967. Rectangular Confidence Regions for Means of
Multivariate Normal Distributions J. Am. Stat. Assoc. 62: 626-633
</p>
<p>Wright, P. S. 1992. Adjusted p-values for simultaneous inference.
Biometrics 48: 1005-1013  
</p>


<h3>See Also</h3>

<p>Legendre, P. and Legendre, L. 1998. Numerical Ecology. Elsevier
Science B.V., Amsterdam, The Neatherlands. p. 18
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a familywise threshold of 5% with 5 tests:
cthreshold(c(0.05),5)   # The corrected threshold for each test is 0.01020622
</code></pre>

<hr>
<h2 id='Doubs'>The Doubs fish data</h2><span id='topic+Doubs'></span><span id='topic+Doubs.fish'></span><span id='topic+Doubs.env'></span><span id='topic+Doubs.geo'></span>

<h3>Description</h3>

<p>Fish community composition of the Doubs River, France.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Doubs</code></pre>


<h3>Format</h3>

<p> Contains three matrices:
<code>Doubs.fish</code> the abundance of 27 fish species.
</p>
<p><code>Doubs.env</code> 9 environmental variables (all quantitative).
</p>
<p><code>Doubs.geo</code> geographic information of the samples.
</p>


<h3>Details</h3>

<p>Values in <code>Doubs.fish</code> are counts of individuals of each of 27
species observed in a set of 30 sites located along the 453 km long
Doubs River, France (see Verneaux 1973 for further details about
fishing methods and effort).
</p>
<p><code>Doubs.env</code> contains 11 quantitative variables, namely the slope
(<code>slo</code> 1/1000) and mean minimum discharge (<code>flo</code> m³/s) of
the river, the pH of the water, its harness (Calcium concentration;
<code>har</code>; mg/L), phosphate (<code>pho</code>; mg/L), nitrate (<code>nit</code>;
mg/L), and ammonium (<code>amm</code>; mg/L), concentration as well as its
dissolved oxygen (<code>oxy</code>; mg/L) and biological oxygen demand
(<code>bdo</code>; mg/L).
</p>
<p><code>Doubs.geo</code> contains geographical information. <code>Lon</code>, the
longitude and <code>Lat</code>, the latitude of the sample (degree) as well
as <code>DFS</code>, its distance from the source of the river (km) and
<code>Alt</code>, altitude (m above see level).
</p>


<h3>Source</h3>

<p> Verneaux, 1973 </p>


<h3>References</h3>

<p>Verneaux J. 1973. - Cours d'eau de Franche-Comté (Massif du
Jura). Recherches écologiques sur le réseau hydrographique du
Doubs. Essai de biotypologie. Thèse d'état, Besançon. 257 p.)
</p>
<p>Verneaux, J.; Schmitt, V.; Verneaux, V. &amp; Prouteau, C. 2003. Benthic
insects and fish of the Doubs River system: typological traits and the
development of a species continuum in a theoretically extrapolated
watercourse. Hydrobiologia 490: 60-74
</p>


<h3>See Also</h3>

<p>Borcard, D.; Gillet, F. &amp; Legendre, P. 2011. Numerical Ecology with
R. Springer, New-York, NY, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Doubs)
summary(Doubs.fish)
summary(Doubs.env)
summary(Doubs.geo)
</code></pre>

<hr>
<h2 id='eigenmap'>Spatial eigenvector maps</h2><span id='topic+eigenmap'></span><span id='topic+Wf.sqrd'></span><span id='topic+Wf.RBF'></span><span id='topic+Wf.binary'></span><span id='topic+Wf.PCNM'></span><span id='topic+Wf.Drayf1'></span><span id='topic+Wf.Drayf2'></span><span id='topic+Wf.Drayf3'></span><span id='topic+eigenmap.score'></span>

<h3>Description</h3>

<p>Function to calculate spatial eigenvector maps of a set of locations
in a space with an arbitrary number of dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenmap(x,opt.coord=NA,weighting=Wf.sqrd,boundaries,wpar,select=.Machine$double.eps^0.5)
Wf.sqrd(D)
Wf.RBF(D,wpar=1)
Wf.binary(D,boundaries)
Wf.PCNM(D,boundaries)
Wf.Drayf1(D,boundaries)
Wf.Drayf2(D,boundaries,wpar=1)
Wf.Drayf3(D,boundaries,wpar=1)
eigenmap.score(object,target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenmap_+3A_x">x</code></td>
<td>
<p> A set of coordinates defined in one (numeric vector) or many
(a coordinate x dimension matrix) dimensions or, alternatively, a
distance matrix provided by <code><a href="stats.html#topic+dist">dist</a></code>. Coordinates are
treated as cartesian coordinates and the distances between them are
assumed to be Euclidean. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_opt.coord">opt.coord</code></td>
<td>
<p> Coordinates to be used when a distance matrix is
provided as x. Used for plotting purposes. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_weighting">weighting</code></td>
<td>
<p> The function to obtain the edge weighting
matrix. That function must have the raw distances as a first
parameter, optionally a second parameter named <code>boundaries</code>
giving the boundaries of the within which locations are regarded as
neighbour and a third parameter named <code>wpar</code> containing any
other weighting function parameter.
</p>
<p><code>Wf.sqrd</code> consists in taking <code class="reqn">w_{i,j} =
      -0.5*d_{i,j}</code> and does not involve any
trunction.
</p>
<p><code>Wf.sqrd</code> consists in taking <code class="reqn">w_{i,j} =
      exp(-wpar*d_{i,j}^2)</code> and does not
involve any trunction.
</p>
<p><code>Wf.binary</code> (default value) the spatial weighting matrix is
simply the connectivity matrix,
</p>
<p><code>Wf.PCNM</code> is <code class="reqn">a_{i,j} = 1 - (d_{i,j} /
      (4*boundaries_2))^2</code>
</p>
<p><code>Wf.Drayf1</code> is <code class="reqn">a_{i,j} = 1 - (d_{i,j} / d_{max})</code> where <code class="reqn">d_max</code> is the distance
between the two most distant locations in the set,
</p>
<p><code>Wf.Drayf2</code> is <code class="reqn">a_{i,j} = 1 - (d_{i,j} /
      d_{max})^{wpar}</code>,
</p>
<p><code>Wf.Drayf3</code> is <code class="reqn">a_{i,j} = 1 / d_{i,j}^{wpar}</code>, and
</p>
<p>Functions <code>Wf.Drayf1</code>, <code>Wf.Drayf2</code>, and <code>Wf.Drayf3</code>
were proposed by Dray et al. (2006) and function <code>PCNM</code> was
proposed by Legendre and Legendre (2012).
The <code>Wf.sqrd</code> weighting approach is equivallent to submitting
the elementwise square-root of the distance matrix to a principal
coordinate analysis. That option is not much documented in the
ecological litterature, but is actually equivallent, for evenly
spaced transect or surfaces (square or rectangle), to using the
basis functions of type II discrete cosine basis transforms. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_boundaries">boundaries</code></td>
<td>
<p> (optional) Threshold values (minimum and maximum)
used to obtain the connectivity matrix. Pairs of location whose
distance to one another are between these values are considered as
neighbours (<code class="reqn">b_{i,j}=1</code>) whereas values located below
the mininum and above the maximum are considered as equivallent or
distant, respectively (<code class="reqn">b_{i,j}=0</code> in both
cases). Defaults are <code class="reqn">0</code> for the minimum value and <code>NA</code>
for the maximum. Values <code>NA</code> indicates the function to take the
minimum value that allow every locations to form a single cluster
following single linkage clustering as a maximum value (obtained
from <code><a href="stats.html#topic+hclust">hclust</a></code></p>
</td></tr></table>
<p>. Ignored when <code>weighting="Wf.sqrd"</code>
or <code>weighting="Wf.RBF"</code>.
</p>
<table>
<tr><td><code id="eigenmap_+3A_wpar">wpar</code></td>
<td>
<p> Weighting function parameters. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_select">select</code></td>
<td>
<p> The smallest absolute eigenvalue for eigenfunctions to
be considered as a suitable predictive variables. Default value
depends on one's particular computer and is set to the square-root
of <code>.Machine$double.eps</code> </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_d">D</code></td>
<td>
<p> A distance matrix. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_object">object</code></td>
<td>
<p> A <code><a href="#topic+eigenmap-class">eigenmap-class</a></code> object. </p>
</td></tr>
<tr><td><code id="eigenmap_+3A_target">target</code></td>
<td>
<p> A set of distances between the sampling locations
(passed to <code><a href="#topic+eigenmap">eigenmap</a></code> using <code>x</code>) and the target
locations where spatially-explicit predictions are to be made. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial eigenvector maps are sets of eigenfunctions obtained from the
locations of the observations in a structuring framework, e.g.,
space, time, or in a graph. It is obtained by eigenvalue
decomposition of a  spatial weighting matrix, computed as described
in Dray et al. (2006) and Legendre &amp; Legendre (2012, Section
14.2). That square matrix is Gower-centred before
eigen-decomposition. The spatial weighting matrix is the Hadamard
product of a connectivity matrix <code class="reqn">\mathbf{B}</code> and an edge
weighting matrix <code class="reqn">\mathbf{A}</code>. The function described herein
handles user-chosen truncation parameters to calculate
<code class="reqn">\mathbf{B}</code> and provides a default approach to estimate
these parameters should they be missing. It also offers four
different ways of computing <code class="reqn">\mathbf{A}</code> through parameters
<code>weighting</code> and <code>wpar</code>.
</p>
<p>In is noteworthy that in the present implementation, matrix
<code class="reqn">\mathbf{B}</code> is not obtained using a minimum spanning tree as
suggested by Dray et al. (2006) but using a simpler approach whereby
every distances within a user-defined trunction interval are taken
as neighbour.
</p>
<p>Functions <code><a href="#topic+Wf.sqrd">Wf.sqrd</a></code>, <code><a href="#topic+Wf.RBF">Wf.RBF</a></code>,
<code><a href="#topic+Wf.binary">Wf.binary</a></code>, <code><a href="#topic+Wf.PCNM">Wf.PCNM</a></code>,
<code><a href="#topic+Wf.Drayf1">Wf.Drayf1</a></code>, <code><a href="#topic+Wf.Drayf2">Wf.Drayf2</a></code>, and
<code><a href="#topic+Wf.Drayf3">Wf.Drayf3</a></code> are not intested to be called as is but
through <code><a href="#topic+eigenmap">eigenmap</a></code> (and within
<code><a href="#topic+eigenmap.score">eigenmap.score</a></code>). Other, user-defined, function can be
used by <code><a href="#topic+eigenmap">eigenmap</a></code> and should be visible to if one wants
to call <code><a href="#topic+eigenmap.score">eigenmap.score</a></code> to obtain predictors.
</p>
<p>For <code><a href="#topic+eigenmap.score">eigenmap.score</a></code>, the distances between sampling
locations and the targets locations must be of the same type as
those that had been passed to <code><a href="#topic+eigenmap">eigenmap</a></code>. If cartesian
coordinates were passed to <code>x</code>, the distances to target must be
Euclidean.
</p>


<h3>Value</h3>

<p><code><a href="#topic+eigenmap">eigenmap</a></code> returns a <code><a href="#topic+eigenmap-class">eigenmap-class</a></code> object
and <code><a href="#topic+eigenmap.score">eigenmap.score</a></code> returns a the scores on for each
target locations 
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Departement des sciences biologiques,
Universite de Montréal, Montréal, Quebec, Canada. </p>


<h3>References</h3>

<p>Borcard, D. and Legendre, P. 2002. All-scale spatial analysis of
ecological data by means of principal coordinates of neighbour
matrices. Ecol. Model. 153: 51-68
</p>
<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>
<p>Legendre, P. and Legendre, L. 2012. Numerical Ecology, 3rd English
edition. Elsevier Science B.V., Amsterdam, The Neatherlands.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCA">MCA</a></code>
<code><a href="#topic+eigenmap-class">eigenmap-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
### Example 1: A linear transect.
#
data(Salmon)
#
## No boundaries provided for a function that requires them: a warning is issued
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.binary)
map # plot(map)
#
## Boundaries are provided: the function is happy
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.binary,boundaries=c(0,20))
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.Drayf1,boundaries=c(0,20))
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.Drayf2,boundaries=c(0,20))
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.Drayf3,boundaries=c(0,20),wpar=2)
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.PCNM,boundaries=c(0,20))
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.sqrd)
map # plot(map)
#
map &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.RBF,wpar=0.001)
map # plot(map)
#
### Example 2: Using predictior scores
#
smpl &lt;- c(4,7,10,14,34,56,61,64)  # A sample to discard
map &lt;- eigenmap(x=Salmon[-smpl,"Position"],weighting=Wf.sqrd)
scr &lt;- eigenmap.score(object=map,target=as.matrix(dist(Salmon[,"Position"]))[,-smpl])
all(round(scr[-smpl,] - map$U, 10) == 0) # Scores of sampling points are the eigenvectors
scr[smpl,]
#
wh &lt;- 5L   # You can try with other vectors.
plot(map$U[,wh]~Salmon[-smpl,"Position"], ylab = expression(U[5]),
     xlab = "Position along transect")
points(y=scr[smpl,wh],x=Salmon[smpl,"Position"],pch=21,bg="black")
#
map &lt;- eigenmap(x=Salmon[-smpl,"Position"],weighting=Wf.binary,boundaries=c(0,20))
scr &lt;- eigenmap.score(object=map,target=as.matrix(dist(Salmon[,"Position"]))[smpl,-smpl])
#
wh &lt;- 1L   # You can try with other vectors.
plot(map$U[,wh]~Salmon[-smpl,"Position"], ylab = expression(U[1]),
     xlab = "Position along transect (m)")
points(y=scr[,wh],x=Salmon[smpl,"Position"],pch=21,bg="black")
#
map &lt;- eigenmap(x=Salmon[-smpl,"Position"],weighting=Wf.PCNM,boundaries=c(0,100))
scr &lt;- eigenmap.score(object=map,target=as.matrix(dist(Salmon[,"Position"]))[smpl,-smpl])
#
wh &lt;- 1L   # You can try with other vectors.
plot(map$U[,wh]~Salmon[-smpl,"Position"], ylab = expression(U[1]),
     xlab = "Position along transect (m)")
points(y=scr[,wh],x=Salmon[smpl,"Position"],pch=21,bg="black")
#
### Example 3: A unevenly sampled surface.
#
data(Mite)
map &lt;- eigenmap(x=as.matrix(mite.geo),weighting=Wf.sqrd)
map # plot(map)
#
map &lt;- eigenmap(x=as.matrix(mite.geo),weighting=Wf.RBF)
map # plot(map)
#
</code></pre>

<hr>
<h2 id='eigenmap-class'>Class and methods for spatial eigenvector maps</h2><span id='topic+eigenmap-class'></span><span id='topic+print.eigenmap'></span><span id='topic+plot.eigenmap'></span>

<h3>Description</h3>

<p>Methods to handle spatial eigenvector maps of a set of locations in a
space with an arbitrary number of dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eigenmap'
print(x, ...)
## S3 method for class 'eigenmap'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenmap-class_+3A_x">x</code></td>
<td>
<p> An object of <code><a href="#topic+eigenmap-class">eigenmap-class</a></code> </p>
</td></tr>
<tr><td><code id="eigenmap-class_+3A_...">...</code></td>
<td>
<p> Further parameters to be passed to other functions or
methods (currently ignored). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method provides the number of the number of
orthonormal variables (i.e. basis functions), the number of
observations these functions are spanning, and their associated
eigenvalues.
</p>
<p>The <code>plot</code> method provides a plot of the eigenvalues and offers
the possibility to plot the values of variables for 1- or
2-dimensional sets of coordinates. <code>plot.eigenmap</code> opens the default
graphical device driver, i.e., <code>X11</code>, <code>windows</code>, or
<code>quartz</code> and recurses through variable with a left mouse click on
the graphical window. A right mouse click interrupts recursing on
<code>X11</code> and <code>windows</code> (Mac OS X users should hit <em>Esc</em> on
the <code>quartz</code> graphical device driver (Mac OS X users).
</p>


<h3>Value</h3>

<p><code><a href="#topic+eigenmap-class">eigenmap-class</a></code> objects contain:
</p>
<table>
<tr><td><code>coordinates</code></td>
<td>
<p> a matrix of coordinates, </p>
</td></tr>
<tr><td><code>truncate</code></td>
<td>
<p> the interval within which pairs of sites are
considered as neighbour, </p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p> the distance matrix, </p>
</td></tr>
<tr><td><code>weighting</code></td>
<td>
<p> the weighting function that had been used, </p>
</td></tr>
<tr><td><code>wpar</code></td>
<td>
<p> the weighting function parameter that had been used, </p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p> a vector of the eigenvalues obtain from the computation
of the eigenvector map, and </p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p> a matrix of the eigenvectors defining the eigenvector map. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Dray, S.; Legendre, P. and Peres-Neto, P. 2006. Spatial modelling: a
comprehensive framework for principal coordinate analysis of neighbor
matrices (PCNM). Ecol. Modelling 196: 483-493
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MCA">MCA</a></code>
<code><a href="#topic+eigenmap">eigenmap</a></code>
</p>

<hr>
<h2 id='gcd'>Great circle distances</h2><span id='topic+gcd.slc'></span><span id='topic+gcd.hf'></span><span id='topic+gcd.vife'></span>

<h3>Description</h3>

<p>Functions to calculate great circle distances among sets of points
with known longitude and lattitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcd.slc(ss, radius = 6371)
gcd.hf(ss, radius = 6371)
gcd.vife(ss, a = 6378137, b = 6356752.314245, f = 1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcd_+3A_ss">ss</code></td>
<td>
<p> A two-columns data.frame or matrix of the geographic
coordinates (in degree.decimals; lattitude and then longitude) of
the locations between which the geodesic distances are being
calculated. </p>
</td></tr>
<tr><td><code id="gcd_+3A_radius">radius</code></td>
<td>
<p> Mean earth radius (mean length of parallels) in
km. Default: 6371 km </p>
</td></tr>
<tr><td><code id="gcd_+3A_a">a</code></td>
<td>
<p> Length (in m) of major axis of the ellipsoid (radius at
equator). Default: 6378137 m (i.e. that for WGS-84). </p>
</td></tr>
<tr><td><code id="gcd_+3A_b">b</code></td>
<td>
<p> Length (in m) of minor axis of the ellipsoid (radius at the
poles). Default: 6356752.314245 m (i.e. that for WGS-84). </p>
</td></tr>
<tr><td><code id="gcd_+3A_f">f</code></td>
<td>
<p> Flattening of the ellipsoid. Default: 1/298.257223563
(i.e. that for WGS-84). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of spatial eigenvector maps requires a distance
matrix. The euclidean distance is appropriate when a cartesian plan
can be reasonably assumed. The latter can be calculated with function
<code><a href="stats.html#topic+dist">dist</a></code>. The great circle distance is appropriate when the
sampling points are located on a spheroid (e.g. planet
Earth). Function <code>gcd.slc</code> uses the spherical law of cosines,
which is the fastest of the three approaches and performs relatively
well for distances above 1 m. Function <code>gcd.hf</code> uses the the
Haversine formula, which is more accurate for smaller distances
(bellow 1 m). Finally, functions <code>gcd.vife</code> uses the Vincenty
inverse formula for ellipsoids, which is an iterative approach that
take substantially more computation time than the latter two methods
has precision up to 0.5 mm with exact longitudes and lattitudes. </p>


<h3>Value</h3>

<p>An object of class ‘&quot;dist&quot;’ (see <code><a href="stats.html#topic+dist">dist</a></code> for details) that
contains the distances (in km) between the locations (rows of
<code>ss</code>).
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Departement des sciences biologiques,
Universite de Montréal, Montréal, Quebec, Canada. </p>


<h3>References</h3>

<p>Mario Pineda-Krch, URL:
http://www.r-bloggers.com/great-circle-distance-calculations-in-r/
</p>
<p>Vincenty, T. (1975) Closed formulas for the direct and reverse
geodetic problems. J. Geodesy 51(3): 241-342
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigenmap-class">eigenmap-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Calculating the distances between Canada's capital cities:
CapitalCitiesOfCanada &lt;-
    matrix(c(45.417,-75.7,53.533333,-113.5,48.422151,-123.3657,
             49.899444,-97.139167,45.95,-66.666667,47.5675,-52.707222,
             44.647778,-63.571389,43.7,-79.4,46.24,-63.1399,
             46.816667,-71.216667,50.454722,-104.606667,62.442222,-114.3975,
             63.748611,-68.519722,60.716667,-135.05),14L,2L,byrow=TRUE,
             dimnames=list(c("Ottawa","Edmonton","Victoria","Winnipeg",
                             "Fredericton","St-John's","Halifax","Toronto",
                             "Charlottetown","Quebec City","Regina",
                             "Yellowknife","Iqaluit","Whitehorse"),c("Lon","Lat")))
#
sphericalcosdists &lt;- gcd.slc(CapitalCitiesOfCanada)
vincentydists &lt;- gcd.vife(CapitalCitiesOfCanada)
#
cor(as.numeric(sphericalcosdists),as.numeric(vincentydists))
percentdev &lt;- 100*(vincentydists-sphericalcosdists)/vincentydists
mean(percentdev)
# Spherical Law of Cosines underestimated these distances by ~0.26
# percent.
#
</code></pre>

<hr>
<h2 id='MCA'> Multiple-descriptors, Multiscale Codependence Analysis </h2><span id='topic+MCA'></span><span id='topic+test.cdp'></span><span id='topic+permute.cdp'></span><span id='topic+parPermute.cdp'></span>

<h3>Description</h3>

<p> Functions to perform Multiscale Codependence Analysis
(MCA) </p>


<h3>Usage</h3>

<pre><code class='language-R'>MCA(Y, X, emobj)
test.cdp(object, alpha = 0.05, max.step, response.tests = TRUE)
permute.cdp(object, permute, alpha = 0.05, max.step,
            response.tests = TRUE)
parPermute.cdp(object, permute, alpha = 0.05, max.step,
               response.tests = TRUE, nnode, seeds, verbose = TRUE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCA_+3A_y">Y</code></td>
<td>
<p> a numeric matrix or vector containing the response
variable(s). </p>
</td></tr>
<tr><td><code id="MCA_+3A_x">X</code></td>
<td>
<p> a numeric matrix or vector containing the explanatory
variable(s). </p>
</td></tr>
<tr><td><code id="MCA_+3A_emobj">emobj</code></td>
<td>
<p> a <code><a href="#topic+eigenmap-class">eigenmap-class</a></code> object. </p>
</td></tr>
<tr><td><code id="MCA_+3A_object">object</code></td>
<td>
<p> a <code><a href="#topic+cdp-class">cdp-class</a></code> object. </p>
</td></tr>
<tr><td><code id="MCA_+3A_alpha">alpha</code></td>
<td>
<p> type I (<code class="reqn">\alpha</code>) error threshold used by the
testing procedure. </p>
</td></tr>
<tr><td><code id="MCA_+3A_max.step">max.step</code></td>
<td>
<p> maximum number of steps to perform when testing for
statistical significance. </p>
</td></tr>
<tr><td><code id="MCA_+3A_response.tests">response.tests</code></td>
<td>
<p> a boolean specifying whether to test individual
response variables. </p>
</td></tr>
<tr><td><code id="MCA_+3A_permute">permute</code></td>
<td>
<p> The number of random permutations used for
testing. When omitted, the number of permutations is calculated
using function <code><a href="#topic+minpermute">minpermute</a></code>.</p>
</td></tr>
<tr><td><code id="MCA_+3A_nnode">nnode</code></td>
<td>
<p> The number of parallel computation nodes. </p>
</td></tr>
<tr><td><code id="MCA_+3A_seeds">seeds</code></td>
<td>
<p> Random number generator seeds for parallel the
computation nodes. </p>
</td></tr>
<tr><td><code id="MCA_+3A_verbose">verbose</code></td>
<td>
<p> Whether to return user notifications. </p>
</td></tr>
<tr><td><code id="MCA_+3A_...">...</code></td>
<td>
<p> Parameters to be passed to <code>parallel::makeCluster()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiscale Codependence Analysis (MCA) allows to calculate
correlation-like (i.e.codependence) coefficients between two variables
with respect to structuring variables (Moran's eigenvector maps). The
purpose of this function is limited to parameter fitting. Test
procedures are handled through <code>test.cdp</code> (parametric testing)
or <code>permute.cdp</code> (permutation testing). Additionaly, methods are
provided for printing, displaying the testing summary, plotting
results, calculating fitted and residuals values, and making
predictions. It is noteworthy that the test procedure used by
<code>MCA</code> deviates from the standard R workflow since intermediate
testing functions (<code>test.cdp</code> and <code>permute.cdp</code>) need
first to be called before any testing be performed. For <code>MCA</code>,
testing functionalities had been moved away from summary.cdp because
testing is computationally intensive. Function <code>parPermute.cdp</code>
allows the user to spread the number of permutation on many
computation nodes. It relies on package <code>parallel</code>. Omitting
parameter <code>nnode</code> lets function <code>parallel::detectCores()</code>
specify the number of node. Similarly, omitting parameter <code>seeds</code>
lets the draw seeds uniformly between
<code>±.Machine$integer.max</code>. If needed, one may pass initialization
parameters to <code>parallel::makeCluster()</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+cdp-class">cdp-class</a></code> object.
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to
multiscale codependence analysis: Assessing the drivers of community
structure across spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigenmap">eigenmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
###### Begin {Salmon exemple}
#
data(Salmon)
#
## Converting the data from data frames to to matrices:
Abundance &lt;- log1p(as.matrix(Salmon[,"Abundance",drop=FALSE]))
Environ &lt;- as.matrix(Salmon[,3L:5])
#
## Creating a spatial eigenvector map:
map1 &lt;- eigenmap(x=Salmon[,"Position"],weighting=Wf.binary,boundaries=c(0,20))
#
## Case of a single descriptor:
mca1 &lt;- MCA(Y=Abundance,X=Environ[,"Substrate",drop=FALSE],emobj=map1)
mca1
mca1_partest &lt;- test.cdp(mca1)
mca1_partest
summary(mca1_partest)
par(mar = c(6,4,2,4))
plot(mca1_partest, las = 3)
mca1_pertest &lt;- permute.cdp(mca1)
## Not run: 
## or:
mca1_pertest &lt;- parPermute.cdp(mca1,permute=999999)

## End(Not run)
mca1_pertest
summary(mca1_pertest)
plot(mca1_pertest, las = 3)
mca1_pertest$UpYXcb$C # Array containing the codependence coefficients
#
## With all descriptors at once:
mca2 &lt;- MCA(Y=log1p(as.matrix(Salmon[,"Abundance",drop=FALSE])),
            X=as.matrix(Salmon[,3L:5]),emobj=map1)
mca2
mca2_partest &lt;- test.cdp(mca2)
mca2_partest
summary(mca2_partest)
par(mar = c(6,4,2,4))
plot(mca2_partest, las = 3)
mca2_pertest &lt;- permute.cdp(mca2)
## Not run: 
or:
mca2_pertest &lt;- parPermute.cdp(mca2,permute=999999)

## End(Not run)
mca2_pertest
summary(mca2_pertest)
plot(mca2_pertest, las = 3)
mca2_pertest$UpYXcb$C # Array containing the codependence coefficients
mca2_pertest$UpYXcb$C[,1L,] # now turned into a matrix.
#
###### End {Salmon exemple}
#
###### Begin {Doubs exemple}
#
data(Doubs)
#
## Creating a spatial eigenvector map:
map2 &lt;- eigenmap(x=Doubs.geo[,"DFS"])
#
mca3 &lt;- MCA(Y=log1p(Doubs.fish),X=Doubs.env,emobj=map2)
mca3
mca3_pertest &lt;- permute.cdp(mca3)
## Not run: 
## or:
mca3_pertest &lt;- parPermute.cdp(mca3,permute=999999)

## End(Not run)
mca3_pertest
summary(mca3_pertest)
par(mar = c(6,4,2,4))
plot(mca3_pertest, las = 2)
mca3_pertest$UpYXcb$C # Array containing the codependence coefficients
#
## Display the results along the transect
spmeans &lt;- colMeans(log1p(Doubs.fish))
pca1 &lt;- svd(log1p(Doubs.fish) - rep(spmeans,each=nrow(Doubs.fish)))
par(mar = c(5,5,2,5)+0.1)
plot(y = pca1$u[,1L], x = Doubs.geo[,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA1 loadings", xlab = "Distance from river source (km)")
#
x &lt;- seq(0,450,1)
newdists &lt;- matrix(NA, length(x), nrow(Doubs.geo))
for(i in 1L:nrow(newdists))
  newdists[i,] &lt;- abs(Doubs.geo[,"DFS"] - x[i])
#
## Calculating predictions for arbitrary sites under the same set of
## environmental conditions that the codependence model was built with.
prd1 &lt;- predict(mca3_pertest,
                newdata=list(target = eigenmap.score(map2, newdists)))
#
## Projection of the predicted species abundance on pca1:
Uprd1 &lt;- (prd1 - rep(spmeans, each = nrow(prd1))) %*% pca1$v %*% diag(pca1$d^-1)
lines(y = Uprd1[,1L], x = x, col=2, lty = 1)
#
## Projection of the predicted species abundance on pca2:
plot(y = pca1$u[,2L], x = Doubs.geo[,"DFS"], pch = 21L, bg = "red",
     ylab = "PCA2 loadings", xlab = "Distance from river source (km)")
lines(y = Uprd1[,2L], x = x, col=2, lty = 1)

#
## Displaying only the observed and predicted abundance for Brown Trout.
par(new=TRUE)
plot(y = log1p(Doubs.fish[,"TRU"]),Doubs.geo[,"DFS"],pch=21L,bg="green",
     ylab="",xlab="",new=FALSE,axes=FALSE)
axis(4)
lines(y = prd1[,"TRU"], x = x, col=3)
mtext(side=4, "log(Abundance+1)", line = 2.5)
#
###### End {Doubs exemple}
#
###### Begin {Oribatid exemple}
#
data(Mite)
#
map3 &lt;- eigenmap(x = mite.geo)
# Organize the environmental variables
mca4 &lt;- MCA(Y = log1p(mite.species), X = mite.env, emobj = map3)
mca4_partest &lt;- test.cdp(mca4, response.tests = FALSE)
summary(mca4_partest)
plot(mca4_partest, las = 2, lwd = 2)
plot(mca4_partest, col = rainbow(1200)[1L:1000], las = 3, lwd = 4,
     main = "Codependence diagram", col.signif = "white")
#
rng &lt;- list(x = seq(min(mite.geo[,"x"]) - 0.1, max(mite.geo[,"x"]) + 0.1, 0.05),
            y = seq(min(mite.geo[,"y"]) - 0.1, max(mite.geo[,"y"]) + 0.1, 0.05))
grid &lt;- cbind(x = rep(rng[["x"]], length(rng[["y"]])),
              y = rep(rng[["y"]], each = length(rng[["x"]])))
newdists &lt;- matrix(NA, nrow(grid), nrow(mite.geo))
for(i in 1L:nrow(grid)) {
  newdists[i,] &lt;- ((mite.geo[,"x"] - grid[i,"x"])^2 +
                    (mite.geo[,"y"] - grid[i,"y"])^2)^0.5
}
#
spmeans &lt;- colMeans(mite.species)
pca2 &lt;- svd(log1p(mite.species) - rep(spmeans, each = nrow(mite.species)))
#
prd2 &lt;- predict(mca4_partest,
          newdata = list(target = eigenmap.score(map3, newdists)))
Uprd2 &lt;- (prd2 - rep(spmeans, each = nrow(prd2))) %*% pca2$v %*% diag(pca2$d^-1)
#
### Printing the response variable
prmat &lt;- Uprd2[,1L]
dim(prmat) &lt;- c(length(rng$x),length(rng$y))
zlim &lt;- c(min(min(prmat),min(pca2$u[,1L])),max(max(prmat),max(pca2$u[,1L])))
image(z = prmat, x = rng$x, y = rng$y, asp = 1, zlim = zlim,
      col = rainbow(1200L)[1L:1000], ylab = "y", xlab = "x")
points(x = mite.geo[,"x"], y = mite.geo[,"y"], pch = 21,
  bg = rainbow(1200L)[round(1+(999*(pca2$u[,1L]-zlim[1L])/(zlim[2L]-zlim[1L])),0)])
#
###### End {Oribatid exemple}
#
</code></pre>

<hr>
<h2 id='minpermute'> Number of permutations for MCA </h2><span id='topic+minpermute'></span>

<h3>Description</h3>

<p>Calculate the number of permutations suitable for testing Multiscale
Codependence Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minpermute(alpha,nbtest,margin=1,ru=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minpermute_+3A_alpha">alpha</code></td>
<td>
<p> The familywise type I error threshold allowable for the
complete analysis. </p>
</td></tr>
<tr><td><code id="minpermute_+3A_nbtest">nbtest</code></td>
<td>
<p> The number of test performed (the number of
eigenvectors in the &lsquo;mem&rsquo; object in the case of
<code><a href="#topic+MCA">MCA</a></code>). </p>
</td></tr>
<tr><td><code id="minpermute_+3A_margin">margin</code></td>
<td>
<p> A margin allowed for the number of permutation. Default
value: 1. </p>
</td></tr>
<tr><td><code id="minpermute_+3A_ru">ru</code></td>
<td>
<p> The magnitude of the round-up to apply to the number of
permutations. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculate the number of permutations for use with
<code><a href="#topic+permute.cdp">permute.cdp</a></code>. Parameter <code>margin</code> allows to apply a
safe margin to the number of permutations. The minimal suitable value
for this parameter is 1. Parameter <code>ru</code> allows one to round-up
the number of permutations. A value of 0 implies no round-up, a value
of 1 a round-up to the next ten, 2 a round-up to the next hundred, and
so on. Function <code>minpermute</code> is called internally by
<code><a href="#topic+permute.cdp">permute.cdp</a></code> in case <code>permute = NA</code>. In that case,
the margin is set to 10 (<code>margin = 10</code>) and the outcome is
rounded-up to the next thousand (<code>ru = 3</code>). This function is
meant for users that wish to apply their own margins and round-up
factors to calculate the number of permutations for use with
<code>permute.cdp</code>.
</p>


<h3>Value</h3>

<p>The minimum number of permutation to be used for
<code><a href="#topic+permute.cdp">permute.cdp</a></code>.
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>


<h3>See Also</h3>

<p><a href="#topic+permute.cdp">permute.cdp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For a 5% threshold under 50 tests.
minpermute(alpha = 0.05, nbtest=50)
# Allowing more margin (implies more computation time).
minpermute(alpha = 0.05, nbtest=50, margin=10, ru=3)
</code></pre>

<hr>
<h2 id='Mite'>Lac Geai oribatid mites community data</h2><span id='topic+Mite'></span><span id='topic+mite.species'></span><span id='topic+mite.env'></span><span id='topic+mite.geo'></span>

<h3>Description</h3>

<p>A data set containing information on the microfauna of 70 sites
located within the the peat on shore of Lac Geai, a bog lake located
at the Station de Biologie de l'Université de Montréal, St-Hippolyte,
QC, Canada (+45.9954; -73.9936).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mite</code></pre>


<h3>Format</h3>

<p> Contains three matrices:
<code>mite.species</code> the abundance of 35 morpho-species of oribatid
mites (Acari).
</p>
<p><code>mite.env</code> 14 environmental variables (quantitative and binary).
</p>
<p><code>mite.geo</code> the relative coordinates of the samples.
</p>


<h3>Details</h3>

<p>Values in <code>mite.species</code> are counts of individuals of each of the
morpho-species obtained from 5 cm diameter cores going from the
surface of the peat down to a depth of 7 cm. See Bordard &amp; Legendre
(1994) and reference therein for details about sample treatment and
species identification.
</p>
<p><code>mite.env</code> contains two quantitative variables, namely the
substratum density (g/L) and water content (percent wet mass over dry
mass), in addition to 12 dummy variables. The first seven represent
the composition of the substratum: <em>Sphagnum magellacinum</em> (with
a majority of <em>S. rubellum</em>), <em>S. rubellum</em>,
<em>S. nemorum</em>, (with a majority of <em>S. augustifollium</em>),
<em>S. rubellum</em> + <em>S. magellicum</em> (in equal proportions),
lignous litter, bare peat, and interface between <em>Sphagnum</em>
species. The next three dummy variables represent the presence and
abundance of shrubs (<em>Kalmia polifolia</em>, <em>K. angustifolia</em>,
and <em>Rhododentron groenlandicum</em>): none, few, and many. The last
two dummy variables represent the microtopography of the peat: blanket
(flat) or hummock (raised).
</p>
<p><code>mite.geo</code> contains the location of the samples, in meters, with
respect to the sampling grid. Point (0,0) is the lower left end of the
plot for an observer looking from the shore towards the water. The
<code>x</code> coordinate is the offset along the shore (from left to right)
while the <code>y</code> coordinate is the offset from the shore while
moving towards the water (See Borcard &amp; Legendre, 1994, Fig. 1 for
details on the sampling area).
</p>


<h3>Source</h3>

<p> Daniel Borcard, Département de sciences biologiques, Université
de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Borcard, D. &amp; Legendre, P. 1994. Environmental control and spatial
structure in ecological communities: an example using Oribatid mites
(Acari, Oribatei). Environ. Ecol. Stat. 1: 37-61
</p>


<h3>See Also</h3>

<p>Borcard, D.; P. Legendre &amp; P. Drapeau. 1992. Partialling out the
spatial component of ecological variation. Ecology 73: 1045-1055
</p>
<p>Legendre, P. 2005. Species associations: the Kendall coefficient of
concordance revisited. Journal of Agricultural, Biological and
Environmental Statistics 10: 226-245
</p>
<p>Borcard, D.; Gillet, F. &amp; Legendre, P. 2011. Numerical Ecology with
R. Springer, New-York, NY, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mite)
summary(mite.species)
summary(mite.env)
summary(mite.geo)
</code></pre>

<hr>
<h2 id='Product-distribution'>Frequency distributions for MCA parametric testing</h2><span id='topic+Product-distribution'></span><span id='topic+dphi'></span><span id='topic+pphi'></span><span id='topic+dtau'></span><span id='topic+ptau'></span>

<h3>Description</h3>

<p>Density and distribution functions of the phi statistic, which is the
product of two Fisher-Snedecor distributions with particular degrees
of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dphi(x, nu1, nu2, tol = .Machine$double.eps ^ 0.5)
pphi(q, nu1, nu2, lower.tail = TRUE, tol = .Machine$double.eps ^ 0.5)
dtau(x, nu, tol = .Machine$double.eps ^ 0.5)
ptau(q, nu, lower.tail = TRUE, tol = .Machine$double.eps ^ 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Product-distribution_+3A_x">x</code>, <code id="Product-distribution_+3A_q">q</code></td>
<td>
<p> vector of quantile. </p>
</td></tr>
<tr><td><code id="Product-distribution_+3A_nu1">nu1</code>, <code id="Product-distribution_+3A_nu2">nu2</code>, <code id="Product-distribution_+3A_nu">nu</code></td>
<td>
<p> degrees of freedom (&gt;0, may be
non-integer). <code>Inf</code> is allowed. </p>
</td></tr>
<tr><td><code id="Product-distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p> logical; if TRUE (default), probabilities are P[X
&lt;= x], otherwise, P[X &gt; x]. </p>
</td></tr>
<tr><td><code id="Product-distribution_+3A_tol">tol</code></td>
<td>
<p> tolerance used for numerical estimation. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density distribution of a variable <code>z</code> that is the product of
two random variables <code>x</code> and <code>y</code> with density distributions
f(x) and g(y), respectively, is the integral over the intersection of
the domains of <code>x</code> and <code>y</code> of f(x) * g(z/x) / abs(x) dx.
</p>
<p><code>dphi</code> estimates density values using numerical integration
(<code><a href="stats.html#topic+integrate">integrate</a></code>) the Fisher-Scedecor <code><a href="stats.html#topic+df">df</a></code> density
distribution function. Following the algebra of Multiscale
Codependence Analysis, f(x) has df1 = nu1 and df2 = nu1 * nu2 degrees
of freedom and g(x) has 'df1 = 1' and 'df2 = nu2' degrees of
freedom. Hence, that product distribution has two parameters.
</p>
<p><code>pphi</code> integrates <code>dphi</code> in the interval
[<code>0</code>,<code>q</code>] when 'lower.tail = TRUE' (the default) and on
the interval [<code>q</code>,<code>Inf</code>] when 'lower.tail = FALSE'.
</p>
<p><code>dtau</code> and <code>ptau</code> are similar to <code>dphi</code> integrates
<code>pphi</code>, but with f(x) and f(y) being two Student's t distribution
with <code>nu</code> degrees of freedom.  It is called by functions
<code><a href="#topic+test.cdp">test.cdp</a></code> and <code><a href="#topic+permute.cdp">permute.cdp</a></code> to perform
hypothesis tests for single response variables, in which case
unilateral tests can be performed.
</p>


<h3>Value</h3>

<p><code>dphi</code> and <code>dtau</code> return the density functions whereas
<code>pphi</code> and <code>ptau</code> return the distribution functions.
</p>


<h3>Author(s)</h3>

<p> Guillaume Guénard, Département des sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Springer, M. D. 1979. The algebra of random variables. John Wiley and
Sons Inc., Hoboken, NJ, USA.
</p>
<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>
<p>Guénard, G. Legendre, P. 2018. Bringing multivariate support to
multiscale codependence analysis: Assessing the drivers of community
structure across spatial scales. Meth. Ecol. Evol. 9: 292-304
</p>


<h3>See Also</h3>

<p><a href="#topic+test.cdp">test.cdp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
### Displays the phi probability distribution for five different numbers
### of degrees of freedom:
#
x &lt;- 10^seq(-4, 0.5, 0.05)
plot(y = dphi(x, 1, 10), x = x, type = "l", col = "black", las = 1, ylab = "pdf",
  ylim = c(0, 0.5))
lines(y = dphi(x, 3, 10), x = x, col = "purple")
lines(y = dphi(x, 5, 70), x = x, col = "blue")
lines(y = dphi(x, 12, 23), x = x, col = "green")
lines(y = dphi(x, 35, 140), x = x, col = "red")
#
### Displays the density distribution function for 10 degrees of freedom
### and the cumulative probability above x = 1.
#
x &lt;- 10^seq(-4, 0.5, 0.05)
y &lt;- dphi(x, 5, 70)
plot(y = y, x = x, type = "l", col = "black", las = 1, ylab = "Density",
  ylim = c(0, 0.5))
polygon(x = c(x[81L:91], x[length(x)], 1), y = c(y[81L:91], 0, 0),
  col = "grey")
text(round(pphi(1, 5, 70, lower.tail=FALSE), 3), x = 1.75, y = 0.05)
#
### Idem for the tau distribution:
#
x &lt;- c(-(10^seq(0.5, -4, -0.05)), 10^seq(-4, 0.5, 0.05))
plot(y = dtau(x, 1), x = x, type = "l", col = "black", las = 1,
   ylab = "pdf", ylim = c(0, 0.5))
lines(y = dtau(x, 2), x = x, col = "purple")
lines(y = dtau(x, 5), x = x, col="blue")
lines(y = dtau(x, 10), x = x, col="green")
lines(y = dtau(x, 100), x = x, col="red")
#
y &lt;- dtau(x, 10)
plot(y = y, x = x, type = "l", col = "black", las = 1, ylab = "Density",
  ylim = c(0, 0.5))
polygon(x = c(x[which(x==1):length(x)], x[length(x)],1),
  y = c(y[which(x==1):length(x)], 0, 0), col = "grey")
text(round(ptau(1, 10, lower.tail = FALSE), 3), x = 1.5, y = 0.03)
polygon(x = c(-1, x[1L], x[1L:which(x==-1)]),
  y = c(0, 0, y[1L:which(x==-1)]), col="grey")
text(round(ptau(-1, 10), 3), x = -1.5, y = 0.03)
#
</code></pre>

<hr>
<h2 id='Salmon'>Juvenile Atlantic salmon (parr) density in St-Marguerite river,
Québec, Canada</h2><span id='topic+Salmon'></span>

<h3>Description</h3>

<p>A 1520m transect of the St-Marguerite River.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Salmon</code></pre>


<h3>Format</h3>

<p> A 76 rows by  5 columns <code><a href="base.html#topic+data.frame">data.frame</a></code>. </p>


<h3>Details</h3>

<p>Contains (1) the 76 sampling site positions along a 1520 m river
segment beginning at a location called &lsquo;Bardsville&rsquo; (Lat:
48°23'01.59&rdquo; N ; Long: 70°12'10.05&rdquo; W), (2) the number of parr
(young salmon, ages I+ and II+) observed at the sampling sites, (3)
the mean water depths (m), (4) the mean current velocity (m/s), and
(5) the mean substrate size (mm). Sampling took place on July 7, 2002,
in the 76 sites, each 20 m long. The &lsquo;Bardsville&rsquo; river segment
is located in the upper portion of  Sainte-Marguerite River, Quebec,
Canada.
</p>


<h3>Source</h3>

<p> Daniel Boisclair, Département de sciences biologiques,
Université de Montréal, Montréal, Québec, Canada. </p>


<h3>References</h3>

<p>Guénard, G., Legendre, P., Boisclair, D., and Bilodeau, M. 2010.
Multiscale codependence analysis: an integrated approach to analyse
relationships across scales. Ecology 91: 2952-2964
</p>


<h3>See Also</h3>

<p>Bouchard, J. and Boisclair, D. 2008. The relative importance of local,
lateral, and longitudinal variables on the development of habitat
quality models for a river. Can. J. Fish. Aquat. Sci. 65: 61-73
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Salmon)
summary(Salmon)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
