<!DOCTYPE html><html><head><title>Help for package InformativeCensoring</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {InformativeCensoring}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#col.headings'><p>Specify the columns of the data frame required by score imputation method</p></a></li>
<li><a href='#cox.zph'><p>Test Cox proportional hazards assumption</p></a></li>
<li><a href='#ExtractSingle'><p>Extract a single risk score/gamma imputed data set/model fit</p></a></li>
<li><a href='#gammaImpute'><p>Perform gamma-Imputation for a given data set</p></a></li>
<li><a href='#GammaImputedData.object'><p><code>GammaImputedData</code> object</p></a></li>
<li><a href='#GammaImputedSet.object'><p><code>GammaImputedSet</code> object</p></a></li>
<li><a href='#GammaStat.object'><p><code>GammaStat</code> object</p></a></li>
<li><a href='#GammaStatList.object'><p><code>GammaStatList</code> object</p></a></li>
<li><a href='#ImputeStat'><p>S3 generic to fit model(s) to risk score/gamma Imputed objects</p></a></li>
<li><a href='#InformativeCensoring-package'><p>Perform methods of multiple imputation for</p>
time to event data</a></li>
<li><a href='#MakeTimeDepScore'><p>Create a valid <code>ScoreTD</code> object</p></a></li>
<li><a href='#NN.options'><p>Create a list of options which control the nearest neighbour algorithm</p>
for risk score imputation</a></li>
<li><a href='#ScoreImpute'><p>Perform risk score multiple imputation method</p></a></li>
<li><a href='#ScoreImputedData.object'><p><code>ScoreImputedData</code> object</p></a></li>
<li><a href='#ScoreImputedSet.object'><p><code>ScoreImputedSet</code> object</p></a></li>
<li><a href='#ScoreInd'><p>Simulated time to event data with 5 time independent covariates</p></a></li>
<li><a href='#ScoreStat.object'><p>ScoreStat object</p></a></li>
<li><a href='#ScoreStatList.object'><p>ScoreStatList</p></a></li>
<li><a href='#ScoreStatSet'><p>S3 generic to create a <code>ScoreStatSet</code> object</p></a></li>
<li><a href='#ScoreStatSet.object'><p>An object which contains the test statistic and estimators for</p>
a set of model fits to imputed data using risk score imputation</a></li>
<li><a href='#ScoreTD.object'><p>A <code>ScoreTD</code> object</p></a></li>
<li><a href='#ScoreTimeDep'><p>Simulated time dependent variables for time to event data</p></a></li>
<li><a href='#summary.ScoreStatSet'><p>Summary object of <code>ScoreStatSet</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Imputation for Informative Censoring</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Bartlett &lt;jonathan.bartlett1@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>David Ruau [aut],
  Nikolas Burkoff [aut],
  Jonathan Bartlett [aut, cre],
  Dan Jackson [aut],
  Edmund Jones [aut],
  Martin Law [aut],
  Paul Metcalfe [aut]</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple Imputation for Informative Censoring.
    This package implements two methods. Gamma Imputation
    described in &lt;<a href="https://doi.org/10.1002%2Fsim.6274">doi:10.1002/sim.6274</a>&gt; and Risk Score Imputation
    described in &lt;<a href="https://doi.org/10.1002%2Fsim.3480">doi:10.1002/sim.3480</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), survival (&ge; 2.36-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, dplyr (&ge; 0.4.3), parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jwb133/InformativeCensoring">https://github.com/jwb133/InformativeCensoring</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-05 14:12:45 UTC; lshjb12</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-05 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='col.headings'>Specify the columns of the data frame required by score imputation method</h2><span id='topic+col.headings'></span>

<h3>Description</h3>

<p>Specify the columns of the data frame required by score imputation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.headings(arm, has.event, time, Id, DCO.time, to.impute, censor.type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.headings_+3A_arm">arm</code></td>
<td>
<p>column name which will contain the subject's treatment group</p>
</td></tr>
<tr><td><code id="col.headings_+3A_has.event">has.event</code></td>
<td>
<p>column name which will contain whether 
the subject has an event (1) or not(0)</p>
</td></tr>
<tr><td><code id="col.headings_+3A_time">time</code></td>
<td>
<p>column name of censoring/event time</p>
</td></tr>
<tr><td><code id="col.headings_+3A_id">Id</code></td>
<td>
<p>column name of subject Id</p>
</td></tr>
<tr><td><code id="col.headings_+3A_dco.time">DCO.time</code></td>
<td>
<p>column name of the time at which the subject would have been
censored had they not had an event before data cut off</p>
</td></tr>
<tr><td><code id="col.headings_+3A_to.impute">to.impute</code></td>
<td>
<p>column name of the logical column as to whether events should
be imputed</p>
</td></tr>
<tr><td><code id="col.headings_+3A_censor.type">censor.type</code></td>
<td>
<p>column name of the column containing the reason for censoring,
0=had event, 1=non-administrative censoring 2=administrative censoring &ndash; only subjects
with 1 in this column count as having an &lsquo;event&rsquo; in the Cox model for censoring 
(optionally used &ndash; if not used then all subjects who are censored are used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contain the given arguments
</p>

<hr>
<h2 id='cox.zph'>Test Cox proportional hazards assumption</h2><span id='topic+cox.zph'></span>

<h3>Description</h3>

<p>See cox.zph function in the survival package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.zph(fit, transform = "km", global = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox.zph_+3A_fit">fit</code></td>
<td>

<p>the result of fitting a Cox regression model, using the
<code>coxph</code> or <code>coxme</code> functions. 
</p>
</td></tr>
<tr><td><code id="cox.zph_+3A_transform">transform</code></td>
<td>

<p>a character string specifying how the survival times should be transformed 
before the test is performed. 
Possible values are <code>"km"</code>, <code>"rank"</code>, <code>"identity"</code> or a 
function of one argument. 
</p>
</td></tr>
<tr><td><code id="cox.zph_+3A_global">global</code></td>
<td>

<p>should a global chi-square test be done, in addition to the 
per-variable or per-term tests tests. 
</p>
</td></tr>
<tr><td><code id="cox.zph_+3A_...">...</code></td>
<td>
<p>Additional arguments to cox.zph, for example <code>index</code> if
fit is a <code>GammaStatList</code>  object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survival.html#topic+cox.zph">cox.zph</a></code>
</p>

<hr>
<h2 id='ExtractSingle'>Extract a single risk score/gamma imputed data set/model fit</h2><span id='topic+ExtractSingle'></span><span id='topic+ExtractSingle.GammaImputedSet'></span><span id='topic+ExtractSingle.GammaStatList'></span><span id='topic+ExtractSingle.ScoreImputedSet'></span><span id='topic+ExtractSingle.ScoreStatList'></span>

<h3>Description</h3>

<p>Extract a single risk score/gamma imputed data set/model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GammaImputedSet'
ExtractSingle(x, index)

## S3 method for class 'GammaStatList'
ExtractSingle(x, index)

ExtractSingle(x, index)

## S3 method for class 'ScoreImputedSet'
ExtractSingle(x, index)

## S3 method for class 'ScoreStatList'
ExtractSingle(x, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractSingle_+3A_x">x</code></td>
<td>
<p>The multiple imputed object</p>
</td></tr>
<tr><td><code id="ExtractSingle_+3A_index">index</code></td>
<td>
<p>Integer, which imputed data set/model fit should be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The individual data set/model fit
</p>

<hr>
<h2 id='gammaImpute'>Perform gamma-Imputation for a given data set</h2><span id='topic+gammaImpute'></span>

<h3>Description</h3>

<p>This function performs the Imputation described in
Relaxing the independent censoring assumptions in the Cox proportional
hazards model using multiple imputation. (2014) D. Jackson et al. Statist. Med. (33)
4681-4694
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaImpute(
  formula,
  data,
  m,
  gamma,
  gamma.factor,
  bootstrap.strata = rep(1, nrow(data)),
  DCO.time,
  ...,
  parallel = c("no", "multicore", "snow")[1],
  ncpus = 1L,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaImpute_+3A_formula">formula</code></td>
<td>
<p>The model formula to be used when fitting the models to calculate
the cumulative hazard. A formula for coxph can include strata terms but not
cluster or tt and only right-censored <code>Surv</code> objects can be used.
Note the function does not allow multiple strata to be written as <code>strata(W1)+strata(W2)</code>,
use <code>strata(W1,W2)</code> instead</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_data">data</code></td>
<td>
<p>A time to event data set for which event times are to be imputed</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_m">m</code></td>
<td>
<p>The number of imputations to be created</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_gamma">gamma</code></td>
<td>
<p>Either column name containing the value of gamma or a vector of values giving the subject specific
size of the step change in the log hazard at censoring. If a subject has NA in this column then no imputation is performed
for this subject (i.e. the subject's censored time remains unchanged after imputation). If a subject has already had an
event then the value of gamma is ignored. If <code>gamma.factor</code> is also used then the subject specific gamma
are all multipled by <code>gamma.factor</code>. At least one of <code>gamma</code> and <code>gamma.factor</code> must be included.</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_gamma.factor">gamma.factor</code></td>
<td>
<p>If used, a single numeric value. If no <code>gamma</code> then the step change in log
hazard for all subjects at censoring is given by <code>gamma.factor</code>. If <code>gamma</code> is used
then for each subject, the step change in log hazard is given by <code>gamma.factor</code> multiplied by the subject specific gamma.
At least one of <code>gamma</code> and <code>gamma.factor</code> must be included.</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_bootstrap.strata">bootstrap.strata</code></td>
<td>
<p>The strata argument for stratified bootstrap sampling, see argument <code>strata</code>
for the function <code>boot::boot</code> for further details. If argument is not used then standard sampling with
replacement will be used</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_dco.time">DCO.time</code></td>
<td>
<p>Either column name containing the subject's data cutoff time or a vector
of DCO.times for the subjects or a single number to be used as the DCO.time for all subjects
(if imputed events are &gt; this DCO.time then subjects are censored at DCO.time in imputed data sets)</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed into the model fit function</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically one would chose this to be
the number of available CPUs</p>
</td></tr>
<tr><td><code id="gammaImpute_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel="snow"</code>. If not supplied, a
cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the Gamma Imputation vignette for further details
</p>


<h3>Value</h3>

<p>A <code>GammaImputedSet.object</code> containing the imputed data sets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GammaImputedSet.object">GammaImputedSet.object</a></code> <code><a href="#topic+GammaImputedData.object">GammaImputedData.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(nwtco)
nwtco &lt;- nwtco[1:500,]

#creating 2 imputed data sets (m=2) for speed, would normally create more
ans &lt;- gammaImpute(formula=Surv(edrel,rel)~histol + instit,
                   data = nwtco, m=2, gamma.factor=1, DCO.time=6209)

#subject specific gamma (multiplied by gamma.factor to give the jump)
#NA for subjects that are not to be imputed
jumps &lt;- c(rep(NA,10),rep(1,490))
DCO.values &lt;- rep(6209,500)

ans.2 &lt;- gammaImpute(formula=Surv(edrel,rel)~histol + instit + strata(stage),
                   data = nwtco, m=2, bootstrap.strata=strata(nwtco$stage),
                   gamma=jumps, gamma.factor=1, DCO.time=DCO.values)

#can also use column names
nwtco$gamma &lt;- jumps
nwtco$DCO.time &lt;- DCO.values
ans.3 &lt;- gammaImpute(formula=Surv(edrel,rel)~histol + instit + strata(stage),
                   data = nwtco, m=2, bootstrap.strata=strata(nwtco$stage),
                   gamma="gamma", DCO.time="DCO.time")

## End(Not run)

</code></pre>

<hr>
<h2 id='GammaImputedData.object'><code>GammaImputedData</code> object</h2><span id='topic+GammaImputedData.object'></span>

<h3>Description</h3>

<p>An object which contains
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the time to event data
with 3 new columns impute.time and impute.event, the imputed event/censoring times and event indicators
(for subjects whose data is not imputed these columns contain the unchanged event/censoring time and
event indicator) and internal_gamma_val which is the value of gamma used for each subject in this data set</p>
</dd>
<dt><code>default.formula</code></dt><dd><p>The default model formula which will be used when fitting the imputed data</p>
</dd>
</dl>

<hr>
<h2 id='GammaImputedSet.object'><code>GammaImputedSet</code> object</h2><span id='topic+GammaImputedSet.object'></span>

<h3>Description</h3>

<p>An object which contains the set of gamma imputed data frames.
Use the <code>ExtractSingle</code> function to extract a single
<code>GammaImputedData</code> objects. Use the ImputeStat function to fit models
to the entire set of imputed data frames
</p>


<h3>Details</h3>

<p>It contains the following:
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the unimputed time to event data (along with a column internal_gamma_val
which is the value of gamma used for each subject in this data set)</p>
</dd>
<dt><code>m</code></dt><dd><p>The number of imputed data sets</p>
</dd>
<dt><code>gamma.factor</code></dt><dd><p>The value of gamma.factor used with the imputation</p>
</dd>
<dt><code>impute.time</code></dt><dd><p>A matrix (1 column per imputed data set) containing the imputed times</p>
</dd>
<dt><code>impute.event</code></dt><dd><p>A matrix (1 column per imputed data set) containing the imputed event indicators</p>
</dd>
<dt><code>default.formula</code></dt><dd><p>The default model formula which will be used when fitting the imputed data</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+GammaImputedData.object">GammaImputedData.object</a></code>
</p>

<hr>
<h2 id='GammaStat.object'><code>GammaStat</code> object</h2><span id='topic+GammaStat.object'></span>

<h3>Description</h3>

<p>An S3 object which contains the point estimate 
and test statistic after fitting a model to 
a <code>GammaImputedData</code> object.
</p>


<h3>Details</h3>

<p>The function <code>print.GammaStat</code> has been implemented
</p>
<p>The object contains the following:
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>The model used to create the fit</p>
</dd>
<dt><code>method</code></dt><dd><p>The model used for the fit</p>
</dd>
<dt><code>estimate</code></dt><dd><p>A point estimate of the test statistic</p>
</dd>
<dt><code>var</code></dt><dd><p>The estimate for the variance of the test statistic</p>
</dd>
</dl>

<hr>
<h2 id='GammaStatList.object'><code>GammaStatList</code> object</h2><span id='topic+GammaStatList.object'></span>

<h3>Description</h3>

<p>The object containing the results of fitting models to
a <code>GammaImputedSet</code> object.
</p>


<h3>Details</h3>

<p>A <code>summary.GammaStatList</code> has been implemented which performs
Rubin's multiple imputation rules. 
</p>
<p>The object contains the following
</p>


<h3>Slots</h3>


<dl>
<dt><code>fits</code></dt><dd><p>A list of <code>GammaStat</code> objects containing the model fits for
the imputed data sets</p>
</dd>
<dt><code>statistics</code></dt><dd><p>A list with two elements: estimates and vars which contain the coefficient
estimates and their variances one column per covariate one row per imputed data set</p>
</dd>
<dt><code>m</code></dt><dd><p>The number of model fits</p>
</dd>
</dl>

<hr>
<h2 id='ImputeStat'>S3 generic to fit model(s) to risk score/gamma Imputed objects</h2><span id='topic+ImputeStat'></span><span id='topic+ImputeStat.GammaImputedData'></span><span id='topic+ImputeStat.GammaImputedSet'></span><span id='topic+ImputeStat.ScoreImputedSet'></span>

<h3>Description</h3>

<p>S3 generic to fit model(s) to risk score/gamma Imputed objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GammaImputedData'
ImputeStat(
  object,
  method = c("Cox", "weibull", "exponential")[1],
  formula = NULL,
  ...
)

## S3 method for class 'GammaImputedSet'
ImputeStat(
  object,
  method = c("Cox", "weibull", "exponential")[1],
  formula = NULL,
  ...,
  parallel = c("no", "multicore", "snow")[1],
  ncpus = 1L,
  cl = NULL
)

ImputeStat(
  object,
  method = c("logrank", "Wilcoxon", "Cox", "weibull", "exponential")[1],
  formula,
  ...
)

## S3 method for class 'ScoreImputedSet'
ImputeStat(
  object,
  method = c("logrank", "Wilcoxon", "Cox")[1],
  formula = NULL,
  ...,
  parallel = c("no", "multicore", "snow")[1],
  ncpus = 1L,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImputeStat_+3A_object">object</code></td>
<td>
<p>A <code>ScoreImputedData</code>, <code>ScoreImputedSet</code>, <code>GammaImputedData</code> or <code>GammaImputedSet</code> object 
to fit the model to</p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_method">method</code></td>
<td>
<p>The type of statistical model to fit. There are three methods which can be performed when using
Risk Score imputation   <br />
&quot;logrank&quot;: a logrank test using <code>survival::survdiff</code> <br />
&quot;Wilcoxon&quot;: Peto &amp; Peto modification of the Gehan-Wilcoxon test using <code>survival::survdiff</code>
with <code>rho=1</code> <br />
&quot;Cox&quot;: Fit a cox model using <code>survival::coxph</code>  <br /> 
</p>
<p>For gamma imputation the model can be &quot;Cox&quot; (using <code>survival::coxph</code>), 
&quot;weibull&quot; or &quot;exponential&quot; both using <code>survival::coxph</code></p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_formula">formula</code></td>
<td>
<p>The model formula to fit.
If no formula argument is used, then object$default.formula will be used.
For risk score imputation this is <code>~ treatment.group</code> and for gamma imputation
this is the formula used when fitting the Cox model
</p>
<p>For <code>method="Cox"</code>, additional covariates can be included by explictily giving a 
formula argument. For logrank/Wilcoxon only additional strata terms can be
included. 
</p>
<p>In all cases only the right hand side of the formula is required
The survival object on the left hand side is created automatically
E.g. for a Cox model could use formula=~arm + covar1. The cluster and tt options cannot be used
See the vignettes for further details</p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_...">...</code></td>
<td>
<p>Additional arguments which are passed into the model fit function</p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any), can be used for <code>GammaImputedSet</code> and <code>ScoreImputedSet</code></p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically one would chose this to be
the number of available CPUs, can be used for <code>GammaImputedSet</code> and <code>ScoreImputedSet</code>.</p>
</td></tr>
<tr><td><code id="ImputeStat_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel="snow"</code>. If not supplied, a
cluster on the local machine is created for the duration of the call, can be used for <code>GammaImputedSet</code> and <code>ScoreImputedSet</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreStat.object">ScoreStat.object</a></code> <code><a href="#topic+ScoreImputedData.object">ScoreImputedData.object</a></code>
</p>

<hr>
<h2 id='InformativeCensoring-package'>Perform methods of multiple imputation for
time to event data</h2><span id='topic+InformativeCensoring-package'></span><span id='topic+InformativeCensoring'></span>

<h3>Description</h3>

<p>Perform methods of multiple imputation for
time to event data
</p>


<h3>Details</h3>

<p>See Nonparametric comparison of two survival functions with
dependent censoring via nonparametric multiple imputation. Hsu and Taylor
Statistics in Medicine (2009) 28:462-475 for Hsu's method
</p>
<p>See Relaxing the independent censoring assumption in the Cox proportional
hazards model using multiple imputation. Jackson et al., Statistics in Medicine
(2014) 33:4681-4694 for Jackson's method
</p>


<h3>Author(s)</h3>

<p><a href="mailto:David.Ruau@astrazeneca.com">David.Ruau@astrazeneca.com</a>
</p>

<hr>
<h2 id='MakeTimeDepScore'>Create a valid <code>ScoreTD</code> object</h2><span id='topic+MakeTimeDepScore'></span>

<h3>Description</h3>

<p>Create a valid <code>ScoreTD</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeTimeDepScore(data, Id, time.start, time.end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeTimeDepScore_+3A_data">data</code></td>
<td>
<p>A data frame of time dependent covariates</p>
</td></tr>
<tr><td><code id="MakeTimeDepScore_+3A_id">Id</code></td>
<td>
<p>The column name of the subject Id</p>
</td></tr>
<tr><td><code id="MakeTimeDepScore_+3A_time.start">time.start</code></td>
<td>
<p>The covariates are valid for the time [time.start,time.end] where
time.start is the column name of time.start</p>
</td></tr>
<tr><td><code id="MakeTimeDepScore_+3A_time.end">time.end</code></td>
<td>
<p>The covariates are valid for the time [time.start,time.end] where
time.end is the column name of time.end</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ScoreTD</code> object
</p>

<hr>
<h2 id='NN.options'>Create a list of options which control the nearest neighbour algorithm
for risk score imputation</h2><span id='topic+NN.options'></span>

<h3>Description</h3>

<p>Create a list of options which control the nearest neighbour algorithm
for risk score imputation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NN.options(NN = 5, w.censoring = 0.2, min.subjects = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NN.options_+3A_nn">NN</code></td>
<td>
<p>The (maximum) number of subjects to be included in the
risk set</p>
</td></tr>
<tr><td><code id="NN.options_+3A_w.censoring">w.censoring</code></td>
<td>
<p>The weighting on the censoring risk score when 
calculating distances for the nearest neighbour calculation
A weighting of <code>(1-w.censoring)</code> is used for the event risk score</p>
</td></tr>
<tr><td><code id="NN.options_+3A_min.subjects">min.subjects</code></td>
<td>
<p>If using time dependent score imputation include at least
this number of subjects when fitting the Cox model (i.e. include some subjects who were censored/had event
earlier than the cenosred observation if neccessary)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of options used within the ScoreImputedData
function
</p>

<hr>
<h2 id='ScoreImpute'>Perform risk score multiple imputation method</h2><span id='topic+ScoreImpute'></span>

<h3>Description</h3>

<p>Perform risk score multiple imputation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreImpute(
  data,
  event.model,
  censor.model = event.model,
  col.control,
  NN.control = NN.options(),
  time.dep = NULL,
  m,
  bootstrap.strata = rep(1, nrow(data)),
  ...,
  parallel = c("no", "multicore", "snow")[1],
  ncpus = 1L,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScoreImpute_+3A_data">data</code></td>
<td>
<p>The data set for which imputation is required</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_event.model">event.model</code></td>
<td>
<p>The right hand side of the formula to be used for fitting the Cox model for calculating the time to 
event score e.g. ~Z1+Z2+Z3.</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_censor.model">censor.model</code></td>
<td>
<p>The right hand side of the formula to be used for fitting the Cox model for calculating the time to 
censoring score if not included then <code>event.model</code> will be used</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_col.control">col.control</code></td>
<td>
<p>A list of the columns names of <code>data</code> which are used by the imputation algorithm
See example below and for further details of these columns and their purpose see <code><a href="#topic+col.headings">col.headings</a></code></p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_nn.control">NN.control</code></td>
<td>
<p>Parameters which control the nearest neighbour algorithm. See <code><a href="#topic+NN.options">NN.options</a></code></p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_time.dep">time.dep</code></td>
<td>
<p>A ScoreTD object, to be included if the time dependent score imputation method is to be used, otherwise it should be NULL</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_m">m</code></td>
<td>
<p>The number of data sets to impute</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_bootstrap.strata">bootstrap.strata</code></td>
<td>
<p>When performing the bootstrap procedure for fitting the models,
how should the data be stratified (see strata argument to <code>boot::boot</code>). if argument
is not used then standard sampling with replacement is used to generate the bootstrap data</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_...">...</code></td>
<td>
<p>Additional arguments passed into the Cox model Note the subset and na.action arguments should not be used 
(na.fail will be used when fitting the Cox model)</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any).</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: typically one would chose this to be
the number of available CPUs</p>
</td></tr>
<tr><td><code id="ScoreImpute_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel="snow"</code>. If not supplied, a
cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that coxph may fail to converge and the following output
Warning in fitter(X, Y, strats, offset, init, control, weights = weights, :  
Ran out of iterations and did not converge
</p>
<p>It is possible to use ridge regression by including a ridge term in the model formula
(e.g. <code>~Z1+ridge(Z2,theta=1)</code>). See <code><a href="survival.html#topic+ridge">ridge</a></code> for further details
</p>


<h3>Value</h3>

<p>A <code>ScoreImputedSet</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreImputedSet.object">ScoreImputedSet.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ScoreInd)

col.control &lt;- col.headings(has.event="event", time="time",
                            Id="Id",arm="arm",
                            DCO.time="DCO.time", 
                            to.impute="to.impute")

## Not run: 
ans &lt;- ScoreImpute(data=ScoreInd,event.model=~Z1+Z2+Z3+Z4+Z5,
                   col.control=col.control, m=5,
                   bootstrap.strata=ScoreInd$arm,
                   NN.control=NN.options(NN=5,w.censoring = 0.2))

## End(Not run)

</code></pre>

<hr>
<h2 id='ScoreImputedData.object'><code>ScoreImputedData</code> object</h2><span id='topic+ScoreImputedData.object'></span>

<h3>Description</h3>

<p>An object which contains
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the time to event data
with 2 new columns impute.time and impute.event, the imputed event/censoring times and event indicators
(for subjects whose data is not imputed these columns contain the unchanged event/censoring time and
event indicator )</p>
</dd>
<dt><code>col.control</code></dt><dd><p>The list of column names the risk score imputation method requires see <code><a href="#topic+col.headings">col.headings</a></code>
for further details. If censor.type was not used then <code>col.control$censor.type="using_has.event_col"</code></p>
</dd>
<dt><code>default.formula</code></dt><dd><p>The default model formula which will be used when fitting the imputed data using a Cox model</p>
</dd>
</dl>

<hr>
<h2 id='ScoreImputedSet.object'><code>ScoreImputedSet</code> object</h2><span id='topic+ScoreImputedSet.object'></span>

<h3>Description</h3>

<p>An object which contains the set of score imputed data frames.
Use the <code>ExtractSingle</code> function to extract a single 
<code>ScoreImputedData</code> object. Use the <code>ScoreStat</code> function to fit models
to the entire set of imputed data frames
</p>


<h3>Details</h3>

<p>It contains the following:
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A data frame containing the unimputed time to event data</p>
</dd>
<dt><code>col.control</code></dt><dd><p>The list of column names the score imputation method requires see <code><a href="#topic+col.headings">col.headings</a></code>
for further details</p>
</dd>
<dt><code>m</code></dt><dd><p>The number of imputed data sets</p>
</dd>
<dt><code>impute.time</code></dt><dd><p>A matrix (1 column per imputed data set) containing the imputed times</p>
</dd>
<dt><code>impute.event</code></dt><dd><p>A matrix (1 column per imputed data set) containing the imputed event indicators</p>
</dd>
<dt><code>default.formula</code></dt><dd><p>The default model formula which will be used when fitting the imputed data using a Cox model</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreImputedData.object">ScoreImputedData.object</a></code>
</p>

<hr>
<h2 id='ScoreInd'>Simulated time to event data with 5 time independent covariates</h2><span id='topic+ScoreInd'></span>

<h3>Description</h3>

<p>This dataset is inspired by the simulation described in Hsu and Taylor,
Statistics in Medicine (2009) 28:462-475 with an additional DCO.time column
</p>


<h3>Format</h3>

<p>A data.frame containing a row per subject with eleven columns:
</p>


<h3>Fields</h3>


<dl>
<dt><code>Id</code></dt><dd><p>subject identifier</p>
</dd>
<dt><code>arm</code></dt><dd><p>factor for treatment group control=0, active=1</p>
</dd>
<dt><code>Z1</code></dt><dd><p>binary time independent covariate</p>
</dd>
<dt><code>Z2</code></dt><dd><p>continuous time independent covariate</p>
</dd>
<dt><code>Z3</code></dt><dd><p>binary time independent covariate</p>
</dd>
<dt><code>Z4</code></dt><dd><p>continuous time independent covariate</p>
</dd>
<dt><code>Z5</code></dt><dd><p>binary time independent covariate</p>
</dd>
<dt><code>event</code></dt><dd><p>event indicator (1 yes, 0 no)</p>
</dd>
<dt><code>time</code></dt><dd><p>subject censoring/event time (in years)</p>
</dd>
<dt><code>to.impute</code></dt><dd><p>logical, should an event time be imputed for this subject?
(this is ignored if subject has event time)</p>
</dd>
<dt><code>DCO.time</code></dt><dd><p>The time the subject would have been censored if they had not
had an event or been censored before the data cut off date</p>
</dd>
</dl>

<hr>
<h2 id='ScoreStat.object'>ScoreStat object</h2><span id='topic+ScoreStat.object'></span>

<h3>Description</h3>

<p>An S3 object which contains the point estimate 
and test statistic after fitting a model to 
a <code>ScoreImputedData</code> object.
</p>


<h3>Details</h3>

<p>The functions <code>print.ScoreStat</code> and <code>as.vector.ScoreStat</code>
have been included 
</p>
<p>The object contains the following:
</p>
<p>The test statistic should be normally distributed and hence for
the logrank test Z = (O_2 - E_2)/sqrt(V_2), i.e. the square root of the standard
Chi squared statistic (with the appropriate sign)
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>The model used to create the fit</p>
</dd>
<dt><code>method</code></dt><dd><p>The method used for the fit</p>
</dd>
<dt><code>estimate</code></dt><dd><p>A point estimate of the test statistic</p>
</dd>
<dt><code>var</code></dt><dd><p>The estimate for the variance of the test statistic</p>
</dd>
<dt><code>statistic</code></dt><dd><p>The test statistic given by <code>estimate/sqrt(var)</code></p>
</dd>
</dl>

<hr>
<h2 id='ScoreStatList.object'>ScoreStatList</h2><span id='topic+ScoreStatList.object'></span>

<h3>Description</h3>

<p>The object containing the results of fitting models to
a <code>ScoreImputedSet</code> object.
</p>


<h3>Details</h3>

<p>A <code>summary.ScoreStatList</code> has been implemented.
</p>
<p>The object contains the following
</p>


<h3>Slots</h3>


<dl>
<dt><code>fits</code></dt><dd><p>A list of <code>ScoreStat</code> objects containing the model fits for
the imputed data sets</p>
</dd>
<dt><code>statistics</code></dt><dd><p>A <code>ScoreStatSet</code> object containing the statistics</p>
</dd>
<dt><code>m</code></dt><dd><p>The number of model fits</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreStatSet.object">ScoreStatSet.object</a></code> <code><a href="#topic+ScoreStat.object">ScoreStat.object</a></code>
</p>

<hr>
<h2 id='ScoreStatSet'>S3 generic to create a <code>ScoreStatSet</code> object</h2><span id='topic+ScoreStatSet'></span>

<h3>Description</h3>

<p>S3 generic to create a <code>ScoreStatSet</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreStatSet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScoreStatSet_+3A_x">x</code></td>
<td>
<p>The object to convert into a <code>ScoreStatSet</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ScoreStatSet object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ScoreStatSet.object">ScoreStatSet.object</a></code>
</p>

<hr>
<h2 id='ScoreStatSet.object'>An object which contains the test statistic and estimators for
a set of model fits to imputed data using risk score imputation</h2><span id='topic+ScoreStatSet.object'></span>

<h3>Description</h3>

<p>The object is a Mx3 matrix, one row per imputed data set
and columns: estimate (the point estimates), var (their variances)
and Z (the test statistic). M must be &gt; 4
</p>


<h3>Details</h3>

<p>Note the Z should be ~ standard normal (so we do not use the chi_squared
test statistic see <code><a href="#topic+ScoreStat.object">ScoreStat.object</a></code> for further details)
</p>
<p>The summary.ScoreStatSet function will apply the MI averaging procedures
and estimates of the test statistic and p-value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ScoreStatSet">summary.ScoreStatSet</a></code>
</p>

<hr>
<h2 id='ScoreTD.object'>A <code>ScoreTD</code> object</h2><span id='topic+ScoreTD.object'></span>

<h3>Description</h3>

<p>This data frame holds time dependent covariates for
use with risk score imputation
</p>


<h3>Details</h3>

<p>The data frame contains the following columns:
'Id' for subject ID <br />
'time.start' and 'time.end' the range of time for which 
the covariate values are valid - i.e. [time.start,time.end] <br /> 
Additional columns are the time dependent covariates 
</p>
<p>All data for a single subject should be stored in consecutive rows, sorted 
by time and the starting time of a row should match the ending time of the previous row
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MakeTimeDepScore">MakeTimeDepScore</a></code>
</p>

<hr>
<h2 id='ScoreTimeDep'>Simulated time dependent variables for time to event data</h2><span id='topic+ScoreTimeDep'></span>

<h3>Description</h3>

<p>This data set contains time dependent covariates for the
<code><a href="#topic+ScoreInd">ScoreInd</a></code> time to event data.
</p>


<h3>Format</h3>

<p>A data.frame containing 1 row per subject-visit
</p>


<h3>Fields</h3>


<dl>
<dt><code>Id</code></dt><dd><p>The Subject Id</p>
</dd>
<dt><code>start</code></dt><dd><p>The covariate given in each row are for a given subject from time 'start'...</p>
</dd>
<dt><code>end</code></dt><dd><p>... until time end</p>
</dd>
<dt><code>W1</code></dt><dd><p>The value of a (binary) time dependent variable
for the subject with the given 'Id' between times 'start' and 'end'</p>
</dd>
<dt><code>W2</code></dt><dd><p>The value of a (continuous) time dependent variable
for the subject with the given 'Id' between times 'start' and 'end'</p>
</dd>
</dl>

<hr>
<h2 id='summary.ScoreStatSet'>Summary object of <code>ScoreStatSet</code> object</h2><span id='topic+summary.ScoreStatSet'></span><span id='topic+summary.ScoreStatSet.object'></span>

<h3>Description</h3>

<p>This object contains the multiple imputed 
averages/p-values of a set of estimates from 
risk score imputed data sets.
</p>


<h3>Details</h3>

<p>A <code>print.summary.ScoreStatSet</code> function has been implemented
</p>
<p>This object contains three lists meth1 and meth2 and methRubin
meth1 averages the point estimates to produce an F test statistic,
meth2 averages the test statistics and prodcues a t test statistic
and methRubin follows Rubin's standard rules and is used for calculating
confidence intervals
</p>
<p>See the vignette for further details.
</p>
<p>meth1, meth2 and methRubin are lists with the following elements:
estimate: average estimator for meth1, NOTE: for meth2 this is the average test statistic, <br />
var: estimate of variance of &quot;estimate&quot; field <br />
test.stat: test statistic <br />
distribution: distribution of statistical test (i.e. F or t) <br />
p.value: p-value of test <br />
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
