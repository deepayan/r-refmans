<!DOCTYPE html><html><head><title>Help for package match2C</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {match2C}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_balance'><p>Check balance after matching.</p></a></li>
<li><a href='#check_balance_template'><p>Check balance after template matching.</p></a></li>
<li><a href='#construct_outcome'><p>Construct an output for matching.</p></a></li>
<li><a href='#construct_outcome_template'><p>Construct an output for template matching.</p></a></li>
<li><a href='#create_list_from_mat'><p>Create a list representation of a distance matrix.</p></a></li>
<li><a href='#create_list_from_scratch'><p>Create a sparse list representation of treatment-to-control distance</p>
matrix with a caliper.</a></li>
<li><a href='#create_list_from_scratch_overall'><p>Create a sparse list representation of treated-to-control distance</p>
matrix with a fixed number caliper with L1-distance.</a></li>
<li><a href='#dt_Rouse'><p>Rouse (1995) dataset</p></a></li>
<li><a href='#force_control'><p>Force including certain controls in the final matched samples.</p></a></li>
<li><a href='#match_2C'><p>Optimal Matching with Two Criteria.</p></a></li>
<li><a href='#match_2C_list'><p>Perform a pair (or 1:k) matching with two user-specified list representations of</p>
distance matrices.</a></li>
<li><a href='#match_2C_mat'><p>Perform a pair matching using two user-specified distance matrices.</p></a></li>
<li><a href='#NewPackage-package'>
<p>A short title line describing what the package does</p></a></li>
<li><a href='#revert_dist_list_cpp'><p>Revert a treated-to-control distance list.</p></a></li>
<li><a href='#solve_network_flow'><p>Solve a network flow problem.</p></a></li>
<li><a href='#stitch_two_nets'><p>Stitch two treated-to-control networks into one two-part networks.</p></a></li>
<li><a href='#stitch_two_nets_template'><p>Stitch a template-to-treated network and a treated-to-control network</p>
into one two-part network.</a></li>
<li><a href='#template_match'><p>Optimal Matching with Two Criteria.</p></a></li>
<li><a href='#treated_control_net'><p>Create a treate-to-control network to be solved via a network flow algorithm.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Match One Sample using Two Criteria</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate matching in observational studies typically has two goals: 1. to construct 
    treated and control groups that have similar distribution of observed covariates and 2. to produce 
    matched pairs or sets that are homogeneous in a few priority variables. This packages implements a
    network-flow-based method built around a tripartite graph that can simultaneously achieve both goals.
    The package also implements a template matching algorithm using a variant of the tripartite graph 
    design. A brief description of the workflow and some examples are given in the vignette. A more elaborated
    tutorial can be found at <a href="https://www.researchgate.net/publication/359513837_Tutorial_for_R_Package_match2C">https://www.researchgate.net/publication/359513837_Tutorial_for_R_Package_match2C</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, mvnfast, rcbalance, Rcpp, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, knitr, mvtnorm, RItools, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-17 04:38:27 UTC; bzhan</td>
</tr>
<tr>
<td>Author:</td>
<td>Bo Zhang [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bo Zhang &lt;bzhang3@fredhutch.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_balance'>Check balance after matching.</h2><span id='topic+check_balance'></span>

<h3>Description</h3>

<p>This function checks the overall balance after statistical matching and plots
the distribution of the propensity score in the treated group, the control group,
and the matched control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_balance(Z, match_object, cov_list, plot_propens, propens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_balance_+3A_z">Z</code></td>
<td>
<p>A vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="check_balance_+3A_match_object">match_object</code></td>
<td>
<p>An object returned by match_2C or match_2C_mat or match_2C_list.</p>
</td></tr>
<tr><td><code id="check_balance_+3A_cov_list">cov_list</code></td>
<td>
<p>A vector of names of covariates as appeared in the original dataset.</p>
</td></tr>
<tr><td><code id="check_balance_+3A_plot_propens">plot_propens</code></td>
<td>
<p>Post-matching distribution of the estimated propensity scores in
two groups is plotted if TRUE; FALSE by default.</p>
</td></tr>
<tr><td><code id="check_balance_+3A_propens">propens</code></td>
<td>
<p>NULL by default. If plot_propens = TRUE, then a vector of
estimated propensity scores satisfying length(propens) = length(Z)
needs to be supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data frame of the overall balance after statistical
matching. We tabulate the mean of each covariate in the cov_list in the treated group
and control groups after matching, and calculate their standardized differences.
Standardized difference is defined as the mean difference divided by the pooled
standard error before matching.
</p>

<hr>
<h2 id='check_balance_template'>Check balance after template matching.</h2><span id='topic+check_balance_template'></span>

<h3>Description</h3>

<p>This function checks the overall balance after template matching and returns a
dataframe with 7 columns: (1) mean of all covariates in the treated group,
(2) mean of all covariates in the control group,
(3) standardized mean differences of (1) and (2),
(4) mean of all covariates in the matched treated group,
(5) mean of all covariates in the matched control group,
(6) standardized mean differences of (4) and (5),
(7) mean of covariates in the template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_balance_template(dataset, template, template_match_object, cov_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_balance_template_+3A_dataset">dataset</code></td>
<td>
<p>The original dataset.</p>
</td></tr>
<tr><td><code id="check_balance_template_+3A_template">template</code></td>
<td>
<p>A data frame of the template.</p>
</td></tr>
<tr><td><code id="check_balance_template_+3A_template_match_object">template_match_object</code></td>
<td>
<p>An object returned by template_match.</p>
</td></tr>
<tr><td><code id="check_balance_template_+3A_cov_list">cov_list</code></td>
<td>
<p>A vector of names of covariates as appeared in the original dataset and the template.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data frame of the overall balance after template
matching. We tabulate the mean and SMD of each covariate in the cov_list in the template,
the matched treated group, and the matched control group.
</p>

<hr>
<h2 id='construct_outcome'>Construct an output for matching.</h2><span id='topic+construct_outcome'></span>

<h3>Description</h3>

<p>This function constructs the output given the relaxsolution
to the associated network flow problem and the original dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_outcome(res, dist_list_1, Z, dataset, controls = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_outcome_+3A_res">res</code></td>
<td>
<p>A callrelax output.</p>
</td></tr>
<tr><td><code id="construct_outcome_+3A_dist_list_1">dist_list_1</code></td>
<td>
<p>A possibly sparse representation of the first distance matrix.</p>
</td></tr>
<tr><td><code id="construct_outcome_+3A_z">Z</code></td>
<td>
<p>A vector of treatment status.</p>
</td></tr>
<tr><td><code id="construct_outcome_+3A_dataset">dataset</code></td>
<td>
<p>The original dataset.</p>
</td></tr>
<tr><td><code id="construct_outcome_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of three objects: 1) feasible: 0/1 depending on the
feasibility of the matching problem; 2) data_with_matched_set_ind: a data frame that is the
same as the original data frame, except that a column called &ldquo;matched_set&rdquo; and a column
called &ldquo;distance&rdquo; are appended to it. &ldquo;matched_set&rdquo; column assigns 1,2,...,n_t to each matched
set, and NA to those not matched to any treated. Variable &ldquo;distance&rdquo; records the distance
(as specified in the left network) between each matched control and the treated, and assigns NA
to all treated and controls that are left unmatched. If matching is not feasible, NULL will be returned;
3) matched_data_in_order:a dataframe organized in the order of matched sets and otherwise the
same as data_with_matched_set_ind. Note that the matched_set column assigns 1,2,...,n_t for
as indices for matched sets, and NA for those controls that are not paired. Null will
be returned if the matching is unfeasible.
</p>

<hr>
<h2 id='construct_outcome_template'>Construct an output for template matching.</h2><span id='topic+construct_outcome_template'></span>

<h3>Description</h3>

<p>This function constructs the output for template matching given
the relaxsolution to the network flow problem,
number of edges in the template-to-treated network,
a vector of treatment status, and the original dataset. This function
is of little interest to users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_outcome_template(res, num_edges_left, Z, dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_outcome_template_+3A_res">res</code></td>
<td>
<p>A callrelax output.</p>
</td></tr>
<tr><td><code id="construct_outcome_template_+3A_num_edges_left">num_edges_left</code></td>
<td>
<p>Number of edges in the template-to-treatment network.</p>
</td></tr>
<tr><td><code id="construct_outcome_template_+3A_z">Z</code></td>
<td>
<p>A vector of treatment status.</p>
</td></tr>
<tr><td><code id="construct_outcome_template_+3A_dataset">dataset</code></td>
<td>
<p>The original dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of three objects: 1) feasible: 0/1 depending on the
feasibility of the matching problem; 2) match_treated: a data frame of the matched treated
units; 3) match_control: a data frame of the matched control units.
</p>

<hr>
<h2 id='create_list_from_mat'>Create a list representation of a distance matrix.</h2><span id='topic+create_list_from_mat'></span>

<h3>Description</h3>

<p>This function creates a &ldquo;list representation&rdquo;
of a treatment-by-control distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_list_from_mat(
  Z,
  dist_mat,
  p = NULL,
  caliper = NULL,
  k = NULL,
  penalty = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_list_from_mat_+3A_z">Z</code></td>
<td>
<p>A length (n = n_t + n_c) vector of treatment indicators.</p>
</td></tr>
<tr><td><code id="create_list_from_mat_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A treatment-by-control (n_t-by-n_c) distance matrix.</p>
</td></tr>
<tr><td><code id="create_list_from_mat_+3A_p">p</code></td>
<td>
<p>A vector of length (n_t + n_c) on which caliper applies (e.g. propensity scores)</p>
</td></tr>
<tr><td><code id="create_list_from_mat_+3A_caliper">caliper</code></td>
<td>
<p>Size of the caliper.</p>
</td></tr>
<tr><td><code id="create_list_from_mat_+3A_k">k</code></td>
<td>
<p>Connect each treated to the nearest k controls</p>
</td></tr>
<tr><td><code id="create_list_from_mat_+3A_penalty">penalty</code></td>
<td>
<p>Penalty for violating the caliper. Set to Inf by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a list representation of a treatment-by-control
network. The list representation can be made sparse using a user-specified
caliper. A list representation of a treatment-by-control distance matrix
consists of the following arguments:
</p>

<ul>
<li><p> start_n: a vector containing the node numbers of
the start nodes of each arc in the network.
</p>
</li>
<li><p> end_n: a vector containing the node numbers of
the end nodes of each arc in the network.
</p>
</li>
<li><p> d: a vector containing the integer cost of
each arc in the network.
</p>
</li></ul>

<p>Node 1,2,...,n_t are n_t treatment nodes; n_t + 1, n_t + 2, ..., n_t + n_c
are n_c control nodes. start_n, end_n, and d should have the same lengths,
all of which equal to the number of edges.
</p>
<p>There are two options for users to make a network sparse. Option caliper
is a value applied to the vector p to avoid connecting treated to controls
whose covariate or propensity score defined by p is outside p +/- caliper.
Second, within a specified caliper, sometimes there are still too many controls
connected to each treated, and we can further trim down this number up to k
by restricting our attention to the k nearest (in p) to each treated.
</p>
<p>By default a hard caliper is applied, i.e., option penalty is set to Inf by default.
Users may make the caliper a soft one by setting penalty to a large yet finite number.
</p>


<h3>Value</h3>

<p>This function returns a list that consists of three arguments: start_n, end_n, and d,
as described above.
</p>

<hr>
<h2 id='create_list_from_scratch'>Create a sparse list representation of treatment-to-control distance
matrix with a caliper.</h2><span id='topic+create_list_from_scratch'></span>

<h3>Description</h3>

<p>This function takes in a n-by-p matrix of observed covariates,
a length-n vector of treatment indicator, a caliper, and construct
a possibly sparse list representation of the distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_list_from_scratch(
  Z,
  X,
  exact = NULL,
  soft_exact = FALSE,
  p = NULL,
  caliper_low = NULL,
  caliper_high = NULL,
  k = NULL,
  alpha = 1,
  penalty = Inf,
  method = "maha",
  dist_func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_list_from_scratch_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_x">X</code></td>
<td>
<p>A n-by-p matrix of covariates.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_exact">exact</code></td>
<td>
<p>A vector of strings indicating which variables need to be exactly matched.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_soft_exact">soft_exact</code></td>
<td>
<p>If set to TRUE, the exact constraint is enforced up to a large penalty.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_p">p</code></td>
<td>
<p>A length-n vector on which a caliper applies, e.g. a vector of propensity score.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_caliper_low">caliper_low</code></td>
<td>
<p>Size of caliper low.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_caliper_high">caliper_high</code></td>
<td>
<p>Size of caliper high.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_k">k</code></td>
<td>
<p>Connect each treated to the nearest k controls. See details section.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_alpha">alpha</code></td>
<td>
<p>Tuning parameter.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_penalty">penalty</code></td>
<td>
<p>Penalty for violating the caliper. Set to Inf by default.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_method">method</code></td>
<td>
<p>Method used to compute treated-control distance</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_+3A_dist_func">dist_func</code></td>
<td>
<p>A user-specified function that compute treate-control distance. See
details section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, there are 4 methods implemented in this function: 'maha'
(Mahalanobis distance), robust maha' (robust Mahalanobis distance),
'0/1' (distance = 0 if and only if covariates are the same),
'Hamming' (Hamming distance).
</p>
<p>Users can also supply their own distance function by setting method = 'other' and
using the argument &ldquo;dist_func&rdquo;. &ldquo;dist_func&rdquo; is a user-supplied distance
function in the following format:
dist_func(controls, treated), where treated is a length-p vector
of covaraites and controls is a n_c-by-p matrix of covariates.
The output of function dist_func is a length-n_c vector of distance
between each control and the treated.
</p>
<p>There are two options for users to make a network sparse. Option caliper
is a value applied to the vector p to avoid connecting treated to controls
whose covariate or propensity score defined by p is outside p +/- caliper.
Second, within a specified caliper, sometimes there are still too many controls
connected to each treated, and we can further trim down this number up to k
by restricting our attention to the k nearest (in p) to each treated.
</p>
<p>By default a hard caliper is applied, i.e., option penalty is set to Inf by default.
Users may make the caliper a soft one by setting penalty to a large yet finite number.
</p>


<h3>Value</h3>

<p>This function returns a list of three objects: start_n, end_n, and d.
See documentation of function &ldquo;create_list_from_mat&rdquo; for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We first prepare the input X, Z, propensity score

attach(dt_Rouse)
X = cbind(female,black,bytest,dadeduc,momeduc,fincome)
Z = IV
propensity = glm(IV~female+black+bytest+dadeduc+momeduc+fincome,
                family=binomial)$fitted.values
detach(dt_Rouse)

# Create distance lists with built-in options.

# Mahalanobis distance with propensity score caliper = 0.05
# and k = 100.

dist_list_pscore_maha = create_list_from_scratch(Z, X, p = propensity,
                               caliper_low = 0.05, k = 100, method = 'maha')


# More examples, including how to use a user-supplied
# distance function, can be found in the vignette.

## End(Not run)
</code></pre>

<hr>
<h2 id='create_list_from_scratch_overall'>Create a sparse list representation of treated-to-control distance
matrix with a fixed number caliper with L1-distance.</h2><span id='topic+create_list_from_scratch_overall'></span>

<h3>Description</h3>

<p>This function takes in a n-by-p matrix of observed covariates,
a length-n vector of treatment indicator, a caliper, and construct
a possibly sparse list representation of the distance matrix with
Mahalanobis distance. Note that this function is of limited interest
to most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_list_from_scratch_overall(
  Z,
  X,
  exact = NULL,
  soft_exact = FALSE,
  p = NULL,
  caliper_low = NULL,
  caliper_high = NULL,
  k = NULL,
  penalty = Inf,
  dist_func = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_list_from_scratch_overall_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_x">X</code></td>
<td>
<p>A n-by-p matrix of covariates.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_exact">exact</code></td>
<td>
<p>A vector of strings indicating which variables are to be exactly matched.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_soft_exact">soft_exact</code></td>
<td>
<p>If set to TRUE, the exact constraint is enforced up to a large penalty.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_p">p</code></td>
<td>
<p>A length-n vector on which a caliper applies, e.g. a vector of propensity score.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_caliper_low">caliper_low</code></td>
<td>
<p>Size of caliper_inf.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_caliper_high">caliper_high</code></td>
<td>
<p>Size of caliper_sup.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_k">k</code></td>
<td>
<p>Connect each treated to the nearest k controls</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_penalty">penalty</code></td>
<td>
<p>Penalty for violating the caliper. Set to Inf by default.</p>
</td></tr>
<tr><td><code id="create_list_from_scratch_overall_+3A_dist_func">dist_func</code></td>
<td>
<p>A function used to calculate distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of three objects: start_n, end_n, and d.
See documentation of function &ldquo;create_list_from_mat&rdquo; for more details.
</p>

<hr>
<h2 id='dt_Rouse'>Rouse (1995) dataset</h2><span id='topic+dt_Rouse'></span>

<h3>Description</h3>

<p>Variables of the dataset is as follows:
</p>

<dl>
<dt>educ86</dt><dd><p>Years of education since 1986.</p>
</dd>
<dt>twoyr</dt><dd><p>Attending a two-year college immediately after high school.</p>
</dd>
<dt>female</dt><dd><p>Gender: 1 if female and 0 otherwise.</p>
</dd>
<dt>black</dt><dd><p>Race: 1 if African American and 0 otherwise.</p>
</dd>
<dt>hispanic</dt><dd><p>Race: 1 if Hispanic and 0 otherwise.</p>
</dd>
<dt>bytest</dt><dd><p>Test score.</p>
</dd>
<dt>fincome</dt><dd><p>Family income.</p>
</dd>
<dt>fincmiss</dt><dd><p>Missingness indicator for family income.</p>
</dd>
<dt>IV</dt><dd><p>Instrumental variable: encouagement to attend a two-year college.</p>
</dd>
<dt>dadeduc</dt><dd><p>Dad's education: College - 2; Some college - 1; Neither - 0.</p>
</dd>
<dt>momeduc</dt><dd><p>Mom's education: College - 2; Some college - 1; Neither - 0.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(dt_Rouse)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3037 rows, 8 observed variables, 1 binary instrumental variable,
1 treatment, and 1 continuous response.
</p>


<h3>Source</h3>

<p>ss
</p>

<hr>
<h2 id='force_control'>Force including certain controls in the final matched samples.</h2><span id='topic+force_control'></span>

<h3>Description</h3>

<p>This function processes the given distance list by adding certain zero-cost
edges so that the user-specified controls are forced into the final matched
samples. This function is of little interest to most users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>force_control(dist_list, Z, include)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="force_control_+3A_dist_list">dist_list</code></td>
<td>
<p>A distance_list object.</p>
</td></tr>
<tr><td><code id="force_control_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="force_control_+3A_include">include</code></td>
<td>
<p>A binary vector indicating which controls must be included (length(include) = sum(1-Z).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a distance list object with added edges.
</p>

<hr>
<h2 id='match_2C'>Optimal Matching with Two Criteria.</h2><span id='topic+match_2C'></span>

<h3>Description</h3>

<p>This function performs an optimal statistical matching that sequentially balances the nominal levels
(near-fine balance), the marginal distribution of the propensity score, and the total
within-matched-pair Mahalanobis distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_2C(
  Z,
  X,
  propensity,
  dataset,
  method = "maha",
  exact = NULL,
  caliper_left = 1,
  caliper_right = 1,
  k_left = NULL,
  k_right = NULL,
  fb_var = NULL,
  controls = 1,
  include = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_2C_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_x">X</code></td>
<td>
<p>A n-by-p matrix of covariates with column names.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_propensity">propensity</code></td>
<td>
<p>A vector of estimated propensity score (length(propensity) = length(Z)).</p>
</td></tr>
<tr><td><code id="match_2C_+3A_dataset">dataset</code></td>
<td>
<p>Dataset to be matched.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_method">method</code></td>
<td>
<p>Method used to compute treated-control distance on the left. The default is the Mahalanobis distance.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_exact">exact</code></td>
<td>
<p>A vector of strings indicating which variables need to be exactly matched.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_caliper_left">caliper_left</code></td>
<td>
<p>Size of caliper on the left network.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_caliper_right">caliper_right</code></td>
<td>
<p>Size of caliper on the right network.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_k_left">k_left</code></td>
<td>
<p>Connect each treated to k_left controls closest in the propensity score in the left network.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_k_right">k_right</code></td>
<td>
<p>Connect each treated to k_right controls closest in the propensity score in the right network.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_fb_var">fb_var</code></td>
<td>
<p>A vector giving names of variables in matrix X to be finely balanced.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated. Default is 1.</p>
</td></tr>
<tr><td><code id="match_2C_+3A_include">include</code></td>
<td>
<p>A binary vector indicating which controls must be included (length(include) = sum(1-Z)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of three objects including the feasibility
of the matching problem and the matched controls organized in different formats.
See the documentation of the function construct_outcome or the vignette for more
details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# We first prepare the input X, Z, propensity score

attach(dt_Rouse)
X = cbind(female,black,bytest,dadeduc,momeduc,fincome)
Z = IV
propensity = glm(IV~female+black+bytest+dadeduc+momeduc+fincome,
                family=binomial)$fitted.values
detach(dt_Rouse)

matching_output_double_calipers = match_2C(Z = Z, X = X,
propensity = propensity,
caliper_left = 0.05, caliper_right = 0.05,
k_left = 100, k_right = 100,
dataset = dt_Rouse)

# Please refer to the vignette for many more examples.


</code></pre>

<hr>
<h2 id='match_2C_list'>Perform a pair (or 1:k) matching with two user-specified list representations of
distance matrices.</h2><span id='topic+match_2C_list'></span>

<h3>Description</h3>

<p>This function performs a pair-matching using (at most) two user-specified distance
matrices in their (possibly sparse) list representations. For more details
on &ldquo;list representations&rdquo; of a treatment-by-control distance matrix, see
the documentation of the function &ldquo;create_list_from_mat&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_2C_list(
  Z,
  dataset,
  dist_list_1,
  dist_list_2 = NULL,
  lambda = 1000,
  controls = 1,
  overflow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_2C_list_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_dataset">dataset</code></td>
<td>
<p>dataset to be matched.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_dist_list_1">dist_list_1</code></td>
<td>
<p>A (possibly sparse) list representation of
treatment-by-control distance matrix.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_dist_list_2">dist_list_2</code></td>
<td>
<p>A second (possibly sparse) list representation of
treatment-by-control distance matrix.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_lambda">lambda</code></td>
<td>
<p>A penalty that does a trade-off between two parts of the network.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated. Default is set to 1.</p>
</td></tr>
<tr><td><code id="match_2C_list_+3A_overflow">overflow</code></td>
<td>
<p>A logical value indicating if overflow protection is turned on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed for more experienced and sophisticated R users.
Instead of providing possibly dense treatment-by-control distance matrices
that take up a lot of memories, users may simply provide two lists that specifies
information of edges: their starting points, ending points, capacity, and cost.
For more information on list representations of a distance matrix, see the
documentation of the function &ldquo;create_list_from_mat&rdquo; and &ldquo;create_list_from_scratch&rdquo;.
Note that by setting dist_list_2 = NULL, the usual matching framework is restored.
</p>


<h3>Value</h3>

<p>This function returns the same object as function match_2C_mat.
</p>

<hr>
<h2 id='match_2C_mat'>Perform a pair matching using two user-specified distance matrices.</h2><span id='topic+match_2C_mat'></span>

<h3>Description</h3>

<p>This function performs a pair-matching using two user-specified distance
matrices and two calipers. Typically one distance matrix is used to
minimize matched-pair differences, and a second distance matrix is used
to enforce constraints on marginal distributions of certain variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_2C_mat(
  Z,
  dataset,
  dist_mat_1,
  dist_mat_2,
  lambda,
  controls = 1,
  p_1 = NULL,
  caliper_1 = NULL,
  k_1 = NULL,
  p_2 = NULL,
  caliper_2 = NULL,
  k_2 = NULL,
  penalty = Inf,
  overflow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_2C_mat_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_dataset">dataset</code></td>
<td>
<p>The original dataset.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_dist_mat_1">dist_mat_1</code></td>
<td>
<p>A user-specified treatment-by-control (n_t-by-n_c) distance matrix.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_dist_mat_2">dist_mat_2</code></td>
<td>
<p>A second user-specified treatment-by-control (n_t-by-n_c) distance matrix.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_lambda">lambda</code></td>
<td>
<p>A penalty that controls the trade-off between two parts of the network.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_p_1">p_1</code></td>
<td>
<p>A length-n vector on which caliper_1 applies, e.g. a vector of propensity score.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_caliper_1">caliper_1</code></td>
<td>
<p>Size of caliper_1.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_k_1">k_1</code></td>
<td>
<p>Maximum number of controls each treated is connected to in the first network.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_p_2">p_2</code></td>
<td>
<p>A length-n vector on which caliper_2 applies, e.g. a vector of propensity score.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_caliper_2">caliper_2</code></td>
<td>
<p>Size of caliper_2.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_k_2">k_2</code></td>
<td>
<p>Maximum number of controls each treated is connected to in the second network.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_penalty">penalty</code></td>
<td>
<p>Penalty for violating the caliper. Set to Inf by default.</p>
</td></tr>
<tr><td><code id="match_2C_mat_+3A_overflow">overflow</code></td>
<td>
<p>A logical value indicating if overflow protection is turned on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a pair matching via a two-part network.
The first part is a network whose treatment-to-control distance
matrix is supplied by dist_mat_1. The second part of the
network is constructed using distance matrix specified by dist_mat_2. Often,
the first part of the network is used to minimize total treated-to-control matched pair
distances, and the second part is used to enforce certain marginal constraints.
</p>
<p>The function constructs two list representations of distance matrices, possibly
using the caliper. caliper_1 is applied to p_1 (caliper_2 applied to p_2) in order to
construct sparse list representations. For instance, a caliper equal to 0.2 (caliper_1 = 0.2)
applied to the propensity score (p_1).
</p>
<p>lambda is a penalty, or a tuning parameter, that balances these two objectives. When lambda is
very large, the network will first minimize the second part of network and then the first part.
</p>


<h3>Value</h3>

<p>This function returns a list of three objects including the feasibility
of the matching problem and the matched controls organized in different formats.
See the documentation of the function construct_outcome or the tutorial for more
details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
To run the following code, one needs to first install
and load the package optmatch.

# We first prepare the input X, Z, propensity score

#attach(dt_Rouse)
#X = cbind(female,black,bytest,dadeduc,momeduc,fincome)
#Z = IV
#propensity = glm(IV~female+black+bytest+dadeduc+momeduc+fincome,
#family=binomial)$fitted.values
#n_t = sum(Z)
#n_c = length(Z) - n_t
#dt_Rouse$propensity = propensity
#detach(dt_Rouse)

# Next, we use the match_on function in optmatch
to create two treated-by-control distance matrices.

#library(optmatch)
# dist_mat_1 = match_on(IV~female+black+bytest+dadeduc+momeduc+fincome,
# method = 'mahalanobis', data = dt_Rouse)

# dist_mat_2 = match_on(IV ~ female, method = 'euclidean', data = dt_Rouse)


# Feed two distance matrices to the function match_2C_mat without caliper
# and a large penalty lambda to enforce (near-)fine balance.

#matching_output = match_2C_mat(Z, dt_Rouse, dist_mat_1, dist_mat_2,
#                               lambda = 10000, p_1 = NULL, p_2 = NULL)

# For more examples, please consult the RMarkdown tutorial.

## End(Not run)


</code></pre>

<hr>
<h2 id='NewPackage-package'>
A short title line describing what the package does
</h2><span id='topic+NewPackage-package'></span><span id='topic+NewPackage'></span>

<h3>Description</h3>

<p>A more detailed description of what the package does. A length
of about one to five lines is recommended.
</p>


<h3>Details</h3>

<p>This section should provide a more detailed overview of how to use the
package, including the most important functions.
</p>


<h3>Author(s)</h3>

<p>Your Name, email optional.
</p>
<p>Maintainer: Your Name &lt;your@email.com&gt;
</p>


<h3>References</h3>

<p>This optional section can contain literature or other references for
background information.
</p>


<h3>See Also</h3>

<p>Optional links to other man pages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
     ## Optional simple examples of the most important functions
     ## These can be in \dontrun{} and \donttest{} blocks.   
  
## End(Not run)
</code></pre>

<hr>
<h2 id='revert_dist_list_cpp'>Revert a treated-to-control distance list.</h2><span id='topic+revert_dist_list_cpp'></span>

<h3>Description</h3>

<p>Revert a treated-to-control distance list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revert_dist_list_cpp(n_t, n_c, startn, endn, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revert_dist_list_cpp_+3A_n_t">n_t</code></td>
<td>
<p>Number of treated units</p>
</td></tr>
<tr><td><code id="revert_dist_list_cpp_+3A_n_c">n_c</code></td>
<td>
<p>Number of control units</p>
</td></tr>
<tr><td><code id="revert_dist_list_cpp_+3A_startn">startn</code></td>
<td>
<p>Vector of starting nodes of edges</p>
</td></tr>
<tr><td><code id="revert_dist_list_cpp_+3A_endn">endn</code></td>
<td>
<p>Vector of ending nodes of edges</p>
</td></tr>
<tr><td><code id="revert_dist_list_cpp_+3A_d">d</code></td>
<td>
<p>Vector of cost associated with edges</p>
</td></tr>
</table>

<hr>
<h2 id='solve_network_flow'>Solve a network flow problem.</h2><span id='topic+solve_network_flow'></span>

<h3>Description</h3>

<p>This function solves network flow optimization problems
by calling the RELAX-IV algorithm implemented in FORTRAN
by Dimitri Bertsekas and Paul Tseng, and made available by
Sam Pimentel in the package rcbalance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_network_flow(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_network_flow_+3A_net">net</code></td>
<td>
<p>A list of five vectors: startn, endn, ucap, cost, b.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is of limited interest to users.
</p>


<h3>Value</h3>

<p>If the problem is feasible, function returns a list with the following elements:
crash: an integer, equal to zero if the algorithm ran correctly and equal to 1 if it crashed.
feasible: an integer, equal to zero if the problem is not feasible.
x: a vector equal in length to the number of arcs in argument problem net,
giving in each coordinate the number of units of flow passing across the
corresponding edge in the optimal network flow.
If the problem is not feasible, it returns &quot;Not feasible.&quot;
</p>

<hr>
<h2 id='stitch_two_nets'>Stitch two treated-to-control networks into one two-part networks.</h2><span id='topic+stitch_two_nets'></span>

<h3>Description</h3>

<p>This function takes as inputs two networks and one penalty lambda,
and constructs one two-part network out of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch_two_nets(net1, net2, lambda, controls = 1, overflow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitch_two_nets_+3A_net1">net1</code></td>
<td>
<p>A list of five vectors: startn, endn, ucap, cost, b.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_+3A_net2">net2</code></td>
<td>
<p>A list of five vectors: startn, endn, ucap, cost, b.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_+3A_lambda">lambda</code></td>
<td>
<p>A penalty.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_+3A_overflow">overflow</code></td>
<td>
<p>A logical value indicating if overflow protection is turned on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is of limited interest to users. Once overflow is set to
TRUE, each cotnrol in the first network will be directly connected to
the sink at a large cost, so that the network flow problem is feasible
as long as the first part is feasible.
</p>


<h3>Value</h3>

<p>This function returns a list of five vectors:
startn, endn, ucap, cost, b.
</p>

<hr>
<h2 id='stitch_two_nets_template'>Stitch a template-to-treated network and a treated-to-control network
into one two-part network.</h2><span id='topic+stitch_two_nets_template'></span>

<h3>Description</h3>

<p>This function takes as inputs a template-to-treated network,
one treated-to-control network, a tuning parameter lambda,
and number of controls, and constructs one two-part network out of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch_two_nets_template(net1, net2, n_c, lambda, multiple = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitch_two_nets_template_+3A_net1">net1</code></td>
<td>
<p>A list of five vectors: startn, endn, ucap, cost, b.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_template_+3A_net2">net2</code></td>
<td>
<p>A list of five vectors: startn, endn, ucap, cost, b.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_template_+3A_n_c">n_c</code></td>
<td>
<p>Number of control units.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_template_+3A_lambda">lambda</code></td>
<td>
<p>A penalty.</p>
</td></tr>
<tr><td><code id="stitch_two_nets_template_+3A_multiple">multiple</code></td>
<td>
<p>Number of treated units matched to each unit in the template</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is of limited interest to users. Parameter lambda is a
weight given to the first part of the network, and a large lambda value
emphasizes resemblance to the template. Parameter multiple could be taken
as any integer number between 1 and floor(treated size / template size).
</p>


<h3>Value</h3>

<p>This function returns a list of five vectors:
startn, endn, ucap, cost, b.
</p>

<hr>
<h2 id='template_match'>Optimal Matching with Two Criteria.</h2><span id='topic+template_match'></span>

<h3>Description</h3>

<p>This function takes as arguments a dataset to be matched and a template, and
outputs matched pairs that are closely matched, well balanced, and mimicking
the user-supplied template in covariates' distributions of the given template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>template_match(
  template,
  X,
  Z,
  dataset,
  multiple = 1,
  lambda = 1,
  caliper_gscore = 1,
  k_gscore = NULL,
  penalty_gscore = Inf,
  caliper_pscore = 1,
  k_pscore = NULL,
  penalty_pscore = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="template_match_+3A_template">template</code></td>
<td>
<p>A dataframe of template units.</p>
</td></tr>
<tr><td><code id="template_match_+3A_x">X</code></td>
<td>
<p>A n-by-p matrix of covariates with column names.</p>
</td></tr>
<tr><td><code id="template_match_+3A_z">Z</code></td>
<td>
<p>A length-n vector of treatment indicator.</p>
</td></tr>
<tr><td><code id="template_match_+3A_dataset">dataset</code></td>
<td>
<p>Dataset to be matched.</p>
</td></tr>
<tr><td><code id="template_match_+3A_multiple">multiple</code></td>
<td>
<p>Number of treated units matched to each template unit. Default is 1.</p>
</td></tr>
<tr><td><code id="template_match_+3A_lambda">lambda</code></td>
<td>
<p>A tuning parameter controlling the trade-off between internal and external validity. A large lambda favors internal validity of the matched sample. A small lambda favors resemblance to the template.</p>
</td></tr>
<tr><td><code id="template_match_+3A_caliper_gscore">caliper_gscore</code></td>
<td>
<p>Size of generalizability caliper.</p>
</td></tr>
<tr><td><code id="template_match_+3A_k_gscore">k_gscore</code></td>
<td>
<p>Connect each template unit to k_gscore treated units closest in the generalizability score.</p>
</td></tr>
<tr><td><code id="template_match_+3A_penalty_gscore">penalty_gscore</code></td>
<td>
<p>Penalty for violating the generalizability caliper. Set to Inf by default.</p>
</td></tr>
<tr><td><code id="template_match_+3A_caliper_pscore">caliper_pscore</code></td>
<td>
<p>Size of propensity score caliper.</p>
</td></tr>
<tr><td><code id="template_match_+3A_k_pscore">k_pscore</code></td>
<td>
<p>Connect each treated to k_pscore control units closest in the propensity score.</p>
</td></tr>
<tr><td><code id="template_match_+3A_penalty_pscore">penalty_pscore</code></td>
<td>
<p>Penalty for violating the propensity score caliper. Set to Inf by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to the vignette for reproducible examples.
</p>


<h3>Value</h3>

<p>This function returns a list of three objects: 1) feasible: 0/1 depending on the
feasibility of the matching problem; 2) match_treated: a data frame of the matched treated
units; 3) match_control: a data frame of the matched control units.
</p>

<hr>
<h2 id='treated_control_net'>Create a treate-to-control network to be solved via a network flow algorithm.</h2><span id='topic+treated_control_net'></span>

<h3>Description</h3>

<p>This function takes in a list representation of distance matrix
and create a network structure to be solved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treated_control_net(n_t, n_c, dist_list, controls = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treated_control_net_+3A_n_t">n_t</code></td>
<td>
<p>Number of treated subjects.</p>
</td></tr>
<tr><td><code id="treated_control_net_+3A_n_c">n_c</code></td>
<td>
<p>Number of controls.</p>
</td></tr>
<tr><td><code id="treated_control_net_+3A_dist_list">dist_list</code></td>
<td>
<p>A list representation of the distance matrix.</p>
</td></tr>
<tr><td><code id="treated_control_net_+3A_controls">controls</code></td>
<td>
<p>Number of controls matched to each treated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dist_list is a list consisting of the following three elements:
start_n:  the starting nodes for all edges,
end_n:    the ending nodes for all edges,
d: distance of all treated-control edges.
Function create_dist_list in this package constructs
such a list representation given a user-specified distance function.
</p>


<h3>Value</h3>

<p>This function returns a list of five vectors:
startn, endn, ucap, cost, b.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
