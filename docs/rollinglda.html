<!DOCTYPE html><html><head><title>Help for package rollinglda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rollinglda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rollinglda-package'><p>rollinglda: Construct Consistent Time Series from Textual Data</p></a></li>
<li><a href='#as.RollingLDA'><p>RollingLDA Object</p></a></li>
<li><a href='#economy'><p>A Snippet of the Economy Dataset from toscaData</p></a></li>
<li><a href='#getChunks'><p>Getter for RollingLDA</p></a></li>
<li><a href='#RollingLDA'><p>RollingLDA</p></a></li>
<li><a href='#updateRollingLDA'><p>Updating an existing RollingLDA object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construct Consistent Time Series from Textual Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Description:</td>
<td>A rolling version of the Latent Dirichlet Allocation, see Rieger et al. (2021) &lt;<a href="https://doi.org/10.18653%2Fv1%2F2021.findings-emnlp.201">doi:10.18653/v1/2021.findings-emnlp.201</a>&gt;. By a sequential approach, it enables the construction of LDA-based time series of topics that are consistent with previous states of LDA models. After an initial modeling, updates can be computed efficiently, allowing for real-time monitoring and detection of events or structural breaks.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JonasRieger/rollinglda">https://github.com/JonasRieger/rollinglda</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JonasRieger/rollinglda/issues">https://github.com/JonasRieger/rollinglda/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ldaPrototype (&ge; 0.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.8.5), data.table (&ge; 1.11.2), lubridate,
stats, tosca (&ge; 0.2-0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 12:26:31 UTC; riege</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Rieger <a href="https://orcid.org/0000-0002-0007-4478"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Rieger &lt;jonas.rieger@tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 07:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='rollinglda-package'>rollinglda: Construct Consistent Time Series from Textual Data</h2><span id='topic+rollinglda'></span><span id='topic+rollinglda-package'></span>

<h3>Description</h3>

<p>RollingLDA is a rolling version of the Latent Dirichlet
Allocation (LDA). By a sequential approach, it enables the construction of
LDA-based time series of topics that are consistent with previous states of
LDA models. After an initial modeling, updates can be computed efficiently,
allowing for real-time monitoring and detection of events or structural breaks.<br />
For bug reports and feature requests please use the issue tracker:
<a href="https://github.com/JonasRieger/rollinglda/issues">https://github.com/JonasRieger/rollinglda/issues</a>. Also have a look at
the (detailed) example at <a href="https://github.com/JonasRieger/rollinglda">https://github.com/JonasRieger/rollinglda</a>.
</p>


<h3>Data</h3>

<p><code><a href="#topic+economy">economy</a></code> Example Dataset (576 articles from Wikinews) for testing.
</p>


<h3>Constructor</h3>

<p><code><a href="#topic+as.RollingLDA">as.RollingLDA</a></code> RollingLDA objects used in this package.
</p>


<h3>Getter</h3>

<p><code><a href="#topic+getChunks">getChunks</a></code> Getter for <code><a href="#topic+as.RollingLDA">RollingLDA</a></code> objects.
</p>


<h3>Modeling</h3>

<p><code><a href="#topic+RollingLDA">RollingLDA</a></code> Performing the method from scratch.<br />
<code><a href="#topic+updateRollingLDA">updateRollingLDA</a></code> Performing updates on <code><a href="#topic+as.RollingLDA">RollingLDA</a></code> objects.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jonas Rieger <a href="mailto:jonas.rieger@tu-dortmund.de">jonas.rieger@tu-dortmund.de</a> (<a href="https://orcid.org/0000-0002-0007-4478">ORCID</a>)
</p>


<h3>References</h3>

<p>Rieger, Jonas, Carsten Jentsch and Jörg Rahnenführer (2021).
&quot;RollingLDA: An Update Algorithm of Latent Dirichlet Allocation to Construct
Consistent Time Series from Textual Data&quot;. <em>EMNLP Findings 2021</em>.
URL <a href="https://doi.org/10.18653/v1/2021.findings-emnlp.201">doi:10.18653/v1/2021.findings-emnlp.201</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/JonasRieger/rollinglda">https://github.com/JonasRieger/rollinglda</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/JonasRieger/rollinglda/issues">https://github.com/JonasRieger/rollinglda/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.RollingLDA'>RollingLDA Object</h2><span id='topic+as.RollingLDA'></span><span id='topic+is.RollingLDA'></span>

<h3>Description</h3>

<p>Constructor for RollingLDA objects used in this package.
The function may be useful to create a RollingLDA object out of a standard
<code><a href="ldaPrototype.html#topic+LDA">LDA</a></code> object to use it as initial model and
update it using <code><a href="#topic+updateRollingLDA">updateRollingLDA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.RollingLDA(x, id, lda, docs, dates, vocab, chunks, param)

is.RollingLDA(obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.RollingLDA_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+RollingLDA">RollingLDA</a></code> object. Alternatively each element can be passed for
individual results. Individually set elements overwrite elements from <code>x</code>.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the computation/model.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_lda">lda</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="ldaPrototype.html#topic+LDA">LDA</a></code> object.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_docs">docs</code></td>
<td>
<p>[<code>named list</code>]<br />
Texts in a preprocessed format. See <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_dates">dates</code></td>
<td>
<p>[<code>(un)named Date</code>]<br />
Dates of the texts. If unnamed, it must match the order of docs.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_vocab">vocab</code></td>
<td>
<p>[<code>character</code>]<br />
Vocabularies.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_chunks">chunks</code></td>
<td>
<p>[<code>data.table</code>]<br />
with specifications for each model chunk
</p>

<dl>
<dt><code>chunk.id</code></dt><dd><p>[<code>integer</code>] Index counting up starting with <code>0</code>.</p>
</dd>
<dt><code>start.date</code></dt><dd><p>[<code>Date</code>] Minimum of each chunk's dates.</p>
</dd>
<dt><code>end.date</code></dt><dd><p>[<code>Date</code>] Maximum of each chunk's dates.</p>
</dd>
<dt><code>memory</code></dt><dd><p>[<code>Date</code>] Date from which texts are considered as memory.</p>
</dd>
<dt><code>n</code></dt><dd><p>[<code>integer</code>] Number of fitted texts.</p>
</dd>
<dt><code>n.dicsarded</code></dt><dd><p>[<code>integer</code>] Number of lost texts through preprocessing.</p>
</dd>
<dt><code>n.memory</code></dt><dd><p>[<code>integer</code>] Number of texts considered as memory.</p>
</dd>
<dt><code>n.vocab</code></dt><dd><p>[<code>integer</code>] Number of vocabularies (monotonously increasing).</p>
</dd>
</dl>

<p>If not passed, <code>lda</code> is interpreted as initialization chunk.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_param">param</code></td>
<td>
<p>[<code>named list(4)</code>]<br />
Parameters of the object, i.e. parameters for future updates fitted on the
to be created model. List always should contain names &quot;vocab.abs&quot;, &quot;vocab.rel&quot;,
&quot;vocab.fallback&quot; and &quot;doc.abs&quot;.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_obj">obj</code></td>
<td>
<p>[<code>R</code> object]<br />
Object to test.</p>
</td></tr>
<tr><td><code id="as.RollingLDA_+3A_verbose">verbose</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should test information be given in the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you call <code>as.RollingLDA</code> on an object <code>x</code> which already is of
the structure of an <code>RollingLDA</code> object (in particular a <code>RollingLDA</code>
object itself), the additional arguments <code>id, param, ...</code>
may be used to override the specific elements.
</p>


<h3>Value</h3>

<p>[<code>named list</code>] <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
</p>


<h3>See Also</h3>

<p>Other RollingLDA functions: 
<code><a href="#topic+RollingLDA">RollingLDA</a>()</code>,
<code><a href="#topic+getChunks">getChunks</a>()</code>,
<code><a href="#topic+updateRollingLDA">updateRollingLDA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roll_lda = RollingLDA(texts = economy_texts,
                      dates = economy_dates,
                      chunks = "quarter",
                      memory = "3 quarter",
                      init = "2008-07-03",
                      K = 10,
                      type = "lda")

is.RollingLDA(roll_lda, verbose = TRUE)
getID(roll_lda)
roll_lda = as.RollingLDA(roll_lda, id = "newID")
getID(roll_lda)

</code></pre>

<hr>
<h2 id='economy'>A Snippet of the Economy Dataset from toscaData</h2><span id='topic+economy'></span><span id='topic+economy_texts'></span><span id='topic+economy_dates'></span><span id='topic+texts'></span><span id='topic+dates'></span>

<h3>Description</h3>

<p>Example Dataset from Wikinews consisting of 576 articles. It can be used to
familiarize with the functions offered by this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(economy_texts)

data(economy_dates)
</code></pre>


<h3>Format</h3>

<p><code>economy_texts</code> is a named list of tokenized texts of length 576.
</p>
<p><code>economy_dates</code> is
</p>
<p>An object of class <code>Date</code> of length 576.
</p>


<h3>Source</h3>

<p><a href="https://github.com/Docma-TU/toscaData">https://github.com/Docma-TU/toscaData</a>
</p>

<hr>
<h2 id='getChunks'>Getter for RollingLDA</h2><span id='topic+getChunks'></span><span id='topic+getNames'></span><span id='topic+getDates'></span><span id='topic+getDocs'></span><span id='topic+getVocab'></span><span id='topic+getLDA.RollingLDA'></span><span id='topic+getID.RollingLDA'></span><span id='topic+getParam.RollingLDA'></span>

<h3>Description</h3>

<p>Returns the corresponding element of a <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChunks(x)

getNames(x)

getDates(x, names, inverse)

getDocs(x, names, inverse)

getVocab(x)

## S3 method for class 'RollingLDA'
getLDA(x, job, reduce, all)

## S3 method for class 'RollingLDA'
getID(x)

## S3 method for class 'RollingLDA'
getParam(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChunks_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+RollingLDA">RollingLDA</a></code> object.</p>
</td></tr>
<tr><td><code id="getChunks_+3A_names">names</code></td>
<td>
<p>[<code>character</code>]<br />
Names of the requested items (dates or docs). Default are all names.</p>
</td></tr>
<tr><td><code id="getChunks_+3A_inverse">inverse</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should all items except those with the given names be returned? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getChunks_+3A_job">job</code></td>
<td>
<p>not implemented for <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
See <code><a href="ldaPrototype.html#topic+getSCLOP">getLDA</a></code></p>
</td></tr>
<tr><td><code id="getChunks_+3A_reduce">reduce</code></td>
<td>
<p>not implemented for <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
See <code><a href="ldaPrototype.html#topic+getSCLOP">getLDA</a></code></p>
</td></tr>
<tr><td><code id="getChunks_+3A_all">all</code></td>
<td>
<p>not implemented for <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
See <code><a href="ldaPrototype.html#topic+getSCLOP">getLDA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The requested element of a <code><a href="#topic+RollingLDA">RollingLDA</a></code> object.
</p>


<h3>See Also</h3>

<p>Other RollingLDA functions: 
<code><a href="#topic+RollingLDA">RollingLDA</a>()</code>,
<code><a href="#topic+as.RollingLDA">as.RollingLDA</a>()</code>,
<code><a href="#topic+updateRollingLDA">updateRollingLDA</a>()</code>
</p>

<hr>
<h2 id='RollingLDA'>RollingLDA</h2><span id='topic+RollingLDA'></span><span id='topic+RollingLDA.default'></span>

<h3>Description</h3>

<p>Performs a rolling version of Latent Dirichlet Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RollingLDA(...)

## Default S3 method:
RollingLDA(
  texts,
  dates,
  chunks,
  memory,
  vocab.abs = 5L,
  vocab.rel = 0,
  vocab.fallback = 100L,
  doc.abs = 0L,
  memory.fallback = 0L,
  init,
  type = c("ldaprototype", "lda"),
  id,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RollingLDA_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="ldaPrototype.html#topic+LDARep">LDARep</a></code>
or <code><a href="ldaPrototype.html#topic+LDAPrototype">LDAPrototype</a></code>, respectively.
Default parameters are <code>alpha = eta = 1/K</code> and <code>num.iterations = 200</code>.
There is no default for <code>K</code>.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_texts">texts</code></td>
<td>
<p>[<code>named list</code>]<br />
Tokenized texts.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_dates">dates</code></td>
<td>
<p>[<code>(un)named Date</code>]<br />
Dates of the tokenized texts. If unnamed, it must match the order of texts.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_chunks">chunks</code></td>
<td>
<p>[<code>Date</code> or <code>character(1)</code>]<br />
Sorted dates of the beginnings of each chunk to be modeled after the initial model.
If passed as <code>character</code>, dates are determined by passing <code>init</code>
plus one day as <code>from</code> argument, <code>max(dates)</code> as <code>to</code> argument
and <code>chunks</code> as <code>by</code> argument in <code><a href="base.html#topic+seq.Date">seq.Date</a></code>.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_memory">memory</code></td>
<td>
<p>[<code>Date</code>, <code>character(1)</code> or <code>integer(1)</code>]<br />
Sorted dates of the beginnings of each chunk's memory. If passed as <code>character</code>,
dates are determined by using the dates of the beginnings of each chunk and
substracting the given time interval in <code>memory</code> passing it as
<code>by</code> argument in <code><a href="base.html#topic+seq.Date">seq.Date</a></code>. If passed as
<code>integer/numeric</code>, the dates are determined by going backwards the
modeled texts chronologically and taking the date of the text at position
<code>memory</code>.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_vocab.abs">vocab.abs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.abs</code> over all texts and at the same time a higher relative
frequency than <code>vocab.rel</code>. Default is 5.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_vocab.rel">vocab.rel</code></td>
<td>
<p>[0,1]<br />
A relative lower bound limit for which words are taken into account. See also
<code>vocab.abs</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_vocab.fallback">vocab.fallback</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.fallback</code> over all texts even if they might not have a higher
relative frequency than <code>vocab.rel</code>. Default is 100.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_doc.abs">doc.abs</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
An absolute lower bound limit for which texts are taken into account. All
texts are considered for modeling that have more words (subsetted to words
occurring in the vocabularies) than <code>doc.abs</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_memory.fallback">memory.fallback</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
If there are no texts as memory in a certain chunk, <code>memory</code> is
determined by going backwards the modeled texts chronologically and taking
the date of the text at position <code>memory.fallback</code>.
Default is 0, which means &quot;end the fitting&quot;.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_init">init</code></td>
<td>
<p>[<code>Date(1)</code> or <code>integer(1)</code>]<br />
Date up to which the initial model should be computed. This parameter is
needed/used only if <code>chunks</code> is passed as <code>character</code>. Otherwise
the initial model is computed up to the first date in <code>chunks</code> minus one
day. If <code>init</code> is passed as <code>integer/numeric</code>, the <code>init</code>
lowest date from <code>dates</code> is selected.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
One of &quot;ldaPrototype&quot; or &quot;lda&quot; specifying whether a LDAProtoype or standard
LDA should be modeled as initial model. Default is &quot;ldaprototype&quot;.</p>
</td></tr>
<tr><td><code id="RollingLDA_+3A_id">id</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name for the computation/model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first computes a initial LDA model (using
<code><a href="ldaPrototype.html#topic+LDARep">LDARep</a></code> or <code><a href="ldaPrototype.html#topic+LDAPrototype">LDAPrototype</a></code>).
Afterwards it models temporal chunks of texts with a specified memory for
initialization of each model chunk.
</p>
<p>The function returns a <code>RollingLDA</code> object. You can receive results and
all other elements of this object with getter functions (see <code><a href="#topic+getChunks">getChunks</a></code>).
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>id</code></dt><dd><p>[<code>character(1)</code>] See above.</p>
</dd>
<dt><code>lda</code></dt><dd><p><code><a href="ldaPrototype.html#topic+LDA">LDA</a></code> object of the fitted RollingLDA.</p>
</dd>
<dt><code>docs</code></dt><dd><p>[<code>named list</code>] with modeled texts in a preprocessed format.
See <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code>.</p>
</dd>
<dt><code>dates</code></dt><dd><p>[<code>named Date</code>] with dates of the modeled texts.</p>
</dd>
<dt><code>vocab</code></dt><dd><p>[<code>character</code>] with the vocabularies considered
for modeling.</p>
</dd>
<dt><code>chunks</code></dt><dd><p>[<code>data.table</code>] with specifications for each
model chunk.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>vocab.abs</code> [<code>integer(1)</code>], <code>vocab.rel</code> [0,1],
<code>vocab.fallback</code> [<code>integer(1)</code>] and
<code>doc.abs</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other RollingLDA functions: 
<code><a href="#topic+as.RollingLDA">as.RollingLDA</a>()</code>,
<code><a href="#topic+getChunks">getChunks</a>()</code>,
<code><a href="#topic+updateRollingLDA">updateRollingLDA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>roll_lda = RollingLDA(texts = economy_texts,
                      dates = economy_dates,
                      chunks = "quarter",
                      memory = "3 quarter",
                      init = "2008-07-03",
                      K = 10,
                      type = "lda")

roll_lda
getChunks(roll_lda)
getLDA(roll_lda)


roll_proto = RollingLDA(texts = economy_texts,
                        dates = economy_dates,
                        chunks = "quarter",
                        memory = "3 quarter",
                        init = "2007-07-03",
                        K = 10,
                        n = 12,
                        pm.backend = "socket",
                        ncpus = 2)

roll_proto
getChunks(roll_proto)
getLDA(roll_proto)


</code></pre>

<hr>
<h2 id='updateRollingLDA'>Updating an existing RollingLDA object</h2><span id='topic+updateRollingLDA'></span><span id='topic+RollingLDA.RollingLDA'></span>

<h3>Description</h3>

<p>Performs an update of an existing object consisting of a rolling version
of Latent Dirichlet Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateRollingLDA(
  x,
  texts,
  dates,
  chunks,
  memory,
  param = getParam(x),
  compute.topics = TRUE,
  memory.fallback = 0L,
  ...
)

## S3 method for class 'RollingLDA'
RollingLDA(
  x,
  texts,
  dates,
  chunks,
  memory,
  param = getParam(x),
  compute.topics = TRUE,
  memory.fallback = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateRollingLDA_+3A_x">x</code></td>
<td>
<p>[<code>named list</code>]<br />
<code><a href="#topic+RollingLDA">RollingLDA</a></code> object.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_texts">texts</code></td>
<td>
<p>[<code>named list</code>]<br />
Tokenized texts.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_dates">dates</code></td>
<td>
<p>[<code>(un)named Date</code>]<br />
Sorted dates of the tokenized texts. If unnamed, it must match the order of texts.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_chunks">chunks</code></td>
<td>
<p>[<code>Date</code> or <code>character(1)</code>]<br />
Sorted dates of the beginnings of each chunk to be modeled as updates.
If passed as <code>character</code>, dates are determined by passing the minimum of
<code>dates</code> as <code>from</code> argument, <code>max(dates)</code> as <code>to</code> argument
and <code>chunks</code> as <code>by</code> argument in <code><a href="base.html#topic+seq.Date">seq.Date</a></code>.
If not passed, all texts are interpreted as one chunk.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_memory">memory</code></td>
<td>
<p>[<code>Date</code>, <code>character(1)</code> or <code>integer(1)</code>]<br />
Dates of the beginnings of each chunk's memory. If passed as <code>character</code>,
dates are determined by using the dates of the beginnings of each chunk and
substracting the given time interval in <code>memory</code> passing it as
<code>by</code> argument in <code><a href="base.html#topic+seq.Date">seq.Date</a></code>. If passed as
<code>integer/numeric</code>, the dates are determined by going backwards the
modeled texts chronologically and taking the date of the text at position
<code>memory</code>.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_param">param</code></td>
<td>
<p>[<code>named list</code>] with entries (Default is <code>getParam(x)</code>)
</p>

<dl>
<dt><code>vocab.abs</code></dt><dd><p>[<code>integer(1)</code>]
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.abs</code> over all texts and at the same time a higher relative
frequency than <code>vocab.rel</code>.</p>
</dd>
<dt><code>vocab.rel</code></dt><dd><p>[0,1]
A relative lower bound limit for which words are taken into account.
See also <code>vocab.abs</code>.</p>
</dd>
<dt><code>vocab.fallback</code></dt><dd><p>[<code>integer(1)</code>]
An absolute lower bound limit for which words are taken into account. All
words are considered in the vocabularies that have a count higher than
<code>vocab.fallback</code> over all texts even if they might not have a higher
relative frequency than <code>vocab.rel</code>.</p>
</dd>
<dt><code>doc.abs</code></dt><dd><p>[<code>integer(1)</code>]
An absolute lower bound limit for which texts are taken into account. All
texts are considered for modeling that have more words (subsetted to words
occurring in the vocabularies) than <code>doc.abs</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_compute.topics">compute.topics</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the topic matrix of the LDA model be computed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_memory.fallback">memory.fallback</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
If there are no texts as memory in a certain chunk, <code>memory</code> is
determined by going backwards the modeled texts chronologically and taking
the date of the text at position <code>memory.fallback</code>.
Default is 0, which means &quot;end the fitting&quot;.</p>
</td></tr>
<tr><td><code id="updateRollingLDA_+3A_...">...</code></td>
<td>
<p>not implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses an existing <code><a href="#topic+RollingLDA">RollingLDA</a></code> object and
models new texts with a specified memory as initialization of the new LDA chunk.
</p>
<p>The function returns a <code><a href="#topic+RollingLDA">RollingLDA</a></code> object. You can receive results and
all other elements of this object with getter functions (see <code><a href="#topic+getChunks">getChunks</a></code>).
</p>


<h3>Value</h3>

<p>[<code>named list</code>] with entries
</p>

<dl>
<dt><code>id</code></dt><dd><p>[<code>character(1)</code>] See above.</p>
</dd>
<dt><code>lda</code></dt><dd><p><code><a href="ldaPrototype.html#topic+LDA">LDA</a></code> object of the fitted RollingLDA.</p>
</dd>
<dt><code>docs</code></dt><dd><p>[<code>named list</code>] with modeled texts in a preprocessed format.
See <code><a href="tosca.html#topic+LDAprep">LDAprep</a></code></p>
</dd>
<dt><code>dates</code></dt><dd><p>[<code>named Date</code>] with dates of the modeled texts.</p>
</dd>
<dt><code>vocab</code></dt><dd><p>[<code>character</code>] with the vocabularies considered
for modeling.</p>
</dd>
<dt><code>chunks</code></dt><dd><p>[<code>data.table</code>] with specifications for each
model chunk.</p>
</dd>
<dt><code>param</code></dt><dd><p>[<code>named list</code>] with parameter specifications for
<code>vocab.abs</code> [<code>integer(1)</code>], <code>vocab.rel</code> [0,1],
<code>vocab.fallback</code> [<code>integer(1)</code>] and
<code>doc.abs</code> [<code>integer(1)</code>]. See above for explanation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other RollingLDA functions: 
<code><a href="#topic+RollingLDA">RollingLDA</a>()</code>,
<code><a href="#topic+as.RollingLDA">as.RollingLDA</a>()</code>,
<code><a href="#topic+getChunks">getChunks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
roll_lda = RollingLDA(texts = economy_texts[economy_dates &lt; "2008-05-01"],
                      dates = economy_dates[economy_dates &lt; "2008-05-01"],
                      chunks = "month",
                      memory = "month",
                      init = 100,
                      K = 10,
                      type = "lda")

# updateRollingLDA = RollingLDA, if first argument is a RollingLDA object
roll_update = RollingLDA(roll_lda,
                         texts = economy_texts[economy_dates &gt;= "2008-05-01"],
                         dates = economy_dates[economy_dates &gt;= "2008-05-01"],
                         chunks = "month",
                         memory = "month")

roll_update
getChunks(roll_update)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
