<!DOCTYPE html><html><head><title>Help for package ssaBSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ssaBSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ASSA'>
<p>ASSA Method for Non-stationary Identification</p></a></li>
<li><a href='#rtvAR1'>
<p>Simulation of Time Series with Time-varying Autocovariance</p></a></li>
<li><a href='#rtvvar'>
<p>Simulation of Time Series with Time-varying Variance</p></a></li>
<li><a href='#ssabss'>
<p>Class: ssabss</p></a></li>
<li><a href='#ssaBSS-package'>
<p>Stationary Subspace Analysis</p></a></li>
<li><a href='#SSAcomb'>
<p>Combination Main SSA Methods</p></a></li>
<li><a href='#SSAcor'>
<p>Identification of Non-stationarity in the Covariance Structure</p></a></li>
<li><a href='#SSAsave'>
<p>Identification of Non-stationarity in Variance</p></a></li>
<li><a href='#SSAsir'>
<p>Identification of Non-stationarity in Mean</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stationary Subspace Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Matilainen &lt;markus.matilainen@outlook.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>tsBSS (&ge; 0.5.3), ICtest (&ge; 0.3-4), JADE (&ge; 2.0-2), BSSprep,
ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>xts, zoo</td>
</tr>
<tr>
<td>Description:</td>
<td>Stationary subspace analysis (SSA) is a blind source separation (BSS) variant where stationary components are separated from non-stationary components. Several SSA methods for multivariate time series are provided here (Flumian et al. (2021); Hara et al. (2010) &lt;<a href="https://doi.org/10.1007%2F978-3-642-17537-4_52">doi:10.1007/978-3-642-17537-4_52</a>&gt;) along with functions to simulate time series with time-varying variance and autocovariance (Patilea and Raissi(2014) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.884504">doi:10.1080/01621459.2014.884504</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-01 15:31:21 UTC; manmat</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Matilainen <a href="https://orcid.org/0000-0002-5597-2670"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Lea Flumian [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sara Taskinen <a href="https://orcid.org/0000-0001-9470-7258"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-01 16:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ASSA'>
ASSA Method for Non-stationary Identification
</h2><span id='topic+ASSA'></span><span id='topic+ASSA.default'></span><span id='topic+ASSA.ts'></span><span id='topic+ASSA.xts'></span><span id='topic+ASSA.zoo'></span>

<h3>Description</h3>

<p>ASSA (Analytic Stationary Subspace Analysis) method for identifying non-stationary components of mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASSA(X, ...)

## Default S3 method:
ASSA(X, K, n.cuts = NULL, ...)
## S3 method for class 'ts'
ASSA(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASSA_+3A_x">X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="ASSA_+3A_k">K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code id="ASSA_+3A_n.cuts">n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td></tr>
<tr><td><code id="ASSA_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>.
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. Algorithm first calculates matrix
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = \frac{1}{T}\sum_{i = 1}^K \left({\bf m}_{T_i} {\bf m}_{T_i}^T + \frac{1}{2} {\bf S}_{T_i} {\bf S}_{T_i}^T\right) - \frac{1}{2} {\bf I},</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, <code class="reqn">{\bf I}</code> is an identity matrix, and <code class="reqn">{\bf m}_{T_i}</code> is the average of values of <code class="reqn">{\bf Y}</code> and <code class="reqn">{\bf S}_{T_i}</code> is the sample variance of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> via eigendecomposition
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = {\bf UDU}^T.</code>
</p>

<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf U}</code> are the eigenvectors corresponding to the non-zero eigenvalues and the rest correspond to the zero eigenvalues. In the same way, the first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of non-stationary components, and the last <code class="reqn">p-k</code> rows to the subspace of stationary components. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Used separation matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Eigenvalues of M.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td></tr>
<tr><td><code>n.cut</code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Name of the method (&quot;ASSA&quot;), to be used in e.g. screeplot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Hara S., Kawahara Y., Washio T. and von BÃ¼nau P. (2010). <em>Stationary Subspace Analysis as a Generalized Eigenvalue Problem</em>, Neural Information Processing. Theory and Algorithms, Part I, pp. 422-429.
</p>


<h3>See Also</h3>

<p><code><a href="JADE.html#topic+JADE">JADE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
A &lt;- rorth(4)

z1 &lt;- arima.sim(n, model = list(ar = 0.7)) + rep(c(-1.52, 1.38), c(floor(n*0.5),
        n - floor(n*0.5)))
z2 &lt;- rtvvar(n, alpha = 0.1, beta = 1)
z3 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24))) 
z4 &lt;- arima.sim(n, model = list(ar = c(0.34, 0.27, 0.18)))

Z &lt;- cbind(z1, z2, z3, z4)
X &lt;- as.ts(tcrossprod(Z, A)) # An mts object

res &lt;- ASSA(X, K = 6)
screeplot(res, type = "lines") # Two non-zero eigenvalues

# Plotting the components as an mts object
plot(res) # The first two are nonstationary

</code></pre>

<hr>
<h2 id='rtvAR1'>
Simulation of Time Series with Time-varying Autocovariance
</h2><span id='topic+rtvAR1'></span>

<h3>Description</h3>

<p>Simulating time-varying variance based on TV-AR1 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtvAR1(n, sigma = 0.93)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtvAR1_+3A_n">n</code></td>
<td>
<p>Length of the time series</p>
</td></tr>
<tr><td><code id="rtvAR1_+3A_sigma">sigma</code></td>
<td>
<p>Parameter <code class="reqn">\sigma^2</code> in TV-AR1, i.e. the variance. Default is 0.93.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time varying autoregressive processes of order 1 (TV-AR1) is
</p>
<p style="text-align: center;"><code class="reqn">x_t = a_t x_{t-1} + \epsilon_t,</code>
</p>

<p>with <code class="reqn">x_0=0</code>, <code class="reqn">\epsilon_t</code> is iid <code class="reqn">N(0, \sigma^2)</code> and <code class="reqn">a_t = 0.5\cos(2\pi t/T)</code>.
</p>


<h3>Value</h3>

<p>The simulated series as a <code><a href="stats.html#topic+ts">ts</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Sara Taskinen, Markus Matilainen
</p>


<h3>References</h3>

<p>Patilea V. and RaÃ¯ssi H. (2014) <em>Testing Second-Order Dynamics for Autoregressive Processes in Presence of Time-Varying Variance</em>, Journal of the American Statistical Association, 109 (507), 1099-1111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
X &lt;- rtvAR1(n, sigma = 0.93)
plot(X)

</code></pre>

<hr>
<h2 id='rtvvar'>
Simulation of Time Series with Time-varying Variance
</h2><span id='topic+rtvvar'></span>

<h3>Description</h3>

<p>Simulating time-varying variance based on TV-VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtvvar(n, alpha, beta = 1, simple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtvvar_+3A_n">n</code></td>
<td>
<p>Length of the time series</p>
</td></tr>
<tr><td><code id="rtvvar_+3A_alpha">alpha</code></td>
<td>
<p>Parameter <code class="reqn">\alpha</code> in TV-VAR</p>
</td></tr>
<tr><td><code id="rtvvar_+3A_beta">beta</code></td>
<td>
<p>Parameter <code class="reqn">\beta</code> in TV-VAR. Default is 1.</p>
</td></tr>
<tr><td><code id="rtvvar_+3A_simple">simple</code></td>
<td>
<p>A logical vector indicating whether <code class="reqn">h_t</code> is considered as its own process, or just <code class="reqn">t/T</code>. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time varying variance (TV-VAR) process <code class="reqn">x_t</code> with parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> is of the form
</p>
<p style="text-align: center;"><code class="reqn">x_t = \tilde h_t \epsilon_t,</code>
</p>

<p>where, if <code>simple = FALSE</code>,
</p>
<p style="text-align: center;"><code class="reqn">\tilde h_t^2 = h_t^2 + \alpha x_{t-1}^2,</code>
</p>
<p> where <code class="reqn">\epsilon</code> are iid <code class="reqn">N(0,1)</code>, <code class="reqn">x_0 = 0</code> and <code class="reqn">h_t =  10 - 10 \sin(\beta \pi t/T + \pi/6)  (1 + t/T)</code>,
</p>
<p>and if <code>simple = TRUE</code>, </p>
<p style="text-align: center;"><code class="reqn">\tilde h_t = t/T.</code>
</p>



<h3>Value</h3>

<p>The simulated series as a <code><a href="stats.html#topic+ts">ts</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Sara Taskinen, Markus Matilainen
</p>


<h3>References</h3>

<p>Patilea V. and RaÃ¯ssi H. (2014) <em>Testing Second-Order Dynamics for Autoregressive Processes in Presence of Time-Varying Variance</em>, Journal of the American Statistical Association, 109 (507), 1099-1111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
X &lt;- rtvvar(n, alpha = 0.2, beta = 0.5, simple = FALSE)
plot(X)

</code></pre>

<hr>
<h2 id='ssabss'>
Class: ssabss
</h2><span id='topic+ssabss'></span><span id='topic+plot.ssabss'></span><span id='topic+screeplot.ssabss'></span><span id='topic+ggscreeplot.ssabss'></span>

<h3>Description</h3>

<p>Class 'ssabss' (blind source separation in stationary subspace analysis) with methods plot, screeplot (prints a screeplot of an object of class 'ssabss') and ggscreeplot (prints a screeplot of an object of class 'ssabss' using package <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>).
</p>
<p>The class 'ssabss' also inherits methods from the class 'bss' in package <code><a href="JADE.html#topic+JADE">JADE</a></code>: for extracting the components (<code><a href="JADE.html#topic+bss.components">bss.components</a></code>), for plotting the components (<code><a href="JADE.html#topic+plot.bss">plot.bss</a></code>), for printing (<code><a href="JADE.html#topic+print.bss">print.bss</a></code>), and for extracting the coefficients (<code><a href="JADE.html#topic+coef.bss">coef.bss</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ssabss'
plot(x, ...)

## S3 method for class 'ssabss'
screeplot(x, type = c("lines", "barplot"), xlab = "Number of components",
          ylab = NULL, main = paste("Screeplot for", x$method),
          pointsize = 4, breaks = 1:length(x$D), color = "red", ...)
                              
## S3 method for class 'ssabss'
ggscreeplot(x, type = c("lines", "barplot"), xlab = "Number of components",
            ylab = NULL, main = paste("Screeplot for", x$method),
            pointsize = 4, breaks = 1:length(x$D), color = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssabss_+3A_x">x</code></td>
<td>
<p>An object of class 'ssabss'.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_type">type</code></td>
<td>
<p>Type of screeplot. Choices are &quot;lines&quot; (default) and &quot;barplot&quot;.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis. Default is &quot;Number of components&quot;.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis. Default is &quot;Sum of pseudo eigenvalues&quot; if method is <code><a href="#topic+SSAcomb">SSAcomb</a></code> and &quot;Eigenvalues&quot; otherwise.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_main">main</code></td>
<td>
<p>Title of the plot. Default is &quot;Screeplot for ...&quot;, where ... denotes for the name of the method used.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_pointsize">pointsize</code></td>
<td>
<p>Size of the points in the plot (for <code>type = "lines"</code> only). Default is 4.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_breaks">breaks</code></td>
<td>
<p>Breaks and labels for the x-axis. Default is from 1 to the number of series by 1.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_color">color</code></td>
<td>
<p>Color of the line (if <code>type = "lines"</code>) or bar (if <code>type = "barplot")</code>. Default is red.</p>
</td></tr>
<tr><td><code id="ssabss_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A screeplot can be used to determine the number of interesting components. For <code><a href="#topic+SSAcomb">SSAcomb</a></code> it plots the sum of pseudo eigenvalues and for other methods it plots the eigenvalues.
</p>


<h3>Author(s)</h3>

<p>Markus Matilainen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ASSA">ASSA</a></code>, <code><a href="#topic+SSAsir">SSAsir</a></code>, <code><a href="#topic+SSAsave">SSAsave</a></code>, <code><a href="#topic+SSAcor">SSAcor</a></code>, <code><a href="#topic+SSAcomb">SSAcomb</a></code>, <code><a href="JADE.html#topic+JADE">JADE</a></code>, <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>
</p>

<hr>
<h2 id='ssaBSS-package'>
Stationary Subspace Analysis</h2><span id='topic+ssaBSS-package'></span>

<h3>Description</h3>

<p>Stationary subspace analysis (SSA) is a blind source separation (BSS) variant where stationary components are separated from non-stationary components. Several SSA methods for multivariate time series are provided here (Flumian et al. (2021); Hara et al. (2010) &lt;doi:10.1007/978-3-642-17537-4_52&gt;) along with functions to simulate time series with time-varying variance and autocovariance (Patilea and RaÃ¯ssi(2014) &lt;doi:10.1080/01621459.2014.884504&gt;).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ssaBSS</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-12-01</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)
</td>
</tr>

</table>

<p>This package contains functions for identifying different types of nonstationarity
</p>

<ul>
<li><p><code><a href="#topic+SSAsir">SSAsir</a></code>  &ndash; SIR type function for mean non-stationarity identification
</p>
</li>
<li><p><code><a href="#topic+SSAsave">SSAsave</a></code>  &ndash; SAVE type function for variance non-stationarity identification
</p>
</li>
<li><p><code><a href="#topic+SSAcor">SSAcor</a></code>  &ndash; Function for identifying changes in autocorrelation
</p>
</li>
<li><p><code><a href="#topic+ASSA">ASSA</a></code>  &ndash; ASSA: Analytic SSA for identification of nonstationarity in mean and variance.
</p>
</li>
<li><p><code><a href="#topic+SSAcomb">SSAcomb</a></code>  &ndash; Combination of <code><a href="#topic+SSAsir">SSAsir</a></code>, <code><a href="#topic+SSAsave">SSAsave</a></code>, and <code><a href="#topic+SSAcor">SSAcor</a></code> using joint diagonalization
</p>
</li></ul>

<p>The package also contains function <code><a href="#topic+rtvvar">rtvvar</a></code> to simulate a time series with time-varying variance (TV-VAR), and function <code><a href="#topic+rtvAR1">rtvAR1</a></code> to simulate a time series with time-varying autocovariance (TV-AR1).
</p>


<h3>Author(s)</h3>

<p>Markus Matilainen, LÃ©a Flumian, Klaus Nordhausen, Sara Taskinen
</p>
<p>Maintainer: Markus Matilainen &lt;markus.matilainen@outlook.com&gt; 
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>
<p>Hara S., Kawahara Y., Washio T. and von BÃ¼nau P. (2010). <em>Stationary Subspace Analysis as a Generalized Eigenvalue Problem</em>, Neural Information Processing. Theory and Algorithms, Part I, pp. 422-429.
</p>
<p>Patilea V. and RaÃ¯ssi H. (2014) <em>Testing Second-Order Dynamics for Autoregressive Processes in Presence of Time-Varying Variance</em>, Journal of the American Statistical Association, 109 (507), 1099-1111.
</p>

<hr>
<h2 id='SSAcomb'>
Combination Main SSA Methods
</h2><span id='topic+SSAcomb'></span><span id='topic+SSAcomb.default'></span><span id='topic+SSAcomb.ts'></span><span id='topic+SSAcomb.xts'></span><span id='topic+SSAcomb.zoo'></span>

<h3>Description</h3>

<p>SSAcomb method for identification for non-stationarity in mean, variance and covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSAcomb(X, ...)

## Default S3 method:
SSAcomb(X, K, n.cuts = NULL, tau = 1, eps = 1e-6, maxiter = 2000, ...)
## S3 method for class 'ts'
SSAcomb(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSAcomb_+3A_x">X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_k">K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_n.cuts">n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_tau">tau</code></td>
<td>
<p>The lag as a scalar or a vector. Default is 1.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_eps">eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="SSAcomb_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>. 
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. For all lags <code class="reqn">j = 1, ..., ntau</code>, algorithm first calculates the <code class="reqn">{\bf M}</code> matrices from SSAsir (matrix <code class="reqn">{\bf M}_1</code>), SSAsave (matrix <code class="reqn">{\bf M}_2</code>) and SSAcor (matrices <code class="reqn">{\bf M}_{j+2}</code>).
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i = 1}^{ntau+2} ||\textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}')||^2.</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, ntau + 2</code>. The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf US}^{-1/2}</code>.
</p>
<p>Then the pseudo eigenvalues <code class="reqn">{\bf D}_i = \textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}') = \textrm{diag}(d_{i,1}, \ldots, d_{i,p})</code> are obtained and the value of <code class="reqn">d_{i,j}</code> tells if the <code class="reqn">j</code>th component is nonstationary with respect to <code class="reqn">{\bf M}_i</code>.
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Used M-matrices as an array.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The sums of pseudo eigenvalues.</p>
</td></tr>
<tr><td><code>DTable</code></td>
<td>
<p>The peudo eigenvalues of size <em>ntau + 2</em> to see which type of nonstationarity there exists in each component.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td></tr>
<tr><td><code>n.cut</code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The used lag.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Name of the method (&quot;SSAcomb&quot;), to be used in e.g. screeplot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code><a href="JADE.html#topic+JADE">JADE</a></code> <code><a href="JADE.html#topic+rjd">frjd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 10000
A &lt;- rorth(6)

z1 &lt;- arima.sim(n, model = list(ar = 0.7)) + rep(c(-1.52, 1.38), 
        c(floor(n*0.5), n - floor(n*0.5)))
z2 &lt;- rtvAR1(n)
z3 &lt;- rtvvar(n, alpha = 0.2, beta = 0.5)
z4 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24), ar = c(0.14, 0.45)))
z5 &lt;- arima.sim(n, model = list(ma = c(0.34))) 
z6 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.15)))

Z &lt;- cbind(z1, z2, z3, z4, z5, z6)
library(xts)
X &lt;- tcrossprod(Z, A)
X &lt;- xts(X, order.by = as.Date(1:n)) # An xts object

res &lt;- SSAcomb(X, K = 12, tau = 1)
ggscreeplot(res, type = "lines") # Three non-zero eigenvalues
res$DTable # Components have different kind of nonstationarities

# Plotting the components as an xts object
plot(res, multi.panel = TRUE) # The first three are nonstationary


</code></pre>

<hr>
<h2 id='SSAcor'>
Identification of Non-stationarity in the Covariance Structure
</h2><span id='topic+SSAcor'></span><span id='topic+SSAcor.default'></span><span id='topic+SSAcor.ts'></span><span id='topic+SSAcor.xts'></span><span id='topic+SSAcor.zoo'></span>

<h3>Description</h3>

<p>SSAcor method for identifying non-stationarity in the covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSAcor(X, ...)

## Default S3 method:
SSAcor(X, K, n.cuts = NULL, tau = 1, eps = 1e-6, maxiter = 2000, ...)
## S3 method for class 'ts'
SSAcor(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSAcor_+3A_x">X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_k">K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_n.cuts">n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_tau">tau</code></td>
<td>
<p>The lag as a scalar or a vector. Default is 1.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_eps">eps</code></td>
<td>
<p>Convergence tolerance.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="SSAcor_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>. 
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. For all lags <code class="reqn">j=1, ..., ntau</code>, algorithm first calculates matrices
</p>
<p style="text-align: center;"><code class="reqn">{\bf M_j} = \sum_{i = 1}^K \frac{T_i}{T}({\bf S}_{j,T} - {\bf S}_{j,T_i})({\bf S}_{j,T} - {\bf S}_{j,T_i})^T,</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, <code class="reqn">{\bf S}_{J,T}</code> is the global sample covariance for lag <code class="reqn">j</code>, and <code class="reqn">{\bf S}_{\tau,T_i}</code> is the sample covariance of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> by maximizing 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j = 1}^{ntau} ||\textrm{diag}({\bf}{\bf U}{\bf M}_j {\bf U}')||^2.</code>
</p>

<p>where <code class="reqn">j = 1, \ldots, ntau</code>.
</p>
<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. 
Then the pseudo eigenvalues <code class="reqn">{\bf D}_i = \textrm{diag}({\bf}{\bf U}{\bf M}_i {\bf U}') = \textrm{diag}(d_{i,1}, \ldots, d_{i,p})</code> are obtained and the value of <code class="reqn">d_{i,j}</code> tells if the <code class="reqn">j</code>th component is nonstationary with respect to <code class="reqn">{\bf M}_i</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of components with non-stationary covariance, and the last <code class="reqn">p-k</code> rows to the subspace of components with stationary covariance. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Used separation matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>The sums of pseudo eigenvalues.</p>
</td></tr>
<tr><td><code>DTable</code></td>
<td>
<p>The peudo eigenvalues of size <em>ntau*p</em> to see which type of nonstationarity there exists in each component.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td></tr>
<tr><td><code>n.cut</code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>The used lag.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Name of the method (&quot;SSAcor&quot;), to be used in e.g. screeplot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code><a href="JADE.html#topic+JADE">JADE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
A &lt;- rorth(4)

z1 &lt;- rtvAR1(n)
z2a &lt;- arima.sim(floor(n/3), model = list(ar = c(0.5),
        innov = c(rnorm(floor(n/3), 0, 1))))
z2b &lt;- arima.sim(floor(n/3), model = list(ar = c(0.2),
        innov = c(rnorm(floor(n/3), 0, 1.28))))
z2c &lt;- arima.sim(n - 2*floor(n/3), model = list(ar = c(0.8),
        innov = c(rnorm(n - 2*floor(n/3), 0, 0.48))))
z2 &lt;- c(z2a, z2b, z2c)
z3 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24), ar = c(0.14, 0.45)))
z4 &lt;- arima.sim(n, model = list(ar = c(0.34, 0.27, 0.18))) 

Z &lt;- cbind(z1, z2, z3, z4)
library(zoo)
X &lt;- as.zoo(tcrossprod(Z, A)) # A zoo object

res &lt;- SSAcor(X, K = 6, tau = 1)
ggscreeplot(res, type = "barplot", color = "gray") # Two non-zero eigenvalues

# Plotting the components as a zoo object
plot(res) # The first two are nonstationary in autocovariance

</code></pre>

<hr>
<h2 id='SSAsave'>
Identification of Non-stationarity in Variance
</h2><span id='topic+SSAsave'></span><span id='topic+SSAsave.default'></span><span id='topic+SSAsave.ts'></span><span id='topic+SSAsave.xts'></span><span id='topic+SSAsave.zoo'></span>

<h3>Description</h3>

<p>SSAsave method for identifying non-stationarity in variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSAsave(X, ...)

## Default S3 method:
SSAsave(X, K, n.cuts = NULL, ...)
## S3 method for class 'ts'
SSAsave(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSAsave_+3A_x">X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="SSAsave_+3A_k">K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code id="SSAsave_+3A_n.cuts">n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td></tr>
<tr><td><code id="SSAsave_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>.
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. Algorithm first calculates matrix
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = \sum_{i = 1}^K \frac{T_i}{T}({\bf I} - {\bf S}_{T_i}) ({\bf I} - {\bf S}_{T_i})^T,</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, <code class="reqn">{\bf I}</code> is an identity matrix, and <code class="reqn">{\bf S}_{T_i}</code> is the sample variance of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> via eigendecomposition
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = {\bf UDU}^T.</code>
</p>

<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf U}</code> are the eigenvectors corresponding to the non-zero eigenvalues and the rest correspond to the zero eigenvalues. In the same way, the first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of components with non-stationary variance, and the last <code class="reqn">p-k</code> rows to the subspace of components with stationary variance. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Used separation matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Eigenvalues of M.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td></tr>
<tr><td><code>n.cut</code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Name of the method (&quot;SSAsave&quot;), to be used in e.g. screeplot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code><a href="JADE.html#topic+JADE">JADE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
A &lt;- rorth(4)

z1 &lt;- rtvvar(n, alpha = 0.2, beta = 0.5)
z2 &lt;- rtvvar(n, alpha = 0.1, beta = 1)
z3 &lt;- arima.sim(n, model = list(ma = c(0.72, 0.24))) 
z4 &lt;- arima.sim(n, model = list(ar = c(0.34, 0.27, 0.18)))

Z &lt;- cbind(z1, z2, z3, z4)
X &lt;- as.ts(tcrossprod(Z, A)) # An mts object

res &lt;- SSAsave(X, K = 6)
res$D # Two non-zero eigenvalues
screeplot(res, type = "lines") # This can also be seen in screeplot
ggscreeplot(res, type = "lines") # ggplot version of screeplot

# Plotting the components as an mts object
plot(res) # The first two are nonstationary in variance


</code></pre>

<hr>
<h2 id='SSAsir'>
Identification of Non-stationarity in Mean
</h2><span id='topic+SSAsir'></span><span id='topic+SSAsir.default'></span><span id='topic+SSAsir.ts'></span><span id='topic+SSAsir.xts'></span><span id='topic+SSAsir.zoo'></span>

<h3>Description</h3>

<p>SSAsir method for identifying non-stationarity in mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSAsir(X, ...)

## Default S3 method:
SSAsir(X, K, n.cuts = NULL, ...)
## S3 method for class 'ts'
SSAsir(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSAsir_+3A_x">X</code></td>
<td>
<p>A numeric matrix or a multivariate time series object of class <code><a href="stats.html#topic+ts">ts</a></code>, <code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="zoo.html#topic+zoo">zoo</a></code>. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="SSAsir_+3A_k">K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code id="SSAsir_+3A_n.cuts">n.cuts</code></td>
<td>
<p>A K+1 vector of values that correspond to the breaks which are used for splitting the data. Default is intervals of equal length.</p>
</td></tr>
<tr><td><code id="SSAsir_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that a <code class="reqn">p</code>-variate <code class="reqn">{\bf Y}</code> with <code class="reqn">T</code> observations is whitened, i.e. <code class="reqn">{\bf Y}={\bf S}^{-1/2}({\bf X}_t - \frac{1}{T}\sum_{t=1}^T {\bf X}_{t})</code>, for <code class="reqn">t = 1, \ldots, T,</code>
where <code class="reqn">{\bf S}</code> is the sample covariance matrix of <code class="reqn">{\bf X}</code>.
</p>
<p>The values of <code class="reqn">{\bf Y}</code> are then split into <code class="reqn">K</code> disjoint intervals <code class="reqn">T_i</code>. Algorithm first calculates matrix
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = \sum_{i = 1}^K \frac{T_i}{T}({\bf m}_{T_i} {\bf m}_{T_i}^T),</code>
</p>

<p>where <code class="reqn">i = 1, \ldots, K</code>, <code class="reqn">K</code> is the number of breakpoints, and <code class="reqn">{\bf m}_{T_i}</code> is the average of values of <code class="reqn">{\bf Y}</code> which belong to a disjoint interval <code class="reqn">T_i</code>.
</p>
<p>The algorithm finds an orthogonal matrix <code class="reqn">{\bf U}</code> via eigendecomposition
</p>
<p style="text-align: center;"><code class="reqn">{\bf M} = {\bf UDU}^T.</code>
</p>

<p>The final unmixing matrix is then <code class="reqn">{\bf W} = {\bf U S}^{-1/2}</code>. The first <code class="reqn">k</code> rows of <code class="reqn">{\bf U}</code> are the eigenvectors corresponding to the non-zero eigenvalues and the rest correspond to the zero eigenvalues. In the same way, the first <code class="reqn">k</code> rows of <code class="reqn">{\bf W}</code> project the observed time series to the subspace of components with non-stationary mean, and the last <code class="reqn">p-k</code> rows to the subspace of components with stationary mean. 
</p>


<h3>Value</h3>

<p>A list of class 'ssabss', inheriting from class 'bss', containing the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>The estimated unmixing matrix.</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>The estimated sources as time series object standardized to have mean 0 and unit variances.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Used separation matrix.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of intervals the time series is split into.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Eigenvalues of M.</p>
</td></tr>
<tr><td><code>MU</code></td>
<td>
<p>The mean vector of <code>X</code>.</p>
</td></tr>
<tr><td><code>n.cut</code></td>
<td>
<p>Used K+1 vector of values that correspond to the breaks which are used for splitting the data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Name of the method (&quot;SSAsir&quot;), to be used in e.g. screeplot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Matilainen, Klaus Nordhausen
</p>


<h3>References</h3>

<p>Flumian L., Matilainen M., Nordhausen K. and Taskinen S. (2021) <em>Stationary subspace analysis based on second-order statistics</em>. Submitted. Available on arXiv: https://arxiv.org/abs/2103.06148
</p>


<h3>See Also</h3>

<p><code><a href="JADE.html#topic+JADE">JADE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 5000
A &lt;- rorth(4)
  
z1 &lt;- arima.sim(n, model = list(ar = 0.7)) + rep(c(-1.52, 1.38),
        c(floor(n*0.5), n - floor(n*0.5)))
z2 &lt;- arima.sim(n, model = list(ar = 0.5)) + rep(c(-0.75, 0.84, -0.45),
        c(floor(n/3), floor(n/3), n - 2*floor(n/3)))
z3 &lt;- arima.sim(n, model = list(ma = 0.72))
z4 &lt;- arima.sim(n, model = list(ma = c(0.34)))

Z &lt;- cbind(z1, z2, z3, z4)
X &lt;- tcrossprod(Z, A)

res &lt;- SSAsir(X, K = 6)
res$D # Two non-zero eigenvalues
screeplot(res, type = "lines") # This can also be seen in screeplot

# Plotting the components
plot(res) # The first two are nonstationary in mean

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
