<!DOCTYPE html><html lang="en-AU"><head><title>Help for package paleopop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paleopop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#paleopop-package'><p>paleopop: Pattern-Oriented Modeling Framework for Coupled Niche-Population Paleo-Climatic Models</p></a></li>
<li><a href='#bison_hs_raster'><p>Bison vignette habitat suitability raster</p></a></li>
<li><a href='#paleopop'><p>paleopop: Ensemble population modeling and simulation on paleo time scales</p></a></li>
<li><a href='#paleopop_simulator'><p>Runs a customized population model simulation.</p></a></li>
<li><a href='#PaleoPopModel'><p>R6 class representing a population model for the paleopop simulator</p></a></li>
<li><a href='#PaleoPopResults'><p>R6 class representing paleopop simulator results.</p></a></li>
<li><a href='#PaleoRegion'><p>R6 class representing a paleontological region.</p></a></li>
<li><a href='#region_subset'><p>Function generates a region subset of matrix values based on a subset of coordinates within the original region (using nearest spatial neighbor if coordinates differ).</p></a></li>
<li><a href='#siberia_raster'><p>Bison vignette Siberia raster</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pattern-Oriented Modeling Framework for Coupled Niche-Population
Paleo-Climatic Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>July Pilowsky &lt;pilowskyj@caryinstitute.org&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GlobalEcologyLab/paleopop/">https://github.com/GlobalEcologyLab/paleopop/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GlobalEcologyLab/paleopop/issues">https://github.com/GlobalEcologyLab/paleopop/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>This extension of the poems pattern-oriented modeling (POM) framework
    provides a collection of modules and functions customized for paleontological
    time-scales, and optimized for single-generation transitions and large populations,
    across multiple generations.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>poems (&ge; 1.0.0), R6 (&ge; 2.5.0), sf (&ge; 0.9), trend (&ge; 1.1.4)</td>
</tr>
<tr>
<td>Collate:</td>
<td>data.R PaleoPopModel.R PaleoPopResults.R PaleoRegion.R
paleopop_simulator.R paleopop-package.R region_subset.R</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, markdown, dplyr,
raster</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-27 20:26:36 UTC; caryinstitute</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean Haythorne [aut],
  July Pilowsky <a href="https://orcid.org/0000-0002-6376-2585"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stuart Brown <a href="https://orcid.org/0000-0002-0669-1418"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Damien Fordham <a href="https://orcid.org/0000-0003-2137-5592"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-07 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='paleopop-package'>paleopop: Pattern-Oriented Modeling Framework for Coupled Niche-Population Paleo-Climatic Models</h2><span id='topic+paleopop-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>This extension of the poems pattern-oriented modeling (POM) framework provides a collection of modules and functions customized for paleontological time-scales, and optimized for single-generation transitions and large populations, across multiple generations.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: July Pilowsky <a href="mailto:pilowskyj@caryinstitute.org">pilowskyj@caryinstitute.org</a> (<a href="https://orcid.org/0000-0002-6376-2585">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sean Haythorne <a href="mailto:sean.haythorne@adelaide.edu.au">sean.haythorne@adelaide.edu.au</a>
</p>
</li>
<li><p> Stuart Brown <a href="mailto:s.brown@adelaide.edu.au">s.brown@adelaide.edu.au</a> (<a href="https://orcid.org/0000-0002-0669-1418">ORCID</a>)
</p>
</li>
<li><p> Damien Fordham <a href="mailto:damien.fordham@adelaide.edu.au">damien.fordham@adelaide.edu.au</a> (<a href="https://orcid.org/0000-0003-2137-5592">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/GlobalEcologyLab/paleopop/">https://github.com/GlobalEcologyLab/paleopop/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/GlobalEcologyLab/paleopop/issues">https://github.com/GlobalEcologyLab/paleopop/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bison_hs_raster'>Bison vignette habitat suitability raster</h2><span id='topic+bison_hs_raster'></span>

<h3>Description</h3>

<p>A <em>raster</em> dataset defining estimated habitat suitability values for each grid
cells of the Siberian study region of the bison example vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bison_hs_raster
</code></pre>


<h3>Format</h3>

<p>A <em>raster::RasterStack</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>21 rows by 180 columns by 1001 layers</p>
</dd>
<dt>resolution</dt><dd><p>2 by 2 degree grid cells</p>
</dd>
<dt>extent</dt><dd><p>longitude -180 to 180 degrees; latitude 42 to 84 degrees</p>
</dd>
<dt>values</dt><dd><p>Estimated habitat suitability values of 0 to 1</p>
</dd>
</dl>



<h3>Source</h3>

<p>TBA
</p>

<hr>
<h2 id='paleopop'>paleopop: Ensemble population modeling and simulation on paleo time scales</h2><span id='topic+paleopop'></span>

<h3>Description</h3>

<p>The <code>paleopop</code> package is an extension of the <code><a href="poems.html#topic+poems">poems</a></code> framework of <code><a href="R6.html#topic+R6Class">R6</a></code> classes, which 
simulate populations on a dynamic landscape and validate the results via pattern-oriented modeling. <code>paleopop</code> adds
functionality for modeling populations over paleo time scales.
</p>


<h3>Details</h3>

<p>The new functions and R6 classes added by <code>paleopop</code> to the <code>poems</code> framework are:
</p>
<ul>
<li> <p><code><a href="#topic+paleopop_simulator">paleopop_simulator</a></code> function: Analogous to the <code><a href="poems.html#topic+population_simulator">population_simulator</a></code> 
function in <code>poems</code>, this is the engine of simulation in <code>paleopop</code>, handling input parameters,
simulating over long time scales, and outputting up to six different types of results.
</p>
</li>
<li> <p><code><a href="#topic+PaleoRegion">PaleoRegion</a></code> class: Inherited from <code><a href="poems.html#topic+Region">Region</a></code>, this class defines a 
geographic region that changes over time, creating a temporal mask that defines which cells are occupiable at a
time step.
</p>
</li>
<li> <p><code><a href="#topic+region_subset">region_subset</a></code> function: a utility function for subsetting regions defined by coordinates. 
</p>
</li>
<li> <p><code><a href="#topic+PaleoPopModel">PaleoPopModel</a></code> class: Inherited from
<code><a href="poems.html#topic+SimulationModel">SimulationModel</a></code>, this class encapsulates the input parameters
utilized by the <code><a href="#topic+paleopop_simulator">paleopop_simulator</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+PaleoPopResults">PaleoPopResults</a></code> class: Inherited from
<code><a href="poems.html#topic+SimulationResults">SimulationResults</a></code>, this class encapsulates the results generated
by the <code><a href="#topic+paleopop_simulator">paleopop_simulator</a></code>, as well as dynamically generating
additional derived results.
</p>
</li></ul>


<hr>
<h2 id='paleopop_simulator'>Runs a customized population model simulation.</h2><span id='topic+paleopop_simulator'></span>

<h3>Description</h3>

<p>Simulates a population model customized for paleontological time-scales, optimized
for single-generation transitions and large populations, across multiple generations
and returns simulation results. Each generational time-step includes:
</p>

<ol>
<li><p> Density dependence calculations
</p>
</li>
<li><p> Environmental stochasticity calculations
</p>
</li>
<li><p> Generational transition calculations
</p>
</li>
<li><p> Harvest calculations
</p>
</li>
<li><p> Dispersal calculations
</p>
</li>
<li><p> Results collection
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>paleopop_simulator(inputs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paleopop_simulator_+3A_inputs">inputs</code></td>
<td>
<p>Nested list/object with named elements:
</p>

<dl>
<dt><code>random_seed</code></dt><dd><p>Number to seed the random number generation for stochasticity.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of populations.</p>
</dd>
<dt><code>initial_abundance</code></dt><dd><p>Array of initial abundances for each population.</p>
</dd>
<dt><code>transition_rate</code></dt><dd><p>Rate of transition (or fecundity) between generations.</p>
</dd>
<dt><code>standard_deviation</code></dt><dd><p>Standard deviation applied to transition rates.</p>
</dd>
<dt><code>compact_decomposition</code></dt><dd><p>List containing a compact transposed 
(Cholesky) decomposition <em>matrix</em> (t_decomposition_compact_matrix) 
and a corresponding <em>map</em> of population indices 
(t_decomposition_compact_map), as per 
<code><a href="poems.html#topic+SpatialCorrelation">SpatialCorrelation</a></code> class 
attributes.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Matrix of carrying capacities (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
<dt><code>density_dependence</code></dt><dd><p>Density dependence type (&quot;competition&quot;, &quot;logistic&quot;, or &quot;ceiling&quot;).</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate (for &quot;competition&quot; or &quot;logistic&quot; density dependence).</p>
</dd>
<dt><code>harvest</code></dt><dd><p>Boolean for utilizing harvesting.</p>
</dd>
<dt><code>harvest_max</code></dt><dd><p>Proportion harvested per year (note: annual time scale - not generational).</p>
</dd>
<dt><code>harvest_g</code></dt><dd><p>The <em>G</em> parameter in the harvest function.</p>
</dd>
<dt><code>harvest_z</code></dt><dd><p>The <em>Z</em> parameter in the harvest function.</p>
</dd>
<dt><code>harvest_max_n</code></dt><dd><p>Maximum density per grid cell.</p>
</dd>
<dt><code>human_density</code></dt><dd><p>Matrix of human density (fraction) (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
<dt><code>dispersal_data</code></dt><dd><p>List of data frames of non-zero dispersal rates and indices for constructing a compact dispersal matrix, and optional changing rates over time, as per class <code><a href="poems.html#topic+DispersalGenerator">DispersalGenerator</a></code> <em>dispersal_data</em> attribute.</p>
</dd>
<dt><code>dispersal_target_k</code></dt><dd><p>Target population carrying capacity threshold for density dependent dispersal.</p>
</dd>
<dt><code>abundance_threshold</code></dt><dd><p>Abundance threshold (that needs to be exceeded) for each population to persist.</p>
</dd>
<dt><code>occupancy_threshold</code></dt><dd><p>Threshold for the number of populations occupied (that needs to be exceeded) for all populations to persist.</p>
</dd>
<dt><code>results_selection</code></dt><dd><p>List of results selection from: &quot;abundance&quot;, &quot;ema&quot;, &quot;extirpation&quot;, &quot;harvested&quot;, &quot;occupancy&quot;, &quot;human_density&quot;.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation results as a nested list (as selected):
</p>

<dl>
<dt><code>abundance</code></dt><dd><p>Matrix of simulation abundances (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
<dt><code>ema</code></dt><dd><p>Matrix of expected minimum abundances (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
<dt><code>extirpation</code></dt><dd><p>Array of extirpation times for each population.</p>
</dd>
<dt><code>harvested</code></dt><dd><p>Matrix of estimated individuals harvested (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
<dt><code>occupancy</code></dt><dd><p>Array of number of populations occupied at each time-step.</p>
</dd>
<dt><code>human_density</code></dt><dd><p>Matrix of human densities, (<em>populations</em> rows by <em>time_steps</em> columns).</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
library(poems)
# Ring Island example region
coordinates &lt;- data.frame(x = rep(seq(-178.02, -178.06, -0.01), 5),
                          y = rep(seq(19.02, 19.06, 0.01), each = 5))
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
sealevel_raster &lt;- template_raster
template_raster[][c(7:9, 12:14, 17:19)] &lt;- NA # make Ring Island
sealevel_raster[][c(7:9, 12:14, 17:18)] &lt;- NA
raster_stack &lt;- raster::stack(x = append(replicate(9, template_raster), sealevel_raster))
region &lt;- PaleoRegion$new(template_raster = raster_stack)

# Model template
model_template &lt;- PaleoPopModel$new(
region = region,
time_steps = 10,
years_per_step = 12, # years per generational time-step
standard_deviation = 0.1,
growth_rate_max = 0.6,
harvest = FALSE,
populations = region$region_cells,
initial_abundance = seq(9000, 0, -1000),
transition_rate = 1.0,
carrying_capacity = rep(1000, 17),
dispersal = (!diag(nrow = 17, ncol = 17))*0.05,
density_dependence = "logistic",
dispersal_target_k = 10,
occupancy_threshold = 1, 
abundance_threshold = 10,
results_selection = c("abundance")
)

# Simulations
results &lt;- paleopop_simulator(model_template) # input as PaleoPopModel object
inputs &lt;- model_template$get_attributes()
paleopop_simulator(inputs) # input as list of attributes

</code></pre>

<hr>
<h2 id='PaleoPopModel'>R6 class representing a population model for the paleopop simulator</h2><span id='topic+PaleoPopModel'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a
spatially-explicit demographic-based population model. It extends the
<code><a href="poems.html#topic+SimulationModel">poems</a></code> class with parameters for the
<code><a href="#topic+paleopop_simulator">paleopop_simulator</a></code>. It inherits functionality for creating a
nested model, whereby a nested template model with fixed parameters is
maintained when a model is cloned for various sampled parameters. Also
provided are extensions to the methods for checking the consistency and
completeness of model parameters.
</p>


<h3>Super classes</h3>

<p><code><a href="poems.html#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="poems.html#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="poems.html#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code><a href="poems.html#topic+SimulationModel">poems::SimulationModel</a></code> -&gt; <code>PaleoPopModel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>simulation_function</code></dt><dd><p>Name (character string) or source path of the default simulation function, which takes a model as an input and returns the simulation results.</p>
</dd>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="poems.html#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population coordinates (WGS84) in longitude (degrees West) and latitude (degrees North).</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>Number to seed the random number generation for stochasticity.</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>years_per_step</code></dt><dd><p>Number of years per time step.</p>
</dd>
<dt><code>populations</code></dt><dd><p>Number of population cells.</p>
</dd>
<dt><code>initial_abundance</code></dt><dd><p>Array (matrix) of initial abundance values at each population cell.</p>
</dd>
<dt><code>transition_rate</code></dt><dd><p>Rate (numeric) of transition between generations at each time-step.</p>
</dd>
<dt><code>standard_deviation</code></dt><dd><p>Standard deviation (numeric) for applying environmental stochasticity to transition rates.</p>
</dd>
<dt><code>compact_decomposition</code></dt><dd><p>List containing a compact transposed 
(Cholesky) decomposition <em>matrix</em> (t_decomposition_compact_matrix) 
and a corresponding <em>map</em> of population indices 
(t_decomposition_compact_map), as per 
<code><a href="poems.html#topic+SpatialCorrelation">SpatialCorrelation</a></code> class 
attributes.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Array (or matrix) of carrying capacity values at each population cell (across time).</p>
</dd>
<dt><code>density_dependence</code></dt><dd><p>Density dependence type (&quot;competition&quot;, &quot;logistic&quot;, or &quot;ceiling&quot;).</p>
</dd>
<dt><code>growth_rate_max</code></dt><dd><p>Maximum growth rate (utilized by density dependence processes).</p>
</dd>
<dt><code>dispersal_data</code></dt><dd><p>List of data frames of non-zero dispersal rates and
indices for constructing a compact dispersal matrix, and optional 
changing rates over time, as per class 
<code><a href="poems.html#topic+DispersalGenerator">DispersalGenerator</a></code> 
<em>dispersal_data</em> attribute.</p>
</dd>
<dt><code>dispersal_target_k</code></dt><dd><p>Target population carrying capacity threshold for density dependent dispersal.</p>
</dd>
<dt><code>harvest</code></dt><dd><p>Boolean for utilizing harvesting.</p>
</dd>
<dt><code>harvest_max</code></dt><dd><p>Proportion harvested per year (annual time scale - not generational).</p>
</dd>
<dt><code>harvest_g</code></dt><dd><p>The &quot;G&quot; parameter in the harvest function.</p>
</dd>
<dt><code>harvest_z</code></dt><dd><p>The &quot;Z&quot; parameter in the harvest function.</p>
</dd>
<dt><code>harvest_max_n</code></dt><dd><p>Maximum density per grid cell.</p>
</dd>
<dt><code>human_density</code></dt><dd><p>Matrix of human density (fraction) ($populations rows by $time_steps columns).</p>
</dd>
<dt><code>abundance_threshold</code></dt><dd><p>Abundance threshold (that needs to be exceeded) for each population to persist.</p>
</dd>
<dt><code>occupancy_threshold</code></dt><dd><p>Threshold for the number of populations occupied (that needs to be exceeded) for all populations to persist.</p>
</dd>
<dt><code>results_selection</code></dt><dd><p>List of results selection from (&quot;abundance&quot;, &quot;ema&quot;, &quot;extirpation&quot;, &quot;harvested&quot;, &quot;occupancy&quot;, &quot;human_density&quot;).</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>template_model</code></dt><dd><p>Nested template model for fixed (non-sampled) attributes for shallow cloning.</p>
</dd>
<dt><code>sample_attributes</code></dt><dd><p>Vector of sample attribute names (only).</p>
</dd>
<dt><code>required_attributes</code></dt><dd><p>Vector of required attribute names (only), i.e. those needed to run a simulation.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PaleoPopModel-list_consistency"><code>PaleoPopModel$list_consistency()</code></a>
</p>
</li>
<li> <p><a href="#method-PaleoPopModel-list_completeness"><code>PaleoPopModel$list_completeness()</code></a>
</p>
</li>
<li> <p><a href="#method-PaleoPopModel-clone"><code>PaleoPopModel$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="get_attribute_names"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-get_attribute_names'><code>poems::SimulationModel$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="get_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-get_attributes'><code>poems::SimulationModel$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="incomplete_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-incomplete_attributes'><code>poems::SimulationModel$incomplete_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="inconsistent_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-inconsistent_attributes'><code>poems::SimulationModel$inconsistent_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="initialize"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-initialize'><code>poems::SimulationModel$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="is_complete"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-is_complete'><code>poems::SimulationModel$is_complete()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="is_consistent"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-is_consistent'><code>poems::SimulationModel$is_consistent()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="new_clone"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-new_clone'><code>poems::SimulationModel$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="set_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-set_attributes'><code>poems::SimulationModel$set_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationModel" data-id="set_sample_attributes"><a href='../../poems/html/SimulationModel.html#method-SimulationModel-set_sample_attributes'><code>poems::SimulationModel$set_sample_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PaleoPopModel-list_consistency"></a>



<h4>Method <code>list_consistency()</code></h4>

<p>Returns a boolean to indicate if (optionally selected or all) model attributes (such as dimensions) are consistent.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoPopModel$list_consistency(params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Optional array of parameter/attribute names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>List of booleans (or NAs) to indicate consistency of selected/all attributes.
</p>


<hr>
<a id="method-PaleoPopModel-list_completeness"></a>



<h4>Method <code>list_completeness()</code></h4>

<p>Returns a list of booleans (or NAs) for each parameter to indicate attributes that are necessary to simulate the model have been set and are consistent/valid.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoPopModel$list_completeness()</pre></div>



<h5>Returns</h5>

<p>List of booleans (or NAs) for each parameter to indicate to indicate completeness (and consistency).
</p>


<hr>
<a id="method-PaleoPopModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoPopModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(poems)
library(raster)
# Ring Island example region
coordinates &lt;- data.frame(x = rep(seq(-178.02, -178.06, -0.01), 5),
                          y = rep(seq(19.02, 19.06, 0.01), each = 5))
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
sealevel_raster &lt;- template_raster
template_raster[][c(7:9, 12:14, 17:19)] &lt;- NA # make Ring Island
sealevel_raster[][c(7:9, 12:14, 17:18)] &lt;- NA
raster_stack &lt;- raster::stack(x = append(replicate(9, template_raster), sealevel_raster))
region &lt;- PaleoRegion$new(template_raster = raster_stack)

# Model template
template_model &lt;- PaleoPopModel$new(simulation_function = "paleopop_simulator", # the default
                                    region = region, years_per_step = 25, # default: 1 year
                                    time_steps = 10)
template_model$required_attributes # more requirements than the SimulationModel object in poems
template_model$is_complete() # the required attributes have not been filled in
template_model#is_consistent() # however, the attributes that are filled in are consistent

</code></pre>

<hr>
<h2 id='PaleoPopResults'>R6 class representing paleopop simulator results.</h2><span id='topic+PaleoPopResults'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class for encapsulating and dynamically generating
spatially-explicit <code><a href="#topic+paleopop_simulator">paleopop_simulator</a></code> results, as well as optional
re-generated <code><a href="poems.html#topic+Generator">Generator</a></code> for niche carrying capacity and/or human
density.
</p>


<h3>Super classes</h3>

<p><code><a href="poems.html#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="poems.html#topic+GenericModel">poems::GenericModel</a></code> -&gt; <code><a href="poems.html#topic+SpatialModel">poems::SpatialModel</a></code> -&gt; <code><a href="poems.html#topic+SimulationResults">poems::SimulationResults</a></code> -&gt; <code>PaleoPopResults</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>model_attributes</code></dt><dd><p>A vector of model attribute names.</p>
</dd>
<dt><code>region</code></dt><dd><p>A <code><a href="poems.html#topic+Region">Region</a></code> (or inherited class) object specifying the study region.</p>
</dd>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population coordinates (WGS84) in longitude (degrees West) and latitude (degrees North).</p>
</dd>
<dt><code>time_steps</code></dt><dd><p>Number of simulation time steps.</p>
</dd>
<dt><code>burn_in_steps</code></dt><dd><p>Optional number of initial 'burn-in' time steps to be ignored.</p>
</dd>
<dt><code>occupancy_mask</code></dt><dd><p>Optional binary mask array (matrix), data frame, or raster (stack) for each cell at each time-step of the simulation including burn-in.</p>
</dd>
<dt><code>trend_interval</code></dt><dd><p>Optional time-step range (indices) for trend calculations (assumes indices begin after the burn-in when utilized).</p>
</dd>
<dt><code>abundance</code></dt><dd><p>Matrix of population abundance across simulation time-steps (<em>populations</em> rows by <em>duration</em> columns).</p>
</dd>
<dt><code>abundance_trend</code></dt><dd><p>Trend or average Sen's <code><a href="trend.html#topic+sens.slope">slope</a></code> of total abundance (optionally across a time-step interval).</p>
</dd>
<dt><code>ema</code></dt><dd><p>Matrix of population expected minimum abundance (EMA) across simulation time-steps (<em>populations</em> rows by <em>duration</em> columns).</p>
</dd>
<dt><code>extirpation</code></dt><dd><p>Array of population extirpation times.</p>
</dd>
<dt><code>extinction_location</code></dt><dd><p>The weighted centroid of cells occupied in the time-step prior to the extirpation of all populations (if occurred).</p>
</dd>
<dt><code>harvested</code></dt><dd><p>Matrix of the number of animals harvested from each population at each time-step (<em>populations</em> rows by <em>duration</em> columns).</p>
</dd>
<dt><code>occupancy</code></dt><dd><p>Array of the number of populations occupied at each time-step.</p>
</dd>
<dt><code>carrying_capacity</code></dt><dd><p>Optional matrix of simulation input carrying capacity to be combined with results (<em>populations</em> rows by <em>duration</em> columns).</p>
</dd>
<dt><code>human_density</code></dt><dd><p>Optional matrix of simulation input human density to be combined with results (<em>populations</em> rows by <em>duration</em> columns).</p>
</dd>
<dt><code>all</code></dt><dd><p>Nested simulation results for all cells.</p>
</dd>
<dt><code>parent</code></dt><dd><p>Parent simulation results for individual cells.</p>
</dd>
<dt><code>default</code></dt><dd><p>Default value/attribute utilized when applying primitive metric functions (e.g. max) to the results.</p>
</dd>
<dt><code>attribute_aliases</code></dt><dd><p>A list of alternative alias names for model attributes (form: <code>alias = "attribute"</code>) to be used with the set and get attributes methods.</p>
</dd>
<dt><code>error_messages</code></dt><dd><p>A vector of error messages encountered when setting model attributes.</p>
</dd>
<dt><code>warning_messages</code></dt><dd><p>A vector of warning messages encountered when setting model attributes.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PaleoPopResults-clone"><code>PaleoPopResults$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute'><code>poems::GenericModel$get_attribute()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericModel" data-id="get_attribute_aliases"><a href='../../poems/html/GenericModel.html#method-GenericModel-get_attribute_aliases'><code>poems::GenericModel$get_attribute_aliases()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="get_attribute_names"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-get_attribute_names'><code>poems::SimulationResults$get_attribute_names()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="get_attributes"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-get_attributes'><code>poems::SimulationResults$get_attributes()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="initialize"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-initialize'><code>poems::SimulationResults$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="new_clone"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-new_clone'><code>poems::SimulationResults$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="SimulationResults" data-id="set_attributes"><a href='../../poems/html/SimulationResults.html#method-SimulationResults-set_attributes'><code>poems::SimulationResults$set_attributes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PaleoPopResults-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoPopResults$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
library(poems)
# Ring Island example region
coordinates &lt;- data.frame(x = rep(seq(-178.02, -178.06, -0.01), 5),
                          y = rep(seq(19.02, 19.06, 0.01), each = 5))
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
sealevel_raster &lt;- template_raster
template_raster[][c(7:9, 12:14, 17:19)] &lt;- NA # make Ring Island
sealevel_raster[][c(7:9, 12:14, 17:18)] &lt;- NA
raster_stack &lt;- raster::stack(x = append(replicate(9, template_raster), sealevel_raster))
region &lt;- PaleoRegion$new(template_raster = raster_stack)

# Model template
model_template &lt;- PaleoPopModel$new(
region = region,
time_steps = 10,
years_per_step = 12, # years per generational time-step
standard_deviation = 0.1,
growth_rate_max = 0.6,
harvest = FALSE,
populations = region$region_cells,
initial_abundance = seq(9000, 0, -1000),
transition_rate = 1.0,
carrying_capacity = rep(1000, 17),
dispersal = (!diag(nrow = 17, ncol = 17))*0.05,
density_dependence = "logistic",
dispersal_target_k = 10,
occupancy_threshold = 1, 
abundance_threshold = 10,
results_selection = c("abundance")
)

# Simulations
results &lt;- paleopop_simulator(model_template)

# Results
results_model &lt;- PaleoPopResults$new(results = results, region = region, time_steps = 10)
results_model$extirpation # cells where the population goes to zero are marked 1
results_model$occupancy # indicates with 0 and 1 which cells are occupied at each time step
results_model$ema # expected minimum abundance

</code></pre>

<hr>
<h2 id='PaleoRegion'>R6 class representing a paleontological region.</h2><span id='topic+PaleoRegion'></span>

<h3>Description</h3>

<p><code><a href="R6.html#topic+R6Class">R6</a></code> class representing a study region of temporally changing
spatial grid cells, defined via a <em>RasterLayer</em> object
(see <code><a href="raster.html#topic+raster-package">raster</a></code>) and a temporal mask indicating
which cells are included at each time step.
</p>


<h3>Super classes</h3>

<p><code><a href="poems.html#topic+GenericClass">poems::GenericClass</a></code> -&gt; <code><a href="poems.html#topic+Region">poems::Region</a></code> -&gt; <code>PaleoRegion</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>attached</code></dt><dd><p>A list of dynamically attached attributes (name-value pairs).</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>coordinates</code></dt><dd><p>Data frame (or matrix) of X-Y population (WGS84) coordinates in longitude (degrees West) and latitude (degrees North) (get and set), or distance-based coordinates dynamically returned by region raster (get only).</p>
</dd>
<dt><code>region_raster</code></dt><dd><p>A <em>RasterLayer</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) defining the region with finite values (NAs elsewhere).</p>
</dd>
<dt><code>use_raster</code></dt><dd><p>Boolean to indicate that a raster is to be used to define the region (default TRUE).</p>
</dd>
<dt><code>strict_consistency</code></dt><dd><p>Boolean to indicate that, as well as resolution, extent and CRS, consistency checks also ensure that a raster's finite/occupiable cells are the same or a subset of those defined by the region (default TRUE).</p>
</dd>
<dt><code>temporal_mask</code></dt><dd><p>Matrix of booleans indicating which region cells are included at each time step.</p>
</dd>
<dt><code>region_cells</code></dt><dd><p>Dynamically calculated number of region coordinates or raster cells with finite/non-NA values.</p>
</dd>
<dt><code>region_indices</code></dt><dd><p>Dynamically calculated region indices for raster cells with finite/non-NA values (all if not a raster).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PaleoRegion-new"><code>PaleoRegion$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PaleoRegion-raster_from_values"><code>PaleoRegion$raster_from_values()</code></a>
</p>
</li>
<li> <p><a href="#method-PaleoRegion-temporal_mask_raster"><code>PaleoRegion$temporal_mask_raster()</code></a>
</p>
</li>
<li> <p><a href="#method-PaleoRegion-clone"><code>PaleoRegion$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="poems" data-topic="GenericClass" data-id="new_clone"><a href='../../poems/html/GenericClass.html#method-GenericClass-new_clone'><code>poems::GenericClass$new_clone()</code></a></span></li>
<li><span class="pkg-link" data-pkg="poems" data-topic="Region" data-id="raster_is_consistent"><a href='../../poems/html/Region.html#method-Region-raster_is_consistent'><code>poems::Region$raster_is_consistent()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PaleoRegion-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method sets temporally changing raster layers for paleontological region.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoRegion$new(template_raster = NULL, remove_zeros = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>template_raster</code></dt><dd><p>A <em>RasterLayer</em>, <em>RasterBrick</em>, or <em>RasterStack</em> object (see <code><a href="raster.html#topic+raster-package">raster</a></code>) defining the paleontological region with example finite values (NAs elsewhere)</p>
</dd>
<dt><code>remove_zeros</code></dt><dd><p>Boolean to indicate that cells that are zero across all layers (times) are to be removed, i.e. set to NA (default is FALSE).</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed individually.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PaleoRegion-raster_from_values"></a>



<h4>Method <code>raster_from_values()</code></h4>

<p>Converts an array (or matrix) of values into a raster (or stack) consistent with the region raster (matching extent, resolution, and finite/NA cells), and with the temporal mask (if any) applied.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoRegion$raster_from_values(values)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>values</code></dt><dd><p>An array (or matrix) of values to be placed in the raster (or stack) having dimensions consistent with the region cell number.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <em>RasterLayer</em> (or <em>RasterStack/Brick</em>) object consistent with the region raster with temporal mask (if any) applied.
</p>


<hr>
<a id="method-PaleoRegion-temporal_mask_raster"></a>



<h4>Method <code>temporal_mask_raster()</code></h4>

<p>Returns the temporal mask as a raster stack/brick object consistent with the region raster.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoRegion$temporal_mask_raster()</pre></div>



<h5>Returns</h5>

<p>A <em>RasterStack/Brick</em>) object with temporal mask values of 1 (true) and NA elsewhere.
</p>


<hr>
<a id="method-PaleoRegion-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PaleoRegion$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>library(poems)
library(raster)
# Ring Island example region
coordinates &lt;- data.frame(x = rep(seq(-178.02, -178.06, -0.01), 5),
                          y = rep(seq(19.02, 19.06, 0.01), each = 5))
template_raster &lt;- Region$new(coordinates = coordinates)$region_raster # full extent
sealevel_raster &lt;- template_raster
template_raster[][c(7:9, 12:14, 17:19)] &lt;- NA # make Ring Island
sealevel_raster[][c(7:9, 12:14, 17:18)] &lt;- NA
raster_stack &lt;- raster::stack(x = append(replicate(9, template_raster), sealevel_raster))
region &lt;- PaleoRegion$new(template_raster = raster_stack)
raster::plot(region$temporal_mask_raster()[[1]], main = "Ring Island (first timestep)",
             xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
             colNA = "blue", legend = FALSE)
raster::plot(region$temporal_mask_raster()[[10]], main = "Ring Island (last timestep)",
             xlab = "Longitude (degrees)", ylab = "Latitude (degrees)",
             colNA = "blue", legend = FALSE)

</code></pre>

<hr>
<h2 id='region_subset'>Function generates a region subset of matrix values based on a subset of coordinates within the original region (using nearest spatial neighbor if coordinates differ).</h2><span id='topic+region_subset'></span>

<h3>Description</h3>

<p><code>region_subset</code> generates a region subset of matrix values based on a subset of coordinates within the original region (using nearest spatial neighbor if coordinates differ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>region_subset(orig_coords = NULL, orig_matrix = NULL, subset_coords = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="region_subset_+3A_orig_coords">orig_coords</code></td>
<td>
<p>Data frame (or matrix) of original/full region of X-Y coordinates (WGS84) in longitude (degrees West) and latitude (degrees North).</p>
</td></tr>
<tr><td><code id="region_subset_+3A_orig_matrix">orig_matrix</code></td>
<td>
<p>Matrix of original values with rows corresponding to the original/full region coordinates.</p>
</td></tr>
<tr><td><code id="region_subset_+3A_subset_coords">subset_coords</code></td>
<td>
<p>Data frame (or matrix) of X-Y subset region coordinates (WGS84) in longitude (degrees West) and latitude (degrees North).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of values corresponding to the subset region coordinates (using nearest spatial neighbor if original and subset coordinates differ).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordinates &lt;- data.frame(x = rep(seq(-178.02, -178.06, -0.01), 5),
                          y = rep(seq(19.02, 19.06, 0.01), each = 5))
values &lt;- matrix(seq(1, 25, 1))
subset &lt;- data.frame(x = rep(seq(-178, -178.04, -0.005), 7), 
                     y = rep(seq(19.03, 19.06, 0.005), each = 9))
region_subset(coordinates, values, subset) # nearest neighbor interpolation

</code></pre>

<hr>
<h2 id='siberia_raster'>Bison vignette Siberia raster</h2><span id='topic+siberia_raster'></span>

<h3>Description</h3>

<p>A <code>raster</code> dataset defining the grid cells of the Siberia study region in a temporally dynamic manner for the
bison example vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siberia_raster
</code></pre>


<h3>Format</h3>

<p>A <em>raster::RasterStack</em> object:
</p>

<dl>
<dt>dimensions</dt><dd><p>21 rows by 180 columns by 1001 layers</p>
</dd>
<dt>resolution</dt><dd><p>2 by 2 degree grid cells</p>
</dd>
<dt>crs</dt><dd><p>WGS84 latitude longitude</p>
</dd>
<dt>extent</dt><dd><p>longitude -180 to 180 degrees; latitude 42 to 84 degrees</p>
</dd>
<dt>values</dt><dd><p>region defined by 913 cells with value of 1, surrounded by non-region <code>NA</code> values</p>
</dd>
</dl>



<h3>Source</h3>

<p>TBA
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
