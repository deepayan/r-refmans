<!DOCTYPE html><html><head><title>Help for package graphicalExtremes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graphicalExtremes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#graphicalExtremes'><p>graphicalExtremes: Statistical methodology for graphical extreme value models.</p></a></li>
<li><a href='#censor'><p>Censor dataset</p></a></li>
<li><a href='#check_graph'><p>Check input graph</p></a></li>
<li><a href='#check_partial_matrix_and_graph'><p>Check input graph and partial matrix</p></a></li>
<li><a href='#check_split_by_sep'><p>Identify pairs of vertices that are split by a separator</p></a></li>
<li><a href='#checkGamma'><p>HR parameter matrix checks</p></a></li>
<li><a href='#chi2Gamma'><p>Transformation between <code class="reqn">\chi</code> and <code class="reqn">\Gamma</code></p></a></li>
<li><a href='#complete_Gamma'><p>Completion of Gamma matrices</p></a></li>
<li><a href='#complete_Gamma_decomposable'><p>Completion of decomposable Gamma matrices</p></a></li>
<li><a href='#complete_Gamma_general'><p>Non-decomposable completion of variogram matrices</p></a></li>
<li><a href='#complete_Gamma_general_demo'><p>DEMO-VERSION: Completion of non-decomposable Gamma matrices</p></a></li>
<li><a href='#complete_Gamma_general_split'><p>Non-decomposable completion of variogram matrices</p></a></li>
<li><a href='#complete_Gamma_one_step'><p>Completion of two-clique decomposable Gamma matrices</p></a></li>
<li><a href='#computeLimits'><p>Compute plot limits</p></a></li>
<li><a href='#danube'><p>Upper Danube basin dataset</p></a></li>
<li><a href='#data2mpareto'><p>Data standardization to multivariate Pareto scale</p></a></li>
<li><a href='#eglatent'><p>Learning extremal graph structure with latent variables</p></a></li>
<li><a href='#eglearn'><p>Learning extremal graph structure</p></a></li>
<li><a href='#emp_chi'><p>Empirical estimation of extremal correlation matrix <code class="reqn">\chi</code></p></a></li>
<li><a href='#emp_chi_multdim'><p>Empirical estimation of extremal correlation <code class="reqn">\chi</code></p></a></li>
<li><a href='#emp_vario'><p>Estimation of the variogram matrix <code class="reqn">\Gamma</code> of a Huesler-Reiss distribution</p></a></li>
<li><a href='#emst'><p>Fitting extremal minimum spanning tree</p></a></li>
<li><a href='#emtp2'><p>Performs Gaussian likelihood optimization under Laplacian matrix constraints.</p></a></li>
<li><a href='#ensure_matrix_symmetry'><p>Ensure numerical matrix symmetry/zero values</p></a></li>
<li><a href='#fast_diag'><p>Fast computation of diag(y %<em>% M %</em>% t(y))</p></a></li>
<li><a href='#fillFixedParams'><p>Helper function to combine par with fixed params (in init)</p></a></li>
<li><a href='#findVsep'><p>Find a separator set for two vertices</p></a></li>
<li><a href='#fit_graph_to_Theta'><p>Experimental: Fit graph using empirical Theta matrix</p></a></li>
<li><a href='#fitInInterval'><p>Fit value(s) in interval</p></a></li>
<li><a href='#flightCountMatrixToConnectionList'><p>Convert flight counts to connection list</p></a></li>
<li><a href='#flights'><p>Flights delay data</p></a></li>
<li><a href='#fmpareto_graph_HR'><p>Parameter fitting for Huesler-Reiss graphical models</p></a></li>
<li><a href='#fmpareto_graph_HR_clique_average'><p>HR Parameter fitting - Helper functions</p></a></li>
<li><a href='#fmpareto_HR_MLE'><p>Parameter fitting for multivariate Huesler-Reiss Pareto distribution</p></a></li>
<li><a href='#Gamma2chi_3D'><p>Compute theoretical <code class="reqn">\chi</code> in 3D</p></a></li>
<li><a href='#Gamma2graph'><p>Convert matrix to graph</p></a></li>
<li><a href='#Gamma2Sigma'><p>Conversion between Huesler-Reiss parameter matrices</p></a></li>
<li><a href='#generate_random_chordal_graph'><p>Generate random graphs</p></a></li>
<li><a href='#generate_random_Gamma'><p>Generate a random Gamma matrix</p></a></li>
<li><a href='#generate_random_graphical_Gamma'><p>Generate a random Gamma matrix for a given graph</p></a></li>
<li><a href='#generate_random_integer_Gamma'><p>Generate a random Gamma matrix containing only integers</p></a></li>
<li><a href='#generate_random_model'><p>Generate random Huesler-Reiss Models</p></a></li>
<li><a href='#generate_random_spd_matrix'><p>Generate a random symmetric positive definite matrix</p></a></li>
<li><a href='#get_alert_function'><p>Get alert function</p></a></li>
<li><a href='#get_cliques_and_separators'><p>Get Cliques and Separators of a graph</p></a></li>
<li><a href='#get_cliques_and_separators_OLD'><p>Get Cliques and Separators of a graph</p></a></li>
<li><a href='#get_mc_cores'><p>Number of cores to be used in parallel computations</p></a></li>
<li><a href='#get_small_tol'><p>Tolerances to be used in computations</p></a></li>
<li><a href='#getDanubeFlowGraph'><p>Get Danube flow graph</p></a></li>
<li><a href='#getFlightDelayData'><p>Get filtered flight delays</p></a></li>
<li><a href='#getFlightGraph'><p>Get flight graph</p></a></li>
<li><a href='#getPackageData'><p>Get package data</p></a></li>
<li><a href='#getSubMatrixForSubgraph'><p>Get the submatrix corresponding to a subgraph</p></a></li>
<li><a href='#graphs_equal'><p>Graph equality</p></a></li>
<li><a href='#logdV_HR'><p>Compute the exponent measure density of HR distribution</p></a></li>
<li><a href='#logdVK_HR'><p>Compute censored exponent measure</p></a></li>
<li><a href='#logLH_HR'><p>Full censored log-likelihood of HR model</p></a></li>
<li><a href='#loglik_HR'><p>Compute Huesler-Reiss log-likelihood, AIC, and BIC</p></a></li>
<li><a href='#make_numeric_indices'><p>Convert indices to numerical indices</p></a></li>
<li><a href='#make_sep_list'><p>Create a list of separators</p></a></li>
<li><a href='#mparetomargins'><p>Marginalize multivariate Pareto dataset</p></a></li>
<li><a href='#order_cliques'><p>Order Cliques</p></a></li>
<li><a href='#par2Matrix'><p>Create Gamma or Theta from vector</p></a></li>
<li><a href='#parToMatricesFactory'><p>Factory: parToMatrices</p></a></li>
<li><a href='#plotDanube'><p>Plot Danube River Flow Data</p></a></li>
<li><a href='#plotFlights'><p>Plot flight data</p></a></li>
<li><a href='#rmpareto'><p>Sampling of a multivariate Pareto distribution</p></a></li>
<li><a href='#rmpareto_tree'><p>Sampling of a multivariate Pareto distribution on a tree</p></a></li>
<li><a href='#rmstable'><p>Sampling of a multivariate max-stable distribution</p></a></li>
<li><a href='#rmstable_tree'><p>Sampling of a multivariate max-stable distribution on a tree</p></a></li>
<li><a href='#simu_px_dirichlet'><p>Simulate Dirichlet extremal functions</p></a></li>
<li><a href='#simu_px_HR'><p>Simulate HR extremal functions</p></a></li>
<li><a href='#simu_px_logistic'><p>Simulate logistic extremal functions</p></a></li>
<li><a href='#simu_px_neglogistic'><p>Simulate negative logistic extremal functions</p></a></li>
<li><a href='#simu_px_tree_dirichlet'><p>Simulate Dirichlet extremal functions on a tree</p></a></li>
<li><a href='#simu_px_tree_HR'><p>Simulate HR extremal functions on a tree</p></a></li>
<li><a href='#simu_px_tree_logistic'><p>Simulate logistic extremal functions on a tree</p></a></li>
<li><a href='#split_graph'><p>Split graph into invariant subgraphs</p></a></li>
<li><a href='#unif'><p>Uniform margin</p></a></li>
<li><a href='#V_HR'><p>Compute exponent measure</p></a></li>
<li><a href='#Zmatrix'><p>Computes the Z-matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Methodology for Graphical Extreme Value Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Engelke &lt;sebastian.engelke@unige.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical methodology for sparse multivariate extreme value models. Methods are
             provided for exact simulation and statistical inference for multivariate Pareto distributions
             on graphical structures as described in the paper 'Graphical Models for Extremes' by
             Engelke and Hitz (2020) &lt;<a href="https://doi.org/10.1111%2Frssb.12355">doi:10.1111/rssb.12355</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>bzip2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown, dplyr, ggplot2,
bookdown, maps</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 1.2.4.1), mvtnorm (&ge; 1.0.10), Rdpack, stats (&ge;
3.6.0), utils, corpcor, osqp, glmnet, glassoFast, edmcr, CVXR</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sebastian-engelke/graphicalExtremes">https://github.com/sebastian-engelke/graphicalExtremes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sebastian-engelke/graphicalExtremes/issues">https://github.com/sebastian-engelke/graphicalExtremes/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-18 14:18:13 UTC; Manuel</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Engelke [aut, cre],
  Adrien S. Hitz [aut],
  Nicola Gnecco [aut],
  Manuel Hentschel [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-18 16:43:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='graphicalExtremes'>graphicalExtremes: Statistical methodology for graphical extreme value models.</h2><span id='topic+graphicalExtremes'></span><span id='topic+_PACKAGE'></span><span id='topic+graphicalExtremes-package'></span>

<h3>Description</h3>

<p>An implementation of the statistical methodology paper Engelke and Hitz (2020) for sparse
multivariate extreme value models.
Includes exact simulation algorithms and statistical
inference methods for multivariate Pareto distributions on graphical structures.
Also contains implementations of statistical methods from
Engelke and Volgushev (2022), Röttger et al. (2021), and Hentschel et al. (2022).
</p>


<h3>Details</h3>

<p>The following global options are used by functions in the package.
Their values can be changed using <code><a href="base.html#topic+options">base::options()</a></code>.
</p>

<dl>
<dt><code>"graphicalExtremes.mc.cores"</code></dt><dd>
<p>The (maximal) number of cores to use in parallel tasks.
Will always be overwritten by 1 on Windows.
</p>
</dd>
<dt><code>"graphicalExtremes.tol.small"</code></dt><dd>
<p>The &quot;small&quot; tolerance is used in internal computations for values that should
mathematically be exactly <strong>equal to zero</strong>, but deviate due to inherent
limitations of numerical computations. This value is used e.g. when checking
matrices for symmetry and definiteness.
In general, this value is used only as a &quot;permissive&quot; tolerance, in the sense
that if a value has to be positive, it is compared to actual zero, but if
it has to be zero, its absolute value is compared to this tolerance.
</p>
</dd>
<dt><code>"graphicalExtremes.tol.large"</code></dt><dd>
<p>The &quot;large&quot; tolerance is used for values that <strong>converge to zero</strong>, but are
mathematically not supposed to be equal to zero. This value is used e.g.
when converting a precision matrix <code class="reqn">\Theta</code> to an adjacency matrix of a graph.
</p>
</dd>
<dt><code style="white-space: pre;">&#8288;"graphicalExtremes.default.alert&#8288;</code></dt><dd>
<p>The default alert function to be used in validity checks of Huesler-Reiss parameter matrix transformations.
Can be a function that takes an arbitrary number of strings as arguments (e.g. <code>cat()</code>, <code>stop()</code>),
<code>FALSE</code> to ignore the alerts, or <code>TRUE</code>/<code>NULL</code> to use the default function <code>warning()</code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sebastian Engelke <a href="mailto:sebastian.engelke@unige.ch">sebastian.engelke@unige.ch</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Adrien S. Hitz
</p>
</li>
<li><p> Nicola Gnecco
</p>
</li>
<li><p> Manuel Hentschel
</p>
</li></ul>



<h3>References</h3>

<p>Engelke S, Hitz AS (2020).
&ldquo;Graphical models for extremes (with discussion).&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>82</b>, 871&ndash;932.<br /><br /> Engelke S, Volgushev S (2022).
&ldquo;Structure learning for extremal tree models.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>.
<a href="https://doi.org/10.1111/rssb.12556">doi:10.1111/rssb.12556</a>, Forthcoming, https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.12556.<br /><br /> Hentschel M, Engelke S, Segers J (2022).
&ldquo;Statistical Inference for Hüsler-Reiss Graphical Models Through Matrix Completions.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2210.14292">doi:10.48550/ARXIV.2210.14292</a>, <a href="https://arxiv.org/abs/2210.14292">https://arxiv.org/abs/2210.14292</a>.<br /><br /> Röttger F, Engelke S, Zwiernik P (2021).
&ldquo;Total positivity in multivariate extremes.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2112.14727">doi:10.48550/ARXIV.2112.14727</a>, <a href="https://arxiv.org/abs/2112.14727">https://arxiv.org/abs/2112.14727</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/sebastian-engelke/graphicalExtremes">https://github.com/sebastian-engelke/graphicalExtremes</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sebastian-engelke/graphicalExtremes/issues">https://github.com/sebastian-engelke/graphicalExtremes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='censor'>Censor dataset</h2><span id='topic+censor'></span>

<h3>Description</h3>

<p>Censors each row of matrix <code>x</code> with vector <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="censor_+3A_x">x</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix.</p>
</td></tr>
<tr><td><code id="censor_+3A_p">p</code></td>
<td>
<p>Numeric vector with <code>d</code> elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix.
</p>

<hr>
<h2 id='check_graph'>Check input graph</h2><span id='topic+check_graph'></span>

<h3>Description</h3>

<p>Checks that the input graph is a valid graph for an extremal graphical model.
If necessary, converts the graph to an undirected graph.
Removes vertex labels if present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_graph(
  graph,
  graph_type = c("general", "decomposable", "block", "tree"),
  check_connected = TRUE,
  nVertices = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_graph_+3A_graph">graph</code></td>
<td>
<p>An [<code>igraph::graph</code>] object.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_graph_type">graph_type</code></td>
<td>
<p><code>"general"</code>, <code>"decomposable"</code>, <code>"block"</code>, <code>"tree"</code>. The required type of graph.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_check_connected">check_connected</code></td>
<td>
<p>Whether to check if the graph is connected.</p>
</td></tr>
<tr><td><code id="check_graph_+3A_nvertices">nVertices</code></td>
<td>
<p>The number of vertices required in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given <code>graph</code>, if necessary converted to undirected.
If the graph is not valid an error is thrown.
</p>


<h3>See Also</h3>

<p>Other input validation functions:
<code><a href="#topic+checkGamma">checkGamma</a>()</code>,
<code><a href="#topic+check_partial_matrix_and_graph">check_partial_matrix_and_graph</a>()</code>,
<code><a href="#topic+ensure_matrix_symmetry">ensure_matrix_symmetry</a>()</code>
</p>

<hr>
<h2 id='check_partial_matrix_and_graph'>Check input graph and partial matrix</h2><span id='topic+check_partial_matrix_and_graph'></span>

<h3>Description</h3>

<p>Checks and converts the partial matrix and graph given for a
HR graphical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_partial_matrix_and_graph(M, graph = NULL, graph_type = "general")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_partial_matrix_and_graph_+3A_m">M</code></td>
<td>
<p>A partial matrix or a vector of entries corresponding to the edges of <code>graph</code></p>
</td></tr>
<tr><td><code id="check_partial_matrix_and_graph_+3A_graph">graph</code></td>
<td>
<p>A graph object or <code>NULL</code> if the graph structure is implied by the <code>NA</code> structure of <code>M</code></p>
</td></tr>
<tr><td><code id="check_partial_matrix_and_graph_+3A_graph_type">graph_type</code></td>
<td>
<p>Passed to <code><a href="#topic+check_graph">check_graph()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of
</p>
<table>
<tr><td><code>matrix</code></td>
<td>
<p>The matrix given as input or implied by the input</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>The graph given as input or implied by the input</p>
</td></tr>
</table>
<p>Throws an error if the input is not valid.
</p>


<h3>See Also</h3>

<p>Other input validation functions:
<code><a href="#topic+checkGamma">checkGamma</a>()</code>,
<code><a href="#topic+check_graph">check_graph</a>()</code>,
<code><a href="#topic+ensure_matrix_symmetry">ensure_matrix_symmetry</a>()</code>
</p>

<hr>
<h2 id='check_split_by_sep'>Identify pairs of vertices that are split by a separator</h2><span id='topic+check_split_by_sep'></span>

<h3>Description</h3>

<p>Identify pairs of vertices that are split by a separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_split_by_sep(graph, sep, edgeMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_split_by_sep_+3A_graph">graph</code></td>
<td>
<p>A graph</p>
</td></tr>
<tr><td><code id="check_split_by_sep_+3A_sep">sep</code></td>
<td>
<p>A set of vertex ids that are used to split the graph</p>
</td></tr>
<tr><td><code id="check_split_by_sep_+3A_edgemat">edgeMat</code></td>
<td>
<p>A two-column matrix, containing the vertex-paris to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, indicating for each edge whether it is split by <code>sep</code>
</p>

<hr>
<h2 id='checkGamma'>HR parameter matrix checks</h2><span id='topic+checkGamma'></span><span id='topic+checkSigmaTheta'></span><span id='topic+checkTheta'></span><span id='topic+checkSigma'></span><span id='topic+checkMatrix'></span><span id='topic+is_valid_Gamma'></span><span id='topic+is_valid_Theta'></span><span id='topic+is_valid_Sigma'></span>

<h3>Description</h3>

<p>Checks whether the matrix given is a valid Huesler-Reiss parameter matrix
in the role of <code class="reqn">\Gamma</code>, <code class="reqn">\Theta</code>, or <code class="reqn">\Sigma</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkGamma(Gamma, alert = NULL, tol = get_small_tol(), returnBoolean = FALSE)

checkSigmaTheta(
  M,
  k,
  full,
  matrixName = "Sigma",
  tol = get_small_tol(),
  alert = NULL,
  returnBoolean = FALSE
)

checkTheta(
  Theta,
  k = NULL,
  full = FALSE,
  tol = get_small_tol(),
  alert = NULL,
  returnBoolean = FALSE
)

checkSigma(
  Sigma,
  k = NULL,
  full = FALSE,
  tol = get_small_tol(),
  alert = NULL,
  returnBoolean = FALSE
)

checkMatrix(
  M,
  name = c("Gamma", "Sigma", "Theta")[1],
  k = NULL,
  full = FALSE,
  tol = get_small_tol(),
  alert = NULL,
  returnBoolean = FALSE
)

is_valid_Gamma(M, tol = get_small_tol())

is_valid_Theta(Theta, k = NULL, full = FALSE, tol = get_small_tol())

is_valid_Sigma(Sigma, k = NULL, full = FALSE, tol = get_small_tol())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkGamma_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_alert">alert</code></td>
<td>
<p>Passed to <code>get_alert_function</code>: <code>NULL</code> or <code>TRUE</code> to read the option value,
<code>FALSE</code> to return a dummy function, or a function that takes an arbitrary number of strings as arguments (e.g. <code>stop()</code>).</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar. Values below this are considered as zero,
when zeros are required (e.g. row-sums).</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_returnboolean">returnBoolean</code></td>
<td>
<p>Logical scalar, set to <code>TRUE</code> to return a boolean instead of the (adjusted) input.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_m">M</code></td>
<td>
<p>Numeric matrix, <code class="reqn">\Gamma</code>, <code class="reqn">\Sigma</code>, or <code class="reqn">\Theta</code>.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_k">k</code></td>
<td>
<p><code>NULL</code> if the input/output matrix is <code class="reqn">\Sigma</code>/<code class="reqn">\Theta</code>.
Else, an integer between 1 and d indicating the value of k in <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_full">full</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>!is.null(k)</code>,
the input/output matrix is a <code class="reqn">d \times d</code> matrix with the kth row filled with zeros.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_matrixname">matrixName</code></td>
<td>
<p>Name of the matrix to be used in alerts/error messages.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_theta">Theta</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> precision matrix.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_sigma">Sigma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> covariance matrix.</p>
</td></tr>
<tr><td><code id="checkGamma_+3A_name">name</code></td>
<td>
<p>Name of the input matrix, indicating which other function to call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code style="white-space: pre;">&#8288;is_valid_*&#8288;</code> are a wrapper around <code style="white-space: pre;">&#8288;check*&#8288;</code>, with arguments
<code>alert=FALSE</code> and <code>returnBoolean=TRUE</code>.
</p>


<h3>Value</h3>

<p>For <code style="white-space: pre;">&#8288;check*&#8288;</code>, the input matrix, passed through <code><a href="#topic+ensure_matrix_symmetry_and_truncate_zeros">ensure_matrix_symmetry_and_truncate_zeros</a></code>.
</p>
<p>For <code style="white-space: pre;">&#8288;is_valid_*&#8288;</code>, a boolean indicating whether the input is a valid parameter matrix.
</p>


<h3>See Also</h3>

<p>Other input validation functions:
<code><a href="#topic+check_graph">check_graph</a>()</code>,
<code><a href="#topic+check_partial_matrix_and_graph">check_partial_matrix_and_graph</a>()</code>,
<code><a href="#topic+ensure_matrix_symmetry">ensure_matrix_symmetry</a>()</code>
</p>

<hr>
<h2 id='chi2Gamma'>Transformation between <code class="reqn">\chi</code> and <code class="reqn">\Gamma</code></h2><span id='topic+chi2Gamma'></span><span id='topic+Gamma2chi'></span>

<h3>Description</h3>

<p>Transforms between the extremal correlation <code class="reqn">\chi</code> and the variogram <code class="reqn">\Gamma</code>.
Only valid for Huesler-Reiss distributions.
Done element-wise, no checks of the entire matrix structure are performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi2Gamma(chi)

Gamma2chi(Gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi2Gamma_+3A_chi">chi</code></td>
<td>
<p>Numeric vector or matrix with entries between 0 and 1.</p>
</td></tr>
<tr><td><code id="chi2Gamma_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric vector or matrix with non-negative entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for transformation from <code class="reqn">\chi</code> to <code class="reqn">\Gamma</code> is element-wise
</p>
<p style="text-align: center;"><code class="reqn">\Gamma = (2 \Phi^{-1}(1 - 0.5 \chi))^2,</code>
</p>

<p>where <code class="reqn">\Phi^{-1}</code> is the inverse of the standard normal distribution function.
</p>
<p>The formula for transformation from <code class="reqn">\Gamma</code> to <code class="reqn">\chi</code> is element-wise
</p>
<p style="text-align: center;"><code class="reqn">\chi = 2 - 2 \Phi(\sqrt{\Gamma} / 2),</code>
</p>

<p>where <code class="reqn">\Phi</code> is the standard normal distribution function.
</p>


<h3>Value</h3>

<p>Numeric vector or matrix containing the implied <code class="reqn">\Gamma</code>.
</p>
<p>Numeric vector or matrix containing the implied <code class="reqn">\chi</code>.
</p>


<h3>See Also</h3>

<p>Other parameter matrix transformations:
<code><a href="#topic+Gamma2Sigma">Gamma2Sigma</a>()</code>,
<code><a href="#topic+Gamma2graph">Gamma2graph</a>()</code>,
<code><a href="#topic+par2Matrix">par2Matrix</a>()</code>
</p>

<hr>
<h2 id='complete_Gamma'>Completion of Gamma matrices</h2><span id='topic+complete_Gamma'></span>

<h3>Description</h3>

<p>Given a <code>graph</code> and a (partial) variogram matrix <code>Gamma</code>, returns a full
variogram matrix that agrees with <code>Gamma</code> in entries corresponding to edges
of <code>graph</code> and whose corresponding precision matrix, obtained by
<code><a href="#topic+Gamma2Theta">Gamma2Theta()</a></code>, has zeros in entries corresponding to non-edges of <code>graph</code>.
For results on the existence and uniqueness of this completion, see
Hentschel et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma(Gamma, graph = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_Gamma_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="complete_Gamma_+3A_graph">graph</code></td>
<td>
<p><code>NULL</code> or <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object. If <code>NULL</code>, the graph
is implied by non-edge entries in <code>Gamma</code> being <code>NA</code>. Must be connected, undirected.</p>
</td></tr>
<tr><td><code id="complete_Gamma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+complete_Gamma_general_split">complete_Gamma_general_split()</a></code> if <code>graph</code>
is not decomposable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>graph</code> is decomposable, <code>Gamma</code> only needs to be specified on
the edges of the graph, other entries are ignored.
If <code>graph</code> is not decomposable, the graphical completion algorithm requires
a fully specified (but non-graphical) variogram matrix <code>Gamma</code> to begin with.
If necessary, this initial completion is computed using <code><a href="edmcr.html#topic+npf">edmcr::npf()</a></code>.
</p>


<h3>Value</h3>

<p>Completed <code class="reqn">d \times d</code> variogram matrix.
</p>


<h3>References</h3>

<p>Hentschel M, Engelke S, Segers J (2022).
&ldquo;Statistical Inference for Hüsler-Reiss Graphical Models Through Matrix Completions.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2210.14292">doi:10.48550/ARXIV.2210.14292</a>, <a href="https://arxiv.org/abs/2210.14292">https://arxiv.org/abs/2210.14292</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gamma2Theta">Gamma2Theta()</a></code>
</p>
<p>Other matrix completion related topics:
<code><a href="#topic+complete_Gamma_decomposable">complete_Gamma_decomposable</a>()</code>,
<code><a href="#topic+complete_Gamma_general_demo">complete_Gamma_general_demo</a>()</code>,
<code><a href="#topic+complete_Gamma_general_split">complete_Gamma_general_split</a>()</code>,
<code><a href="#topic+complete_Gamma_general">complete_Gamma_general</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Block graph:
Gamma &lt;- rbind(
  c(0, .5, NA, NA),
  c(.5, 0, 1, 1.5),
  c(NA, 1, 0, .8),
  c(NA, 1.5, .8, 0)
)

complete_Gamma(Gamma)

## Alternative representation of the same completion problem:
my_graph &lt;- igraph::graph_from_adjacency_matrix(rbind(
  c(0, 1, 0, 0),
  c(1, 0, 1, 1),
  c(0, 1, 0, 1),
  c(0, 1, 1, 0)
), mode = "undirected")
Gamma_vec &lt;- c(.5, 1, 1.5, .8)
complete_Gamma(Gamma_vec, my_graph)

## Decomposable graph:
G &lt;- rbind(
c(0, 5, 7, 6, NA),
c(5, 0, 14, 15, NA),
c(7, 14, 0, 5, 5),
c(6, 15, 5, 0, 6),
c(NA, NA, 5, 6, 0)
)

complete_Gamma(G)

## Non-decomposable graph:
G &lt;- rbind(
c(0, 5, 7, 6, 6),
c(5, 0, 14, 15, 13),
c(7, 14, 0, 5, 5),
c(6, 15, 5, 0, 6),
c(6, 13, 5, 6, 0)
)
g &lt;- igraph::make_ring(5)

complete_Gamma(G, g)


</code></pre>

<hr>
<h2 id='complete_Gamma_decomposable'>Completion of decomposable Gamma matrices</h2><span id='topic+complete_Gamma_decomposable'></span>

<h3>Description</h3>

<p>Given a decomposable <code>graph</code> and incomplete variogram matrix <code>Gamma</code>,
returns the full <code>Gamma</code> matrix implied by the conditional independencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma_decomposable(Gamma, graph = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_Gamma_decomposable_+3A_gamma">Gamma</code></td>
<td>
<p>A variogram matrix that is specified on the edges of <code>graph</code>
and the diagonals. All other entries are ignored (if <code>graph</code> is specified),
or should be <code>NA</code> to indicate non-edges in <code>graph</code>.</p>
</td></tr>
<tr><td><code id="complete_Gamma_decomposable_+3A_graph">graph</code></td>
<td>
<p><code>NULL</code> or a decomposable [<code>igraph::graph</code>] object. If <code>NULL</code>, the
structure of <code>NA</code> entries in <code>Gamma</code> is used instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complete variogram matrix that agrees with <code>Gamma</code> on the entries
corresponding to edges in <code>graph</code> and the diagonals.
The corresponding <code class="reqn">\Theta</code> matrix produced by <code><a href="#topic+Gamma2Theta">Gamma2Theta()</a></code> has zeros
in the remaining entries.
</p>


<h3>See Also</h3>

<p>Other matrix completion related topics:
<code><a href="#topic+complete_Gamma_general_demo">complete_Gamma_general_demo</a>()</code>,
<code><a href="#topic+complete_Gamma_general_split">complete_Gamma_general_split</a>()</code>,
<code><a href="#topic+complete_Gamma_general">complete_Gamma_general</a>()</code>,
<code><a href="#topic+complete_Gamma">complete_Gamma</a>()</code>
</p>

<hr>
<h2 id='complete_Gamma_general'>Non-decomposable completion of variogram matrices</h2><span id='topic+complete_Gamma_general'></span>

<h3>Description</h3>

<p>Given a non-decomposable <code>graph</code>, and (non-graphical) variogram matrix <code>Gamma</code>,
modifies <code>Gamma</code> in non-edge entries, such that the resulting matrix is a
variogram matrix with graphical structure described by <code>graph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma_general(
  Gamma,
  graph,
  N = 10000,
  tol = get_large_tol(),
  check_tol = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_Gamma_general_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_+3A_graph">graph</code></td>
<td>
<p><code>igraph::graph()</code> object.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_+3A_n">N</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar. Tolerance to be used when completing submatrices.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_+3A_check_tol">check_tol</code></td>
<td>
<p>Numeric/integer scalar. How often to check the tolerance when completing submatrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A completed <code class="reqn">d \times d</code> variogram matrix.
</p>


<h3>See Also</h3>

<p>Other matrix completion related topics:
<code><a href="#topic+complete_Gamma_decomposable">complete_Gamma_decomposable</a>()</code>,
<code><a href="#topic+complete_Gamma_general_demo">complete_Gamma_general_demo</a>()</code>,
<code><a href="#topic+complete_Gamma_general_split">complete_Gamma_general_split</a>()</code>,
<code><a href="#topic+complete_Gamma">complete_Gamma</a>()</code>
</p>

<hr>
<h2 id='complete_Gamma_general_demo'>DEMO-VERSION: Completion of non-decomposable Gamma matrices</h2><span id='topic+complete_Gamma_general_demo'></span>

<h3>Description</h3>

<p>Given a <code>graph</code> and variogram matrix <code>Gamma</code>, returns the full <code>Gamma</code>
matrix implied by the conditional independencies.
DEMO VERSION: Returns a lot of details and allows specifying the graph list
that is used. Is way slower than other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma_general_demo(Gamma, graph, N = 1000, tol = 0, gList = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_Gamma_general_demo_+3A_gamma">Gamma</code></td>
<td>
<p>A complete variogram matrix (without any graphical structure).</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_demo_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_demo_+3A_n">N</code></td>
<td>
<p>The maximal number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_demo_+3A_tol">tol</code></td>
<td>
<p>The tolerance to use when checking for zero entries in <code>Theta</code>.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_demo_+3A_glist">gList</code></td>
<td>
<p>A list of graphs to be used instead of the output from <code><a href="#topic+make_sep_list">make_sep_list()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list, containing the following details.
The &quot;error term&quot; is the maximal absolute value of <code>Theta</code> in a non-edge entry.
</p>
<table>
<tr><td><code>graph</code>, <code>N</code>, <code>tol</code></td>
<td>
<p>As in the input</p>
</td></tr>
<tr><td><code>gList</code></td>
<td>
<p>As in the input or computed by <code><a href="#topic+make_sep_list">make_sep_list()</a></code>.</p>
</td></tr>
<tr><td><code>Gamma0</code>, <code>Theta0</code>, <code>err0</code></td>
<td>
<p>Initial <code>Gamma</code>, <code>Theta</code>, and error term.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>

<p>A nested list, containing the following infos for each performed iteration:
</p>

<dl>
<dt><code>n</code></dt><dd><p>Number of the iteration</p>
</dd>
<dt><code>t</code></dt><dd><p>Corresponding index in <code>gList</code></p>
</dd>
<dt><code>g</code></dt><dd><p>The graph used</p>
</dd>
<dt><code>Gamma</code>, <code>Theta</code>, <code>err</code></dt><dd><p>The value of <code>Gamma</code>, <code>Theta</code>, and error term after the iteration</p>
</dd>
</dl>

</td></tr>
</table>


<h3>See Also</h3>

<p>Other matrix completion related topics:
<code><a href="#topic+complete_Gamma_decomposable">complete_Gamma_decomposable</a>()</code>,
<code><a href="#topic+complete_Gamma_general_split">complete_Gamma_general_split</a>()</code>,
<code><a href="#topic+complete_Gamma_general">complete_Gamma_general</a>()</code>,
<code><a href="#topic+complete_Gamma">complete_Gamma</a>()</code>
</p>

<hr>
<h2 id='complete_Gamma_general_split'>Non-decomposable completion of variogram matrices</h2><span id='topic+complete_Gamma_general_split'></span>

<h3>Description</h3>

<p>Given a non-decomposable <code>graph</code>, and (non-graphical) variogram matrix <code>Gamma</code>,
modifies <code>Gamma</code> in non-edge entries, such that the resulting matrix is a
variogram matrix with graphical structure described by <code>graph</code>.
Does so by splitting <code>graph</code> at complete separators into smaller subgraphs,
and calling <code>complete_Gamma_general</code> for each subgraph/submatrix,
using multiple cores if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma_general_split(
  Gamma,
  graph,
  N = 10000,
  sub_tol = get_large_tol() * 0.001,
  check_tol = 100,
  mc_cores_overwrite = NULL,
  final_tol = get_large_tol()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_Gamma_general_split_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_graph">graph</code></td>
<td>
<p><code>igraph::graph()</code> object.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_n">N</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_sub_tol">sub_tol</code></td>
<td>
<p>Numeric scalar. Tolerance to be used when completing submatrices.
Should be smaller than <code>final_tol</code>.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_check_tol">check_tol</code></td>
<td>
<p>Numeric/integer scalar. How often to check the tolerance when completing submatrices.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_mc_cores_overwrite">mc_cores_overwrite</code></td>
<td>
<p><code>NULL</code> or numeric/integer scalar. Maximal number of cores to use.</p>
</td></tr>
<tr><td><code id="complete_Gamma_general_split_+3A_final_tol">final_tol</code></td>
<td>
<p>Numeric scalar. Check convergence of the final result with this tolerance.
Skipped if this value is &lt; 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A completed <code class="reqn">d \times d</code> variogram matrix.
</p>


<h3>See Also</h3>

<p>Other matrix completion related topics:
<code><a href="#topic+complete_Gamma_decomposable">complete_Gamma_decomposable</a>()</code>,
<code><a href="#topic+complete_Gamma_general_demo">complete_Gamma_general_demo</a>()</code>,
<code><a href="#topic+complete_Gamma_general">complete_Gamma_general</a>()</code>,
<code><a href="#topic+complete_Gamma">complete_Gamma</a>()</code>
</p>

<hr>
<h2 id='complete_Gamma_one_step'>Completion of two-clique decomposable Gamma matrices</h2><span id='topic+complete_Gamma_one_step'></span>

<h3>Description</h3>

<p>Given a decomposable <code>graph</code> consisting of two cliques and incomplete
variogram matrix <code>Gamma</code>, returns the full <code>Gamma</code> matrix implied by the
conditional independencies. The rows/columns of <code>Gamma</code> must be ordered
such that the clique of size <code>nA</code> (excluding separator) comes first, then
the separator of size <code>nC</code>, and then the remaining <code>nB</code> vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_Gamma_one_step(Gamma, nA, nC, nB)
</code></pre>

<hr>
<h2 id='computeLimits'>Compute plot limits</h2><span id='topic+computeLimits'></span>

<h3>Description</h3>

<p>Helper function to compute the axis limits of a plot
with given x, y data and optionally a fixed x-y-ratio and
correcting the latitude/longitude scale at different latitudes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeLimits(xData, yData, xyRatio = 1, convertLatLong = TRUE, stretch = 1)
</code></pre>

<hr>
<h2 id='danube'>Upper Danube basin dataset</h2><span id='topic+danube'></span>

<h3>Description</h3>

<p>A dataset containing river discharge data for tributaries of the Danube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>danube
</code></pre>


<h3>Format</h3>

<p>A named <code>list</code> with four entries
</p>

<dl>
<dt><code>data_clustered</code></dt><dd><p>A numeric matrix, containing pre-processed discharge data for each gauging station</p>
</dd>
<dt><code>data_raw</code></dt><dd><p>A numeric matrix, containing daily (raw) discharge data for each gauging station</p>
</dd>
<dt><code>info</code></dt><dd><p>A data frame, containing information about each gauging station</p>
</dd>
<dt><code>flow_edges</code></dt><dd>
<p>A two-column numeric matrix. Each row contains the indices (in <code>info</code>)
of a pair of gauging stations that are directly connected by a river.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>To obtain the matrix <code>data_clustered</code>, the daily discharge data from the summer months of
1960 to 2010, given in <code>data_raw</code>, was declustered, yielding between seven and ten observations per year.
Each row corresponds to one observation from this declustered time series,
the <em>non-unique rownames</em> indicate which year an observation is from.
Each column corresponds to one of the gauging stations,
with column indices in <code>data_raw</code>/<code>data_clustered</code> corresponding to row indices in <code>info</code>.
See (Asadi et al. 2015) for details on the preprocessing and declustering.
</p>
<p><code>info</code> is a data frame containing the following information for
each of the gauging stations or its corresponding catchment area:
</p>

<dl>
<dt><code>RivNames</code></dt><dd><p>Name of the river at the gauging station</p>
</dd>
<dt><code>Lat</code>, <code>Long</code></dt><dd><p>Coordinates of the gauging station</p>
</dd>
<dt><code>Lat_Center</code>, <code>Long_Center</code></dt><dd><p>Coordinates of the center of the catchment corresponding to the gauging station</p>
</dd>
<dt><code>Alt</code></dt><dd><p>Mean altitude of the catchment</p>
</dd>
<dt><code>Area</code></dt><dd><p>Area of the catchment corresponding to the gauging station</p>
</dd>
<dt><code>Slope</code></dt><dd><p>Mean slope of the catchment</p>
</dd>
<dt><code>PlotCoordX</code>, <code>PlotCoordY</code></dt><dd>
<p>X-Y-coordinates which can be used to arrange the gauging stations when plotting a flow graph.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bavarian Environmental Agency <a href="https://www.gkd.bayern.de">https://www.gkd.bayern.de</a>.
</p>


<h3>References</h3>

<p>Asadi P, Davison AC, Engelke S (2015).
&ldquo;Extremes on river networks.&rdquo;
<em>Ann. Appl. Stat.</em>, <b>9</b>(4), 2023 &ndash; 2050.
<a href="https://doi.org/10.1214/15-AOAS863">doi:10.1214/15-AOAS863</a>.
</p>


<h3>See Also</h3>

<p>Other danubeData: 
<code><a href="#topic+getDanubeFlowGraph">getDanubeFlowGraph</a>()</code>,
<code><a href="#topic+plotDanube">plotDanube</a>()</code>
</p>
<p>Other datasets:
<code><a href="#topic+flights">flights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(danube$data_clustered)
colnames(danube$info)

</code></pre>

<hr>
<h2 id='data2mpareto'>Data standardization to multivariate Pareto scale</h2><span id='topic+data2mpareto'></span>

<h3>Description</h3>

<p>Transforms the <code>data</code> matrix empirically to the multivariate Pareto scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data2mpareto(data, p, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data2mpareto_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="data2mpareto_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1. Probability used for the quantile to
threshold the data.</p>
</td></tr>
<tr><td><code id="data2mpareto_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If rows containing NAs should be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns of the <code>data</code> matrix are first transformed empirically to
standard Pareto distributions. Then, only the observations where at least
one component exceeds the <code>p</code>-quantile of the standard Pareto distribution
are kept. Those observations are finally divided by the <code>p</code>-quantile
of the standard Pareto distribution to standardize them to the multivariate Pareto scale.
</p>
<p>If <code>na.rm</code> is <code>FALSE</code>, missing entries are left as such during the transformation of univariate marginals.
In the thresholding step, missing values are considered as <code>-Inf</code>.
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">m \times d</code> matrix, where <code>m</code> is the number
of rows in the original <code>data</code> matrix that are above the threshold.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>
<p>Other structure estimation methods:
<code><a href="#topic+eglatent">eglatent</a>()</code>,
<code><a href="#topic+eglearn">eglearn</a>()</code>,
<code><a href="#topic+emst">emst</a>()</code>,
<code><a href="#topic+fit_graph_to_Theta">fit_graph_to_Theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 20
d &lt;- 4
p &lt;- .8
G &lt;- cbind(
  c(0, 1.5, 1.5, 2),
  c(1.5, 0, 2, 1.5),
  c(1.5, 2, 0, 1.5),
  c(2, 1.5, 1.5, 0)
)

set.seed(123)
my_data &lt;- rmstable(n, "HR", d = d, par = G)
data2mpareto(my_data, p)

</code></pre>

<hr>
<h2 id='eglatent'>Learning extremal graph structure with latent variables</h2><span id='topic+eglatent'></span>

<h3>Description</h3>

<p>Following the methodology from Engelke and Taeb (2024),
fits an extremal graph structure with latent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eglatent(
  Gamma,
  lam1_list = c(0.1, 0.15, 0.19, 0.205),
  lam2_list = c(2),
  refit = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eglatent_+3A_gamma">Gamma</code></td>
<td>
<p>conditionally negative semidefinite matrix. This will be typically the empirical variogram matrix.</p>
</td></tr>
<tr><td><code id="eglatent_+3A_lam1_list">lam1_list</code></td>
<td>
<p>Numeric vector of non-negative regularization parameters for eglatent.
Default is <code>lam1_list = c(0.1, 0.15, 0.19, 0.205)</code>.</p>
</td></tr>
<tr><td><code id="eglatent_+3A_lam2_list">lam2_list</code></td>
<td>
<p>Numeric vector of non-negative regularization parameters for eglatent.
Default is <code>lam2_list = c(2)</code>.</p>
</td></tr>
<tr><td><code id="eglatent_+3A_refit">refit</code></td>
<td>
<p>Logical scalar, if TRUE then the model is refit on the estimated graph to obtain an estimate of the Gamma matrix on that graph.
Default is <code>refit = TRUE</code>.</p>
</td></tr>
<tr><td><code id="eglatent_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar, indicating whether to print progress updates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function fits one model for each combination
of values in <code>lam1_list</code> and <code>lam2_list</code>. All returned objects
have one entry per model. List consisting of:
#' </p>
<table>
<tr><td><code>graph</code></td>
<td>

<p>A list of <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> objects representing the
fitted graphs.
</p>
</td></tr>
<tr><td><code>rk</code></td>
<td>

<p>Numeric vector containing the estimated ranks of the latent
variables.
</p>
</td></tr>
<tr><td><code>G_est</code></td>
<td>

<p>A list of numeric estimated <code class="reqn">d \times d</code>
variogram matrices <code class="reqn">\Gamma</code> corresponding to the fitted graphs.
</p>
</td></tr>
<tr><td><code>G_refit</code></td>
<td>

<p>A list of numeric estimated <code class="reqn">d \times d</code>
variogram matrices <code class="reqn">\Gamma</code> refitted with fixed graphs
corresponding to the fitted graphs.
</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>

<p>A list containing the values of <code>lam1_list</code> and <code>lam2_list</code>
used for the model fit.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Engelke S, Taeb A (2024).
&ldquo;Extremal graphical modeling with latent variables.&rdquo;
2403.09604.
</p>


<h3>See Also</h3>

<p>Other structure estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+eglearn">eglearn</a>()</code>,
<code><a href="#topic+emst">emst</a>()</code>,
<code><a href="#topic+fit_graph_to_Theta">fit_graph_to_Theta</a>()</code>
</p>

<hr>
<h2 id='eglearn'>Learning extremal graph structure</h2><span id='topic+eglearn'></span>

<h3>Description</h3>

<p>Following the methodology from Engelke et al. (2022),
fits an extremal graph structure using the neighborhood selection approach
(see Meinshausen and Bühlmann (2006)) or graphical lasso
(see Friedman et al. (2008)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eglearn(
  data,
  p = NULL,
  rholist = c(0.1, 0.15, 0.19, 0.205),
  reg_method = c("ns", "glasso"),
  complete_Gamma = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eglearn_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="eglearn_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale. Else,
<code>p</code> is used as the probability in the function <code><a href="#topic+data2mpareto">data2mpareto()</a></code>
to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="eglearn_+3A_rholist">rholist</code></td>
<td>
<p>Numeric vector of non-negative regularization parameters
for the lasso.
Default is <code>rholist = c(0.1, 0.15, 0.19, 0.205)</code>.
For details see <code><a href="glasso.html#topic+glassopath">glasso::glassopath()</a></code>.</p>
</td></tr>
<tr><td><code id="eglearn_+3A_reg_method">reg_method</code></td>
<td>
<p>One of <code style="white-space: pre;">&#8288;"ns", "glasso"&#8288;</code>, for neighborhood selection and
graphical lasso, respectively.
Default is <code>reg_method = "ns"</code>.
For details see Meinshausen and Bühlmann (2006),
Friedman et al. (2008).</p>
</td></tr>
<tr><td><code id="eglearn_+3A_complete_gamma">complete_Gamma</code></td>
<td>
<p>Whether you want to try fto complete Gamma matrix.
Default is <code>complete_Gamma = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List made of:
</p>
<table>
<tr><td><code>graph</code></td>
<td>

<p>A list of <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> objects representing the
fitted graphs for each <code>rho</code> in <code>rholist</code>.
</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>

<p>A list of numeric estimated <code class="reqn">d \times d</code>
variogram matrices <code class="reqn">\Gamma</code> corresponding to the fitted graphs,
for each <code>rho</code> in <code>rholist</code>. If <code>complete_Gamma = FALSE</code> or the
underlying graph is not connected, it returns <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>rholist</code></td>
<td>

<p>The list of penalty coefficients.
</p>
</td></tr>
<tr><td><code>graph_ic</code></td>
<td>

<p>A list of <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> objects
representing the optimal graph
according to the <code>aic</code>, <code>bic</code>, and <code>mbic</code> information criteria.
If <code>reg_method = "glasso"</code>, it returns a list of <code>NULL</code>.
</p>
</td></tr>
<tr><td><code>Gamma_ic</code></td>
<td>

<p>A list of numeric <code class="reqn">d \times d</code> estimated
variogram matrices <code class="reqn">\Gamma</code> corresponding
to the <code>aic</code>, <code>bic</code>, and <code>mbic</code> information criteria.
If <code>reg_method = "glasso"</code>, <code>complete_Gamma = FALSE</code>, or the underlying
graph is not connected, it returns a list of <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Engelke S, Lalancette M, Volgushev S (2022).
&ldquo;Learning extremal graphical structures in high dimensions.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2111.00840">doi:10.48550/ARXIV.2111.00840</a>, Available from <a href="https://arxiv.org/abs/2111.00840">https://arxiv.org/abs/2111.00840</a>., 2111.00840, <a href="https://arxiv.org/abs/2111.00840">https://arxiv.org/abs/2111.00840</a>.<br /><br /> Friedman J, Hastie T, Tibshirani R (2008).
&ldquo;Sparse inverse covariance estimation with the graphical lasso.&rdquo;
<em>Biostatistics</em>, <b>9</b>(3), 432&ndash;441.<br /><br /> Meinshausen N, Bühlmann P (2006).
&ldquo;High-dimensional graphs and variable selection with the Lasso.&rdquo;
<em>Ann. Statist.</em>, <b>34</b>(3), 1436 &ndash; 1462.
<a href="https://doi.org/10.1214/009053606000000281">doi:10.1214/009053606000000281</a>.
</p>


<h3>See Also</h3>

<p>Other structure estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+eglatent">eglatent</a>()</code>,
<code><a href="#topic+emst">emst</a>()</code>,
<code><a href="#topic+fit_graph_to_Theta">fit_graph_to_Theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
m &lt;- generate_random_model(d=6)
y &lt;- rmpareto(n=500, par=m$Gamma)
ret &lt;- eglearn(y)

</code></pre>

<hr>
<h2 id='emp_chi'>Empirical estimation of extremal correlation matrix <code class="reqn">\chi</code></h2><span id='topic+emp_chi'></span><span id='topic+emp_chi_pairwise'></span>

<h3>Description</h3>

<p>Estimates empirically the matrix of bivariate extremal correlation coefficients <code class="reqn">\chi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp_chi(data, p = NULL)

emp_chi_pairwise(data, p = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp_chi_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="emp_chi_+3A_p">p</code></td>
<td>
<p>Numeric scalar between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale. Else,
<code>p</code> is used as the probability in <code><a href="#topic+data2mpareto">data2mpareto()</a></code> to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="emp_chi_+3A_verbose">verbose</code></td>
<td>
<p>Print verbose progress information</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>emp_chi_pairwise</code> calls <code>emp_chi</code> for each pair of observations.
This is more robust if the data contains many <code>NA</code>s, but can take rather long.
</p>


<h3>Value</h3>

<p>Numeric matrix <code class="reqn">d \times d</code>. The matrix contains the
bivariate extremal coefficients <code class="reqn">\chi_{ij}</code>, for <code class="reqn">i, j = 1, ..., d</code>.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
d &lt;- 4
p &lt;- .8
Gamma &lt;- cbind(
  c(0, 1.5, 1.5, 2),
  c(1.5, 0, 2, 1.5),
  c(1.5, 2, 0, 1.5),
  c(2, 1.5, 1.5, 0)
)

set.seed(123)
my_data &lt;- rmstable(n, "HR", d = d, par = Gamma)
emp_chi(my_data, p)

</code></pre>

<hr>
<h2 id='emp_chi_multdim'>Empirical estimation of extremal correlation <code class="reqn">\chi</code></h2><span id='topic+emp_chi_multdim'></span>

<h3>Description</h3>

<p>Estimates the <code>d</code>-dimensional extremal correlation coefficient <code class="reqn">\chi</code> empirically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp_chi_multdim(data, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp_chi_multdim_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="emp_chi_multdim_+3A_p">p</code></td>
<td>
<p>Numeric scalar between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale. Else,
<code>p</code> is used as the probability in <code><a href="#topic+data2mpareto">data2mpareto()</a></code> to standardize the <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scalar. The empirical <code>d</code>-dimensional extremal correlation coefficient <code class="reqn">\chi</code>
for the <code>data</code>.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
d &lt;- 2
p &lt;- .8
G &lt;- cbind(
  c(0, 1.5),
  c(1.5, 0)
)

set.seed(123)
my_data &lt;- rmstable(n, "HR", d = d, par = G)
emp_chi_multdim(my_data, p)

</code></pre>

<hr>
<h2 id='emp_vario'>Estimation of the variogram matrix <code class="reqn">\Gamma</code> of a Huesler-Reiss distribution</h2><span id='topic+emp_vario'></span><span id='topic+emp_vario_pairwise'></span>

<h3>Description</h3>

<p>Estimates the variogram of the Huesler-Reiss distribution empirically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emp_vario(data, k = NULL, p = NULL)

emp_vario_pairwise(data, k = NULL, p = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emp_vario_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="emp_vario_+3A_k">k</code></td>
<td>
<p>Integer between 1 and <code>d</code>. Component of the multivariate
observations that is conditioned to be larger than the threshold <code>p</code>.
If <code>NULL</code> (default), then an average over all <code>k</code> is returned.</p>
</td></tr>
<tr><td><code id="emp_vario_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale. Else,
<code>p</code> is used as the probability in the function <code><a href="#topic+data2mpareto">data2mpareto()</a></code>
to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="emp_vario_+3A_verbose">verbose</code></td>
<td>
<p>Print verbose progress information</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>emp_vario_pairwise</code> calls <code>emp_vario</code> for each pair of observations.
This is more robust if the data contains many <code>NA</code>s, but can take rather long.
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">d \times d</code> matrix. The estimated variogram of the Huesler-Reiss distribution.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- generate_random_Gamma(d=5)
y &lt;- rmpareto(n=100, par=G)
Ghat &lt;- emp_vario(y)

</code></pre>

<hr>
<h2 id='emst'>Fitting extremal minimum spanning tree</h2><span id='topic+emst'></span>

<h3>Description</h3>

<p>Fits an extremal minimum spanning tree, where the edge weights are:
</p>

<ul>
<li><p> negative maximized log-likelihoods of the bivariate Huesler-Reiss distributions,
if <code>method = "ML"</code>. See Engelke and Hitz (2020) for details.
</p>
</li>
<li><p> empirical extremal variogram, if <code>method = "vario"</code>. See Engelke and Volgushev (2022) for details.
</p>
</li>
<li><p> empirical extremal correlation, if <code>method = "chi"</code>. See Engelke and Volgushev (2022) for details.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>emst(data, p = NULL, method = c("vario", "ML", "chi"), cens = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emst_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the dimension.</p>
</td></tr>
<tr><td><code id="emst_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale. Else,
<code>p</code> is used as the probability in the function <code><a href="#topic+data2mpareto">data2mpareto()</a></code>
to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="emst_+3A_method">method</code></td>
<td>
<p>One of <code style="white-space: pre;">&#8288;"vario", "ML", "chi"&#8288;</code>.
Default is <code>method = "vario"</code>.</p>
</td></tr>
<tr><td><code id="emst_+3A_cens">cens</code></td>
<td>
<p>Logical. This argument is considered only if <code>method = "ML"</code>.
If <code>TRUE</code>, then censored likelihood contributions are used for
components below the threshold. By default, <code>cens = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List consisting of:
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object. The fitted minimum spanning tree.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>

<p>Numeric <code class="reqn">d \times d</code> estimated variogram matrix <code class="reqn">\Gamma</code>
corresponding to the fitted minimum spanning tree.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Engelke S, Hitz AS (2020).
&ldquo;Graphical models for extremes (with discussion).&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>82</b>, 871&ndash;932.<br /><br /> Engelke S, Volgushev S (2022).
&ldquo;Structure learning for extremal tree models.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>.
<a href="https://doi.org/10.1111/rssb.12556">doi:10.1111/rssb.12556</a>, Forthcoming, https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssb.12556.
</p>


<h3>See Also</h3>

<p>Other structure estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+eglatent">eglatent</a>()</code>,
<code><a href="#topic+eglearn">eglearn</a>()</code>,
<code><a href="#topic+fit_graph_to_Theta">fit_graph_to_Theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fitting a 4-dimensional HR minimum spanning tree
my_graph &lt;- igraph::graph_from_adjacency_matrix(
  rbind(
    c(0, 1, 0, 0),
    c(1, 0, 1, 1),
    c(0, 1, 0, 0),
    c(0, 1, 0, 0)
  ),
  mode = "undirected"
)
n &lt;- 100
Gamma_vec &lt;- c(.5, 1.4, .8)
complete_Gamma(Gamma = Gamma_vec, graph = my_graph) ## full Gamma matrix

set.seed(123)
my_data &lt;- rmpareto_tree(n, "HR", tree = my_graph, par = Gamma_vec)
my_fit &lt;- emst(my_data, p = NULL, method = "ML", cens = FALSE)
</code></pre>

<hr>
<h2 id='emtp2'>Performs Gaussian likelihood optimization under Laplacian matrix constraints.</h2><span id='topic+emtp2'></span>

<h3>Description</h3>

<p>This function implements a block descent algorithm to find the maximum of the
Gaussian log-likelihood under the constraint that the concentration matrix is a Laplacian matrix.
See Röttger et al. (2021) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emtp2(Gamma, tol = 1e-06, verbose = TRUE, initial_point = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emtp2_+3A_gamma">Gamma</code></td>
<td>
<p>conditionally negative semidefinite matrix. This will be typically the empirical variogram matrix.</p>
</td></tr>
<tr><td><code id="emtp2_+3A_tol">tol</code></td>
<td>
<p>The convergence tolerance. The algorithm terminates when the sum of absolute differences between two iterations is below <code>tol</code>.</p>
</td></tr>
<tr><td><code id="emtp2_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE (default) the output will be printed.</p>
</td></tr>
<tr><td><code id="emtp2_+3A_initial_point">initial_point</code></td>
<td>
<p>if TRUE (default), the algorithm will construct an initial point before the iteration steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of:
</p>
<table>
<tr><td><code>G_emtp2</code></td>
<td>
<p>The optimal value of the variogram matrix</p>
</td></tr>
<tr><td><code>it</code></td>
<td>
<p>The number of iterations</p>
</td></tr>
</table>


<h3>References</h3>

<p>Röttger F, Engelke S, Zwiernik P (2021).
&ldquo;Total positivity in multivariate extremes.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2112.14727">doi:10.48550/ARXIV.2112.14727</a>, <a href="https://arxiv.org/abs/2112.14727">https://arxiv.org/abs/2112.14727</a>.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>

<hr>
<h2 id='ensure_matrix_symmetry'>Ensure numerical matrix symmetry/zero values</h2><span id='topic+ensure_matrix_symmetry'></span><span id='topic+truncate_zeros'></span><span id='topic+ensure_matrix_symmetry_and_truncate_zeros'></span>

<h3>Description</h3>

<p>Ensures the symmetry of a square matrix by averaging it with its transpose.
Optionally verifies that the matrix was close to symmetric before.
</p>
<p>Makes sure zeros are &quot;numerically zero&quot;, by truncating all small values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_matrix_symmetry(M, checkTol = Inf, alert = NULL)

truncate_zeros(M, tol = get_small_tol())

ensure_matrix_symmetry_and_truncate_zeros(
  M,
  tol = get_small_tol(),
  checkTol = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_matrix_symmetry_+3A_m">M</code></td>
<td>
<p>Numeric square matrix.</p>
</td></tr>
<tr><td><code id="ensure_matrix_symmetry_+3A_checktol">checkTol</code></td>
<td>
<p>Positive scalar. If the maximum absolute difference between <code>M</code>
and <code>t(M)</code> is larger, show a warning.</p>
</td></tr>
<tr><td><code id="ensure_matrix_symmetry_+3A_alert">alert</code></td>
<td>
<p>Passed to <code>get_alert_function</code>: <code>NULL</code> or <code>TRUE</code> to read the option value,
<code>FALSE</code> to return a dummy function, or a function that takes an arbitrary number of strings as arguments (e.g. <code>stop()</code>).</p>
</td></tr>
<tr><td><code id="ensure_matrix_symmetry_+3A_tol">tol</code></td>
<td>
<p>All entries with absolute value below this value are truncated to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted value of <code>M</code>.
</p>


<h3>See Also</h3>

<p>Other input validation functions:
<code><a href="#topic+checkGamma">checkGamma</a>()</code>,
<code><a href="#topic+check_graph">check_graph</a>()</code>,
<code><a href="#topic+check_partial_matrix_and_graph">check_partial_matrix_and_graph</a>()</code>
</p>

<hr>
<h2 id='fast_diag'>Fast computation of diag(y %<em>% M %</em>% t(y))</h2><span id='topic+fast_diag'></span>

<h3>Description</h3>

<p>Fast computation of diag(y %<em>% M %</em>% t(y))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_diag(y, M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_diag_+3A_y">y</code></td>
<td>
<p>Numeric matrix</p>
</td></tr>
<tr><td><code id="fast_diag_+3A_m">M</code></td>
<td>
<p>Numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>

<hr>
<h2 id='fillFixedParams'>Helper function to combine par with fixed params (in init)</h2><span id='topic+fillFixedParams'></span>

<h3>Description</h3>

<p>Helper function to combine par with fixed params (in init)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillFixedParams(par, init, fixParams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillFixedParams_+3A_par">par</code></td>
<td>
<p>Numeric vector. The parameters that are optimized</p>
</td></tr>
<tr><td><code id="fillFixedParams_+3A_init">init</code></td>
<td>
<p>Numeric vector. The initial parameters (including the ones optimized over)</p>
</td></tr>
<tr><td><code id="fillFixedParams_+3A_fixparams">fixParams</code></td>
<td>
<p>Numeric or logical vector. Positions of fixed parameters in the full parameter vector.</p>
</td></tr>
</table>

<hr>
<h2 id='findVsep'>Find a separator set for two vertices</h2><span id='topic+findVsep'></span>

<h3>Description</h3>

<p>Finds a reasonably small set of vertices that separate <code>v0</code> and <code>v1</code> in <code>graph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findVsep(graph, v0, v1)
</code></pre>

<hr>
<h2 id='fit_graph_to_Theta'>Experimental: Fit graph using empirical Theta matrix</h2><span id='topic+fit_graph_to_Theta'></span>

<h3>Description</h3>

<p>Fits a graph to an empirical Gamma matrix by computing the corresponding
Theta matrix using <code><a href="#topic+Gamma2Theta">Gamma2Theta()</a></code> and greedily chooses <code>m</code> edges that
correspond to high absolute values in Theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_graph_to_Theta(data, m = NULL, Gamma_emp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_graph_to_Theta_+3A_data">data</code></td>
<td>
<p>The (standardized) data from which to compute Gamma</p>
</td></tr>
<tr><td><code id="fit_graph_to_Theta_+3A_m">m</code></td>
<td>
<p>The number of edges to add, defaults to the number of edges in a tree</p>
</td></tr>
<tr><td><code id="fit_graph_to_Theta_+3A_gamma_emp">Gamma_emp</code></td>
<td>
<p>The empirical Gamma matrix
(can be <code>NULL</code> if <code>data</code> is given)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing an [<code>igraph::graph</code>] object and a fitted <code>Gamma</code> matrix
</p>


<h3>See Also</h3>

<p>Other structure estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+eglatent">eglatent</a>()</code>,
<code><a href="#topic+eglearn">eglearn</a>()</code>,
<code><a href="#topic+emst">emst</a>()</code>
</p>

<hr>
<h2 id='fitInInterval'>Fit value(s) in interval</h2><span id='topic+fitInInterval'></span>

<h3>Description</h3>

<p>Fit value(s) in interval, all arguments are recycled where necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitInInterval(x, xMin = -Inf, xMax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitInInterval_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="fitInInterval_+3A_xmin">xMin</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="fitInInterval_+3A_xmax">xMax</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>

<hr>
<h2 id='flightCountMatrixToConnectionList'>Convert flight counts to connection list</h2><span id='topic+flightCountMatrixToConnectionList'></span>

<h3>Description</h3>

<p>Convert a numeric matrix containing flight counts between airports to a data
frame containing a list of connections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flightCountMatrixToConnectionList(nFlightsPerConnection, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flightCountMatrixToConnectionList_+3A_nflightsperconnection">nFlightsPerConnection</code></td>
<td>
<p>A square, numeric matrix with identical column- and row-names.
Each entry represents the number of flights from the airport indexing the row to
the airport indexing the column in some arbitrary time period.</p>
</td></tr>
<tr><td><code id="flightCountMatrixToConnectionList_+3A_directed">directed</code></td>
<td>
<p>Logical scalar. Whether flights A-&gt;B and B-&gt;A should be considered separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>departureAirport</code>, <code>arrivalAirport</code>, <code>nFlights</code>.
Each row represents one connection with &gt;=1 flights in the input matrix.
</p>


<h3>See Also</h3>

<p>Other flight data related topics:
<code><a href="#topic+flights">flights</a></code>,
<code><a href="#topic+getFlightDelayData">getFlightDelayData</a>()</code>,
<code><a href="#topic+getFlightGraph">getFlightGraph</a>()</code>,
<code><a href="#topic+plotFlights">plotFlights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flightCountMatrixToConnectionList(flights$flightCounts[1:100, 1:100, 1])

</code></pre>

<hr>
<h2 id='flights'>Flights delay data</h2><span id='topic+flights'></span>

<h3>Description</h3>

<p>A dataset containing daily total delays of major U.S. airlines.
The raw data was obtained from the U.S.
<a href="https://www.bts.dot.gov/">Bureau of Transportation Statistics</a>,
and pre-processed as described in
Hentschel et al. (2022).
<em>Note: The CRAN version of this package contains only data from 2010-2013.</em>
<em>The full dataset is available in the GitHub version of this package.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flights
</code></pre>


<h3>Format</h3>

<p>A named <code>list</code> with three entries:
</p>

<dl>
<dt><code>airports</code></dt><dd><p>A <code>data.frame</code>, containing information about US airports</p>
</dd>
<dt><code>delays</code></dt><dd><p>A numeric matrix, containing daily aggregated delays at the airports in the dataset</p>
</dd>
<dt><code>flightCounts</code></dt><dd>
<p>A numeric array, containing yearly flight numbers between airports in the dataset
</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>flightCounts</code> is a three-dimensional array, containing the number of flights in the dataset
between each pair of airports, aggregated on a yearly basis.
Each entry is the total number of flights between the departure airport (row)
and destination airport (column) in a given year (dimension 3).
This array does not contain any <code>NA</code>s, even if an airport did not operate
at all in a given year, which is simply indicated by zeros.
</p>
<p><code>delays</code> is a three-dimensional array containing daily total positive delays,
in minutes, of incoming and outgoing flights respectively.
Each column corresponds to an airport in the dataset and each row corresponds
to a day. The third dimension has length two, <code>'arrivals'</code> containing delays of
incoming flights and <code>'departures'</code> containing delays of outgoing flights.
Zeros indicate that there were flights arriving/departing at that airport
on a given day, but none of them had delays. <code>NA</code>s indicate that there were
no flights arriving/departing at that airport on that day at all.
</p>
<p><code>airports</code> is a data frame containing the following information about a number of US airports.
Some entries are missing, which is indicated by <code>NA</code>s.
</p>

<dl>
<dt><code>IATA</code></dt><dd><p>3-letter IATA code</p>
</dd>
<dt><code>Name</code></dt><dd><p>name of the airport</p>
</dd>
<dt><code>City</code></dt><dd><p>main city served by the airport</p>
</dd>
<dt><code>Country</code></dt><dd><p>country or territory where the airport is located (mostly <code>"United States"</code>)</p>
</dd>
<dt><code>ICAO</code></dt><dd><p>4-letter ICAO code</p>
</dd>
<dt><code>Latitude</code></dt><dd><p>latitude of the airport, in decimal degrees</p>
</dd>
<dt><code>Longitude</code></dt><dd><p>longitude of the airport, in decimal degrees</p>
</dd>
<dt><code>Altitude</code></dt><dd><p>altitude of the airport, in feet</p>
</dd>
<dt><code>Timezone</code></dt><dd><p>timezone of the airport, in hours offset from UTC</p>
</dd>
<dt><code>DST</code></dt><dd><p>Daylight savings time used at the airport. 'A'=US/Canada, 'N'=None.</p>
</dd>
<dt><code>Timezone2</code></dt><dd><p>name of the timezone of the airport</p>
</dd>
</dl>



<h3>Source</h3>

<p>Raw delays data:
</p>

<ul>
<li> <p><a href="https://www.bts.dot.gov/browse-statistical-products-and-data/bts-publications/airline-service-quality-performance-234-time">https://www.bts.dot.gov/browse-statistical-products-and-data/bts-publications/airline-service-quality-performance-234-time</a>
</p>
</li></ul>

<p>Fields/Forms used in the raw data:
</p>

<ul>
<li> <p><a href="https://esubmit.rita.dot.gov/ViewReports.aspx">https://esubmit.rita.dot.gov/ViewReports.aspx</a>
</p>
</li>
<li> <p><a href="https://esubmit.rita.dot.gov/On-Time-Form1.aspx">https://esubmit.rita.dot.gov/On-Time-Form1.aspx</a>
</p>
</li>
<li> <p><a href="https://esubmit.rita.dot.gov/On-Time-Form3A.aspx">https://esubmit.rita.dot.gov/On-Time-Form3A.aspx</a>
</p>
</li></ul>

<p>Airports (includes license information):
</p>

<ul>
<li> <p><a href="https://openflights.org/data">https://openflights.org/data</a>
</p>
</li></ul>



<h3>References</h3>

<p>Hentschel M, Engelke S, Segers J (2022).
&ldquo;Statistical Inference for Hüsler-Reiss Graphical Models Through Matrix Completions.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2210.14292">doi:10.48550/ARXIV.2210.14292</a>, <a href="https://arxiv.org/abs/2210.14292">https://arxiv.org/abs/2210.14292</a>.
</p>


<h3>See Also</h3>

<p>Other flight data related topics:
<code><a href="#topic+flightCountMatrixToConnectionList">flightCountMatrixToConnectionList</a>()</code>,
<code><a href="#topic+getFlightDelayData">getFlightDelayData</a>()</code>,
<code><a href="#topic+getFlightGraph">getFlightGraph</a>()</code>,
<code><a href="#topic+plotFlights">plotFlights</a>()</code>
</p>
<p>Other datasets:
<code><a href="#topic+danube">danube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get total number of flights in the dataset:
totalFlightCounts &lt;- apply(flights$flightCounts, c(1,2), sum)

# Get number of flights for specific years in the dataset:
flightCounts_10_11 &lt;- apply(flights$flightCounts[,,c('2010', '2011')], c(1,2), sum)

# Get list of connections from 2008:
connections_10 &lt;- flightCountMatrixToConnectionList(flights$flightCounts[,,'2010'])

</code></pre>

<hr>
<h2 id='fmpareto_graph_HR'>Parameter fitting for Huesler-Reiss graphical models</h2><span id='topic+fmpareto_graph_HR'></span>

<h3>Description</h3>

<p>Fits the parameter matrix (variogram) of a multivariate Huesler-Reiss Pareto distribution
with a given graphical structure, using maximum-likelihood estimation
or the empirical variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmpareto_graph_HR(
  data,
  graph,
  p = NULL,
  method = c("vario", "ML"),
  handleCliques = c("average", "full", "sequential"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmpareto_graph_HR_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the number of dimensions.</p>
</td></tr>
<tr><td><code id="fmpareto_graph_HR_+3A_graph">graph</code></td>
<td>
<p>Undirected, connected [<code>igraph::graph</code>] object with <code>d</code> vertices,
representing the graphical structure of the fitted Huesler-Reiss model.</p>
</td></tr>
<tr><td><code id="fmpareto_graph_HR_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> is already on a multivariate Pareto scale.
Else, <code>p</code> is used as the probability in the function <code><a href="#topic+data2mpareto">data2mpareto()</a></code>
to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="fmpareto_graph_HR_+3A_method">method</code></td>
<td>
<p>One of <code>c('vario', 'ML')</code>, with <code>'vario'</code> as default, indicating
the method to be used for parameter estimation. See details.</p>
</td></tr>
<tr><td><code id="fmpareto_graph_HR_+3A_handlecliques">handleCliques</code></td>
<td>
<p>How to handle cliques and separators in the graph.
See details.</p>
</td></tr>
<tr><td><code id="fmpareto_graph_HR_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE()</a></code>. Currently <code>cens</code>, <code>maxit</code>,
<code>optMethod</code>, and <code>useTheta</code> are supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>handleCliques='average'</code>, the marginal parameter matrix is estimated for
each maximal clique of the <code>graph</code> and then combined into a partial parameter
matrix by taking the average of entries from overlapping cliques. Lastly,
the full parameter matrix is computed using <code><a href="#topic+complete_Gamma">complete_Gamma()</a></code>.
</p>
<p>If <code>handleCliques='full'</code>, first the full parameter matrix is estimated using the
specified <code>method</code> and then the non-edge entries are adjusted such that the
final parameter matrix has the graphical structure indicated by <code>graph</code>.
</p>
<p>If <code>handleCliques='sequential'</code>, <code>graph</code> must be decomposable, and
<code>method='ML'</code> must be specified. The parameter matrix is first estimated on
the (recursive) separators and then on the rest of the cliques, keeping
previously estimated entries fixed.
</p>
<p>If <code>method='ML'</code>, the computational cost is mostly influenced by the total size
of the graph (if <code>handleCliques='full'</code>) or the size of the cliques,
and can already take a significant amount of time for modest dimensions (e.g. <code>d=3</code>).
</p>


<h3>Value</h3>

<p>The estimated parameter matrix.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>

<hr>
<h2 id='fmpareto_graph_HR_clique_average'>HR Parameter fitting - Helper functions</h2><span id='topic+fmpareto_graph_HR_clique_average'></span><span id='topic+fmpareto_graph_HR_clique_sequential'></span><span id='topic+combine_clique_estimates_by_averaging'></span>

<h3>Description</h3>

<p>Helper functions called by <code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmpareto_graph_HR_clique_average(data, graph, method = c("ML", "vario"), ...)

fmpareto_graph_HR_clique_sequential(data, graph, ...)

combine_clique_estimates_by_averaging(cliques, subGammas)
</code></pre>

<hr>
<h2 id='fmpareto_HR_MLE'>Parameter fitting for multivariate Huesler-Reiss Pareto distribution</h2><span id='topic+fmpareto_HR_MLE'></span>

<h3>Description</h3>

<p>Fits the parameters of a multivariate Huesler-Reiss Pareto distribution
using (censored) maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmpareto_HR_MLE(
  data,
  p = NULL,
  cens = FALSE,
  init = NULL,
  fixParams = integer(0),
  useTheta = TRUE,
  maxit = 100,
  graph = NULL,
  optMethod = "BFGS",
  nAttemptsFixInit = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmpareto_HR_MLE_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, where <code>n</code> is the
number of observations and <code>d</code> is the number of dimensions.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_p">p</code></td>
<td>
<p>Numeric scalar between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> is already on a multivariate Pareto scale. Else,
<code>p</code> is used as the probability in <code><a href="#topic+data2mpareto">data2mpareto()</a></code> to standardize the data.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_cens">cens</code></td>
<td>
<p>Logical scalar. If true, then censored likelihood contributions are used for
components below the threshold. This is computationally expensive and by default <code>cens = FALSE</code>.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_init">init</code></td>
<td>
<p>Numeric vector or numeric matrix. Initial parameter values in the optimization.
If <code>NULL</code>, the empirical variogram is used instead. Otherwise should be a numeric
vector with one entry per edge in <code>graph</code>, or a complete variogram/precision matrix.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_fixparams">fixParams</code></td>
<td>
<p>Numeric or logical vector. Indices of the parameter vectors that are kept
fixed (identical to <code>init</code>) during the optimization. Default is <code>integer(0)</code>.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_usetheta">useTheta</code></td>
<td>
<p>Logical. Whether to perform the MLE optimization in terms of Theta or Gamma.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_maxit">maxit</code></td>
<td>
<p>Positive integer. The maximum number of iterations in the optimization.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_graph">graph</code></td>
<td>
<p>Graph object from <code>igraph</code> package or <code>NULL</code> (implying the complete graph).</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_optmethod">optMethod</code></td>
<td>
<p>String. A valid optimization method used by the function
<a href="stats.html#topic+optim">stats::optim</a>. By default, <code>method = "BFGS"</code>.</p>
</td></tr>
<tr><td><code id="fmpareto_HR_MLE_+3A_nattemptsfixinit">nAttemptsFixInit</code></td>
<td>
<p>Numeric. If <code>useTheta=TRUE</code> and the initial parameter <code>init</code> is not valid,
attempt to fix it first by making sure all off-diagonal entries are negative and then adding some random noise
at most this many times.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the parameters corresponding to edges in <code>graph</code> are optimized, the remaining
entries are implied by the graphical structure. If <code>graph</code> is <code>NULL</code>, the complete graph is used.
The optimization is done either in terms of the variogram (Gamma) or precision matrix (Theta),
depending on the value of <code>useTheta</code>. If <code>graph</code> is non-decomposable,
<code>useTheta=TRUE</code> is significantly faster, otherwise they are similar in performance.
</p>


<h3>Value</h3>

<p>List consisting of:
</p>
<table>
<tr><td><code>convergence</code></td>
<td>
<p>Logical. Indicates whether the optimization converged or not.</p>
</td></tr>
<tr><td><code>Gamma</code></td>
<td>
<p>Numeric <code style="white-space: pre;">&#8288;d x d&#8288;</code> matrix. Fitted variogram matrix.</p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>Numeric <code style="white-space: pre;">&#8288;d x d&#8288;</code> matrix. Fitted precision matrix.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>Numeric vector. Optimal parameters, including fixed parameters.</p>
</td></tr>
<tr><td><code>par_opt</code></td>
<td>
<p>Numeric. Optimal parameters, excluding fixed parameters.</p>
</td></tr>
<tr><td><code>nllik</code></td>
<td>
<p>Numeric. Optimal value of the negative log-likelihood function.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Numeric matrix. Estimated Hessian matrix of the estimated parameters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>,
<code><a href="#topic+loglik_HR">loglik_HR</a>()</code>
</p>

<hr>
<h2 id='Gamma2chi_3D'>Compute theoretical <code class="reqn">\chi</code> in 3D</h2><span id='topic+Gamma2chi_3D'></span>

<h3>Description</h3>

<p>Computes the theoretical <code class="reqn">\chi</code> coefficient in 3 dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma2chi_3D(Gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma2chi_3D_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">3 \times 3</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 3-dimensional <code class="reqn">\chi</code> coefficient, i.e.,
the extremal correlation coefficient for the HR distribution. Note that
<code class="reqn">0 \leq \chi \leq 1</code>.
</p>

<hr>
<h2 id='Gamma2graph'>Convert matrix to graph</h2><span id='topic+Gamma2graph'></span><span id='topic+Sigma2graph'></span><span id='topic+Theta2graph'></span><span id='topic+partialMatrixToGraph'></span>

<h3>Description</h3>

<p>Creates a graph object representing the graph structure implied by a parameter matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma2graph(Gamma, tol = get_large_tol(), check = TRUE)

Sigma2graph(Sigma, tol = get_large_tol(), k = NULL, full = FALSE, check = TRUE)

Theta2graph(Theta, tol = get_large_tol(), k = NULL, full = FALSE, check = TRUE)

partialMatrixToGraph(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma2graph_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar. Entries in the precision matrix with absolute value
smaller than this are considered to be zero.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_check">check</code></td>
<td>
<p>Whether to check the inputs and call <code>ensure_matrix_symmetry_and_truncate_zeros</code>
on the outputs.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_sigma">Sigma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> covariance matrix.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_k">k</code></td>
<td>
<p><code>NULL</code> if the input/output matrix is <code class="reqn">\Sigma</code>/<code class="reqn">\Theta</code>.
Else, an integer between 1 and d indicating the value of k in <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_full">full</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>!is.null(k)</code>,
the input/output matrix is a <code class="reqn">d \times d</code> matrix with the kth row filled with zeros.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_theta">Theta</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> precision matrix.</p>
</td></tr>
<tr><td><code id="Gamma2graph_+3A_m">M</code></td>
<td>
<p>Partial matrix with <code>NA</code> entries indicating missing edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object.
</p>


<h3>See Also</h3>

<p>Other parameter matrix transformations:
<code><a href="#topic+Gamma2Sigma">Gamma2Sigma</a>()</code>,
<code><a href="#topic+chi2Gamma">chi2Gamma</a>()</code>,
<code><a href="#topic+par2Matrix">par2Matrix</a>()</code>
</p>

<hr>
<h2 id='Gamma2Sigma'>Conversion between Huesler-Reiss parameter matrices</h2><span id='topic+Gamma2Sigma'></span><span id='topic+Gamma2Theta'></span><span id='topic+Sigma2Gamma'></span><span id='topic+Theta2Gamma'></span><span id='topic+Sigma2Theta'></span><span id='topic+Theta2Sigma'></span><span id='topic+Theta2Theta'></span><span id='topic+Sigma2Sigma'></span><span id='topic+Gamma2Gamma'></span><span id='topic+matrix2matrix'></span>

<h3>Description</h3>

<p>Converts between different matrices that parametrize the same
Huesler-Reiss distribution:
<code class="reqn">\Gamma</code>, <code class="reqn">\Sigma</code>, <code class="reqn">\Theta</code>, <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.
The <code class="reqn">(d-1) \times (d-1)</code> matrices <code class="reqn">\Sigma^k</code> and <code class="reqn">\Theta^k</code> can also be given/returned
as <code class="reqn">d \times d</code> matrices with the kth row and column filled with zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gamma2Sigma(Gamma, k = NULL, full = FALSE, check = TRUE)

Gamma2Theta(Gamma, k = NULL, full = FALSE, check = TRUE)

Sigma2Gamma(Sigma, k = NULL, full = FALSE, check = TRUE)

Theta2Gamma(Theta, k = NULL, full = FALSE, check = TRUE)

Sigma2Theta(
  Sigma,
  k1 = NULL,
  k2 = NULL,
  full1 = FALSE,
  full2 = FALSE,
  check = TRUE
)

Theta2Sigma(
  Theta,
  k1 = NULL,
  k2 = NULL,
  full1 = FALSE,
  full2 = FALSE,
  check = TRUE
)

Theta2Theta(
  Theta,
  k1 = NULL,
  k2 = NULL,
  full1 = FALSE,
  full2 = FALSE,
  check = TRUE
)

Sigma2Sigma(
  Sigma,
  k1 = NULL,
  k2 = NULL,
  full1 = FALSE,
  full2 = FALSE,
  check = TRUE
)

Gamma2Gamma(Gamma, check = TRUE)

matrix2matrix(
  M,
  name1 = c("Gamma", "Sigma", "Theta")[1],
  name2 = c("Gamma", "Sigma", "Theta")[1],
  k1 = NULL,
  k2 = NULL,
  full1 = FALSE,
  full2 = FALSE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma2Sigma_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> variogram matrix.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_k">k</code></td>
<td>
<p><code>NULL</code> if the input/output matrix is <code class="reqn">\Sigma</code>/<code class="reqn">\Theta</code>.
Else, an integer between 1 and d indicating the value of k in <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_full">full</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>!is.null(k)</code>,
the input/output matrix is a <code class="reqn">d \times d</code> matrix with the kth row filled with zeros.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_check">check</code></td>
<td>
<p>Whether to check the inputs and call <code>ensure_matrix_symmetry_and_truncate_zeros</code>
on the outputs.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_sigma">Sigma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> covariance matrix.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_theta">Theta</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> or <code class="reqn">(d-1) \times (d-1)</code> precision matrix.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_k1">k1</code></td>
<td>
<p><code>NULL</code> if the input matrix is <code class="reqn">\Sigma</code>/<code class="reqn">\Theta</code>.
Else, an integer between 1 and d indicating the value of k in <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_k2">k2</code></td>
<td>
<p><code>NULL</code> if the output matrix is <code class="reqn">\Sigma</code>/<code class="reqn">\Theta</code>.
Else, an integer between 1 and d indicating the value of k in <code class="reqn">\Sigma^k</code>, <code class="reqn">\Theta^k</code>.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_full1">full1</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>!is.null(k1)</code>,
the input is a <code class="reqn">d \times d</code> matrix with the kth row filled with zeros.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_full2">full2</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>!is.null(k2)</code>,
the output is a <code class="reqn">d \times d</code> matrix with the kth row filled with zeros.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_m">M</code></td>
<td>
<p>Numeric matrix, <code class="reqn">\Gamma</code>, <code class="reqn">\Sigma</code>, or <code class="reqn">\Theta</code>.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_name1">name1</code></td>
<td>
<p>Name of the input representation.</p>
</td></tr>
<tr><td><code id="Gamma2Sigma_+3A_name2">name2</code></td>
<td>
<p>Name of the output representation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>k</code>, <code>k1</code>, or <code>k2</code> is <code>NULL</code>, the corresponding <code style="white-space: pre;">&#8288;full*&#8288;</code> argument is ignored.
</p>
<p><code>Gamma2Gamma</code> only checks and returns the input.
</p>
<p><code>matrix2matrix</code> is a wrapper function that calls the corresponding
conversion function implied by <code>name1</code>, <code>name2</code>.
</p>


<h3>Value</h3>

<p>The desired parameter matrix corresponding to the specified inputs.
</p>


<h3>See Also</h3>

<p>Other parameter matrix transformations:
<code><a href="#topic+Gamma2graph">Gamma2graph</a>()</code>,
<code><a href="#topic+chi2Gamma">chi2Gamma</a>()</code>,
<code><a href="#topic+par2Matrix">par2Matrix</a>()</code>
</p>

<hr>
<h2 id='generate_random_chordal_graph'>Generate random graphs</h2><span id='topic+generate_random_chordal_graph'></span><span id='topic+generate_random_connected_graph'></span><span id='topic+generate_random_tree'></span><span id='topic+generate_random_cactus'></span>

<h3>Description</h3>

<p>Generate random graphs with different structures.
These do not follow well-defined distributions and are mostly meant for quickly
generating test models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_chordal_graph(
  d,
  cMin = 2,
  cMax = 6,
  sMin = 1,
  sMax = 4,
  block_graph = FALSE,
  ...
)

generate_random_connected_graph(
  d,
  m = NULL,
  p = 2/(d + 1),
  maxTries = 1000,
  ...
)

generate_random_tree(d)

generate_random_cactus(d, cMin = 2, cMax = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_chordal_graph_+3A_d">d</code></td>
<td>
<p>Number of vertices in the graph</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_cmin">cMin</code></td>
<td>
<p>Minimal size of cliques/blocks (last one might be smaller if necessary)</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_cmax">cMax</code></td>
<td>
<p>Maximal size of cliques/blocks</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_smin">sMin</code></td>
<td>
<p>Minimal size of separators</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_smax">sMax</code></td>
<td>
<p>Maximal size of separators</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_block_graph">block_graph</code></td>
<td>
<p>Force <code style="white-space: pre;">&#8288;sMin == sMax == 1&#8288;</code> to produce a block graph</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_...">...</code></td>
<td>
<p>Ignored, only allowed for compatibility</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_m">m</code></td>
<td>
<p>Number of edges in the graph (specify this or <code>p</code>)</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_p">p</code></td>
<td>
<p>Probability of each edge being in the graph (specify this or <code>m</code>)</p>
</td></tr>
<tr><td><code id="generate_random_chordal_graph_+3A_maxtries">maxTries</code></td>
<td>
<p>Maximum number of tries to produce a connected Erdoes-Renyi graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_random_chordal_graph</code> generates a random chordal graph by starting with a (small) complete graph
and then adding new cliques until the specified size is reached.
The sizes of cliques and separators can be specified.
</p>
<p><code>generate_random_connected_graph</code> first tries to generate an Erdoes-Renyi graph, if that fails, falls back
to producing a tree and adding random edges to that tree.
</p>
<p><code>generate_random_cactus</code> generates a random cactus graph (mostly useful for benchmarking).
</p>


<h3>Value</h3>

<p>An [<code>igraph::graph</code>] object
</p>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_Gamma">generate_random_Gamma</a>()</code>,
<code><a href="#topic+generate_random_graphical_Gamma">generate_random_graphical_Gamma</a>()</code>,
<code><a href="#topic+generate_random_integer_Gamma">generate_random_integer_Gamma</a>()</code>,
<code><a href="#topic+generate_random_model">generate_random_model</a>()</code>,
<code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix</a>()</code>
</p>

<hr>
<h2 id='generate_random_Gamma'>Generate a random Gamma matrix</h2><span id='topic+generate_random_Gamma'></span>

<h3>Description</h3>

<p>Generates a valid Gamma matrix with a given dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_Gamma(d, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_Gamma_+3A_d">d</code></td>
<td>
<p>Size of the matrix</p>
</td></tr>
<tr><td><code id="generate_random_Gamma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix()</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_chordal_graph">generate_random_chordal_graph</a>()</code>,
<code><a href="#topic+generate_random_graphical_Gamma">generate_random_graphical_Gamma</a>()</code>,
<code><a href="#topic+generate_random_integer_Gamma">generate_random_integer_Gamma</a>()</code>,
<code><a href="#topic+generate_random_model">generate_random_model</a>()</code>,
<code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix</a>()</code>
</p>

<hr>
<h2 id='generate_random_graphical_Gamma'>Generate a random Gamma matrix for a given graph</h2><span id='topic+generate_random_graphical_Gamma'></span>

<h3>Description</h3>

<p>Generates a valid Gamma matrix with conditional independence structure
specified by a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_graphical_Gamma(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_graphical_Gamma_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object</p>
</td></tr>
<tr><td><code id="generate_random_graphical_Gamma_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix()</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_Gamma">generate_random_Gamma</a>()</code>,
<code><a href="#topic+generate_random_chordal_graph">generate_random_chordal_graph</a>()</code>,
<code><a href="#topic+generate_random_integer_Gamma">generate_random_integer_Gamma</a>()</code>,
<code><a href="#topic+generate_random_model">generate_random_model</a>()</code>,
<code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix</a>()</code>
</p>

<hr>
<h2 id='generate_random_integer_Gamma'>Generate a random Gamma matrix containing only integers</h2><span id='topic+generate_random_integer_Gamma'></span>

<h3>Description</h3>

<p>Generates a random variogram Matrix by producing a <code class="reqn">(d-1) \times (d-1)</code> matrix <code>B</code> with random
integer entries between <code>-b</code> and <code>b</code>, computing <code>S = B %*% t(B)</code>,
and passing this <code>S</code> to <code><a href="#topic+Sigma2Gamma">Sigma2Gamma()</a></code>.
This process is repeated with an increasing <code>b</code> until a valid Gamma matrix
is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_integer_Gamma(d, b = 2, b_step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_integer_Gamma_+3A_d">d</code></td>
<td>
<p>Number of rows/columns in the output matrix</p>
</td></tr>
<tr><td><code id="generate_random_integer_Gamma_+3A_b">b</code></td>
<td>
<p>Initial <code>b</code> used in the algorithm described above</p>
</td></tr>
<tr><td><code id="generate_random_integer_Gamma_+3A_b_step">b_step</code></td>
<td>
<p>By how much <code>b</code> is increased in each iteration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code class="reqn">d \times d</code> variogram matrix with integer entries
</p>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_Gamma">generate_random_Gamma</a>()</code>,
<code><a href="#topic+generate_random_chordal_graph">generate_random_chordal_graph</a>()</code>,
<code><a href="#topic+generate_random_graphical_Gamma">generate_random_graphical_Gamma</a>()</code>,
<code><a href="#topic+generate_random_model">generate_random_model</a>()</code>,
<code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
generate_random_integer_Gamma(5, 2, 0.1)

</code></pre>

<hr>
<h2 id='generate_random_model'>Generate random Huesler-Reiss Models</h2><span id='topic+generate_random_model'></span>

<h3>Description</h3>

<p>Generates a random connected graph and Gamma matrix with conditional independence
structure corresponding to that graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_model(d, graph_type = "general", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_model_+3A_d">d</code></td>
<td>
<p>Number of vertices in the graph</p>
</td></tr>
<tr><td><code id="generate_random_model_+3A_graph_type">graph_type</code></td>
<td>
<p><code>"tree"</code>, <code>"block"</code>, <code>"decomposable"</code>, <code>"complete"</code>, or <code>"general"</code></p>
</td></tr>
<tr><td><code id="generate_random_model_+3A_...">...</code></td>
<td>
<p>Further arguments passed to functions generating the graph and Gamma matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_Gamma">generate_random_Gamma</a>()</code>,
<code><a href="#topic+generate_random_chordal_graph">generate_random_chordal_graph</a>()</code>,
<code><a href="#topic+generate_random_graphical_Gamma">generate_random_graphical_Gamma</a>()</code>,
<code><a href="#topic+generate_random_integer_Gamma">generate_random_integer_Gamma</a>()</code>,
<code><a href="#topic+generate_random_spd_matrix">generate_random_spd_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
d &lt;- 12

generate_random_model(d, 'tree')
generate_random_model(d, 'block')
generate_random_model(d, 'decomposable')
generate_random_model(d, 'general')
generate_random_model(d, 'complete')

</code></pre>

<hr>
<h2 id='generate_random_spd_matrix'>Generate a random symmetric positive definite matrix</h2><span id='topic+generate_random_spd_matrix'></span>

<h3>Description</h3>

<p>Generates a random <code class="reqn">d \times d</code> symmetric positive definite matrix.
This is done by generating a random <code class="reqn">d \times d</code> matrix <code>B</code>,
then computing <code>B %*% t(B)</code>,
and then normalizing the matrix to approximately single digit entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_random_spd_matrix(d, bMin = -10, bMax = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_random_spd_matrix_+3A_d">d</code></td>
<td>
<p>Number of rows/columns</p>
</td></tr>
<tr><td><code id="generate_random_spd_matrix_+3A_bmin">bMin</code></td>
<td>
<p>Minimum value of entries in <code>B</code></p>
</td></tr>
<tr><td><code id="generate_random_spd_matrix_+3A_bmax">bMax</code></td>
<td>
<p>Maximum value of entries in <code>B</code></p>
</td></tr>
<tr><td><code id="generate_random_spd_matrix_+3A_...">...</code></td>
<td>
<p>Ignored, only allowed for compatibility</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other example generation functions:
<code><a href="#topic+generate_random_Gamma">generate_random_Gamma</a>()</code>,
<code><a href="#topic+generate_random_chordal_graph">generate_random_chordal_graph</a>()</code>,
<code><a href="#topic+generate_random_graphical_Gamma">generate_random_graphical_Gamma</a>()</code>,
<code><a href="#topic+generate_random_integer_Gamma">generate_random_integer_Gamma</a>()</code>,
<code><a href="#topic+generate_random_model">generate_random_model</a>()</code>
</p>

<hr>
<h2 id='get_alert_function'>Get alert function</h2><span id='topic+get_alert_function'></span>

<h3>Description</h3>

<p>Get a function that can be used to alert the user of invalid inputs.
Returns the value implied by the <code>overwrite</code> argument,
or the option <code>"graphicalExtremes.default.alert"</code>,
falling back to <code>warning()</code> if neither is specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alert_function(overwrite = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alert_function_+3A_overwrite">overwrite</code></td>
<td>
<p><code>NULL</code> or <code>TRUE</code> to read the option value,
<code>FALSE</code> to return a dummy function,
or a function that takes an arbitrary number of strings as arguments (e.g. <code>stop()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes an arbitrary number of strings as arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphicalExtremes-package">graphicalExtremes-package</a></code>
</p>
<p>Other default parameters:
<code><a href="#topic+get_mc_cores">get_mc_cores</a>()</code>,
<code><a href="#topic+get_small_tol">get_small_tol</a>()</code>
</p>

<hr>
<h2 id='get_cliques_and_separators'>Get Cliques and Separators of a graph</h2><span id='topic+get_cliques_and_separators'></span>

<h3>Description</h3>

<p>Finds all cliques, separators, and (recursively) separators of separators
in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cliques_and_separators(
  graph,
  sortIntoLayers = FALSE,
  includeSingletons = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cliques_and_separators_+3A_graph">graph</code></td>
<td>
<p>An [<code>igraph::graph</code>] object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex sets that represent the cliques and (recursive)
separators of <code>graph</code>, ordered such that separators come before cliques they separate.
</p>

<hr>
<h2 id='get_cliques_and_separators_OLD'>Get Cliques and Separators of a graph</h2><span id='topic+get_cliques_and_separators_OLD'></span>

<h3>Description</h3>

<p>Finds all cliques, separators, and (recursively) separators of separators
in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cliques_and_separators_OLD(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cliques_and_separators_OLD_+3A_graph">graph</code></td>
<td>
<p>An [<code>igraph::graph</code>] object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex sets that represent the cliques and (recursive)
separators of <code>graph</code>
</p>

<hr>
<h2 id='get_mc_cores'>Number of cores to be used in parallel computations</h2><span id='topic+get_mc_cores'></span>

<h3>Description</h3>

<p>Helper function that returns the number of cores to be used in parallel computations.
Will always be 1 on Windows. On other systems, this value can be set using
<code>setOption('graphicalExtremes.mc.cores', ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mc_cores(overwrite = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mc_cores_+3A_overwrite">overwrite</code></td>
<td>
<p>Use this value (if it is valid and not on Windows)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer to be used as number of cores
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphicalExtremes-package">graphicalExtremes-package</a></code>
</p>
<p>Other default parameters:
<code><a href="#topic+get_alert_function">get_alert_function</a>()</code>,
<code><a href="#topic+get_small_tol">get_small_tol</a>()</code>
</p>

<hr>
<h2 id='get_small_tol'>Tolerances to be used in computations</h2><span id='topic+get_small_tol'></span><span id='topic+get_large_tol'></span>

<h3>Description</h3>

<p>Helper function that returns the tolerance to be used in internal computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_small_tol(overwrite = NULL)

get_large_tol(overwrite = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_small_tol_+3A_overwrite">overwrite</code></td>
<td>
<p><code>NULL</code> or numeric scalar. If specified, use this value
instead of the option value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two different tolerances used in the package, for details see
<code><a href="#topic+graphicalExtremes-package">graphicalExtremes-package</a></code>. The default values for these tolerances can be
set using the options <code>"graphicalExtremes.tol.small"</code> and
<code>"graphicalExtremes.tol.large"</code>.
</p>


<h3>Value</h3>

<p>A non-negative numerical scalar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graphicalExtremes-package">graphicalExtremes-package</a></code>
</p>
<p>Other default parameters:
<code><a href="#topic+get_alert_function">get_alert_function</a>()</code>,
<code><a href="#topic+get_mc_cores">get_mc_cores</a>()</code>
</p>

<hr>
<h2 id='getDanubeFlowGraph'>Get Danube flow graph</h2><span id='topic+getDanubeFlowGraph'></span>

<h3>Description</h3>

<p>Returns an <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object representing the flow graph of the <code><a href="#topic+danube">danube</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDanubeFlowGraph(stationIndices = NULL, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDanubeFlowGraph_+3A_stationindices">stationIndices</code></td>
<td>
<p>Logical or numerical vector. Indicating which stations to include.</p>
</td></tr>
<tr><td><code id="getDanubeFlowGraph_+3A_directed">directed</code></td>
<td>
<p>Logical. Whether the graph should be directed (in the direction of flow).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object.
</p>


<h3>See Also</h3>

<p>Other danubeData: 
<code><a href="#topic+danube">danube</a></code>,
<code><a href="#topic+plotDanube">plotDanube</a>()</code>
</p>

<hr>
<h2 id='getFlightDelayData'>Get filtered flight delays</h2><span id='topic+getFlightDelayData'></span>

<h3>Description</h3>

<p>Get filtered flight delay data, containing only a selection of dates and airports.
Currently, all possible selections correspond to the case study in Hentschel et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFlightDelayData(
  what = c("delays", "IATAs", "dates"),
  airportFilter = c("all", "tcCluster", "tcAll"),
  dateFilter = c("all", "tcTrain", "tcTest", "tcAll"),
  delayFilter = c("totals", "arrivals", "departures")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFlightDelayData_+3A_what">what</code></td>
<td>
<p>Whether to get the array of delays (numerical),
or just the vector of airport codes (<code>"IATAs"</code>, strings)
or dates (as strings). Specify exactly one.</p>
</td></tr>
<tr><td><code id="getFlightDelayData_+3A_airportfilter">airportFilter</code></td>
<td>
<p>Which airports to include. Specify exactly one. See details below.</p>
</td></tr>
<tr><td><code id="getFlightDelayData_+3A_datefilter">dateFilter</code></td>
<td>
<p>Which dates to include. Specify exactly one. See details below.</p>
</td></tr>
<tr><td><code id="getFlightDelayData_+3A_delayfilter">delayFilter</code></td>
<td>
<p>Which kinds of delays to include. Specify one or more.
Possible values are <code>"arrivals"</code>, <code>"departures"</code>, and <code>"totals"</code> (computed as sum of arrival and departure delays).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The provided lists of airports and dates correspond to the ones used in
the case study of Hentschel et al. (2022).
The argument <code>airportFilter="tcCluster"</code> corresponds to the airports in the analyzed &quot;Texas Cluster&quot;,
<code>airportFilter="tcAll"</code> corresponds to all airports used in the previous clustering step,
<code>airportFilter="all"</code> corresponds to all airports in the dataset.
</p>
<p>Similarly, <code>dateFilter="tcTrain"</code> selects the dates from the training set,
<code>dateFilter="tcTest"</code> the ones from the test/validation set.
To get the union of these sets, specify <code>dateFilter="tcAll"</code>.
To get all dates in the dataset (possibly more than for &quot;tcAll&quot;),
specify <code>dateFilter="all"</code>.
</p>


<h3>Value</h3>

<p>If <code>what="IATAs"</code> or <code>what="dates"</code>, a character vector.
If required, it can be converted to <code><a href="base.html#topic+Date">Date</a></code> objects using <code><a href="base.html#topic+as.Date">as.Date()</a></code>.
</p>
<p>If <code>what="delays"</code>, a three-dimensional array or two-dimensional matrix,
with dimensions corresponding to dates, airports, and delay types.
</p>


<h3>References</h3>

<p>Hentschel M, Engelke S, Segers J (2022).
&ldquo;Statistical Inference for Hüsler-Reiss Graphical Models Through Matrix Completions.&rdquo;
<a href="https://doi.org/10.48550/ARXIV.2210.14292">doi:10.48550/ARXIV.2210.14292</a>, <a href="https://arxiv.org/abs/2210.14292">https://arxiv.org/abs/2210.14292</a>.
</p>


<h3>See Also</h3>

<p>Other flight data related topics:
<code><a href="#topic+flightCountMatrixToConnectionList">flightCountMatrixToConnectionList</a>()</code>,
<code><a href="#topic+flights">flights</a></code>,
<code><a href="#topic+getFlightGraph">getFlightGraph</a>()</code>,
<code><a href="#topic+plotFlights">plotFlights</a>()</code>
</p>

<hr>
<h2 id='getFlightGraph'>Get flight graph</h2><span id='topic+getFlightGraph'></span>

<h3>Description</h3>

<p>Convert the info from <code>flights$flightCounts</code> to an <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFlightGraph(IATAs = NULL, years = NULL, minNFlights = 1, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFlightGraph_+3A_iatas">IATAs</code></td>
<td>
<p>Character vector. IATA codes of airports to include</p>
</td></tr>
<tr><td><code id="getFlightGraph_+3A_years">years</code></td>
<td>
<p>Character vector. Years to include (as strings).</p>
</td></tr>
<tr><td><code id="getFlightGraph_+3A_minnflights">minNFlights</code></td>
<td>
<p>Numerical scalar. Minimum number of flights on a connection to
be included as an edge.</p>
</td></tr>
<tr><td><code id="getFlightGraph_+3A_directed">directed</code></td>
<td>
<p>Logical scalar. Whether flights A-&gt;B and B-&gt;A should be considered separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object containing a vertex for each airport
and an edge whenever there are at least <code>minNFlights</code> between two airports.
</p>


<h3>See Also</h3>

<p>Other flight data related topics:
<code><a href="#topic+flightCountMatrixToConnectionList">flightCountMatrixToConnectionList</a>()</code>,
<code><a href="#topic+flights">flights</a></code>,
<code><a href="#topic+getFlightDelayData">getFlightDelayData</a>()</code>,
<code><a href="#topic+plotFlights">plotFlights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- getFlightGraph()

</code></pre>

<hr>
<h2 id='getPackageData'>Get package data</h2><span id='topic+getPackageData'></span>

<h3>Description</h3>

<p>Get private data sets from <code>inst/extdata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPackageData(filename, isRDS = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPackageData_+3A_filename">filename</code></td>
<td>
<p>Base name of the file. E.g. <code>"FILENAME"</code> for a file <code>inst/extdata/FILENAME</code>.</p>
</td></tr>
<tr><td><code id="getPackageData_+3A_isrds">isRDS</code></td>
<td>
<p>Whether the file is an <code>.RDS</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>isRDS=TRUE</code> an R object.
If <code>isRDS=FALSE</code> an environment, containing the R objects from the file.
</p>

<hr>
<h2 id='getSubMatrixForSubgraph'>Get the submatrix corresponding to a subgraph</h2><span id='topic+getSubMatrixForSubgraph'></span>

<h3>Description</h3>

<p>Both the graph and subgraph need to have persistent IDs
If graph==NULL it is assumed to have pIDs 1, 2, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubMatrixForSubgraph(fullMatrix, subgraph, graph = NULL)
</code></pre>

<hr>
<h2 id='graphs_equal'>Graph equality</h2><span id='topic+graphs_equal'></span>

<h3>Description</h3>

<p>Produce true if two graphs have same vertices and edges (ordered)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphs_equal(g1, g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphs_equal_+3A_g1">g1</code></td>
<td>
<p><code>igraph::graph</code></p>
</td></tr>
<tr><td><code id="graphs_equal_+3A_g2">g2</code></td>
<td>
<p><code>igraph::graph</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical</code> indicating if the graphs are equal
</p>

<hr>
<h2 id='logdV_HR'>Compute the exponent measure density of HR distribution</h2><span id='topic+logdV_HR'></span>

<h3>Description</h3>

<p>Computes the exponent measure density of HR distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdV_HR(x, Gamma = NULL, Theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logdV_HR_+3A_x">x</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix or vector with <code>d</code> elements.</p>
</td></tr>
<tr><td><code id="logdV_HR_+3A_gamma">Gamma</code></td>
<td>
<p>d x d variogram matrix or numeric vector with d(d-1)/2 elements,
containing the upper triangular part of a variogram matrix.</p>
</td></tr>
<tr><td><code id="logdV_HR_+3A_theta">Theta</code></td>
<td>
<p>d x d precision matrix or numeric vector with d(d-1)/2 elements,
containing the upper triangular part of a precision matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>Gamma</code> and <code>Theta</code> are needed internally, but if one
is missing it is computed from the other one.
</p>


<h3>Value</h3>

<p>Numeric. The censored exponent measure of the HR distribution.
</p>

<hr>
<h2 id='logdVK_HR'>Compute censored exponent measure</h2><span id='topic+logdVK_HR'></span>

<h3>Description</h3>

<p>Computes the (censored) exponent measure density of HR distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdVK_HR(x, K, Gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logdVK_HR_+3A_x">x</code></td>
<td>
<p>Numeric vector with <code>d</code> positive elements
where the censored exponent measure is to be evaluated.</p>
</td></tr>
<tr><td><code id="logdVK_HR_+3A_k">K</code></td>
<td>
<p>Integer vector, subset of 1, ..., <code>d</code>, the index set that is not censored.
Or logical vector of length <code>d</code>, indicating entries that are not censored.</p>
</td></tr>
<tr><td><code id="logdVK_HR_+3A_gamma">Gamma</code></td>
<td>
<p>d x d variogram matrix or numeric vector with d(d-1)/2 elements,
containing the upper triangular part of a variogram matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The censored exponent measure of the HR distribution.
If no entries are censored, the result of <code style="white-space: pre;">&#8288;logdV_HR(x, par&#8288;</code> is returned.
</p>

<hr>
<h2 id='logLH_HR'>Full censored log-likelihood of HR model</h2><span id='topic+logLH_HR'></span>

<h3>Description</h3>

<p>Computes the full (censored) log-likelihood of HR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLH_HR(data, Gamma, cens = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLH_HR_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix, containing
observations following a multivariate HR Pareto distribution.</p>
</td></tr>
<tr><td><code id="logLH_HR_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">d \times d</code> matrix, representing a variogram matrix <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code id="logLH_HR_+3A_cens">cens</code></td>
<td>
<p>Boolean. If true, then censored log-likelihood is computed.
By default, <code>cens = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The full censored log-likelihood of HR model.
</p>

<hr>
<h2 id='loglik_HR'>Compute Huesler-Reiss log-likelihood, AIC, and BIC</h2><span id='topic+loglik_HR'></span>

<h3>Description</h3>

<p>Computes (censored) Huesler-Reiss log-likelihood, AIC, and BIC values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_HR(data, p = NULL, graph = NULL, Gamma, cens = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_HR_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix. It contains
observations following a multivariate HR Pareto distribution.</p>
</td></tr>
<tr><td><code id="loglik_HR_+3A_p">p</code></td>
<td>
<p>Numeric between 0 and 1 or <code>NULL</code>. If <code>NULL</code> (default),
it is assumed that the <code>data</code> are already on multivariate Pareto scale.
Else, <code>p</code> is used as the probability in the function <code><a href="#topic+data2mpareto">data2mpareto()</a></code>
to standardize the <code>data</code>.</p>
</td></tr>
<tr><td><code id="loglik_HR_+3A_graph">graph</code></td>
<td>
<p>An [<code>igraph::graph</code>] object or <code>NULL</code>. The <code>graph</code> must be undirected and
connected. If no graph is specified, the complete graph is used.</p>
</td></tr>
<tr><td><code id="loglik_HR_+3A_gamma">Gamma</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix.
It represents a variogram matrix <code class="reqn">\Gamma</code>.</p>
</td></tr>
<tr><td><code id="loglik_HR_+3A_cens">cens</code></td>
<td>
<p>Boolean. If true, then censored log-likelihood is computed.
By default, <code>cens = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector <code>c("loglik"=..., "aic"=..., "bic"=...)</code> with the evaluated
log-likelihood, AIC, and BIC values.
</p>


<h3>See Also</h3>

<p>Other parameter estimation methods:
<code><a href="#topic+data2mpareto">data2mpareto</a>()</code>,
<code><a href="#topic+emp_chi_multdim">emp_chi_multdim</a>()</code>,
<code><a href="#topic+emp_chi">emp_chi</a>()</code>,
<code><a href="#topic+emp_vario">emp_vario</a>()</code>,
<code><a href="#topic+emtp2">emtp2</a>()</code>,
<code><a href="#topic+fmpareto_HR_MLE">fmpareto_HR_MLE</a>()</code>,
<code><a href="#topic+fmpareto_graph_HR">fmpareto_graph_HR</a>()</code>
</p>

<hr>
<h2 id='make_numeric_indices'>Convert indices to numerical indices</h2><span id='topic+make_numeric_indices'></span>

<h3>Description</h3>

<p>Converts (possibly) logical indices to numerical ones.
Also ensures unique indices and sorts them if specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_numeric_indices(ind, n = NULL, unique = TRUE, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_numeric_indices_+3A_ind">ind</code></td>
<td>
<p>The numerical or logical index vector</p>
</td></tr>
<tr><td><code id="make_numeric_indices_+3A_n">n</code></td>
<td>
<p>Max numerical index (used if <code>ind</code> is logical and might be recycled)</p>
</td></tr>
<tr><td><code id="make_numeric_indices_+3A_unique">unique</code></td>
<td>
<p>Whether to keep every (numerical) index at most once</p>
</td></tr>
<tr><td><code id="make_numeric_indices_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the numerical indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical index vector
</p>

<hr>
<h2 id='make_sep_list'>Create a list of separators</h2><span id='topic+make_sep_list'></span>

<h3>Description</h3>

<p>Creates a list of separator set, such that every pair of non-adjacent
vertices in <code>graph</code> is completely disconnected by the removal of
(at least) one of the separator sets from the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sep_list(graph, details = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sep_list_+3A_graph">graph</code></td>
<td>
<p>A graph</p>
</td></tr>
<tr><td><code id="make_sep_list_+3A_details">details</code></td>
<td>
<p>Return detailed infos (default <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of numeric vectors
</p>

<hr>
<h2 id='mparetomargins'>Marginalize multivariate Pareto dataset</h2><span id='topic+mparetomargins'></span>

<h3>Description</h3>

<p>Marginalize a multivariate Pareto dataset <code>data</code> with respect to the
variables in <code>set_indices</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mparetomargins(data, set_indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mparetomargins_+3A_data">data</code></td>
<td>
<p>Numeric <code class="reqn">n \times d</code> matrix. A dataset containing
observations following a multivariate Pareto distribution.</p>
</td></tr>
<tr><td><code id="mparetomargins_+3A_set_indices">set_indices</code></td>
<td>
<p>Numeric vector with at most <code>d</code> different elements in
1, ..., <code>d</code>. The variables with respect to which to marginalize
the multivariate distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times m</code> matrix, where <code>m</code> is the length
of <code>set_indices</code>. Marginalized multivariate Pareto data.
</p>

<hr>
<h2 id='order_cliques'>Order Cliques</h2><span id='topic+order_cliques'></span>

<h3>Description</h3>

<p>Orders the cliques in a connected decomposable graph so that they fulfill the running intersection property.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_cliques(cliques)
</code></pre>

<hr>
<h2 id='par2Matrix'>Create Gamma or Theta from vector</h2><span id='topic+par2Matrix'></span><span id='topic+par2Gamma'></span><span id='topic+par2Theta'></span><span id='topic+matrix2par'></span>

<h3>Description</h3>

<p>Convert parameter vector <code>par</code> (upper triangular part of Gamma/Theta matrix)
to full Gamma/Theta, or vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par2Matrix(par, allowMatrix = FALSE, allowNull = FALSE, zeroRowSums = FALSE)

par2Gamma(par, allowMatrix = FALSE, allowNull = FALSE)

par2Theta(par, allowMatrix = FALSE, allowNull = FALSE)

matrix2par(M, allowVector = FALSE, allowNull = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par2Matrix_+3A_par">par</code></td>
<td>
<p>Numeric vector with <code>d</code> elements.
Upper triangular part of a Gamma/Theta matrix.</p>
</td></tr>
<tr><td><code id="par2Matrix_+3A_allowmatrix">allowMatrix</code></td>
<td>
<p>If <code>TRUE</code> and <code>par</code> is already a matrix, return it as is.</p>
</td></tr>
<tr><td><code id="par2Matrix_+3A_allownull">allowNull</code></td>
<td>
<p>If <code>TRUE</code> and <code>par</code> is NULL, return NULL.</p>
</td></tr>
<tr><td><code id="par2Matrix_+3A_zerorowsums">zeroRowSums</code></td>
<td>
<p>If <code>TRUE</code> the diagonal is set to (-1) times the rowSums.</p>
</td></tr>
<tr><td><code id="par2Matrix_+3A_m">M</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="par2Matrix_+3A_allowvector">allowVector</code></td>
<td>
<p>If <code>TRUE</code> and <code>M</code> is already a vector, return it as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix <code class="reqn">d \times d</code>. Full Gamma/Theta matrix corresponding to <code>par</code>.
</p>
<p>Upper triangular part of <code>M</code> (or <code>M</code> itself/NULL if allowed)
</p>


<h3>See Also</h3>

<p>Other parameter matrix transformations:
<code><a href="#topic+Gamma2Sigma">Gamma2Sigma</a>()</code>,
<code><a href="#topic+Gamma2graph">Gamma2graph</a>()</code>,
<code><a href="#topic+chi2Gamma">chi2Gamma</a>()</code>
</p>

<hr>
<h2 id='parToMatricesFactory'>Factory: parToMatrices</h2><span id='topic+parToMatricesFactory'></span>

<h3>Description</h3>

<p>Creates a helper function to convert a parameter vector <code>par</code> to a Gamma and/or Theta matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parToMatricesFactory(
  graph,
  init = NULL,
  fixParams = integer(0),
  parIsTheta = FALSE,
  checkValidity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parToMatricesFactory_+3A_graph">graph</code></td>
<td>
<p><code>par</code> represents entries corresponding to the edges of <code>graph</code>.</p>
</td></tr>
<tr><td><code id="parToMatricesFactory_+3A_init">init</code></td>
<td>
<p>The values used for fixed parameters</p>
</td></tr>
<tr><td><code id="parToMatricesFactory_+3A_fixparams">fixParams</code></td>
<td>
<p>The indices (logical or numeric) of fixed parameters in the full parameter vector.</p>
</td></tr>
<tr><td><code id="parToMatricesFactory_+3A_paristheta">parIsTheta</code></td>
<td>
<p><code>TRUE</code> if <code>par</code> represents entries in Theta (otherwise Gamma)</p>
</td></tr>
<tr><td><code id="parToMatricesFactory_+3A_checkvalidity">checkValidity</code></td>
<td>
<p>Whether to check if the implied Gamma/Theta is a valid parameter matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function <code>parToMatrices(par, forceGamma=FALSE, forceTheta=FALSE)</code>,
which takes a parameter vector and returns either <code>NULL</code> or a list with entries <code>Gamma</code>, <code>Theta</code>.
The function returns <code>NULL</code> if <code>checkValidity==TRUE</code> and <code>par</code> implies an invalid matrix.
Otherwise, depending on <code>parIsTheta</code>, <code>forceTheta</code>, and <code>forceGamma</code>, one or both of
<code>Gamma</code> and <code>Theta</code> are matrices implied by <code>par</code>.
</p>

<hr>
<h2 id='plotDanube'>Plot Danube River Flow Data</h2><span id='topic+plotDanube'></span><span id='topic+plotDanubeIGraph'></span>

<h3>Description</h3>

<p>Plotting function to visualize the river flow data from the <code><a href="#topic+danube">danube</a></code> dataset.
Requires <code>ggplot2</code> to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDanube(
  stationIndices = NULL,
  graph = NULL,
  directed = NULL,
  plotStations = TRUE,
  plotConnections = TRUE,
  labelStations = FALSE,
  returnGGPlot = FALSE,
  useStationVolume = FALSE,
  useConnectionVolume = FALSE,
  mapCountries = c("Germany"),
  vertexColors = NULL,
  vertexShapes = NULL,
  edgeColors = NULL,
  xyRatio = NULL,
  clipMap = 1.2,
  useLatex = FALSE,
  edgeAlpha = 0.2
)

plotDanubeIGraph(
  stationIndices = NULL,
  graph = NULL,
  directed = NULL,
  labelStations = TRUE,
  vertexColors = NULL,
  vertexShapes = NULL,
  edgeColors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDanube_+3A_stationindices">stationIndices</code></td>
<td>
<p>Logical or numerical vector, indicating the stations to be plotted.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_graph">graph</code></td>
<td>
<p>An <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object or <code>NULL</code> to use the flow graph.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_directed">directed</code></td>
<td>
<p>Logical. Whether to consider the flow graph as directed.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_plotstations">plotStations</code></td>
<td>
<p>Logical. Whether to plot the stations.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_plotconnections">plotConnections</code></td>
<td>
<p>Logical. Whether to plot the connections.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_labelstations">labelStations</code></td>
<td>
<p>Logical. Whether to label stations.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_returnggplot">returnGGPlot</code></td>
<td>
<p>If <code>TRUE</code>, a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a></code> object is returned and not plotted immediately.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_usestationvolume">useStationVolume</code></td>
<td>
<p>Logical. Whether to indicate flow volume at a station by circle size.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_useconnectionvolume">useConnectionVolume</code></td>
<td>
<p>Logical. Whether to indicate flow volume on a connection by line width.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_mapcountries">mapCountries</code></td>
<td>
<p>Which country borders to show using <code>ggplot2::map_data('world', mapCountries)</code>.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_vertexcolors">vertexColors</code></td>
<td>
<p>Vector with color information for vertices.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_vertexshapes">vertexShapes</code></td>
<td>
<p>Vector with shape information for vertices.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_edgecolors">edgeColors</code></td>
<td>
<p>Vector with color information for edges.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_xyratio">xyRatio</code></td>
<td>
<p>Approximate X-Y-ratio (w.r.t. distance on the ground) of the area shown in the plot.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_clipmap">clipMap</code></td>
<td>
<p>Logical or numeric scalar. Whether to ignore the map image when determining the axis limits of the plot.
If it is a positive scalar, the plot limits are extended by that factor.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_uselatex">useLatex</code></td>
<td>
<p>Whether to format numbers etc. as latex code (useful when plotting to tikz).</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_edgealpha">edgeAlpha</code></td>
<td>
<p>Numeric scalar between 0 and 1. The alpha value to be used when plotting edges/connections.</p>
</td></tr>
<tr><td><code id="plotDanube_+3A_...">...</code></td>
<td>
<p>Passed through to <code><a href="igraph.html#topic+plot.igraph">igraph::plot.igraph</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>vertexColors</code>, <code>vertexShapes</code>, and <code>edgeColors</code> are interpreted differently
by <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>/<code><a href="ggplot2.html#topic+geom_segment">ggplot2::geom_segment</a></code> and <code><a href="igraph.html#topic+plot.igraph">igraph::plot.igraph()</a></code>.
</p>
<p><code>plotDanube</code> uses a combination of <code>ggplot2</code> functions to plot the graph.
</p>
<p><code>plotDanubeIGraph</code> uses <code><a href="igraph.html#topic+plot.igraph">igraph::plot.igraph</a></code> to plot the graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotFlights">plotFlights</a></code>
</p>
<p>Other danubeData: 
<code><a href="#topic+danube">danube</a></code>,
<code><a href="#topic+getDanubeFlowGraph">getDanubeFlowGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic plot
graphicalExtremes::plotDanube()

# Plot flow volumes
graphicalExtremes::plotDanube(
    clipMap = 1.2,
    useConnectionVolume = TRUE,
    useStationVolume = TRUE
)

# Plot other graph structures
nStations &lt;- nrow(graphicalExtremes::danube$info)
g &lt;- igraph::erdos.renyi.game(nStations, nStations, 'gnm')
graphicalExtremes::plotDanube(
    clipMap = 1.2,
    graph = g
)

</code></pre>

<hr>
<h2 id='plotFlights'>Plot flight data</h2><span id='topic+plotFlights'></span>

<h3>Description</h3>

<p>Plotting function to visualize the flight connections from the <code><a href="#topic+flights">flights</a></code> dataset.
This function requires the package <code>ggplot2</code> to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFlights(
  airportIndices = NULL,
  airports_sel = NULL,
  connections_sel = NULL,
  graph = NULL,
  plotAirports = TRUE,
  plotConnections = TRUE,
  labelAirports = FALSE,
  returnGGPlot = FALSE,
  useAirportNFlights = FALSE,
  useConnectionNFlights = FALSE,
  minNFlights = 0,
  map = "state",
  vertexColors = NULL,
  vertexShapes = NULL,
  edgeColors = NULL,
  xyRatio = NULL,
  clipMap = FALSE,
  useLatex = FALSE,
  edgeAlpha = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFlights_+3A_airportindices">airportIndices</code></td>
<td>
<p>The indices of the airports (w.r.t. <code>airports_sel</code>) to include.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_airports_sel">airports_sel</code></td>
<td>
<p>The airports to plot. Might be further subset by arguments <code>airportIndices</code>, <code>graph</code>.
If <code>NULL</code>, then <code><a href="#topic+flights">flights</a></code><code style="white-space: pre;">&#8288;$airports&#8288;</code> will be used.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_connections_sel">connections_sel</code></td>
<td>
<p>A three columns data frame as output by <code><a href="#topic+flightCountMatrixToConnectionList">flightCountMatrixToConnectionList()</a></code>.
If <code>NULL</code>, then <code><a href="#topic+flights">flights</a></code><code style="white-space: pre;">&#8288;$nFlights&#8288;</code> will be used to construct one.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_graph">graph</code></td>
<td>
<p>An optional <code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object, containing a flight graph to plot.
Vertices should either match the selected airports in number and order,
or be named with the corresponding IATA codes of the airports they represent.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_plotairports">plotAirports</code></td>
<td>
<p>Logical. Whether to plot the airports specified.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_plotconnections">plotConnections</code></td>
<td>
<p>Logical. Whether to plot the connections specified.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_labelairports">labelAirports</code></td>
<td>
<p>Logical. Whether to show the IATA code next to each plotted airport.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_returnggplot">returnGGPlot</code></td>
<td>
<p>If <code>TRUE</code>, a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a></code> object is returned and not plotted immediately.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_useairportnflights">useAirportNFlights</code></td>
<td>
<p>Logical. Whether to vary the size of the circles representing airports in the plot,
according to the number of flights at that airport.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_useconnectionnflights">useConnectionNFlights</code></td>
<td>
<p>Logical. Whether to vary the size of the edges representing connections in the plot,
according to the number of flights on that connection.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_minnflights">minNFlights</code></td>
<td>
<p>Numeric scalar. Only plot connections with at least this many flights.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_map">map</code></td>
<td>
<p>String or <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>NULL</code>. What map to use as the background image.
Strings are passed to <code><a href="ggplot2.html#topic+map_data">ggplot2::map_data()</a></code>, data frames are assumed to be the output of <code><a href="ggplot2.html#topic+map_data">ggplot2::map_data()</a></code>.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_vertexcolors">vertexColors</code></td>
<td>
<p>Optional vector, named with IATA codes, to be used as colors for the vertices/airports.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_vertexshapes">vertexShapes</code></td>
<td>
<p>Optional vector, named with IATA codes, to be used as shapes for the vertices/airports. Is coerced to <code>character</code>.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_edgecolors">edgeColors</code></td>
<td>
<p>Optional vector or symmetric matrix (character or numeric), to be used as colors for edges/connections.
If this is a vector, its entries must match the plotted connections (in the order specified in <code>connections_sel</code> or implied by <code><a href="igraph.html#topic+as_edgelist">igraph::get.edgelist</a></code>).
If this is a matrix, its row/column names must be IATA codes, or its rows/columns match the plotted airports (in number and order).</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_xyratio">xyRatio</code></td>
<td>
<p>Approximate X-Y-ratio (w.r.t. distance on the ground) of the area shown in the plot.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_clipmap">clipMap</code></td>
<td>
<p>Logical or numeric scalar. Whether to ignore the map image when determining the axis limits of the plot.
If it is a positive scalar, the plot limits are extended by that factor.</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_uselatex">useLatex</code></td>
<td>
<p>Whether to format numbers etc. as latex code (useful when plotting to tikz).</p>
</td></tr>
<tr><td><code id="plotFlights_+3A_edgealpha">edgeAlpha</code></td>
<td>
<p>Numeric scalar between 0 and 1. The alpha value to be used when plotting edges/connections.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>returnGGPlot</code> is <code>TRUE</code>, a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a></code> object, otherwise <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDanube">plotDanube</a></code>
</p>
<p>Other flight data related topics:
<code><a href="#topic+flightCountMatrixToConnectionList">flightCountMatrixToConnectionList</a>()</code>,
<code><a href="#topic+flights">flights</a></code>,
<code><a href="#topic+getFlightDelayData">getFlightDelayData</a>()</code>,
<code><a href="#topic+getFlightGraph">getFlightGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot all airports in the dataset
plotFlights(plotConnections = FALSE, map = 'world')

# Plot a selection of airports
plotFlights(c('JFK', 'SFO', 'LAX'), useConnectionNFlights = TRUE, useAirportNFlights = TRUE)

# Plot airports with a custom connections graph
IATAs &lt;- c('ACV', 'BFL', 'EUG', 'SFO', 'MRY')
graph &lt;- igraph::make_full_graph(length(IATAs))
plotFlights(IATAs, graph=graph, clipMap = 1.5)

</code></pre>

<hr>
<h2 id='rmpareto'>Sampling of a multivariate Pareto distribution</h2><span id='topic+rmpareto'></span>

<h3>Description</h3>

<p>Simulates exact samples of a multivariate Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmpareto(
  n,
  model = c("HR", "logistic", "neglogistic", "dirichlet"),
  d = NULL,
  par
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmpareto_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="rmpareto_+3A_model">model</code></td>
<td>
<p>The parametric model type; one of:
</p>

<ul>
<li> <p><code>HR</code> (default),
</p>
</li>
<li> <p><code>logistic</code>,
</p>
</li>
<li> <p><code>neglogistic</code>,
</p>
</li>
<li> <p><code>dirichlet</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmpareto_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto distribution.
In some cases this can be <code>NULL</code> and will be inferred from <code>par</code>.</p>
</td></tr>
<tr><td><code id="rmpareto_+3A_par">par</code></td>
<td>
<p>Respective parameter for the given <code>model</code>, that is,
</p>

<ul>
<li> <p><code class="reqn">\Gamma</code>, numeric <code class="reqn">d \times d</code> variogram matrix, if <code>model = HR</code>.
</p>
</li>
<li> <p><code class="reqn">\theta \in (0, 1)</code>, if <code>model = logistic</code>.
</p>
</li>
<li> <p><code class="reqn">\theta &gt; 0</code>, if <code>model = neglogistic</code>.
</p>
</li>
<li> <p><code class="reqn">\alpha</code>, numeric vector of size <code>d</code> with positive entries, if <code>model = dirichlet</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation follows the algorithm in Engelke and Hitz (2020).
For details on the parameters of the Huesler-Reiss, logistic
and negative logistic distributions see Dombry et al. (2016), and for the Dirichlet
distribution see Coles and Tawn (1991).
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix of simulations of the
multivariate Pareto distribution.
</p>


<h3>References</h3>

<p>Coles S, Tawn JA (1991).
&ldquo;Modelling extreme multivariate events.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>53</b>, 377&ndash;392.<br /><br /> Dombry C, Engelke S, Oesting M (2016).
&ldquo;Exact simulation of max-stable processes.&rdquo;
<em>Biometrika</em>, <b>103</b>, 303&ndash;317.<br /><br /> Engelke S, Hitz AS (2020).
&ldquo;Graphical models for extremes (with discussion).&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>82</b>, 871&ndash;932.
</p>


<h3>See Also</h3>

<p>Other sampling functions:
<code><a href="#topic+rmpareto_tree">rmpareto_tree</a>()</code>,
<code><a href="#topic+rmstable_tree">rmstable_tree</a>()</code>,
<code><a href="#topic+rmstable">rmstable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 4-dimensional HR distribution
n &lt;- 10
d &lt;- 4
G &lt;- cbind(
  c(0, 1.5, 1.5, 2),
  c(1.5, 0, 2, 1.5),
  c(1.5, 2, 0, 1.5),
  c(2, 1.5, 1.5, 0)
)

rmpareto(n, "HR", d = d, par = G)

## A 3-dimensional logistic distribution
n &lt;- 10
d &lt;- 3
theta &lt;- .6
rmpareto(n, "logistic", d, par = theta)

## A 5-dimensional negative logistic distribution
n &lt;- 10
d &lt;- 5
theta &lt;- 1.5
rmpareto(n, "neglogistic", d, par = theta)

## A 4-dimensional Dirichlet distribution
n &lt;- 10
d &lt;- 4
alpha &lt;- c(.8, 1, .5, 2)
rmpareto(n, "dirichlet", d, par = alpha)
</code></pre>

<hr>
<h2 id='rmpareto_tree'>Sampling of a multivariate Pareto distribution on a tree</h2><span id='topic+rmpareto_tree'></span>

<h3>Description</h3>

<p>Simulates exact samples of a multivariate Pareto distribution that
is an extremal graphical model on a tree as defined in Engelke and Hitz (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmpareto_tree(n, model = c("HR", "logistic", "dirichlet")[1], tree, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmpareto_tree_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="rmpareto_tree_+3A_model">model</code></td>
<td>
<p>The parametric model type; one of:
</p>

<ul>
<li> <p><code>HR</code> (default),
</p>
</li>
<li> <p><code>logistic</code>,
</p>
</li>
<li> <p><code>dirichlet</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmpareto_tree_+3A_tree">tree</code></td>
<td>
<p>Graph object from <code>igraph</code> package.
This object must be a tree, i.e., an
undirected graph that is connected and has no cycles.</p>
</td></tr>
<tr><td><code id="rmpareto_tree_+3A_par">par</code></td>
<td>
<p>Respective parameter for the given <code>model</code>, that is,
</p>

<ul>
<li> <p><code class="reqn">\Gamma</code>, numeric <code class="reqn">d \times d</code> variogram matrix,
where only the entries corresponding to the edges of the <code>tree</code> are used,
if <code>model = HR</code>. Alternatively, can be a vector of
length <code>d-1</code> containing the entries of the variogram corresponding
to the edges of the given <code>tree</code>.
</p>
</li>
<li> <p><code class="reqn">\theta \in (0, 1)</code>, vector of length <code>d-1</code>
containing the logistic parameters corresponding
to the edges of the given <code>tree</code>, if <code>model = logistic</code>.
</p>
</li>
<li><p> a matrix of size <code class="reqn">(d - 1) \times 2</code>, where the rows
contain the parameters vectors <code class="reqn">\alpha</code> of size 2 with positive entries
for each of the edges in <code>tree</code>, if <code>model = dirichlet</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation follows the algorithm in Engelke and Hitz (2020).
For details on the parameters of the Huesler-Reiss, logistic
and negative logistic distributions see Dombry et al. (2016), and for the Dirichlet
distribution see Coles and Tawn (1991).
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix of simulations of the
multivariate Pareto distribution.
</p>


<h3>References</h3>

<p>Coles S, Tawn JA (1991).
&ldquo;Modelling extreme multivariate events.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>53</b>, 377&ndash;392.<br /><br /> Dombry C, Engelke S, Oesting M (2016).
&ldquo;Exact simulation of max-stable processes.&rdquo;
<em>Biometrika</em>, <b>103</b>, 303&ndash;317.<br /><br /> Engelke S, Hitz AS (2020).
&ldquo;Graphical models for extremes (with discussion).&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>82</b>, 871&ndash;932.
</p>


<h3>See Also</h3>

<p>Other sampling functions:
<code><a href="#topic+rmpareto">rmpareto</a>()</code>,
<code><a href="#topic+rmstable_tree">rmstable_tree</a>()</code>,
<code><a href="#topic+rmstable">rmstable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 4-dimensional HR tree model

my_tree &lt;- igraph::graph_from_adjacency_matrix(rbind(
  c(0, 1, 0, 0),
  c(1, 0, 1, 1),
  c(0, 1, 0, 0),
  c(0, 1, 0, 0)
),
mode = "undirected"
)
n &lt;- 10
Gamma_vec &lt;- c(.5, 1.4, .8)
set.seed(123)
rmpareto_tree(n, "HR", tree = my_tree, par = Gamma_vec)

## A 4-dimensional Dirichlet model with asymmetric edge distributions

alpha &lt;- cbind(c(.2, 1, .5), c(1.5, .6, .8))
rmpareto_tree(n, model = "dirichlet", tree = my_tree, par = alpha)
</code></pre>

<hr>
<h2 id='rmstable'>Sampling of a multivariate max-stable distribution</h2><span id='topic+rmstable'></span>

<h3>Description</h3>

<p>Simulates exact samples of a multivariate max-stable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmstable(n, model = c("HR", "logistic", "neglogistic", "dirichlet")[1], d, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmstable_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="rmstable_+3A_model">model</code></td>
<td>
<p>The parametric model type; one of:
</p>

<ul>
<li> <p><code>HR</code> (default),
</p>
</li>
<li> <p><code>logistic</code>,
</p>
</li>
<li> <p><code>neglogistic</code>,
</p>
</li>
<li> <p><code>dirichlet</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmstable_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto
distribution.</p>
</td></tr>
<tr><td><code id="rmstable_+3A_par">par</code></td>
<td>
<p>Respective parameter for the given <code>model</code>, that is,
</p>

<ul>
<li> <p><code class="reqn">\Gamma</code>, numeric <code class="reqn">d \times d</code> variogram matrix, if <code>model = HR</code>.
</p>
</li>
<li> <p><code class="reqn">\theta \in (0, 1)</code>, if <code>model = logistic</code>.
</p>
</li>
<li> <p><code class="reqn">\theta &gt; 0</code>, if <code>model = neglogistic</code>.
</p>
</li>
<li> <p><code class="reqn">\alpha</code>, numeric vector of size <code>d</code> with positive entries, if <code>model = dirichlet</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation follows the extremal function algorithm in Dombry et al. (2016).
For details on the parameters of the Huesler-Reiss, logistic
and negative logistic distributions see Dombry et al. (2016), and for the Dirichlet
distribution see Coles and Tawn (1991).
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix of simulations of the
multivariate max-stable distribution.
</p>


<h3>References</h3>

<p>Coles S, Tawn JA (1991).
&ldquo;Modelling extreme multivariate events.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>53</b>, 377&ndash;392.<br /><br /> Dombry C, Engelke S, Oesting M (2016).
&ldquo;Exact simulation of max-stable processes.&rdquo;
<em>Biometrika</em>, <b>103</b>, 303&ndash;317.
</p>


<h3>See Also</h3>

<p>Other sampling functions:
<code><a href="#topic+rmpareto_tree">rmpareto_tree</a>()</code>,
<code><a href="#topic+rmpareto">rmpareto</a>()</code>,
<code><a href="#topic+rmstable_tree">rmstable_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 4-dimensional HR distribution
n &lt;- 10
d &lt;- 4
G &lt;- cbind(
  c(0, 1.5, 1.5, 2),
  c(1.5, 0, 2, 1.5),
  c(1.5, 2, 0, 1.5),
  c(2, 1.5, 1.5, 0)
)

rmstable(n, "HR", d = d, par = G)

## A 3-dimensional logistic distribution
n &lt;- 10
d &lt;- 3
theta &lt;- .6
rmstable(n, "logistic", d, par = theta)

## A 5-dimensional negative logistic distribution
n &lt;- 10
d &lt;- 5
theta &lt;- 1.5
rmstable(n, "neglogistic", d, par = theta)

## A 4-dimensional Dirichlet distribution
n &lt;- 10
d &lt;- 4
alpha &lt;- c(.8, 1, .5, 2)
rmstable(n, "dirichlet", d, par = alpha)
</code></pre>

<hr>
<h2 id='rmstable_tree'>Sampling of a multivariate max-stable distribution on a tree</h2><span id='topic+rmstable_tree'></span>

<h3>Description</h3>

<p>Simulates exact samples of a multivariate max-stable distribution that
is an extremal graphical model on a tree as defined in Engelke and Hitz (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmstable_tree(n, model = c("HR", "logistic", "dirichlet")[1], tree, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmstable_tree_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="rmstable_tree_+3A_model">model</code></td>
<td>
<p>The parametric model type; one of:
</p>

<ul>
<li> <p><code>HR</code> (default),
</p>
</li>
<li> <p><code>logistic</code>,
</p>
</li>
<li> <p><code>dirichlet</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rmstable_tree_+3A_tree">tree</code></td>
<td>
<p>Graph object from <code>igraph</code> package.
This object must be a tree, i.e., an
undirected graph that is connected and has no cycles.</p>
</td></tr>
<tr><td><code id="rmstable_tree_+3A_par">par</code></td>
<td>
<p>Respective parameter for the given <code>model</code>, that is,
</p>

<ul>
<li> <p><code class="reqn">\Gamma</code>, numeric <code class="reqn">d \times d</code> variogram matrix,
where only the entries corresponding to the edges of the <code>tree</code> are used,
if <code>model = HR</code>. Alternatively, can be a vector of
length <code>d-1</code> containing the entries of the variogram corresponding
to the edges of the given <code>tree</code>.
</p>
</li>
<li> <p><code class="reqn">\theta \in (0, 1)</code>, vector of length <code>d-1</code>
containing the logistic parameters corresponding
to the edges of the given <code>tree</code>, if <code>model = logistic</code>.
</p>
</li>
<li><p> a matrix of size <code class="reqn">(d - 1) \times 2</code>, where the rows
contain the parameter vectors <code class="reqn">\alpha</code> of size 2 with positive entries
for each of the edges in <code>tree</code>, if <code>model = dirichlet</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation follows a combination of the extremal function algorithm in Dombry et al. (2016)
and the theory in Engelke and Hitz (2020) to sample from a single extremal function.
For details on the parameters of the Huesler-Reiss, logistic
and negative logistic distributions see Dombry et al. (2016), and for the Dirichlet
distribution see Coles and Tawn (1991).
</p>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix of simulations of the
multivariate max-stable distribution.
</p>


<h3>References</h3>

<p>Coles S, Tawn JA (1991).
&ldquo;Modelling extreme multivariate events.&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>53</b>, 377&ndash;392.<br /><br /> Dombry C, Engelke S, Oesting M (2016).
&ldquo;Exact simulation of max-stable processes.&rdquo;
<em>Biometrika</em>, <b>103</b>, 303&ndash;317.<br /><br /> Engelke S, Hitz AS (2020).
&ldquo;Graphical models for extremes (with discussion).&rdquo;
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>82</b>, 871&ndash;932.
</p>


<h3>See Also</h3>

<p>Other sampling functions:
<code><a href="#topic+rmpareto_tree">rmpareto_tree</a>()</code>,
<code><a href="#topic+rmpareto">rmpareto</a>()</code>,
<code><a href="#topic+rmstable">rmstable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 4-dimensional HR tree model

my_tree &lt;- igraph::graph_from_adjacency_matrix(rbind(
  c(0, 1, 0, 0),
  c(1, 0, 1, 1),
  c(0, 1, 0, 0),
  c(0, 1, 0, 0)
),
mode = "undirected"
)
n &lt;- 10
Gamma_vec &lt;- c(.5, 1.4, .8)
rmstable_tree(n, "HR", tree = my_tree, par = Gamma_vec)

## A 4-dimensional Dirichlet model with asymmetric edge distributions

alpha &lt;- cbind(c(.2, 1, .5), c(1.5, .6, .8))
rmstable_tree(n, model = "dirichlet", tree = my_tree, par = alpha)
</code></pre>

<hr>
<h2 id='simu_px_dirichlet'>Simulate Dirichlet extremal functions</h2><span id='topic+simu_px_dirichlet'></span>

<h3>Description</h3>

<p>Simulates Dirichlet extremal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_dirichlet(n, d, idx, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_dirichlet_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_dirichlet_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto distribution.
In some cases this can be <code>NULL</code> and will be inferred from <code>par</code>.</p>
</td></tr>
<tr><td><code id="simu_px_dirichlet_+3A_idx">idx</code></td>
<td>
<p>Integer or numeric vector with <code>n</code> elements. Index/indices from
1 to <code>d</code>, that determine which extremal function to simulate.</p>
</td></tr>
<tr><td><code id="simu_px_dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of size <code>d</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_HR'>Simulate HR extremal functions</h2><span id='topic+simu_px_HR'></span>

<h3>Description</h3>

<p>Simulates the Huesler-Reiss extremal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_HR(n, d, idx, trend, chol_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_HR_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_HR_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto distribution.
In some cases this can be <code>NULL</code> and will be inferred from <code>par</code>.</p>
</td></tr>
<tr><td><code id="simu_px_HR_+3A_idx">idx</code></td>
<td>
<p>Integer. Index corresponding to the variable over which
the extremal function is simulated.</p>
</td></tr>
<tr><td><code id="simu_px_HR_+3A_trend">trend</code></td>
<td>
<p>Numeric. Trend corresponding to the variable <code>idx</code>.</p>
</td></tr>
<tr><td><code id="simu_px_HR_+3A_chol_mat">chol_mat</code></td>
<td>
<p>Numeric matrix <code class="reqn">d \times d</code>.
Cholesky decomposition of the desired covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_logistic'>Simulate logistic extremal functions</h2><span id='topic+simu_px_logistic'></span>

<h3>Description</h3>

<p>Simulates logistic extremal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_logistic(n, d, idx, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_logistic_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_logistic_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto distribution.
In some cases this can be <code>NULL</code> and will be inferred from <code>par</code>.</p>
</td></tr>
<tr><td><code id="simu_px_logistic_+3A_idx">idx</code></td>
<td>
<p>Integer or numeric vector with <code>n</code> elements. Index/indices from
1 to <code>d</code>, that determine which extremal function to simulate.</p>
</td></tr>
<tr><td><code id="simu_px_logistic_+3A_theta">theta</code></td>
<td>
<p>Numeric &mdash; assume <code class="reqn">0 &lt; \theta &lt; 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_neglogistic'>Simulate negative logistic extremal functions</h2><span id='topic+simu_px_neglogistic'></span>

<h3>Description</h3>

<p>Simulates negative logistic extremal functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_neglogistic(n, d, idx, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_neglogistic_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_neglogistic_+3A_d">d</code></td>
<td>
<p>Dimension of the multivariate Pareto distribution.
In some cases this can be <code>NULL</code> and will be inferred from <code>par</code>.</p>
</td></tr>
<tr><td><code id="simu_px_neglogistic_+3A_idx">idx</code></td>
<td>
<p>Integer or numeric vector with <code>n</code> elements. Index/indices from
1 to <code>d</code>, that determine which extremal function to simulate.</p>
</td></tr>
<tr><td><code id="simu_px_neglogistic_+3A_theta">theta</code></td>
<td>
<p>Numeric &mdash; assume <code class="reqn">\theta &gt; 0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_tree_dirichlet'>Simulate Dirichlet extremal functions on a tree</h2><span id='topic+simu_px_tree_dirichlet'></span>

<h3>Description</h3>

<p>Simulates Dirichlet extremal functions on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_tree_dirichlet(n, alpha.start, alpha.end, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_tree_dirichlet_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_tree_dirichlet_+3A_alpha.start">alpha.start</code></td>
<td>
<p>Numeric vector with <code>d-1</code> elements, where <code>d</code> is
the number of nodes in the tree (and <code>d-1</code> is the number of edges).</p>
</td></tr>
<tr><td><code id="simu_px_tree_dirichlet_+3A_alpha.end">alpha.end</code></td>
<td>
<p>Numeric vector with <code>d-1</code> elements, where <code>d</code> is
the number of nodes in the tree (and <code>d-1</code> is the number of edges).</p>
</td></tr>
<tr><td><code id="simu_px_tree_dirichlet_+3A_a">A</code></td>
<td>
<p>Numeric <code class="reqn">d \times (d-1)</code> matrix; the rows represent the
nodes in the tree, the columns represent the edges. For a fixed node
<code class="reqn">k = 1, \dots, d</code>, each entry <code class="reqn">(i, j)</code> is
equal to 1 if the edge in position <code>j</code> is on the directed path from node
<code>k</code> to node <code>i</code> in the polytree rooted at node <code>k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_tree_HR'>Simulate HR extremal functions on a tree</h2><span id='topic+simu_px_tree_HR'></span>

<h3>Description</h3>

<p>Simulates the Huesler-Reiss extremal functions on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_tree_HR(n, Gamma_vec, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_tree_HR_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_tree_HR_+3A_gamma_vec">Gamma_vec</code></td>
<td>
<p>Numeric vector with <code>d-1</code> elements, where <code>d</code> is the
number of nodes in the tree (and <code>d-1</code> is the number of edges).</p>
</td></tr>
<tr><td><code id="simu_px_tree_HR_+3A_a">A</code></td>
<td>
<p>Numeric <code class="reqn">d \times (d-1)</code> matrix; the rows represent the nodes
in the tree, the columns represent the edges. For a fixed node
<code class="reqn">k = 1, \dots, d</code>, each entry <code class="reqn">(i, j)</code> is
equal to 1 if the edge in position <code>j</code> is on the directed path from node
<code>k</code> to node <code>i</code> in the polytree rooted at node <code>k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='simu_px_tree_logistic'>Simulate logistic extremal functions on a tree</h2><span id='topic+simu_px_tree_logistic'></span>

<h3>Description</h3>

<p>Simulates logistic extremal functions on a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_px_tree_logistic(n, theta, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_px_tree_logistic_+3A_n">n</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="simu_px_tree_logistic_+3A_theta">theta</code></td>
<td>
<p>Numeric vector with 1 or <code>d-1</code> elements.
Assume that the entry are such that <code class="reqn">0 &lt; \theta &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="simu_px_tree_logistic_+3A_a">A</code></td>
<td>
<p>Numeric <code class="reqn">d \times (d-1)</code> matrix; the rows represent the
nodes in the tree, the columns represent the edges. For a fixed node
<code class="reqn">k = 1, \dots, d</code>, each entry <code class="reqn">(i, j)</code> is
equal to 1 if the edge in position <code>j</code> is on the directed path from node
<code>k</code> to node <code>i</code> in the polytree rooted at node <code>k</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric <code class="reqn">n \times d</code> matrix. Simulated data.
</p>

<hr>
<h2 id='split_graph'>Split graph into invariant subgraphs</h2><span id='topic+split_graph'></span>

<h3>Description</h3>

<p>Split graph into invariant subgraphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_graph(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_graph_+3A_g">g</code></td>
<td>
<p><code><a href="igraph.html#topic+make_graph">igraph::graph</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of invariant subgraphs
</p>

<hr>
<h2 id='unif'>Uniform margin</h2><span id='topic+unif'></span>

<h3>Description</h3>

<p>Rescale the vector <code>x</code> empirically to uniform margin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unif(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unif_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="unif_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If TRUE, missing values are removed. If FALSE, missing values are kept as such.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with entries rescaled to uniform margins
</p>

<hr>
<h2 id='V_HR'>Compute exponent measure</h2><span id='topic+V_HR'></span>

<h3>Description</h3>

<p>Computes the exponent measure of HR distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>V_HR(x, Gamma = NULL, Theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="V_HR_+3A_x">x</code></td>
<td>
<p>Numeric vector with <code>d</code> positive elements
where the exponent measure is to be evaluated.</p>
</td></tr>
<tr><td><code id="V_HR_+3A_gamma">Gamma</code></td>
<td>
<p>d x d variogram matrix or numeric vector with d(d-1)/2 elements,
containing the upper triangular part of a variogram matrix.</p>
</td></tr>
<tr><td><code id="V_HR_+3A_theta">Theta</code></td>
<td>
<p>d x d precision matrix or numeric vector with d(d-1)/2 elements,
containing the upper triangular part of a precision matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only <code>Gamma</code> is needed for the computation. <code>Theta</code> is only used to
compute <code>Gamma</code> if necessary.
</p>


<h3>Value</h3>

<p>Numeric. The exponent measure of the HR distribution.
</p>

<hr>
<h2 id='Zmatrix'>Computes the Z-matrix</h2><span id='topic+Zmatrix'></span>

<h3>Description</h3>

<p>Copied from the R package &quot;golazo&quot; with kind permission by Piotr Zwiernik <a href="mailto:piotr.zwiernik@utoronto.ca">piotr.zwiernik@utoronto.ca</a>.
This function outputs the Z matrix, that is, the unique ultrametric matrix dominating S.
This matrix is used to construct a starting point in the GOLAZO algorithm when L=0 but U has strictly positive (off-diagonal entries).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zmatrix(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zmatrix_+3A_s">S</code></td>
<td>
<p>a covariance matrix</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
