<!DOCTYPE html><html><head><title>Help for package coder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coder-package'><p>coder: Deterministic Categorization of Items Based on External Code Data</p></a></li>
<li><a href='#ae'><p>Classcodes for adverse events after knee and hip arthroplasty</p></a></li>
<li><a href='#all_classcodes'><p>Summary data for all default classcodes object in the package</p></a></li>
<li><a href='#as.data.frame.classified'><p>Convert output from classify() to matrix/data.frame/data.table</p></a></li>
<li><a href='#as.keyvalue.classcodes'><p>Make keyvalue object from classcodes object</p></a></li>
<li><a href='#categorize'><p>Categorize cases based on external data and classification scheme</p></a></li>
<li><a href='#charlson'><p>Classcodes for Charlson comorbidity based on ICD-codes</p></a></li>
<li><a href='#classcodes'><p>Classcodes methods</p></a></li>
<li><a href='#classify'><p>Classify codified data</p></a></li>
<li><a href='#clean_text'><p>Make clean text with only lowercase alphanumeric characters and &quot;_&quot;</p></a></li>
<li><a href='#codebook'><p>codebook(s) for classcodes object</p></a></li>
<li><a href='#codify'><p>Codify case data with external code data (within specified time frames)</p></a></li>
<li><a href='#cols'><p>Return all columns from x with names matching &quot;find&quot;</p></a></li>
<li><a href='#copybig'><p>Decide if large objects should be copied</p></a></li>
<li><a href='#cps'><p>Classcodes for the comorbidity-polypharmacy score (CPS) based on ICD-10 codes</p></a></li>
<li><a href='#elixhauser'><p>Classcodes for Elixhauser based on ICD-codes</p></a></li>
<li><a href='#ex_atc'><p>Example data for random ATC codes</p></a></li>
<li><a href='#ex_icd10'><p>Example data for random codes assigned to random people</p></a></li>
<li><a href='#ex_people'><p>Example data for random people</p></a></li>
<li><a href='#hip_ae_hailer'><p>Classcodes for infection and dislocation after hip arthroplasty</p></a></li>
<li><a href='#index_fun'><p>Calculate index based on classification scheme</p></a></li>
<li><a href='#print.classcodes'><p>Print classcodes object</p></a></li>
<li><a href='#print.classified'><p>Printing classified data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rxriskv'><p>Classcodes for RxRisk V based on ATC codes</p></a></li>
<li><a href='#set_classcodes'><p>Set classcodes object</p></a></li>
<li><a href='#summary.classcodes'><p>Summarizing a classcodes object</p></a></li>
<li><a href='#visualize.classcodes'><p>Visualize classification scheme in web browser</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Deterministic Categorization of Items Based on External Code
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13.10</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Fast categorization of items based on external code data identified by 
  regular expressions. A typical use case considers patient with medically coded 
  data, such as codes from the International Classification of Diseases ('ICD') or 
  the Anatomic Therapeutic Chemical ('ATC') classification system. 
  Functions of the package relies on a triad of objects: (1) case data with unit 
  id:s and possible dates of interest; (2) external code data for corresponding 
  units in (1) and with optional dates of interest and; (3) a classification 
  scheme ('classcodes' object) with regular expressions to identify and 
  categorize relevant codes from (2). 
  It is easy to introduce new classification schemes ('classcodes' objects) or  
  to use default schemes included in the package. Use cases includes patient 
  categorization based on 'comorbidity indices' such as 'Charlson', 'Elixhauser', 
  'RxRisk V', or the 'comorbidity-polypharmacy' score (CPS), as well as adverse 
  events after hip and knee replacement surgery.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, knitr, rmarkdown, writexl</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, decoder, generics, methods, tibble</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/coder/">https://docs.ropensci.org/coder/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/coder/issues">https://github.com/ropensci/coder/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-14 16:29:21 UTC; eribu</td>
</tr>
<tr>
<td>Author:</td>
<td>Erik Bulow <a href="https://orcid.org/0000-0002-9973-456X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Emely C Zabore [rev] (Emily reviewed the package (v. 0.12.1) for
    rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/381&gt;),
  David Robinson [rev] (David reviewed the package (v. 0.12.1) for
    rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/381&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Erik Bulow &lt;eriklgb@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-14 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coder-package'>coder: Deterministic Categorization of Items Based on External Code Data</h2><span id='topic+coder'></span><span id='topic+coder-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Fast categorization of items based on external code data identified by regular expressions. A typical use case considers patient with medically coded data, such as codes from the International Classification of Diseases ('ICD') or the Anatomic Therapeutic Chemical ('ATC') classification system. Functions of the package relies on a triad of objects: (1) case data with unit id:s and possible dates of interest; (2) external code data for corresponding units in (1) and with optional dates of interest and; (3) a classification scheme ('classcodes' object) with regular expressions to identify and categorize relevant codes from (2). It is easy to introduce new classification schemes ('classcodes' objects) or to use default schemes included in the package. Use cases includes patient categorization based on 'comorbidity indices' such as 'Charlson', 'Elixhauser', 'RxRisk V', or the 'comorbidity-polypharmacy' score (CPS), as well as adverse events after hip and knee replacement surgery.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Erik Bulow <a href="mailto:eriklgb@gmail.com">eriklgb@gmail.com</a> (<a href="https://orcid.org/0000-0002-9973-456X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Emely C Zabore (Emily reviewed the package (v. 0.12.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/381&gt;) [reviewer]
</p>
</li>
<li><p> David Robinson (David reviewed the package (v. 0.12.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/381&gt;) [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/coder/">https://docs.ropensci.org/coder/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/coder/issues">https://github.com/ropensci/coder/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ae'>Classcodes for adverse events after knee and hip arthroplasty</h2><span id='topic+ae'></span><span id='topic+knee_ae'></span><span id='topic+hip_ae'></span>

<h3>Description</h3>

<p>ICD-10 group names are prefixed by two letters as given by the references.
Two groups (DB and DM) are split into two due to different conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knee_ae

hip_ae
</code></pre>


<h3>Format</h3>

<p>Data frame with 3 columns:
</p>

<dl>
<dt>group</dt><dd><p>Different types of adverse events (see reference section)</p>
</dd>
<dt>icd10</dt><dd><p>regular expressions identifying ICD-10 codes for each
group</p>
</dd>
<dt>icd10_fracture</dt><dd><p>regular expressions for fracture patients.
Essentially the same as <code>regex</code> but with some additional codes for
group &quot;DM1 other&quot;</p>
</dd>
<dt>kva</dt><dd><p>regular expressions identifying KVA codes</p>
</dd>
<dt>condition</dt><dd><p>special conditions are used, see below.</p>
</dd>
</dl>

<p>An object of class <code>classcodes</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 7 rows and 5 columns.
</p>


<h3>Hip fractures</h3>

<p>Adverse events (AE) codes for hip fractures are based on codes for elective
cases but with some additional codes for DM 1 (N300, N308, N309 and N390).
</p>


<h3>Conditions</h3>

<p>Special conditions apply to all categories.
Those require non-standard modifications
of the classcodes data prior to categorization.
</p>

<dl>
<dt>hbdia1_hdia</dt><dd><p><code>TRUE</code> if the code was
given as any type of diagnose during hospital visit for index operation,
or as main diagnose for later visits, otherwise <code>FALSE</code></p>
</dd>
<dt>late_hdia</dt><dd><p><code>TRUE</code> if the code was
given as main diagnose at a later visit after the index operation,
otherwise <code>FALSE</code></p>
</dd>
<dt>post_op</dt><dd><p><code>TRUE</code> if the code was
given at a later visit after the index operation, otherwise <code>FALSE</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Magneli M, Unbeck M, Rogmark C, Rolfson O, Hommel A, Samuelsson B, et al.
Validation of adverse events after hip arthroplasty:
a Swedish multi-centre cohort study.
BMJ Open. 2019 Mar 7;9(3):e023773.
</p>


<h3>See Also</h3>

<p>hip_ae_hailer
</p>
<p>Other default classcodes: 
<code><a href="#topic+charlson">charlson</a></code>,
<code><a href="#topic+cps">cps</a></code>,
<code><a href="#topic+elixhauser">elixhauser</a></code>,
<code><a href="#topic+hip_ae_hailer">hip_ae_hailer</a></code>,
<code><a href="#topic+rxriskv">rxriskv</a></code>
</p>

<hr>
<h2 id='all_classcodes'>Summary data for all default classcodes object in the package</h2><span id='topic+all_classcodes'></span>

<h3>Description</h3>

<p>Tabulate object names and list all related versions of implemented regular
expressions
and index weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_classcodes()
</code></pre>


<h3>Value</h3>

<p><a href="tibble.html#topic+tibble">tibble::tibble</a> with columns describing all default classcodes
objects from the package.
</p>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_classcodes()
</code></pre>

<hr>
<h2 id='as.data.frame.classified'>Convert output from classify() to matrix/data.frame/data.table</h2><span id='topic+as.data.frame.classified'></span><span id='topic+as.data.table.classified'></span><span id='topic+as.matrix.classified'></span>

<h3>Description</h3>

<p>Convert output from classify() to matrix/data.frame/data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classified'
as.data.frame(x, ...)

## S3 method for class 'classified'
as.data.table(x, ...)

## S3 method for class 'classified'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.classified_+3A_x">x</code></td>
<td>
<p>output from <code><a href="#topic+classify">classify()</a></code></p>
</td></tr>
<tr><td><code id="as.data.frame.classified_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame/data table with:
</p>

<ul>
<li><p> first column named as &quot;id&quot; column specified as input
to <code><a href="#topic+classify">classify()</a></code> and with data from <code>row.names(x)</code>
</p>
</li>
<li><p> all columns from <code>classified</code>
</p>
</li>
<li><p> no row names
</p>
</li></ul>

<p>or simply the input matrix without additional attributes
</p>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- classify(c("C80", "I20", "unvalid_code"), "elixhauser")

as.matrix(x)[, 1:3]
as.data.frame(x)[, 1:3]
data.table::as.data.table(x)[, 1:3]

# `as_tibble()` works automatically due to internal use of `as.data.frame()`.
tibble::as_tibble(x)
</code></pre>

<hr>
<h2 id='as.keyvalue.classcodes'>Make keyvalue object from classcodes object</h2><span id='topic+as.keyvalue.classcodes'></span>

<h3>Description</h3>

<p>S3-method for generic <code><a href="decoder.html#topic+keyvalue">decoder::as.keyvalue()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classcodes'
as.keyvalue(x, coding, cc_args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.keyvalue.classcodes_+3A_x">x</code></td>
<td>
<p>classcodes object</p>
</td></tr>
<tr><td><code id="as.keyvalue.classcodes_+3A_coding">coding</code></td>
<td>
<p>either a vector with codes from the original classification,
or a name (character vector of length one) of a keyvalue object
from package &quot;decoder&quot; (for example &quot;icd10cm&quot; or &quot;atc&quot;)</p>
</td></tr>
<tr><td><code id="as.keyvalue.classcodes_+3A_cc_args">cc_args</code></td>
<td>
<p>List of named arguments passed to <code><a href="#topic+set_classcodes">set_classcodes()</a></code></p>
</td></tr>
<tr><td><code id="as.keyvalue.classcodes_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="decoder.html#topic+keyvalue">decoder::as.keyvalue()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>keyvalue</code> where <code>key</code> is the subset of codes from
<code>object$key</code>identified by the regular expression from <code>x</code> and where
<code>value</code> is the corresponding <code>x$group</code>. Hence, note that the original
<code>object$value</code> is not used in the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all codes with corresponding classes as recognized by the Elixhauser
# comorbidity classification according to the Swedish version of the
# international classification of diseases version 10 (ICD-10-SE)
head(decoder::as.keyvalue(elixhauser, "icd10se"))

# Similar but with the American ICD-10-CM instead
# Note that the `value` column is similar as above
# (with names from `x$group`) and not
# from `object$value`
head(decoder::as.keyvalue(elixhauser, "icd10cm"))

# Codes identified by regular expressions based on ICD-9-CM and found in
# the Swedish version of ICD-9 used within the national cancer register
# (thus, a subset of the whole classification).
head(
  decoder::as.keyvalue(
    elixhauser, "icd9",
    cc_args = list(regex = "icd9cm")
  )
)
</code></pre>

<hr>
<h2 id='categorize'>Categorize cases based on external data and classification scheme</h2><span id='topic+categorize'></span><span id='topic+categorize.data.frame'></span><span id='topic+categorize.tbl_df'></span><span id='topic+categorize.data.table'></span><span id='topic+categorize.codified'></span>

<h3>Description</h3>

<p>This is the main function of the package, which relies of a triad of objects:
(1) <code>data</code> with unit id:s and possible dates of interest;
(2) <code>codedata</code> for corresponding
units and with optional dates of interest and;
(3) a classification scheme (<code><a href="#topic+classcodes">classcodes</a></code> object; <code>cc</code>) with regular
expressions to identify and categorize relevant codes.
The function combines the three underlying steps performed by
<code><a href="#topic+codify">codify()</a></code>, <code><a href="#topic+classify">classify()</a></code> and <code><a href="#topic+index">index()</a></code>.
Relevant arguments are passed to those functions by
<code>codify_args</code> and <code>cc_args</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize(x, ...)

## S3 method for class 'data.frame'
categorize(x, ...)

## S3 method for class 'tbl_df'
categorize(x, ...)

## S3 method for class 'data.table'
categorize(x, ..., codedata, id, code, codify_args = list())

## S3 method for class 'codified'
categorize(
  x,
  ...,
  cc,
  index = NULL,
  cc_args = list(),
  check.names = TRUE,
  .data_cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorize_+3A_x">x</code></td>
<td>
<p>data set with mandatory character id column
(identified by argument <code>id = "&lt;col_name&gt;"</code>),
and optional <code><a href="base.html#topic+Date">Date</a></code>  of interest
(identified by argument <code>date = "&lt;col_name&gt;"</code>).
Alternatively, the output from <code><a href="#topic+codify">codify()</a></code></p>
</td></tr>
<tr><td><code id="categorize_+3A_...">...</code></td>
<td>
<p>arguments passed between methods</p>
</td></tr>
<tr><td><code id="categorize_+3A_codedata">codedata</code></td>
<td>
<p>external code data with mandatory character id column
(identified by <code>id = "&lt;col_name&gt;"</code>),
code column (identified by argument <code>code = "&lt;col_name&gt;"</code>)
and optional <code><a href="base.html#topic+Date">Date</a></code> column
(identified by <code>codify_args = list(code_date = "&lt;col_name&gt;")</code>).</p>
</td></tr>
<tr><td><code id="categorize_+3A_id">id</code></td>
<td>
<p>name of unique character id column found in
both <code>x</code>and <code>codedata</code>.
(where it must not be unique).</p>
</td></tr>
<tr><td><code id="categorize_+3A_code">code</code></td>
<td>
<p>name of code column in <code>codedata</code>.</p>
</td></tr>
<tr><td><code id="categorize_+3A_codify_args">codify_args</code></td>
<td>
<p>Lists of named arguments passed to <code><a href="#topic+codify">codify()</a></code></p>
</td></tr>
<tr><td><code id="categorize_+3A_cc">cc</code></td>
<td>
<p><code><a href="#topic+classcodes">classcodes</a></code> object (or name of a default object from
<code><a href="#topic+all_classcodes">all_classcodes()</a></code>).</p>
</td></tr>
<tr><td><code id="categorize_+3A_index">index</code></td>
<td>
<p>Argument passed to <code><a href="#topic+index">index()</a></code>.
A character vector of names of columns with index weights from the
corresponding classcodes object (as supplied by the <code>cc</code>argument).
See <code>attr(cc, "indices")</code> for available options.
Set to <code>FALSE</code> if no index should be calculated.
If <code>NULL</code>, the default, all available indices (from <code>attr(cc, "indices")</code>)
are provided.</p>
</td></tr>
<tr><td><code id="categorize_+3A_cc_args">cc_args</code></td>
<td>
<p>List with named arguments passed to
<code><a href="#topic+set_classcodes">set_classcodes()</a></code></p>
</td></tr>
<tr><td><code id="categorize_+3A_check.names">check.names</code></td>
<td>
<p>Column names are based on <code>cc$group</code>, which might include
spaces. Those names are changed to syntactically correct names by
<code>check.names = TRUE</code>. Syntactically invalid, but grammatically correct
names might be preferred for presentation of the data as achieved by
<code>check.names = FALSE</code>. Alternatively, if <code>categorize</code> is called repeatedly,
longer informative names might be created by
<code>cc_args = list(tech_names = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="categorize_+3A_.data_cols">.data_cols</code></td>
<td>
<p>used internally</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the same class as <code>x</code> with additional logical columns
indicating membership of groups identified by the
<code>classcodes</code> object (the <code>cc</code> argument).
Numeric indices are also included if requested by the <code>index</code> argument.
</p>


<h3>See Also</h3>

<p>Other verbs: 
<code><a href="#topic+classify">classify</a>()</code>,
<code><a href="#topic+codify">codify</a>()</code>,
<code><a href="#topic+index_fun">index_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For this example, 1 core would suffice:
old_threads &lt;- data.table::getDTthreads()
data.table::setDTthreads(1)

# For some patient data (ex_people) and related hospital visit code data
# with ICD 10-codes (ex_icd10), add the Elixhauser comorbidity
# conditions based on all registered ICD10-codes
categorize(
   x            = ex_people,
   codedata     = ex_icd10,
   cc           = "elixhauser",
   id           = "name",
   code         = "icd10"
)


# Add Charlson categories and two versions of a calculated index
# ("quan_original" and "quan_updated").
categorize(
   x            = ex_people,
   codedata     = ex_icd10,
   cc           = "charlson",
   id           = "name",
   code         = "icd10",
   index        = c("quan_original", "quan_updated")
)


# Only include recent hospital visits within 30 days before surgery,
categorize(
   x            = ex_people,
   codedata     = ex_icd10,
   cc           = "charlson",
   id           = "name",
   code         = "icd10",
   index        = c("quan_original", "quan_updated"),
   codify_args  = list(
      date      = "surgery",
      days      = c(-30, -1),
      code_date = "admission"
   )
)



# Multiple versions -------------------------------------------------------

# We can compare categorization by according to Quan et al. (2005); "icd10",
# and Armitage et al. (2010); "icd10_rcs" (see `?charlson`)
# Note the use of `tech_names = TRUE` to distinguish the column names from the
# two versions.

# We first specify some common settings ...
ind &lt;- c("quan_original", "quan_updated")
cd  &lt;- list(date = "surgery", days = c(-30, -1), code_date = "admission")

# ... we then categorize once with "icd10" as the default regular expression ...
categorize(
   x            = ex_people,
   codedata     = ex_icd10,
   cc           = "charlson",
   id           = "name",
   code         = "icd10",
   index        = ind,
   codify_args  = cd,
   cc_args      = list(tech_names = TRUE)
) %&gt;%

# .. and once more with `regex = "icd10_rcs"`
categorize(
   codedata     = ex_icd10,
   cc           = "charlson",
   id           = "name",
   code         = "icd10",
   index        = ind,
   codify_args  = cd,
   cc_args      = list(regex = "icd10_rcs", tech_names = TRUE)
)



# column names ------------------------------------------------------------

# Default column names are based on row names from corresponding classcodes
# object but are modified to be syntactically correct.
default &lt;-
   categorize(ex_people, codedata = ex_icd10, cc = "elixhauser",
              id = "name", code = "icd10")

# Set `check.names = FALSE` to retain original names:
original &lt;-
  categorize(
    ex_people, codedata = ex_icd10, cc = "elixhauser",
    id = "name", code = "icd10",
    check.names = FALSE
   )

# Or use `tech_names = TRUE` for informative but long names (use case above)
tech &lt;-
  categorize(ex_people, codedata = ex_icd10, cc = "elixhauser",
    id = "name", code = "icd10",
    cc_args = list(tech_names = TRUE)
  )

# Compare
tibble::tibble(names(default), names(original), names(tech))

# Go back to original number of threads
data.table::setDTthreads(old_threads)
</code></pre>

<hr>
<h2 id='charlson'>Classcodes for Charlson comorbidity based on ICD-codes</h2><span id='topic+charlson'></span>

<h3>Description</h3>

<p>Classcodes for Charlson comorbidity based on ICD-codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charlson
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 8 variables:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;group:&#8288;</code> comorbidity groups
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;description:&#8288;</code> Verbal description of codes as described by
Deyo et al. (1992).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd10:&#8288;</code> regular expressions identifying ICD-10 codes of each
group as decoded from Quan et al. 2005. Note that this classification was
not originally used with all weights! To simply use this classification
table with weights other than <code>quan_original</code> and <code>quan_updated</code>
might therefore lead to different results than originally intended for each
index.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd9cm_deyo:&#8288;</code>Codes from table 1 column &quot;Deyo's ICD-9-CM&quot;
in Quan et al. (2005).
Procedure code 38.48 for peripheral vascular disease ignored.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd9cm_enhanced:&#8288;</code> Codes from table 1 column &quot;Enhanced ICD-9-CM&quot;
in Quan et al. (2005).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd10_rcs:&#8288;</code> Codification by Armitage (2010).
Note that Peptic ulcer disease is not included.
All liver diseases (including mild) are included in
&quot;moderate or severe liver disease&quot;.
All diabetes is included in &quot;diabetes complication&quot;
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd8_brusselaers:&#8288;</code> Back translated version from ICD-10 to
ICD-8 by Brusselaers et al. (2017).
&quot;Moderate and severe liver disease&quot; contains all liver disease and
&quot;diabetes complication&quot; contains all diabetes.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;icd9_brusselaers:&#8288;</code> Back translated version from ICD-10 to
ICD-9 by Brusselaers et al. (2017).
&quot;Moderate and severe liver disease&quot; contains all liver disease and
&quot;diabetes complication&quot; contains all diabetes.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;charlson:&#8288;</code> original weights as suggested by Charlson et al.
(1987)*
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;deyo_ramano:&#8288;</code> weights suggested by Deyo and Romano*
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;dhoore:&#8288;</code> weights suggested by D'Hoore*
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;ghali:&#8288;</code> weights suggested by Ghali*
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;quan_original:&#8288;</code> weights suggested by Quan (2005)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;quan_updated:&#8288;</code> weights suggested by Quan (2011)
</p>
</li></ul>


<ul>
<li><p> Weights decoded from Yurkovich et al. (2015).
</p>
</li></ul>



<h3>References</h3>

<p>Armitage, J. N., &amp; van der Meulen, J. H. (2010).
Identifying co-morbidity in surgical patients using administrative data
with the Royal College of Surgeons Charlson Score.
British Journal of Surgery, 97(5), 772–781.
</p>
<p>Brusselaers N, Lagergren J. (2017)
The Charlson Comorbidity Index in Registry-based Research.
Methods Inf Med 2017;56:401–6.
</p>
<p>Deyo, R. A., Cherkin, D. C., &amp; Ciol, M. A. (1992).
Adapting a clinical comorbidity index for use with ICD-9-CM
administrative databases.
Journal of Clinical Epidemiology, 45(6), 613–619.
</p>
<p>Quan Hude et al. (2005). Coding algorithms for defining
comorbidities in ICD-9-CM and ICD-10 administrative data.
Medical care, 1130-1139.
</p>
<p>Yurkovich, M., Avina-Zubieta, J. A., Thomas, J., Gorenchtein, M., &amp; Lacaille,
D. (2015). A systematic review identifies valid comorbidity indices derived
from administrative health data.
Journal of clinical epidemiology, 68(1), 3-14.
</p>


<h3>See Also</h3>

<p>Other default classcodes: 
<code><a href="#topic+ae">ae</a></code>,
<code><a href="#topic+cps">cps</a></code>,
<code><a href="#topic+elixhauser">elixhauser</a></code>,
<code><a href="#topic+hip_ae_hailer">hip_ae_hailer</a></code>,
<code><a href="#topic+rxriskv">rxriskv</a></code>
</p>

<hr>
<h2 id='classcodes'>Classcodes methods</h2><span id='topic+classcodes'></span><span id='topic+as.classcodes'></span><span id='topic+as.classcodes.classcodes'></span><span id='topic+as.classcodes.data.frame'></span><span id='topic+is.classcodes'></span>

<h3>Description</h3>

<p><code>classcodes</code> are classification schemes based on regular expression stored in
data frames. These are essential to the package and constitute the third
part of the triad of case data, code data and a classification scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.classcodes(x, ...)

## S3 method for class 'classcodes'
as.classcodes(
  x,
  ...,
  regex = attr(x, "regexpr"),
  indices = attr(x, "indices"),
  hierarchy = attr(x, "hierarchy")
)

## S3 method for class 'data.frame'
as.classcodes(
  x,
  ...,
  regex = NULL,
  indices = NULL,
  hierarchy = attr(x, "hierarchy"),
  .name = NULL
)

is.classcodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classcodes_+3A_x">x</code></td>
<td>
<p>data frame with columns described in the details section.
Alternatively a <code>classcodes</code> object to be modified.</p>
</td></tr>
<tr><td><code id="classcodes_+3A_...">...</code></td>
<td>
<p>arguments passed between methods#'</p>
</td></tr>
<tr><td><code id="classcodes_+3A_regex">regex</code>, <code id="classcodes_+3A_indices">indices</code></td>
<td>
<p>character vector with names of columns in <code>x</code> containing
regular expressions/indices.</p>
</td></tr>
<tr><td><code id="classcodes_+3A_hierarchy">hierarchy</code></td>
<td>
<p>named list of pairwise group names to appear as superior and
subordinate for indices.
To be used for indexing when the subordinate class is redundant
(see the details section of <code><a href="#topic+elixhauser">elixhauser</a></code> for an example).</p>
</td></tr>
<tr><td><code id="classcodes_+3A_.name">.name</code></td>
<td>
<p>used internally for name dispatch</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A classcodes object is a data frame with mandatory columns:
</p>

<ul>
<li> <p><code>group</code>: unique and non missing class names
</p>
</li>
<li><p> At least one column with regular expressions
(<a href="base.html#topic+regex">regex</a> without Perl-like versions) defining class
membership. Those columns can have arbitrary names
(as specified by the <code>regex</code> argument).
Occurrences of non unique regular expressions will lead to the same class
having multiple names. This is accepted but will raise a warning.
Classes do not have to be disjunct.
</p>
</li></ul>

<p>The object can have additional optional columns:
</p>

<ul>
<li> <p><code>description</code>: description of each category
</p>
</li>
<li> <p><code>condition</code>: a class might have conditions additional to what
is expressed by the regular expressions.
If so, these should be specified as quoted
expressions that can be evaluated within the data frame used by
<code><a href="#topic+classify">classify()</a></code>
</p>
</li>
<li><p> weights for each class used by
<code><a href="#topic+index">index()</a></code>. Could be more than one and could have arbitrary names
(as specified by the <code>indices</code>argument).
</p>
</li></ul>



<h3>Value</h3>

<p>Object of class <code>classcodes</code> (inheriting from data frame)
with additional attributes:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;code:&#8288;</code> the coding used (for example &quot;icd10&quot;, or &quot;ATC&quot;).
<code>NULL</code> for unknown/arbitrary coding.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;regexprs:&#8288;</code> name of columns with regular expressions
(as specified by the <code>regex</code>argument)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;indices:&#8288;</code> name of columns with (optional) index weights
(as specified by the <code>indices</code>argument)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;hierarchy:&#8288;</code> list as specified by the <code>hierarchy</code> argument.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;name:&#8288;</code> name as specified by the <code>.name</code> argument.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>vignette("classcodes")</code>
<code>vignette("Interpret_regular_expressions")</code>
The package have several default classcodes included, see <code><a href="#topic+all_classcodes">all_classcodes()</a></code>.
</p>
<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>
<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Elixhauser comorbidity classification is already a classcodes object
is.classcodes(coder::elixhauser)

# Strip its class attributes to use in examples
df &lt;- as.data.frame(coder::elixhauser)

# Specify which columns store regular expressions and indices
# (assume no hierarchy)
elix &lt;-
  as.classcodes(
    df,
    regex     = c("icd10", "icd10_short", "icd9cm", "icd9cm_ahrqweb", "icd9cm_enhanced"),
    indices   = c("sum_all", "sum_all_ahrq", "walraven",
                "sid29", "sid30", "ahrq_mort", "ahrq_readm"),
    hierarchy = NULL
  )
elix

# Specify hierarchy for patients with different types of cancer and diabetes
# See `?elixhauser` for details
as.classcodes(
  elix,
  hierarchy = list(
    cancer   = c("metastatic cancer", "solid tumor"),
    diabetes = c("diabetes complicated", "diabetes uncomplicated")
  )
)

# Several checks are performed to not allow any erroneous classcodes object
## Not run: 
  as.classcodes(iris)
  as.classcodes(iris, regex = "Species")

## End(Not run)
</code></pre>

<hr>
<h2 id='classify'>Classify codified data</h2><span id='topic+classify'></span><span id='topic+classify.default'></span><span id='topic+classify.codified'></span><span id='topic+classify.data.frame'></span><span id='topic+classify.data.table'></span>

<h3>Description</h3>

<p>This is the second step of <code>codify() %&gt;% classify() %&gt;% index()</code>.
Hence, the function takes a codified data set and classify each case based on
relevant codes as identified by the classification scheme provided by a
<code>classcodes</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify(codified, cc, ..., cc_args = list())

## Default S3 method:
classify(codified, cc, ..., cc_args = list())

## S3 method for class 'codified'
classify(codified, ...)

## S3 method for class 'data.frame'
classify(codified, ...)

## S3 method for class 'data.table'
classify(codified, cc, ..., id, code, cc_args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_codified">codified</code></td>
<td>
<p>output from <code><a href="#topic+codify">codify()</a></code></p>
</td></tr>
<tr><td><code id="classify_+3A_cc">cc</code></td>
<td>
<p><code><a href="#topic+classcodes">classcodes</a></code> object (or name of a default object from
<code><a href="#topic+all_classcodes">all_classcodes()</a></code>).</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>arguments passed between methods</p>
</td></tr>
<tr><td><code id="classify_+3A_cc_args">cc_args</code></td>
<td>
<p>List with named arguments passed to
<code><a href="#topic+set_classcodes">set_classcodes()</a></code></p>
</td></tr>
<tr><td><code id="classify_+3A_code">code</code>, <code id="classify_+3A_id">id</code></td>
<td>
<p>name of code/id columns (in <code>codified</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;classified&quot;. Inheriting from a Boolean matrix with
one row for each element/row of <code>codified</code>
and columns for each class with corresponding class names (according to the
<code><a href="#topic+classcodes">classcodes</a></code> object). Note, however, that <code><a href="#topic+print.classified">print.classified()</a></code> preview
this output as a tibble.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame.classified">as.data.frame.classified()</a></code>, <code><a href="#topic+as.data.table.classified">as.data.table.classified()</a></code> and
<code><a href="#topic+as.matrix.classified">as.matrix.classified()</a></code>, <code><a href="#topic+print.classified">print.classified()</a></code>
</p>
<p>Other verbs: 
<code><a href="#topic+categorize">categorize</a>()</code>,
<code><a href="#topic+codify">codify</a>()</code>,
<code><a href="#topic+index_fun">index_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# classify.default() ------------------------------------------------------

# Classify individual ICD10-codes by Elixhauser
classify(c("C80", "I20", "unvalid_code"), "elixhauser")



# classify.codified() -----------------------------------------------------

# Prepare some codified data with ICD-10 codes during 1 year (365 days)
# before surgery
x &lt;-
  codify(
    ex_people,
    ex_icd10,
    id        = "name",
    code      = "icd10",
    date      = "surgery",
    days      = c(-365, 0),
    code_date = "admission"
  )

# Classify those patients by the Charlson and Elixhasuer comorbidity indices
classify(x, "charlson")        # classcodes object by name ...
classify(x, coder::elixhauser) # ... or by the object itself


# -- start/stop --
# Assume that a prefix "ICD-10 = " is used for all codes and that some
# additional numbers are added to the end
x$icd10 &lt;- paste0("ICD-10 = ", x$icd10)

# Set start = FALSE to identify codes which are not necessarily found in the
# beginning of the string
classify(x, "charlson", cc_args = list(start = FALSE))


# -- regex --
# Use a different version of Charlson (as formulated by regular expressions
# according to the Royal College of Surgeons (RCS) by passing arguments to
# `set_classcodes()` using the `cc_args` argument
y &lt;-
  classify(
    x,
    "charlson",
    cc_args = list(regex = "icd10_rcs")
  )


# -- tech_names --
# Assume that we want to compare the results using the default ICD-10
# formulations (from Quan et al. 2005) and the RCS version and that the result
# should be put into the same data frame. We can use `tech_names = TRUE`
# to distinguish variables with otherwise similar names
cc &lt;- list(tech_names = TRUE) # Prepare sommon settings
compare &lt;-
  merge(
  classify(x, "charlson", cc_args = cc),
  classify(x, "charlson", cc_args = c(cc, regex = "icd10_rcs"))
)
names(compare) # long but informative and distinguishable column names



# classify.data.frame() / classify.data.table() ------------------------

# Assume that `x` is a data.frame/data.table without additional attributes
# from `codify()` ...
xdf &lt;- as.data.frame(x)
xdt &lt;- data.table::as.data.table(x)

# ... then the `id` and `code` columns must be specified explicitly
classify(xdf, "charlson", id = "name", code = "icd10")
classify(xdt, "charlson", id = "name", code = "icd10")
</code></pre>

<hr>
<h2 id='clean_text'>Make clean text with only lowercase alphanumeric characters and &quot;_&quot;</h2><span id='topic+clean_text'></span>

<h3>Description</h3>

<p>Make clean text with only lowercase alphanumeric characters and &quot;_&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_text(x_name, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_text_+3A_x_name">x_name</code></td>
<td>
<p>Name of object to use as prefix</p>
</td></tr>
<tr><td><code id="clean_text_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of the same length as <code>x</code>
</p>

<hr>
<h2 id='codebook'>codebook(s) for classcodes object</h2><span id='topic+codebook'></span><span id='topic+print.codebook'></span><span id='topic+codebooks'></span>

<h3>Description</h3>

<p><code><a href="#topic+summary.classcodes">summary.classcodes()</a></code> and <code><a href="#topic+visualize.classcodes">visualize.classcodes()</a></code> are used to
summarize/visualize classcodes in R. A codebook, on the other hand,
is an exported summary
saved in an Excel spreadsheet to use in collaboration with non R-users.
Several codebooks might be combined into a single Excel document with
several sheets (one for each codebook).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codebook(object, coding, ..., file = NULL)

## S3 method for class 'codebook'
print(x, ...)

codebooks(..., file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codebook_+3A_object">object</code></td>
<td>
<p>classcodes object</p>
</td></tr>
<tr><td><code id="codebook_+3A_coding">coding</code></td>
<td>
<p>either a vector with codes from the original classification,
or a name (character vector of length one) of a keyvalue object
from package &quot;decoder&quot; (for example &quot;icd10cm&quot; or &quot;atc&quot;)</p>
</td></tr>
<tr><td><code id="codebook_+3A_...">...</code></td>
<td>
<p>Additional arguments for each function:
</p>

<ul>
<li> <p><code>codebook()</code>: arguments passed to <code><a href="#topic+summary.classcodes">summary.classcodes()</a></code>
</p>
</li>
<li> <p><code>codebooks()</code>: multiple named outputs from <code><a href="#topic+codebook">codebook()</a></code>
</p>
</li>
<li> <p><code>print.codebook()</code>: arguments passed to <code>tibble:::print.tbl()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="codebook_+3A_file">file</code></td>
<td>
<p>name/path to Excel file for data export</p>
</td></tr>
<tr><td><code id="codebook_+3A_x">x</code></td>
<td>
<p>output from <code>codebook()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions are primarily called for their side effects (exporting data to
Excel or printing to screen). In addition:
</p>

<ul>
<li> <p><code>codebook()</code>returns list of data frames describing relationship
between groups and individual codes
</p>
</li>
<li> <p><code>codebooks()</code> returns a concatenated list with output from <code>codebook()</code>.
Only one 'README' object is kept however and renamed as such.
</p>
</li>
<li> <p><code>print.codebook()</code>returns <code>x</code> (invisible)
</p>
</li></ul>



<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># codebook() --------------------------------------------------------------
## Not run: 
# Export codebook (to temporary file) with all codes identified by the
# Elixhauser comorbidity classification based on ICD-10-CM
codebook(elixhauser, "icd10cm", file = tempfile("codebook", fileext = ".xlsx"))

# All codes from ICD-9-CM Disease part used by Elixhauser enhanced version
codebook(elixhauser, "icd9cmd",
  cc_args = list(regex = "icd9cm_enhanced",
  file = tempfile("codebook", fileext = ".xlsx"))
)

# The codebook returns a list with three objects.
# Access a dictionary table with translates of each code to text:
codebook(charlson, "icd10cm")$all_codes


# print.codebook() --------------------------------------------------------

# If argument `file` is unspecified, a preview of each sheet of the codebook is
# printed to the screen
(cb &lt;- codebook(charlson, "icd10cm"))

# The preview can be modified by arguments to the print-method
print(cb, n = 20)


# codebooks() -------------------------------------------------------------

# Combine codebooks based on different versions of the regular expressions
# and export to a single (temporary) Excel file
c1 &lt;- codebook(elixhauser, "icd10cm")
c2 &lt;- codebook(elixhauser, "icd9cmd",
  cc_args = list(regex = "icd9cm_enhanced")
  )

codebooks(
  elix_icd10 = c1, elix_icd9cm = c2,
  file = tempfile("codebooks", fileext = ".xlsx")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='codify'>Codify case data with external code data (within specified time frames)</h2><span id='topic+codify'></span><span id='topic+codify.data.frame'></span><span id='topic+codify.data.table'></span><span id='topic+print.codified'></span>

<h3>Description</h3>

<p>This is the first step of <code>codify() %&gt;% classify() %&gt;% index()</code>.
The function combines case data from one data set with related code data from
a second source, possibly limited to codes valid at certain time points
relative to case dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codify(x, codedata, ..., id, code, date = NULL, code_date = NULL, days = NULL)

## S3 method for class 'data.frame'
codify(x, ..., id, date = NULL, days = NULL)

## S3 method for class 'data.table'
codify(
  x,
  codedata,
  ...,
  id,
  code,
  date = NULL,
  code_date = NULL,
  days = NULL,
  alnum = FALSE,
  .copy = NA
)

## S3 method for class 'codified'
print(x, ..., n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="codify_+3A_x">x</code></td>
<td>
<p>data set with mandatory character id column
(identified by argument <code>id = "&lt;col_name&gt;"</code>),
and optional <code><a href="base.html#topic+Date">Date</a></code>  of interest
(identified by argument <code>date = "&lt;col_name&gt;"</code>).
Alternatively, the output from <code><a href="#topic+codify">codify()</a></code></p>
</td></tr>
<tr><td><code id="codify_+3A_codedata">codedata</code></td>
<td>
<p>additional data with columns
including case id (<code>character</code>), code and an optional date (<a href="base.html#topic+Date">Date</a>) for
each code. An optional column <code>condition</code> might distinguish codes/dates
with certain characteristics (see example).</p>
</td></tr>
<tr><td><code id="codify_+3A_...">...</code></td>
<td>
<p>arguments passed between methods</p>
</td></tr>
<tr><td><code id="codify_+3A_id">id</code>, <code id="codify_+3A_code">code</code>, <code id="codify_+3A_date">date</code>, <code id="codify_+3A_code_date">code_date</code></td>
<td>
<p>column names with case id
(<code>character</code> from <code>x</code> and <code>codedata</code>), <code>code</code> (from <code>x</code>) and
optional date (<a href="base.html#topic+Date">Date</a> from <code>x</code>) and
<code>code_date</code> (<a href="base.html#topic+Date">Date</a> from <code>codedata</code>).</p>
</td></tr>
<tr><td><code id="codify_+3A_days">days</code></td>
<td>
<p>numeric vector of length two with lower and upper bound for range
of relevant days relative to <code>date</code>. See &quot;Relevant period&quot;.</p>
</td></tr>
<tr><td><code id="codify_+3A_alnum">alnum</code></td>
<td>
<p>Should codes be cleaned from all non alphanumeric characters?</p>
</td></tr>
<tr><td><code id="codify_+3A_.copy">.copy</code></td>
<td>
<p>Should the object be copied internally by <code><a href="data.table.html#topic+copy">data.table::copy()</a></code>?
<code>NA</code> (by default) means that objects smaller than 1 GB are copied.
If the size is larger, the argument must be set explicitly. Set <code>TRUE</code>
to make copies regardless of object size. This is recommended if enough RAM
is available. If set to <code>FALSE</code>, calculations might be carried out
but the object will be changed by reference.
IMPORTANT! This might lead to undesired consequences and should only be used
if absolutely necessary!</p>
</td></tr>
<tr><td><code id="codify_+3A_n">n</code></td>
<td>
<p>number of rows to preview as tibble.
The output is technically a <a href="data.table.html#topic+data.table">data.table::data.table</a>, which might be an
unusual format to look at. Use <code>n = NULL</code> to print the object as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>codified</code> (inheriting from <a href="data.table.html#topic+data.table">data.table::data.table</a>).
Essentially <code>x</code> with additional columns:
<code style="white-space: pre;">&#8288;code, code_date&#8288;</code>: left joined from <code>codedata</code> or <code>NA</code>
if no match within period. <code>in_period</code>: Boolean indicator if the case
had at least one code within the specified period.
</p>
<p>The output has one row for each combination of &quot;id&quot; from <code>x</code> and
&quot;code&quot; from <code>codedata</code>. Rows from <code>x</code> might be repeated
accordingly.
</p>


<h3>Relevant period</h3>

<p>Some examples for argument <code>days</code>:
</p>

<ul>
<li> <p><code>c(-365, -1)</code>: window of one year prior to the <code>date</code>
column of <code>x</code>. Useful for patient comorbidity.
</p>
</li>
<li> <p><code>c(1, 30)</code>: window of 30 days after <code>date</code>.
Useful for adverse events after a surgical procedure.
</p>
</li>
<li> <p><code>c(-Inf, Inf)</code>: no limitation on non-missing dates.
</p>
</li>
<li> <p><code>NULL</code>: no time limitation at all.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other verbs: 
<code><a href="#topic+categorize">categorize</a>()</code>,
<code><a href="#topic+classify">classify</a>()</code>,
<code><a href="#topic+index_fun">index_fun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Codify all patients from `ex_people` with their ICD-10 codes from `ex_icd10`
x &lt;- codify(ex_people, ex_icd10, id = "name", code = "icd10")
x

# Only consider codes if recorded at hospital admissions within one year prior
# to surgery
codify(
  ex_people,
  ex_icd10,
  id        = "name",
  code      = "icd10",
  date      = "surgery",
  code_date = "admission",
  days      = c(-365, 0)   # admission during one year before surgery
)

# Only consider codes if recorded after surgery
codify(
  ex_people,
  ex_icd10,
  id        = "name",
  code      = "icd10",
  date      = "surgery",
  code_date = "admission",
  days      = c(1, Inf)     # admission any time after surgery
)


# Dirty code data ---------------------------------------------------------

# Assume that codes contain unwanted "dirty" characters
# Those could for example be a dot used by ICD-10 (i.e. X12.3 instead of X123)
dirt &lt;- c(strsplit(c("!#%&amp;/()=?`,.-_"), split = ""), recursive = TRUE)
rdirt &lt;- function(x) sample(x, nrow(ex_icd10), replace = TRUE)
sub &lt;- function(i) substr(ex_icd10$icd10, i, i)
ex_icd10$icd10 &lt;-
  paste0(
    rdirt(dirt), sub(1),
    rdirt(dirt), sub(2),
    rdirt(dirt), sub(3),
    rdirt(dirt), sub(4),
    rdirt(dirt), sub(5)
  )
head(ex_icd10)

# Use `alnum = TRUE` to ignore non alphanumeric characters
codify(ex_people, ex_icd10, id = "name", code = "icd10", alnum = TRUE)



# Big data ----------------------------------------------------------------

# If `data` or `codedata` are large compared to available
# Random Access Memory (RAM) it might not be possible to make internal copies
# of those objects. Setting `.copy = FALSE` might help to overcome such problems

# If no copies are made internally, however, the input objects (if data tables)
# would change in the global environment
x2 &lt;- data.table::as.data.table(ex_icd10)
head(x2) # Look at the "icd10" column (with dirty data)

# Use `alnum = TRUE` combined with `.copy = FALSE`
codify(ex_people, x2, id = "name", code = "icd10", alnum = TRUE, .copy = FALSE)

# Even though no explicit assignment was specified
# (neither for the output of codify(), nor to explicitly alter `x2`,
# the `x2` object has changed (look at the "icd10" column!):
head(x2)

# Hence, the `.copy` argument should only be used if necessary
# and if so, with caution!


# print.codify() ----------------------------------------------------------

x # Preview first 10 rows as a tibble
print(x, n = 20) # Preview first 20 rows as a tibble
print(x, n = NULL) # Print as data.table (ignoring the 'classified' class)
</code></pre>

<hr>
<h2 id='cols'>Return all columns from x with names matching &quot;find&quot;</h2><span id='topic+cols'></span>

<h3>Description</h3>

<p>Return all columns from x with names matching &quot;find&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cols(find, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cols_+3A_find">find</code></td>
<td>
<p>character vector with names to match</p>
</td></tr>
<tr><td><code id="cols_+3A_x">x</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='copybig'>Decide if large objects should be copied</h2><span id='topic+copybig'></span>

<h3>Description</h3>

<p>Decide if large objects should be copied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copybig(x, .copy = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copybig_+3A_x">x</code></td>
<td>
<p>object (potentially of large size)</p>
</td></tr>
<tr><td><code id="copybig_+3A_.copy">.copy</code></td>
<td>
<p>Should the object be copied internally by <code><a href="data.table.html#topic+copy">data.table::copy()</a></code>?
<code>NA</code> (by default) means that objects smaller than 1 GB are copied.
If the size is larger, the argument must be set explicitly. Set <code>TRUE</code>
to make copies regardless of object size. This is recommended if enough RAM
is available. If set to <code>FALSE</code>, calculations might be carried out
but the object will be changed by reference.
IMPORTANT! This might lead to undesired consequences and should only be used
if absolutely necessary!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>x</code> unchanged, or a fresh copy of <code>x</code>.
</p>

<hr>
<h2 id='cps'>Classcodes for the comorbidity-polypharmacy score (CPS) based on ICD-10 codes</h2><span id='topic+cps'></span>

<h3>Description</h3>

<p>Classcodes for the comorbidity-polypharmacy score (CPS) based on ICD-10 codes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cps
</code></pre>


<h3>Format</h3>

<p>A data frame with 2 rows and 2 variables:
</p>

<dl>
<dt>group</dt><dd><p>comorbidity groups, either &quot;ordinary&quot; for most ICD-10-codes or
&quot;special&quot; for codes beginning with &quot;UA&quot;, &quot;UB&quot; and &quot;UP&quot;</p>
</dd>
<dt>icd10</dt><dd><p>regular expressions identifying ICD-10 codes of each
group</p>
</dd>
<dt>only_ordinary</dt><dd><p>index weights, 1 for ordinary and 0 for special</p>
</dd>
</dl>



<h3>References</h3>

<p>Stawicki, Stanislaw P., et al.
&quot;Comorbidity polypharmacy score and its clinical utility: A pragmatic
practitioner's perspective.&quot; Journal of emergencies, trauma, and shock 8.4
(2015): 224.
</p>


<h3>See Also</h3>

<p>Other default classcodes: 
<code><a href="#topic+ae">ae</a></code>,
<code><a href="#topic+charlson">charlson</a></code>,
<code><a href="#topic+elixhauser">elixhauser</a></code>,
<code><a href="#topic+hip_ae_hailer">hip_ae_hailer</a></code>,
<code><a href="#topic+rxriskv">rxriskv</a></code>
</p>

<hr>
<h2 id='elixhauser'>Classcodes for Elixhauser based on ICD-codes</h2><span id='topic+elixhauser'></span>

<h3>Description</h3>

<p>Solid tumors are subordinate to metastatic cancer. A patient with both
conditions will still be classified as such but a possible (weighted)
index value will only account for metastatic cancer. The same is true for
&quot;diabetes uncomplicated&quot;, which is subordinate of &quot;diabetes complicated&quot;.
See Elixhauser et al. (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elixhauser
</code></pre>


<h3>Format</h3>

<p>A data frame with 31 rows and 8 variables:
</p>

<dl>
<dt>group</dt><dd><p>comorbidity groups</p>
</dd>
<dt>icd10</dt><dd><p>regular expressions identifying ICD-10 codes of
each group. Corresponds to column 'ICD-10' in table 2
of Quan et al. (2005).</p>
</dd>
<dt>icd10_short</dt><dd><p>regular expressions identifying only the first
three characters of ICD-10 codes of each group. This alternative version
was added only to use in emergency when only the first three digits are
available. It is not an official version and we do not recommend to
use it!</p>
</dd>
<dt>icd9cm</dt><dd><p>Corresponds to column 'Elixhauser's Original ICD-9-CM'
in table 2 of Quan et al. (2005).</p>
</dd>
<dt>icd9cm_ahrqweb</dt><dd><p>Corresponds to column
'Elixhauser AHRQ-Web ICD-9-CM' in table 2 of Quan et al. (2005).</p>
</dd>
<dt>icd9cm_enhanced</dt><dd><p>Corresponds to column 'Enhanced ICD-9-CM'
in table 2 of Quan et al. (2005).</p>
</dd>
<dt>sum_all</dt><dd><p>all weights = 1 (thus no weights)</p>
</dd>
<dt>sum_all_ahrq</dt><dd><p>as <code>sum_all</code> excluding &quot;cardiac arrhythmia.
Compare to <code>icd9cm_ahrqweb</code> which does not
consider this condition.</p>
</dd>
<dt>walraven</dt><dd><p>weights suggested by Walraven et al. (2009)</p>
</dd>
<dt>sid29</dt><dd><p>weights suggested by Thompson et al. (2015)
based on all conditions except cardiac arrhythmia</p>
</dd>
<dt>sid30</dt><dd><p>weights suggested by Thompson et al. (2015)
based on all conditions</p>
</dd>
<dt>ahrq_mort</dt><dd><p>weights for in-hospital mortality suggested by
Moore et al. (2017)</p>
</dd>
<dt>ahrq_readm</dt><dd><p>weights for readmissions suggested by
Moore et al. (2017)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Note that &quot;DRG screen&quot; as proposed in table 1 of Elixhauser et al. (1998)
is not handled by the coder package. This should instead be considered as
an additional pre- or post-processing step!
</p>


<h3>References</h3>

<p>Elixhauser A, Steiner C, Harris DR, Coffey RM (1998).
Comorbidity Measures for Use with Administrative Data.
Med Care. 1998;36(1):8–27.
</p>
<p>Moore, B. J., White, S., Washington, R., Coenen, N., &amp; Elixhauser, A. (2017).
Identifying Increased Risk of Readmission and In-hospital Mortality Using
Hospital Administrative Data.
Medical Care, 55(7), 698–705.
</p>
<p>Quan Hude et al. (2005). Coding algorithms for defining
comorbidities in ICD-9-CM and ICD-10 administrative data.
Medical care, 1130-1139.
</p>
<p>Thompson, N. R., Fan, Y., Dalton, J. E., Jehi, L., Rosenbaum, B. P.,
Vadera, S., &amp; Griffith, S. D. (2015).
A new Elixhauser-based comorbidity summary measure to predict in-hospital
mortality. Med Care, 53(4), 374–379.
</p>
<p>Walraven, C. Van, Austin, P. C., Jennings, A., Quan, H., Alan, J., Walraven,
C. Van, … Jennings, A. (2009).
A Modification of the Elixhauser Comorbidity Measures Into a Point System
for Hospital Death Using Administrative Data.
Medical Care, 47(6), 626–633.
</p>


<h3>See Also</h3>

<p>Other default classcodes: 
<code><a href="#topic+ae">ae</a></code>,
<code><a href="#topic+charlson">charlson</a></code>,
<code><a href="#topic+cps">cps</a></code>,
<code><a href="#topic+hip_ae_hailer">hip_ae_hailer</a></code>,
<code><a href="#topic+rxriskv">rxriskv</a></code>
</p>

<hr>
<h2 id='ex_atc'>Example data for random ATC codes</h2><span id='topic+ex_atc'></span>

<h3>Description</h3>

<p>Example data for fictive people to use for testing and in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_atc
</code></pre>


<h3>Format</h3>

<p>Data frames with 100 rows and 2 variables:
</p>

<dl>
<dt>name</dt><dd><p>random person names</p>
</dd>
<dt>atc</dt><dd><p>Random codes from the Anatomic Therapeutic Chemical
classification (ATC) system.</p>
</dd>
<dt>prescription</dt><dd><p>random dates of prescription of medications with
corresponding ATC codes</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other example data: 
<code><a href="#topic+ex_icd10">ex_icd10</a></code>,
<code><a href="#topic+ex_people">ex_people</a></code>
</p>

<hr>
<h2 id='ex_icd10'>Example data for random codes assigned to random people</h2><span id='topic+ex_icd10'></span>

<h3>Description</h3>

<p>Example data for fictive ICD-10-diagnoses to use for testing and
in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_icd10
</code></pre>


<h3>Format</h3>

<p>Data frames with 1,000 rows and 4 variables:
</p>

<dl>
<dt>id</dt><dd><p>Random names corresponding to column <code>name</code> in dataset
<code>ex_people</code></p>
</dd>
<dt>date</dt><dd><p>random dates corresponding to registered (comorbidity) codes</p>
</dd>
<dt>code</dt><dd><p>ICD-10 codes from the <code>uranium_pathology</code>
dataset in the <code>icd.data</code> package by Jack Wasey originating from the
United States Transuranium and Uranium Registries,
published in the public domain.</p>
</dd>
<dt>hdia</dt><dd><p>boolean marker if corresponding code is the main diagnose of
the hospital visit (randomly assigned to 10 percent of the codes)</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://github.com/jackwasey/icd.data
https://ustur.wsu.edu/about-us/
</p>


<h3>See Also</h3>

<p>Other example data: 
<code><a href="#topic+ex_atc">ex_atc</a></code>,
<code><a href="#topic+ex_people">ex_people</a></code>
</p>

<hr>
<h2 id='ex_people'>Example data for random people</h2><span id='topic+ex_people'></span>

<h3>Description</h3>

<p>Example data for fictive people to use for testing and in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_people
</code></pre>


<h3>Format</h3>

<p>Data frames with 100 rows and 2 variables:
</p>

<dl>
<dt>name</dt><dd><p>random person names</p>
</dd>
<dt>surgery</dt><dd><p>random dates for a relevant event</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other example data: 
<code><a href="#topic+ex_atc">ex_atc</a></code>,
<code><a href="#topic+ex_icd10">ex_icd10</a></code>
</p>

<hr>
<h2 id='hip_ae_hailer'>Classcodes for infection and dislocation after hip arthroplasty</h2><span id='topic+hip_ae_hailer'></span>

<h3>Description</h3>

<p>Classcodes for infection and dislocation after hip arthroplasty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hip_ae_hailer
</code></pre>


<h3>Format</h3>

<p>Data frame with 3 columns:
</p>

<dl>
<dt>group</dt><dd><p>Infection or dislocation</p>
</dd>
<dt>icd10</dt><dd><p>regular expressions based on ICD-10</p>
</dd>
<dt>kva</dt><dd><p>regular expressions based on NOMESCO/KVA codes</p>
</dd>
</dl>



<h3>See Also</h3>

<p>ae
</p>
<p>Other default classcodes: 
<code><a href="#topic+ae">ae</a></code>,
<code><a href="#topic+charlson">charlson</a></code>,
<code><a href="#topic+cps">cps</a></code>,
<code><a href="#topic+elixhauser">elixhauser</a></code>,
<code><a href="#topic+rxriskv">rxriskv</a></code>
</p>

<hr>
<h2 id='index_fun'>Calculate index based on classification scheme</h2><span id='topic+index_fun'></span><span id='topic+index'></span><span id='topic+index.data.frame'></span><span id='topic+index.matrix'></span>

<h3>Description</h3>

<p>This is the third step of <code>codify() %&gt;% classify() %&gt;% index()</code>.
The function takes classified case data and calculates
(weighted) index sums as specified by weights from a <code>classcodes</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index(classified, ...)

## S3 method for class 'data.frame'
index(classified, ...)

## S3 method for class 'matrix'
index(classified, index = NULL, cc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_fun_+3A_classified">classified</code></td>
<td>
<p>output from <code><a href="#topic+classify">classify()</a></code></p>
</td></tr>
<tr><td><code id="index_fun_+3A_...">...</code></td>
<td>
<p>used internally</p>
</td></tr>
<tr><td><code id="index_fun_+3A_index">index</code></td>
<td>
<p>name of column with 'weights' from corresponding
<code><a href="#topic+classcodes">classcodes</a></code> object. Can be <code>NULL</code> if the index is just a unweighted
count of all identified groups.</p>
</td></tr>
<tr><td><code id="index_fun_+3A_cc">cc</code></td>
<td>
<p><code><a href="#topic+classcodes">classcodes</a></code> object. Can be <code>NULL</code> if a <code>classcodes</code> object is
already available as an attribute of <code>classified</code> (which is often the case)
and/or if <code>index = NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Index weights for subordinate hierarchical classes
(as identified by <code>attr(cc, "hierarchy")</code>) are excluded in presence of
superior classes if index specified with argument <code>index</code>.
</p>


<h3>Value</h3>

<p>Named numeric index vector with names corresponding to
<code>rownames(classified)</code>
</p>


<h3>See Also</h3>

<p>Other verbs: 
<code><a href="#topic+categorize">categorize</a>()</code>,
<code><a href="#topic+classify">classify</a>()</code>,
<code><a href="#topic+codify">codify</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prepare some codified data with ICD-10 codes during 1 year (365 days)
# before surgery
x &lt;-
  codify(
    ex_people,
    ex_icd10,
    id        = "name",
    code      = "icd10",
    date      = "surgery",
    days      = c(-365, 0),
    code_date = "admission"
  )

# Classify those patients by the Charlson comorbidity indices
cl &lt;- classify(x, "charlson")

# Calculate (weighted) index values
head(index(cl))                  # Un-weighted sum/no of conditions for each patient
head(index(cl, "quan_original")) # Weighted index (Quan et al. 2005; see `?charlson`)
head(index(cl, "quan_updated"))  # Weighted index (Quan et al. 2011; see `?charlson`)

# Tabulate index for all patients.
# As expected, most patients are healthy and have index = 0/NA,
# where NA indicates no recorded hospital visits
# found in `ex_icd10` during codification.
# In practice, those patients might be assumed to have 0 comorbidity as well.
table(index(cl, "quan_original"), useNA = "always")

# If `cl` is a matrix without additional attributes (as imposed by `codify()`)
# an explicit classcodes object must be specified by the `cc` argument
cl2 &lt;- as.matrix(cl)
head(index(cl2, cc = "charlson"))
</code></pre>

<hr>
<h2 id='print.classcodes'>Print classcodes object</h2><span id='topic+print.classcodes'></span>

<h3>Description</h3>

<p>Print classcodes object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classcodes'
print(x, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.classcodes_+3A_x">x</code></td>
<td>
<p>object of type classcodes</p>
</td></tr>
<tr><td><code id="print.classcodes_+3A_n">n</code></td>
<td>
<p>number of rows to preview (<code>n = 0</code> is allowed)</p>
</td></tr>
<tr><td><code id="print.classcodes_+3A_...">...</code></td>
<td>
<p>arguments passed to print method for tibble</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default printing
elixhauser

# Print attributes data but no data preview
print(elixhauser, n = 0)

# Print all rows
print(elixhauser, n = 31)
</code></pre>

<hr>
<h2 id='print.classified'>Printing classified data</h2><span id='topic+print.classified'></span>

<h3>Description</h3>

<p>Preview first <code>n</code> rows as tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classified'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.classified_+3A_x">x</code></td>
<td>
<p>output from <code><a href="#topic+classify">classify()</a></code></p>
</td></tr>
<tr><td><code id="print.classified_+3A_...">...</code></td>
<td>
<p>additional arguments passed to printing method for a <code>tibble</code>.
<code>n</code> is the number of rows to preview.
Set <code>n = NULL</code> to disable the <code>tibble</code>
preview and print the object as is (a matrix).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Preview all output
classify(c("C80", "I20", "unvalid_code"), "elixhauser")

# Preview only the first row
print(classify(c("C80", "I20", "unvalid_code"), "elixhauser"), n = 1)

# Print object as is (matrix)
print(classify(c("C80", "I20", "unvalid_code"), "elixhauser"), n = NULL)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+visualize'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+visualize">visualize</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+reexports">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rxriskv'>Classcodes for RxRisk V based on ATC codes</h2><span id='topic+rxriskv'></span>

<h3>Description</h3>

<p>Note that desired implementation might differ over time and by country.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxriskv
</code></pre>


<h3>Format</h3>

<p>Data frames with 46 rows and 6 variables:
</p>

<dl>
<dt>group</dt><dd><p>medical condition</p>
</dd>
<dt>pratt</dt><dd><p>ATC codes from table 1 in Pratt et al. 2018
(ignoring PBS item codes and extra conditions).</p>
</dd>
<dt>garland</dt><dd><p>Modified version by Anne
Garland to resemble medical use in Sweden 2016 (Unpublished).</p>
</dd>
<dt>caughey</dt><dd><p>From appendix 1 in Caughey et al. 2010</p>
</dd>
<dt>pratt</dt><dd><p>Mortality weights from table 1 in Pratt et al. 2018</p>
</dd>
<dt>sum_all</dt><dd><p>Unweighted count of all conditions.</p>
</dd>
</dl>



<h3>References</h3>

<p>Caughey GE, Roughead EE, Vitry AI, McDermott RA, Shakib S, Gilbert AL.
Comorbidity in the elderly with diabetes:
Identification of areas of potential treatment conflicts.
Diabetes Res Clin Pract 2010;87:385–93.
</p>
<p>Pratt NL, Kerr M, Barratt JD, Kemp-Casey A, Kalisch Ellett LM,
Ramsay E, et al.
The validity of the Rx-Risk Comorbidity Index using medicines mapped to
the Anatomical Therapeutic Chemical (ATC) Classification System.
BMJ Open 2018;8.
</p>


<h3>See Also</h3>

<p>Other default classcodes: 
<code><a href="#topic+ae">ae</a></code>,
<code><a href="#topic+charlson">charlson</a></code>,
<code><a href="#topic+cps">cps</a></code>,
<code><a href="#topic+elixhauser">elixhauser</a></code>,
<code><a href="#topic+hip_ae_hailer">hip_ae_hailer</a></code>
</p>

<hr>
<h2 id='set_classcodes'>Set classcodes object</h2><span id='topic+set_classcodes'></span>

<h3>Description</h3>

<p>Prepare a <code>classcodes</code>object by specifying the regular expressions
to use for classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_classcodes(
  cc,
  classified = NULL,
  regex = NULL,
  start = TRUE,
  stop = FALSE,
  tech_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_classcodes_+3A_cc">cc</code></td>
<td>
<p><code><a href="#topic+classcodes">classcodes</a></code> object (or name of a default object from
<code><a href="#topic+all_classcodes">all_classcodes()</a></code>).</p>
</td></tr>
<tr><td><code id="set_classcodes_+3A_classified">classified</code></td>
<td>
<p>object that classcodes could be inherited from</p>
</td></tr>
<tr><td><code id="set_classcodes_+3A_regex">regex</code></td>
<td>
<p>name of column with regular expressions to use for
classification.
<code>NULL</code> (default) uses <code>attr(obj, "regexpr")[1]</code>.</p>
</td></tr>
<tr><td><code id="set_classcodes_+3A_start">start</code>, <code id="set_classcodes_+3A_stop">stop</code></td>
<td>
<p>should codes start/end with the specified regular
expressions? If <code>TRUE</code>, column &quot;regex&quot; is prefixed/suffixed
by <code style="white-space: pre;">&#8288;^/$&#8288;</code>.</p>
</td></tr>
<tr><td><code id="set_classcodes_+3A_tech_names">tech_names</code></td>
<td>
<p>should technical column names be used? If <code>FALSE</code>,
colnames are taken directly from group names of <code>cc</code>, if <code>TRUE</code>,
these are changed to more technical names avoiding special characters and
are prefixed by the name of the classification scheme.
<code>NULL</code> (by default) preserves previous names if <code>cc</code> is inherited from
<code>classified</code> (fall backs to <code>FALSE</code> if not already set).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+classcodes">classcodes</a></code> object.
</p>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare a classcodes object for the Charlson comorbidity classification
# based on the default regular expressions
set_classcodes(charlson)   # by object
set_classcodes("charlson") # by name

# Same as above but based on regular expressions for ICD-8 (see `?charlson`)
set_classcodes(charlson, regex = "icd8_brusselaers")

# Only recognize codes if no other characters are found after the relevant codes
# Hence if the code vector stops with the code
set_classcodes(charlson, stop = TRUE)

# Accept code vectors with strings which do not necessarily start with the code.
# This is useful if the code might appear in the middle of a longer character
# string or if a common prefix is used for all codes.
set_classcodes(charlson, start = FALSE)

# Use technical names to clearly describe the origin of each group.
# Note that the `cc` argument must be specified by a character string
# since this name is used as part of the column names
x &lt;- set_classcodes("charlson", tech_names = TRUE)
x$group
</code></pre>

<hr>
<h2 id='summary.classcodes'>Summarizing a classcodes object</h2><span id='topic+summary.classcodes'></span><span id='topic+print.summary.classcodes'></span>

<h3>Description</h3>

<p>Classification schemes are formalized by regular expressions within the
classcodes objects. These are computationally effective but sometimes hard to
interpret. Use this function to list all codes identified for each
group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classcodes'
summary(object, coding, ..., cc_args = list())

## S3 method for class 'summary.classcodes'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.classcodes_+3A_object">object</code></td>
<td>
<p>classcodes object</p>
</td></tr>
<tr><td><code id="summary.classcodes_+3A_coding">coding</code></td>
<td>
<p>either a vector with codes from the original classification,
or a name (character vector of length one) of a keyvalue object
from package &quot;decoder&quot; (for example &quot;icd10cm&quot; or &quot;atc&quot;)</p>
</td></tr>
<tr><td><code id="summary.classcodes_+3A_...">...</code></td>
<td>

<ul>
<li> <p><code>summary.classcodes()</code>: ignored
</p>
</li>
<li> <p><code>print.summary.classcodes()</code>: arguments passed to <code>tibble:::print.tbl()</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary.classcodes_+3A_cc_args">cc_args</code></td>
<td>
<p>List of named arguments passed to <code><a href="#topic+set_classcodes">set_classcodes()</a></code></p>
</td></tr>
<tr><td><code id="summary.classcodes_+3A_x">x</code></td>
<td>
<p>output from <code>summary.classcodes()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Methods primarily called for their side effects (printing to the screen) but
with additional invisible objects returned:
</p>

<ul>
<li> <p><code>summary.classcodes()</code>: list with input arguments <code>object</code> and <code>coding</code>
unchanged, as well as a data frame (<code>summary</code>) with columns for groups
identified (<code>group</code>); the number of codes to be recognized for each group
(<code>n</code>) and individual codes within each group (<code>codes</code>).
</p>
</li>
<li> <p><code>print.summary.classcodes()</code>: argument <code>x</code> unchanged
</p>
</li></ul>



<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+visualize.classcodes">visualize.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# summary.classcodes() ----------------------------------------------------

# Summarize all ICD-10-CM codes identified by the Elixhauser
# comorbidity classification
# See `?decoder::icd10cm` for details
summary(elixhauser, coding = "icd10cm")

# Is there a difference if instead considering the Swedish ICD-10-SE?
# See `?decoder::icd10se` for details
summary(elixhauser, coding = "icd10se")

# Which ICD-9-CM diagnostics codes are recognized by Charlson according to
# Brusselears et al. 2017 (see `?charlson`)
summary(
  charlson, coding = "icd9cmd",
  cc_args = list(regex = "icd9_brusselaers")
)


# print.summary.classcodes() ----------------------------------------------

# Print all 31 lines of the summarized Elixhauser classcodes object
print(
  summary(elixhauser, coding = "icd10cm"),
  n = 31
)

</code></pre>

<hr>
<h2 id='visualize.classcodes'>Visualize classification scheme in web browser</h2><span id='topic+visualize.classcodes'></span>

<h3>Description</h3>

<p>Groups from a <code>classcodes</code> object are visualized by their regular expressions
in the default web browser.
The visualization does not give any details on group names, conditions or
weights but might be useful both for understanding of a classification scheme
in use, and during the creation and debugging of such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'classcodes'
visualize(x, group = NULL, show = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize.classcodes_+3A_x">x</code></td>
<td>
<p><a href="#topic+classcodes">classcodes</a> object or name of such object included in the package
(see <code><a href="#topic+all_classcodes">all_classcodes()</a></code>).</p>
</td></tr>
<tr><td><code id="visualize.classcodes_+3A_group">group</code></td>
<td>
<p>names (as character vector) of groups to visualize
(subset of <code>rownames(x)</code>). (All groups if <code>NULL</code>.)</p>
</td></tr>
<tr><td><code id="visualize.classcodes_+3A_show">show</code></td>
<td>
<p>should a visualization be shown in the default web browser.
Set to <code>FALSE</code> to just retrieve a URL for later use.</p>
</td></tr>
<tr><td><code id="visualize.classcodes_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+set_classcodes">set_classcodes</a></code>
</p>

<dl>
<dt><code>regex</code></dt><dd><p>name of column with regular expressions to use for
classification.
<code>NULL</code> (default) uses <code>attr(obj, "regexpr")[1]</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>URL to website with visualization (invisible)
</p>


<h3>See Also</h3>

<p>Other classcodes: 
<code><a href="#topic+all_classcodes">all_classcodes</a>()</code>,
<code><a href="#topic+as.data.frame.classified">as.data.frame.classified</a>()</code>,
<code><a href="#topic+classcodes">classcodes</a></code>,
<code><a href="#topic+codebook">codebook</a>()</code>,
<code><a href="#topic+print.classcodes">print.classcodes</a>()</code>,
<code><a href="#topic+print.classified">print.classified</a>()</code>,
<code><a href="#topic+set_classcodes">set_classcodes</a>()</code>,
<code><a href="#topic+summary.classcodes">summary.classcodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The default behavior is to open a visualization in the default web browser
## Not run: 

 # How is depression classified according to Elixhauser?
 visualize("elixhauser", "depression")

 # Compare the two diabetes groups according to Charlson
 visualize("charlson",
   c("diabetes without complication", "diabetes complication"))

 # Is this different from the "Royal College of Surgeons classification?
 # Yes, there is only one group for diabetes
 visualize("charlson",
   c("diabetes without complication", "diabetes complication"),
   regex = "rcs"
 )

 # Show all groups from Charlson
 visualize("charlson")

 # It is also possible to visualize an arbitrary regular expression
 # from a character string
 visualize("I2([12]|52)")

## End(Not run)

 # The URL is always returned (invisable) but the visual display can
 # also be omitted
url &lt;- visualize("hip_ae", show = FALSE)
url
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
