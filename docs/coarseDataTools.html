<!DOCTYPE html><html><head><title>Help for package coarseDataTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coarseDataTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cd.fit'><p>An S4 Class that stores a fitted coarse data object</p></a></li>
<li><a href='#cd.fit.mcmc'><p>An S4 Class that stores a MCMC fit coarse data object</p></a></li>
<li><a href='#dgammaOff1'><p>Function that calculates dgamma with a offset of 1 (i.e., 1 is equivalent to 0)</p></a></li>
<li><a href='#dic.fit'><p>censored survival data</p></a></li>
<li><a href='#dic.fit.mcmc'><p>Fits the distribution to the passed-in data using MCMC</p>
as implemented in MCMCpack.</a></li>
<li><a href='#EMforCFR'><p>A function to estimate the relative case fatality ratio when reporting rates</p>
are time-varying and deaths are lagged because of survival time.</a></li>
<li><a href='#exp.win.lengths'><p>Exposure window lengths from an influenza outbreak at a NYC school</p></a></li>
<li><a href='#fluA.inc.per'><p>Coarse incubation period data for influenza A</p></a></li>
<li><a href='#get.obs.type'><p>Tries to guess the observation types (SIC, DIC, or exact).</p></a></li>
<li><a href='#logLik,cd.fit-method'><p>Get the log-likelihood value of a <code>cd.fit</code> or <code>cd.fit.mcmc</code> object</p></a></li>
<li><a href='#loglikhd'><p>Negative log likelihood for a dataset of interval-censored data, given a</p>
distribution and its parameters.</a></li>
<li><a href='#mcmc.erlang'><p>Does a metropolis hastings for the Erlang distribution</p></a></li>
<li><a href='#mcmcpack.ll'><p>posterior log likelihood function to pass to MCMCpack sampler</p></a></li>
<li><a href='#nycH1N1'><p>Incubation period data from New York City Public Schools, 2009 H1N1 influenza outbreak</p></a></li>
<li><a href='#pgammaOff1'><p>Function that calculates pgamma with a offset of 1 (i.e., 1 is equivalent to 0)</p></a></li>
<li><a href='#precision.simulation'><p>Simulate incubation period analyses with coarse data</p></a></li>
<li><a href='#simulated.outbreak.deaths'><p>Simulated case and death reports from a fictional outbreak</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Coarsely Observed Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas G. Reich &lt;nick@umass.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=coarseDataTools">https://cran.r-project.org/package=coarseDataTools</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack, graphics, stats, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to analyze coarse data.
    Specifically, it contains functions to (1) fit parametric accelerated
    failure time models to interval-censored survival time data, and (2)
    estimate the case-fatality ratio in scenarios with under-reporting.
    This package's development was motivated by applications to infectious
    disease: in particular, problems with estimating the incubation period and
    the case fatality ratio of a given disease.  Sample data files are included
    in the package. See Reich et al. (2009) &lt;<a href="https://doi.org/10.1002%2Fsim.3659">doi:10.1002/sim.3659</a>&gt;, 
    Reich et al. (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2011.01709.x">doi:10.1111/j.1541-0420.2011.01709.x</a>&gt;, and 
    Lessler et al. (2009) &lt;<a href="https://doi.org/10.1016%2FS1473-3099%2809%2970069-6">doi:10.1016/S1473-3099(09)70069-6</a>&gt;.</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CFR_estimation.R' 'dic.fit.mcmc.R' 'dic.fit.R'
'get.obs.type.R' 'S4stuff.R' 'sampleSizeSimulation.R'
'coarseDataTools-package.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-09 15:50:04 UTC; ngr</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas G. Reich [aut, cre],
  Justin Lessler [aut],
  Andrew Azman [aut],
  Zhian N. Kamvar [ctb]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-09 17:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cd.fit'>An S4 Class that stores a fitted coarse data object</h2><span id='topic+cd.fit'></span><span id='topic+cd.fit-class'></span>

<h3>Description</h3>

<p>This is the output from <code>dic.fit()</code>, which contains the important bits of information about the model fit and key options used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ests</code>:</dt><dd><p>Matrix of class <code>"numeric"</code>. This matrix summarizes the results of fitting the model. Rows correspond to the first parameter , the second parameter and then percentiles specified by the ptiles argument. Columns correspond to the point estimate, the lower and upper bounds on the 95% confidence interval and the standard error of the point estimate. If the maximization does not converge, this matrix is filled with NAs.</p>
</dd>
<dt><code>conv</code>:</dt><dd><p>Object of class <code>"numeric"</code>. A value of 1 indicates successful convergence; 0 indicates unsuccessful convergence.</p>
</dd>
<dt><code>MSG</code>:</dt><dd><p>Object of class <code>"character"</code>. The error message returned from <code>optim()</code> if the routine fails to converge.</p>
</dd>
<dt><code>loglik</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Value of the estimated maximum log-likelihood.</p>
</dd>
<dt><code>samples</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. Data frame of bootstrap estimates of parameters (if bootstraps were performed).</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. Original data used to fit model.</p>
</dd>
<dt><code>dist</code>:</dt><dd><p>Object of class <code>"character"</code>. Failure time distribution fit to data. &quot;L&quot; for log-normal, &quot;G&quot; for gamma, &quot;W&quot; for Weibull, and &quot;E&quot; for Erlang.</p>
</dd>
<dt><code>inv.hessian</code>:</dt><dd><p>Object of class <code>"matrix"</code>. The inverse of the hessian matrix for the likelihood surface at the MLE. Used to determine the standard errors for the percentiles. Note that optimization is done on a transformed scale with all parameters logged for all distributions except the first parameter of the log-normal distribution.</p>
</dd>
<dt><code>est.method</code>:</dt><dd><p>Object of class <code>"character"</code>. Method used for estimation.</p>
</dd>
<dt><code>ci.method</code>:</dt><dd><p>Object of class <code>"character"</code>. Method used for estimation of confidence/credible intervals.</p>
</dd>
</dl>


<hr>
<h2 id='cd.fit.mcmc'>An S4 Class that stores a MCMC fit coarse data object</h2><span id='topic+cd.fit.mcmc'></span><span id='topic+cd.fit.mcmc-class'></span>

<h3>Description</h3>

<p>This is the output from <code>dic.fit.mcmc()</code>, which contains the important bits of information about the model fit and key options used.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ests</code>:</dt><dd><p>Matrix of class <code>"numeric"</code>. This matrix summarizes the results of fitting the model. Rows correspond to the first parameter , the second parameter and then percentiles specified by the ptiles argument. Columns correspond to the point estimate, the lower and upper bounds on the 95% credible interval and the standard error of the point estimate.</p>
</dd>
<dt><code>conv</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Not used in with <code>dic.fit.mcmc</code></p>
</dd>
<dt><code>MSG</code>:</dt><dd><p>Object of class <code>"character"</code>. The error message returned from optim() if the routine fails to converge.</p>
</dd>
<dt><code>loglik</code>:</dt><dd><p>Object of class <code>"numeric"</code>.  Not used in with <code>dic.fit.mcmc</code>.</p>
</dd>
<dt><code>samples</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. Data frame of posterior draws of parameters.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"data.frame"</code>. Original data used to fit model.</p>
</dd>
<dt><code>dist</code>:</dt><dd><p>Object of class <code>"character"</code>. Failure time distribution fit to data. &quot;L&quot; for log-normal, &quot;G&quot; for gamma, &quot;W&quot; for Weibull, and &quot;E&quot; for Erlang.</p>
</dd>
<dt><code>inv.hessian</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Not used in with <code>dic.fit.mcmc</code>.</p>
</dd>
<dt><code>est.method</code>:</dt><dd><p>Object of class <code>"character"</code>. Method used for estimation.</p>
</dd>
<dt><code>ci.method</code>:</dt><dd><p>Object of class <code>"character"</code>. Method used for estimation of confidence/credible intervals.</p>
</dd>
</dl>


<hr>
<h2 id='dgammaOff1'>Function that calculates dgamma with a offset of 1 (i.e., 1 is equivalent to 0)</h2><span id='topic+dgammaOff1'></span>

<h3>Description</h3>

<p>Function that calculates dgamma with a offset of 1 (i.e., 1 is equivalent to 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgammaOff1(x, replace0 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgammaOff1_+3A_x">x</code></td>
<td>
<p>value to calculate dgamma at</p>
</td></tr>
<tr><td><code id="dgammaOff1_+3A_replace0">replace0</code></td>
<td>
<p>should we replace 0 with epsilon</p>
</td></tr>
<tr><td><code id="dgammaOff1_+3A_...">...</code></td>
<td>
<p>other parameters to dgamma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dgamma offset
</p>

<hr>
<h2 id='dic.fit'>censored survival data</h2><span id='topic+dic.fit'></span>

<h3>Description</h3>

<p><code>dic.fit</code> fits a parametric accelerated failure time model to survival
data. It was developed with the application to estimating incubation periods of infectious diseases 
in mind but is applicable to many general problems.
The data can be a mixture of doubly interval-censored, single
interval-censored or exact observations from a single univariate
distribution. Currently, three distributions are supported: log-normal,
gamma, and Weibull. (The Erlang distribution is supported in the
<code>dic.fit.mcmc</code> function, which implements an MCMC version of this
code.) We use a consistent (par1, par2) notation for each distribution, they
map in the following manner: </p>
<p style="text-align: center;"><code class="reqn">Log-normal(meanlog=par1, sdlog=par2)</code>
</p>

<p style="text-align: center;"><code class="reqn">Gamma(shape=par1, scale=par2)</code>
</p>
 <p style="text-align: center;"><code class="reqn">Weibull(shape=par1, scale=par2)</code>
</p>

<p>Standard errors of parameters can be computed using closed-form asymptotic
formulae or using a bootstrap routine for log-normal and gamma models.
Currently, bootstrap SEs are the only option for the gamma models, which do
not have a closed form for the percentiles. <code>dic.fit()</code> calculates
asymptotic SEs by default, or whenever the <code>n.boots</code> option is set to
0. To compute bootstrap SEs, just set <code>n.boots</code> to be greater than
zero. <code><a href="#topic+dic.fit.mcmc">dic.fit.mcmc</a></code> also allows for Markov Chain Monte Carlo
fitting of these three parametric models and Erlang models as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic.fit(
  dat,
  start.par2 = log(2),
  opt.method = "L-BFGS-B",
  par1.int = c(log(0.5), log(13)),
  par2.int = c(log(1.01), log(log(5))),
  ptiles = c(0.05, 0.95, 0.99),
  dist = "L",
  n.boots = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic.fit_+3A_dat">dat</code></td>
<td>
<p>a matrix with columns named &quot;EL&quot;, &quot;ER&quot;, &quot;SL&quot;, &quot;SR&quot;, corresponding
to the left (L) and right (R) endpoints of the windows of possible
exposure (E) and symptom onset (S). Also, a &quot;type&quot; column must be
specified and have entries with 0, 1, or 2, corresponding to doubly
interval-censored, single interval-censored or exact observations,
respectively.</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_start.par2">start.par2</code></td>
<td>
<p>starting value for 2nd parameter of desired distribution</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_opt.method">opt.method</code></td>
<td>
<p>method used by optim</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_par1.int">par1.int</code></td>
<td>
<p>the log-scale interval of possible median values (in the
same units as the observations in dat).  Narrowing this interval can help
speed up convergence of the algorithm, but care must be taken so that
possible values are not excluded or that the maximization does not return
a value at an endpoint of this interval.</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_par2.int">par2.int</code></td>
<td>
<p>the log-scale interval of possible dispersion values</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_ptiles">ptiles</code></td>
<td>
<p>percentiles of interest</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_dist">dist</code></td>
<td>
<p>what distribution to use to fit the data. Default &quot;L&quot; for
log-normal. &quot;G&quot; for gamma, and &quot;W&quot; for Weibull.</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_n.boots">n.boots</code></td>
<td>
<p>number of bootstrap resamples (0 means that asymptotic results are desired)</p>
</td></tr>
<tr><td><code id="dic.fit_+3A_...">...</code></td>
<td>
<p>additional options passed to optim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cd.fit S4 object.
</p>


<h3>References</h3>

<p>Reich NG et al.  Statistics in Medicine.  Estimating incubation
periods with coarse data. 2009.
<a href="https://pubmed.ncbi.nlm.nih.gov/19598148/">https://pubmed.ncbi.nlm.nih.gov/19598148/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd.fit">cd.fit</a></code>, <code><a href="#topic+dic.fit.mcmc">dic.fit.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fluA.inc.per)
dic.fit(fluA.inc.per, dist="L")
</code></pre>

<hr>
<h2 id='dic.fit.mcmc'>Fits the distribution to the passed-in data using MCMC
as implemented in MCMCpack.</h2><span id='topic+dic.fit.mcmc'></span>

<h3>Description</h3>

<p>Similar to <code><a href="#topic+dic.fit">dic.fit</a></code> but uses MCMC instead of a direct likelihood optimization routine to fit the model. Currently, four distributions are supported: log-normal, gamma, Weibull, and Erlang. See Details for prior specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic.fit.mcmc(
  dat,
  prior.par1 = NULL,
  prior.par2 = NULL,
  init.pars = c(1, 1),
  ptiles = c(0.05, 0.95, 0.99),
  verbose = 1000,
  burnin = 3000,
  n.samples = 5000,
  dist = "L",
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic.fit.mcmc_+3A_dat">dat</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_prior.par1">prior.par1</code></td>
<td>
<p>vector of first prior parameters for each model parameter. If <code>NULL</code> then default parameters are used (as described in Details section).</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_prior.par2">prior.par2</code></td>
<td>
<p>vector of second prior parameters for each model parameter. If <code>NULL</code> then default parameters are used (as described in Details section).</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_init.pars">init.pars</code></td>
<td>
<p>the initial parameter values (vector length = 2 )</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_ptiles">ptiles</code></td>
<td>
<p>returned percentiles of the survival survival distribution</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>how often do you want a print out from MCMCpack on iteration number and M-H acceptance rate</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>number of burnin samples</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_n.samples">n.samples</code></td>
<td>
<p>number of samples to draw from the posterior (after the burnin)</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_dist">dist</code></td>
<td>
<p>distribution to be used (L for log-normal,W for weibull, G for Gamma, and E for erlang, off1G for 1 day right shifted gamma)</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator for MCMC</p>
</td></tr>
<tr><td><code id="dic.fit.mcmc_+3A_...">...</code></td>
<td>
<p>additional parameters to <a href="MCMCpack.html#topic+MCMCmetrop1R">MCMCmetrop1R</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following models are used:
</p>
<p style="text-align: center;"><code class="reqn">Log-normal model: f(x) = \frac{1}{x*\sigma \sqrt{2 * \pi}} exp\{-\frac{(\log x - \mu)^2}{2 * \sigma^2}\}</code>
</p>

<p style="text-align: center;"><code class="reqn">Log-normal Default Prior: \mu ~ N(0, 1000), log(\sigma) ~ N(0,1000)</code>
</p>

<p style="text-align: center;"><code class="reqn">Weibull model: f(x) = \frac{\alpha}{\beta}(\frac{x}{\beta})^{\alpha-1} exp\{-(\frac{x}{\beta})^{\alpha}\}</code>
</p>

<p style="text-align: center;"><code class="reqn">Weibull Default Prior Specification: log(\alpha) ~ N( 0, 1000), \beta ~ Gamma(0.001,0.001)</code>
</p>

<p style="text-align: center;"><code class="reqn">Gamma model: f(x) = \frac{1}{\theta^k \Gamma(k)} x^{k-1} exp\{-\frac{x}{\theta}\}</code>
</p>

<p style="text-align: center;"><code class="reqn">Gamma Default Prior Specification: p(k,\theta) \propto \frac{1}{\theta} * \sqrt{k*TriGamma(k)-1}</code>
</p>

<p>(Note: this is Jeffery's Prior when both parameters are unknown), and 
</p>
<p style="text-align: center;"><code class="reqn">Trigamma(x) = \frac{\partial}{\partial x^2} ln(\Gamma(x))</code>
</p>
<p>.)
</p>
<p style="text-align: center;"><code class="reqn">Erlang model: f(x) = \frac{1}{\theta^k (k-1)!} x^{k-1} exp\{-\frac{x}{\theta}\}</code>
</p>

<p style="text-align: center;"><code class="reqn">Erlang Default Prior Specification: k \sim NBinom(100,1), log(\theta) \sim N(0,1000)</code>
</p>

<p>(Note: parameters in the negative binomial distribution above represent mean and size, respectively)
</p>


<h3>Value</h3>

<p>a cd.fit.mcmc S4 object
</p>

<hr>
<h2 id='EMforCFR'>A function to estimate the relative case fatality ratio when reporting rates
are time-varying and deaths are lagged because of survival time.</h2><span id='topic+EMforCFR'></span>

<h3>Description</h3>

<p>This function implements an EM algorithm to estimate the relative case
fatality ratio between two groups when reporting rates are time-varying and
deaths are lagged because of survival time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMforCFR(assumed.nu, alpha.start.values, full.data, max.iter = 50, 
  verb = FALSE, tol = 1e-10, SEM.var = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMforCFR_+3A_assumed.nu">assumed.nu</code></td>
<td>
<p>a vector of probabilities corresponding to the survival
distribution, i.e. nu[i]=Pr(surviving i days | fatal case)</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_alpha.start.values">alpha.start.values</code></td>
<td>
<p>a vector starting values for the reporting rate
parameter of the GLM model. This must have length which corresponds to one
less than the number of unique integer values of full.dat[,&quot;new.times&quot;].</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_full.data">full.data</code></td>
<td>
<p>A matrix of observed data. See description below.</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_max.iter">max.iter</code></td>
<td>
<p>The maximum number of iterations for the EM algorithm and
the accompanying SEM algorithm (if used).</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_verb">verb</code></td>
<td>
<p>An indicator for whether the function should print results as it
runs.</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_tol">tol</code></td>
<td>
<p>A tolerance to use to test for convergence of the EM algorithm.</p>
</td></tr>
<tr><td><code id="EMforCFR_+3A_sem.var">SEM.var</code></td>
<td>
<p>If TRUE, the SEM algorithm will be run in addition to the EM
algorithm to calculate the variance of the parameter estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data matrix full.data must have the following columns: 
</p>
 <dl>
<dt>grp</dt><dd><p>a 1 or a 2 indicating which of the two groups, j, 
the observation is for.</p>
</dd> <dt>new.times</dt><dd><p>an integer value representing
the time, t, of observation.</p>
</dd> <dt>R</dt><dd><p>the count of recovered cases with
onset at time t in group j.</p>
</dd> <dt>D</dt><dd><p>the count of deaths which occurred at
time t in groupo j (note that these deaths did not have disease onset at
time t but rather died at time t).</p>
</dd> <dt>N</dt><dd><p>the total cases at t, j, or
the sum of R and D columns.</p>
</dd> </dl>



<h3>Value</h3>

<p>A list with the following elements </p>
 <dl>
<dt>naive.rel.cfr
</dt><dd><p>the naive estimate of the relative case fatality ratio</p>
</dd> 
<dt>glm.rel.cfr </dt><dd><p>the reporting-rate-adjusted estimate of the relative
case fatality ratio</p>
</dd> <dt>EM.rel.cfr </dt><dd><p>the lag-adjusted estimate of the
relative case fatality ratio</p>
</dd> <dt>EM.re.cfr.var </dt><dd><p>the variance for the
log-scale lag-adjusted estimator taken from the final M-step</p>
</dd> 
<dt>EM.rel.cfr.var.SEM </dt><dd><p> the Supplemented EM algorithm variance for the
log-scale lag-adjusted estimator</p>
</dd> <dt>EM.rel.cfr.chain </dt><dd><p>a vector of the
EM algorithm iterates of the lag-adjusted relative CFR estimates</p>
</dd> 
<dt>EMiter</dt><dd><p>the number of iterations needed for the EM algorithm to
converge</p>
</dd> <dt>EMconv</dt><dd><p>indicator for convergence of the EM algorithm.  0
indicates all parameters converged within max.iter iterations.  1 indicates
that the estimate of the relative case fatality ratio converged but other
did not.  2 indicates that the relative case fatality ratio did not
converge.</p>
</dd> <dt>SEMconv</dt><dd><p>indicator for convergence of SEM algorithm. 
Same scheme as EMconv.</p>
</dd> <dt>ests</dt><dd><p> the coefficient estimates for the
model </p>
</dd> <dt>ests.chain</dt><dd><p> a matrix with all of the coefficient estimates,
at each EM iteration</p>
</dd> <dt>DM</dt><dd><p>the DM matrix from the SEM algorithm</p>
</dd> 
<dt>DMiter</dt><dd><p>a vector showing how many iterations it took for the
variance component to converge in the SEM algorithm</p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>       
    ## This is code from the CFR vignette provided in the documentation.
       
data(simulated.outbreak.deaths)
min.cases &lt;- 10 
N.1 &lt;- simulated.outbreak.deaths[1:60, "N"] 
N.2 &lt;- simulated.outbreak.deaths[61:120, "N"] 
first.t &lt;- min(which(N.1 &gt; min.cases &amp; N.2 &gt; min.cases)) 
last.t &lt;- max(which(N.1 &gt; min.cases &amp; N.2 &gt; min.cases)) 
idx.for.Estep &lt;- first.t:last.t 
new.times &lt;- 1:length(idx.for.Estep) 
simulated.outbreak.deaths &lt;- cbind(simulated.outbreak.deaths, new.times = NA) 
simulated.outbreak.deaths[c(idx.for.Estep, idx.for.Estep + 60), "new.times"] &lt;- rep(new.times, + 2)
assumed.nu = c(0, 0.3, 0.4, 0.3)
alpha.start &lt;- rep(0, 22)
       
## caution! this next line may take several minutes (5-10, depanding on 
##    the speed of your machine) to run.
## Not run: cfr.ests &lt;- EMforCFR(assumed.nu = assumed.nu, 
                              alpha.start.values = alpha.start, 
                              full.data = simulated.outbreak.deaths, 
                              verb = FALSE, 
                              SEM.var = TRUE, 
                              max.iter = 500, 
                              tol = 1e-05)
## End(Not run)
</code></pre>

<hr>
<h2 id='exp.win.lengths'>Exposure window lengths from an influenza outbreak at a NYC school</h2><span id='topic+exp.win.lengths'></span>

<h3>Description</h3>

<p>A numeric vector of exposure window lengths taken from a dataset of doubly interval-censored incubation period observations.  All observations came from a NYC public school.  The outbreak has been described in full in Lessler et al. (see citation below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exp.win.lengths)
</code></pre>


<h3>Format</h3>

<p>A numeric vector with 134 positive values.  Each value represents an exposure window length from an observation of the incubation period for that individual.  The exposure window length is the length of time during which exposure could have occurred.  For example, if an individual could have been exposed anytime between 6am on Monday to 6am on Wednesday, her exposure window length would be 2 days.
</p>


<h3>Source</h3>

<p>Lessler J et al.  New England Journal of Medicine. Outbreak of 2009 Pandemic Influenza A (H1N1) at a New York City School. 2009. 361(27):2628-2636. <a href="https://www.nejm.org/doi/full/10.1056/nejmoa0906089">https://www.nejm.org/doi/full/10.1056/nejmoa0906089</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exp.win.lengths)
summary(exp.win.lengths)
hist(exp.win.lengths)
</code></pre>

<hr>
<h2 id='fluA.inc.per'>Coarse incubation period data for influenza A</h2><span id='topic+fluA.inc.per'></span>

<h3>Description</h3>

<p>These observations on the incubation period of influenza A come from a variety of sources, and were gathered for a literature review.  They report doubly interval-censored, single interval-censored or exact observations for the incubation period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fluA.inc.per)
</code></pre>


<h3>Format</h3>

<p>A data frame with 151 observations on the following 7 variables. 
</p>

<dl>
<dt><code>author</code></dt><dd><p>the name of the primary author for the source of the observation</p>
</dd>
<dt><code>year</code></dt><dd><p>the year of the study which is the source of the observation</p>
</dd>
<dt><code>EL</code></dt><dd><p>the earliest possible time of infection</p>
</dd>
<dt><code>ER</code></dt><dd><p>the latest possible time of infection</p>
</dd>
<dt><code>SL</code></dt><dd><p>the earliest possible time of symptom onset</p>
</dd>
<dt><code>SR</code></dt><dd><p>the latest possible time of symptom onset</p>
</dd>
<dt><code>type</code></dt><dd><p>an indicator of the type of observation: 0 for doubly interval-censored, 1 for single-interval censored, 2 for exact</p>
</dd></dl>



<h3>Source</h3>

<p>Lessler J, Reich NG, Brookmeyer R, Perl TM, Nelson KE, Cummings DAT. (2009) A systematic review of the incubation periods of acute respiratory viral infections. Lancet Infectious Diseases. 9(5):291-300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fluA.inc.per)
head(fluA.inc.per)
</code></pre>

<hr>
<h2 id='get.obs.type'>Tries to guess the observation types (SIC, DIC, or exact).</h2><span id='topic+get.obs.type'></span>

<h3>Description</h3>

<p>Tries to guess the observation types (SIC, DIC, or exact).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.obs.type(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.obs.type_+3A_dat">dat</code></td>
<td>
<p>a matrix of data, similar to what needs to be passed to <code>dic.fit()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of guessed types
</p>

<hr>
<h2 id='logLik+2Ccd.fit-method'>Get the log-likelihood value of a <code>cd.fit</code> or <code>cd.fit.mcmc</code> object</h2><span id='topic+logLik+2Ccd.fit-method'></span><span id='topic+logLik'></span>

<h3>Description</h3>

<p>Get the log-likelihood value of a <code>cd.fit</code> or <code>cd.fit.mcmc</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cd.fit'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik+2B2Ccd.fit-method_+3A_object">object</code></td>
<td>
<p>A <code>cd.fit</code> or <code>cd.fit.mcmc</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>log-likelihood value
</p>

<hr>
<h2 id='loglikhd'>Negative log likelihood for a dataset of interval-censored data, given a
distribution and its parameters.</h2><span id='topic+loglikhd'></span>

<h3>Description</h3>

<p>Negative log likelihood for a dataset of interval-censored data, given a
distribution and its parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikhd(pars, dat, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikhd_+3A_pars">pars</code></td>
<td>
<p>vector of the transformed (estimation scale) parameters</p>
</td></tr>
<tr><td><code id="loglikhd_+3A_dat">dat</code></td>
<td>
<p>a dataset, as in <code>dic.fit</code></p>
</td></tr>
<tr><td><code id="loglikhd_+3A_dist">dist</code></td>
<td>
<p>a distribution, as in <code>dic.fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package uses two versions of each parameter, the estimation
scale, or the scale that is used for numerical optimization, and the
reporting scale, or the natural scale of the parameters. For all
likelihood calculations, this <code>loglikhd</code> function expects parameters
that are on the estimation scale, i.e. have range <code class="reqn">(-\infty, \infty)</code>.
Specifically, this translates into all parameters for all distributions
being log-transformed except for the meanlog (i.e. &quot;par1&quot;) for the
log-normal distribution.
</p>


<h3>Value</h3>

<p>negative log-likelihood for a given dataset, parameters, and
distribution.
</p>

<hr>
<h2 id='mcmc.erlang'>Does a metropolis hastings for the Erlang distribution</h2><span id='topic+mcmc.erlang'></span>

<h3>Description</h3>

<p>Does a metropolis hastings for the Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.erlang(
  dat,
  prior.par1,
  prior.par2,
  init.pars,
  verbose,
  burnin,
  n.samples,
  sds = c(1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.erlang_+3A_dat">dat</code></td>
<td>
<p>the data to fit</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_prior.par1">prior.par1</code></td>
<td>
<p>mean of priors. A negative binomial (for shape) and a normal for log(scale)</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_prior.par2">prior.par2</code></td>
<td>
<p>dispersion parameters for priors, dispersion for negative binomial, log scale sd for normal</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_init.pars">init.pars</code></td>
<td>
<p>the starting parameters on the reporting scale</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_verbose">verbose</code></td>
<td>
<p>how often to print an update</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_burnin">burnin</code></td>
<td>
<p>how many burnin iterations to do</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of samples to keep and report back</p>
</td></tr>
<tr><td><code id="mcmc.erlang_+3A_sds">sds</code></td>
<td>
<p>the standard deviations for the proposal distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of n.samples X 2 parameters, on the estimation scale
</p>

<hr>
<h2 id='mcmcpack.ll'>posterior log likelihood function to pass to MCMCpack sampler</h2><span id='topic+mcmcpack.ll'></span>

<h3>Description</h3>

<p>posterior log likelihood function to pass to MCMCpack sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcpack.ll(pars, dat, prior.par1, prior.par2, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcpack.ll_+3A_pars">pars</code></td>
<td>
<p>the parameters to calculate the ll at</p>
</td></tr>
<tr><td><code id="mcmcpack.ll_+3A_dat">dat</code></td>
<td>
<p>the date to base it on</p>
</td></tr>
<tr><td><code id="mcmcpack.ll_+3A_prior.par1">prior.par1</code></td>
<td>
<p>first parameter of each prior</p>
</td></tr>
<tr><td><code id="mcmcpack.ll_+3A_prior.par2">prior.par2</code></td>
<td>
<p>second parameter of each prior</p>
</td></tr>
<tr><td><code id="mcmcpack.ll_+3A_dist">dist</code></td>
<td>
<p>the distribution the likelihood is being calculated for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the posterior log likelihood
</p>

<hr>
<h2 id='nycH1N1'>Incubation period data from New York City Public Schools, 2009 H1N1 influenza outbreak</h2><span id='topic+nycH1N1'></span>

<h3>Description</h3>

<p>These observations on the incubation period of influenza A come from the investigation of the H1N1 outbreak in NYC schools in the spring of 2009. They report doubly interval-censored observations for the incubation period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nycH1N1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 134 observations on the following 5 variables. 
</p>

<dl>
<dt><code>EL</code></dt><dd><p>the earliest possible time of infection</p>
</dd>
<dt><code>ER</code></dt><dd><p>the latest possible time of infection</p>
</dd>
<dt><code>SL</code></dt><dd><p>the earliest possible time of symptom onset</p>
</dd>
<dt><code>SR</code></dt><dd><p>the latest possible time of symptom onset</p>
</dd>
<dt><code>type</code></dt><dd><p>an indicator of the type of observation: 0 for doubly interval-censored, 1 for single-interval censored, 2 for exact. All of these observations are doubly interval-censored.</p>
</dd></dl>



<h3>Source</h3>

<p>Lessler J, Reich NG, Cummings DAT and The DOHMH Swine Influenza Investigation Team. Outbreak of 2009 Pandemic Influenza A (H1N1) at a New York City School. New England Journal of Medicine. 2009. 361(27):2628-2636.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nycH1N1)
head(nycH1N1)
## Not run: dic.fit(nycH1N1)
</code></pre>

<hr>
<h2 id='pgammaOff1'>Function that calculates pgamma with a offset of 1 (i.e., 1 is equivalent to 0)</h2><span id='topic+pgammaOff1'></span>

<h3>Description</h3>

<p>Function that calculates pgamma with a offset of 1 (i.e., 1 is equivalent to 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgammaOff1(x, replace0 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgammaOff1_+3A_x">x</code></td>
<td>
<p>value to calculate pgamma at</p>
</td></tr>
<tr><td><code id="pgammaOff1_+3A_replace0">replace0</code></td>
<td>
<p>should we replace 0 with epsilon</p>
</td></tr>
<tr><td><code id="pgammaOff1_+3A_...">...</code></td>
<td>
<p>other parameters to pgamma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pgamma offset
</p>

<hr>
<h2 id='precision.simulation'>Simulate incubation period analyses with coarse data</h2><span id='topic+precision.simulation'></span><span id='topic+precision.simulation.exact'></span><span id='topic+precision.simulation.coarse'></span><span id='topic+generate.coarse.data'></span>

<h3>Description</h3>

<p>These functions simulate coarse incubation period data sets and
analyze them.  The goal is for these simulations to provide evidence for
how much information a given dataset contains about a characteristic of
the incubation period distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision.simulation(
  N,
  med = 2,
  disp = 1.3,
  percentile = 0.5,
  nsim = 100,
  exact.data = FALSE,
  pct.type.A = 0.5,
  exp.win.dat = NULL,
  verb = FALSE
)

precision.simulation.exact(N, med, disp, percentile, nsim, verb)

precision.simulation.coarse(
  N,
  med,
  disp,
  percentile,
  nsim,
  pct.type.A,
  exp.win.dat,
  verb
)

generate.coarse.data(N, med, disp, pct.type.A, exp.win.dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision.simulation_+3A_n">N</code></td>
<td>
<p>Overall sample size for the datasets to be simulated.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_med">med</code></td>
<td>
<p>Median for the assumed log normal distribution of the incubation
periods.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_disp">disp</code></td>
<td>
<p>Dispersion for the assumed log normal distribution of the
incubation periods.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_percentile">percentile</code></td>
<td>
<p>Percentile of the incubation period distribution which we
want to estimate.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_nsim">nsim</code></td>
<td>
<p>Number of datasets to analyze in the simulation.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_exact.data">exact.data</code></td>
<td>
<p>Either TRUE/FALSE.  Incidates whether the data generated
should be coarsened at all.  If TRUE, pct.type.A and exp.win.dat are
ignored.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_pct.type.a">pct.type.A</code></td>
<td>
<p>Percent of the N observations that are assumed to be type
A data.  If N*pct.type.A is not an integer, it will be rounded to the
nearest integer.</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_exp.win.dat">exp.win.dat</code></td>
<td>
<p>A vector of exposure window lengths.  Defaults to the
observed window lengths from Lessler et al. (see below).</p>
</td></tr>
<tr><td><code id="precision.simulation_+3A_verb">verb</code></td>
<td>
<p>If TRUE, a message with the system time and iteration number
will be printed ten times during the simulation run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>precision.simulation</code> functions return a matrix with four
columns and nsim rows.  The &quot;ests&quot; column gives the estimated percentiles
for the incubation period distribution.  The &quot;SE&quot; column gives the
standard error for the estimate.  The &quot;conv&quot; column is 1 if the doubly
interval-censored likelihood maximization converged.  Otherwise, it is 0.
The &quot;bias&quot; column gives the estimated percentile - true percentile. The
<code>generate.coarse.data</code> function returns a matrix with data suitable
for analysis by the <code>dic.fit</code> function.
</p>

<hr>
<h2 id='simulated.outbreak.deaths'>Simulated case and death reports from a fictional outbreak</h2><span id='topic+simulated.outbreak.deaths'></span>

<h3>Description</h3>

<p>This dataset provides reported counts of cases and deaths occurring at different time points across a simulated outbreak. Details of the data simulation algorithm are provided in the manuscript &quot;Estimating case fatality ratios from infectious disease surveillance data&quot; (Reich et al., under review, available upon request).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulated.outbreak.deaths)
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>time</code></dt><dd><p>time, t,  after start of outbreak</p>
</dd>
<dt><code>grp</code></dt><dd><p>an categorical variable indicating membership in one of two groups of a covariate, j</p>
</dd>
<dt><code>R</code></dt><dd><p>number of recovered cases reported at the given t and j</p>
</dd>
<dt><code>D</code></dt><dd><p>number of deaths reported at the given t and j</p>
</dd>
<dt><code>N</code></dt><dd><p>total number of cases and deaths reported at t and j, or D+R</p>
</dd>
</dl>



<h3>Source</h3>

<p>Reich NG, Lessler J, Cummings DAT, Brookmeyer R. Estimating case fatality ratios from infectious disease surveillance data. Biometrics. 2012. 68(2): 598-606.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulated.outbreak.deaths)
head(simulated.outbreak.deaths)
plot(simulated.outbreak.deaths[simulated.outbreak.deaths[,"grp"]==1,"D"], type="l")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
