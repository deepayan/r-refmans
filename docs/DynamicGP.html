<!DOCTYPE html><html><head><title>Help for package DynamicGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DynamicGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DynamicGP-package'><p>Modelling and Analysis of Dynamic Computer Experiments</p></a></li>
<li><a href='#ESL2D'>
<p>Expected Squared <code class="reqn">L_2</code> Discrepancy Approach for Estimating the</p>
Solution to the Inverse Problem</a></li>
<li><a href='#knnsvdGP'><p>K-nearest neighbor SVD-Based GP model</p></a></li>
<li><a href='#lasvdGP'>
<p>Local Approximate SVD-Based GP Models</p></a></li>
<li><a href='#saEI'><p>Saddlepoint Approximate Expected Improvement Criterion for</p>
the Sequential Design for Inverse Problems</a></li>
<li><a href='#SL2D'>
<p>Squared <code class="reqn">L_{2}</code> Discrepancy Approach for Estimating the</p>
Solution to the Inverse Problem</a></li>
<li><a href='#svdGP'>
<p>Full SVD-Based GP Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Modelling and Analysis of Dynamic Computer Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-9</td>
</tr>
<tr>
<td>Description:</td>
<td>Emulating and solving inverse problems for dynamic computer experiments.
	     It contains two major functionalities: (1) localized GP model for large-scale
	     dynamic computer experiments using the algorithm proposed by
	     Zhang et al. (2018) &lt;<a href="https://arxiv.org/abs/1611.09488">arXiv:1611.09488</a>&gt;; (2) solving inverse problems
	     in dynamic computer experiments. The current version only supports 64-bit
	     version of R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ru Zhang &lt;heavenmarshal@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lhs, parallel, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Ru Zhang [aut, cre],
  Chunfang Devon Lin [aut],
  Pritam Ranjan [aut],
  Robert B Gramacy [ctb],
  Nicolas Devillard [ctb],
  Jorge Nocedal [ctb],
  Jose Luis Morales [ctb],
  Ciyou Zhu [ctb],
  Richard Byrd [ctb],
  Peihuang Lu-Chen [ctb],
  Berend Hasselman [ctb],
  Jack Dongarra [ctb],
  Jeremy Du Croz [ctb],
  Sven Hammarling [ctb],
  Richard Hanson [ctb],
  University of Chicago [cph],
  University of California [cph]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-03 20:40:35 UTC; rzhang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-08 10:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='DynamicGP-package'>Modelling and Analysis of Dynamic Computer Experiments</h2><span id='topic+DynamicGP-package'></span>

<h3>Description</h3>

<p>For emulating dynamic computer experiments, three functions
are included. The function <code>svdGP</code> fits full SVD-based GP model
which is computationally demanding for large-scale dyanmic computer
experiments. As is well known, the time complexity of fitting a GP
model is <code class="reqn">O(N^3)</code> where <code class="reqn">N</code> is the number of training/design
points. Since fitting a common GP model for really large <code class="reqn">N</code> would
be computationally burdensome, we fit local SVD-based GP models on a
sequentially selected small neighborhood set for every test
inputs. The function <code>knnsvdGP</code> fits K-nearest neighbor SVD-based
GP models which selects neighborhood sets based on the Euclidean
distance with repect to the test points. The function <code>lasvdGP</code>
fits local approximate SVD-based GP model using the new algorithm
proposed by Zhang et al. (2018).
</p>
<p>The lasvdGP is an extension of the local approximate GP (laGP) model
developed by Gramacy and Lee (2015) for the emulation of large-scale
scalar valued computer experiments. The neighborhood selection and
SVD-based GP model fitting algorithm is suitable for
parallelization. We use both the R package &quot;parallel&quot; and the OpenMP
library for this task. The parallelization can achieve nearly linear
speed since the procedure on each test point is independent and
identical.
</p>
<p>For the inverse problem in dynamic computer experiments, we also
provide three functions. The function <code>ESL2D</code> minimizes the
expected squared <code class="reqn">L_{2}</code> discrepancy between the target response
and the simulator outputs to estimate the solution to the inverse
problem, where the expectation is taken with respect to the predictive
distribution of the <code>svdGP</code> model. A naive estimation approach
<code>SL2D</code> simply minimizes the squared <code class="reqn">L_{2}</code> discrepancy
between the target response and the predicted mean response of the
SVD-based GP model. The function <code>saEI</code> performs the squential
design procedure for the inverse problem. It selects the follow-up
design points as per an expected improvement criterion whose values
are numerically approximated by the saddlepoint approximation
technique. Details of the three methods for the inverse problem are
provided in Chapter 4 of Zhang (2018).  </p>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p>Gramacy, R. B. and Apley, D. W. (2015) <em>Local Gaussian
process approximation for large computer experiments</em>, Journal of
Computational and Graphical Statistics 24(2), 561-578.
</p>
<p>Zhang, R., Lin, C. D. and Ranjan, P. (2018) <em>Local Gaussian
Process Model for Large-scale Dynamic Computer Experiments</em>,
Journal of Computational and Graphical Statistics, <br /> DOI:
10.1080/10618600.2018.1473778.
</p>
<p>Zhang, R. (2018) <em>Modeling and Analysis of Dynamic Computer Experiments</em>,
PhD thesis, Queen's University, ON, Canada.
</p>

<hr>
<h2 id='ESL2D'>
Expected Squared <code class="reqn">L_2</code> Discrepancy Approach for Estimating the
Solution to the Inverse Problem
</h2><span id='topic+ESL2D'></span>

<h3>Description</h3>

<p>This function fits an SVD-based GP model on the
training dataset <code>design</code> and response matrix <code>resp</code>, and
minimizes the expected squared <code class="reqn">L_{2}</code> discrepancy on the
test set <code>candidate</code> to estimate the solution to the inverse
problem. The details are provided in Chapter 4 of Zhang (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESL2D(design,resp,yobs,candidate,frac=.95,nstarts=5,
      mtype=c("zmean","cmean","lmean"),
      gstart=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESL2D_+3A_design">design</code></td>
<td>
<p>An <code class="reqn">N</code> by <code class="reqn">d</code> matrix of <code class="reqn">N</code>
training/design inputs.</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_resp">resp</code></td>
<td>
<p> An <code class="reqn">L</code> by <code class="reqn">N</code> response matrix of <code>design</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code class="reqn">N</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_yobs">yobs</code></td>
<td>
<p> A vector of length <code class="reqn">L</code> of the time-series valued
field observations or the target response.
</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_candidate">candidate</code></td>
<td>
<p> An <code class="reqn">M</code> by <code class="reqn">d</code> matrix of <code class="reqn">M</code> candidate points
on which the estimated solution to the inverse problem is extracted.
</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_frac">frac</code></td>
<td>

<p>The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_mtype">mtype</code></td>
<td>
<p> The type of mean functions for the GP models. The choice
&quot;zmean&quot; denotes zero-mean, &quot;cmean&quot; indicates constant-mean, &quot;lmean&quot; indicates
linear-mean. The default choice is &quot;zmean&quot;.
</p>
</td></tr>
<tr><td><code id="ESL2D_+3A_gstart">gstart</code></td>
<td>
<p> The starting number and upper bound for estimating the
nugget parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the
nugget parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>,
since <code>sqrt(.Machine$double.eps)</code> is the lower bound of the
nugget term. The default value is 0.0001.</p>
</td></tr> </table>


<h3>Value</h3>

<table>
<tr><td><code>xhat</code></td>
<td>
<p>The estimated solution to the inverse problem obtained from the
candidate set <code>candidate</code></p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p> Zhang, R. (2018) <em>Modeling and Analysis of Dynamic Computer Experiments</em>,
PhD thesis, Queen's University, ON, Canada.</p>


<h3>See Also</h3>

<p><code><a href="#topic+SL2D">SL2D</a></code>, <code><a href="#topic+saEI">saEI</a></code>, <code><a href="#topic+svdGP">svdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("lhs")
  forretal &lt;- function(x,t,shift=1)
  {
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
  }
  timepoints &lt;- seq(0,1,len=200)
  design &lt;- lhs::randomLHS(30,3)
  candidate &lt;- lhs::randomLHS(500,3)
  candidate &lt;- rbind(candidate,design)

  ## evaluate the response matrix on the design matrix
  resp &lt;- apply(design,1,forretal,timepoints)
  x0 &lt;- runif(3)
  y0 &lt;- forretal(x0,timepoints)
  yobs &lt;- y0+rnorm(200,0,sd(y0)/sqrt(50))
  xhat &lt;- ESL2D(design,resp,yobs,candidate,nstarts=1)
  yhat &lt;- forretal(xhat,timepoints)

  ## draw a figure to illustrate
  plot(y0,ylim=c(min(y0,yhat),max(y0,yhat)))
  lines(yhat,col="red")
</code></pre>

<hr>
<h2 id='knnsvdGP'>K-nearest neighbor SVD-Based GP model</h2><span id='topic+knnsvdGP'></span>

<h3>Description</h3>

<p>Fits a K-nearest neighbour SVD-based GP model on a test set
<code>X0</code>, training set <code>design</code> and response matrix <code>resp</code>. The
local neighbourhood sets consist of <code>nn</code> points which are selected
by the Euclidean distance with respect to the test points. See Zhang et
al. (2018) for details.This function supports the
parallelization via both the R packages &quot;parallel&quot; and the OpenMP
library.</p>


<h3>Usage</h3>

<pre><code class='language-R'>knnsvdGP(design,resp, X0=design, nn=20, nsvd = nn, frac = .95,
         gstart = 0.0001, nstarts = 5,centralize=FALSE, maxit=100,
         errlog = "", nthread = 1, clutype="PSOCK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knnsvdGP_+3A_design">design</code></td>
<td>
<p> An <code class="reqn">N</code> by <code class="reqn">d</code> matrix of <code class="reqn">N</code> training/design
inputs.</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_resp">resp</code></td>
<td>
<p> An <code class="reqn">L</code> by <code class="reqn">N</code> response matrix of <code>design</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code class="reqn">N</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_x0">X0</code></td>
<td>
<p> An <code class="reqn">M</code> by <code class="reqn">d</code> matrix of <code class="reqn">M</code> test inputs. The
localized SVD-based GP models will be fitted on every point (row) of
<code>X0</code>. The default value of <code>X0</code> is <code>design</code>.</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_nn">nn</code></td>
<td>

<p>The number of neighborhood points selected by the Euclidean
distance. the default value is 20.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_nsvd">nsvd</code></td>
<td>

<p>The number of design points closest to the test points on whose
response matrix to perform the initial singular value
decomposition. The default value is <code>nn</code>.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_frac">frac</code></td>
<td>

<p>The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_gstart">gstart</code></td>
<td>

<p>The starting number and upper bound for estimating the nugget
parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the nugget
parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>, since
<code>sqrt(.Machine$double.eps)</code> is the lower bound of the nugget
term. The default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_centralize">centralize</code></td>
<td>

<p>If <code>centralize=TRUE</code> the response matrix will be centralized
(subtract the mean) before the start of the algorithm. The mean will
be added to the predictive mean at the finish of the algorithm. The
default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations in the numerical optimization algorithm
for maximizing the posterior density function. The default value is
100.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_errlog">errlog</code></td>
<td>

<p>The path of a log file that records the errors occur in the process of fitting
local SVD-based GP models. If an empty string is provided, no log file will be
produced.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_nthread">nthread</code></td>
<td>

<p>The number of threads (processes) used in parallel execution of this
function. <code>nthread=1</code> implies no parallelization. The default
value is 1.
</p>
</td></tr>
<tr><td><code id="knnsvdGP_+3A_clutype">clutype</code></td>
<td>

<p>The type of parallization utilized by this function. If <code>clutype="OMP"</code>,
it will use the OpenMP parallelization. Otherwise, it indicates the
type of cluster in the R package &quot;parallel&quot; . The default value is &quot;PSOCK&quot;.
Required only if <code>nthread</code>&gt;1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pmean</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted mean for the response at
the test set <code>X0</code>.
</p>
</td></tr>
<tr><td><code>ps2</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted variance for the response at
the test set <code>X0</code>.
</p>
</td></tr>
<tr><td><code>flags</code></td>
<td>

<p>A vector of integers of length <code class="reqn">M</code> which indicates the status for fitting the
local SVD-based GP models for each of the <code class="reqn">M</code> input points in the test set.
The value <code class="reqn">0</code> indicates successful fitting, the value <code class="reqn">1</code> indicates an
error in Cholesky decomposition of the correlation matrices, the value <code class="reqn">2</code>
indicates an error in SVD of the local response matrix, the value <code class="reqn">3</code> indicates
an error in optimizing the nugget term.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p>Zhang, R., Lin, C. D. and Ranjan, P. (2018) <em>Local Gaussian
Process Model for Large-scale Dynamic Computer Experiments</em>,
Journal of Computational and Graphical Statistics, <br /> DOI:
10.1080/10618600.2018.1473778.</p>


<h3>See Also</h3>

<p><code><a href="#topic+lasvdGP">lasvdGP</a></code>, <code><a href="#topic+svdGP">svdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("lhs")
forretal &lt;- function(x,t,shift=1)
{
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
}
timepoints &lt;- seq(0,1,len=200)
design &lt;- lhs::randomLHS(100,3)
test &lt;- lhs::randomLHS(20,3)

## evaluate the response matrix on the design matrix
resp &lt;- apply(design,1,forretal,timepoints)

nn &lt;- 15
gs &lt;- sqrt(.Machine$double.eps)

## knnsvdGP with mutiple (5) start points for GP model estimation
## It use the R package "parallel" for parallelization
retknnmsp &lt;- knnsvdGP(design,resp,test,nn,frac=.95,gstart=gs,
                      centralize=TRUE,nstarts=5,nthread=2,clutype="PSOCK")

## knnsvdGP with single start point for GP model estimation
## It does not use parallel computation
retknnss &lt;- knnsvdGP(design,resp,test,nn,frac=.95,gstart=gs,
                     centralize=TRUE,nstarts=1,nthread=1)
</code></pre>

<hr>
<h2 id='lasvdGP'>
Local Approximate SVD-Based GP Models
</h2><span id='topic+lasvdGP'></span>

<h3>Description</h3>

<p>Fits a local approximate SVD-based GP model on a test set
<code>X0</code>, training/design set <code>design</code> and response matrix
<code>resp</code>. The local neighborhood sets consist of <code>nn</code> out of
which <code>n0</code> points are selected by the Euclidean distance with
respect to the test points. The remaining <code>nn</code>-<code>n0</code>
neighborhood points are selected sequentially by a greedy algorithm
proposed by Zhang et al. (2018). This function supports the
parallelization via both the R packages &quot;parallel&quot; and the OpenMP
library.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasvdGP(design, resp, X0=design, n0=10, nn=20,
        nfea = min(1000,nrow(design)),
        nsvd = nn, nadd = 1, frac = .95, gstart = 0.0001,
        resvdThres = min(5, nn-n0), every = min(5,nn-n0),
        nstarts = 5,centralize=FALSE, maxit=100,
        errlog = "", nthread = 1, clutype="PSOCK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasvdGP_+3A_design">design</code></td>
<td>
<p> An <code class="reqn">N</code> by <code class="reqn">d</code> matrix of <code class="reqn">N</code> training/design
inputs.</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_resp">resp</code></td>
<td>
<p> An <code class="reqn">L</code> by <code class="reqn">N</code> response matrix of <code>design</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code class="reqn">N</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_x0">X0</code></td>
<td>
<p> An <code class="reqn">M</code> by <code class="reqn">d</code> matrix of <code class="reqn">M</code> test inputs. The
localized SVD-based GP models will be fitted on every point (row) of
<code>X0</code>. The default value of <code>X0</code> is <code>design</code>.</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_n0">n0</code></td>
<td>

<p>The number of points in the initial neighborhood set. The initial
neighborhood set is selected by the Euclidean distance. The default
value is 10.</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nn">nn</code></td>
<td>

<p>The total number of neighborhood points. The <code>nn-n0</code> points are
selected sequentially by the proposed algorithm. The default value
is 20.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nfea">nfea</code></td>
<td>

<p>The number of feasible points within which to select the
neighborhood points. This function will only consider the
<code>nfea</code> design points closest to the test point in terms of
Euclidean distance when selecting neighborhood points. The default
value is the minimum of <code class="reqn">N</code> and 1000.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nsvd">nsvd</code></td>
<td>

<p>The number of design points closest to the test points on whose
response matrix to perform the initial singular value
decomposition. The default value is <code>nn</code>.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nadd">nadd</code></td>
<td>

<p>The number of neighborhood points selected at one iteration. The
default value is 1.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_frac">frac</code></td>
<td>

<p>The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_gstart">gstart</code></td>
<td>

<p>The starting number and upper bound for estimating the nugget
parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the nugget
parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>, since
<code>sqrt(.Machine$double.eps)</code> is the lower bound of the nugget
term. The default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_resvdthres">resvdThres</code></td>
<td>

<p>The threshold to re-perform SVD. After every <code>resvdThres</code>
points have been included into the neighborhood set, the SVD of the
response matrix will be re-performed and the SVD-based GP model will
be refitted. The default value is the minimum of <code>nn</code>-<code>n0</code>
and 5.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_every">every</code></td>
<td>

<p>The threshold to refit GP models without re-perform SVD. After every
<code>every</code> points have been included into the neighborhood set,
the GP models will be refitted. But the SVD will not be
re-performed. It is suggested <code>every</code> &lt;= <code>resvdThres</code>. The
default value is the minimum of <code>nn</code>-<code>n0</code> and 5.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_centralize">centralize</code></td>
<td>

<p>If <code>centralize=TRUE</code> the response matrix will be centralized
(subtract the mean) before the start of the algorithm. The mean will
be added to the predictive mean at the finish of the algorithm. The
default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations in the numerical optimization algorithm
for maximizing the posterior density function. The default value is
100.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_errlog">errlog</code></td>
<td>

<p>The path of a log file that records the errors occur in the process of fitting
local SVD-based GP models. If an empty string is provided, no log file will be
produced.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_nthread">nthread</code></td>
<td>

<p>The number of threads (processes) used in parallel execution of this
function. <code>nthread=1</code> implies no parallelization. The default
value is 1.
</p>
</td></tr>
<tr><td><code id="lasvdGP_+3A_clutype">clutype</code></td>
<td>

<p>The type of parallization utilized by this function. If <code>clutype="OMP"</code>,
it will use the OpenMP parallelization. Otherwise, it indicates the
type of cluster in the R package &quot;parallel&quot; . The default value is &quot;PSOCK&quot;.
Required only if <code>nthread</code>&gt;1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pmean</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted mean for the response at
the test set <code>X0</code>.
</p>
</td></tr>
<tr><td><code>ps2</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted variance for the response at
the test set <code>X0</code>.
</p>
</td></tr>
<tr><td><code>flags</code></td>
<td>

<p>A vector of integers of length <code class="reqn">M</code> which indicates the status for fitting the
local SVD-based GP models for each of the <code class="reqn">M</code> input points in the test set.
The value <code class="reqn">0</code> indicates successful fitting, the value <code class="reqn">1</code> indicates an
error in Cholesky decomposition of the correlation matrices, the value <code class="reqn">2</code>
indicates an error in SVD of the local response matrix, the value <code class="reqn">3</code> indicates
an error in optimizing the nugget term.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p>Zhang, R., Lin, C. D. and Ranjan, P. (2018) <em>Local Gaussian
Process Model for Large-scale Dynamic Computer Experiments</em>,
Journal of Computational and Graphical Statistics, <br /> DOI:
10.1080/10618600.2018.1473778.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knnsvdGP">knnsvdGP</a></code>, <code><a href="#topic+svdGP">svdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("lhs")
forretal &lt;- function(x,t,shift=1)
{
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
}
timepoints &lt;- seq(0,1,len=200)
design &lt;- lhs::randomLHS(100,3)
test &lt;- lhs::randomLHS(20,3)

## evaluate the response matrix on the design matrix
resp &lt;- apply(design,1,forretal,timepoints)

n0 &lt;- 14
nn &lt;- 15
gs &lt;- sqrt(.Machine$double.eps)

## lasvdGP with mutiple (5) start points for GP model estimation,
## It use the R package "parallel" for parallelization
retlamsp &lt;- lasvdGP(design,resp,test,n0,nn,frac=.95,gstart=gs,
                    centralize=TRUE,nstarts=5,nthread=2,clutype="PSOCK")

## lasvdGP with single start point for GP model estimation,
## It does not use parallel computation
retlass &lt;- lasvdGP(design,resp,test,n0,nn,frac=.95,gstart=gs,
                   centralize=TRUE,nstarts=1,nthread=1)

</code></pre>

<hr>
<h2 id='saEI'>Saddlepoint Approximate Expected Improvement Criterion for
the Sequential Design for Inverse Problems</h2><span id='topic+saEI'></span>

<h3>Description</h3>

<p>This function performs the sequential design procedure for
the inverse problem. It starts from an initial design set <code>xi</code>
and selects the follow-up design points from the candidate set
<code>candei</code> as per the expected improvement (EI) criterion which is
numerically approximated by the saddlepoint approximation technique in
Huang and Oosterlee (2011). The surrogate is refitted using the
augmented data via <code>svdGP</code>. After the selection of <code>nadd</code>
follow-up points, the solution of the inverse problem is estimated
either by the <code>ESL2D</code> approach or by the <code>SL2D</code>
approach. Details are provided in Chapter 4 of Zhang (2018).  </p>


<h3>Usage</h3>

<pre><code class='language-R'>saEI(xi,yi,yobs,nadd,candei,candest,func,...,
     mtype=c("zmean","cmean","lmean"),
     estsol=c("ESL2D","SL2D"),
     frac=.95, nstarts=5, gstart=0.0001,
     nthread=1, clutype="PSOCK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saEI_+3A_xi">xi</code></td>
<td>
<p> An <code>N0</code> by <code class="reqn">d</code> matrix of <code>N0</code> initial design
points.  </p>
</td></tr>
<tr><td><code id="saEI_+3A_yi">yi</code></td>
<td>
<p> An <code class="reqn">L</code> by <code>N0</code> response matrix of <code>xi</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code>N0</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="saEI_+3A_yobs">yobs</code></td>
<td>
<p> A vector of length <code class="reqn">L</code> of the time-series valued
field observations or the target response.</p>
</td></tr>
<tr><td><code id="saEI_+3A_nadd">nadd</code></td>
<td>
<p> The number of the follow-up design points selected by
this function.</p>
</td></tr>
<tr><td><code id="saEI_+3A_candei">candei</code></td>
<td>
<p>An <code>M1</code> by <code class="reqn">d</code> matrix of <code>M1</code> candidate points
on which the follow-up design points are selected.</p>
</td></tr>
<tr><td><code id="saEI_+3A_candest">candest</code></td>
<td>
<p> An <code>M2</code> by <code class="reqn">d</code> matrix of <code>M2</code> candidate points
on which the (final) estimated solution to the inverse problem is extracted.
</p>
</td></tr>
<tr><td><code id="saEI_+3A_func">func</code></td>
<td>
<p> An R function of the dynamic computer simulator. The
first argument of <code>func</code> should be a vector of <code class="reqn">d</code>-dimensional
inputs. The simulator <code>func</code> should return a vector of length
<code class="reqn">L</code> as the output.</p>
</td></tr>
<tr><td><code id="saEI_+3A_...">...</code></td>
<td>
<p> The remaining arguments of the simulator <code>func</code>.</p>
</td></tr>
<tr><td><code id="saEI_+3A_mtype">mtype</code></td>
<td>
<p> The type of mean functions for the GP models. The choice
&quot;zmean&quot; denotes zero-mean, &quot;cmean&quot; indicates constant-mean, &quot;lmean&quot; indicates
linear-mean. The default choice is &quot;zmean&quot;.</p>
</td></tr>
<tr><td><code id="saEI_+3A_estsol">estsol</code></td>
<td>
<p> The method for estimating the final solution to the inverse
problem after all follow-up design points are included, &quot;ESL2D&quot;
denotes the ESL2D approach, &quot;SL2D&quot; denotes the SL2D approach. The
default choice is &quot;ESL2D&quot;.</p>
</td></tr>
<tr><td><code id="saEI_+3A_frac">frac</code></td>
<td>
<p> The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="saEI_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="saEI_+3A_gstart">gstart</code></td>
<td>
<p> The starting number and upper bound for estimating the
nugget parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the
nugget parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>,
since <code>sqrt(.Machine$double.eps)</code> is the lower bound of the
nugget term. The default value is 0.0001.  </p>
</td></tr>
<tr><td><code id="saEI_+3A_nthread">nthread</code></td>
<td>

<p>The number of threads (processes) used in parallel execution of this
function. <code>nthread=1</code> implies no parallelization. The default
value is 1.
</p>
</td></tr>
<tr><td><code id="saEI_+3A_clutype">clutype</code></td>
<td>

<p>The type of cluster in the R package &quot;parallel&quot; to perform
parallelization. The default value is &quot;PSOCK&quot;. Required only if
<code>nthread</code>&gt;1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>xx</code></td>
<td>
<p>The design set selected by the sequential design approach,
which includes both the initial and the follow-up design points.</p>
</td></tr>
<tr><td><code>yy</code></td>
<td>
<p>The response matrix collected on the design set <code>xx</code>.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>The estimated solution to the inverse problem obtained on the
candidate set <code>candest</code> from the final fitted surrogate.</p>
</td></tr>
<tr><td><code>maxei</code></td>
<td>
<p> A vector of length <code>nadd</code>, it collects the maximum
value of the EI criterion in each iteration of the sequential design
approach.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p>Huang, X. and Oosterlee, C. W. (2011) <em>Saddlepoint approximations
for expectations and an application to CDO pricing</em>, SIAM Journal on
Financial Mathematics, 2(1) 692-714.
</p>
<p>Zhang, R. (2018) <em>Modeling and Analysis of Dynamic Computer Experiments</em>,
PhD thesis, Queen's University, ON, Canada.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ESL2D">ESL2D</a></code>, <code><a href="#topic+SL2D">SL2D</a></code>, <code><a href="#topic+svdGP">svdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("lhs")
  forretal &lt;- function(x,t,shift=1)
  {
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
  }
  timepoints &lt;- seq(0,1,len=200)
  xi &lt;- lhs::randomLHS(30,3)
  candei &lt;- lhs::randomLHS(500,3)
  candest &lt;- lhs::randomLHS(500,3)
  candest &lt;- rbind(candest, xi)

  ## evaluate the response matrix on the design matrix
  yi &lt;- apply(xi,1,forretal,timepoints)
  x0 &lt;- runif(3)
  y0 &lt;- forretal(x0,timepoints)
  yobs &lt;- y0+rnorm(200,0,sd(y0)/sqrt(50))
  ret &lt;- saEI(xi,yi,yobs,1,candei,candest,forretal,timepoints,
              nstarts=1, nthread=1)
  yhat &lt;- forretal(ret$xhat,timepoints)

  ## draw a figure to illustrate
  plot(y0,ylim=c(min(y0,yhat),max(y0,yhat)))
  lines(yhat,col="red")
</code></pre>

<hr>
<h2 id='SL2D'>
Squared <code class="reqn">L_{2}</code> Discrepancy Approach for Estimating the
Solution to the Inverse Problem
</h2><span id='topic+SL2D'></span>

<h3>Description</h3>

<p>This function fits an SVD-based GP model on the
training dataset <code>design</code> and response matrix <code>resp</code>, and
minimizes the squared <code class="reqn">L_{2}</code> discrepancy between the target
response and the predicted mean of the SVD-based GP model on the
test set <code>candidate</code> to estimate the solution to the inverse
problem. It is a naive approach for estimating the solution provided
in Chapter 4 of Zhang (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL2D(design,resp,yobs,candidate,frac=.95,nstarts=5,
     mtype=c("zmean","cmean","lmean"),
     gstart=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SL2D_+3A_design">design</code></td>
<td>
<p> An <code class="reqn">N</code> by <code class="reqn">d</code> matrix of <code class="reqn">N</code>
training/design inputs.</p>
</td></tr>
<tr><td><code id="SL2D_+3A_resp">resp</code></td>
<td>
<p> An <code class="reqn">L</code> by <code class="reqn">N</code> response matrix of <code>design</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code class="reqn">N</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="SL2D_+3A_yobs">yobs</code></td>
<td>
<p> A vector of length <code class="reqn">L</code> of the time-series valued
field observations or the target response.
</p>
</td></tr>
<tr><td><code id="SL2D_+3A_candidate">candidate</code></td>
<td>
<p> An <code class="reqn">M</code> by <code class="reqn">d</code> matrix of <code class="reqn">M</code> candidate points
on which the estimated solution to the inverse problem is extracted.
</p>
</td></tr>
<tr><td><code id="SL2D_+3A_frac">frac</code></td>
<td>

<p>The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="SL2D_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="SL2D_+3A_mtype">mtype</code></td>
<td>
<p> The type of mean functions for the GP models. The choice
&quot;zmean&quot; denotes zero-mean, &quot;cmean&quot; indicates constant-mean, &quot;lmean&quot; indicates
linear-mean. The default choice is &quot;zmean&quot;.
</p>
</td></tr>
<tr><td><code id="SL2D_+3A_gstart">gstart</code></td>
<td>
<p> The starting number and upper bound for estimating the
nugget parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the
nugget parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>,
since <code>sqrt(.Machine$double.eps)</code> is the lower bound of the
nugget term. The default value is 0.0001.</p>
</td></tr> </table>


<h3>Value</h3>

<table>
<tr><td><code>xhat</code></td>
<td>
<p>The estimated solution to the inverse problem obtained from the
candidate set <code>candidate</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>References</h3>

<p> Zhang, R. (2018) <em>Modeling and Analysis of Dynamic Computer Experiments</em>,
PhD thesis, Queen's University, ON, Canada.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ESL2D">ESL2D</a></code>, <code><a href="#topic+saEI">saEI</a></code>, <code><a href="#topic+svdGP">svdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("lhs")
  forretal &lt;- function(x,t,shift=1)
  {
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
  }
  timepoints &lt;- seq(0,1,len=200)
  design &lt;- lhs::randomLHS(30,3)
  candidate &lt;- lhs::randomLHS(500,3)
  candidate &lt;- rbind(candidate,design)

  ## evaluate the response matrix on the design matrix
  resp &lt;- apply(design,1,forretal,timepoints)
  x0 &lt;- runif(3)
  y0 &lt;- forretal(x0,timepoints)
  yobs &lt;- y0+rnorm(200,0,sd(y0)/sqrt(50))
  xhat &lt;- SL2D(design,resp,yobs,candidate,nstarts=1)
  yhat &lt;- forretal(xhat,timepoints)

  ## draw a figure to illustrate
  plot(y0,ylim=c(min(y0,yhat),max(y0,yhat)))
  lines(yhat,col="red")
</code></pre>

<hr>
<h2 id='svdGP'>
Full SVD-Based GP Models</h2><span id='topic+svdGP'></span>

<h3>Description</h3>

<p>This function fits a full SVD-based GP model with test set <code>X0</code>,
design set <code>design</code> and response matrix <code>resp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdGP(design,resp,X0=design,nstarts=5,gstart=0.0001,
      frac=.95,centralize=FALSE,nthread=1,clutype="PSOCK")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svdGP_+3A_design">design</code></td>
<td>
<p> An <code class="reqn">N</code> by <code class="reqn">d</code> matrix of <code class="reqn">N</code> training/design
inputs.</p>
</td></tr>
<tr><td><code id="svdGP_+3A_resp">resp</code></td>
<td>
<p> An <code class="reqn">L</code> by <code class="reqn">N</code> response matrix of <code>design</code>,
where <code class="reqn">L</code> is the length of the time series outputs, <code class="reqn">N</code> is
the number of design points.</p>
</td></tr>
<tr><td><code id="svdGP_+3A_x0">X0</code></td>
<td>
<p> An <code class="reqn">M</code> by <code class="reqn">d</code> matrix of <code class="reqn">M</code> test inputs. The
default value of <code>X0</code> is <code>design</code>.</p>
</td></tr>
<tr><td><code id="svdGP_+3A_nstarts">nstarts</code></td>
<td>

<p>The number of starting points used in the numerical maximization of
the posterior density function. The larger <code>nstarts</code> will
typically lead to more accurate prediction but longer computational
time. The default value is 5.
</p>
</td></tr>
<tr><td><code id="svdGP_+3A_gstart">gstart</code></td>
<td>

<p>The starting number and upper bound for estimating the nugget
parameter. If <code>gstart = sqrt(.Machine$double.eps)</code>, the nugget
parameter will be fixed at <code>sqrt(.Machine$double.eps)</code>, since
<code>sqrt(.Machine$double.eps)</code> is the lower bound of the nugget
term. The default value is 0.0001.
</p>
</td></tr>
<tr><td><code id="svdGP_+3A_frac">frac</code></td>
<td>

<p>The threshold in the cumulative percentage criterion to select the
number of SVD bases. The default value is 0.95.
</p>
</td></tr>
<tr><td><code id="svdGP_+3A_centralize">centralize</code></td>
<td>

<p>If <code>centralize=TRUE</code> the response matrix will be centralized
(subtract the mean) before the start of the algorithm. The mean will
be added to the predictive mean at the finish of the algorithm. The
default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="svdGP_+3A_nthread">nthread</code></td>
<td>

<p>The number of threads (processes) used in parallel execution of this
function. <code>nthread=1</code> implies no parallelization. The default
value is 1.
</p>
</td></tr>
<tr><td><code id="svdGP_+3A_clutype">clutype</code></td>
<td>

<p>The type of cluster in the R package &quot;parallel&quot; to perform
parallelization. The default value is &quot;PSOCK&quot;. Required only if
<code>nthread</code>&gt;1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pmean</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted mean for the response at
the test set <code>X0</code>.
</p>
</td></tr>
<tr><td><code>ps2</code></td>
<td>

<p>An <code class="reqn">L</code> by <code class="reqn">M</code> matrix of posterior predicted variance for the response at
the test set <code>X0</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ru Zhang <a href="mailto:heavenmarshal@gmail.com">heavenmarshal@gmail.com</a>,
</p>
<p>C. Devon Lin <a href="mailto:devon.lin@queensu.ca">devon.lin@queensu.ca</a>,
</p>
<p>Pritam Ranjan <a href="mailto:pritamr@iimidr.ac.in">pritamr@iimidr.ac.in</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+knnsvdGP">knnsvdGP</a></code>, <code><a href="#topic+lasvdGP">lasvdGP</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("lhs")
forretal &lt;- function(x,t,shift=1)
{
    par1 &lt;- x[1]*6+4
    par2 &lt;- x[2]*16+4
    par3 &lt;- x[3]*6+1
    t &lt;- t+shift
    y &lt;- (par1*t-2)^2*sin(par2*t-par3)
}
timepoints &lt;- seq(0,1,len=200)
design &lt;- lhs::randomLHS(50,3)
test &lt;- lhs::randomLHS(50,3)

## evaluate the response matrix on the design matrix
resp &lt;- apply(design,1,forretal,timepoints)

## fit full SVD-based GP model
ret &lt;- svdGP(design,resp,test,frac=.95,nstarts=1,
             centralize=TRUE,nthread=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
