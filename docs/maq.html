<!DOCTYPE html><html><head><title>Help for package maq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {maq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#average_gain'><p>Get estimate of gain given a spend level.</p></a></li>
<li><a href='#difference_gain'><p>Get estimate of difference in gain given a spend level with paired standard errors.</p></a></li>
<li><a href='#get_ipw_scores'><p>Construct evaluation scores via inverse-propensity weighting.</p></a></li>
<li><a href='#integrated_difference'><p>Get estimate of the area between two Qini curves with paired standard errors.</p></a></li>
<li><a href='#maq'><p>Fit a Multi-Armed Qini.</p></a></li>
<li><a href='#plot.maq'><p>Plot the estimated Qini curve.</p></a></li>
<li><a href='#predict.maq'><p>Predict treatment allocation.</p></a></li>
<li><a href='#print.maq'><p>Print a maq object.</p></a></li>
<li><a href='#summary.maq'><p>Qini curve summary.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multi-Armed Qini</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluate treatment rules for costly and mutually exclusive treatment arms with Qini curves as proposed in Sverdrup, Wu, Athey, and Wager (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2306.11979">doi:10.48550/arXiv.2306.11979</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grf (&ge; 2.3.0), testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/grf-labs/maq">https://github.com/grf-labs/maq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/grf-labs/maq/issues">https://github.com/grf-labs/maq/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-08 02:27:05 UTC; erikcs</td>
</tr>
<tr>
<td>Author:</td>
<td>Erik Sverdrup [aut, cre],
  Han Wu [aut],
  Susan Athey [aut],
  Stefan Wager [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Erik Sverdrup &lt;erikcs@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-08 03:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='average_gain'>Get estimate of gain given a spend level.</h2><span id='topic+average_gain'></span>

<h3>Description</h3>

<p>Get an estimate of Q(B).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_gain(object, spend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_gain_+3A_object">object</code></td>
<td>
<p>A maq object.</p>
</td></tr>
<tr><td><code id="average_gain_+3A_spend">spend</code></td>
<td>
<p>The spend level B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of Q(B) along with standard errors.
</p>

<hr>
<h2 id='difference_gain'>Get estimate of difference in gain given a spend level with paired standard errors.</h2><span id='topic+difference_gain'></span>

<h3>Description</h3>

<p>Given two Qini curves, <code class="reqn">Q_a</code> and <code class="reqn">Q_b</code>, get an estimate of the difference
<code class="reqn">Q_a(B) - Q_b(B)</code>, at a spend level B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference_gain(object.lhs, object.rhs, spend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_gain_+3A_object.lhs">object.lhs</code></td>
<td>
<p>A maq object <code class="reqn">Q_a</code> to subtract from.</p>
</td></tr>
<tr><td><code id="difference_gain_+3A_object.rhs">object.rhs</code></td>
<td>
<p>A maq object <code class="reqn">Q_b</code> to subtract with.</p>
</td></tr>
<tr><td><code id="difference_gain_+3A_spend">spend</code></td>
<td>
<p>The spend level B.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of difference in gain along with standard errors.
</p>

<hr>
<h2 id='get_ipw_scores'>Construct evaluation scores via inverse-propensity weighting.</h2><span id='topic+get_ipw_scores'></span>

<h3>Description</h3>

<p>A simple convenience function to
construct an evaluation score matrix via IPW, where entry (i, k) equals
</p>

<ul>
<li> <p><code class="reqn">\frac{\mathbf{1}(W_i=k)Y_i}{P[W_i=k | X_i]} - \frac{\mathbf{1}(W_i=0)Y_i}{P[W_i=0 | X_i]}</code>,
</p>
</li></ul>

<p>where <code class="reqn">W_i</code> is the treatment assignment of unit i and <code class="reqn">Y_i</code> the observed outcome.
<code class="reqn">k = 1 \ldots K</code> are one of K treatment arms and k = 0 is the control arm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ipw_scores(Y, W, W.hat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ipw_scores_+3A_y">Y</code></td>
<td>
<p>The observed outcome.</p>
</td></tr>
<tr><td><code id="get_ipw_scores_+3A_w">W</code></td>
<td>
<p>The observed treatment assignment (must be a factor vector,
where the first factor level is the control arm).</p>
</td></tr>
<tr><td><code id="get_ipw_scores_+3A_w.hat">W.hat</code></td>
<td>
<p>Optional treatment propensities. If these vary by unit and arm, then
this should be a matrix with the treatment assignment
probability of units to arms, with columns corresponding to the levels of <code>W</code>.
If these only vary by arm, a vector can also be supplied.
If W.hat is NULL (Default), then the assignment probabilities are assumed to be uniform
and the same for each arm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \cdot K</code> matrix of evaluation scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Draw some equally likely samples from control arm A and treatment arms B and C.
n &lt;- 5000
W &lt;- as.factor(sample(c("A", "B", "C"), n, replace = TRUE))
Y &lt;- 42 * (W == "B") - 42 * (W == "C") + rnorm(n)
IPW.scores &lt;- get_ipw_scores(Y, W)
# An estimate of E[Y(B) - Y(A)] and E[Y(C) - Y(A)]. Should be approx 42 and -42.
colMeans(IPW.scores)

# Draw non-uniformly from the different arms.
W.hat &lt;- c(0.2, 0.2, 0.6)
W &lt;- as.factor(sample(c("A", "B", "C"), n, replace = TRUE, prob = W.hat))
Y &lt;- 42 * (W == "B") - 42 * (W == "C") + rnorm(n)
IPW.scores &lt;- get_ipw_scores(Y, W, W.hat = W.hat)
# Should still be approx 42 and -42.
colMeans(IPW.scores)


</code></pre>

<hr>
<h2 id='integrated_difference'>Get estimate of the area between two Qini curves with paired standard errors.</h2><span id='topic+integrated_difference'></span>

<h3>Description</h3>

<p>Given two Qini curves, <code class="reqn">Q_a</code> and <code class="reqn">Q_b</code>, and a maximum spend <code class="reqn">\bar B</code>,
get an estimate of the integrated difference
<code class="reqn">\int_{0}^{\bar B} (Q_a(B) - Q_b(B))dB</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrated_difference(object.lhs, object.rhs, spend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrated_difference_+3A_object.lhs">object.lhs</code></td>
<td>
<p>A maq object <code class="reqn">Q_a</code> to subtract from.</p>
</td></tr>
<tr><td><code id="integrated_difference_+3A_object.rhs">object.rhs</code></td>
<td>
<p>A maq object <code class="reqn">Q_b</code> to subtract with.</p>
</td></tr>
<tr><td><code id="integrated_difference_+3A_spend">spend</code></td>
<td>
<p>The spend level <code class="reqn">\bar B</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate of the area between the two curves along with standard errors.
</p>

<hr>
<h2 id='maq'>Fit a Multi-Armed Qini.</h2><span id='topic+maq'></span>

<h3>Description</h3>

<p>Consider <code class="reqn">k = 1, \ldots, K</code> mutually exclusive and costly treatment arms,
where k = 0 is a zero-cost control arm. Let <code class="reqn">\hat \tau(\cdot)</code> be an <em>estimated</em>
multi-armed treatment effect function and <code class="reqn">C(\cdot)</code> a known cost function
(where the k-th element of these vectors measures <code class="reqn">E[Y_i(k) - Y_i(0) | X_i]</code> and
<code class="reqn">E[C_i(k) - C_i(0) | X_i]</code> where <code class="reqn">Y_i(k)</code> are potential outcomes corresponding
to the k-th treatment state, <code class="reqn">C_i(k)</code> the cost of assigning unit i the k-th arm,
and <code class="reqn">X_i</code> a set of covariates). We provide estimates of the Qini curve:
</p>

<ul>
<li> <p><code class="reqn">Q(B) = E[\langle \pi_B(X_i), \tau(X_i)\rangle], B \in (0, B_{max}],</code>
</p>
</li></ul>

<p>which is the expected gain, at any budget constraint B, when assigning treatment in accordance
to <code class="reqn">\pi_B</code>, the treatment policy that optimally selects
which arm to assign to which unit while incurring a cost less than or equal to B in expectation
when using the given functions <code class="reqn">\hat \tau(\cdot)</code> and <code class="reqn">C(\cdot)</code>:
</p>

<ul>
<li> <p><code class="reqn">\pi_B = argmax_{\pi} \left\{E[\langle \pi(X_i), \hat \tau(X_i) \rangle]: E[\langle \pi(X_i), C(X_i) \rangle] \leq B \right\}.</code>
</p>
</li></ul>

<p>At a budget B, the k-th element of <code class="reqn">\pi_B(X_i)</code> is 1 if assigning the k-th arm
to the i-th unit is optimal, and 0 otherwise.
The Qini curve can be used to quantify the value, as measured by the expected gain over
assigning each unit the control arm when using the estimated function
<code class="reqn">\hat \tau(\cdot)</code> with cost structure <code class="reqn">C(\cdot)</code> to allocate treatment,
as we vary the available budget <code class="reqn">B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maq(
  reward,
  cost,
  DR.scores,
  budget = NULL,
  target.with.covariates = TRUE,
  R = 0,
  paired.inference = TRUE,
  sample.weights = NULL,
  clusters = NULL,
  tie.breaker = NULL,
  num.threads = NULL,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maq_+3A_reward">reward</code></td>
<td>
<p>A <code class="reqn">n \cdot K</code> matrix of test set treatment effect estimates <code class="reqn">\hat \tau(X_i)</code>.
(Note: the estimated function <code class="reqn">\hat \tau(\cdot)</code> should be constructed on a held-out training set)</p>
</td></tr>
<tr><td><code id="maq_+3A_cost">cost</code></td>
<td>
<p>A <code class="reqn">n \cdot K</code> matrix of test set costs <code class="reqn">C(X_i) &gt; 0</code>, where entry (i, k)
measures the cost of assigning the i-th unit the k-th treatment arm.
If the costs does not vary by unit, only by arm, this can also be a K-length vector.
(Note: these costs need not be denominated on the same scale as the treatment effect estimates).</p>
</td></tr>
<tr><td><code id="maq_+3A_dr.scores">DR.scores</code></td>
<td>
<p>An <code class="reqn">n \cdot K</code> matrix of test set evaluation scores used to form an estimate of
Q(B). With known treatment propensities <code class="reqn">P[W_i|X_i]</code>,
these scores can be constructed via inverse-propensity weighting, i.e, with entry (i, k) equal to
<code class="reqn">\frac{\mathbf{1}(W_i=k)Y_i}{P[W_i=k | X_i]} - \frac{\mathbf{1}(W_i=0)Y_i}{P[W_i=0 | X_i]}</code>.
In observational settings where <code class="reqn">P[W_i|X_i]</code> has to be estimated, then an alternative is to
construct these scores via augmented inverse-propensity weighting (AIPW) - yielding a doubly
robust estimate of the Qini curve (for details, see the paper).</p>
</td></tr>
<tr><td><code id="maq_+3A_budget">budget</code></td>
<td>
<p>The maximum spend per unit, <code class="reqn">B_{max}</code>, to fit the Qini curve on.
Setting this to NULL (Default), will fit the path up to a maximum spend per unit
where each unit that is expected to benefit (that is, <code class="reqn">\hat \tau_k(X_i)&gt;0</code>) is treated.</p>
</td></tr>
<tr><td><code id="maq_+3A_target.with.covariates">target.with.covariates</code></td>
<td>
<p>If TRUE (Default), then the policy <code class="reqn">\pi_B</code> takes covariates
<code class="reqn">X_i</code> into account. If FALSE, then the policy only takes the average reward
<code class="reqn">\bar \tau = E[\hat \tau(X_i)]</code> and average costs <code class="reqn">\bar C = E[C(X_i)]</code> into account when
allocating treatment. This can be used to construct a baseline Qini curve to assess the value
of treatment targeting based on covariates.</p>
</td></tr>
<tr><td><code id="maq_+3A_r">R</code></td>
<td>
<p>Number of bootstrap replicates for computing standard errors. Default is 0
(only point estimates are computed).</p>
</td></tr>
<tr><td><code id="maq_+3A_paired.inference">paired.inference</code></td>
<td>
<p>Whether to allow for paired tests with other Qini curves fit on the same
evaluation data. If TRUE (Default) then the path of bootstrap replicates are stored in order to perform
paired comparisons that account for the correlation between curves evaluated on the same data. This
takes memory on the order of <code class="reqn">O(RnK)</code> and requires the comparison objects to be fit with
the same seed and R values as well as the same number of samples.</p>
</td></tr>
<tr><td><code id="maq_+3A_sample.weights">sample.weights</code></td>
<td>
<p>Weights given to an observation in estimation.
If NULL, each observation is given the same weight. Default is NULL.</p>
</td></tr>
<tr><td><code id="maq_+3A_clusters">clusters</code></td>
<td>
<p>Vector of integers or factors specifying which cluster each observation corresponds to,
which are used to construct clustered standard errors.
Default is NULL (ignored).</p>
</td></tr>
<tr><td><code id="maq_+3A_tie.breaker">tie.breaker</code></td>
<td>
<p>An optional permutation of the integers 1 to n used to
break potential ties in the optimal treatment allocation
(only relevant if the predictions <code class="reqn">\hat \tau(X)</code> are not continuous).
If NULL, the ties are broken by the lowest sample id (i.e. the sample appearing first in the data).
Default is NULL.</p>
</td></tr>
<tr><td><code id="maq_+3A_num.threads">num.threads</code></td>
<td>
<p>Number of threads used in bootstrap replicates. By default, the number of threads
is set to the maximum hardware concurrency.</p>
</td></tr>
<tr><td><code id="maq_+3A_seed">seed</code></td>
<td>
<p>The seed of the C++ random number generator. Default is 42.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fit maq object.
</p>


<h3>References</h3>

<p>Sverdrup, Erik, Han Wu, Susan Athey, and Stefan Wager.
&quot;Qini Curves for Multi-Armed Treatment Rules&quot;.
arXiv preprint arXiv:2306.11979, 2023.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("grf", quietly = TRUE)) {
# Fit a CATE estimator on a training sample.
n &lt;- 3000
p &lt;- 5
X &lt;- matrix(runif(n * p), n, p)
W &lt;- as.factor(sample(c("0", "1", "2"), n, replace = TRUE))
Y &lt;- X[, 1] + X[, 2] * (W == "1") + 1.5 * X[, 3] * (W == "2") + rnorm(n)
train &lt;- sample(1:n, n/2)

tau.forest &lt;- grf::multi_arm_causal_forest(X[train, ], Y[train], W[train])

# Predict CATEs on held out evaluation data.
test &lt;- -train
tau.hat &lt;- predict(tau.forest, X[test, ], drop = TRUE)$predictions

# Assume costs equal a unit's pre-treatment covariate - the following are a toy example.
cost &lt;- cbind(X[test, 4] / 4, X[test, 5])

# Fit an evaluation forest to compute doubly robust scores on the test set.
eval.forest &lt;- grf::multi_arm_causal_forest(X[test, ], Y[test], W[test])
DR.scores &lt;- grf::get_scores(eval.forest, drop = TRUE)

# Fit a Qini curve on evaluation data, using 200 bootstrap replicates for confidence intervals.
ma.qini &lt;- maq(tau.hat, cost, DR.scores, R = 200)

# Plot the Qini curve.
plot(ma.qini)
legend("topleft", c("All arms", "95% CI"), lty = c(1, 3))

# Get an estimate of gain at a given spend per unit along with standard errors.
average_gain(ma.qini, spend = 0.2)

# Get the treatment allocation matrix at a given spend per unit.
pi.mat &lt;- predict(ma.qini, spend = 0.2)

# If the treatment randomization probabilities are known, then an alternative to
# evaluation via AIPW scores is to use inverse-propensity weighting (IPW).
W.hat &lt;- rep(1/3, 3)
IPW.scores &lt;- get_ipw_scores(Y[test], W[test], W.hat)
mq.ipw &lt;- maq(tau.hat, cost, IPW.scores)

plot(mq.ipw, add = TRUE, col = 2)
legend("topleft", c("All arms", "95% CI", "All arms (IPW)"), col = c(1, 1, 2), lty = c(1, 3, 1))

# Estimate some baseline policies.
# a) A policy that ignores covariates and only takes the average reward/cost into account.
qini.avg &lt;- maq(tau.hat, cost, DR.scores, target.with.covariates = FALSE, R = 200)

# b) A policy that only use arm 1.
qini.arm1 &lt;- maq(tau.hat[, 1], cost[, 1], DR.scores[, 1], R = 200)

# c) A policy that only use arm 2.
qini.arm2 &lt;- maq(tau.hat[, 2], cost[, 2], DR.scores[, 2], R = 200)

plot(ma.qini, ci.args = NULL)
plot(qini.avg, col = 2, add = TRUE, ci.args = NULL)
plot(qini.arm1, col = 3, add = TRUE, ci.args = NULL)
plot(qini.arm2, col = 4, add = TRUE, ci.args = NULL)
legend("topleft", c("All arms (targeting)", "All arms (without targeting)", "Arm 1", "Arm 2"),
       col = 1:4, lty = 1)

# Estimate the value of employing all arms over a random allocation.
difference_gain(ma.qini, qini.avg, spend = 0.2)

# Estimate the value of targeting with both arms as opposed to targeting with only arm 1.
difference_gain(ma.qini, qini.arm1, spend = 0.2)

# Estimate the value of targeting with both arms as opposed to targeting with only arm 2.
difference_gain(ma.qini, qini.arm2, spend = 0.2)

# Compare targeting strategies over a range of budget values by estimating an area between
# two curves up to a given spend point.
integrated_difference(ma.qini, qini.arm1, spend = 0.3)
}


</code></pre>

<hr>
<h2 id='plot.maq'>Plot the estimated Qini curve.</h2><span id='topic+plot.maq'></span>

<h3>Description</h3>

<p>Plot the estimated curve <code class="reqn">Q(B), B \in (0, B_{max}]</code>. If the underlying estimated policy
<code class="reqn">\pi_B</code> entails treating zero units, then this function returns an empty value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maq'
plot(
  x,
  ...,
  add = FALSE,
  horizontal.line = TRUE,
  ci.args = list(),
  grid.step = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.maq_+3A_x">x</code></td>
<td>
<p>A maq object.</p>
</td></tr>
<tr><td><code id="plot.maq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to plot.</p>
</td></tr>
<tr><td><code id="plot.maq_+3A_add">add</code></td>
<td>
<p>Whether to add to an already existing plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.maq_+3A_horizontal.line">horizontal.line</code></td>
<td>
<p>Whether to draw a horizontal line where the Qini curve plateaus.
Only applies if add = TRUE and the maq object is fit with a maximum <code>budget</code> that is sufficient
to treat all units that are expected to benefit.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.maq_+3A_ci.args">ci.args</code></td>
<td>
<p>A list of optional arguments to <code>lines()</code> for drawing 95 % confidence bars.
Set to NULL to ignore CIs.</p>
</td></tr>
<tr><td><code id="plot.maq_+3A_grid.step">grid.step</code></td>
<td>
<p>The spend grid increment size to plot the curve on. Default is
<code>max(floor(length(path.length) / 1000), 1)</code> where path.length is the size of the
grid underlying the estimated Qini curve.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.maq'>Predict treatment allocation.</h2><span id='topic+predict.maq'></span>

<h3>Description</h3>

<p>Get an estimate of the policy <code class="reqn">\pi_B(X_i)</code> at a spend level B.
<code class="reqn">\pi_B(X_i)</code> is a K-dimensional vector where the k-th element is 1 if assigning the k-th
arm to unit i is optimal at a given spend B, and 0 otherwise (with all entries 0 if the
control arm is assigned).
Depending on the value of B, <code class="reqn">\pi_B(X_j)</code> might be fractional for at most one unit j.
There are two such cases - the first one is when there is not sufficient budget left to assign j an
initial arm. The second is if there is not sufficient budget to upgrade unit j from arm k to k'.
In these cases <code class="reqn">\pi_B(X_j)</code> takes on one, or two fractional values, respectively,
representing an assignment probability of a given arm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maq'
predict(object, spend, type = c("matrix", "vector"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.maq_+3A_object">object</code></td>
<td>
<p>A maq object.</p>
</td></tr>
<tr><td><code id="predict.maq_+3A_spend">spend</code></td>
<td>
<p>The spend level B.</p>
</td></tr>
<tr><td><code id="predict.maq_+3A_type">type</code></td>
<td>
<p>If &quot;matrix&quot; (Default), then return a matrix where the i-th entry equals
<code class="reqn">\pi_B(X_i)</code> as described above.
If &quot;vector&quot;, then <code class="reqn">\pi_B(X_i)</code> is instead encoded taking values in the set {0, 1, ..., K}.
If the allocation is fractional at the given B, this option returns the policy corresponding
to the previous/lower value of the spend path, at which point the policy is integer-valued, but
incurs a cost less than B in expectation.</p>
</td></tr>
<tr><td><code id="predict.maq_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with row i equal to <code class="reqn">\pi_B(X_i)</code>. If <code>type = "vector"</code> then an
n-length vector with elements equal to the arm (from 0 to K) that is assigned at the given spend B
(note: if the treatment allocation contains a fractional entry at the given B, then the returned
vector is the policy at the nearest spend B' in the solution path where the allocation is
integer-valued but incurs a cost B' &lt; B).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some toy data and fit a solution path.
n &lt;- 10
K &lt;- 4
reward &lt;- matrix(rnorm(n * K), n, K)
cost &lt;- matrix(runif(n * K), n, K)
DR.scores &lt;- reward + rnorm(n)
path &lt;- maq(reward, cost, DR.scores)

# Get the treatment allocation matrix
pi.mat &lt;- predict(path, 0.1)
pi.mat
# pi.mat might have fractional entries for a single unit but satisfies
# the budget in expectation exactly.
sum(cost * pi.mat) / n

# Get the treatment allocation instead encoded in the set {0, 1, ..., K}.
pi.vec &lt;- predict(path, 0.1, type = "vector")
pi.vec
# If a unit has a fractional entry, then pi.vec will incur a cost slightly
# lower than 0.1.
sum(cost[cbind(1:n, pi.vec)]) / n

# Retrieve the underlying solution path.
data.path &lt;- summary(path)
# If we predict at a spend level on this grid, say entry 5,
# then the policy is integer-valued:
spend &lt;- data.path$spend[5]
predict(path, spend)
predict(path, spend, type = "vector")


</code></pre>

<hr>
<h2 id='print.maq'>Print a maq object.</h2><span id='topic+print.maq'></span>

<h3>Description</h3>

<p>Print a maq object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maq'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.maq_+3A_x">x</code></td>
<td>
<p>A maq object.</p>
</td></tr>
<tr><td><code id="print.maq_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>

<hr>
<h2 id='summary.maq'>Qini curve summary.</h2><span id='topic+summary.maq'></span>

<h3>Description</h3>

<p>Get a data.frame with columns equal to [B, Q(B), std.err(Q(B)), i, k], where
i is the unit and k the treatment arm that is optimal to assign at a spend level B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maq'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.maq_+3A_object">object</code></td>
<td>
<p>A maq object.</p>
</td></tr>
<tr><td><code id="summary.maq_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame making up the elements of the estimated Qini curve.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
