<!DOCTYPE html><html><head><title>Help for package tidyft</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyft}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arrange'><p>Arrange entries in data.frame</p></a></li>
<li><a href='#as_fst'><p>Save a data.frame as a fst table</p></a></li>
<li><a href='#complete'><p>Complete a data frame with missing combinations of data</p></a></li>
<li><a href='#count'><p>Count observations by group</p></a></li>
<li><a href='#cummean'><p>Cumulative mean</p></a></li>
<li><a href='#distinct'><p>Select distinct/unique rows in data.table</p></a></li>
<li><a href='#drop_na'><p>Drop or delete data by rows or columns</p></a></li>
<li><a href='#dummy'><p>Fast creation of dummy variables</p></a></li>
<li><a href='#export_fst'><p>Read and write fst files</p></a></li>
<li><a href='#fill'><p>Fill in missing values with previous or next value</p></a></li>
<li><a href='#filter'><p>Filter entries in data.frame</p></a></li>
<li><a href='#fst'><p>Parse,inspect and extract data.table from fst file</p></a></li>
<li><a href='#group_by'><p>Group by one or more variables</p></a></li>
<li><a href='#inner_join'><p>Join tables</p></a></li>
<li><a href='#lead'><p>Fast lead/lag for vectors</p></a></li>
<li><a href='#longer'><p>Pivot data between long and wide</p></a></li>
<li><a href='#mat_df'><p>Conversion between tidy table and named matrix</p></a></li>
<li><a href='#mutate'><p>Create or transform variables</p></a></li>
<li><a href='#nest'><p>Nest and unnest</p></a></li>
<li><a href='#nth'><p>Extract the nth value from a vector</p></a></li>
<li><a href='#object_size'><p>Nice printing of report the Space Allocated for an Object</p></a></li>
<li><a href='#pull'><p>Pull out a single variable</p></a></li>
<li><a href='#read_csv'><p>Convenient file reader</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relocate'><p>Change column order</p></a></li>
<li><a href='#replace_vars'><p>Fast value replacement in data frame</p></a></li>
<li><a href='#rowwise_mutate'><p>Computation by rows</p></a></li>
<li><a href='#select'><p>Select/rename variables by name</p></a></li>
<li><a href='#separate'><p>Separate a character column into two columns using</p>
a regular expression separator</a></li>
<li><a href='#slice'><p>Subset rows using their positions</p></a></li>
<li><a href='#summarise'><p>Summarise columns to single values</p></a></li>
<li><a href='#sys_time_print'><p>Convenient print of time taken</p></a></li>
<li><a href='#uncount'><p>&quot;Uncount&quot; a data frame</p></a></li>
<li><a href='#unite'><p>Unite multiple columns into one by pasting strings together</p></a></li>
<li><a href='#utf8_encoding'><p>Use UTF-8 for character encoding in a data frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast and Memory Efficient Data Operations in Tidy Syntax</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Tidy syntax for 'data.table', using modification by reference whenever possible.
 This toolkit is designed for big data analysis in high-performance desktop or laptop computers.
 The syntax of the package is similar or identical to 'tidyverse'.
 It is user friendly, memory efficient and time saving. For more information,
 check its ancestor package 'tidyfst'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hope-data-science/tidyft">https://github.com/hope-data-science/tidyft</a>,
<a href="https://hope-data-science.github.io/tidyft/">https://hope-data-science.github.io/tidyft/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hope-data-science/tidyft/issues">https://github.com/hope-data-science/tidyft/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.8), stringr (&ge; 1.4.0), fst (&ge; 0.9.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, profvis, dplyr, dtplyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 14:16:51 UTC; DELL</td>
</tr>
<tr>
<td>Author:</td>
<td>Tian-Yuan Huang <a href="https://orcid.org/0000-0002-3591-4203"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tian-Yuan Huang &lt;huang.tian-yuan@qq.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-08 14:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='arrange'>Arrange entries in data.frame</h2><span id='topic+arrange'></span>

<h3>Description</h3>

<p>Analogous function for <code>arrange</code> in <span class="pkg">dplyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange(.data, ..., cols = NULL, order = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="arrange_+3A_...">...</code></td>
<td>
<p>Arrange by what group? Minus symbol means arrange by
descending order.</p>
</td></tr>
<tr><td><code id="arrange_+3A_cols">cols</code></td>
<td>
<p>For <code>set_arrange</code> only.
A character vector of column names of <code>.data</code> by which to order.
If present, override <code>...</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="arrange_+3A_order">order</code></td>
<td>
<p>For <code>set_arrange</code> only. An integer vector with only possible
values of 1 and -1, corresponding to ascending and descending order.
Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once arranged, the order of entries would be changed forever.
</p>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="data.table.html#topic+setorder">setorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = as.data.table(iris)
a %&gt;% arrange(Sepal.Length)
a
a %&gt;% arrange(cols = c("Sepal.Width","Petal.Length"))
a

</code></pre>

<hr>
<h2 id='as_fst'>Save a data.frame as a fst table</h2><span id='topic+as_fst'></span>

<h3>Description</h3>

<p>This function first export the data.frame to a temporal file,
and then parse it back as a fst table (class name is &quot;fst_table&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fst(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_fst_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fst_table</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  iris %&gt;%
    as_fst() -&gt; iris_fst
  iris_fst

</code></pre>

<hr>
<h2 id='complete'>Complete a data frame with missing combinations of data</h2><span id='topic+complete'></span>

<h3>Description</h3>

<p>Turns implicit missing values into explicit missing values.
Analogous function for <code>complete</code> function in <span class="pkg">tidyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(.data, ..., fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="complete_+3A_...">...</code></td>
<td>
<p>Specification of columns to expand.The selection of columns is
supported by the flexible <code><a href="tidyfst.html#topic+select_dt">select_dt</a></code>.
To find all unique combinations of provided columns, including those not found in the data,
supply each variable as a separate argument. But the two modes (select the
needed columns and fill outside values) could not be mixed,
find more details in examples.</p>
</td></tr>
<tr><td><code id="complete_+3A_fill">fill</code></td>
<td>
<p>Atomic value to fill into the missing cell, default uses <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the provided columns with addtion data are of different length,
all the unique combinations would be returned. This operation should be used
only on unique entries, and it will always returned the unique entries.
</p>
<p>If you supply fill parameter, these values will also replace existing explicit missing values in the data set.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+complete">complete</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)

df %&gt;% complete(item_id,item_name)
df %&gt;% complete(item_id,item_name,fill = 0)
df %&gt;% complete("item")
df %&gt;% complete(item_id=1:3)
df %&gt;% complete(item_id=1:3,group=1:2)
df %&gt;% complete(item_id=1:3,group=1:3,item_name=c("a","b","c"))

</code></pre>

<hr>
<h2 id='count'>Count observations by group</h2><span id='topic+count'></span><span id='topic+add_count'></span>

<h3>Description</h3>

<p>Analogous function for <code>count</code> and <code>add_count</code> in <span class="pkg">dplyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(.data, ..., sort = FALSE, name = "n")

add_count(.data, ..., name = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_.data">.data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>variables to group by.</p>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p>logical. If TRUE result will be sorted in desending order by resulting variable.</p>
</td></tr>
<tr><td><code id="count_+3A_name">name</code></td>
<td>
<p>character. Name of resulting variable. Default uses &quot;n&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = as.data.table(mtcars)
count(a,cyl)
count(a,cyl,sort = TRUE)
a

b = as.data.table(iris)
b %&gt;% add_count(Species,name = "N")
b
</code></pre>

<hr>
<h2 id='cummean'>Cumulative mean</h2><span id='topic+cummean'></span>

<h3>Description</h3>

<p>Returns a vector whose elements are the cumulative mean of the elements of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cummean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cummean_+3A_x">x</code></td>
<td>
<p>a numeric or complex object,
or an object that can be coerced to one of these.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cummean(1:10)

</code></pre>

<hr>
<h2 id='distinct'>Select distinct/unique rows in data.table</h2><span id='topic+distinct'></span>

<h3>Description</h3>

<p>Analogous function for <code>distinct</code> in <span class="pkg">dplyr</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct_+3A_.data">.data</code></td>
<td>
<p>data.table</p>
</td></tr>
<tr><td><code id="distinct_+3A_...">...</code></td>
<td>
<p>Optional variables to use when determining uniqueness.
If there are multiple rows for a given combination of inputs,
only the first row will be preserved.
If omitted, will use all variables.</p>
</td></tr>
<tr><td><code id="distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in data.table. If a combination of ... is not distinct,
this keeps the first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+distinct">distinct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 a = as.data.table(iris)
 b = as.data.table(mtcars)
 a %&gt;% distinct(Species)
 b %&gt;% distinct(cyl,vs,.keep_all = TRUE)


</code></pre>

<hr>
<h2 id='drop_na'>Drop or delete data by rows or columns</h2><span id='topic+drop_na'></span><span id='topic+delete_na'></span>

<h3>Description</h3>

<p><code>drop_na</code> drops entries by specified columns.
<code>delete_na</code> deletes rows or columns with too many NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_na(.data, ...)

delete_na(.data, MARGIN, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="drop_na_+3A_...">...</code></td>
<td>
<p>Colunms to be dropped or deleted.</p>
</td></tr>
<tr><td><code id="drop_na_+3A_margin">MARGIN</code></td>
<td>
<p>1 or 2. 1 for deleting rows, 2 for deleting columns.</p>
</td></tr>
<tr><td><code id="drop_na_+3A_n">n</code></td>
<td>
<p>If number (proportion) of NAs is larger than or equal to &quot;n&quot;,
the columns/rows would be deleted. When smaller than 1, use as proportion.
When larger or equal to 1, use as number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x
x %&gt;% delete_na(2,0.75)

x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x %&gt;% delete_na(2,0.5)

x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x %&gt;% delete_na(2,0.24)

x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x %&gt;% delete_na(2,2)

x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x %&gt;% delete_na(1,0.6)
x = data.table(x = c(1, 2, NA, 3), y = c(NA, NA, 4, 5),z = rep(NA,4))
x %&gt;% delete_na(1,2)


</code></pre>

<hr>
<h2 id='dummy'>Fast creation of dummy variables</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Quickly create dummy (binary) columns from character and factor type columns in the inputted data (and numeric columns if specified.)
This function is useful for statistical analysis when you want binary columns rather than character columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy(.data, ..., longname = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="dummy_+3A_...">...</code></td>
<td>
<p>Columns you want to create dummy variables from.
Very flexible, find in the examples.</p>
</td></tr>
<tr><td><code id="dummy_+3A_longname">longname</code></td>
<td>
<p>logical. Should the output column labeled with the
original column name? Default uses <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no columns provided, will return the original data frame.
</p>
<p>This function is inspired by <span class="pkg">fastDummies</span> package, but provides
simple and precise usage, whereas <code>fastDummies::dummy_cols</code> provides more
features for statistical usage.
</p>


<h3>Value</h3>

<p>data.table
</p>


<h3>See Also</h3>

<p><code><a href="fastDummies.html#topic+dummy_cols">dummy_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris = as.data.table(iris)
iris %&gt;% dummy(Species)
iris %&gt;% dummy(Species,longname = FALSE)

mtcars = as.data.table(mtcars)
mtcars %&gt;% head() %&gt;% dummy(vs,am)
mtcars %&gt;% head() %&gt;% dummy("cyl|gear")

</code></pre>

<hr>
<h2 id='export_fst'>Read and write fst files</h2><span id='topic+export_fst'></span><span id='topic+import_fst'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="fst.html#topic+read_fst">read_fst</a></code> and <code><a href="fst.html#topic+write_fst">write_fst</a></code>
from <span class="pkg">fst</span>, but use a different default. For data import, always return a data.table.
For data export, always compress the data to the smallest size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_fst(x, path, compress = 100, uniform_encoding = TRUE)

import_fst(
  path,
  columns = NULL,
  from = 1,
  to = NULL,
  as.data.table = TRUE,
  old_format = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_fst_+3A_x">x</code></td>
<td>
<p>a data frame to write to disk</p>
</td></tr>
<tr><td><code id="export_fst_+3A_path">path</code></td>
<td>
<p>path to fst file</p>
</td></tr>
<tr><td><code id="export_fst_+3A_compress">compress</code></td>
<td>
<p>value in the range 0 to 100, indicating the amount of compression to use.
Lower values mean larger file sizes. The default compression is set to 50.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_uniform_encoding">uniform_encoding</code></td>
<td>
<p>If 'TRUE', all character vectors will be assumed to have elements with equal encoding.
The encoding (latin1, UTF8 or native) of the first non-NA element will used as encoding for the whole column.
This will be a correct assumption for most use cases.
If 'uniform.encoding' is set to 'FALSE', no such assumption will be made and all elements will be converted
to the same encoding. The latter is a relatively expensive operation and will reduce write performance for
character columns.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_columns">columns</code></td>
<td>
<p>Column names to read. The default is to read all columns.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_from">from</code></td>
<td>
<p>Read data starting from this row number.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_to">to</code></td>
<td>
<p>Read data up until this row number. The default is to read to the last row of the stored dataset.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_as.data.table">as.data.table</code></td>
<td>
<p>If TRUE, the result will be returned as a <code>data.table</code> object. Any keys set on
dataset <code>x</code> before writing will be retained. This allows for storage of sorted datasets. This option
requires <code>data.table</code> package to be installed.</p>
</td></tr>
<tr><td><code id="export_fst_+3A_old_format">old_format</code></td>
<td>
<p>must be FALSE, the old fst file format is deprecated and can only be read and
converted with fst package versions 0.8.0 to 0.8.10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'import_fst' returns a data.table with the selected columns and rows. 'export_fst'
writes 'x' to a 'fst' file and invisibly returns 'x' (so you can use this function in a pipeline).
</p>


<h3>See Also</h3>

<p><code><a href="fst.html#topic+read_fst">read_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

export_fst(iris,"iris_fst_test.fst")
iris_dt = import_fst("iris_fst_test.fst")
iris_dt
unlink("iris_fst_test.fst")


</code></pre>

<hr>
<h2 id='fill'>Fill in missing values with previous or next value</h2><span id='topic+fill'></span><span id='topic+shift_fill'></span>

<h3>Description</h3>

<p>Fills missing values in selected columns using the next or previous entry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(.data, ..., direction = "down")

shift_fill(x, direction = "down")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="fill_+3A_...">...</code></td>
<td>
<p>A selection of columns.</p>
</td></tr>
<tr><td><code id="fill_+3A_direction">direction</code></td>
<td>
<p>Direction in which to fill missing values.
Currently either &quot;down&quot; (the default), &quot;up&quot;.</p>
</td></tr>
<tr><td><code id="fill_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fill</code> is filling data.table's columns,
<code>shift_fill</code> is filling any vectors.
</p>


<h3>Value</h3>

<p>A filled data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.table(Month = 1:12, Year = c(2000, rep(NA, 10),2001))
df
df %&gt;% fill(Year)

df &lt;- data.table(Month = 1:12, Year = c(2000, rep(NA, 10),2001))
df %&gt;% fill(Year,direction = "up")

</code></pre>

<hr>
<h2 id='filter'>Filter entries in data.frame</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>Analogous function for <code>filter</code> in <span class="pkg">dplyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently data.table is not able to delete rows by reference,
</p>


<h3>Value</h3>

<p>A data.table
</p>


<h3>References</h3>

<p><a href="https://github.com/Rdatatable/data.table/issues/635">https://github.com/Rdatatable/data.table/issues/635</a>
</p>
<p><a href="https://stackoverflow.com/questions/10790204/how-to-delete-a-row-by-reference-in-data-table">https://stackoverflow.com/questions/10790204/how-to-delete-a-row-by-reference-in-data-table</a>
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+filter">filter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris = as.data.table(iris)
iris %&gt;% filter(Sepal.Length &gt; 7)
iris %&gt;% filter(Sepal.Length &gt; 7,Sepal.Width &gt; 3)
iris %&gt;% filter(Sepal.Length &gt; 7 &amp; Sepal.Width &gt; 3)
iris %&gt;% filter(Sepal.Length == max(Sepal.Length))
</code></pre>

<hr>
<h2 id='fst'>Parse,inspect and extract data.table from fst file</h2><span id='topic+fst'></span><span id='topic+parse_fst'></span><span id='topic+slice_fst'></span><span id='topic+select_fst'></span><span id='topic+filter_fst'></span><span id='topic+summary_fst'></span>

<h3>Description</h3>

<p>An API for reading fst file as data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_fst(path)

slice_fst(ft, row_no)

select_fst(ft, ...)

filter_fst(ft, ...)

summary_fst(ft)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fst_+3A_path">path</code></td>
<td>
<p>path to fst file</p>
</td></tr>
<tr><td><code id="fst_+3A_ft">ft</code></td>
<td>
<p>An object of class fst_table, returned by <code>parse_fst</code></p>
</td></tr>
<tr><td><code id="fst_+3A_row_no">row_no</code></td>
<td>
<p>An integer vector (Positive)</p>
</td></tr>
<tr><td><code id="fst_+3A_...">...</code></td>
<td>
<p>The filter conditions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary_fst</code> could provide some basic information about
the fst table.
</p>


<h3>Value</h3>

<p><code>parse_fst</code> returns a fst_table class.
</p>
<p><code>select_fst</code> and <code>filter_fst</code> returns a data.table.
</p>


<h3>See Also</h3>

<p><code><a href="fst.html#topic+fst">fst</a></code>, <code><a href="fst.html#topic+metadata_fst">metadata_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # write the file first
  path = tempfile(fileext = ".fst")
  fst::write_fst(iris,path)
  # parse the file but not reading it
  parse_fst(path) -&gt; ft

  ft

  class(ft)
  lapply(ft,class)
  names(ft)
  dim(ft)
  summary_fst(ft)

  # get the data by query
  ft %&gt;% slice_fst(1:3)
  ft %&gt;% slice_fst(c(1,3))

  ft %&gt;% select_fst(Sepal.Length)
  ft %&gt;% select_fst(Sepal.Length,Sepal.Width)
  ft %&gt;% select_fst("Sepal.Length")
  ft %&gt;% select_fst(1:3)
  ft %&gt;% select_fst(1,3)
  ft %&gt;% select_fst("Se")

  # return a warning with message
  
    ft %&gt;% select_fst("nothing")
  

  ft %&gt;% select_fst("Se|Sp")
  ft %&gt;% select_fst(cols = names(iris)[2:3])

  ft %&gt;% filter_fst(Sepal.Width &gt; 3)
  ft %&gt;% filter_fst(Sepal.Length &gt; 6 , Species == "virginica")
  ft %&gt;% filter_fst(Sepal.Length &gt; 6 &amp; Species == "virginica" &amp; Sepal.Width &lt; 3)

</code></pre>

<hr>
<h2 id='group_by'>Group by one or more variables</h2><span id='topic+group_by'></span><span id='topic+group_exe'></span><span id='topic+groups'></span><span id='topic+ungroup'></span>

<h3>Description</h3>

<p>Most data operations are done on groups defined by variables.
<code>group_by</code> will group the data.table by selected variables (setting
them as keys), and arrange them in ascending order.
<code>group_exe</code> could do computations by group, it receives an object
returned by <code>group_by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by(.data, ...)

group_exe(.data, ...)

groups(x)

ungroup(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>For <code>group_by</code>:Variables to group by.
For <code>group_exe</code>:Any data manipulation arguments that
could be implemented on a data.table.</p>
</td></tr>
<tr><td><code id="group_by_+3A_x">x</code></td>
<td>
<p>A data.table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>mutate</code> and <code>summarise</code>, it is recommended to
use the innate &quot;by&quot; parameter, which is faster. Once the data.table is
grouped, the order is changed forever.
</p>
<p><code>groups()</code> could return a character vector of specified groups.
</p>
<p><code>ungroup()</code> would delete the keys in data.table.
</p>


<h3>Value</h3>

<p>A data.table with keys
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a = as.data.table(iris)
a
a %&gt;%
  group_by(Species) %&gt;%
  group_exe(
    head(3)
  )
groups(a)
ungroup(a)
groups(a)
</code></pre>

<hr>
<h2 id='inner_join'>Join tables</h2><span id='topic+inner_join'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+full_join'></span><span id='topic+anti_join'></span><span id='topic+semi_join'></span>

<h3>Description</h3>

<p>The mutating joins add columns from 'y' to 'x',
matching rows based on the keys:
</p>
<p>* 'inner_join()': includes all rows in 'x' and 'y'.
* 'left_join()': includes all rows in 'x'.
* 'right_join()': includes all rows in 'y'.
* 'full_join()': includes all rows in 'x' or 'y'.
</p>
<p>Filtering joins filter rows from 'x' based on the presence or absence
of matches in 'y':
</p>
<p>* 'semi_join()' return all rows from 'x' with a match in 'y'.
* 'anti_join()' return all rows from 'x' without a match in 'y'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join(x, y, by = NULL, on = NULL)

left_join(x, y, by = NULL, on = NULL)

right_join(x, y, by = NULL, on = NULL)

full_join(x, y, by = NULL, on = NULL)

anti_join(x, y, by = NULL, on = NULL)

semi_join(x, y, by = NULL, on = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_join_+3A_x">x</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="inner_join_+3A_y">y</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="inner_join_+3A_by">by</code></td>
<td>
<p>(Optional) A character vector of variables to join by.
</p>
<p>If 'NULL', the default, '*_join()' will perform a natural join, using all
variables in common across 'x' and 'y'. A message lists the variables so that you
can check they're correct; suppress the message by supplying 'by' explicitly.
</p>
<p>To join by different variables on 'x' and 'y', use a named vector.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;)' will match 'x$a' to 'y$b'.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, 'by = c(&quot;a&quot;, &quot;b&quot;)' will match 'x$a' to 'y$a' and 'x$b' to
'y$b'. Use a named vector to match different variables in 'x' and 'y'.
For example, 'by = c(&quot;a&quot; = &quot;b&quot;, &quot;c&quot; = &quot;d&quot;)' will match 'x$a' to 'y$b' and
'x$c' to 'y$d'.</p>
</td></tr>
<tr><td><code id="inner_join_+3A_on">on</code></td>
<td>
<p>(Optional)
Indicate which columns in x should be joined with which columns in y.
Examples included:
1.<code>.by = c("a","b")</code> (this is a must for <code>set_full_join</code>);
2.<code>.by = c(x1="y1", x2="y2")</code>;
3.<code>.by = c("x1==y1", "x2==y2")</code>;
4.<code>.by = c("a", V2="b")</code>;
5.<code>.by = .(a, b)</code>;
6.<code>.by = c("x&gt;=a", "y&lt;=b")</code> or <code>.by = .(x&gt;=a, y&lt;=b)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
workers = fread("
    name company
    Nick Acme
    John Ajax
    Daniela Ajax
")

positions = fread("
    name position
    John designer
    Daniela engineer
    Cathie manager
")

workers %&gt;% inner_join(positions)
workers %&gt;% left_join(positions)
workers %&gt;% right_join(positions)
workers %&gt;% full_join(positions)

# filtering joins
workers %&gt;% anti_join(positions)
workers %&gt;% semi_join(positions)

# To suppress the message, supply 'by' argument
workers %&gt;% left_join(positions, by = "name")

# Use a named 'by' if the join variables have different names
positions2 = setNames(positions, c("worker", "position")) # rename first column in 'positions'
workers %&gt;% inner_join(positions2, by = c("name" = "worker"))

# the syntax of 'on' could be a bit different
workers %&gt;% inner_join(positions2,on = "name==worker")


</code></pre>

<hr>
<h2 id='lead'>Fast lead/lag for vectors</h2><span id='topic+lead'></span><span id='topic+lag'></span>

<h3>Description</h3>

<p>Analogous function for <code>lead</code> and <code>lag</code> in <span class="pkg">dplyr</span> by
wrapping <span class="pkg">data.table</span>'s <code>shift</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lead(x, n = 1L, fill = NA)

lag(x, n = 1L, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lead_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="lead_+3A_n">n</code></td>
<td>
<p>a positive integer of length 1,
giving the number of positions to lead or lag by. Default uses 1</p>
</td></tr>
<tr><td><code id="lead_+3A_fill">fill</code></td>
<td>
<p>Value to use for padding when the window goes beyond the input length.
Default uses <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+lead">lead</a></code>,<code><a href="data.table.html#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lead(1:5)
lag(1:5)
lead(1:5,2)
lead(1:5,n = 2,fill = 0)
</code></pre>

<hr>
<h2 id='longer'>Pivot data between long and wide</h2><span id='topic+longer'></span><span id='topic+wider'></span>

<h3>Description</h3>

<p>Fast table pivoting from long to wide and from wide to long.
These functions are supported by <code>dcast.data.table</code> and <code>melt.data.table</code>
from <span class="pkg">data.table</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longer(.data, ..., name = "name", value = "value", na.rm = FALSE)

wider(.data, ..., name, value = NULL, fun = NULL, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longer_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="longer_+3A_...">...</code></td>
<td>
<p>Columns for unchanged group. Flexible, see examples.</p>
</td></tr>
<tr><td><code id="longer_+3A_name">name</code></td>
<td>
<p>Name for the measured variable names column.</p>
</td></tr>
<tr><td><code id="longer_+3A_value">value</code></td>
<td>
<p>Name for the data values column(s).</p>
</td></tr>
<tr><td><code id="longer_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, <code>NA</code> values will be removed from the molten data.</p>
</td></tr>
<tr><td><code id="longer_+3A_fun">fun</code></td>
<td>
<p>Should the data be aggregated before casting?
Defaults to <code>NULL</code>, which uses <code>length</code> for aggregation.
If a function is provided, with aggregated by this function.</p>
</td></tr>
<tr><td><code id="longer_+3A_fill">fill</code></td>
<td>
<p>Value with which to fill missing cells. Default uses <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyfst.html#topic+longer_dt">longer_dt</a></code>,<code><a href="tidyfst.html#topic+wider_dt">wider_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stocks &lt;- data.table(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

stocks %&gt;% longer(time)
stocks %&gt;% longer(-(2:4)) # same
stocks %&gt;% longer(-"X|Y|Z") # same
long_stocks = longer(stocks,"ti") # same as above except for assignment

long_stocks %&gt;% wider(time,name = "name",value = "value")

# the unchanged group could be missed if all the rest will be used
long_stocks %&gt;% wider(name = "name",value = "value")

</code></pre>

<hr>
<h2 id='mat_df'>Conversion between tidy table and named matrix</h2><span id='topic+mat_df'></span><span id='topic+df_mat'></span>

<h3>Description</h3>

<p>Convenient fucntions to implement conversion between
tidy table and named matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_df(m)

df_mat(df, row, col, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_df_+3A_m">m</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="mat_df_+3A_df">df</code></td>
<td>
<p>A data.frame with at least 3 columns, one for row name,
one for column name, and one for values. The names for column and
row should be unique.</p>
</td></tr>
<tr><td><code id="mat_df_+3A_row">row</code></td>
<td>
<p>Unquoted expression of column name for row</p>
</td></tr>
<tr><td><code id="mat_df_+3A_col">col</code></td>
<td>
<p>Unquoted expression of column name for column</p>
</td></tr>
<tr><td><code id="mat_df_+3A_value">value</code></td>
<td>
<p>Unquoted expression of column name for values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>mat_df</code>, a data.frame.
For <code>df_mat</code>, a named matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm = matrix(c(1:8,NA),ncol = 3,dimnames = list(letters[1:3],LETTERS[1:3]))
mm
tdf = mat_df(mm)
tdf
mat = df_mat(tdf,row,col,value)
setequal(mm,mat)

tdf %&gt;%
  setNames(c("A","B","C")) %&gt;%
  df_mat(A,B,C)

</code></pre>

<hr>
<h2 id='mutate'>Create or transform variables</h2><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+mutate_when'></span><span id='topic+mutate_vars'></span>

<h3>Description</h3>

<p><code>mutate()</code> adds new variables and preserves existing ones;
<code>transmute()</code> adds new variables and drops existing ones.
Both functions preserve the number of rows of the input.
New variables overwrite existing variables of the same name.
</p>
<p><code>mutate_when</code> integrates <code>mutate</code> and <code>case_when</code>
in <span class="pkg">dplyr</span> and make a new tidy verb for data.table. <code>mutate_vars</code> is
a super function to do updates in specific columns according to conditions.
</p>
<p>If you mutate a data.table, it is forever changed.
No copies made, which is efficient, but should be used with caution.
If you still want the keep the original data.table, use
<code><a href="data.table.html#topic+copy">copy</a></code> first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate(.data, ..., by)

transmute(.data, ..., by)

mutate_when(.data, when, ..., by)

mutate_vars(.data, .cols = NULL, .func, ..., by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions</p>
</td></tr>
<tr><td><code id="mutate_+3A_by">by</code></td>
<td>
<p>(Optional) Mutate by what group?</p>
</td></tr>
<tr><td><code id="mutate_+3A_when">when</code></td>
<td>
<p>An object which can be coerced to logical mode</p>
</td></tr>
<tr><td><code id="mutate_+3A_.cols">.cols</code></td>
<td>
<p>Any types that can be accepted by <code><a href="tidyfst.html#topic+select_dt">select_dt</a></code>.</p>
</td></tr>
<tr><td><code id="mutate_+3A_.func">.func</code></td>
<td>
<p>Function to be run within each column, should return a value or
vectors with same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Newly created variables are available immediately
  a = as.data.table(mtcars)
  copy(a) %&gt;% mutate(cyl2 = cyl * 2)
  a

  # change forever
  a %&gt;% mutate(cyl2 = cyl * 2)
  a

  # You can also use mutate() to remove variables and
  # modify existing variables
  a %&gt;% mutate(
    mpg = NULL,
    disp = disp * 0.0163871 # convert to litres
  )

  a %&gt;% transmute(cyl,one = 1)
  a


 iris[3:8,] %&gt;%
   as.data.table() %&gt;%
   mutate_when(Petal.Width == .2,
               one = 1,Sepal.Length=2)

 iris[3:8,] %&gt;%
   as.data.table() %&gt;%
   mutate_vars("Pe",scale)

</code></pre>

<hr>
<h2 id='nest'>Nest and unnest</h2><span id='topic+nest'></span><span id='topic+unnest'></span><span id='topic+squeeze'></span><span id='topic+chop'></span><span id='topic+unchop'></span>

<h3>Description</h3>

<p>Analogous function for <code>nest</code> and <code>unnest</code> in <span class="pkg">tidyr</span>.
<code>unnest</code> will automatically remove other list-columns except for the
target list-columns (which would be unnested later). Also, <code>squeeze</code> is
designed to merge multiple columns into list column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest(.data, ..., mcols = NULL, .name = "ndt")

unnest(.data, ...)

squeeze(.data, ..., .name = "ndt")

chop(.data, ...)

unchop(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_+3A_.data">.data</code></td>
<td>
<p>data.table, nested or unnested</p>
</td></tr>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>The variables for nest group(for <code>nest</code>),
columns to be nested(for <code>squeeze</code> and <code>chop</code>),
or column(s) to be unnested(for <code>unnest</code>).
Could recieve anything that <code><a href="tidyfst.html#topic+select_dt">select_dt</a></code> could receive.</p>
</td></tr>
<tr><td><code id="nest_+3A_mcols">mcols</code></td>
<td>
<p>Name-variable pairs in the list, form like</p>
</td></tr>
<tr><td><code id="nest_+3A_.name">.name</code></td>
<td>
<p>Character. The nested column name. Defaults to &quot;ndt&quot;.
<code>list(petal="^Pe",sepal="^Se")</code>, see example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the <code>nest</code>, the data would be nested to a column named 'ndt',
which is short for nested data.table.
</p>
<p>The <code>squeeze</code> would not remove the originial columns.
</p>
<p>The <code>unchop</code> is the reverse operation of <code>chop</code>.
</p>
<p>These functions are experiencing the experimental stage, especially
the <code>unnest</code>. If they don't work on some circumtances, try <span class="pkg">tidyr</span>
package.
</p>


<h3>Value</h3>

<p>data.table, nested or unnested
</p>


<h3>References</h3>

<p>https://www.r-bloggers.com/much-faster-unnesting-with-data-table/
</p>
<p>https://stackoverflow.com/questions/25430986/create-nested-data-tables-by-collapsing-rows-into-new-data-tables
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+nest">nest</a></code>, <code><a href="tidyr.html#topic+chop">chop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mtcars = as.data.table(mtcars)
iris = as.data.table(iris)

# examples for nest

# nest by which columns?
 mtcars %&gt;% nest(cyl)
 mtcars %&gt;% nest("cyl")
 mtcars %&gt;% nest(cyl,vs)
 mtcars %&gt;% nest(vs:am)
 mtcars %&gt;% nest("cyl|vs")
 mtcars %&gt;% nest(c("cyl","vs"))

# nest two columns directly
iris %&gt;% nest(mcols = list(petal="^Pe",sepal="^Se"))

# nest more flexibly
iris %&gt;% nest(mcols = list(ndt1 = 1:3,
  ndt2 = "Pe",
  ndt3 = Sepal.Length:Sepal.Width))

# examples for unnest
# unnest which column?
 mtcars %&gt;% nest("cyl|vs") %&gt;%
   unnest(ndt)
 mtcars %&gt;% nest("cyl|vs") %&gt;%
   unnest("ndt")

df &lt;- data.table(
  a = list(c("a", "b"), "c"),
  b = list(c(TRUE,TRUE),FALSE),
  c = list(3,c(1,2)),
  d = c(11, 22)
)

df
df %&gt;% unnest(a)
df %&gt;% unnest(2)
df %&gt;% unnest("c")
df %&gt;% unnest(cols = names(df)[3])

# You can unnest multiple columns simultaneously
df %&gt;% unnest(1:3)
df %&gt;% unnest(a,b,c)
df %&gt;% unnest("a|b|c")

# examples for squeeze
# nest which columns?
iris %&gt;% squeeze(1:2)
iris %&gt;% squeeze("Se")
iris %&gt;% squeeze(Sepal.Length:Petal.Width)

# examples for chop
df &lt;- data.table(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
df %&gt;% chop(y,z)
df %&gt;% chop(y,z) %&gt;% unchop(y,z)
</code></pre>

<hr>
<h2 id='nth'>Extract the nth value from a vector</h2><span id='topic+nth'></span>

<h3>Description</h3>

<p>Get the value from a vector with its position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nth(v, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nth_+3A_v">v</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="nth_+3A_n">n</code></td>
<td>
<p>A single integer specifying the position. Default uses <code>1</code>.
Negative integers index from the end
(i.e. -1L will return the last value in the vector).
If a double is supplied, it will be silently truncated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = 1:10
nth(x, 1)
nth(x, 5)
nth(x, -2)

</code></pre>

<hr>
<h2 id='object_size'>Nice printing of report the Space Allocated for an Object</h2><span id='topic+object_size'></span>

<h3>Description</h3>

<p>Provides an estimate of the memory that is being used to store an R object.
A wrapper of 'object.size', but use a nicer printing unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_size(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_size_+3A_object">object</code></td>
<td>
<p>an R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;object_size&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;% object_size()

</code></pre>

<hr>
<h2 id='pull'>Pull out a single variable</h2><span id='topic+pull'></span>

<h3>Description</h3>

<p>Analogous function for <code>pull</code> in <span class="pkg">dplyr</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull(.data, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_+3A_.data">.data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="pull_+3A_col">col</code></td>
<td>
<p>A name of column or index (should be positive).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+pull">pull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;% pull(2)
mtcars %&gt;% pull(cyl)
mtcars %&gt;% pull("cyl")
</code></pre>

<hr>
<h2 id='read_csv'>Convenient file reader</h2><span id='topic+read_csv'></span>

<h3>Description</h3>

<p>A wrapper of <code>fread</code> in <span class="pkg">data.table</span>.
Highlighting the encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csv(path, utf8 = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_csv_+3A_path">path</code></td>
<td>
<p>File name in working directory, path to file.</p>
</td></tr>
<tr><td><code id="read_csv_+3A_utf8">utf8</code></td>
<td>
<p>Should &quot;UTF-8&quot; used as the encoding? (Defaults to <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="read_csv_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code>data.table::fread</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+setDT'></span><span id='topic+data.table'></span><span id='topic+as.data.table'></span><span id='topic+copy'></span><span id='topic+tables'></span><span id='topic+fread'></span><span id='topic+fwrite'></span><span id='topic+rbindlist'></span><span id='topic+fcoalesce'></span><span id='topic+uniqueN'></span><span id='topic+CJ'></span><span id='topic+transpose'></span><span id='topic+setnames'></span><span id='topic+rleid'></span><span id='topic+rleidv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code>, <code><a href="data.table.html#topic+J">CJ</a></code>, <code><a href="data.table.html#topic+copy">copy</a></code>, <code><a href="data.table.html#topic+data.table">data.table</a></code>, <code><a href="data.table.html#topic+coalesce">fcoalesce</a></code>, <code><a href="data.table.html#topic+fread">fread</a></code>, <code><a href="data.table.html#topic+fwrite">fwrite</a></code>, <code><a href="data.table.html#topic+rbindlist">rbindlist</a></code>, <code><a href="data.table.html#topic+rleid">rleid</a></code>, <code><a href="data.table.html#topic+rleid">rleidv</a></code>, <code><a href="data.table.html#topic+setDT">setDT</a></code>, <code><a href="data.table.html#topic+setattr">setnames</a></code>, <code><a href="data.table.html#topic+tables">tables</a></code>, <code><a href="data.table.html#topic+transpose">transpose</a></code>, <code><a href="data.table.html#topic+duplicated">uniqueN</a></code></p>
</dd>
<dt>stringr</dt><dd><p><code><a href="stringr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relocate'>Change column order</h2><span id='topic+relocate'></span>

<h3>Description</h3>

<p>Use 'relocate()' to change column positions,
using the same syntax as 'select()'. Check similar function
as 'relocate()' in <span class="pkg">dplyr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate(.data, ..., how = "first", where = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="relocate_+3A_...">...</code></td>
<td>
<p>Columns to move</p>
</td></tr>
<tr><td><code id="relocate_+3A_how">how</code></td>
<td>
<p>The mode of movement, including &quot;first&quot;,&quot;last&quot;,&quot;after&quot;,&quot;before&quot;.
Default uses &quot;first&quot;.</p>
</td></tr>
<tr><td><code id="relocate_+3A_where">where</code></td>
<td>
<p>Destination of columns selected by <code>...</code>.
Applicable for &quot;after&quot; and &quot;before&quot; mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once you relocate the columns, the order changes forever.
</p>


<h3>Value</h3>

<p>A data.table with rearranged columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
df
df %&gt;% relocate(f)
df %&gt;% relocate(a,how = "last")

df %&gt;% relocate(is.character)
df %&gt;% relocate(is.numeric, how = "last")
df %&gt;% relocate("[aeiou]")

df %&gt;% relocate(a, how = "after",where = f)
df %&gt;% relocate(f, how = "before",where = a)
df %&gt;% relocate(f, how = "before",where = c)
df %&gt;% relocate(f, how = "after",where = c)

df2 &lt;- data.table(a = 1, b = "a", c = 1, d = "a")
df2 %&gt;% relocate(is.numeric,
                    how = "after",
                    where = is.character)
df2 %&gt;% relocate(is.numeric,
                    how="before",
                    where = is.character)
</code></pre>

<hr>
<h2 id='replace_vars'>Fast value replacement in data frame</h2><span id='topic+replace_vars'></span>

<h3>Description</h3>

<p><code>replace_vars</code> could replace any value(s) or values
that match specific patterns to another specific value in a data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_vars(.data, ..., from = is.na, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_vars_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="replace_vars_+3A_...">...</code></td>
<td>
<p>Colunms to be replaced. If not specified, use all columns.</p>
</td></tr>
<tr><td><code id="replace_vars_+3A_from">from</code></td>
<td>
<p>A value, a vector of values or a function returns a logical value.
Defaults to <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="replace_vars_+3A_to">to</code></td>
<td>
<p>A value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>


<h3>See Also</h3>

<p><code><a href="tidyfst.html#topic+replace_dt">replace_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> iris %&gt;% as.data.table() %&gt;%
   mutate(Species = as.character(Species))-&gt; new_iris

 new_iris %&gt;%
   replace_vars(Species, from = "setosa",to = "SS")
 new_iris %&gt;%
   replace_vars(Species,from = c("setosa","virginica"),to = "sv")
 new_iris %&gt;%
   replace_vars(Petal.Width, from = .2,to = 2)
 new_iris %&gt;%
   replace_vars(from = .2,to = NA)
 new_iris %&gt;%
   replace_vars(is.numeric, from = function(x) x &gt; 3, to = 9999 )

</code></pre>

<hr>
<h2 id='rowwise_mutate'>Computation by rows</h2><span id='topic+rowwise_mutate'></span><span id='topic+rowwise_summarise'></span>

<h3>Description</h3>

<p>Compute on a data frame a row-at-a-time.
This is most useful when a vectorised function doesn't exist.
Only mutate and summarise are supported so far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowwise_mutate(.data, ...)

rowwise_summarise(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise_mutate_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="rowwise_mutate_+3A_...">...</code></td>
<td>
<p>Name-value pairs of expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+rowwise">rowwise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># without rowwise
df &lt;- data.table(x = 1:2, y = 3:4, z = 4:5)
df %&gt;% mutate(m = mean(c(x, y, z)))
# with rowwise
df &lt;- data.table(x = 1:2, y = 3:4, z = 4:5)
df %&gt;% rowwise_mutate(m = mean(c(x, y, z)))


# # rowwise is also useful when doing simulations
params = fread(" sim n mean sd
  1  1     1   1
  2  2     2   4
  3  3    -1   2")

params %&gt;%
  rowwise_summarise(sim,z = rnorm(n,mean,sd))

</code></pre>

<hr>
<h2 id='select'>Select/rename variables by name</h2><span id='topic+select'></span><span id='topic+select_vars'></span><span id='topic+select_dt'></span><span id='topic+select_mix'></span><span id='topic+rename'></span>

<h3>Description</h3>

<p>Choose or rename variables from a data.table.
<code>select()</code> keeps only the variables you mention;
<code>rename()</code> keeps all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select(.data, ...)

select_vars(.data, ..., rm.dup = TRUE)

select_dt(.data, ..., cols = NULL, negate = FALSE)

select_mix(.data, ..., rm.dup = TRUE)

rename(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas.
Very flexible, same as <code>tidyfst::select_dt</code> and <code>tidyfst::select_mix</code>.
details find <code><a href="tidyfst.html#topic+select_dt">select_dt</a></code>.</p>
</td></tr>
<tr><td><code id="select_+3A_rm.dup">rm.dup</code></td>
<td>
<p>Should duplicated columns be removed? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="select_+3A_cols">cols</code></td>
<td>
<p>(Optional)A numeric or character vector.</p>
</td></tr>
<tr><td><code id="select_+3A_negate">negate</code></td>
<td>
<p>Applicable when regular expression and &quot;cols&quot; is used.
If <code>TRUE</code>, return the non-matched pattern. Default uses <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No copy is made. Once you select or rename a data.table,
they would be changed forever. <code>select_vars</code> could select across
different data types, names and index. See examples.
</p>
<p><code>select_dt</code> and <code>select_mix</code> is the safe mode of
<code>select</code> and <code>select_vars</code>, they keey the original copy but
are not memory-efficient when dealing with large data sets.
</p>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyfst.html#topic+select_dt">select_dt</a></code>, <code><a href="tidyfst.html#topic+rename_dt">rename_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  a = as.data.table(iris)
  a %&gt;% select(1:3)
  a

  a = as.data.table(iris)
  a %&gt;% select_vars(is.factor,"Se")
  a

  a = as.data.table(iris)
  a %&gt;% select("Se") %&gt;%
    rename(sl = Sepal.Length,
    sw = Sepal.Width)
  a


DT = data.table(a=1:2,b=3:4,c=5:6)
DT
DT %&gt;% rename(B=b)

</code></pre>

<hr>
<h2 id='separate'>Separate a character column into two columns using
a regular expression separator</h2><span id='topic+separate'></span>

<h3>Description</h3>

<p>Given either regular expression,
<code>separate()</code> turns a single character column into two columns.
Analogous to <code>tidyr::separate</code>, but only split into two columns only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate(.data, separated_colname, into, sep = "[^[:alnum:]]+", remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="separate_+3A_separated_colname">separated_colname</code></td>
<td>
<p>Column name, string only.</p>
</td></tr>
<tr><td><code id="separate_+3A_into">into</code></td>
<td>
<p>Character vector of length 2.</p>
</td></tr>
<tr><td><code id="separate_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.</p>
</td></tr>
<tr><td><code id="separate_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+separate">separate</a></code>, <code><a href="tidyfst.html#topic+unite_dt">unite_dt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.table(x = c(NA, "a.b", "a.d", "b.c"))
df %&gt;% separate(x, c("A", "B"))
# equals to
df &lt;- data.table(x = c(NA, "a.b", "a.d", "b.c"))
df %&gt;% separate("x", c("A", "B"))
</code></pre>

<hr>
<h2 id='slice'>Subset rows using their positions</h2><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_max'></span><span id='topic+slice_min'></span><span id='topic+slice_sample'></span>

<h3>Description</h3>

<p>'slice()' lets you index rows by their (integer) locations. It allows you
to select, remove, and duplicate rows. It is accompanied by a number of
helpers for common use cases:
</p>
<p>* 'slice_head()' and 'slice_tail()' select the first or last rows.
* 'slice_sample()' randomly selects rows.
* 'slice_min()' and 'slice_max()' select rows with highest or lowest values
of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(.data, ...)

slice_head(.data, n)

slice_tail(.data, n)

slice_max(.data, order_by, n, with_ties = TRUE)

slice_min(.data, order_by, n, with_ties = TRUE)

slice_sample(.data, n, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.</p>
</td></tr>
<tr><td><code id="slice_+3A_n">n</code></td>
<td>
<p>When larger than or equal to 1, the number of rows.
When between 0 and 1, the proportion of rows to select.</p>
</td></tr>
<tr><td><code id="slice_+3A_order_by">order_by</code></td>
<td>
<p>Variable or function of variables to order by.</p>
</td></tr>
<tr><td><code id="slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, 'TRUE',
may return more rows than you request. Use 'FALSE' to ignore ties,
and return the first 'n' rows.</p>
</td></tr>
<tr><td><code id="slice_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with ('TRUE') or without
('FALSE', the default) replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+slice">slice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = as.data.table(iris)
slice(a,1,2)
slice(a,2:3)
slice_head(a,5)
slice_head(a,0.1)
slice_tail(a,5)
slice_tail(a,0.1)
slice_max(a,Sepal.Length,10)
slice_max(a,Sepal.Length,10,with_ties = FALSE)
slice_min(a,Sepal.Length,10)
slice_min(a,Sepal.Length,10,with_ties = FALSE)
slice_sample(a,10)
slice_sample(a,0.1)

</code></pre>

<hr>
<h2 id='summarise'>Summarise columns to single values</h2><span id='topic+summarise'></span><span id='topic+summarise_when'></span><span id='topic+summarise_vars'></span>

<h3>Description</h3>

<p>Create one or more scalar variables summarizing
the variables of an existing data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise(.data, ..., by = NULL)

summarise_when(.data, when, ..., by = NULL)

summarise_vars(.data, .cols = NULL, .func, ..., by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>List of variables or name-value pairs of summary/modifications
functions for <code>summarise_dt</code>.Additional parameters to be passed to
parameter '.func' in <code>summarise_vars</code>.</p>
</td></tr>
<tr><td><code id="summarise_+3A_by">by</code></td>
<td>
<p>Unquoted name of grouping variable of list of unquoted names of
grouping variables. For details see <a href="data.table.html#topic+data.table">data.table</a></p>
</td></tr>
<tr><td><code id="summarise_+3A_when">when</code></td>
<td>
<p>An object which can be coerced to logical mode</p>
</td></tr>
<tr><td><code id="summarise_+3A_.cols">.cols</code></td>
<td>
<p>Columns to be summarised.</p>
</td></tr>
<tr><td><code id="summarise_+3A_.func">.func</code></td>
<td>
<p>Function to be run within each column, should return a value or vectors with same length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = as.data.table(iris)
a %&gt;% summarise(sum = sum(Sepal.Length),avg = mean(Sepal.Length))


a %&gt;%
  summarise_when(Sepal.Length &gt; 5, avg = mean(Sepal.Length), by = Species)

a %&gt;%
  summarise_vars(is.numeric, min, by = Species)


</code></pre>

<hr>
<h2 id='sys_time_print'>Convenient print of time taken</h2><span id='topic+sys_time_print'></span>

<h3>Description</h3>

<p>Convenient printing of time elapsed. A wrapper of
<code>data.table::timetaken</code>, but showing the results more directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sys_time_print(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sys_time_print_+3A_expr">expr</code></td>
<td>
<p>Valid R expression to be timed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the form HH:MM:SS,
or SS.MMMsec if under 60 seconds. See examples.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+timetaken">timetaken</a></code>, <code><a href="base.html#topic+system.time">system.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sys_time_print(Sys.sleep(1))

a = as.data.table(iris)
sys_time_print({
  res = a %&gt;%
    mutate(one = 1)
})
res
</code></pre>

<hr>
<h2 id='uncount'>&quot;Uncount&quot; a data frame</h2><span id='topic+uncount'></span>

<h3>Description</h3>

<p>Performs the opposite operation to 'dplyr::count()',
duplicating rows according to a weighting variable (or expression).
Analogous to 'tidyr::uncount'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncount(.data, wt, .remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncount_+3A_.data">.data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="uncount_+3A_wt">wt</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
<tr><td><code id="uncount_+3A_.remove">.remove</code></td>
<td>
<p>Should the column for <code>weights</code> be removed?
Default uses <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+count">count</a></code>, <code><a href="tidyr.html#topic+uncount">uncount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.table(x = c("a", "b"), n = c(1, 2))
uncount(df, n)
uncount(df,n,FALSE)
</code></pre>

<hr>
<h2 id='unite'>Unite multiple columns into one by pasting strings together</h2><span id='topic+unite'></span>

<h3>Description</h3>

<p>Convenience function to paste together multiple columns into one.
Analogous to <code>tidyr::unite</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite(.data, united_colname, ..., sep = "_", remove = FALSE, na2char = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_+3A_.data">.data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_united_colname">united_colname</code></td>
<td>
<p>The name of the new column, string only.</p>
</td></tr>
<tr><td><code id="unite_+3A_...">...</code></td>
<td>
<p>A selection of columns. If want to select all columns,
pass &quot;&quot; to the parameter. See example.</p>
</td></tr>
<tr><td><code id="unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite_+3A_na2char">na2char</code></td>
<td>
<p>If <code>FALSE</code>, missing values would be merged into <code>NA</code>,
otherwise <code>NA</code> is treated as character &quot;NA&quot;. This is different from
<span class="pkg">tidyr</span>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+unite">unite</a></code>,<code><a href="#topic+separate">separate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- CJ(x = c("a", NA), y = c("b", NA))
df

# Treat missing value as NA, default
df %&gt;% unite("z", x:y, remove = FALSE)
# Treat missing value as character "NA"
df %&gt;% unite("z", x:y, na2char = TRUE, remove = FALSE)
# the unite has memory, "z" would not be removed in new operations
# here we remove the original columns ("x" and "y")
df %&gt;% unite("xy", x:y,remove = TRUE)

# Select all columns
iris %&gt;% as.data.table %&gt;% unite("merged_name",".")
</code></pre>

<hr>
<h2 id='utf8_encoding'>Use UTF-8 for character encoding in a data frame</h2><span id='topic+utf8_encoding'></span>

<h3>Description</h3>

<p><code>fread</code> from <span class="pkg">data.table</span> could not recognize the encoding
and return the correct form, this could be unconvenient for text mining tasks. The
<code>utf8-encoding</code> could use &quot;UTF-8&quot; as the encoding to override the current
encoding of characters in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utf8_encoding(.data, .cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utf8_encoding_+3A_.data">.data</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="utf8_encoding_+3A_.cols">.cols</code></td>
<td>
<p>The columns you want to convert, usually a character column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with characters in UTF-8 encoding
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris %&gt;%
  as.data.table() %&gt;%
  utf8_encoding(Species)  # could also use `is.factor`
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
