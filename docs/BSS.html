<!DOCTYPE html><html lang="en"><head><title>Help for package BSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a1Coefficients'><p>Caclulate the coefficients a_1 in the expression for K_1</p></a></li>
<li><a href='#a3Coefficients'><p>Caclulate the coefficients a_3 in the expression for K_3</p></a></li>
<li><a href='#bssAlphaFit'><p>Estimating the smoothness parameter of a Brownian semistationary process</p></a></li>
<li><a href='#calculateK'><p>Caclulate K_p for a BSS process for a given value of p</p></a></li>
<li><a href='#calculateK1'><p>Caclulate K_1 for a BSS process</p></a></li>
<li><a href='#calculateK2'><p>Caclulate K_2 for a BSS process</p></a></li>
<li><a href='#calculateK3'><p>Caclulate K_3 for a BSS process</p></a></li>
<li><a href='#calculateK4'><p>Caclulate K_4 for a BSS process</p></a></li>
<li><a href='#estimateAccumulatedVolatility'><p>Estimate accumulated volatility processes</p></a></li>
<li><a href='#estimateAccumulatedVolatilityCI'><p>Estimate confidence interval for the accumulated volatility processes</p></a></li>
<li><a href='#estimateK'><p>Estimate K_p for a BSS process, for a given power p</p></a></li>
<li><a href='#exponentiatedOrnsteinUhlenbeck'><p>Simulate an exponentiated OU volatility process</p></a></li>
<li><a href='#gammaKernelBSS'><p>Simulation of gamma kernel Brownian semistationary processes</p></a></li>
<li><a href='#gammaKernelBSSFit'><p>Fitting gamma kernel Brownian semistationary processes</p></a></li>
<li><a href='#gammaKernelCorrelation'><p>Autocorrelation function for the gamma kernel</p></a></li>
<li><a href='#gammaKernelTau'><p>Scale factor for the gamma kernel</p></a></li>
<li><a href='#gammaKernelTauAsymptotic'><p>Asymptotic scale factor for the gamma kernel</p></a></li>
<li><a href='#hybridSchemeCovarianceMatrix'><p>Hybrid scheme covariance matrix</p></a></li>
<li><a href='#powerKernelBSS'><p>Simulation of power law kernel Brownian semistationary processes</p></a></li>
<li><a href='#powerKernelBSSFit'><p>Fitting power law kernel Brownian semistationary processes</p></a></li>
<li><a href='#powerKernelCorrelation'><p>Autocorrelation function for the power law kernel</p></a></li>
<li><a href='#powerKernelTau'><p>Scale factor for the power law kernel</p></a></li>
<li><a href='#realisedPowerVariation'><p>Realised power variation</p></a></li>
<li><a href='#rhoFractionGaussian'><p>Caclulate the correlation of a fractional Gaussian - needed in the calculation of K</p></a></li>
<li><a href='#tauNonParametricEstimate'><p>Non-parametric estimate of the scale factor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Brownian Semistationary Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient simulation of Brownian semistationary (BSS) processes using the hybrid simulation scheme, as described in 
    Bennedsen, Lunde, Pakkannen (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1507.03004">doi:10.48550/arXiv.1507.03004</a>&gt;, as well as functions to fit BSS processes
    to data, and functions to estimate the stochastic volatility process of a BSS process.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>hypergeo, MASS, phangorn</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-24 09:53:34 UTC; phillip</td>
</tr>
<tr>
<td>Author:</td>
<td>Phillip Murray [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Phillip Murray &lt;phillip.murray18@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-24 12:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='a1Coefficients'>Caclulate the coefficients a_1 in the expression for K_1</h2><span id='topic+a1Coefficients'></span>

<h3>Description</h3>

<p>Caclulate the coefficients a_1 in the expression for K_1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a1Coefficients(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a1Coefficients_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>

<hr>
<h2 id='a3Coefficients'>Caclulate the coefficients a_3 in the expression for K_3</h2><span id='topic+a3Coefficients'></span>

<h3>Description</h3>

<p>Caclulate the coefficients a_3 in the expression for K_3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a3Coefficients(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="a3Coefficients_+3A_n">n</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>

<hr>
<h2 id='bssAlphaFit'>Estimating the smoothness parameter of a Brownian semistationary process</h2><span id='topic+bssAlphaFit'></span>

<h3>Description</h3>

<p><code>bssAlphaFit</code> uses the 'Change of Frequency' method to estimate the smoothness parameter, <code>alpha</code>,
of a BSS process. The COF method needs only minimal assumptions on the parametric form of the kernel,
therefore the estimate can be used in any kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bssAlphaFit(Y, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bssAlphaFit_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process at any frequency.</p>
</td></tr>
<tr><td><code id="bssAlphaFit_+3A_p">p</code></td>
<td>
<p>the power to be used in the change of frequency method. The default value is p = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a single value - an estimate for the smoothness parameter alpha.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
lambda &lt;- 1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, lambda, sigma = vol)
y &lt;- bss_simulation$bss

bssAlphaFit(y, p = 2)

</code></pre>

<hr>
<h2 id='calculateK'>Caclulate K_p for a BSS process for a given value of p</h2><span id='topic+calculateK'></span>

<h3>Description</h3>

<p>Caclulate K_p for a BSS process for a given value of p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateK(p, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateK_+3A_p">p</code></td>
<td>
<p>an integer - the power to use for K_p</p>
</td></tr>
<tr><td><code id="calculateK_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='calculateK1'>Caclulate K_1 for a BSS process</h2><span id='topic+calculateK1'></span>

<h3>Description</h3>

<p>Caclulate K_1 for a BSS process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateK1(alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateK1_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='calculateK2'>Caclulate K_2 for a BSS process</h2><span id='topic+calculateK2'></span>

<h3>Description</h3>

<p>Caclulate K_2 for a BSS process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateK2(alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateK2_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='calculateK3'>Caclulate K_3 for a BSS process</h2><span id='topic+calculateK3'></span>

<h3>Description</h3>

<p>Caclulate K_3 for a BSS process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateK3(alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateK3_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='calculateK4'>Caclulate K_4 for a BSS process</h2><span id='topic+calculateK4'></span>

<h3>Description</h3>

<p>Caclulate K_4 for a BSS process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateK4(alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateK4_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='estimateAccumulatedVolatility'>Estimate accumulated volatility processes</h2><span id='topic+estimateAccumulatedVolatility'></span>

<h3>Description</h3>

<p><code>estimateAccumulatedVolatility</code> estimates the pth power accumulated volatility process for a Brownian
semistationary process, using either parametric methods of model fitting first, or using a non-parametric
estimator for the scale factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAccumulatedVolatility(
  Y,
  n,
  p = 2,
  method = "nonparametric",
  kernel = "gamma"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateAccumulatedVolatility_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatility_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatility_+3A_p">p</code></td>
<td>
<p>the power to evaluate the accumulated power volatility process for. Defaults to 2, in order to
estimate the accumulated squared volatility process.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatility_+3A_method">method</code></td>
<td>
<p>text string representing the method used to estimate the accumulated volatility. Options are <code>'acf'</code>, <code>'cof'</code>
or <code>nonparametric</code>. If <code>'acf'</code> is selected, model parameters are fit to the data <code>Y</code> using
least squares on the autocorrelation function and these parameters are used to estimate the scale factor.
If <code>'cof'</code> is selected, only the smoothness parameter <code>alpha</code> is estimated using the change of frequency
method, and then put into an asymptotic expression for the scale factor in the calculation. If <code>'nonparametric'</code>
is selected then the non-parametric estimator for the scale factor will be used in the calculation. Defaults to <code>'nonparametric'</code>.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatility_+3A_kernel">kernel</code></td>
<td>
<p>text string representing the choice of kernel when fitting the model to estimate
the scale factor parametrically. Options are <code>'gamma'</code> and <code>'power'</code>. Defaults to <code>'gamma'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of the same length as <code>Y</code> which is the estimate for the
accumulated volatility process, observed from time 0 to T, at intervals of T/n. Note that the values have been
divided by m_p in the output, so that the estimation is of the integral alone. If the non-parametric
estimator for tau_n is used then the values will be scaled by the expectation of the squared volatility, as
per the theory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
lambda &lt;- 1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, lambda, sigma = vol)
y &lt;- bss_simulation$bss
estimateAccumulatedVolatility(y, n, p = 2, method = 'nonparametric', kernel = 'gamma')

#'

</code></pre>

<hr>
<h2 id='estimateAccumulatedVolatilityCI'>Estimate confidence interval for the accumulated volatility processes</h2><span id='topic+estimateAccumulatedVolatilityCI'></span>

<h3>Description</h3>

<p><code>estimateAccumulatedVolatility</code> estimates a confidence interval for the pth power accumulated volatility process for a Brownian
semistationary process, using either parametric methods of model fitting first, or using a non-parametric
estimator for the scale factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateAccumulatedVolatilityCI(
  Y,
  n,
  p,
  method = "nonparametric",
  kernel = "gamma",
  confidence_level
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_p">p</code></td>
<td>
<p>the power to evaluate the accumulated power volatility process for. Defaults to 2, in order to
estimate the accumulated squared volatility process.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_method">method</code></td>
<td>
<p>text string representing the method used to estimate the accumulated volatility. Options are <code>'acf'</code>, <code>'cof'</code>
or <code>nonparametric</code>. If <code>'acf'</code> is selected, model parameters are fit to the data <code>Y</code> using
least squares on the autocorrelation function and these parameters are used to estimate the scale factor.
If <code>'cof'</code> is selected, only the smoothness parameter <code>alpha</code> is estimated using the change of frequency
method, and then put into an asymptotic expression for the scale factor in the calculation. If <code>'nonparametric'</code>
is selected then the non-parametric estimator for the scale factor will be used in the calculation. Defaults to <code>'nonparametric'</code>.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_kernel">kernel</code></td>
<td>
<p>text string representing the choice of kernel when fitting the model to estimate
the scale factor parametrically. Options are <code>'gamma'</code> and <code>'power'</code>. Defaults to <code>'gamma'</code>.</p>
</td></tr>
<tr><td><code id="estimateAccumulatedVolatilityCI_+3A_confidence_level">confidence_level</code></td>
<td>
<p>the required level for the confidence interval, as a probability between 0 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of two vectors of the same length as <code>Y</code> which are the estimates for the
lower and upper values for the confidence interval. Note that the values have been
divided by m_p in the output, so that the estimation is of the integral alone. If the non-parametric
estimator for tau_n is used then the values will be scaled by the expectation of the squared volatility, as
per the theory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
lambda &lt;- 1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, lambda, sigma = vol)
y &lt;- bss_simulation$bss
estimateAccumulatedVolatility(y, n, p = 2, method = 'nonparametric', kernel = 'gamma')

#'

</code></pre>

<hr>
<h2 id='estimateK'>Estimate K_p for a BSS process, for a given power p</h2><span id='topic+estimateK'></span>

<h3>Description</h3>

<p>Estimate K_p for a BSS process, for a given power p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateK(Y, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateK_+3A_y">Y</code></td>
<td>
<p>a vector of observations of the BSS process</p>
</td></tr>
<tr><td><code id="estimateK_+3A_p">p</code></td>
<td>
<p>an integer - the power to use for K_p</p>
</td></tr>
</table>

<hr>
<h2 id='exponentiatedOrnsteinUhlenbeck'>Simulate an exponentiated OU volatility process</h2><span id='topic+exponentiatedOrnsteinUhlenbeck'></span>

<h3>Description</h3>

<p><code>exponentiatedOrnsteinUhlenbeck</code> simulates an exponentiated Ornstein-Uhlenbeckprocess of the correct length to
be used as the volatility process within the hybrid scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exponentiatedOrnsteinUhlenbeck_+3A_n">N</code></td>
<td>
<p>positive integer determining the number of terms in the Riemman sum element of the
hybrid scheme calculation. Should be of order at least <code>n</code>.</p>
</td></tr>
<tr><td><code id="exponentiatedOrnsteinUhlenbeck_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time. It represents the fineness or frequency of observations.</p>
</td></tr>
<tr><td><code id="exponentiatedOrnsteinUhlenbeck_+3A_t">T</code></td>
<td>
<p>the time interval to simulate the BSS process over.</p>
</td></tr>
<tr><td><code id="exponentiatedOrnsteinUhlenbeck_+3A_theta">theta</code></td>
<td>
<p>positive number giving the mean reversion rate of the OU process.</p>
</td></tr>
<tr><td><code id="exponentiatedOrnsteinUhlenbeck_+3A_beta">beta</code></td>
<td>
<p>the factor in the exponential.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of length <code>N + n*T + 1</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125

vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)

</code></pre>

<hr>
<h2 id='gammaKernelBSS'>Simulation of gamma kernel Brownian semistationary processes</h2><span id='topic+gammaKernelBSS'></span>

<h3>Description</h3>

<p><code>gammaKernelBSS</code> uses the Hybrid scheme to simulate a Brownian semistationary process from the
gamma kernel. It simulates a path where the volatility process is independent of the driving Brownian motion of the
BSS process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKernelBSS(
  N,
  n,
  T,
  kappa = 3,
  alpha,
  lambda,
  sigma = rep(1, N + n * T + 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKernelBSS_+3A_n">N</code></td>
<td>
<p>positive integer determining the number of terms in the Riemman sum element of the
hybrid scheme calculation. Should be of order at least <code>n</code>.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time. It represents the fineness or frequency of observations.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_t">T</code></td>
<td>
<p>the time interval to simulate the BSS process over.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_kappa">kappa</code></td>
<td>
<p>positive integer giving the number of terms to use in the 'lower' sum of the hybrid scheme. Default set to 3.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter of the BSS process to simulate.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_lambda">lambda</code></td>
<td>
<p>the exponent parameter of the BSS process to simulate.</p>
</td></tr>
<tr><td><code id="gammaKernelBSS_+3A_sigma">sigma</code></td>
<td>
<p>the volatility process used in the BSS simulation. This should be a vector of length <code>N + n*T + 1</code>
representing the sample path of sigma from -N to nT. By default this is set to by a vector of 1s so that the
Gaussian core is simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of three objects, <code>core</code> gives the Gaussian core of the process
between 0 and T, at intervals of 1/n. <code>bss</code> gives the BSS sample path on the between 0 and T, at intervals of 1/n,
and <code>vol</code> gives the volatilty process over the same time period.
</p>
<p>N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125
</p>
<p>kappa &lt;- 3
alpha &lt;- -0.2
lambda &lt;- 1.0
</p>
<p>vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, lambda, sigma = vol)
</p>

<hr>
<h2 id='gammaKernelBSSFit'>Fitting gamma kernel Brownian semistationary processes</h2><span id='topic+gammaKernelBSSFit'></span>

<h3>Description</h3>

<p><code>gammaKernelBSSFit</code> uses a method of moments to fit the parameters of a gamma kernel Brownian semistationary process
to a vector of observations. A least squares estimate of the parameters is obtained
by minimising the mean square error between the true gamma kernel autocorrelation function and the
empirical ACF of the data, using lags 0,...,H. The number of lags <code>num_lags</code> used can be adjusted.
The volatility process does not need to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKernelBSSFit(Y, n, num_lags = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKernelBSSFit_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process at frequency <code>n</code>.</p>
</td></tr>
<tr><td><code id="gammaKernelBSSFit_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="gammaKernelBSSFit_+3A_num_lags">num_lags</code></td>
<td>
<p>the number of lags to be used in the regression. The default is to use the first 10 lags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing the parameters <code>alpha</code> and <code>lambda</code>, and also the mean square
error <code>mse</code> of the least squares fit. This can be used to compare model fit when trying different kernels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
lambda &lt;- 1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, lambda, sigma = vol)
y &lt;- bss_simulation$bss

gammaKernelBSSFit(y, n, num_lags = 10)


</code></pre>

<hr>
<h2 id='gammaKernelCorrelation'>Autocorrelation function for the gamma kernel</h2><span id='topic+gammaKernelCorrelation'></span>

<h3>Description</h3>

<p><code>gammaKernelCorrelation</code> calculates the value of the gamma kernel autocorrelation function
directly using the analytic expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKernelCorrelation(alpha, lambda, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKernelCorrelation_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter, alpha, for the gamma kernel.</p>
</td></tr>
<tr><td><code id="gammaKernelCorrelation_+3A_lambda">lambda</code></td>
<td>
<p>the exponent parameter, lambda, for the gamma kernel.</p>
</td></tr>
<tr><td><code id="gammaKernelCorrelation_+3A_h">h</code></td>
<td>
<p>the lag to calculate the autocorrelation at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the autocorrelation for the gamma kernel with
parameters <code>alpha</code> and <code>lambda</code> at lag <code>h</code>.
</p>

<hr>
<h2 id='gammaKernelTau'>Scale factor for the gamma kernel</h2><span id='topic+gammaKernelTau'></span>

<h3>Description</h3>

<p><code>gammaKernelTau</code> evaluates the scale factor tau_n for the gamma kernel using the
exact expression derived from the covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKernelTau(n, alpha, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKernelTau_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="gammaKernelTau_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter, alpha, for the gamma kernel.</p>
</td></tr>
<tr><td><code id="gammaKernelTau_+3A_lambda">lambda</code></td>
<td>
<p>the exponent parameter, lambda, for the gamma kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the scale factor (tau_n) for the gamma kernel with
parameters <code>alpha</code> and <code>lambda</code>, observed at frequency <code>n</code> per unit of time.
</p>

<hr>
<h2 id='gammaKernelTauAsymptotic'>Asymptotic scale factor for the gamma kernel</h2><span id='topic+gammaKernelTauAsymptotic'></span>

<h3>Description</h3>

<p>Asymptotic scale factor for the gamma kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaKernelTauAsymptotic(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaKernelTauAsymptotic_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="gammaKernelTauAsymptotic_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter, alpha, for the gamma kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an approximation for the scale factor (tau_n) for the gamma kernel with
smoothness parameter <code>alpha</code>, observed at frequency <code>n</code> per unit of time, using the asymptotic
expression for the scale factor.
</p>

<hr>
<h2 id='hybridSchemeCovarianceMatrix'>Hybrid scheme covariance matrix</h2><span id='topic+hybridSchemeCovarianceMatrix'></span>

<h3>Description</h3>

<p>Generates the covariance matrix used in simulating Brownian semistationary processes by
the hybrid scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hybridSchemeCovarianceMatrix(kappa, n, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hybridSchemeCovarianceMatrix_+3A_kappa">kappa</code></td>
<td>
<p>number of terms needed for the lower sum in the hybrid scheme.</p>
</td></tr>
<tr><td><code id="hybridSchemeCovarianceMatrix_+3A_n">n</code></td>
<td>
<p>number of observations per unit of time, n = 1/delta.</p>
</td></tr>
<tr><td><code id="hybridSchemeCovarianceMatrix_+3A_alpha">alpha</code></td>
<td>
<p>smoothness parameter used in the BSS simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the covariance matrix for the lower sum in the hybrid scheme calculations.
The dimensions of the covariance matrix will be (kappa + 1) by (kappa + 1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kappa &lt;- 3
n &lt;- 100
alpha &lt;- -0.2

hybridSchemeCovarianceMatrix(kappa, n, alpha)


</code></pre>

<hr>
<h2 id='powerKernelBSS'>Simulation of power law kernel Brownian semistationary processes</h2><span id='topic+powerKernelBSS'></span>

<h3>Description</h3>

<p><code>powerKernelBSS</code> uses the Hybrid scheme to simulate a Brownian semistationary process from the
power law kernel. It simulates a path where the volatility process is independent of the driving Brownian motion of the
BSS process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerKernelBSS(N, n, T, kappa, alpha, beta, sigma = rep(1, N + n * T + 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerKernelBSS_+3A_n">N</code></td>
<td>
<p>positive integer determining the number of terms in the Riemman sum element of the
hybrid scheme calculation. Should be of order at least <code>n</code>.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time. It represents the fineness or frequency of observations.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_t">T</code></td>
<td>
<p>the time interval to simulate the BSS process over.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_kappa">kappa</code></td>
<td>
<p>positive integer giving the number of terms to use in the 'lower' sum of the hybrid scheme. Default set to 3.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter of the BSS process to simulate.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_beta">beta</code></td>
<td>
<p>the exponent parameter of the BSS process to simulate.</p>
</td></tr>
<tr><td><code id="powerKernelBSS_+3A_sigma">sigma</code></td>
<td>
<p>the volatility process used in the BSS simulation. This should be a vector of length <code>N + n*T + 1</code>
representing the sample path of sigma from -N to nT. By default this is set to by a vector of 1s so that the
Gaussian core is simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of three objects, <code>core</code> gives the Gaussian core of the process
between 0 and T, at intervals of 1/n. <code>bss</code> gives the BSS sample path on the between 0 and T, at intervals of 1/n,
and <code>vol</code> gives the volatilty process over the same time period.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta_vol &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
beta_pwr &lt;- -1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta_vol)
bss_simulation &lt;- powerKernelBSS(N, n, T, kappa, alpha, beta_pwr, sigma = vol)



</code></pre>

<hr>
<h2 id='powerKernelBSSFit'>Fitting power law kernel Brownian semistationary processes</h2><span id='topic+powerKernelBSSFit'></span>

<h3>Description</h3>

<p><code>powerKernelBSSFit</code> uses a method of moments to fit the parameters of a power law kernel Brownian semistationary process
to a vector of observations. A least squares estimate of the parameters is obtained
by minimising the mean square error between the true power law kernel autocorrelation function (found by numerical intergration)
and the empirical ACF of the data, using lags 0,...,H. The number of lags <code>num_lags</code> used can be adjusted.
The volatility process does not need to be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerKernelBSSFit(Y, n, num_lags = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerKernelBSSFit_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process at frequency <code>n</code>.</p>
</td></tr>
<tr><td><code id="powerKernelBSSFit_+3A_n">n</code></td>
<td>
<p>positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="powerKernelBSSFit_+3A_num_lags">num_lags</code></td>
<td>
<p>the number of lags to be used in the regression. The default is to use the first 10 lags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list containing the parameters <code>alpha</code> and <code>beta</code>, and also the mean square
error <code>mse</code> of the least squares fit. This can be used to compare model fit when trying different kernels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
n &lt;- 100
T &lt;- 1.0
theta &lt;- 0.5
beta_vol &lt;- 0.125

kappa &lt;- 3
alpha &lt;- -0.2
beta_pwr &lt;- -1.0


vol &lt;- exponentiatedOrnsteinUhlenbeck(N, n, T, theta, beta_vol)
bss_simulation &lt;- gammaKernelBSS(N, n, T, kappa, alpha, beta_pwr, sigma = vol)
y &lt;- bss_simulation$bss

powerKernelBSSFit(y, n, num_lags = 10)


</code></pre>

<hr>
<h2 id='powerKernelCorrelation'>Autocorrelation function for the power law kernel</h2><span id='topic+powerKernelCorrelation'></span>

<h3>Description</h3>

<p><code>powerKernelCorrelation</code> calculates the value of the power law kernel autocorrelation function
directly using numerical integration for the numerator (the covariance term) and the analytic expression
for the denominator (variance term).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerKernelCorrelation(alpha, beta, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerKernelCorrelation_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter, alpha, for the power law kernel.</p>
</td></tr>
<tr><td><code id="powerKernelCorrelation_+3A_beta">beta</code></td>
<td>
<p>the exponent parameter, beta, for the power law kernel.</p>
</td></tr>
<tr><td><code id="powerKernelCorrelation_+3A_h">h</code></td>
<td>
<p>the lag to calculate the autocorrelation at.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the autocorrelation for the power law kernel with
parameters <code>alpha</code> and <code>beta</code> at lag <code>h</code>.
</p>

<hr>
<h2 id='powerKernelTau'>Scale factor for the power law kernel</h2><span id='topic+powerKernelTau'></span>

<h3>Description</h3>

<p><code>powerKernelTau</code> evaluates the scale factor tau_n for the power law kernel using
numerical integration for the covariance term, and exact evaluation for the variance term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerKernelTau(n, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerKernelTau_+3A_n">n</code></td>
<td>
<p>a positive integer indicating the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="powerKernelTau_+3A_alpha">alpha</code></td>
<td>
<p>the smoothness parameter, alpha, for the power law kernel.</p>
</td></tr>
<tr><td><code id="powerKernelTau_+3A_beta">beta</code></td>
<td>
<p>the exponent parameter, beta, for the power law kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the scale factor (tau_n) for the power law kernel with
parameters <code>alpha</code> and <code>beta</code>, observed at frequency <code>n</code> per unit of time.
</p>

<hr>
<h2 id='realisedPowerVariation'>Realised power variation</h2><span id='topic+realisedPowerVariation'></span>

<h3>Description</h3>

<p><code>realisedPowerVariation</code> calculates the realised power variation for a BSS process, which is then
used as a component of estimating the accumulated volatility process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realisedPowerVariation(Y, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="realisedPowerVariation_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process.</p>
</td></tr>
<tr><td><code id="realisedPowerVariation_+3A_p">p</code></td>
<td>
<p>the power variation to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the sum of the pth powers of the absolute first differences of the BSS process.
</p>

<hr>
<h2 id='rhoFractionGaussian'>Caclulate the correlation of a fractional Gaussian - needed in the calculation of K</h2><span id='topic+rhoFractionGaussian'></span>

<h3>Description</h3>

<p>Caclulate the correlation of a fractional Gaussian - needed in the calculation of K
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoFractionGaussian(j, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhoFractionGaussian_+3A_j">j</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="rhoFractionGaussian_+3A_alpha">alpha</code></td>
<td>
<p>a float, the smoothness parameter of the BSS process</p>
</td></tr>
</table>

<hr>
<h2 id='tauNonParametricEstimate'>Non-parametric estimate of the scale factor</h2><span id='topic+tauNonParametricEstimate'></span>

<h3>Description</h3>

<p>Non-parametric estimate of the scale factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tauNonParametricEstimate(Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tauNonParametricEstimate_+3A_y">Y</code></td>
<td>
<p>a vector of observations of a BSS process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the non-parametric estimate for the scale factor.
Note that this will be scaled by the expectation of the square of the volatitity.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
