<!DOCTYPE html><html><head><title>Help for package PairViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PairViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#best_orientation'><p>Re-orients a path to be weight-decreasing</p></a></li>
<li><a href='#cancer'><p>Cancer Survival data</p></a></li>
<li><a href='#desaturate_color'><p>Desaturates colors</p></a></li>
<li><a href='#eseq'><p>Construct eulerian paths on the complete graph where nodes are integers 1..n.</p></a></li>
<li><a href='#etour'><p>Constructs eulerian tours on a graph.</p></a></li>
<li><a href='#eulerian'><p> ~~ Methods for Function eulerian  ~~</p></a></li>
<li><a href='#even_graph'><p>Class of graphs where all nodes have even degree</p></a></li>
<li><a href='#find_path'><p> Constructs a path from a matrix of edge weights.</p></a></li>
<li><a href='#guided_pcp'><p> Guided parallel coordinate plot.</p></a></li>
<li><a href='#hpaths'><p>Hamiltonian paths on the complete graph on 1..n, using Lucas-Walecki constructions.</p></a></li>
<li><a href='#knn_graph'><p>Functions to construct graphs.</p></a></li>
<li><a href='#mc_plot'><p> Multiple comparison plot.</p></a></li>
<li><a href='#mk_complete_graph'><p>Constructs a complete graph.</p></a></li>
<li><a href='#mk_even_graph'><p>  Constructs an even graph</p></a></li>
<li><a href='#order_best'><p>Uses brute-force enumeration  to find the best hamiltonian on the complete graph on 1..n.</p></a></li>
<li><a href='#order_tsp'><p>Uses tsp to find the best hamiltonian on the complete graph on 1..n</p></a></li>
<li><a href='#overlayCI'><p> Function to overlay confidence intervals on the current plot.</p></a></li>
<li><a href='#overview'><p> Overview of PairViz package</p></a></li>
<li><a href='#path_cor'><p> Measures the tendency of edge weights to increase.</p></a></li>
<li><a href='#path_weights'><p> Utility functions to manipulate pairwise information.</p></a></li>
<li><a href='#pcp'><p>Enhanced parallel coordinate plots.</p></a></li>
<li><a href='#spreadout'>
<p>Functions to prepare for categorical parallel coordinates, drawn by catpcp.</p></a></li>
<li><a href='#table_plot'><p> Plots rectangles on a grid</p></a></li>
<li><a href='#weighted_hpaths'><p>Constructs weight decreasing hamiltonian paths</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-12</td>
</tr>
<tr>
<td>Author:</td>
<td>C.B. Hurley and R.W. Oldford</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Catherine Hurley &lt;catherine.hurley@mu.ie&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualization using Graph Traversal</td>
</tr>
<tr>
<td>Description:</td>
<td>Improving graphics by ameliorating order effects, using Eulerian tours 
    and Hamiltonian decompositions of  graphs. References for the methods presented 
    here are C.B. Hurley and R.W. Oldford (2010) &lt;<a href="https://doi.org/10.1198%2Fjcgs.2010.09136">doi:10.1198/jcgs.2010.09136</a>&gt; and 
    C.B. Hurley and R.W. Oldford (2011) &lt;<a href="https://doi.org/10.1007%2Fs00180-011-0229-5">doi:10.1007/s00180-011-0229-5</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>TSP,gtools, graph, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Sleuth3, colorspace,multcomp,igraph,
scales,RColorBrewer,alr4,scagnostics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cbhurley.github.io/PairViz/">https://cbhurley.github.io/PairViz/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-12 14:33:33 UTC; catherine</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-12 15:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='best_orientation'>Re-orients a path to be weight-decreasing </h2><span id='topic+best_orientation'></span>

<h3>Description</h3>

<p>Re-orients a path/cycle, preserving adjacencies so that weights tend to decrease. From specifies the starting point, for cycles only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_orientation(path, d, cycle=FALSE, path_dir= path_cor, from=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_orientation_+3A_path">path</code></td>
<td>
<p>A vector giving a hamiltonian. </p>
</td></tr> 	
<tr><td><code id="best_orientation_+3A_d">d</code></td>
<td>
<p>A <code>dist</code>, used to provide edge weights.</p>
</td></tr>
<tr><td><code id="best_orientation_+3A_cycle">cycle</code></td>
<td>
<p>If <code>TRUE</code>, the <code>path</code> is interpreted as a closed path.</p>
</td></tr>
<tr><td><code id="best_orientation_+3A_path_dir">path_dir</code></td>
<td>
<p>A function used  to evaluate a path start and orientation</p>
</td></tr>
<tr><td><code id="best_orientation_+3A_from">from</code></td>
<td>
<p>Sepcifies the starting point, for cycles only.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hpaths">hpaths</a></code>, <code><a href="#topic+eulerian">eulerian</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(PairViz)

rdist &lt;- function(n) {
	d &lt;- matrix(0,n,n)
	d[lower.tri(d)] &lt;- runif(n*(n-1)/2)
	return(as.dist(d))
	}
r &lt;- rdist(7)
best_orientation(1:7,r) 
best_orientation(1:7,r,cycle=TRUE) 

</code></pre>

<hr>
<h2 id='cancer'>Cancer Survival data</h2><span id='topic+cancer'></span>

<h3>Description</h3>

<p>Patients with advanced cancers of the stomach, bronchus, colon, ovary or breast were treated with ascorbate. The purpose of the study was to determine if the survival times differ with respect to the organ affected by the cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cancer)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>Survival</code></dt><dd><p>time in days</p>
</dd>
<dt><code>Organ</code></dt><dd><p>Organ affected by the cancer</p>
</dd>
</dl>


<h3>References</h3>

<p>Cameron, E. and Pauling, L. (1978) Supplemental ascorbate in the supportive treatment of cancer: re-evaluation of prolongation of survival times in terminal human cancer. Proceedings of the National Academy of Science USA, 75, 4538-4542. 
</p>
<p>Also found in: Manly, B.F.J. (1986) Multivariate Statistical Methods: A Primer, New York: Chapman and Hall, 11. Also found in: Hand, D.J., et al. (1994) A Handbook of Small Data Sets, London: Chapman and Hall, 255.
</p>

<hr>
<h2 id='desaturate_color'>Desaturates colors
</h2><span id='topic+desaturate_color'></span>

<h3>Description</h3>

<p>Desaturates colors</p>


<h3>Usage</h3>

<pre><code class='language-R'>desaturate_color(cols, frac = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desaturate_color_+3A_cols">cols</code></td>
<td>
<p>Colors</p>
</td></tr>
<tr><td><code id="desaturate_color_+3A_frac">frac</code></td>
<td>
<p>Fraction to desaturate by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Desaturated version of orginal colors</p>

<hr>
<h2 id='eseq'>Construct eulerian paths on the complete graph where nodes are integers 1..n.</h2><span id='topic+eseq'></span><span id='topic+eseqa'></span><span id='topic+kntour_drop'></span><span id='topic+kntour_add'></span>

<h3>Description</h3>

<p>Constructs an eulerian 
on  the complete graph where nodes are integers 1..n. The result in an euler tour for odd <code>n</code>. For even  <code>n</code> the result is not exactly an euler tour or path because (n-2)/2 edges must be visited twice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eseq(n)
eseqa(n)
kntour_drop(e)
kntour_add(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eseq_+3A_n">n</code></td>
<td>
<p>a positive integer.</p>
</td></tr>
<tr><td><code id="eseq_+3A_e">e</code></td>
<td>
<p>an euler tour on Kn where n is odd</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm used for eseq builds up a path on 1..n  by appending extra edges on to the path on
nodes 1..(n-2). 
</p>
<p>The function eseqa constructs paths on 1..n using an alternative algorithm. For odd n, the tour starts at 1,
then takes steps of size 1,2,..m repeatedly, where m is (n-1)/2, For even n, the path constructed
is formed as eseqa(n+1), followed by dropping node n+1. 
</p>
<p>The function kntour_drop removes instances of n from the  tour, creating an open  approximately eulerian path on the complete graph with n-1 nodes.
</p>
<p>The function kntour_add inserts an extra node n+1 into a tour
on nodes 1, ..n. It adds a detour to the tour visiting all edges joining nodes 1..n to n+1. The result is an open  approximately eulerian path on the complete graph with n+1 nodes.
</p>


<h3>Value</h3>

<p>a numeric vector.</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hpaths">hpaths</a></code>, <code><a href="#topic+eulerian">eulerian</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(PairViz)
eseq(5)
eseq(6)


</code></pre>

<hr>
<h2 id='etour'>Constructs eulerian tours on a graph. </h2><span id='topic+etour'></span>

<h3>Description</h3>

<p><code>etour</code>&ndash; Constructs an eulerian tour on a graph using Hierholzer's algorithm. Returns a vector of node labels. If <code>weighted</code> is <code>TRUE</code> constructs a weight-decreasing eulerian using the modified Hierholzer's algorithm. Usually <code>etour</code> is not called directly, rather the generic function <code>eulerian</code> is used. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etour(g, start=NULL,weighted=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etour_+3A_g">g</code></td>
<td>
<p>a graph satisfying <code>is_even_graph</code></p>
</td></tr>
<tr><td><code id="etour_+3A_start">start</code></td>
<td>
<p>an optional starting node for the tour.</p>
</td></tr>
<tr><td><code id="etour_+3A_weighted">weighted</code></td>
<td>
<p>whether tour uses weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supplied graph should satisfy<code>is_even_graph</code>. If <code>weighted</code> is <code>TRUE</code>
the lowest weight edge is found, and the tour starts at the
one of its nodes, picking the node with the bigger second-smallest edge weight.
After that the tour follows weight-increasing edges.
If <code>weighted</code> is <code>FALSE</code>
weights are ignored. The returned tour is typically a closed path. However, if the last edge is a duplicated edge added to make the graph even, this edge is omitted and the result is an open path.	
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz)

g &lt;- mk_even_graph(5)

etour(g)
g &lt;- mk_even_graph(6) # adds 3 extra edges to g, so all nodes are even
etour(g)
etour(g, start= "4") # modifies the starting node

eulerian(6) # The eulerian wrapper looks after making even graph,
#also returns numbers rather than nodes

# On a general graph.
v &lt;- LETTERS[1:4]
g &lt;- new("graphNEL",nodes=v)
g &lt;- addEdge(v[1],v[3:4],g,1:2)
g &lt;- addEdge(v[2],v[3:4],g,3:4)
etour(g) 

eulerian(g) # Equivalently, use eulerian wrapper 


n &lt;- LETTERS[1:5]
g &lt;- new("graphNEL",nodes=n)
g &lt;- addEdge(n[1],n[2:3],g)
g &lt;-addEdge(n[2],n[3:5],g)
g &lt;-addEdge(n[4],n[3],g)
is_even_graph(g)
etour(mk_even_graph(g))

eulerian(g) # Equivalently, use eulerian wrapper 


</code></pre>

<hr>
<h2 id='eulerian'> ~~ Methods for Function eulerian  ~~</h2><span id='topic+eulerian'></span><span id='topic+eulerian-methods'></span><span id='topic+eulerian+2CANY-method'></span><span id='topic+eulerian+2CgraphNEL-method'></span><span id='topic+eulerian+2Ceven_graph-method'></span><span id='topic+eulerian+2Cmatrix-method'></span><span id='topic+eulerian+2Cnumeric-method'></span>

<h3>Description</h3>

<p>A generic function that returns an eulerian (or nearly eulerian)
path based on <code>self</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eulerian(self, start=NULL,weighted=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eulerian_+3A_self">self</code></td>
<td>
<p>&ndash; see below</p>
</td></tr>
<tr><td><code id="eulerian_+3A_start">start</code></td>
<td>
<p>&ndash; see below</p>
</td></tr>
<tr><td><code id="eulerian_+3A_weighted">weighted</code></td>
<td>
<p>&ndash; see below</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the eulerian- a character vector of node names for a graph, otherwise a numeric vector. If the graph is not connected, the result is a list of eulerians for each connected component.</p>


<h3>Methods</h3>


<dl>
<dt>self = &quot;even_graph&quot;</dt><dd><p>Uses <code>etour</code> to construct the eulerian. If <code>weighted</code> is TRUE a weighted eulerian is constructed, otherwise weights are ignored.  A non-null <code>start</code> is the eulerian starting point.</p>
</dd>
<dt>self = &quot;graphNEL&quot;</dt><dd><p> Augments the graph using <code>mk_euler_graph</code>, then invokes eulerian again on the augmented verion. If self  is not connected, (approximate) eulerians are formed for each connected component, which are returned as a list. </p>
</dd>
<dt>self = &quot;matrix&quot;</dt><dd><p> Builds a graph using <code>mk_euler_graph</code>, then invokes eulerian again on the result.</p>
</dd>
<dt>self = &quot;numeric&quot;</dt><dd><p> Builds a graph with self nodes using <code>mk_euler_graph</code>, then invokes eulerian again on the result.</p>
</dd>
<dt>self = &quot;ANY&quot;</dt><dd><p> Builds a graph using <code>mk_euler_graph</code>, then invokes eulerian again on the result.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>C. Hierholzer (1873). Uber die Moglichkeit, einen 
Linienzug ohne Wiederholung und ohne Unterbrechung zu umfahren. Math. Annalen VI, pp. 30-32.
</p>
<p>Also, see <a href="#topic+overview">overview</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(PairViz)

d &lt;- as.matrix(eurodist)[1:8,1:8]   # pick the first 8 cities

eulerian(d)
eulerian(d, weighted=FALSE) # In this case, starts at city 1 and ends at city 8


</code></pre>

<hr>
<h2 id='even_graph'>Class of graphs where all nodes have even degree</h2><span id='topic+even_graph-class'></span><span id='topic+graph_NEL-class'></span><span id='topic+is_even_graph'></span><span id='topic+is_even_graph+2Ceven_graph-method'></span><span id='topic+is_even_graph+2CgraphNEL-method'></span>

<h3>Description</h3>

<p>This class is an extension of <code>graphNEL-class</code>. For graphs of this class, euler tours may always be constructed. Objects of this class should  be created by  <code>mk_even_graph</code></p>


<h3>Slots</h3>

<p>This class has all slots from  <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code> plus:
</p>

<dl>
<dt><code>dummy_node</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>extra_edges</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>weighted</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>







</dl>



<h3>Extends</h3>

<p>Class <code><a href="graph.html#topic+graphNEL-class">graphNEL-class</a></code>, directly.
Class <code><a href="graph.html#topic+graph-class">graph-class</a></code>, by class &quot;graphNEL&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>is_even_graph</dt><dd><p><code>signature(g = "graphNEL")</code>: checks whether a graph has all nodes of even degree.</p>
</dd>
<dt>is_even_graph</dt><dd><p><code>signature(g = "even_graph")</code>: always TRUE.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("even_graph")

</code></pre>

<hr>
<h2 id='find_path'> Constructs a path from a matrix of edge weights.
</h2><span id='topic+find_path'></span>

<h3>Description</h3>

<p>Returns a path,  constructed by applying the function in <code>path</code>
to the edge weights. If each edge has many weights, i.e if <code>edgew</code> is a matrix, these weights are first reduced by the function <code>combine</code> applied to the rows. If <code>path</code> is NULL, the returned path defaults to 1..<code>nnodes(edgew)</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>find_path(edgew, path=NULL,  combine=sum, edge.index=edge_index(edgew),...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_path_+3A_edgew">edgew</code></td>
<td>
<p>Matrix (or vector) whose ith row (or element) has weights for pair indexed by pair in row i of edge.index.</p>
</td></tr>
<tr><td><code id="find_path_+3A_path">path</code></td>
<td>
<p>a function
used to construct the index path.</p>
</td></tr>
<tr><td><code id="find_path_+3A_combine">combine</code></td>
<td>
<p>A function that combines the row of weights for an edge into a single numeric value.</p>
</td></tr>
<tr><td><code id="find_path_+3A_edge.index">edge.index</code></td>
<td>
<p>A 2-column matrix with each row giving indices for
corresponding weight in <code>edgew</code>.</p>
</td></tr>
<tr><td><code id="find_path_+3A_...">...</code></td>
<td>
<p>passed to path construction function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>

<hr>
<h2 id='guided_pcp'> Guided parallel coordinate plot. </h2><span id='topic+guided_pcp'></span>

<h3>Description</h3>

<p>Draws a parallel coordinate plot, with an accompanying barchart showing an index (eg correlation, scagnostics) levels for each panel. An index legend is optional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guided_pcp(data, edgew=NULL, path = NULL, pathw=NULL,zoom=NULL,pcpfn=pcp,
     pcp.col = 1,lwd=0.5, panel.colors=NULL, pcp.mar=c(1.5,2,2,2), pcp.scale=TRUE,
     bar.col=1:9,bar.axes=FALSE, bar.mar=NULL,bar.ylim=NULL, reorder.weights=TRUE,
    layout.heights=NULL, layout.widths=c(10,1),
     main=NULL,legend=FALSE,cex.legend = 1,legend.mar=c(1,4,1,1),...)
     </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guided_pcp_+3A_data">data</code></td>
<td>
<p> A data frame or matrix. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_edgew">edgew</code></td>
<td>
<p>Matrix (or vector) whose rows give index values for each pair of variables.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_path">path</code></td>
<td>
<p>an index vector specifying variable order, or a function. If a function, <code>find_path(edgew,path,...)</code> constructs the index vector. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_pathw">pathw</code></td>
<td>
<p>Matrix (or vector) whose rows give index values for each adjacent pair of variables in path. Usually this argument is NULL and <code>pathw</code> is computed from the <code>path</code> and <code>edgew</code>.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_zoom">zoom</code></td>
<td>
<p>If provided, a numeric vector specifying a subsequence of path to display.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_pcpfn">pcpfn</code></td>
<td>
<p>Function to draw the parallel coordinates.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_pcp.col">pcp.col</code></td>
<td>
<p> Line colors.  </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_lwd">lwd</code></td>
<td>
<p> Line widths. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_panel.colors">panel.colors</code></td>
<td>
<p>Background panel colors, passed to the<code>pcpfn</code> </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_pcp.mar">pcp.mar</code></td>
<td>
<p>Controls PCP margin size. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_pcp.scale">pcp.scale</code></td>
<td>
<p>If TRUE, the variables will be scaled to 0-1 range, otherwise the data is not scaled. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_bar.col">bar.col</code></td>
<td>
<p>Bar colors. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_bar.axes">bar.axes</code></td>
<td>
<p>Draw barplot axes, if TRUE. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_bar.mar">bar.mar</code></td>
<td>
<p>Controls barplot margin size. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_bar.ylim">bar.ylim</code></td>
<td>
<p>Vertical limits of bar plot. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_reorder.weights">reorder.weights</code></td>
<td>
<p>If TRUE, reorder barplot indices so large values are drawn at the bottom. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_layout.heights">layout.heights</code></td>
<td>
<p>Controls the layout.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_layout.widths">layout.widths</code></td>
<td>
<p>Controls the layout.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_main">main</code></td>
<td>
<p>Main title for PCP.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_legend">legend</code></td>
<td>
<p>If TRUE, draws the barplot index legend.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_cex.legend">cex.legend</code></td>
<td>
<p>Controls legend text size.</p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_legend.mar">legend.mar</code></td>
<td>
<p>Legend margin size. </p>
</td></tr>
<tr><td><code id="guided_pcp_+3A_...">...</code></td>
<td>
<p> Optional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+pcp">pcp</a></code>,<code><a href="#topic+catpcp">catpcp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>	 			
require(PairViz) 			


data &lt;- mtcars[,c(1,3:6)]
cols &lt;- c("red","green")[mtcars[,9]+1 ]    # transmission type, red=automatic

# add a correlation guide and find "better" hamiltonians...

# add a correlation guide...


corw &lt;- dist2edge(as.dist(cor(data)))
edgew &lt;- cbind(corw*(corw&gt;0), corw*(corw&lt;0))
         
# add a correlation guide to a PCP, positive cors shown in blue, negative in purple...

## Not run: 
dev.new(width=3,height=3)

par(cex.axis=.65)

guided_pcp(data,edgew, pcp.col=cols,
         main="Correlation guided PCP",bar.col = c("blue","purple"))

dev.new(width=7,height=3)
par(cex.axis=.65)

guided_pcp(data,edgew, path=eulerian, pcp.col=cols,lwd=2,
         main="Correlation guided Eulerian PCP",bar.col = c("blue","purple"),bar.axes=TRUE)




## End(Not run)

# Scagnostic guides are useful here- see the demos for more examples.
</code></pre>

<hr>
<h2 id='hpaths'>Hamiltonian paths on the complete graph on 1..n, using Lucas-Walecki constructions.</h2><span id='topic+zigzag'></span><span id='topic+hpaths'></span><span id='topic+permute_hpaths'></span>

<h3>Description</h3>

<p><code>zigzag</code> - Constructs hamiltonian paths where each pair (i,j) 
appears in at least one of the hamiltonians.
</p>
<p><code>hpaths</code> - Returns a hamiltonian decomposition on the complete graph with n nodes. See Details.
</p>
<p><code>permute_hpaths</code> - Returns a modified version of <code>paths</code>, where vertices 
are re-labelled so that the first hamiltonian is <code>path1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zigzag(n)
hpaths(n, matrix=TRUE,cycle=NULL,...)
permute_hpaths(path1,paths= hpaths(length(path1)), matrix=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpaths_+3A_n">n</code></td>
<td>
<p>a positive integer. For <code>hpaths</code>, <code>n</code> may also be a vector specifying the first hamiltonian.</p>
</td></tr>
<tr><td><code id="hpaths_+3A_matrix">matrix</code></td>
<td>
<p>if <code>TRUE</code>, returns a matrix where each row is a hamiltonian 
path, otherwise concatenates the rows into a vector.</p>
</td></tr>
<tr><td><code id="hpaths_+3A_cycle">cycle</code></td>
<td>
<p>If <code>TRUE</code>, returns hamiltonian cycles, i.e. every hamiltonian starts at the same node.
If <code>FALSE</code>, returned paths are open. Defaults to <code>TRUE</code> for odd n,<code>FALSE</code> for even n. </p>
</td></tr>
<tr><td><code id="hpaths_+3A_path1">path1</code></td>
<td>
<p>A vector- This  will be the first hamiltonian of the returned hamiltonian decomposition.</p>
</td></tr>
<tr><td><code id="hpaths_+3A_paths">paths</code></td>
<td>
<p>A matrix where each row is a hamiltonian.</p>
</td></tr>
<tr><td><code id="hpaths_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hpaths</code> - 
From graph theory we know that for odd n, the complete graph decomposes into (n-1)/2 edge distinct hamiltonian
cycles, while for even n the graph decomposes into n/2 edge distinct hamiltonian paths.
The default behaviour of the function  <code>hpaths</code> is to produce the cycle decomposition for odd n and the path
decomposition for even n.
</p>
<p>However, if a <code>TRUE</code> value is supplied as argument cycle, the returned paths are cycles, and the result is a true  decomposition for odd n, but for even n the last hamiltonian has some duplicate edges.
If a <code>FALSE</code> value is supplied as argument cycle, the returned paths are open, and the result is a true decomposition 
for even n, but for odd n the last hamiltonian has some duplicate edges. 
</p>


<h3>Value</h3>

<p>A numeric matrix where each row  contains a permutation of 1..n, or these rows concatenated into a vector if <code>matrix=FALSE</code>.</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>D.E. Lucas (1892), Recreations Matematiques, Vol II. Gauthier Villars, Paris.
</p>
<p>Also	see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+weighted_hpaths">weighted_hpaths</a></code>, <code><a href="#topic+eseq">eseq</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz)

zigzag(7)
hpaths(7) # the rows form a decomp. into hamiltonian cycles

# Now concatenate the rows and close the path
hpaths(7,matrix=FALSE)

# Form a decomposition into hamiltonian cycles- 
# this decomposition is not exact, as the last row duplicates edges
hpaths(7,cycle=FALSE)

# For even n, the default is a decomposition into hamiltonian paths, not cycles.
hpaths(6)

# If cycles are required for even n, 
# the decomposition will not be exact and the last row duplicates edges

hpaths(6,cycle=TRUE)

# If you want to specify the first hamiltonian of the decomposition, use
hpaths(1:7)


</code></pre>

<hr>
<h2 id='knn_graph'>Functions to construct graphs.</h2><span id='topic+knn_graph'></span><span id='topic+dn_graph'></span><span id='topic+mk_hypercube_graph'></span><span id='topic+mk_binary_graph'></span><span id='topic+mk_line_graph'></span><span id='topic+kspace_graph'></span><span id='topic+graph_product'></span><span id='topic+graph_compose'></span><span id='topic+graph_sum'></span><span id='topic+bipartite_graph'></span><span id='topic+iterated_line_graph'></span>

<h3>Description</h3>

<p>Functions to construct graphs- see details below.</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_graph(g, k = 2)
dn_graph(g, d = 1, test=`&lt;=`)
mk_binary_graph(n,sep="",delta=1,test=`==`)
mk_hypercube_graph(n,sep="")
mk_line_graph(g,sep="-")
kspace_graph(n,m, link=NULL,sep="-")
graph_product(g,h, type="cartesian",sep="-")
graph_compose(g,h,sep="-")
graph_sum(g,h,combineWeight=`+`)

bipartite_graph(n1,n2)
iterated_line_graph(g,sep="-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_graph_+3A_g">g</code></td>
<td>
<p>a graph</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_h">h</code></td>
<td>
<p>a graph</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_n">n</code></td>
<td>
<p>a positive integer, or a character vector.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_k">k</code></td>
<td>
<p>a positive integer</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_d">d</code></td>
<td>
<p>an edge weight</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_test">test</code></td>
<td>
<p>used to select edges.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_sep">sep</code></td>
<td>
<p>used to form node names of new graph.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_m">m</code></td>
<td>
<p>subsets of size m are nodes of kneser graph. </p>
</td></tr>
<tr><td><code id="knn_graph_+3A_link">link</code></td>
<td>
<p>A positive number or NULL. If NULL, the returned graph is complete. Otherwise edges for subsets sharing link elements. </p>
</td></tr>
<tr><td><code id="knn_graph_+3A_type">type</code></td>
<td>
<p>the type of graph product, one of &quot;cartesian&quot;, &quot;strong&quot; or &quot;tensor&quot; </p>
</td></tr>
<tr><td><code id="knn_graph_+3A_n1">n1</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_n2">n2</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_delta">delta</code></td>
<td>
<p>used to select edges.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_combineweight">combineWeight</code></td>
<td>
<p>used to combine weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>knn_graph- returns a symmetric k nearest neighbour graph
</p>
<p>dn_graph- returns a  graph formed from g where edges of satisfy test(weight, d). The default retains edges whose weight are 1 are less. Nodes with no edges are also removed.
</p>
<p>mk_hypercube_graph- returns a hypercube graph with $2^n$ nodes
</p>
<p>mk_binary_graph(n,sep=&quot;&quot;,delta=1,test='==') - returns a  graph with <code class="reqn">2^n</code> nodes. Undirected edges join nodes A and B whose binary vectors satisfy <code class="reqn">a_i \leq b_i,i=1, \ldots, n</code> and test(<code class="reqn">\sum(b_i - a_i)</code>, delta) is true.
</p>
<p>mk_line_graph- returns the line graph of g
</p>
<p>kspace_graph- returns a  graph where nodes  are subsets of size m from n. Edges are connect nodes whose subsets share link elements. The standard kneser graph has link=0. When link is NULL, returned graph is complete.
</p>
<p>graph_product(g,h, type=&quot;cartesian&quot;,sep=&quot;-&quot;)- returns the graph product of g and h.
</p>
<p>graph_compose(g,h,sep=&quot;-&quot;)- returns the graph composition of g and h.
</p>
<p>bipartite_graph(n1,n2)- returns the complete bipartite graph with node sets n1 and n2.
</p>
<p>graph_sum(g,h,combineWeight='+')- returns a graph whose nodes and edges are the union of those in g and h. Weights of common edges are combined using combineWeight.
</p>
<p>iterated_line_graph- returns the iterated line graph of g, with compression of nodes as described in the reference Hurley and Oldford(2008) given below.
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>See any Graph Theory text. Also
C.B. Hurley and R.W. Oldford,
Graphs as navigational infrastructure for high dimensional data spaces. 2008 submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# See the demo file nav.R	
</code></pre>

<hr>
<h2 id='mc_plot'> Multiple comparison plot.  </h2><span id='topic+mc_plot'></span>

<h3>Description</h3>

<p>For grouped data. Draws boxplots for each group and overlays with confidence intervals for pairwise comparison of means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_plot(data, fit, path = eulerian, col = rainbow(length(data), s = 0.4), 
levels = c(0.9, 0.95, 0.99), varwidth = TRUE, frame.plot = FALSE, 
boxwex = 0.3, cex=0.75, zoom=NULL,ci.yusr=NULL,ci.pos=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_plot_+3A_data">data</code></td>
<td>
<p> A list of vectors, such as that returned by <code>split</code>. </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_fit">fit</code></td>
<td>
<p> Either an <code><a href="stats.html#topic+aov">aov</a></code> fit, or else  a matrix with columns estimate, followed by confidence intervals. If fit is not an <code><a href="stats.html#topic+aov">aov</a></code> fit, the path argument should be a vector.</p>
</td></tr>
<tr><td><code id="mc_plot_+3A_path">path</code></td>
<td>
<p>an index vector or a function. If a vector, groups are plotted in order <code>data[path]</code>. By default, it is the  function <code><a href="#topic+eulerian">eulerian</a></code>, and produces an ordering where each pair of groups appears adjacently, with p-values roughly increasing as the sequence progresses.  </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_col">col</code></td>
<td>
<p> A vector of colours, one per group.  </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_levels">levels</code></td>
<td>
<p> Vector of increasing confidence levels. </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_varwidth">varwidth</code></td>
<td>
<p>Passed to  <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.  </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_frame.plot">frame.plot</code></td>
<td>
<p> Passed to  <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
<tr><td><code id="mc_plot_+3A_boxwex">boxwex</code></td>
<td>
<p> Passed to  <code><a href="graphics.html#topic+boxplot">boxplot</a></code>. </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_cex">cex</code></td>
<td>
<p> Passed to  <code><a href="graphics.html#topic+boxplot">boxplot</a></code>. </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_zoom">zoom</code></td>
<td>
<p>If provided, a numeric vector specifying a subsequence of path to display.</p>
</td></tr>
<tr><td><code id="mc_plot_+3A_ci.yusr">ci.yusr</code></td>
<td>
<p>Specifies the vertical <code>par(usr) </code> for the confidence intervals. Defaults to max and min. </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_ci.pos">ci.pos</code></td>
<td>
<p>If TRUE, all CIs are mu(max) - mu(min), otherwise mu(right) - mu(left). </p>
</td></tr>
<tr><td><code id="mc_plot_+3A_...">...</code></td>
<td>
<p> Optional arguments, passed to  <code>boxplot</code> and <code><a href="#topic+overlayCI">overlayCI</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p> See also  <code><a href="#topic+overlayCI">overlayCI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>	 			
require(PairViz) 			

data(cancer)
bx &lt;- with(cancer, split(sqrt(Survival),Organ))



a &lt;-  aov(sqrt(Survival) ~ Organ,data=cancer)
## Not run: 
dev.new(height=4.5, width=9.5)
op &lt;- par(no.readonly = TRUE)

par(cex.axis=.75, cex.main = 1.0, cex.lab=1)
par(mar=c(3,5,3,5))

mc_plot(bx,a,main="Pairwise comparisons of cancer types", ylab="Sqrt Survival")

par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='mk_complete_graph'>Constructs a complete graph.</h2><span id='topic+mk_complete_graph'></span>

<h3>Description</h3>

<p>Constructs a complete graph, actually an instance of <code>graph-NEL</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_complete_graph(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_complete_graph_+3A_d">d</code></td>
<td>
<p>an integer vector of length 1 which specified the number of nodes, a character vector of nodes names,  a <code>dist</code>, or a symmetric matrix, either of which specify the nodes and edge weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>- a <code>graph-NEL</code></p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>Examples</h3>

<pre><code class='language-R'>	
require(PairViz)
d &lt;- dist(rnorm(5))
g &lt;- mk_complete_graph(d)
</code></pre>

<hr>
<h2 id='mk_even_graph'>  Constructs an even graph</h2><span id='topic+mk_even_graph-methods'></span><span id='topic+mk_even_graph+2CANY-method'></span><span id='topic+mk_even_graph+2CgraphNEL-method'></span><span id='topic+mk_even_graph+2Cmatrix-method'></span><span id='topic+mk_even_graph+2Cnumeric-method'></span><span id='topic+mk_even_graph+2Ceven_graph-method'></span><span id='topic+mk_even_graph'></span>

<h3>Description</h3>

<p>~~ Methods for function <code>mk_even_graph</code>. Each of these return an instance of <code>even_graph</code>, where all nodes are of even degree. The result  satisfies <code>is_even_graph</code>.
The resulting graph yields an euler tour.</p>


<h3>Methods</h3>


<dl>
<dt>self = &quot;graphNEL&quot;,use_weights=TRUE,add_edges=TRUE</dt><dd><p> This is the workhorse method. If <code>self</code> does not satisfy <code>is_even_graph</code>, the graph is forced to be even by one of the folowing. If add_edges is TRUE, the odd nodes are paired off and a new edge added between each  pair, possibly duplicating an existing edge. If add_edges is a vector of the odd nodes, they are paired off in this order.
If add_edges is FALSE a new dummy node is added with
edges going to all odd nodes.  </p>
</dd>
<dt>self = &quot;matrix&quot;,use_weights=TRUE,add_edges=TRUE</dt><dd><p> first constructs a complete graph using <code>mk_complete_graph</code>, which is then augmented to be even. </p>
</dd>
<dt>self = &quot;numeric&quot;,use_weights=FALSE,add_edges=TRUE</dt><dd><p> first constructs a complete graph using  <code>mk_complete_graph</code>, which is then augmented to be even. </p>
</dd>
<dt>self = &quot;ANY&quot;,use_weights=TRUE,add_edges=TRUE</dt><dd><p> first constructs a complete graph using  <code>mk_complete_graph</code>, which is then augmented to be even. </p>
</dd>
<dt>self = &quot;even_graph&quot;,add_edges=TRUE</dt><dd><p> returns self.</p>
</dd>
</dl>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mk_complete_graph">mk_complete_graph</a></code>, <code><a href="#topic+is_even_graph">is_even_graph</a></code></p>

<hr>
<h2 id='order_best'>Uses brute-force enumeration  to find the best hamiltonian on the complete graph on 1..n.  </h2><span id='topic+order_best'></span>

<h3>Description</h3>

<p>Returns the best hamiltonian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_best(d, maxexact=9,nsamples=50000,path_weight=sum,
cycle=FALSE,path_dir = path_cor,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_best_+3A_d">d</code></td>
<td>
<p>A <code>dist</code>, used to provide edge weights.</p>
</td></tr>
<tr><td><code id="order_best_+3A_maxexact">maxexact</code></td>
<td>
<p>If the sequence length is  <code>&lt;= maxexact</code>, find the overall best hamiltonian, otherwise compares <code>nsamples</code>
randomly generated permutations.</p>
</td></tr>
<tr><td><code id="order_best_+3A_nsamples">nsamples</code></td>
<td>
<p>If the sequence length is  <code>&lt;= maxexact</code>, finds the  best of <code>nsamples</code> randomly generated permutations .</p>
</td></tr>
<tr><td><code id="order_best_+3A_cycle">cycle</code></td>
<td>
<p>If <code>TRUE</code>, finds the shortest cycle, otherwise the shortest open path.</p>
</td></tr>
<tr><td><code id="order_best_+3A_path_weight">path_weight</code></td>
<td>
<p>Combines edge weights into a single path/cycle weight.</p>
</td></tr>
<tr><td><code id="order_best_+3A_path_dir">path_dir</code></td>
<td>
<p>If a function is provided, used to re-orient the cycle/path. Default function is <code><a href="#topic+path_cor">path_cor</a></code>.</p>
</td></tr>
<tr><td><code id="order_best_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires package gtools. 
Currently it is possible to find the best hamiltonian by complete enumeration for up to 10 nodes.
When  <code>path_dir</code>  is non NULL, the returned hamiltonian is also optimally oriented using <code>best_orientation</code>, which compares orientations via <code>path_dir</code>.</p>


<h3>Value</h3>

<p>A vector containing a permutation of 1..n</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+order_tsp">order_tsp</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz)
order_best(eurodist)



</code></pre>

<hr>
<h2 id='order_tsp'>Uses tsp to find the best hamiltonian on the complete graph on 1..n</h2><span id='topic+order_tsp'></span>

<h3>Description</h3>

<p>Returns shortest cycle or path via tsp solver from package TSP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_tsp(d, method = "nearest", cycle=FALSE,improve=FALSE,path_dir = path_cor,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_tsp_+3A_d">d</code></td>
<td>
<p>A <code>dist</code>, used to provide edge weights.</p>
</td></tr>
<tr><td><code id="order_tsp_+3A_method">method</code></td>
<td>
<p>Options are <code>nearest_insertion</code>, <code>farthest_insertion</code>, <code>cheapest_insertion</code>,         
<code>arbitrary_insertion</code>, <code>nn</code>, <code>repetitive_nn</code>,
<code>2-opt</code> and if concorde package is loaded, <code>concorde</code>. See <code><a href="TSP.html#topic+solve_TSP">solve_TSP</a></code> for details.
</p>
</td></tr>
<tr><td><code id="order_tsp_+3A_improve">improve</code></td>
<td>
<p>if <code>TRUE</code>, attempts to improve the solution using &quot;2-opt&quot;.</p>
</td></tr>
<tr><td><code id="order_tsp_+3A_cycle">cycle</code></td>
<td>
<p>If <code>TRUE</code>, finds the shortest cycle, otherwise the shortest open path.</p>
</td></tr>
<tr><td><code id="order_tsp_+3A_path_dir">path_dir</code></td>
<td>
<p>If a function is provided, used to re-orient the cycle/path. Default function is <code><a href="#topic+path_cor">path_cor</a></code>.</p>
</td></tr>
<tr><td><code id="order_tsp_+3A_...">...</code></td>
<td>
<p>passed to <code>solve_tsp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires package TSP.
When  <code>path_dir</code>  is non NULL, the returned hamiltonian is also optimally oriented using <code>best_orientation</code>, which compares orientations via <code>path_dir</code>.</p>


<h3>Value</h3>

<p>A vector containing a permutation of 1..n</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>See package TSP.</p>


<h3>See Also</h3>

<p><code><a href="#topic+order_best">order_best</a></code>, <code><a href="TSP.html#topic+solve_TSP">solve_TSP</a></code> in <span class="pkg">TSP</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz)


rdist &lt;- function(n) {
	d &lt;- matrix(0,n,n)
	d[lower.tri(d)] &lt;- runif(n*(n-1)/2)
	return(as.dist(d))
	}


order_tsp(rdist(7))




edist &lt;- as.dist(as.matrix(eurodist))
order_tsp(edist)

</code></pre>

<hr>
<h2 id='overlayCI'> Function to overlay confidence intervals on the current plot. </h2><span id='topic+overlayCI'></span>

<h3>Description</h3>

<p>Overlays confidence intervals on the current plot. Also draws a right hand axis, a horizontal broken line at zero, and marks the significant comparisons with an arrow, i.e. the CIs that do not intersect zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlayCI(cis, xpos=NULL,ci.cols = NULL, ci.ex = 2, ci.ocol = "grey40", 
p.col = "grey40", pch = 1, sig.col = "red", sig.lwd = 1, yusr = NULL,
ci.label="Differences",ci.cex=0.5,arrow.length=0.1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlayCI_+3A_cis">cis</code></td>
<td>
<p>A matrix containing the confidence intervals. Each row corresponds to a
different comparison, the first column is the estimated mean, and succesive pairs of columns give the lower and upper limits for different confidence levels. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_ci.cols">ci.cols</code></td>
<td>
<p> A vector of colours, one colour for each confidence level. Defaults to shades of grey. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_ci.ex">ci.ex</code></td>
<td>
<p>Controls confidence interval line width. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_xpos">xpos</code></td>
<td>
<p>Horizonal positions where CIs are drawn. Defaults to 1.5,2.5,3.5,..</p>
</td></tr>
<tr><td><code id="overlayCI_+3A_ci.ocol">ci.ocol</code></td>
<td>
<p>Colour of zero line.</p>
</td></tr>
<tr><td><code id="overlayCI_+3A_p.col">p.col</code></td>
<td>
<p>Colour of point used for CI centre. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_pch">pch</code></td>
<td>
<p> Symbol used for CI centre. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_sig.col">sig.col</code></td>
<td>
<p> Colour of arrow marking significant comparisons. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_sig.lwd">sig.lwd</code></td>
<td>
<p>Width of arrow marking significant comparisons. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_yusr">yusr</code></td>
<td>
<p>Specifies the vertical <code>par(usr) </code>.Defaults to max and min. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_ci.label">ci.label</code></td>
<td>
<p>Label drawn on right margin. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_ci.cex">ci.cex</code></td>
<td>
<p>Controls size of CI mean point symbol. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_arrow.length">arrow.length</code></td>
<td>
<p>Controls size arrow at right hand axis. </p>
</td></tr>
<tr><td><code id="overlayCI_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p> This function is called by <code>mc_plot</code></p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p> See Also as <code><a href="#topic+mc_plot">mc_plot</a></code> </p>

<hr>
<h2 id='overview'> Overview of PairViz package </h2><span id='topic+overview'></span><span id='topic+PairViz-package'></span>

<h3>Description</h3>

<p>Implements methods described in Hurley and Oldford paper.
</p>
<p>There are functions for constructing eulerian paths on complete graphs- see <code><a href="#topic+eseq">eseq</a></code>, <code><a href="#topic+hpaths">hpaths</a></code>, and <code><a href="#topic+weighted_hpaths">weighted_hpaths</a></code>, and eulerians on general graphs-
see <code><a href="#topic+etour">etour</a></code> and <code><a href="#topic+eulerian">eulerian</a></code>.
</p>
<p>There are also functions for new types of graphics, <code><a href="#topic+mc_plot">mc_plot</a></code>, <code><a href="#topic+catpcp">catpcp</a></code> and
<code><a href="#topic+guided_pcp">guided_pcp</a></code> and a barchart/mosaic variant <code><a href="#topic+table_plot">table_plot</a></code>.
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>C.B. Hurley and R.W. Oldford,
Pairwise display of high dimensional information via 
Eulerian tours and Hamiltonian decompositions. Journal of Computational and Graphical Statistics.
19(10), pp. 861&ndash;886, 2010.
</p>
<p>C.B. Hurley and R.W. Oldford, 
Eulerian tour algorithms for data visualization and the PairViz package. 
Computational Statistics, 26(4), pp 613&ndash;633, 2011. 
</p>

<hr>
<h2 id='path_cor'> Measures the tendency of edge weights to increase.</h2><span id='topic+path_cor'></span>

<h3>Description</h3>

<p>Returns the (Kendalls tau) correlation of the edge weights with the vector 1.. (number of weights).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_cor(edgew, method = "kendall")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_cor_+3A_edgew">edgew</code></td>
<td>
<p> A vector of edge weights. </p>
</td></tr>
<tr><td><code id="path_cor_+3A_method">method</code></td>
<td>
<p> passed to <code><a href="stats.html#topic+cor">cor</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='path_weights'> Utility functions to manipulate pairwise information.
</h2><span id='topic+path_weights'></span><span id='topic+path_cis'></span><span id='topic+edge2dist'></span><span id='topic+dist2edge'></span><span id='topic+edge_index'></span><span id='topic+nnodes'></span>

<h3>Description</h3>

<p>These  functions perform calculations on edge matrices containing pairwise information.</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_weights(edgew, path,  symmetric = TRUE,edge.index=edge_index(edgew),...)
path_cis(edgew, path,edge.index=edge_index(edgew),ci.pos=FALSE)
edge2dist(edgew, edge.index=edge_index(edgew))
dist2edge(d)
edge_index(x, order="default")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_weights_+3A_edgew">edgew</code></td>
<td>
<p>A Matrix (or vector) whose ith row (or element) has weights for pair indexed by pair in row i of edge.index.
For <code>edge2dist</code>, <code>edgew</code> should be a vector.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_path">path</code></td>
<td>
<p>Vector of indices into rows of <code>edgew</code>.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_symmetric">symmetric</code></td>
<td>
<p>If <code>TRUE</code> edge weights are interpreted as symmetric. </p>
</td></tr>
<tr><td><code id="path_weights_+3A_edge.index">edge.index</code></td>
<td>
<p>A 2-column matrix with each row giving indices for
corresponding weight in <code>edgew</code>.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_ci.pos">ci.pos</code></td>
<td>
<p>If TRUE, all CIs are mu(max) - mu(min), otherwise mu(right) - mu(left). </p>
</td></tr>
<tr><td><code id="path_weights_+3A_d">d</code></td>
<td>
<p>A <code>dist</code> or matrx of distances.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_order">order</code></td>
<td>
<p>If &quot;low.order.first&quot; or &quot;scagnostics&quot;, lists lowest index pairs first, otherwise lists pairs starting with 1, then 2 etc.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_x">x</code></td>
<td>
<p>An edgew matrix or vector, or a positive integer.</p>
</td></tr>
<tr><td><code id="path_weights_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>path_weights</code> - Returns matrix of path weights so that the ith row of result contains weights for indices path[i], path[i+1]
</p>
<p><code>path_cis</code> - Returns matrix of path confidence intervals so that the ith row of result contains intervals for mean-path[i] -  mean-path[i+1]
</p>
<p><code>edge2dist</code> - Returns a <code>dist</code>,
containing elements of <code>edgew</code>. 
</p>
<p><code>dist2edge</code> - Returns a vector of edge weights.
</p>
<p><code>edge_index</code> -A generic function. Returns a 2-column matrix with one row for
each edge.  Each row contains an index pair i,j. If <code>order</code> is &quot;low.order.first&quot; or &quot;scagnostics&quot;, lists lowest index pairs first - this is the default ordering for class <code>scagdf</code>, otherwise lists pairs
starting with 1, then 2 etc
</p>
<p><code>nnodes</code> - Here <code>edgew</code> contains edge weights for a complete graph;  returns the number of nodes in this complete graph.
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz)

s &lt;- matrix(1:40,nrow=10,ncol=4)

edge2dist(s[,1])

path_weights(s,1:4)
path_weights(s,eseq(5))

fm1 &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
tuk &lt;- TukeyHSD(fm1, "tension")[[1]]

# Here the first argument (weight matrix) can have number of columns

path_weights(tuk,c(1:3,1))  



# Here the first argument (weight matrix) should have an odd number of columns-
# the first is the mean difference, other column pairs are endpoints of CIs


path_cis(tuk[,-4],c(1:3,1))
 
 
 </code></pre>

<hr>
<h2 id='pcp'>Enhanced parallel coordinate plots. </h2><span id='topic+pcp'></span><span id='topic+catpcp'></span>

<h3>Description</h3>

<p>pcp draws a parallel coordinate plot.It is a modified
version of <code>parcoord {MASS}</code>.
Variables
may be reordered and panels colored in the display. 
</p>
<p>catpcp draws a parallel coordinate plot variant for categorical data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcp(data, order = NULL, panel.colors = NULL, col = 1, lty = 1, 
horizontal = TRUE, mar = NULL, scale = TRUE, axis.width = 0,
axis.grid.col="grey70",connect=TRUE, ...)

catpcp(data, order = NULL, pcpbars, barvars = 1:ncol(data), 
pcpbars.border = "black", pcpbars.col = NULL, pcpbars.labels = FALSE, 
pcpbars.axis.at = NULL, pcpbars.axis.labels = NULL, 
axis.width = 0.2,connect=TRUE, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcp_+3A_data">data</code></td>
<td>
<p> A data frame or matrix. </p>
</td></tr>
<tr><td><code id="pcp_+3A_order">order</code></td>
<td>
<p>an index vector specifying variable order. If NULL, all variables are used.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_panel.colors">panel.colors</code></td>
<td>
<p>either a vector or a matrix of panel colors. If a 
vector is supplied, the ith color is used for the ith panel. If a matrix, dimensions 
should match those of the variables. Diagonal entries are ignored. </p>
</td></tr>
<tr><td><code id="pcp_+3A_col">col</code></td>
<td>
<p> a vector of colours, recycled as necessary for each observation.  </p>
</td></tr>
<tr><td><code id="pcp_+3A_lty">lty</code></td>
<td>
<p> a vector of line types, 
recycled as necessary for each observation.  </p>
</td></tr>
<tr><td><code id="pcp_+3A_horizontal">horizontal</code></td>
<td>
<p> If TRUE, orientation is horizontal. </p>
</td></tr>
<tr><td><code id="pcp_+3A_mar">mar</code></td>
<td>
<p> margin parameters, passed to <code>par</code>. </p>
</td></tr>
<tr><td><code id="pcp_+3A_scale">scale</code></td>
<td>

<p>If TRUE, the variables are scaled to the unit interval.</p>
</td></tr>
<tr><td><code id="pcp_+3A_axis.width">axis.width</code></td>
<td>
<p>Width of each of the parallel axes.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_axis.grid.col">axis.grid.col</code></td>
<td>
<p>Color of variable axes. Use NULL for no axes.</p>
</td></tr>
<tr><td><code id="pcp_+3A_connect">connect</code></td>
<td>
<p>If FALSE, line segments are not connected. Points are drawn if axis.width=0.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars">pcpbars</code></td>
<td>
<p>A list, with one component per barvar. Component i is a matrix with the bottom and top of the bars for that variable.</p>
</td></tr>
<tr><td><code id="pcp_+3A_barvars">barvars</code></td>
<td>
<p>Categorical variables where overlayed bars show the level frequency.</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars.border">pcpbars.border</code></td>
<td>
<p>Border colour of the bars.</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars.col">pcpbars.col</code></td>
<td>
<p>Colour of the bars.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars.labels">pcpbars.labels</code></td>
<td>
<p>Labels for the bars.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars.axis.at">pcpbars.axis.at</code></td>
<td>
<p>Axis label positions for the bars.
</p>
</td></tr>
<tr><td><code id="pcp_+3A_pcpbars.axis.labels">pcpbars.axis.labels</code></td>
<td>
<p>Axis label text for the bars.</p>
</td></tr>
<tr><td><code id="pcp_+3A_...">...</code></td>
<td>
<p> other parameters, passed to pcp by catpcp</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>require(PairViz) 		
y &lt;- as.data.frame(as.table(HairEyeColor))

colvar &lt;- 3 # any of 1:3 will do
y &lt;- y[order(y[,colvar]),] # ensures that cases are ordered by colour within each factor level
ylong &lt;- apply(y[,-4],2, function(x) rep(x,times=y[,4]))

cols &lt;- desaturate_color(rainbow(4,alpha=0.3),.5)
cols &lt;- cols[as.numeric(as.factor(ylong[,colvar]))]




ds &lt;- factor_spreadout(ylong)




dev.new(width=5,height=2.5)
par(mar=c(2,1,2,1))
par( cex.axis=.8,cex=.8)



catpcp(ds$data,col=cols,lwd=2,pcpbars=ds$bars,pcpbars.labels=TRUE,main="Hair Eye data")

	
	
	
	
	</code></pre>

<hr>
<h2 id='spreadout'>
Functions to prepare for categorical parallel coordinates, drawn by catpcp.
</h2><span id='topic+rater_spreadout'></span><span id='topic+factor_spreadout'></span>

<h3>Description</h3>

<p>factor_spreadout spreads out the data at each factor level.
rater_spreadout spreads out the data at each rating level.
The rater version is appropriate when the variables (factors) have all the same levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_spreadout(d)
rater_spreadout(d, levs, minspace = NULL,scale=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spreadout_+3A_d">d</code></td>
<td>
<p>A data frame where each variable can be interpreted as a factor.
</p>
</td></tr>
<tr><td><code id="spreadout_+3A_levs">levs</code></td>
<td>
<p>The rating levels. Specifying this controls the order of rating levels on each axis.</p>
</td></tr>
<tr><td><code id="spreadout_+3A_minspace">minspace</code></td>
<td>
<p>The minimum amount of space between the bars.</p>
</td></tr>
<tr><td><code id="spreadout_+3A_scale">scale</code></td>
<td>
<p>If scale=FALSE, the ith rater values are spreadout about the value i. If scale=TRUE, all values are scaled to 0-1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>factor_spreadout spreads out the data at each factor level. It returns a list with two components. The first is data, containing the spreadout data, scaled to 0-1. The second is bars, which is a list whose ith component gives the bottom and top of the bars for the ith variable of d.
</p>
<p>rater_spreadout spreads out the data at each rater level. It returns a list with two components. The first is data, containing the spreadout data. If scale=FALSE, the ith rater values are spreadout about the value i. If scale=TRUE, all values are scaled to 0-1. The second component is bars, which is a list whose ith component gives the bottom and top of the bars for the ith variable of d.
</p>

<hr>
<h2 id='table_plot'> Plots rectangles on a grid </h2><span id='topic+table_plot'></span>

<h3>Description</h3>

<p>Plots rectangles on a grid-  a barchart/mosaic variant which facilitates pairwise comparisons.</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_plot(rectw, recth, col="grey50", gapx = NULL, gapy = NULL, 
spacex = 0.03, spacey = 0.03, xjust = "center", yjust = "center", 
xruler = NULL, yruler = NULL, color.ruler = "grey32",
pch0=1,xlab=NULL,ylab=NULL, plot=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_plot_+3A_rectw">rectw</code></td>
<td>
<p> An n*m matrix of  rectangle widths, or a vector of m column widths. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_recth">recth</code></td>
<td>
<p> An n*m  matrix of  rectangle heights, or a vector of n row heights.</p>
</td></tr>
<tr><td><code id="table_plot_+3A_col">col</code></td>
<td>
<p> Rectangle fill colours. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_gapx">gapx</code></td>
<td>
<p> Gaps in the x-direction. If provided should be a vector of length m-1. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_gapy">gapy</code></td>
<td>
<p> Gaps in the x-direction. If provided should be a vector of length n-1. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_spacex">spacex</code></td>
<td>
<p> A single value- extra space between columns as a fraction of maximum row total of rectw .</p>
</td></tr>
<tr><td><code id="table_plot_+3A_spacey">spacey</code></td>
<td>
<p> A single value- extra space between rows as a fraction of maximum column total of recth . </p>
</td></tr>
<tr><td><code id="table_plot_+3A_xjust">xjust</code></td>
<td>
<p>Horizontal justification of rectangles- &quot;center&quot;, &quot;left&quot;, or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="table_plot_+3A_yjust">yjust</code></td>
<td>
<p> Vertical justification of rectangles- &quot;center&quot;, &quot;bottom&quot;, or &quot;top&quot;.</p>
</td></tr>
<tr><td><code id="table_plot_+3A_xruler">xruler</code></td>
<td>
<p>Specifies position of rulers drawn parallel to x-axis. Values are a subset of (&quot;top&quot;,&quot;center&quot;,&quot;bottom&quot;)</p>
</td></tr>
<tr><td><code id="table_plot_+3A_yruler">yruler</code></td>
<td>
<p> Specifies position of rulers drawn parallel to y-axis. Values are a subset of (&quot;left&quot;,&quot;center&quot;,&quot;right&quot;) </p>
</td></tr>
<tr><td><code id="table_plot_+3A_color.ruler">color.ruler</code></td>
<td>
<p> Color for the rulers. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_pch0">pch0</code></td>
<td>
<p> Symbol for zero cell size. May be NULL. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_xlab">xlab</code></td>
<td>
<p> X label </p>
</td></tr>
<tr><td><code id="table_plot_+3A_ylab">ylab</code></td>
<td>
<p> Y label </p>
</td></tr>
<tr><td><code id="table_plot_+3A_plot">plot</code></td>
<td>
<p> If TRUE, draw tge plot. Otherwise returns a matrix where each row is the coordinates of a the calculated rectangle. </p>
</td></tr>
<tr><td><code id="table_plot_+3A_...">...</code></td>
<td>
<p> Passed to plot. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Catherine Hurley</p>


<h3>References</h3>

<p>See <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p> See also <code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="graphics.html#topic+mosaicplot">mosaicplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(PairViz) 	
		
tab &lt;- apply(HairEyeColor, c(1, 2), sum)


dev.new()
par(mar=c(3,3,1,1))
par(cex=.6,mgp=c(2, -.5, 0))
table_plot(sqrt(tab),sqrt(tab))
# this table plot has cells with widths and heights proportional to the square root of cell counts.

tabp &lt;- prop.table(tab,2)

table_plot(apply(tab,2,sum),tabp) # make cell widths proportional to 
#margin totals, heights to conditional prob

cols &lt;- 2:5
table_plot(apply(tab,2,sum),tabp, yjust="bottom",col=cols,yruler=c("left","right")) 
# add colours, rulers and  bottom-justify

# The result is similar to the mosaic, without the mosaic effect of equalizing gaps. 
#In the table version the rectangles line up across rows, 
#so comparing heights, ie. conditional probs is easier.

o &lt;- hpaths(1:4)[2,]
table_plot(apply(tab,2,sum)[o],tabp[,o], yjust="bottom",col=cols,yruler=c("left","right"))
# Permutes the columns so all pairs of columns can be compared. 
#In the second permutation can easily see that   
#p(black|blue eyes)&gt; p(black|green eyes)


dev.new()
par(mar=c(3,3,1,1))
par(mgp=c(2, -.5, 0))
mosaicplot(t(tab)[,nrow(tab):1],col=rev(cols),main="")
# mosaic- good for seeing deviations from independence. hard to compare conditional probs,
# except for those in the bottom and top rows. 

## End(Not run)
	
</code></pre>

<hr>
<h2 id='weighted_hpaths'>Constructs weight decreasing hamiltonian paths </h2><span id='topic+weighted_hpaths'></span>

<h3>Description</h3>

<p>Returns a modified version of <code>paths</code>, where 
component paths/cycles are re-oriented so low weight edges occur first, and the component paths/cycles are then permuted so low-weight paths are first. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_hpaths(d, path1 = NULL, paths=NULL, matrix=TRUE, cycle=NULL, 
path_weight=sum, path_dir = path_cor,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_hpaths_+3A_d">d</code></td>
<td>
<p>A <code>dist</code>, used to provide edge weights.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_path1">path1</code></td>
<td>
<p>A vector giving a hamiltonian. 
This will be the first path of the returned hamiltonian. The default is obtained from <code>order_tsp</code>.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_paths">paths</code></td>
<td>
<p>A matrix where each row is a hamiltonian. Default comes from <code>hpaths</code>.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_matrix">matrix</code></td>
<td>
<p>if <code>TRUE</code>, returns a matrix where each row is a hamiltonian 
path, otherwise concatenates the rows into a vector. For odd <code>n</code>, the starting node is appended to close the eulerian.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_cycle">cycle</code></td>
<td>
<p>If <code>TRUE</code>, the <code>weighted_hpaths</code> algorithm evaluates 
<code>path_weight</code> on  hamiltonian cycles, if <code>FALSE</code>, on open hamiltonian paths.
Default  is <code>TRUE</code> for odd n and <code>FALSE</code> for even <code>n</code>.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_path_weight">path_weight</code></td>
<td>
<p>A function used  combine path weights into a single value. Default function is <code><a href="#topic+path_cor">path_cor</a></code>.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_path_dir">path_dir</code></td>
<td>
<p>A function used  to evaluate a path start and orientation.</p>
</td></tr>
<tr><td><code id="weighted_hpaths_+3A_...">...</code></td>
<td>
<p>passed to <code>path_weight</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>path</code> is not provided, find the hamiltonian (path for even n, cycle for odd n) with the smallest total 
weight. Applying <code>path_dir</code> to edge weights, pick the  starting and point orientation for path1 giving the largest <code>path_dir</code> value. (For open paths, there are only two possible starts, for cycles there are n). 
Apply this node labelling to the  hamiltonians in the  rows of paths. 
Use criterion <code>path_dir</code>  again to find the best orientation for each of rows 2... of paths and
permute these rows in order of increasing <code>path_weight</code>.
</p>


<h3>Author(s)</h3>

<p> C.B. Hurley and R.W. Oldford </p>


<h3>References</h3>

<p>see <a href="#topic+overview">overview</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hpaths">hpaths</a></code>, <code><a href="#topic+eulerian">eulerian</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(PairViz)

weighted_hpaths(dist(rnorm(6)))

weighted_hpaths(dist(rnorm(7)))



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
