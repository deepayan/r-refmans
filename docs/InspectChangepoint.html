<!DOCTYPE html><html lang="en"><head><title>Help for package InspectChangepoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {InspectChangepoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute.threshold'><p>Computing threshold used in <code>inspect</code></p></a></li>
<li><a href='#cusum.transform'><p>CUSUM transformation</p></a></li>
<li><a href='#cusum.transform.missing'><p>MissCUSUM transformation of a matrix with missing entries</p></a></li>
<li><a href='#cusum.univariate.missing'><p>MissCUSUM transformation of a single vector with missing entries</p></a></li>
<li><a href='#inspect'><p>Informative sparse projection for estimation of changepoints (inspect)</p></a></li>
<li><a href='#locate.change'><p>Single changepoint estimation</p></a></li>
<li><a href='#locate.change.missing'><p>Single changepoint estimation with missing data</p></a></li>
<li><a href='#multi.change'><p>Generating a high-dimensional time series with multiple changepoints</p></a></li>
<li><a href='#PiS'><p>Matrix projection onto the nuclear norm unit sphere</p></a></li>
<li><a href='#PiW'><p>Projection onto the standard simplex</p></a></li>
<li><a href='#plot.hdchangeseq'><p>Plot function for 'hdchangeseq' class</p></a></li>
<li><a href='#plot.inspect'><p>Plot function for 'inspect' class objects</p></a></li>
<li><a href='#print.inspect'><p>Print function for 'inspect' class objects</p></a></li>
<li><a href='#printPercentage'><p>Print percentage</p></a></li>
<li><a href='#random.UnitVector'><p>Generate a random unit vectors in R^n</p></a></li>
<li><a href='#rescale.variance'><p>Noise standardisation for multivariate time series.</p></a></li>
<li><a href='#single.change'><p>Generating high-dimensional time series with exactly one change in the mean</p>
structure</a></li>
<li><a href='#sparse.svd'><p>Computing the sparse leading left singular vector of a matrix</p></a></li>
<li><a href='#sparse.svd.missing'><p>Computing the sparse leading left singular vector of a matrix with missing entries</p></a></li>
<li><a href='#summary.inspect'><p>Summary function for 'inspect' class objects</p></a></li>
<li><a href='#vector.clip'><p>Clipping a vector from above and below</p></a></li>
<li><a href='#vector.norm'><p>Norm of a vector</p></a></li>
<li><a href='#vector.normalise'><p>Normalise a vector</p></a></li>
<li><a href='#vector.soft.thresh'><p>Soft thresholding a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Changepoint Estimation via Sparse Projection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Tengyao Wang, Bertille Follain and Richard Samworth</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tengyao Wang &lt;t.wang59@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RSpectra</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a data-driven projection-based method for estimating changepoints in high-dimensional time series. Multiple changepoints are estimated using a (wild) binary segmentation scheme.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-17 11:46:42 UTC; wangt60</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-03 07:00:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute.threshold'>Computing threshold used in <code>inspect</code></h2><span id='topic+compute.threshold'></span>

<h3>Description</h3>

<p>The threshold level to be used in <code>inspect</code> is computed via Monte Carlo simulation of multivariate time series that do not contain any changepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold(n, p, nrep = 100, show_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.threshold_+3A_n">n</code></td>
<td>
<p>Time length of the observation.</p>
</td></tr>
<tr><td><code id="compute.threshold_+3A_p">p</code></td>
<td>
<p>Dimension of the multivariate time series.</p>
</td></tr>
<tr><td><code id="compute.threshold_+3A_nrep">nrep</code></td>
<td>
<p>Number of Monte Carlo repetition to be used.</p>
</td></tr>
<tr><td><code id="compute.threshold_+3A_show_progress">show_progress</code></td>
<td>
<p>whether to show the progress of Monte Carlo simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the threshold level that should be used based on the Monte Carlo simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute.threshold(n=200, p=50)
</code></pre>

<hr>
<h2 id='cusum.transform'>CUSUM transformation</h2><span id='topic+cusum.transform'></span>

<h3>Description</h3>

<p>Performing CUSUM transformation to the input matrix of multivariate time series. If the input is a vector, it is treated as a matrix of one row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusum.transform(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cusum.transform_+3A_x">x</code></td>
<td>
<p>input matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any integers p and n, the CUSUM transformation <code class="reqn">T_{p,n}: R^{p\times n}\to R^{p\times (n-1)}</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">
   [T_{p,n}(M)]_{j,t} := \sqrt{t(n-t)/n}\biggl(\frac{1}{n-t}\sum_{r=t+1}^n M_{j,r} - \frac{1}{t}\sum_{r=1}^t M_{j,r}\biggr).
</code>
</p>



<h3>Value</h3>

<p>The transformed matrix is returned. Note that the returned matrix has the same number of rows but one fewer columns compared with the input matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(20),4,5)
cusum.transform(x)
</code></pre>

<hr>
<h2 id='cusum.transform.missing'>MissCUSUM transformation of a matrix with missing entries</h2><span id='topic+cusum.transform.missing'></span>

<h3>Description</h3>

<p>MissCUSUM transformation of a matrix with missing entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusum.transform.missing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cusum.transform.missing_+3A_x">x</code></td>
<td>
<p>a matrix with missing entries represented by NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MissCUSUM transformed matrix
</p>

<hr>
<h2 id='cusum.univariate.missing'>MissCUSUM transformation of a single vector with missing entries</h2><span id='topic+cusum.univariate.missing'></span>

<h3>Description</h3>

<p>MissCUSUM transformation of a single vector with missing entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusum.univariate.missing(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cusum.univariate.missing_+3A_x">x</code></td>
<td>
<p>a vector with missing entries represented by NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MissCUSUM transformed vector
</p>

<hr>
<h2 id='inspect'>Informative sparse projection for estimation of changepoints (inspect)</h2><span id='topic+inspect'></span>

<h3>Description</h3>

<p>This is the main function of the package InspectChangepoint. The function <code>inspect</code> estimates the locations of multiple changepoints in the mean structure of a multivariate time series. Multiple changepoints are estimated using a (wild) binary segmentation scheme, whereas each segmentation step uses the <code><a href="#topic+locate.change">locate.change</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(
  x,
  lambda,
  threshold,
  schatten = c(1, 2),
  M,
  missing_data = "auto",
  show_progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p>The input data matrix of a high-dimensional time series, with each component time series stored as a row.</p>
</td></tr>
<tr><td><code id="inspect_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter used in <code><a href="#topic+locate.change">locate.change</a></code>.  If no value is supplied, the dafault value is chosen to be log(log(n)*p/2), where p and n are the number of rows and columns of the data matrix x respectively.</p>
</td></tr>
<tr><td><code id="inspect_+3A_threshold">threshold</code></td>
<td>
<p>Threshold level for testing whether an identified changepoint is a true changepoint. If no value is supplied, the threshold level is computed via Monte Carlo simulation of 100 repetitions from the null model.</p>
</td></tr>
<tr><td><code id="inspect_+3A_schatten">schatten</code></td>
<td>
<p>The Schatten norm constraint to use in the <code><a href="#topic+locate.change">locate.change</a></code> function. Default is schatten = 2, i.e. a Frobenius norm constraint.</p>
</td></tr>
<tr><td><code id="inspect_+3A_m">M</code></td>
<td>
<p>The Monte Carlo parameter used for wild binary segmentation. Default is M = 0, which means a classical binary segmentation scheme is used.</p>
</td></tr>
<tr><td><code id="inspect_+3A_missing_data">missing_data</code></td>
<td>
<p>How missing data in x should be handled. If missing_data='meanImpute', then missing data are imputed with row means; if 'MissInspect', use the MissInspect algorithm of Follain et al. (2022)' if 'auto', the program will make the choice depending on the amount of missingness.</p>
</td></tr>
<tr><td><code id="inspect_+3A_show_progress">show_progress</code></td>
<td>
<p>whether to display progress of computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input time series is first standardised using the <code><a href="#topic+rescale.variance">rescale.variance</a></code> function. Recursive calls of the <code><a href="#topic+locate.change">locate.change</a></code> function then segments the multivariate time series using (wild) binary segmentation. A changepoint at time z is defined here to mean that the time series has constant mean structure for time up to and including z and constant mean structure for time from z+1 onwards.
</p>
<p>More details about model assumption and theoretical guarantees can be found in Wang and Samworth (2016). Note that Monte Carlo computation of the threshold value can be slow, especially for large p. If <code>inspect</code> is to be used multiple times with the same (or similar) data matrix size, it is better to precompute the threshold level via Monte Carlo simulation by calling the <code><a href="#topic+compute.threshold">compute.threshold</a></code> function.
</p>


<h3>Value</h3>

<p>The return value is an S3 object of class 'inspect'. It contains a list of two objeccts:
</p>

<ul>
<li><p>x The input data matrix
</p>
</li>
<li><p>changepoints A matrix with three columns. The first column contains the locations of estimated changepoints sorted in increasing order; the second column contains the maximum CUSUM statistics of the projected univariate time series associated with each estimated changepoint; the third column contains the depth of binary segmentation for each detected changepoint.
</p>
</li></ul>



<h3>References</h3>

<p>Wang, T. and Samworth, R. J. (2018) High dimensional changepoint estimation via sparse projection. <em>J. Roy. Statist. Soc., Ser. B</em>, <strong>80</strong>, 57&ndash;83.
Follain, B., Wang, T. and Samworth R. J. (2022) High-dimensional changepoint estimation with heterogeneous missingness. <em>J. Roy. Statist. Soc., Ser. B</em>, to appear
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500; p &lt;- 100; ks &lt;- 30; zs &lt;- c(125,250,375)
varthetas &lt;- c(0.2,0.4,0.6); overlap &lt;- 0.5
obj &lt;- multi.change(n, p, ks, zs, varthetas, overlap)
x &lt;- obj$x
threshold &lt;- compute.threshold(n,p)
ret &lt;- inspect(x, threshold = threshold)
ret
summary(ret)
plot(ret)
</code></pre>

<hr>
<h2 id='locate.change'>Single changepoint estimation</h2><span id='topic+locate.change'></span>

<h3>Description</h3>

<p>Estimate the location of one changepoint in a multivariate time
series. It uses the function <code><a href="#topic+sparse.svd">sparse.svd</a></code> to estimate the best
projection direction, then using univariate CUSUM statistics of the projected
time series to estimate the changepoint location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate.change(
  x,
  lambda,
  schatten = 2,
  sample.splitting = FALSE,
  standardize.series = FALSE,
  view.cusum = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate.change_+3A_x">x</code></td>
<td>
<p>A (p x n) data matrix of multivariate time series, each column
represents a data point</p>
</td></tr>
<tr><td><code id="locate.change_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter. If no value is supplied, the dafault
value is chosen to be sqrt(log(log(n)*p/2)) for p and n number of rows and
columns of the data matrix x respectively.</p>
</td></tr>
<tr><td><code id="locate.change_+3A_schatten">schatten</code></td>
<td>
<p>The Schatten norm constraint to use in the <code><a href="#topic+sparse.svd">sparse.svd</a></code>
function. Default is schatten = 2, i.e. a Frobenius norm constraint.</p>
</td></tr>
<tr><td><code id="locate.change_+3A_sample.splitting">sample.splitting</code></td>
<td>
<p>Whether the changepoint should be estimated via
sample splitting. The theoretical result is proven only for the sample
splitted version of the algorithm. However, the default setting in practice
is without sample splitting.</p>
</td></tr>
<tr><td><code id="locate.change_+3A_standardize.series">standardize.series</code></td>
<td>
<p>Whether the given time series should be
standardised before estimating the projection direction. Default is FALSE,
i.e. the input series is assume to have variance 1 in each coordinate.</p>
</td></tr>
<tr><td><code id="locate.change_+3A_view.cusum">view.cusum</code></td>
<td>
<p>Whether to show a plot of the projected CUSUM series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two items:
</p>

<ul>
<li><p> changepoint - A single integer value estimate of the changepoint
location is returned. If the estimated changepoint is z, it means that the
multivariate time series is piecewise constant up to z and from z+1
onwards.
</p>
</li>
<li><p> cusum - The maximum absolute CUSUM statistic of the projected
univariate time series associated with the estimated changepoint.
</p>
</li>
<li><p> vector.proj - the vector of projection, which is proportional to an estimate of the vector of change.
</p>
</li></ul>



<h3>References</h3>

<p>Wang, T., Samworth, R. J. (2016) High-dimensional changepoint estimation via sparse projection. Arxiv preprint: arxiv1606.06246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000; p &lt;- 1000; k &lt;- 32; z &lt;- 400; vartheta &lt;- 0.12; sigma &lt;- 1; shape &lt;- 3
noise &lt;- 0; corr &lt;- 0
obj &lt;- single.change(n,p,k,z,vartheta,sigma,shape,noise,corr)
x &lt;- obj$x
locate.change(x)
</code></pre>

<hr>
<h2 id='locate.change.missing'>Single changepoint estimation with missing data</h2><span id='topic+locate.change.missing'></span>

<h3>Description</h3>

<p>Single changepoint estimation with missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate.change.missing(
  x,
  lambda,
  standardize.series = FALSE,
  view.cusum = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate.change.missing_+3A_x">x</code></td>
<td>
<p>A (p x n) data matrix of multivariate time series, each column
represents a data point</p>
</td></tr>
<tr><td><code id="locate.change.missing_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter. If no value is supplied, the dafault
value is chosen to be sqrt(log(log(n)*p/2)) for p and n number of rows and
columns of the data matrix x respectively.</p>
</td></tr>
<tr><td><code id="locate.change.missing_+3A_standardize.series">standardize.series</code></td>
<td>
<p>Whether the given time series should be
standardised before estimating the projection direction. Default is FALSE,
i.e. the input series is assume to have variance 1 in each coordinate.</p>
</td></tr>
<tr><td><code id="locate.change.missing_+3A_view.cusum">view.cusum</code></td>
<td>
<p>Whether to show a plot of the projected CUSUM series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two items:
</p>

<ul>
<li><p> changepoint - A single integer value estimate of the changepoint
location is returned. If the estimated changepoint is z, it means that the
multivariate time series is piecewise constant up to z and from z+1
onwards.
</p>
</li>
<li><p> cusum - The maximum absolute CUSUM statistic of the projected
univariate time series associated with the estimated changepoint.
</p>
</li>
<li><p> vector.proj - the vector of projection, which is proportional to an estimate of the vector of change.
</p>
</li></ul>



<h3>References</h3>

<p>Wang, T., Samworth, R. J. (2016) High-dimensional changepoint estimation via sparse projection. Arxiv preprint: arxiv1606.06246.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000; p &lt;- 1000; k &lt;- 32; z &lt;- 400; vartheta &lt;- 0.12; sigma &lt;- 1; shape &lt;- 3
noise &lt;- 0; corr &lt;- 0
obj &lt;- single.change(n,p,k,z,vartheta,sigma,shape,noise,corr)
x &lt;- obj$x
locate.change(x)
</code></pre>

<hr>
<h2 id='multi.change'>Generating a high-dimensional time series with multiple changepoints</h2><span id='topic+multi.change'></span>

<h3>Description</h3>

<p>The data matrix is generated via X = mu + W, where mu is the mean structure matrix that captures the changepoint locations and sparsity structure, and W is a random noise matrix having independent N(0,sigma^2) entries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.change(n, p, ks, zs, varthetas, sigma = 1, overlap = 0, shape = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi.change_+3A_n">n</code></td>
<td>
<p>Time length of the observation</p>
</td></tr>
<tr><td><code id="multi.change_+3A_p">p</code></td>
<td>
<p>Dimension of the multivariate time series</p>
</td></tr>
<tr><td><code id="multi.change_+3A_ks">ks</code></td>
<td>
<p>A vector describing the number of coordinates that undergo a change in each changepoint. If only a scalar is supplied, each changepoint will have the same number of coordinates that undergo a change.</p>
</td></tr>
<tr><td><code id="multi.change_+3A_zs">zs</code></td>
<td>
<p>A vector describing the locations of the changepoints.</p>
</td></tr>
<tr><td><code id="multi.change_+3A_varthetas">varthetas</code></td>
<td>
<p>A vector describing the root mean squared change magnitude in coordinates that undergo a change for each changepoint. If only a scalar is supplied, each changepoint will have the same signal strength value.</p>
</td></tr>
<tr><td><code id="multi.change_+3A_sigma">sigma</code></td>
<td>
<p>noise level</p>
</td></tr>
<tr><td><code id="multi.change_+3A_overlap">overlap</code></td>
<td>
<p>A number between 0 and 1. The proportion of overlap in the signal coordinates for successive changepoints.</p>
</td></tr>
<tr><td><code id="multi.change_+3A_shape">shape</code></td>
<td>
<p>How the signal strength is distributed across signal coordinates. When shape = 0, all signal coordinates are changed by the same amount; when shape = 1, their signal strength are proportional to 1, sqrt(2), ..., sqrt(k); when shape = 2, they are proportional to 1, 2, ..., k; when shape = 3, they are proportional to 1, 1/sqrt(2), ..., 1/sqrt(k).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of the class 'hdchangeseq' is returned.
</p>

<ul>
<li><p> x - The generated data matrix
</p>
</li>
<li><p> mu - The mean structure of the data matrix
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot.hdchangeseq">plot.hdchangeseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000; p &lt;- 200; ks &lt;- 40;
zs &lt;- c(500,1000,1500); varthetas &lt;- c(0.1,0.15,0.2); overlap &lt;- 0.5
obj &lt;- multi.change(n, p, ks, zs, varthetas, overlap)
plot(obj, noise = TRUE)
</code></pre>

<hr>
<h2 id='PiS'>Matrix projection onto the nuclear norm unit sphere</h2><span id='topic+PiS'></span>

<h3>Description</h3>

<p>Projection (with respect to the inner product defined by the Frobenius norm) of a matrix onto the unit sphere defined by the nuclear norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PiS(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PiS_+3A_m">M</code></td>
<td>
<p>Input matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an auxiliary function used by the <code>InspectChangepoint</code> package. The projection is achieved by first performing a singular value decomposition, then projecting the vector of singular values onto the standard simplex, and finally using singular value decomposition in reverse to build the projected matrix.
</p>


<h3>Value</h3>

<p>A matrix of the same dimension as the input is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rnorm(20),4,5)
PiS(M)
</code></pre>

<hr>
<h2 id='PiW'>Projection onto the standard simplex</h2><span id='topic+PiW'></span>

<h3>Description</h3>

<p>The input vector is projected onto the standard simplex, i.e. the set of vectors of the same length as the input vector with non-negative entries that sum to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PiW(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PiW_+3A_v">v</code></td>
<td>
<p>Input vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an auxiliary function used by the <code>InspectChangepoint</code> package.
</p>


<h3>Value</h3>

<p>A vector in the standard simplex that is closest to the input vector is returned.
</p>


<h3>References</h3>

<p>Chen, Y. and Ye, X. (2011) Projection onto a simplex. arXiv preprint, arxiv:1101.6081.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- rnorm(10)
PiW(v)
</code></pre>

<hr>
<h2 id='plot.hdchangeseq'>Plot function for 'hdchangeseq' class</h2><span id='topic+plot.hdchangeseq'></span>

<h3>Description</h3>

<p>Visualising the high-dimensional time series in an 'hdchangeseq' class object. The data matrix or its mean structure is visualised using a grid of coloured rectangles with colours corresponding to the value contained in corresponding coordinates. A heat-spectrum (red to white for values low to high) is used to convert values to colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdchangeseq'
plot(x, noise = TRUE, shuffle = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hdchangeseq_+3A_x">x</code></td>
<td>
<p>An object of 'hdchangeseq' class</p>
</td></tr>
<tr><td><code id="plot.hdchangeseq_+3A_noise">noise</code></td>
<td>
<p>If noise == TRUE, the data matrix is plotted, otherwise, only the mean structure is plotted.</p>
</td></tr>
<tr><td><code id="plot.hdchangeseq_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to shuffle the rows of the plotted matrix.</p>
</td></tr>
<tr><td><code id="plot.hdchangeseq_+3A_...">...</code></td>
<td>
<p>Other graphical parameters are not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000; p &lt;- 200; ks &lt;- 40; zs &lt;- c(500,1000,1500)
varthetas &lt;- c(0.1,0.15,0.2); overlap &lt;- 0.5
obj &lt;- multi.change(n, p, ks, zs, varthetas, overlap)
plot(obj, noise = TRUE)
</code></pre>

<hr>
<h2 id='plot.inspect'>Plot function for 'inspect' class objects</h2><span id='topic+plot.inspect'></span>

<h3>Description</h3>

<p>Plot function for 'inspect' class objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.inspect_+3A_x">x</code></td>
<td>
<p>an 'inspect' class object</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods are not used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inspect">inspect</a></code>
</p>

<hr>
<h2 id='print.inspect'>Print function for 'inspect' class objects</h2><span id='topic+print.inspect'></span>

<h3>Description</h3>

<p>Print function for 'inspect' class objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.inspect_+3A_x">x</code></td>
<td>
<p>an 'inspect' class object</p>
</td></tr>
<tr><td><code id="print.inspect_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods are not used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inspect">inspect</a></code>
</p>

<hr>
<h2 id='printPercentage'>Print percentage</h2><span id='topic+printPercentage'></span>

<h3>Description</h3>

<p>Print percentage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printPercentage(ind, tot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printPercentage_+3A_ind">ind</code></td>
<td>
<p>a vector of for loop interator</p>
</td></tr>
<tr><td><code id="printPercentage_+3A_tot">tot</code></td>
<td>
<p>a vector of for loop lengths</p>
</td></tr>
</table>


<h3>Value</h3>

<p>on screen output of percentage
</p>

<hr>
<h2 id='random.UnitVector'>Generate a random unit vectors in R^n</h2><span id='topic+random.UnitVector'></span>

<h3>Description</h3>

<p>Generate a random unit vectors in R^n
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.UnitVector(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random.UnitVector_+3A_n">n</code></td>
<td>
<p>length of random vector</p>
</td></tr>
</table>

<hr>
<h2 id='rescale.variance'>Noise standardisation for multivariate time series.</h2><span id='topic+rescale.variance'></span>

<h3>Description</h3>

<p>Each row of the input matrix is normalised by the estimated standard deviation computed through the median absolute deviation of increments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale.variance(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale.variance_+3A_x">x</code></td>
<td>
<p>An input matrix of real values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an auxiliary function used by the <code>InspectChangepoint</code> package.
</p>


<h3>Value</h3>

<p>A rescaled matrix of the same size is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(40),5,8) * (1:5)
x.rescaled &lt;- rescale.variance(x)
x.rescaled
</code></pre>

<hr>
<h2 id='single.change'>Generating high-dimensional time series with exactly one change in the mean
structure</h2><span id='topic+single.change'></span>

<h3>Description</h3>

<p>The data matrix is generated via X = mu + W, where mu is the mean structure matrix that captures the changepoint location and sparsity structure, and W is a random noise matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.change(n, p, k, z, vartheta, sigma = 1, shape = 3, noise = 0, corr = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single.change_+3A_n">n</code></td>
<td>
<p>Time length of the observation</p>
</td></tr>
<tr><td><code id="single.change_+3A_p">p</code></td>
<td>
<p>Dimension of the multivariate time series</p>
</td></tr>
<tr><td><code id="single.change_+3A_k">k</code></td>
<td>
<p>Number of coordinates that undergo a change</p>
</td></tr>
<tr><td><code id="single.change_+3A_z">z</code></td>
<td>
<p>Changepoint location, a number between 1 and n-1.</p>
</td></tr>
<tr><td><code id="single.change_+3A_vartheta">vartheta</code></td>
<td>
<p>The root mean squared change magnitude in coordinates that undergo a change</p>
</td></tr>
<tr><td><code id="single.change_+3A_sigma">sigma</code></td>
<td>
<p>noise level, see <code>noise</code> for more details.</p>
</td></tr>
<tr><td><code id="single.change_+3A_shape">shape</code></td>
<td>
<p>How the signal strength is distributed across signal coordinates. When shape = 0, all signal coordinates are changed by the same amount; when shape = 1, their signal strength are proportional to 1, sqrt(2), ..., sqrt(k); when shape = 2, they are proportional to 1, 2, ..., k; when shape = 3, they are proportional to 1, 1/sqrt(2), ..., 1/sqrt(k).</p>
</td></tr>
<tr><td><code id="single.change_+3A_noise">noise</code></td>
<td>
<p>Noise structure of the multivarite time series. For noise = 0, 0.5, 1, columns of W have independent multivariate normal distribution with covariance matrix Sigma. When noise = 0, Sigma = sigma^2 * I_p; when noise = 0.5, noise has local dependence structure given by Sigma_i,j = sigma*corr^|i-j|; when noise = 1, noise has global dependence structure given by matrix(corr,p,p)+diag(p)*(1-corr))) * sigma. When noise = 2, rows of the W are independent and each having an AR(1) structure given by W_j,t = W_j,t-1 * sqrt(corr) + rnorm(sd = sigma) * sqrt(1-corr). For noise = 3, 4, entries of W have i.i.d. uniform distribution and exponential distribution respectively, each centred and rescaled to have zero mean and variance sigma^2.</p>
</td></tr>
<tr><td><code id="single.change_+3A_corr">corr</code></td>
<td>
<p>Used to specify correlation structure in the noise. See <code>noise</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of the class 'hdchangeseq' is returned.
</p>

<ul>
<li><p> x - The generated data matrix
</p>
</li>
<li><p> mu - The mean structure of the data matrix
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot.hdchangeseq">plot.hdchangeseq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000; p &lt;- 100; k &lt;- 10; z &lt;- 800; vartheta &lt;- 1; sigma &lt;- 1
shape &lt;- 3; noise &lt;- 0; corr &lt;- 0
obj &lt;- single.change(n,p,k,z,vartheta,sigma, shape, noise, corr)
plot(obj, noise = TRUE)
</code></pre>

<hr>
<h2 id='sparse.svd'>Computing the sparse leading left singular vector of a matrix</h2><span id='topic+sparse.svd'></span>

<h3>Description</h3>

<p>Estimating the sparse left leading singular vector by first computing a maximiser Mhat of the convex problem
</p>
<p style="text-align: center;"><code class="reqn">&lt;Z, M&gt; - \lambda |M|_1</code>
</p>

<p>subject to the Schatten norm constraint |M|_schatten &lt;= 1 using alternating direction method of multipliers (ADMM). Then the leading left singular vector of Mhat is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.svd(Z, lambda, schatten = c(1, 2), max.iter = 1000, tolerance = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse.svd_+3A_z">Z</code></td>
<td>
<p>Input matrix whose left leading singular vector is to be estimated.</p>
</td></tr>
<tr><td><code id="sparse.svd_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter</p>
</td></tr>
<tr><td><code id="sparse.svd_+3A_schatten">schatten</code></td>
<td>
<p>Schatten norm constraint to be used. Default uses Schatten-2-norm, i.e. the Frobenius norm. Also possible to use Schatten-1-norm, the nuclear norm.</p>
</td></tr>
<tr><td><code id="sparse.svd_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum iteration for ADMM, only used if schatten=1</p>
</td></tr>
<tr><td><code id="sparse.svd_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance level for convergence checking, only used if schatten=1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of schatten = 2, a closed-form solution for Mhat using matrix soft thresholding is possible. We use the closed-form solution instead of the ADMM algorithm to speed up the computation.
</p>


<h3>Value</h3>

<p>A vector that has the same length as nrow(Z) is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- matrix(rnorm(20),4,5)
lambda &lt;- 0.5
sparse.svd(Z, lambda)
</code></pre>

<hr>
<h2 id='sparse.svd.missing'>Computing the sparse leading left singular vector of a matrix with missing entries</h2><span id='topic+sparse.svd.missing'></span>

<h3>Description</h3>

<p>Computing the sparse leading left singular vector of a matrix with missing entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.svd.missing(Z, lambda, max_iter = 1000, tol = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse.svd.missing_+3A_z">Z</code></td>
<td>
<p>Input matrix whose left leading singular vector is to be estimated.</p>
</td></tr>
<tr><td><code id="sparse.svd.missing_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter</p>
</td></tr>
<tr><td><code id="sparse.svd.missing_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum iteration</p>
</td></tr>
<tr><td><code id="sparse.svd.missing_+3A_tol">tol</code></td>
<td>
<p>tolerance level for convergence</p>
</td></tr>
</table>

<hr>
<h2 id='summary.inspect'>Summary function for 'inspect' class objects</h2><span id='topic+summary.inspect'></span>

<h3>Description</h3>

<p>Summary function for 'inspect' class objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.inspect_+3A_object">object</code></td>
<td>
<p>an 'inspect' class object</p>
</td></tr>
<tr><td><code id="summary.inspect_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to methods are not used</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inspect">inspect</a></code>
</p>

<hr>
<h2 id='vector.clip'>Clipping a vector from above and below</h2><span id='topic+vector.clip'></span>

<h3>Description</h3>

<p>Clipping vector or matrix x from above and below
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.clip(x, upper = Inf, lower = -upper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector.clip_+3A_x">x</code></td>
<td>
<p>a vector of real numbers</p>
</td></tr>
<tr><td><code id="vector.clip_+3A_upper">upper</code></td>
<td>
<p>clip above this value</p>
</td></tr>
<tr><td><code id="vector.clip_+3A_lower">lower</code></td>
<td>
<p>clip below this value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the entrywise L_q norm of a vector or a matrix
</p>

<hr>
<h2 id='vector.norm'>Norm of a vector</h2><span id='topic+vector.norm'></span>

<h3>Description</h3>

<p>Calculate the entrywise L_q norm of a vector or a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.norm(v, q = 2, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector.norm_+3A_v">v</code></td>
<td>
<p>a vector of real numbers</p>
</td></tr>
<tr><td><code id="vector.norm_+3A_q">q</code></td>
<td>
<p>a nonnegative real number or Inf</p>
</td></tr>
<tr><td><code id="vector.norm_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean, whether to remove NA before calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the entrywise L_q norm of a vector or a matrix
</p>

<hr>
<h2 id='vector.normalise'>Normalise a vector</h2><span id='topic+vector.normalise'></span>

<h3>Description</h3>

<p>Normalise a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.normalise(v, q = 2, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector.normalise_+3A_v">v</code></td>
<td>
<p>a vector of real numbers</p>
</td></tr>
<tr><td><code id="vector.normalise_+3A_q">q</code></td>
<td>
<p>a nonnegative real number or Inf</p>
</td></tr>
<tr><td><code id="vector.normalise_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean, whether to remove NA before calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalised version of this vector
</p>

<hr>
<h2 id='vector.soft.thresh'>Soft thresholding a vector</h2><span id='topic+vector.soft.thresh'></span>

<h3>Description</h3>

<p>entries of v are moved towards 0 by the amount lambda until they hit 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.soft.thresh(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector.soft.thresh_+3A_x">x</code></td>
<td>
<p>a vector of real numbers</p>
</td></tr>
<tr><td><code id="vector.soft.thresh_+3A_lambda">lambda</code></td>
<td>
<p>soft thresholding value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
