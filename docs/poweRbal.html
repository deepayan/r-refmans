<!DOCTYPE html><html><head><title>Help for package poweRbal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poweRbal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#enum2cladewise'><p>Function to modify the node enumeration in rooted binary trees</p></a></li>
<li><a href='#genAldousBetaTree'><p>Generation of rooted binary trees under Aldous' beta splitting model</p></a></li>
<li><a href='#genAltBirthDeathTree'><p>Generation of rooted binary trees under the alternative birth-death model</p></a></li>
<li><a href='#genBiSSETree'><p>Generation of rooted binary trees under the BiSSE model</p></a></li>
<li><a href='#genCombTree'><p>Generation of the comb or caterpillar tree</p></a></li>
<li><a href='#genDensityTree'><p>Generation of rooted binary trees under the density model</p></a></li>
<li><a href='#genETMTree'><p>Generation of rooted binary trees under the equiprobable-types-model (ETM)</p></a></li>
<li><a href='#genFordsAlphaTree'><p>Generation of rooted binary trees under Ford's alpha model</p></a></li>
<li><a href='#genGFBTree'><p>Generation of the greedy from the bottom tree</p></a></li>
<li><a href='#genGrowTree'><p>Generation of rooted binary trees under tree growing models (no extinction)</p></a></li>
<li><a href='#genMBTree'><p>Generation of the maximally balanced tree</p></a></li>
<li><a href='#genPDATree'><p>Generation of rooted binary trees under the PDA model</p></a></li>
<li><a href='#genTrees'><p>Generation of rooted binary trees under a given tree model</p></a></li>
<li><a href='#genYuleTree'><p>Generation of rooted binary trees under the Yule model</p></a></li>
<li><a href='#getAccRegion'><p>Functions for computing the region of acceptance</p></a></li>
<li><a href='#getPowerMultAM'><p>Functions for computing the power</p></a></li>
<li><a href='#getTSSdata'><p>Functions for generating the TSS data under a tree model</p></a></li>
<li><a href='#getTSSnames'><p>Get information on included tree shape statistics</p></a></li>
<li><a href='#powerComp'><p>Comparison of the power of TSS under different models</p></a></li>
<li><a href='#showTSSdata'><p>Functions for displaying TSS distributions and TSS power</p></a></li>
<li><a href='#tssInfo'><p>Tree shape statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Phylogenetic Tree Models and the Power of Tree Shape Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.0.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Sophie Kersting <a href="https://orcid.org/0000-0002-1038-9246"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kristina Wicke <a href="https://orcid.org/0000-0002-4275-5546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mareike Fischer <a href="https://orcid.org/0000-0002-9429-0859"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sophie Kersting &lt;sophie_kersting@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The first goal of this package is to provide a multitude of tree models,
    i.e., functions that generate rooted binary trees with a given number of leaves.
    Second, the package allows for an easy evaluation and comparison of tree shape
    statistics by estimating their power to differentiate between different tree models.
    Please note that this R package was developed alongside the manuscript
    "Tree balance in phylogenetic models" by
    S. J. Kersting, K. Wicke, and M. Fischer (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2406.05185">doi:10.48550/arXiv.2406.05185</a>&gt;,
    which provides further background and the respective mathematical definitions.
    This project was supported by the project ArtIGROW, which is a part of the
    WIR!-Alliance ArtIFARM –  Artificial Intelligence in Farming funded by the
    German Federal Ministry of Education and Research (No. 03WIR4805).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, scales, phytools, treebalance, R.utils, diversitree</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 07:43:47 UTC; Maus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-28 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='enum2cladewise'>Function to modify the node enumeration in rooted binary trees</h2><span id='topic+enum2cladewise'></span>

<h3>Description</h3>

<p><code>enum2cladewise</code> - Changes the node enumeration to cladewise
enumeration, i.e., starting from the root we follow the rule:<br />
Go to the left child; if that does not exist or was already visited go (up
again and) to the right child.<br />
The nodes in the rooted binary tree can be nearly arbitrarily enumerated
(distinct nodes should have distinct values and the
values should be positive, i.e., &gt;0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enum2cladewise(phy, root = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enum2cladewise_+3A_phy">phy</code></td>
<td>
<p>A rooted binary tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="enum2cladewise_+3A_root">root</code></td>
<td>
<p>Integer value (default = NULL) that should only be specified if
the root is known precisely (not necessary, but speeds up computation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>enum2cladewise</code>  A single tree of class <code>phylo</code> is
returned with cladewise node enumeration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with cladewise enumeration:
phy_alreadycladew &lt;- list(edge = matrix(c(6,7, 7,8, 8,1, 8,2,
                                          7,9, 9,3, 9,4, 6,5),
                                 byrow = TRUE, ncol = 2),
                          tip.label = rep(" ",5), Nnode = 4)
attr(phy_alreadycladew, "class") &lt;- "phylo"
enum2cladewise(phy_alreadycladew, root = 6)$edge
ape::plot.phylo(phy_alreadycladew)
# Example with other node enumeration:
phy_example &lt;- list(edge = matrix(c(1,55, 55,12, 12,2, 12,10, 55,9,
                                    9,13, 9,60, 1,3),
                                  byrow = TRUE, ncol = 2),
                    tip.label = rep(" ",5), Nnode = 4,
                    edge.length = rep(1, 8))
attr(phy_example, "class") &lt;- "phylo"
# The reenumeration works with and without specifying the root:
enum2cladewise(phy_example, root = 1)$edge
ape::plot.phylo(enum2cladewise(phy_example))
</code></pre>

<hr>
<h2 id='genAldousBetaTree'>Generation of rooted binary trees under Aldous' beta splitting model</h2><span id='topic+genAldousBetaTree'></span>

<h3>Description</h3>

<p><code>genAldousBetaTree</code> - Generates a rooted binary tree in
<code>phylo</code> format with the given number of <code>n</code> leaves under the
Aldous beta model.
The Aldous beta model is not a rate-based incremental evolutionary (tree)
construction and thus cannot generate edge lengths, only a topology.
Instead, the Aldous beta model works as follows: The idea is to start with
the root and the set of its descendant leaves, i.e., all <code>n</code> leaves.
Then, this set is partitioned into two subsets according to a density
function dependent on the parameter <code>beta</code>.
The two resulting subsets contain the leaves of the two maximal pending
subtrees of the root, respectively. The same procedure is then applied to the
root's children and their respective subsets, and so forth. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAldousBetaTree(n, BETA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genAldousBetaTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genAldousBetaTree_+3A_beta">BETA</code></td>
<td>
<p>Numeric value &gt;=-2 which specifies how the leaf sets
are partitioned. For certain choices of <code>BETA</code> the Aldous beta model
coincides with known models:<br />
</p>

<ul>
<li> <p><code>BETA</code> = 0: Yule model <br />
</p>
</li>
<li> <p><code>BETA</code> = -3/2: PDA model (all phylogenies equally probable) <br />
</p>
</li>
<li> <p><code>BETA</code> = -2: Caterpillar with <code>n</code> leaves
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genAldousBetaTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> D. Aldous. Probability Distributions on Cladograms. In Random Discrete
Structures, pages 1–18. Springer New York, 1996.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genAldousBetaTree(n = 5, BETA = 1)
</code></pre>

<hr>
<h2 id='genAltBirthDeathTree'>Generation of rooted binary trees under the alternative birth-death model</h2><span id='topic+genAltBirthDeathTree'></span>

<h3>Description</h3>

<p><code>genAltBirthDeathTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the alternative
birth-death model.
In the alternative birth-death process all species have the same speciation
<code>BIRTHRATE</code> and extinction rates <code>DEATHRATE</code>. Extinct species
remain as fossils inside the tree with zero speciation and extinction
rates. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAltBirthDeathTree(n, BIRTHRATE = 1, DEATHRATE = 0, TRIES = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genAltBirthDeathTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_birthrate">BIRTHRATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
rate at which the speciation events occur.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_deathrate">DEATHRATE</code></td>
<td>
<p>Positive numeric value (default = 0) which specifies the
rate at which the extinction events occur.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genAltBirthDeathTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genAltBirthDeathTree(n = 7, DEATHRATE = 1)
</code></pre>

<hr>
<h2 id='genBiSSETree'>Generation of rooted binary trees under the BiSSE model</h2><span id='topic+genBiSSETree'></span>

<h3>Description</h3>

<p><code>genBiSSETree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the BiSSE model.
In the BiSSE model all species have a state, either A or B, and depending on
the state a speciation rate <code>BIRTHRATES</code>, an extinction rate
<code>DEATHRATES</code> as well as a transition rate to the other state
<code>TRANSRATES</code>. <br />
Extinct species are removed from the tree, i.e., the generated tree contains
only species living at the present.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBiSSETree(
  n,
  BIRTHRATES = c(1, 1),
  DEATHRATES = c(0, 0),
  TRANSRATES,
  TRIES = 5,
  TIMEperTRY = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genBiSSETree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_birthrates">BIRTHRATES</code></td>
<td>
<p>Numeric vector (default = c(1,1)) which specifies
the speciation rates in state A and B (vector with 2 values &gt;=0, one
value &gt;0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_deathrates">DEATHRATES</code></td>
<td>
<p>Numeric vector (default = c(0,0)) which specifies
the extinction rates in state A and B (vector with 2 values &gt;=0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_transrates">TRANSRATES</code></td>
<td>
<p>Numeric vector which specifies the
transition rates from A to B and from B to A (vector with 2 values &gt;0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_timepertry">TIMEperTRY</code></td>
<td>
<p>Numeric value (default = 0.1) that specifies the maximum
amount of time (in seconds) invested per try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genBiSSETree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>tree.bisse</code> function of the
<code>diversitree</code> package
(R. G. FitzJohn. Diversitree: Comparative Phylogenetic Analyses of
Diversification in R.  Methods in Ecology and
Evolution, 3(6):1084-1092, 2012). <br />
</p>
</li>
<li><p> W. P. Maddison, P. E. Midford, and S. P. Otto. Estimating a binary
character’s effect on speciation and extinction. Systematic Biology,
56(5):701–710, 2007.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("diversitree", quietly = TRUE)) {
genBiSSETree(n = 5, BIRTHRATES = c(1,2), DEATHRATES = c(0,0),
             TRANSRATES = c(0.1,0.3))
}
</code></pre>

<hr>
<h2 id='genCombTree'>Generation of the comb or caterpillar tree</h2><span id='topic+genCombTree'></span>

<h3>Description</h3>

<p><code>genCombTree</code> - Generates the rooted binary comb tree (also known as
caterpillar tree) in <code>phylo</code> format with the given number of <code>n</code>
leaves. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCombTree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCombTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genCombTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> D. Aldous. Probability Distributions on Cladograms. In Random Discrete
Structures, pages 1–18. Springer New York, 1996.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genCombTree(n = 6)
</code></pre>

<hr>
<h2 id='genDensityTree'>Generation of rooted binary trees under the density model</h2><span id='topic+genDensityTree'></span>

<h3>Description</h3>

<p><code>genDensityTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
density-dependent model.
In the density-dependent tree generation process all species have the same
speciation <code>BIRTHRATE</code>, but the extinction rates depend on the
number of species (it increases linearly with the number of co-existing
lineages until an equilibrium number is reached at which speciation and
extinction rates are equal).
Extinct species are removed from the tree, i.e., the generated tree contains
only species living at the present.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genDensityTree(n, BIRTHRATE = 1, EQUILIB, TRIES = 5, TIMEperTRY = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genDensityTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_birthrate">BIRTHRATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
rate at which the speciation events occur.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_equilib">EQUILIB</code></td>
<td>
<p>Integer value that specifies the equilibrium number.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_timepertry">TIMEperTRY</code></td>
<td>
<p>Numeric value (default = 0.01) that specifies the maximum
amount of time (in seconds) invested per try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genDensityTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> P. H. Harvey, R. M. May, and S. Nee. Phylogenies without fossils.
Evolution, 48(3):523–529, 1994.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genDensityTree(n = 5, EQUILIB = 6)
</code></pre>

<hr>
<h2 id='genETMTree'>Generation of rooted binary trees under the equiprobable-types-model (ETM)</h2><span id='topic+genETMTree'></span>

<h3>Description</h3>

<p><code>genETMTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
equiprobable-types-model.
Given <code>n</code>, all tree shapes/topologies with <code>n</code> leaves are
equiprobable under the ETM.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genETMTree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genETMTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genETMTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtree(..., equiprob = T)</code> function of the
<code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genETMTree(n = 5)
</code></pre>

<hr>
<h2 id='genFordsAlphaTree'>Generation of rooted binary trees under Ford's alpha model</h2><span id='topic+genFordsAlphaTree'></span>

<h3>Description</h3>

<p><code>genFordsAlphaTree</code> - Generates a rooted binary tree in
<code>phylo</code> format with the given number of <code>n</code> leaves under Ford's
alpha model.
Ford's alpha model is not a rate-based evolutionary (tree)
construction and thus cannot generate edge lengths, only a topology.
Instead, it works as follows: The idea is to start with a cherry and
incrementally increase the size of the tree by adding a new leaf with
a leaf edge to any edge (inner or leaf edge), one at a time.
Given a tree with i leaves, then each of the i-1 innner edges (includes
an additional root edge) is chosen with probability
<code>ALPHA</code>/(i-<code>ALPHA</code>).
Each of the i leaf edges is chosen with probability
(1-<code>ALPHA</code>)/(i-<code>ALPHA</code>). <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFordsAlphaTree(n, ALPHA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genFordsAlphaTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genFordsAlphaTree_+3A_alpha">ALPHA</code></td>
<td>
<p>Numeric value &gt;=0 and &lt;=1 which specifies the probabilites of
picking an inner or a leaf edge. For certain choices of
<code>ALPHA</code> Ford's alpha model coincides with known models:<br />
</p>

<ul>
<li> <p><code>ALPHA</code> = 0: Yule model <br />
</p>
</li>
<li> <p><code>ALPHA</code> = 1/2: PDA model (all phylogenies equally probable) <br />
</p>
</li>
<li> <p><code>ALPHA</code> = 1: Caterpillar with <code>n</code> leaves
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genFordsAlphaTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> D. J. Ford. Probabilities on cladograms: introduction to the alpha
model, 2005. <br />
</p>
</li>
<li><p> G. Kaur, K. P. Choi, and T. Wu. Distributions of cherries and pitchforks
for the Ford model. Theoretical Population Biology, 149:27–38, 2023.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genFordsAlphaTree(n = 5, ALPHA = 0.3)
</code></pre>

<hr>
<h2 id='genGFBTree'>Generation of the greedy from the bottom tree</h2><span id='topic+genGFBTree'></span>

<h3>Description</h3>

<p><code>genGFBTree</code> - Generates the rooted binary greedy from the bottom  tree
in <code>phylo</code> format with the given number of <code>n</code> leaves. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGFBTree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGFBTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genGFBTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genGFBTree(n = 6)
</code></pre>

<hr>
<h2 id='genGrowTree'>Generation of rooted binary trees under tree growing models (no extinction)</h2><span id='topic+genGrowTree'></span>

<h3>Description</h3>

<p><code>genGrowTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under a specified
discrete-time tree growing model without extinction.
These tree growing models act at the leaves by varying their speciation
rates according to a parameter <code>ZETA</code> or variance <code>SIGMA</code>. They
may also depend on so-called trait values of the leaves (e.g., continuous or
discrete age, or another numeric trait that affects fitness).<br />
You may choose an already built-in model (see <code>use_built_in</code>) or
specify a (new) model by defining how the rates (and optionally traits)
change in every time step (see parameters <code>childRates</code> and
<code>otherRates</code> as well as <code>childTraits</code> and
<code>otherTraits</code>; see also Table 5 of the supplementary material of
the corresponding manuscript). <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGrowTree(
  n,
  STARTING_RATE = 1,
  STARTING_TRAIT = 10,
  ZETA = 1,
  SIGMA = 0,
  childRates,
  otherRates,
  childTraits = NULL,
  otherTraits = NULL,
  use_built_in = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGrowTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_starting_rate">STARTING_RATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
initial rate at which the speciation events occur (has only influence on the
edge length, not on the tree topology).</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_starting_trait">STARTING_TRAIT</code></td>
<td>
<p>Numeric value (default = 10) which specifies
the initial state of a trait.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_zeta">ZETA</code></td>
<td>
<p>Constant non-negative numeric value (default = 1) which can
influence the speciation rates. Can also be a vector if used as such when
defining the functions <code>childRates</code>, <code>otherRates</code>,
<code>childTraits</code>, and <code>otherTraits</code>.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_sigma">SIGMA</code></td>
<td>
<p>Constant positive numeric value (default = 0) which can influence
the speciation rates. Can also be a vector if used as such when defining the
functions <code>childRates</code>, <code>otherRates</code>, <code>childTraits</code>, and
<code>otherTraits</code>.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_childrates">childRates</code></td>
<td>
<p>A function that generates two speciation rates for the
children emerging from a speciation event based on various factors. <br />
Necessary if <code>use_built_in</code> is not specified.
<code>childTraits</code> works similarly but is executed before
<code>childRates</code>. <br />
All available parameters are: <br />
</p>

<ul>
<li><p> the starting rate <code>sr</code>,  <br />
</p>
</li>
<li><p> the starting trait value <code>st</code>,  <br />
</p>
</li>
<li><p> the parent's rate <code>pr</code>,  <br />
</p>
</li>
<li><p> the parent's trait value <code>pt</code>,  <br />
</p>
</li>
<li><p> the children's trait values <code>ct</code> (vector <code>ct[1]</code> and
<code>ct[2]</code>), <br />
</p>
</li>
<li><p> the parameters zeta <code>ze</code>  <br />
</p>
</li>
<li><p> and sigma <code>si</code>. <br /><br />
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given.<br />
Example: <br />
<code>function (sr, st, pr, pt, ct, ze, si) return(c(pr*ze,
pr*(1-ze)))</code> for biased speciation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="genGrowTree_+3A_otherrates">otherRates</code></td>
<td>
<p>A function that generates a new speciation rate for all
leaves not affected by the speciation event (all but parent and children)
based on various factors. The function is applied after the speciation event,
i.e., after <code>childRates/Traits</code>.<br />
Necessary if <code>use_built_in</code> is not specified.
<code>otherTraits</code> works similarly. <br />
All available parameters are: <br />
</p>

<ul>
<li><p> the starting rate <code>sr</code>,  <br />
</p>
</li>
<li><p> the starting trait value <code>st</code>,  <br />
</p>
</li>
<li><p> the leaf's old rate <code>or</code>,  <br />
</p>
</li>
<li><p> the leaf's old trait value <code>ot</code>, <br />
</p>
</li>
<li><p> the parameters zeta <code>ze</code>  <br />
</p>
</li>
<li><p> and sigma <code>si</code>. <br /><br />
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given. <br />
Example: <br />
<code>function (sr, st, or, ot, ze, si) return(or*ze)</code> for
age-step-based fertility.
</p>
</li></ul>
</td></tr>
<tr><td><code id="genGrowTree_+3A_childtraits">childTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates two
trait values for the children emerging from a speciation event based on
various factors. <br />
See <code>childRates</code> for available parameters (except <code>ct</code>) and
explanations. Not necessary; is only applied if not NULL.<br />
Example: <br />
<code>function (sr, st, pr, pt, ze, si)
return(c(0, 0))</code> for age.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_othertraits">otherTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates a new
trait value for all leaves not affected by the speciation event (all but
parent and children) based on various factors. <br />
See <code>otherRates</code> for available parameters and explanations. <br />
Not necessary; is only applied if not NULL.<br />
Example:<br />
<code>function (sr, st, or, ot, ze, si) return(ot+1)</code>
for discrete age (age in time steps).</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_use_built_in">use_built_in</code></td>
<td>
<p>Optional (default = NULL): Character specifying which of
the already implemented models should be used. Overwrites <code>childRates</code>,
<code>otherRates</code>, <code>childTraits</code>, and <code>otherTraits</code>.<br />
Here is a list of available models with their (abbreviated) underlying
functions given in parentheses  (in order <code>childRates</code>,
<code>otherRates</code>; then <code>childTraits</code> and <code>otherTraits</code>
if necessary): <br />
</p>

<ul>
<li><p> &quot;DCO_sym&quot;: Symmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sr ze, sr ze), sr) <br />
</p>
</li>
<li><p> &quot;DCO_asym&quot;: Asymmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sz, pr), sr) <br />
</p>
</li>
<li><p> &quot;IF_sym&quot;: Symmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr ze), or) <br />
</p>
</li>
<li><p> &quot;IF_asym&quot;: Asymmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr), or) <br />
</p>
</li>
<li><p> &quot;IF-diff&quot;: Unequal fertility inheritance, <code>ZETA</code>&gt;=1
(c(2 pr ze / (ze+1), 2 pr / (ze+1)), or)<br />
</p>
</li>
<li><p> &quot;biased&quot;: Biased speciation, <code>ZETA</code> &gt;=0 and &lt;=1
(c(pr ze, pr (1-ze)), or)<br />
</p>
</li>
<li><p> &quot;ASB&quot;: Age-step-based fertility, <code>ZETA</code>&gt;0
(c(sr, sr), or ze)<br />
</p>
</li>
<li><p> &quot;simpleBrown_sym&quot;: Symmetric simple Brownian, <code>SIGMA</code>&gt; =0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100},
max{pr+ rnorm(1, mean=0, sd=si),1e-100}), or) <br />
</p>
</li>
<li><p> &quot;simpleBrown_asym&quot;: Asymmetric simple Brownian, <code>SIGMA</code>&gt;=0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100}, pr), or) <br />
</p>
</li>
<li><p> &quot;lin-Brown_sym&quot;: Sym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},
max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}), ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown_asym&quot;: Asym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}, pt, ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown-bounded_sym&quot;: Bounded sym. punctuated(-intermittent)
linear-Brownian,  <code>SIGMA</code> vector with two values &gt;=0,
<code>STARTING_TRAIT</code> is automatically set to 10 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20},
min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}), ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown-bounded_asym&quot;: Bounded asym. punctuated(-intermittent)
linear-Brownian, <code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}, pt), ot) <br />
</p>
</li>
<li><p> &quot;log-Brown_sym&quot;: Sym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(10^(log(pt)+ rnorm(1, mean=0, sd=si[2])),
10^(log(pt)+ rnorm(1, mean=0, sd=si[2]))), ot) <br />
</p>
</li>
<li><p> &quot;log-Brown_asym&quot;: Asym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
10^(c(log(pt)+ rnorm(1, mean=0, sd=si[2])), pt), ot)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genGrowTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li>
<li><p> M. G. B. Blum and O. Francois. On statistical tests of phylogenetic tree
imbalance: the Sackin and other indices revisited. Mathematical Biosciences,
195(2):141–153, 2005.
</p>
</li>
<li><p> S. B. Heard. Patterns in phylogenetic tree balance with variable and
evolving speciation rates. Evolution, 50(6):2141–2148, 1996.
</p>
</li>
<li><p> S. J. Kersting. Genetic programming as a means for generating improved
tree balance indices (Master’s thesis, University of Greifswald), 2020.
</p>
</li>
<li><p> M. Kirkpatrick and M. Slatkin. Searching for evolutionary patterns in the
shape of a phylogenetic tree. Evolution, 47(4):1171–1181, 1993.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genGrowTree(n = 5, use_built_in = "IF_sym", ZETA = 2)
</code></pre>

<hr>
<h2 id='genMBTree'>Generation of the maximally balanced tree</h2><span id='topic+genMBTree'></span>

<h3>Description</h3>

<p><code>genMBTree</code> - Generates the rooted binary maximally balanced tree in
<code>phylo</code> format with the given number of <code>n</code> leaves. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMBTree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMBTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genMBTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genMBTree(n = 6)
</code></pre>

<hr>
<h2 id='genPDATree'>Generation of rooted binary trees under the PDA model</h2><span id='topic+genPDATree'></span>

<h3>Description</h3>

<p><code>genPDATree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
proportional-to-distinguishable-arrangements model.
Given <code>n</code>, all phylogenies (trees with labeled leaves) with
<code>n</code> leaves are equiprobable under the PDA.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPDATree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genPDATree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genPDATree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtopology(..., rooted = T)</code> function of
the <code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019). <br />
</p>
</li>
<li><p> D. E. Rosen. Vicariant patterns and historical explanation in
biogeography. Systematic Zoology, 27(2):159, 1978.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genPDATree(n = 5)
</code></pre>

<hr>
<h2 id='genTrees'>Generation of rooted binary trees under a given tree model</h2><span id='topic+genTrees'></span>

<h3>Description</h3>

<p><code>genTrees</code> - Is a wrapper function that generates
<code>Ntrees</code>-many rooted binary trees with the given number of <code>n</code>
leaves under any tree model <code>tm</code> contained in this package (more
details on the available models are given in the parameter information
for <code>tm</code>). <br />
Due to the restrictions of the <code>phylo</code> or <code>multiPhylo</code> format
the number of leaves must be at least 2 since there
must be at least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTrees(n, Ntrees = 1L, tm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTrees_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="genTrees_+3A_ntrees">Ntrees</code></td>
<td>
<p>Integer value (default = 1) that specifies the desired number
of generated trees.</p>
</td></tr>
<tr><td><code id="genTrees_+3A_tm">tm</code></td>
<td>
<p>Character or list specifying the tree model under which the trees
should be generated as well as their parameters. Available are: <br />
</p>

<ul>
<li> <p><code>"yule"</code> - Yule model. <br />
</p>
</li>
<li> <p><code>"pda"</code> - PDA model. <br />
</p>
</li>
<li> <p><code>"etm"</code> - ETM. <br />
</p>
</li>
<li> <p><code>list("aldous", BETA)</code> - Aldous' beta splitting model with parameter
<code>BETA</code> &gt;= -2. <br />
</p>
</li>
<li> <p><code>list("ford", ALPHA)</code> - Ford's alpha model with parameter
<code>ALPHA</code> &gt;= 0 and &lt;= 1. <br />
</p>
</li>
<li> <p><code>list("alt-birth-death", BIRTHRATE, DEATHRATE)</code> or
<code>list("alt-birth-death", BIRTHRATE, DEATHRATE, TRIES)</code> -
Alternative birth-death model with parameters <code>BIRTHRATE</code> &gt;0 and
<code>DEATHRATE</code>&gt;= 0. <br />
</p>
</li>
<li> <p><code>list("density", BIRTHRATE, EQUILIB)</code> or
<code>list("density", BIRTHRATE, EQUILIB, TRIES, TIMEperTRY)</code> -
Density dependent model with parameters <code>BIRTHRATE</code> &gt;0 and
<code>EQULIB</code>&gt;= 1. <br />
</p>
</li>
<li> <p><code>list("BiSSE", BIRTHRATES, DEATHRATES, TRANSRATES)</code> or
<code>list("BiSSE", BIRTHRATES, DEATHRATES, TRANSRATES, TRIES, TIMEperTRY)</code> -
BiSSE model with parameters <code>BIRTHRATES</code> (vector with 2 values &gt;=0, one
value &gt;0),
<code>DEATHRATES</code> (vector with 2 values &gt;=0), and
<code>TRANSRATES</code> (vector with 2 values &gt;=0, one
value &gt;0). <br />
</p>
</li>
<li> <p><code>list("DCO_sym", ZETA)</code> or
<code>list("DCO_sym", ZETA, STARTING_RATE)</code> - Symmetric direct-children-only
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("DCO_asym", ZETA)</code> or
<code>list("DCO_asym", ZETA, STARTING_RATE)</code> - Asymmetric
direct-children-only with parameter <code>ZETA</code> &gt; 0 and optionally
<code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF_sym", ZETA)</code> or
<code>list("IF_sym", ZETA, STARTING_RATE)</code> - Symmetric inherited fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF_asym", ZETA)</code> or
<code>list("IF_asym", ZETA, STARTING_RATE)</code> - Asymmetric inherited fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF-diff", ZETA)</code> or
<code>list("IF-diff", ZETA, STARTING_RATE)</code> - Unequal fertility inheritance
with parameter <code>ZETA</code> &gt;= 1 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("biased", ZETA)</code> or
<code>list("biased", ZETA, STARTING_RATE)</code> - Biased speciation
with parameter <code>ZETA</code> &gt;=0 and &lt;=1 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("ASB", ZETA)</code> or
<code>list("ASB", ZETA, STARTING_RATE)</code> - Age-step-based fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("simpleBrown_sym", SIGMA)</code> or
<code>list("simpleBrown_sym", SIGMA, STARTING_RATE)</code> - Symmetric simple
Brownian with parameter <code>SIGMA</code> &gt;= 0 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("simpleBrown_asym", SIGMA)</code> or
<code>list("simpleBrown_asym", SIGMA, STARTING_RATE)</code> - Asymmetric simple
Brownian with parameter <code>SIGMA</code> &gt;= 0 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("lin-Brown_sym", SIGMA)</code> or
<code>list("lin-Brown_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Sym.
punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown_asym", SIGMA)</code> or
<code>list("lin-Brown_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Asym.
punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown-bounded_sym", SIGMA)</code> or
<code>list("lin-Brown-bounded_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> -
Bounded sym. punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown-bounded_asym", SIGMA)</code> or
<code>list("lin-Brown-bounded_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> -
Bounded asym. punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("log-Brown_sym", SIGMA)</code> or
<code>list("log-Brown_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Sym.
punctuated(-intermittent) log-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("log-Brown_asym", SIGMA)</code> or
<code>list("log-Brown_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Asym.
punctuated(-intermittent) log-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br /><br />
More information on each model and their parameters can be found in the
description of each model, accessible with <code>?genYuleTree</code>,
<code>?genPDATree</code>, <code>?genETMTree</code>, <code>?genAldousBetaTree</code>,
<code>?genFordsAlphaTree</code>, <code>?genBirthDeathTree</code>,
<code>?genAltBirthDeathTree</code>, <code>?genGrowTree</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genTrees</code>   If <code>Ntrees</code> is 1, then a single tree of
class <code>phylo</code> is returned.
If <code>Ntrees</code> is larger than 1, a list of class
<code>multiPhylo</code> containing the trees of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genTrees(n = 5, Ntrees = 2, tm = list("aldous", 1))
genTrees(n = 5, tm = "pda")
</code></pre>

<hr>
<h2 id='genYuleTree'>Generation of rooted binary trees under the Yule model</h2><span id='topic+genYuleTree'></span>

<h3>Description</h3>

<p><code>genYuleTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the Yule model.
The Yule process is a simple birth-process in which all species have the same
speciation rate.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format
the number of leaves must be at least 2 since there must be at
least one edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genYuleTree(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genYuleTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genYuleTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtree</code> function of the <code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019). <br />
</p>
</li>
<li><p> G. U. Yule. A mathematical theory of evolution, based on the conclusions of
Dr. J. C. Willis, F. R. S. Philosophical Transactions of the Royal Society
of London. Series B, Containing Papers of a Biological
Character, 213(402-410):21–87, 1925. <br />
</p>
</li>
<li><p> E. F. Harding. The probabilities of rooted tree-shapes generated by random
bifurcation. Advances in Applied Probability, 3(1):44–77, 1971.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genYuleTree(n = 5)
</code></pre>

<hr>
<h2 id='getAccRegion'>Functions for computing the region of acceptance</h2><span id='topic+getAccRegion'></span><span id='topic+getAccRegion_data'></span>

<h3>Description</h3>

<p><code>getAccRegion</code> - Computes the region of acceptance based on quantiles
for a specified level of significance and method. The critical region is
everything strictly outside this interval, i.e., the interval limits still
belong to the acceptance region.
</p>
<p><code>getAccRegion_data</code> - Computes the region of acceptance for the
given TSS values based on quantiles for a specified level of significance and
method. The critical region is everything strictly outside this interval,
i.e., the interval limits still belong to the acceptance region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccRegion(
  tss,
  null_model = "yule",
  n,
  distribs = "sampled",
  sample_size = 1000L,
  test_type = "two-tailed",
  sig_lvl = 0.05
)

getAccRegion_data(tss_data, test_type = "two-tailed", sig_lvl = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccRegion_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_null_model">null_model</code></td>
<td>
<p>The null model that is to be used to determine the power
of the tree shape statistics. In general, it must be a function that
produces rooted binary trees in <code>phylo</code> format. <br />
If the respective model is included in this
package, then specify the model and its parameters by using a character
or list. Available are all options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (with the two input parameters
<code>n</code> and <code>Ntrees</code>). Example: <br />
Use <code>"new_tm"</code> for the list object
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_distribs">distribs</code></td>
<td>
<p>Determines how the distributions and quantiles are computed.
Available are: <br />
</p>

<ul>
<li><p> &quot;sampled&quot; (default): <code>sample_size</code> many trees are sample under the
respective models to determine the quantiles for the null model and how many
trees under the alternative models lie outside.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAccRegion_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size (integer &gt;=10) if distributions are sampled
(default= 1000L).</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_test_type">test_type</code></td>
<td>
<p>Determines the method. Available are: <br />
</p>

<ul>
<li><p> &quot;two-tailed&quot; (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAccRegion_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_tss_data">tss_data</code></td>
<td>
<p>Numeric matrix of TSS values (one row per TSS). The row names
are used as names for the TSS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getAccRegion</code> Numeric matrix (one row per TSS) with two
columns for the interval limits of the acceptance region.
</p>
<p><code>getAccRegion_data</code> Numeric matrix (one row per TSS) with two
columns for the interval limits of the acceptance region.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAccRegion(tss = c("Sackin", "Colless", "B1I"), n = 8L, sample_size = 100L)
getAccRegion_data(getTSSdata(tss = c("Colless", "Sackin"), n = 8L,
                             Ntrees = 20L, tm = "yule"))
</code></pre>

<hr>
<h2 id='getPowerMultAM'>Functions for computing the power</h2><span id='topic+getPowerMultAM'></span><span id='topic+getPowerMultTSS'></span>

<h3>Description</h3>

<p><code>getPowerMultAM</code> - Computes the power of a single TSS by calculating
the proportion of values outside the region of acceptance for one or multiple
alternative models.
</p>
<p><code>getPowerMultTSS</code> - Computes the power of one or multiple TSS by
calculating the proportion of values outside the region of acceptance for
a single alternative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerMultAM(accept_region, alts_data)

getPowerMultTSS(accept_regions, alt_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPowerMultAM_+3A_accept_region">accept_region</code></td>
<td>
<p>Numeric vector of length two (increasing) setting the
lower and upper limit of the region of acceptance (limits included).</p>
</td></tr>
<tr><td><code id="getPowerMultAM_+3A_alts_data">alts_data</code></td>
<td>
<p>Numeric matrix with one column of values per alternative
model. If there is only one alternative model, then it can be a simple
vector of values instead (returns a single unnamed value).</p>
</td></tr>
<tr><td><code id="getPowerMultAM_+3A_accept_regions">accept_regions</code></td>
<td>
<p>Numeric matrix with two columns. Each column represents
an interval, i.e., lower and upper limit of the region of acceptance (limits
included), of a different TSS.</p>
</td></tr>
<tr><td><code id="getPowerMultAM_+3A_alt_data">alt_data</code></td>
<td>
<p>Numeric matrix with one row of values under the
alternative model per TSS.
If there is only one TSS, then it can be a simple vector of values instead
(returns a single unnamed value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getPower</code> A vector containing the power regarding the given
alternative models (retains column names of <code>alts_data</code>).
</p>
<p><code>getPowerMultTSS</code> A vector containing the power regarding the
given TSS (retains row names of <code>accept_regions</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getPowerMultAM(accept_region = c(10,20),
         alts_data = matrix(c(9,11,13,15,17,19,21,
                             5, 5, 5,15,25,25,25), ncol = 2, byrow = FALSE,
                           dimnames = list(NULL, c("AltTM1", "AltTM2"))))
getPowerMultAM(accept_region = c(10,20), alts_data = c(9,11,13,15,17,19,21))
getPowerMultTSS(accept_regions = matrix(c(10,20,
                                   110,120), ncol = 2, byrow = TRUE,
                           dimnames = list(c("TSS1", "TSS2"),NULL)),
         alt_data = matrix(c(  9, 14, 19, 24,
                             109,114,119,124), nrow = 2, byrow = TRUE,
                           dimnames = list(c("TSS1", "TSS2"),NULL)))
getPowerMultTSS(accept_regions = c(10,20), alt_data = c(9, 14, 19, 24))
</code></pre>

<hr>
<h2 id='getTSSdata'>Functions for generating the TSS data under a tree model</h2><span id='topic+getTSSdata'></span><span id='topic+getTSSdata_trees'></span>

<h3>Description</h3>

<p><code>getTSSdata</code> - Compute the tree shape statistics of trees generated
under a tree model for each given TSS.
</p>
<p><code>getTSSdata_trees</code> - Compute the tree shape statistics for each given
TSS and all given trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTSSdata(tss, n, Ntrees = 1L, tm)

getTSSdata_trees(tss, treeList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTSSdata_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_ntrees">Ntrees</code></td>
<td>
<p>Integer value (default = 1) that specifies the desired number
of generated trees.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_tm">tm</code></td>
<td>
<p>If the respective model is included in this package, then specify
the model and its parameters by using a character or list. Available are all
options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (with the two input parameters
<code>n</code> and <code>Ntrees</code>). Example: <br />
Use <code>"new_tm"</code> for the list object
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_treelist">treeList</code></td>
<td>
<p>List of trees of class <code>multiphylo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getTSSdata</code> Numeric matrix of TSS values (one row per TSS).
</p>
<p><code>getTSSdata_trees</code> Numeric matrix of TSS values
(one row per TSS).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using tree models included in this package.
getTSSdata(tss = c("Colless", "Sackin"), n = 5L, Ntrees = 3L,
           tm = "yule")
# Example using a "new" TM provided by the user.
my_aldous &lt;- list(func = function(n, Ntrees){
                        trees &lt;- lapply(1:Ntrees,
                           function(x){genAldousBetaTree(n = n, BETA =5L)})
                        attr(trees, "class") &lt;- "multiPhylo"
                        return(trees)})
getTSSdata(tss = c("Colless", "Sackin"), n = 5L, Ntrees = 3L,
           tm = "my_aldous")
# Example using TSS provided in tssInfo.
getTSSdata_trees(tss = c("Colless", "Sackin"),
           treeList = lapply(1:6L, function(x) genYuleTree(5)))
# Example using a "new" TSS provided by the user.
my_avd &lt;- list(func = treebalance::avgVertDep, short = "My AVD")
getTSSdata_trees(tss = c("Colless", "my_avd"),
           treeList = lapply(1:6L, function(x) genYuleTree(5)))
</code></pre>

<hr>
<h2 id='getTSSnames'>Get information on included tree shape statistics</h2><span id='topic+getTSSnames'></span><span id='topic+getTSSsimple'></span><span id='topic+getTSScolors'></span><span id='topic+getTSSsafe_n'></span><span id='topic+getTSStype'></span><span id='topic+getTSSonly_bin'></span><span id='topic+getAllTSS'></span>

<h3>Description</h3>

<p><code>getTSSnames</code> - Returns the full names (character/expression) of the
TSS.
</p>
<p><code>getTSSsimple</code> - Returns the simple names (character/expression) of the
TSS.
</p>
<p><code>getTSScolors</code> - Returns the colors of the TSS.
</p>
<p><code>getTSSsafe_n</code> - Returns the ranges of n that can be safely used.
</p>
<p><code>getTSStype</code> - Returns the ranges of n that can be safely used.
</p>
<p><code>getTSSonly_bin</code> - Returns TRUE/FALSE vector: TRUE if TSS is only for
binary trees and FALSE otherwise.
</p>
<p><code>getAllTSS</code> - Returns the short names of all TSS that are safe to
use for the specified <code>n</code>, have one of the specified <code>types</code> and
can be applied to (non-)binary trees (<code>not_only_bin</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTSSnames(tss_shorts)

getTSSsimple(tss_shorts)

getTSScolors(tss_shorts)

getTSSsafe_n(tss_shorts)

getTSStype(tss_shorts)

getTSSonly_bin(tss_shorts)

getAllTSS(n = NULL, not_only_bin = FALSE, types = c("tss", "bali", "imbali"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTSSnames_+3A_tss_shorts">tss_shorts</code></td>
<td>
<p>Vector of short names (characters) of TSS contained in
<code>tssInfo</code>.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_n">n</code></td>
<td>
<p>Integer value or vector of integer values, that
specifies the number(s) of leaves.
If NULL (default), then <code>getAllSafeTSS</code> returns the short names of all
TSS contained in <code>tssInfo</code>.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_not_only_bin">not_only_bin</code></td>
<td>
<p>Select TRUE if you also want to analyze non-binary trees
and therefore want to filter out any TSS that only work on binary trees.
Otherwise, select FALSE (default) if all TSS are applicable.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_types">types</code></td>
<td>
<p>Character vector, that specifies all permissible TSS types. The
vector may contain a subset of <code>c("tss", "bali", "imbali")</code> to indicate
if balance indices, imbalance indices or mere TSS should be included. By
default all types are permissible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getTSSnames</code> Vector of characters/expressions.
</p>
<p><code>getTSSsimple</code> Vector of characters/expressions.
</p>
<p><code>getTSScolors</code> Vector of characters (color names).
</p>
<p><code>getTSSsafe_n</code> Numeric matrix, one row per TSS and two columns
with lower and upper limit.
</p>
<p><code>getTSStype</code> Vector of characters (types as factors).
</p>
<p><code>getTSSonly_bin</code> Logical vector.
</p>
<p><code>getAllTSS</code> Character vector of short names of TSS
contained in <code>tssInfo</code>.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTSSnames(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSsimple(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSScolors(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSsafe_n(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSStype(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSonly_bin(tss_shorts = c("Sackin", "Colless", "B1I"))
getAllTSS(n = c(3,30))
</code></pre>

<hr>
<h2 id='powerComp'>Comparison of the power of TSS under different models</h2><span id='topic+powerComp'></span>

<h3>Description</h3>

<p><code>powerComp</code> - Compare the power of a set of TSS to identify trees
generated under different alternative models given a null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerComp(
  tss,
  null_model = "yule",
  alt_models,
  n,
  distribs = "sampled",
  sample_size = 1000L,
  test_type = "two-tailed",
  sig_lvl = 0.05,
  with_CIradius = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerComp_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_null_model">null_model</code></td>
<td>
<p>The null model that is to be used to determine the power
of the tree shape statistics. In general, it must be a function that
produces rooted binary trees in <code>phylo</code> format. <br />
If the respective model is included in this
package, then specify the model and its parameters by using a character
or list. Available are all options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (dependent on one parameter
<code>n</code>). Example: <br />
Use <code>"new_tm"</code> for the list object <br />
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_alt_models">alt_models</code></td>
<td>
<p>List containing the alternative models that are to be
used to determine the power of the tree shape statistics. Functions that
produce rooted binary trees in <code>phylo</code> format. The information of each
single model must be in the format described for <code>null_model</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_distribs">distribs</code></td>
<td>
<p>Determines how the distributions and quantiles are computed.
Available are: <br />
</p>

<ul>
<li><p> &quot;sampled&quot; (default): <code>sample_size</code> many trees are sample under the
respective models to determine the quantiles for the null model and how many
trees under the alternative models lie outside.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerComp_+3A_sample_size">sample_size</code></td>
<td>
<p>Sample size (integer &gt;=10) if distributions are sampled
(default= 1000L).</p>
</td></tr>
<tr><td><code id="powerComp_+3A_test_type">test_type</code></td>
<td>
<p>Determines the method. Available are: <br />
</p>

<ul>
<li><p> &quot;two-tailed&quot; (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerComp_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="powerComp_+3A_with_ciradius">with_CIradius</code></td>
<td>
<p>Determines if the radii for the 95%-confidence
intervals of the power values should also be computed
and returned (default = FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>powerComp</code>  Numeric matrix, one row per TSS and one
column per alternative model if <code>with_CIradius</code> is FALSE (default).
Else a list with two such numeric matrices, the first for the power and the
second for the confidence interval radius.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>powerComp(tss = c("Sackin", "Colless", "B1I"),
          alt_models = list(list("aldous",-1), "pda", "etm"), n=10L,
          sample_size = 40L, with_CIradius = TRUE)
</code></pre>

<hr>
<h2 id='showTSSdata'>Functions for displaying TSS distributions and TSS power</h2><span id='topic+showTSSdata'></span><span id='topic+showPower'></span><span id='topic+showPower_param'></span>

<h3>Description</h3>

<p><code>showTSSdata</code> - This function plots histograms of TSS data.
</p>
<p><code>showPower</code> - This function displays the power of TSS under
different alternative models.
</p>
<p><code>showPower_param</code> - This function displays the power of TSS under
different representatives of a family of tree models which vary only in one
parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showTSSdata(
  tss_data,
  main = NULL,
  xlab = NULL,
  test_type = "two-tailed",
  sig_lvl = 0.05,
  ...
)

showPower(
  power_data,
  tss_names = NULL,
  tss_colors = NULL,
  model_names = NULL,
  sig_lvl = 0.05,
  ...
)

showPower_param(
  power_data,
  tss_names = NULL,
  tss_colors = NULL,
  tss_ltys = NULL,
  model_name = NULL,
  model_param,
  sig_lvl = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showTSSdata_+3A_tss_data">tss_data</code></td>
<td>
<p>Numeric matrix of TSS values (one row per TSS). The row names
are used as names for the TSS.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_main">main</code></td>
<td>
<p>Title (default = NULL). A generic title is created by default.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis (default = NULL). A generic label is created
by default.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_test_type">test_type</code></td>
<td>
<p>Determines the method. Available are: <br />
</p>

<ul>
<li><p> &quot;two-tailed&quot; (default)
</p>
</li></ul>
</td></tr>
<tr><td><code id="showTSSdata_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1). NO
horizontal line is depicted if set to NULL.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_...">...</code></td>
<td>
<p>Add further specifications for <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_power_data">power_data</code></td>
<td>
<p>Numeric matrix, one row per TSS and one column per
alternative model.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_tss_names">tss_names</code></td>
<td>
<p>Vector of characters/expression of the TSS names (default
= NULL). If none are provided, the row names of <code>power_data</code> are used
as names for the TSS.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_tss_colors">tss_colors</code></td>
<td>
<p>Vector of colors for the TSS (default = NULL).</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_model_names">model_names</code></td>
<td>
<p>Vector of characters/expression of the model names
(default = NULL). If none are provided, the column names of <code>power_data</code>
are used as names for the models.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_tss_ltys">tss_ltys</code></td>
<td>
<p>Vector of line types for the TSS (default = NULL).</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_model_name">model_name</code></td>
<td>
<p>Vector of characters/expressions of the name of the tree
model family and of the parameter (default = NULL), e.g.
<code>c("Aldous\'", expression(beta))</code>.
If none are provided, the first column name of <code>power_data</code> is used.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_model_param">model_param</code></td>
<td>
<p>Numeric vector containing the parameter values of the
representatives of the tree model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>showTSSdata</code> No return value, called for side effects
(plotting).
</p>
<p><code>showPower</code> No return value, called for side effects
(plotting).
</p>
<p><code>showPower_param</code> No return value, called for side effects
(plotting).
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showTSSdata(tss_data = getTSSdata_trees(tss = c("Colless", "Sackin"),
                treeList = lapply(1:20L, function(x) genYuleTree(10))),
                breaks=15)
# With error bars:
showPower(power_data = powerComp(tss = c("Sackin", "Colless", "B1I"),
                                     alt_models = list("pda", "etm"), n=10L,
                                     sample_size = 50L,
                                     with_CIradius = TRUE),
              tss_names = getTSSnames(c("Sackin", "Colless", "B1I")),
              tss_colors = getTSScolors(c("Sackin", "Colless", "B1I")),
              model_names = c("PDA", "ETM"),
              main = "Power (Yule as null model, n = 10, N=50)",
              ylim = c(0,1), ylab = "Power (null model rejected)")
# Without error bars:
showPower(power_data = powerComp(tss = c("Sackin", "Colless", "B1I"),
                                     alt_models = list("pda", "etm"), n=10L,
                                     sample_size = 50L),
              tss_names = getTSSnames(c("Sackin", "Colless", "B1I")),
              tss_colors = getTSScolors(c("Sackin", "Colless", "B1I")),
              model_names = c("PDA", "ETM"),
              main = "Power (Yule as null model, n = 10, N=50)",
              ylim = c(0,1), ylab = "Power (null model rejected)")
# With confidence bands:
showPower_param(power_data = powerComp(tss = c("Sackin", "Colless", "B1I"),
                                   alt_models = list(list("aldous", 0.5),
                                   list("aldous", 0),list("aldous", -0.5),
                                   list("aldous", -1),list("aldous", -1.5)),
                                   n=20L, sample_size = 50L,
                                   with_CIradius = TRUE),
              tss_names = getTSSnames(c("Sackin", "Colless", "B1I")),
              tss_colors = getTSScolors(c("Sackin", "Colless", "B1I")),
              model_name = c("Aldous-beta splitting model", "beta"),
              model_param = c(0.5,0,-0.5,-1,-1.5),
              ylim = c(0,1), ylab = "Power (null model rejected)")
# Without confidence bands:
showPower_param(power_data = powerComp(tss = c("Sackin", "Colless", "B1I"),
                                   alt_models = list(list("aldous", 0.5),
                                   list("aldous", 0),list("aldous", -0.5),
                                   list("aldous", -1),list("aldous", -1.5)),
                                   n=20L, sample_size = 50L),
              tss_names = getTSSnames(c("Sackin", "Colless", "B1I")),
              tss_colors = getTSScolors(c("Sackin", "Colless", "B1I")),
              model_name = c("Aldous-beta splitting model", "beta"),
              model_param = c(0.5,0,-0.5,-1,-1.5),
              ylim = c(0,1), ylab = "Power (null model rejected)")
</code></pre>

<hr>
<h2 id='tssInfo'>Tree shape statistics</h2><span id='topic+tssInfo'></span>

<h3>Description</h3>

<p><code>tssInfo</code> - List that provides information on available tree shape
statistics (TSS) from the package 'treebalance'.
Most of them are either balance or imbalance indices. The indices are grouped
by their families and otherwise sorted alphabetically by their full names.<br />
The following information is provided: <br />
</p>

<ul>
<li><p> short: Abbreviation of the name (plain characters). <br />
</p>
</li>
<li><p> simple: Simplified full name (plain characters). <br />
</p>
</li>
<li><p> name: Full name (partly expressions as some names use special symbols).<br />
</p>
</li>
<li><p> func: Function of the TSS. <br />
</p>
</li>
<li><p> type: Either &quot;tss&quot;, &quot;bali&quot;, or &quot;imbali&quot; expressing what type of tree shape
statistic it is. <br />
</p>
</li>
<li><p> only_binary: TRUE if TSS is suitable only for binary trees, FALSE if also
applicable to arbitrary rooted trees. <br />
</p>
</li>
<li><p> safe_n : Integer vector with two entries specifying the range of leaf
numbers <code>n</code> for which the TSS can be (safely) used, without
warnings for too few leaves or values reaching Inf for too many
leaves.<br />
c(4,800), for example means that this TSS should only be applied
on trees with 4 to 800 leaves. 'Inf' as the second entry means
that there is no specific upper limit, but that the size of the
tree itself and the computation time are the limiting factors.<br />
</p>
</li>
<li><p> col: Color for the TSS (related TSS have similar colors).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tssInfo
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>


<h3>Author(s)</h3>

<p>Sophie Kersting
</p>


<h3>References</h3>


<ul>
<li><p> M. Fischer, L.Herbst, S. J. Kersting, L. Kühn, and K. Wicke,
Tree Balance Indices - A Comprehensive Survey. Springer, 2023.
ISBN: 978-3-031-39799-8
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tssInfo$ALD$name
tssInfo$ALD$func(genYuleTree(6))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
