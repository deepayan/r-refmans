<!DOCTYPE html><html lang="en"><head><title>Help for package poweRbal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poweRbal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#enum2cladewise'><p>Function to modify the node enumeration in rooted binary trees</p></a></li>
<li><a href='#genAldousBetaTree'><p>Generation of rooted binary trees under Aldous' beta splitting model</p></a></li>
<li><a href='#genAltBirthDeathTree'><p>Generation of rooted binary trees under the alternative birth-death model</p></a></li>
<li><a href='#genBiSSETree'><p>Generation of rooted binary trees under the BiSSE model</p></a></li>
<li><a href='#genCombTree'><p>Generation of the comb or caterpillar tree</p></a></li>
<li><a href='#genDensityTree'><p>Generation of rooted binary trees under the density model</p></a></li>
<li><a href='#genETMTree'><p>Generation of rooted binary trees under the equiprobable-types-model (ETM)</p></a></li>
<li><a href='#genFordsAlphaTree'><p>Generation of rooted binary trees under Ford's alpha model</p></a></li>
<li><a href='#genGFBTree'><p>Generation of the greedy from the bottom tree</p></a></li>
<li><a href='#genGrowTree'><p>Generation of rooted binary trees under tree growing models (no extinction)</p></a></li>
<li><a href='#genMBTree'><p>Generation of the maximally balanced tree</p></a></li>
<li><a href='#genPDATree'><p>Generation of rooted binary trees under the PDA model</p></a></li>
<li><a href='#genTrees'><p>Generation of rooted binary trees under a given tree model</p></a></li>
<li><a href='#genYuleTree'><p>Generation of rooted binary trees under the Yule model</p></a></li>
<li><a href='#getAccRegion'><p>Functions for computing the region of acceptance</p></a></li>
<li><a href='#getPowerMultTSS'><p>Function for computing the power given the region of acceptance</p></a></li>
<li><a href='#getTSSdata'><p>Functions for generating the TSS data under a tree model</p></a></li>
<li><a href='#getTSSnames'><p>Get information on included tree shape statistics</p></a></li>
<li><a href='#plot.poweRbal_data'><p>Plot method for poweRbal_data objects</p></a></li>
<li><a href='#powerComp'><p>Comparison of the power of TSS under different models</p></a></li>
<li><a href='#print.poweRbal_data'><p>Print and summary method for poweRbal_data objects</p></a></li>
<li><a href='#showTSSdata'><p>Function for displaying TSS distributions</p></a></li>
<li><a href='#tssInfo'><p>Tree shape statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Phylogenetic Tree Models and the Power of Tree Shape Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Sophie Kersting <a href="https://orcid.org/0000-0002-1038-9246"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kristina Wicke <a href="https://orcid.org/0000-0002-4275-5546"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mareike Fischer <a href="https://orcid.org/0000-0002-9429-0859"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sophie Kersting &lt;sophie_kersting@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The first goal of this package is to provide a multitude of tree models,
    i.e., functions that generate rooted binary trees with a given number of leaves.
    Second, the package allows for an easy evaluation and comparison of tree shape
    statistics by estimating their power to differentiate between different tree models.
    Please note that this R package was developed alongside the manuscript
    "Tree balance in phylogenetic models" by
    S. J. Kersting, K. Wicke, and M. Fischer (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2406.05185">doi:10.48550/arXiv.2406.05185</a>&gt;,
    which provides further background and the respective mathematical definitions.
    This project was supported by the project ArtIGROW, which is a part of the
    WIR!-Alliance ArtIFARM –  Artificial Intelligence in Farming funded by the
    German Federal Ministry of Education and Research (No. 03WIR4805).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, scales, phytools, treebalance, R.utils, diversitree</td>
</tr>
<tr>
<td>Suggests:</td>
<td>memoise</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-16 09:52:27 UTC; Maus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-16 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='enum2cladewise'>Function to modify the node enumeration in rooted binary trees</h2><span id='topic+enum2cladewise'></span>

<h3>Description</h3>

<p><code>enum2cladewise</code> - Changes the node enumeration to cladewise
enumeration, i.e., starting from the root we follow the rule:<br />
Go to the left child; if that does not exist or was already visited go (up
again and) to the right child.<br />
The nodes in the rooted binary tree can be nearly arbitrarily enumerated
(distinct nodes should have distinct values and the
values should be positive, i.e., &gt;0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enum2cladewise(phy, root = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enum2cladewise_+3A_phy">phy</code></td>
<td>
<p>A rooted binary tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="enum2cladewise_+3A_root">root</code></td>
<td>
<p>Integer value (default = NULL) that should only be specified if
the root is known precisely (not necessary, but speeds up computation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>enum2cladewise</code>  A single tree of class <code>phylo</code> is
returned with cladewise node enumeration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with cladewise enumeration:
phy_alreadycladew &lt;- list(edge = matrix(c(6,7, 7,8, 8,1, 8,2,
                                          7,9, 9,3, 9,4, 6,5),
                                 byrow = TRUE, ncol = 2),
                          tip.label = rep(" ",5), Nnode = 4)
attr(phy_alreadycladew, "class") &lt;- "phylo"
enum2cladewise(phy_alreadycladew, root = 6)$edge
ape::plot.phylo(phy_alreadycladew)
# Example with other node enumeration:
phy_example &lt;- list(edge = matrix(c(1,55, 55,12, 12,2, 12,10, 55,9,
                                    9,13, 9,60, 1,3),
                                  byrow = TRUE, ncol = 2),
                    tip.label = rep(" ",5), Nnode = 4,
                    edge.length = rep(1, 8))
attr(phy_example, "class") &lt;- "phylo"
# The reenumeration works with and without specifying the root:
enum2cladewise(phy_example, root = 1)$edge
ape::plot.phylo(enum2cladewise(phy_example))
</code></pre>

<hr>
<h2 id='genAldousBetaTree'>Generation of rooted binary trees under Aldous' beta splitting model</h2><span id='topic+genAldousBetaTree'></span>

<h3>Description</h3>

<p><code>genAldousBetaTree</code> - Generates a rooted binary tree in
<code>phylo</code> format with the given number of <code>n</code> leaves under the
Aldous beta model.
The Aldous beta model is not a rate-based incremental evolutionary (tree)
construction and thus cannot generate edge lengths, only a topology.
Instead, the Aldous beta model works as follows: The idea is to start with
the root and the set of its descendant leaves, i.e., all <code>n</code> leaves.
Then, this set is partitioned into two subsets according to a density
function dependent on the parameter <code>beta</code>.
The two resulting subsets contain the leaves of the two maximal pending
subtrees of the root, respectively. The same procedure is then applied to the
root's children and their respective subsets, and so forth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAldousBetaTree(n, BETA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genAldousBetaTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genAldousBetaTree_+3A_beta">BETA</code></td>
<td>
<p>Numeric value &gt;=-2 which specifies how the leaf sets
are partitioned. For certain choices of <code>BETA</code> the Aldous beta model
coincides with known models:<br />
</p>

<ul>
<li> <p><code>BETA</code> = 0: Yule model <br />
</p>
</li>
<li> <p><code>BETA</code> = -3/2: PDA model (all phylogenies equally probable) <br />
</p>
</li>
<li> <p><code>BETA</code> = -2: Caterpillar with <code>n</code> leaves
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genAldousBetaTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> D. Aldous. Probability Distributions on Cladograms. In Random Discrete
Structures, pages 1–18. Springer New York, 1996.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genAldousBetaTree(n = 5, BETA = 1)
</code></pre>

<hr>
<h2 id='genAltBirthDeathTree'>Generation of rooted binary trees under the alternative birth-death model</h2><span id='topic+genAltBirthDeathTree'></span>

<h3>Description</h3>

<p><code>genAltBirthDeathTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the alternative
birth-death model.
In the alternative birth-death process all species have the same speciation
<code>BIRTHRATE</code> and extinction rates <code>DEATHRATE</code>. Extinct species
remain as fossils inside the tree with zero speciation and extinction
rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genAltBirthDeathTree(n, BIRTHRATE = 1, DEATHRATE = 0, TRIES = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genAltBirthDeathTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_birthrate">BIRTHRATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
rate at which the speciation events occur.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_deathrate">DEATHRATE</code></td>
<td>
<p>Positive numeric value (default = 0) which specifies the
rate at which the extinction events occur.</p>
</td></tr>
<tr><td><code id="genAltBirthDeathTree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genAltBirthDeathTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genAltBirthDeathTree(n = 7, DEATHRATE = 1)
</code></pre>

<hr>
<h2 id='genBiSSETree'>Generation of rooted binary trees under the BiSSE model</h2><span id='topic+genBiSSETree'></span>

<h3>Description</h3>

<p><code>genBiSSETree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the BiSSE model.
In the BiSSE model all species have a state, either A or B, and depending on
the state a speciation rate <code>BIRTHRATES</code>, an extinction rate
<code>DEATHRATES</code> as well as a transition rate to the other state
<code>TRANSRATES</code>. <br />
Extinct species are removed from the tree, i.e., the generated tree contains
only species living at the present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBiSSETree(
  n,
  BIRTHRATES = c(1, 1),
  DEATHRATES = c(0, 0),
  TRANSRATES,
  TRIES = 5,
  TIMEperTRY = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genBiSSETree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_birthrates">BIRTHRATES</code></td>
<td>
<p>Numeric vector (default = c(1,1)) which specifies
the speciation rates in state A and B (vector with 2 values &gt;=0, one
value &gt;0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_deathrates">DEATHRATES</code></td>
<td>
<p>Numeric vector (default = c(0,0)) which specifies
the extinction rates in state A and B (vector with 2 values &gt;=0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_transrates">TRANSRATES</code></td>
<td>
<p>Numeric vector which specifies the
transition rates from A to B and from B to A (vector with 2 values &gt;0).</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
<tr><td><code id="genBiSSETree_+3A_timepertry">TIMEperTRY</code></td>
<td>
<p>Numeric value (default = 0.1) that specifies the maximum
amount of time (in seconds) invested per try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genBiSSETree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>tree.bisse</code> function of the
<code>diversitree</code> package
(R. G. FitzJohn. Diversitree: Comparative Phylogenetic Analyses of
Diversification in R.  Methods in Ecology and
Evolution, 3(6):1084-1092, 2012). <br />
</p>
</li>
<li><p> W. P. Maddison, P. E. Midford, and S. P. Otto. Estimating a binary
character’s effect on speciation and extinction. Systematic Biology,
56(5):701–710, 2007.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("diversitree", quietly = TRUE)) {
genBiSSETree(n = 5, BIRTHRATES = c(1,2), DEATHRATES = c(0,0),
             TRANSRATES = c(0.1,0.3))
}
</code></pre>

<hr>
<h2 id='genCombTree'>Generation of the comb or caterpillar tree</h2><span id='topic+genCombTree'></span>

<h3>Description</h3>

<p><code>genCombTree</code> - Generates the rooted binary comb tree (also known as
caterpillar tree) in <code>phylo</code> format with the given number of <code>n</code>
leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCombTree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genCombTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genCombTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> D. Aldous. Probability Distributions on Cladograms. In Random Discrete
Structures, pages 1–18. Springer New York, 1996.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genCombTree(n = 6)
</code></pre>

<hr>
<h2 id='genDensityTree'>Generation of rooted binary trees under the density model</h2><span id='topic+genDensityTree'></span>

<h3>Description</h3>

<p><code>genDensityTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
density-dependent model.
In the density-dependent tree generation process all species have the same
speciation <code>BIRTHRATE</code>, but the extinction rates depend on the
number of species (it increases linearly with the number of co-existing
lineages until an equilibrium number is reached at which speciation and
extinction rates are equal).
Extinct species are removed from the tree, i.e., the generated tree contains
only species living at the present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genDensityTree(n, BIRTHRATE = 1, EQUILIB, TRIES = 5, TIMEperTRY = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genDensityTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_birthrate">BIRTHRATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
rate at which the speciation events occur.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_equilib">EQUILIB</code></td>
<td>
<p>Integer value that specifies the equilibrium number.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_tries">TRIES</code></td>
<td>
<p>Integer value (default = 5) that specifies
the number of attempts to generate a tree with <code>n</code> leaves.</p>
</td></tr>
<tr><td><code id="genDensityTree_+3A_timepertry">TIMEperTRY</code></td>
<td>
<p>Numeric value (default = 0.01) that specifies the maximum
amount of time (in seconds) invested per try.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genDensityTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> P. H. Harvey, R. M. May, and S. Nee. Phylogenies without fossils.
Evolution, 48(3):523–529, 1994.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genDensityTree(n = 5, EQUILIB = 6)
</code></pre>

<hr>
<h2 id='genETMTree'>Generation of rooted binary trees under the equiprobable-types-model (ETM)</h2><span id='topic+genETMTree'></span>

<h3>Description</h3>

<p><code>genETMTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
equiprobable-types-model.
Given <code>n</code>, all tree shapes/topologies with <code>n</code> leaves are
equiprobable under the ETM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genETMTree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genETMTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genETMTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtree(..., equiprob = T)</code> function of the
<code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genETMTree(n = 5)
</code></pre>

<hr>
<h2 id='genFordsAlphaTree'>Generation of rooted binary trees under Ford's alpha model</h2><span id='topic+genFordsAlphaTree'></span>

<h3>Description</h3>

<p><code>genFordsAlphaTree</code> - Generates a rooted binary tree in
<code>phylo</code> format with the given number of <code>n</code> leaves under Ford's
alpha model.
Ford's alpha model is not a rate-based evolutionary (tree)
construction and thus cannot generate edge lengths, only a topology.
Instead, it works as follows: The idea is to start with a cherry and
incrementally increase the size of the tree by adding a new leaf with
a leaf edge to any edge (inner or leaf edge), one at a time.
Given a tree with i leaves, then each of the i-1 inner edges (includes
an additional root edge) is chosen with probability
<code>ALPHA</code>/(i-<code>ALPHA</code>).
Each of the i leaf edges is chosen with probability
(1-<code>ALPHA</code>)/(i-<code>ALPHA</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFordsAlphaTree(n, ALPHA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genFordsAlphaTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genFordsAlphaTree_+3A_alpha">ALPHA</code></td>
<td>
<p>Numeric value &gt;=0 and &lt;=1 which specifies the probabilities of
picking an inner or a leaf edge. For certain choices of
<code>ALPHA</code> Ford's alpha model coincides with known models:<br />
</p>

<ul>
<li> <p><code>ALPHA</code> = 0: Yule model <br />
</p>
</li>
<li> <p><code>ALPHA</code> = 1/2: PDA model (all phylogenies equally probable) <br />
</p>
</li>
<li> <p><code>ALPHA</code> = 1: Caterpillar with <code>n</code> leaves
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genFordsAlphaTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> D. J. Ford. Probabilities on cladograms: introduction to the alpha
model, 2005. <br />
</p>
</li>
<li><p> G. Kaur, K. P. Choi, and T. Wu. Distributions of cherries and pitchforks
for the Ford model. Theoretical Population Biology, 149:27–38, 2023.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genFordsAlphaTree(n = 5, ALPHA = 0.3)
</code></pre>

<hr>
<h2 id='genGFBTree'>Generation of the greedy from the bottom tree</h2><span id='topic+genGFBTree'></span>

<h3>Description</h3>

<p><code>genGFBTree</code> - Generates the rooted binary greedy from the bottom  tree
in <code>phylo</code> format with the given number of <code>n</code> leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGFBTree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genGFBTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genGFBTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genGFBTree(n = 6)
</code></pre>

<hr>
<h2 id='genGrowTree'>Generation of rooted binary trees under tree growing models (no extinction)</h2><span id='topic+genGrowTree'></span>

<h3>Description</h3>

<p><code>genGrowTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under a specified
discrete-time tree growing model without extinction.
These tree growing models act at the leaves by varying their speciation
rates according to a parameter <code>ZETA</code> or variance <code>SIGMA</code>. They
may also depend on so-called trait values of the leaves (e.g., continuous or
discrete age, or another numeric trait that affects fitness).<br />
You may choose an already built-in model (see <code>use_built_in</code>) or
specify a (new) model by defining how the rates (and optionally traits)
change in every time step (see parameters <code>childRates</code> and
<code>otherRates</code> as well as <code>childTraits</code> and
<code>otherTraits</code>; see also Table 5 of the supplementary material of
the corresponding manuscript).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGrowTree(
  n,
  STARTING_RATE = 1,
  STARTING_TRAIT = 10,
  ZETA = 1,
  SIGMA = 0,
  childRates,
  otherRates,
  childTraits = NULL,
  otherTraits = NULL,
  use_built_in = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genGrowTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_starting_rate">STARTING_RATE</code></td>
<td>
<p>Positive numeric value (default = 1) which specifies the
initial rate at which the speciation events occur (has only influence on the
edge length, not on the tree topology).</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_starting_trait">STARTING_TRAIT</code></td>
<td>
<p>Numeric value (default = 10) which specifies
the initial state of a trait.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_zeta">ZETA</code></td>
<td>
<p>Constant non-negative numeric value (default = 1) which can
influence the speciation rates. Can also be a vector if used as such when
defining the functions <code>childRates</code>, <code>otherRates</code>,
<code>childTraits</code>, and <code>otherTraits</code>.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_sigma">SIGMA</code></td>
<td>
<p>Constant positive numeric value (default = 0) which can influence
the speciation rates. Can also be a vector if used as such when defining the
functions <code>childRates</code>, <code>otherRates</code>, <code>childTraits</code>, and
<code>otherTraits</code>.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_childrates">childRates</code></td>
<td>
<p>A function that generates two speciation rates for the
children emerging from a speciation event based on various factors. <br />
Necessary if <code>use_built_in</code> is not specified.
<code>childTraits</code> works similarly but is executed before
<code>childRates</code>. <br />
All available parameters are: <br />
</p>

<ul>
<li><p> the starting rate <code>sr</code>,  <br />
</p>
</li>
<li><p> the starting trait value <code>st</code>,  <br />
</p>
</li>
<li><p> the parent's rate <code>pr</code>,  <br />
</p>
</li>
<li><p> the parent's trait value <code>pt</code>,  <br />
</p>
</li>
<li><p> the children's trait values <code>ct</code> (vector <code>ct[1]</code> and
<code>ct[2]</code>), <br />
</p>
</li>
<li><p> the parameters zeta <code>ze</code>  <br />
</p>
</li>
<li><p> and sigma <code>si</code>. <br /><br />
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given.<br />
Example: <br />
<code>function (sr, st, pr, pt, ct, ze, si) return(c(pr*ze,
pr*(1-ze)))</code> for biased speciation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="genGrowTree_+3A_otherrates">otherRates</code></td>
<td>
<p>A function that generates a new speciation rate for all
leaves not affected by the speciation event (all but parent and children)
based on various factors. The function is applied after the speciation event,
i.e., after <code>childRates/Traits</code>.<br />
Necessary if <code>use_built_in</code> is not specified.
<code>otherTraits</code> works similarly. <br />
All available parameters are: <br />
</p>

<ul>
<li><p> the starting rate <code>sr</code>,  <br />
</p>
</li>
<li><p> the starting trait value <code>st</code>,  <br />
</p>
</li>
<li><p> the leaf's old rate <code>or</code>,  <br />
</p>
</li>
<li><p> the leaf's old trait value <code>ot</code>, <br />
</p>
</li>
<li><p> the parameters zeta <code>ze</code>  <br />
</p>
</li>
<li><p> and sigma <code>si</code>. <br /><br />
All parameters have to appear in the function definition but not
necessarily in the body of the function. Trait values are NA, if
<code>childTraits</code> and <code>otherTraits</code> is not given. <br />
Example: <br />
<code>function (sr, st, or, ot, ze, si) return(or*ze)</code> for
age-step-based fertility.
</p>
</li></ul>
</td></tr>
<tr><td><code id="genGrowTree_+3A_childtraits">childTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates two
trait values for the children emerging from a speciation event based on
various factors. <br />
See <code>childRates</code> for available parameters (except <code>ct</code>) and
explanations. Not necessary; is only applied if not NULL.<br />
Example: <br />
<code>function (sr, st, pr, pt, ze, si)
return(c(0, 0))</code> for age.</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_othertraits">otherTraits</code></td>
<td>
<p>An optional function (default = NULL) that generates a new
trait value for all leaves not affected by the speciation event (all but
parent and children) based on various factors. <br />
See <code>otherRates</code> for available parameters and explanations. <br />
Not necessary; is only applied if not NULL.<br />
Example:<br />
<code>function (sr, st, or, ot, ze, si) return(ot+1)</code>
for discrete age (age in time steps).</p>
</td></tr>
<tr><td><code id="genGrowTree_+3A_use_built_in">use_built_in</code></td>
<td>
<p>Optional (default = NULL): Character specifying which of
the already implemented models should be used. Overwrites <code>childRates</code>,
<code>otherRates</code>, <code>childTraits</code>, and <code>otherTraits</code>.<br />
Here is a list of available models with their (abbreviated) underlying
functions given in parentheses  (in order <code>childRates</code>,
<code>otherRates</code>; then <code>childTraits</code> and <code>otherTraits</code>
if necessary): <br />
</p>

<ul>
<li><p> &quot;DCO_sym&quot;: Symmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sr ze, sr ze), sr) <br />
</p>
</li>
<li><p> &quot;DCO_asym&quot;: Asymmetric direct-children-only, <code>ZETA</code>&gt;0
(c(sz, pr), sr) <br />
</p>
</li>
<li><p> &quot;IF_sym&quot;: Symmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr ze), or) <br />
</p>
</li>
<li><p> &quot;IF_asym&quot;: Asymmetric inherited fertility, <code>ZETA</code>&gt;0
(c(pr ze, pr), or) <br />
</p>
</li>
<li><p> &quot;IF-diff&quot;: Unequal fertility inheritance, <code>ZETA</code>&gt;=1
(c(2 pr ze / (ze+1), 2 pr / (ze+1)), or)<br />
</p>
</li>
<li><p> &quot;biased&quot;: Biased speciation, <code>ZETA</code> &gt;=0 and &lt;=1
(c(pr ze, pr (1-ze)), or)<br />
</p>
</li>
<li><p> &quot;ASB&quot;: Age-step-based fertility, <code>ZETA</code>&gt;0
(c(sr, sr), or ze)<br />
</p>
</li>
<li><p> &quot;simpleBrown_sym&quot;: Symmetric simple Brownian, <code>SIGMA</code>&gt; =0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100},
max{pr+ rnorm(1, mean=0, sd=si),1e-100}), or) <br />
</p>
</li>
<li><p> &quot;simpleBrown_asym&quot;: Asymmetric simple Brownian, <code>SIGMA</code>&gt;=0
(c(max{pr+ rnorm(1, mean=0, sd=si),1e-100}, pr), or) <br />
</p>
</li>
<li><p> &quot;lin-Brown_sym&quot;: Sym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},
max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}), ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown_asym&quot;: Asym. punctuated(-intermittent) linear-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
c(max{pt + rnorm(1, mean=0, sd=si[2]),1e-100}, pt, ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown-bounded_sym&quot;: Bounded sym. punctuated(-intermittent)
linear-Brownian,  <code>SIGMA</code> vector with two values &gt;=0,
<code>STARTING_TRAIT</code> is automatically set to 10 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20},
min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}), ot) <br />
</p>
</li>
<li><p> &quot;lin-Brown-bounded_asym&quot;: Bounded asym. punctuated(-intermittent)
linear-Brownian, <code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
c(min{max{pt + rnorm(1, mean=0, sd=si[2]),1e-100},20}, pt), ot) <br />
</p>
</li>
<li><p> &quot;log-Brown_sym&quot;: Sym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])),
10^(log(ct[2])+ rnorm(1, mean=0, sd=si[1]))), or; <br />
c(10^(log(pt)+ rnorm(1, mean=0, sd=si[2])),
10^(log(pt)+ rnorm(1, mean=0, sd=si[2]))), ot) <br />
</p>
</li>
<li><p> &quot;log-Brown_asym&quot;: Asym. punctuated(-intermittent) log-Brownian,
<code>SIGMA</code> vector with two values &gt;=0 <br />
(c(10^(log(ct[1])+ rnorm(1, mean=0, sd=si[1])), pr), or; <br />
10^(c(log(pt)+ rnorm(1, mean=0, sd=si[2])), pt), ot)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genGrowTree</code> A single tree of class <code>phylo</code> is
returned.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li>
<li><p> M. G. B. Blum and O. Francois. On statistical tests of phylogenetic tree
imbalance: the Sackin and other indices revisited. Mathematical Biosciences,
195(2):141–153, 2005.
</p>
</li>
<li><p> S. B. Heard. Patterns in phylogenetic tree balance with variable and
evolving speciation rates. Evolution, 50(6):2141–2148, 1996.
</p>
</li>
<li><p> S. J. Kersting. Genetic programming as a means for generating improved
tree balance indices (Master’s thesis, University of Greifswald), 2020.
</p>
</li>
<li><p> M. Kirkpatrick and M. Slatkin. Searching for evolutionary patterns in the
shape of a phylogenetic tree. Evolution, 47(4):1171–1181, 1993.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genGrowTree(n = 5, use_built_in = "IF_sym", ZETA = 2)
</code></pre>

<hr>
<h2 id='genMBTree'>Generation of the maximally balanced tree</h2><span id='topic+genMBTree'></span>

<h3>Description</h3>

<p><code>genMBTree</code> - Generates the rooted binary maximally balanced tree in
<code>phylo</code> format with the given number of <code>n</code> leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMBTree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genMBTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genMBTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genMBTree(n = 6)
</code></pre>

<hr>
<h2 id='genPDATree'>Generation of rooted binary trees under the PDA model</h2><span id='topic+genPDATree'></span>

<h3>Description</h3>

<p><code>genPDATree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the
proportional-to-distinguishable-arrangements model.
Given <code>n</code>, all phylogenies (trees with labeled leaves) with
<code>n</code> leaves are equiprobable under the PDA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genPDATree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genPDATree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genPDATree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtopology(..., rooted = T)</code> function of
the <code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019). <br />
</p>
</li>
<li><p> D. E. Rosen. Vicariant patterns and historical explanation in
biogeography. Systematic Zoology, 27(2):159, 1978.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genPDATree(n = 5)
</code></pre>

<hr>
<h2 id='genTrees'>Generation of rooted binary trees under a given tree model</h2><span id='topic+genTrees'></span>

<h3>Description</h3>

<p><code>genTrees</code> - Is a wrapper function that generates
<code>Ntrees</code>-many rooted binary trees with the given number of <code>n</code>
leaves under any tree model <code>tm</code> contained in this package (more
details on the available models are given in the parameter information
for <code>tm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTrees(n, Ntrees = 1L, tm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genTrees_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0. <br />
Due to the restrictions of the <code>phylo</code> or <code>multiPhylo</code> format,
the number of leaves must be at least 2 since there
must be at least one edge.</p>
</td></tr>
<tr><td><code id="genTrees_+3A_ntrees">Ntrees</code></td>
<td>
<p>Integer value (default = 1) that specifies the desired number
of generated trees.</p>
</td></tr>
<tr><td><code id="genTrees_+3A_tm">tm</code></td>
<td>
<p>Character or list specifying the tree model under which the trees
should be generated as well as their parameters. Available are: <br />
</p>

<ul>
<li> <p><code>"yule"</code> - Yule model. <br />
</p>
</li>
<li> <p><code>"pda"</code> - PDA model. <br />
</p>
</li>
<li> <p><code>"etm"</code> - ETM. <br />
</p>
</li>
<li> <p><code>list("aldous", BETA)</code> - Aldous' beta splitting model with parameter
<code>BETA</code> &gt;= -2. <br />
</p>
</li>
<li> <p><code>list("ford", ALPHA)</code> - Ford's alpha model with parameter
<code>ALPHA</code> &gt;= 0 and &lt;= 1. <br />
</p>
</li>
<li> <p><code>list("alt-birth-death", BIRTHRATE, DEATHRATE)</code> or <br />
<code>list("alt-birth-death", BIRTHRATE, DEATHRATE, TRIES)</code> -
Alternative birth-death model with parameters <code>BIRTHRATE</code> &gt;0 and
<code>DEATHRATE</code>&gt;= 0. <br />
</p>
</li>
<li> <p><code>list("density", BIRTHRATE, EQUILIB)</code> or <br />
<code>list("density", BIRTHRATE, EQUILIB, TRIES, TIMEperTRY)</code> -
Density dependent model with parameters <code>BIRTHRATE</code> &gt;0 and
<code>EQULIB</code>&gt;= 1. <br />
</p>
</li>
<li> <p><code>list("BiSSE", BIRTHRATES, DEATHRATES, TRANSRATES)</code> or <br />
<code>list("BiSSE", BIRTHRATES, DEATHRATES, TRANSRATES, TRIES, TIMEperTRY)</code> -
BiSSE model with parameters <code>BIRTHRATES</code> (vector with 2 values &gt;=0, one
value &gt;0),
<code>DEATHRATES</code> (vector with 2 values &gt;=0), and
<code>TRANSRATES</code> (vector with 2 values &gt;=0, one
value &gt;0). <br />
</p>
</li>
<li> <p><code>list("DCO_sym", ZETA)</code> or <br />
<code>list("DCO_sym", ZETA, STARTING_RATE)</code> - Symmetric direct-children-only
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("DCO_asym", ZETA)</code> or <br />
<code>list("DCO_asym", ZETA, STARTING_RATE)</code> - Asymmetric
direct-children-only with parameter <code>ZETA</code> &gt; 0 and optionally
<code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF_sym", ZETA)</code> or <br />
<code>list("IF_sym", ZETA, STARTING_RATE)</code> - Symmetric inherited fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF_asym", ZETA)</code> or <br />
<code>list("IF_asym", ZETA, STARTING_RATE)</code> - Asymmetric inherited fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("IF-diff", ZETA)</code> or <br />
<code>list("IF-diff", ZETA, STARTING_RATE)</code> - Unequal fertility inheritance
with parameter <code>ZETA</code> &gt;= 1 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("biased", ZETA)</code> or <br />
<code>list("biased", ZETA, STARTING_RATE)</code> - Biased speciation
with parameter <code>ZETA</code> &gt;=0 and &lt;=1 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("ASB", ZETA)</code> or <br />
<code>list("ASB", ZETA, STARTING_RATE)</code> - Age-step-based fertility
with parameter <code>ZETA</code> &gt; 0 and optionally <code>STARTING_RATE</code> &gt; 0
(default = 1). <br />
</p>
</li>
<li> <p><code>list("simpleBrown_sym", SIGMA)</code> or <br />
<code>list("simpleBrown_sym", SIGMA, STARTING_RATE)</code> - Symmetric simple
Brownian with parameter <code>SIGMA</code> &gt;= 0 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("simpleBrown_asym", SIGMA)</code> or <br />
<code>list("simpleBrown_asym", SIGMA, STARTING_RATE)</code> - Asymmetric simple
Brownian with parameter <code>SIGMA</code> &gt;= 0 and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1). <br />
</p>
</li>
<li> <p><code>list("lin-Brown_sym", SIGMA)</code> or <br />
<code>list("lin-Brown_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Sym.
punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown_asym", SIGMA)</code> or <br />
<code>list("lin-Brown_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Asym.
punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown-bounded_sym", SIGMA)</code> or <br />
<code>list("lin-Brown-bounded_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> -
Bounded sym. punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("lin-Brown-bounded_asym", SIGMA)</code> or <br />
<code>list("lin-Brown-bounded_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> -
Bounded asym. punctuated(-intermittent) linear-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("log-Brown_sym", SIGMA)</code> or <br />
<code>list("log-Brown_sym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Sym.
punctuated(-intermittent) log-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br />
</p>
</li>
<li> <p><code>list("log-Brown_asym", SIGMA)</code> or <br />
<code>list("log-Brown_asym", SIGMA, STARTING_RATE, STARTING_TRAIT)</code> - Asym.
punctuated(-intermittent) log-Brownian with parameter
<code>SIGMA</code> (vector with 2 values &gt;=0) and optionally
<code>STARTING_RATE</code> &gt; 0 (default = 1) and <code>STARTING_TRAIT</code>
(default = 10). <br /><br />
More information on each model and their parameters can be found in the
description of each model, accessible with <code>?genYuleTree</code>,
<code>?genPDATree</code>, <code>?genETMTree</code>, <code>?genAldousBetaTree</code>,
<code>?genFordsAlphaTree</code>, <br /> <code>?genBirthDeathTree</code>,
<code>?genAltBirthDeathTree</code>, <code>?genGrowTree</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genTrees</code>   If <code>Ntrees</code> is 1, then a single tree of
class <code>phylo</code> is returned.
If <code>Ntrees</code> is larger than 1, a list of class
<code>multiPhylo</code> containing the trees of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic
models: Supplementary material. https://tinyurl.com/278cwdh8, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genTrees(n = 5, Ntrees = 2, tm = list("aldous", 1))
genTrees(n = 5, tm = "pda")
</code></pre>

<hr>
<h2 id='genYuleTree'>Generation of rooted binary trees under the Yule model</h2><span id='topic+genYuleTree'></span>

<h3>Description</h3>

<p><code>genYuleTree</code> - Generates a rooted binary tree in <code>phylo</code>
format with the given number of <code>n</code> leaves under the Yule model.
The Yule process is a simple birth-process in which all species have the same
speciation rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genYuleTree(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genYuleTree_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.<br />
Due to the restrictions of the <code>phylo</code> or <code>multiphylo</code> format,
the number of leaves must be at least 2 since there must be at
least one edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>genYuleTree</code> A single tree of class <code>phylo</code> is returned.
</p>


<h3>References</h3>


<ul>
<li><p> This function uses the <code>rtree</code> function of the <code>ape</code> package
(E. Paradis, K. Schliep. “ape 5.0: an environment for modern
phylogenetics and evolutionary analyses in R.”
Bioinformatics, 35, 526-528, 2019). <br />
</p>
</li>
<li><p> G. U. Yule. A mathematical theory of evolution, based on the conclusions of
Dr. J. C. Willis, F. R. S. Philosophical Transactions of the Royal Society
of London. Series B, Containing Papers of a Biological
Character, 213(402-410):21–87, 1925. <br />
</p>
</li>
<li><p> E. F. Harding. The probabilities of rooted tree-shapes generated by random
bifurcation. Advances in Applied Probability, 3(1):44–77, 1971.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>genYuleTree(n = 5)
</code></pre>

<hr>
<h2 id='getAccRegion'>Functions for computing the region of acceptance</h2><span id='topic+getAccRegion'></span><span id='topic+getAccRegion_sampled'></span><span id='topic+getAccRegion_exact'></span><span id='topic+computeAccRegion'></span>

<h3>Description</h3>

<p><code>getAccRegion</code> - Computes the region of acceptance based on quantiles
for a specified level of significance and method.
</p>
<p><code>getAccRegion_sampled</code> - Computes a sampling-based region of acceptance
for the given null model based on quantiles for a specified level of
significance and method.
</p>
<p><code>getAccRegion_exact</code> - Computes the exact region of acceptance for the
given null model based on quantiles for a specified level of significance
and method. Currently, this is only implemented for
<code>null_model = "yule"</code> or <code>"pda"</code>, and <code>n</code>&lt;=20.
</p>
<p><code>computeAccRegion</code> - Computes the bounds of the region of acceptance
given the empirical distribution function (specified by the unique values
and their probabilities under the null model) for specified cut-offs
(e.g., 0.025 on both sides for a symmetric two-tailed test).
For values strictly outside of the interval the null hypothesis is
rejected. <br />
This function also computes the probabilities to
reject the null hypothesis if the value equals the lower or upper bound of
the region of acceptance. This probability is 0 for correction method
&quot;none&quot; and for &quot;small-sample&quot; it ensures that the probability of rejection
exactly corresponds with the specified cut-offs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccRegion(
  tss,
  null_model = "yule",
  n,
  distribs = "exact_if_possible",
  N_null = 10000L,
  N_alt = 1000L,
  N_intervals = 1000L,
  test_type = "two-tailed",
  correction = "small-sample",
  sig_lvl = 0.05
)

getAccRegion_sampled(
  tss,
  null_model = "yule",
  n,
  N_null,
  N_alt = 1000L,
  N_intervals = 1000L,
  test_type = "two-tailed",
  correction = "small-sample",
  sig_lvl = 0.05
)

getAccRegion_exact(
  tss,
  null_model = "yule",
  n,
  N_alt = 1000L,
  N_intervals = 1000L,
  test_type = "two-tailed",
  correction = "small-sample",
  sig_lvl = 0.05
)

computeAccRegion(
  unique_null_vals,
  unique_null_probs,
  correction,
  cutoff_left,
  cutoff_right
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAccRegion_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_null_model">null_model</code></td>
<td>
<p>The null model that is to be used to determine the power
of the tree shape statistics. In general, it must be a function that
produces rooted binary trees in <code>phylo</code> format. <br />
If the respective model is included in this
package, then specify the model and its parameters by using a character
or list. Available are all options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (with the two input parameters
<code>n</code> and <code>Ntrees</code>). Example: <br />
Use <code>"new_tm"</code> for the list object
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_distribs">distribs</code></td>
<td>
<p>Determines how the distributions (and with that the
bounds of the critical region) are computed. Available are: <br />
</p>

<ul>
<li><p> &quot;exact_if_possible&quot; (default): Tries to compute the exact distribution
under the null model if possible. Currently, this is only implemented for
<code>null_model = "yule"</code>, <code>"pda"</code>, or <code>"etm"</code>, and
<code>n</code>&lt;=20. In all other cases the distribution is approximated
by sampling <code>N_null</code> many trees under the null model as in the
option &quot;sampled&quot; below. <br />
</p>
</li>
<li><p> &quot;sampled&quot;: <code>N_null</code> many trees are sampled under the
null model to approximate the distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAccRegion_+3A_n_null">N_null</code></td>
<td>
<p>Sample size (integer &gt;=10) if distributions are sampled
(default = 10000L).</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_n_alt">N_alt</code></td>
<td>
<p>Sample size (integer &gt;=10) for the alternative models to
estimate the power (default = 1000L). Only needed here if the
<code>test_type</code> is &quot;two-tailed-unbiased&quot;.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_n_intervals">N_intervals</code></td>
<td>
<p>Number (integer &gt;=3, default = 1000L) of different
quantile/cut-off pairs investigated as potential bounds of the region of
acceptance. This parameter is only necessary if the <code>test_type</code> is
&quot;two-tailed-unbiased&quot;.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_test_type">test_type</code></td>
<td>
<p>Determines the method. Available are: <br />
</p>

<ul>
<li><p> &quot;two-tailed&quot; (default): The lower and upper bound of the region of
acceptance are determined based on the (empirical) distribution function
such that P(TSS &lt; lower bound) &lt;= <code>sig_lvl</code>/2 and
P(TSS &gt; upper bound) &lt;= <code>sig_lvl</code>/2. See parameter <code>correction</code>
for specifying how conservative the test should be: the null
hypothesis can either be rejected only if the values are strictly outside of
this region of acceptance (can be too conservative) or it can also be
rejected (with certain probabilities) if the value equals the lower or
upper bound.<br />
</p>
</li>
<li><p> &quot;two-tailed-unbiased&quot;: Experimental - Use with caution!<br />
The region of acceptance is optimized to yield an unbiased test, i.e., a test
that identifies non-null models with a probability of at least
<code>sig_lvl</code>.
The region of acceptance is determined similar to the default method.
However, it need not be symmetrical, i.e., not necessarily
cutting off <code>sig_lvl</code>/2 on both sides. Also see parameter
<code>correction</code> for specifying how conservative the test should be.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAccRegion_+3A_correction">correction</code></td>
<td>
<p>Specifies the desired correction method.
Available are: <br />
</p>

<ul>
<li><p> &quot;small-sample&quot; (default): This method tries to ensure that the critical
region, i.e., the range of values for which the null hypothesis is rejected,
is as close to <code>sig_lvl</code> as possible (compared with &quot;none&quot; below, which
can be too conservative). The idea is that the null hypothesis is also
rejected with certain probabilities if the value matches a bound of the
region of acceptance. <br />
</p>
</li>
<li><p> &quot;none&quot;: No correction method is applied. With that the test might be
slightly too conservative as the null hypothesis is maintained if the values
are &gt;= the lower and &lt;= the upper bound.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getAccRegion_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_unique_null_vals">unique_null_vals</code></td>
<td>
<p>Numeric vector containing all the unique values under
the null model.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_unique_null_probs">unique_null_probs</code></td>
<td>
<p>Numeric vector containing the corresponding
probabilities of the unique values under the null model.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_cutoff_left">cutoff_left</code></td>
<td>
<p>Numeric value (&gt;=0, &lt;1) specifying the cut-off of the
distribution for the lower bound of the region of acceptance. The sum of
the two cut-offs must be &lt;1.</p>
</td></tr>
<tr><td><code id="getAccRegion_+3A_cutoff_right">cutoff_right</code></td>
<td>
<p>Numeric value (&gt;=0, &lt;1) specifying the cut-off of the
distribution for the upper bound of the region of acceptance. The sum of
the two cut-offs must be &lt;1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getAccRegion</code> Numeric matrix (one row per TSS) with four
columns: The first two columns contain the interval limits of the region
of acceptance, i.e., we reject the null hypothesis for values strictly
outside of this interval. The third and fourth columns contain the
probabilities to reject the null hypothesis if values equal the lower or
upper bound, respectively.
</p>
<p><code>getAccRegion_sampled</code> Numeric matrix (one row per TSS) with
four columns - similar as <code>getAccRegion</code>.
</p>
<p><code>getAccRegion_exact</code> Numeric matrix (one row per TSS) with
four columns - similar as <code>getAccRegion</code>.
</p>
<p><code>computeAccRegion</code> Numeric vector with
four columns - similar as <code>getAccRegion</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAccRegion(tss = c("Sackin", "Colless", "B1I"), n = 6L)
getAccRegion(tss = c("Sackin", "Colless", "B1I"), n = 6L, null_model = "etm",
             N_null = 20L, correction = "none", distribs = "sampled")
getAccRegion(tss = c("Sackin", "Colless", "B1I"), n = 6L, N_null = 20L,
             test_type = "two-tailed-unbiased", N_intervals = 5L,
             N_alt = 10L)
getAccRegion_sampled(tss = c("Sackin", "Colless", "B1I"), n = 6L,
                     N_null = 20L, correction = "none")
getAccRegion_exact(tss = c("Sackin", "Colless", "B1I"),
                   null_model = "etm", n = 8L)
computeAccRegion(unique_null_vals = c(1,2,3,4,5),
                 unique_null_probs = c(0.1,0.4,0.1,0.2,0.2),
                 correction = "small-sample",
                 cutoff_left = 0.15, cutoff_right = 0.15)
</code></pre>

<hr>
<h2 id='getPowerMultTSS'>Function for computing the power given the region of acceptance</h2><span id='topic+getPowerMultTSS'></span>

<h3>Description</h3>

<p><code>getPowerMultTSS</code> - Computes the power of one or multiple TSS by
calculating the proportion of values outside the region of acceptance for
a single alternative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPowerMultTSS(accept_regions, alt_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPowerMultTSS_+3A_accept_regions">accept_regions</code></td>
<td>
<p>Numeric matrix (one row per TSS) with two or four
columns: The first two columns contain the interval limits of the region
of acceptance, i.e., we reject the null hypothesis for values strictly
outside of this interval. The third and fourth columns contain the
probabilities to reject the null hypothesis if values equal the lower or
upper bound, respectively. If the last two columns are missing they are
interpreted as zeroes. See return value of <code>getAccRegion()</code>.</p>
</td></tr>
<tr><td><code id="getPowerMultTSS_+3A_alt_data">alt_data</code></td>
<td>
<p>Numeric matrix  (one row per TSS) with values under the
alternative model.
If there is only one TSS, then it can be a simple vector of values instead
(returns a single unnamed value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getPowerMultTSS</code> A vector containing the power regarding the
given TSS (retains row names of <code>accept_regions</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with small data (with/without third and fourth column):
getPowerMultTSS(accept_regions = c(2,3, 0,0), alt_data = c(1,2,4,5))
getPowerMultTSS(accept_regions = c(2,3, 0.5,1), alt_data = c(1,2,4,5))
# Example with multiple rows/TSS:
getPowerMultTSS(accept_regions = matrix(c(2,3,0,0,
                                          20,30,0.5,0.5),
                                   nrow = 2, byrow = TRUE,
                                   dimnames = list(c("TSS1", "TSS2"), NULL)),
                alt_data = matrix(c(  1,2,3,4,
                                    10,20,30,40),
                                  nrow = 2, byrow = TRUE,
                                  dimnames = list(c("TSS1", "TSS2"), NULL)))
# Example with generated TSS data:
getPowerMultTSS(accept_regions = getAccRegion(tss = c("Colless","SNI"),
                                              n = 6L),
                alt_data = getTSSdata(tss = c("Colless", "SNI"), n = 6L,
                                      Ntrees = 20L, tm = list("aldous", -1)))
</code></pre>

<hr>
<h2 id='getTSSdata'>Functions for generating the TSS data under a tree model</h2><span id='topic+getTSSdata'></span><span id='topic+getTSSdata_trees'></span>

<h3>Description</h3>

<p><code>getTSSdata</code> - Compute the tree shape statistics of trees generated
under a tree model for each given TSS.
</p>
<p><code>getTSSdata_trees</code> - Compute the tree shape statistics for each given
TSS and all given trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTSSdata(tss, n, Ntrees = 1L, tm)

getTSSdata_trees(tss, treeList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTSSdata_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_ntrees">Ntrees</code></td>
<td>
<p>Integer value (default = 1) that specifies the desired number
of generated trees.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_tm">tm</code></td>
<td>
<p>If the respective model is included in this package, then specify
the model and its parameters by using a character or list. Available are all
options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (with the two input parameters
<code>n</code> and <code>Ntrees</code>). Example: <br />
Use <code>"new_tm"</code> for the list object
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="getTSSdata_+3A_treelist">treeList</code></td>
<td>
<p>List of trees of class <code>multiphylo</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getTSSdata</code> Numeric matrix of TSS values (one row per TSS).
</p>
<p><code>getTSSdata_trees</code> Numeric matrix of TSS values
(one row per TSS).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using tree models and TSS included in this package:
getTSSdata(tss = c("Colless", "Sackin"), n = 5L, Ntrees = 3L,
           tm = list("aldous", -1))
# Example using a "new" tree model and a "new" TSS provided by the user:
my_aldous &lt;- list(func = function(n, Ntrees){
                        trees &lt;- lapply(1:Ntrees,
                           function(x){genAldousBetaTree(n = n, BETA =5L)})
                        attr(trees, "class") &lt;- "multiPhylo"
                        return(trees)})
my_avd &lt;- list(func = treebalance::avgVertDep, short = "My AVD")
getTSSdata(tss = c("Colless", "my_avd"), n = 5L, Ntrees = 3L,
           tm = "my_aldous")
# Example using TSS provided in tssInfo.
getTSSdata_trees(tss = c("Colless", "Sackin"),
           treeList = genTrees(n = 5L, Ntrees = 3L, tm = "yule"))
# Example using a "new" TSS provided by the user.
my_avd &lt;- list(func = treebalance::avgVertDep, short = "My AVD")
getTSSdata_trees(tss = c("Colless", "my_avd"),
           treeList = genTrees(n = 5L, Ntrees = 3L,
                               tm = list("IF_sym", 2)))
</code></pre>

<hr>
<h2 id='getTSSnames'>Get information on included tree shape statistics</h2><span id='topic+getTSSnames'></span><span id='topic+getTSSsimple'></span><span id='topic+getTSScolors'></span><span id='topic+getTSSsafe_n'></span><span id='topic+getTSStype'></span><span id='topic+getTSSonly_bin'></span><span id='topic+getAllTSS'></span>

<h3>Description</h3>

<p><code>getTSSnames</code> - Returns the full names (character/expression) of the
TSS.
</p>
<p><code>getTSSsimple</code> - Returns the simple names (character/expression) of the
TSS.
</p>
<p><code>getTSScolors</code> - Returns the colors of the TSS.
</p>
<p><code>getTSSsafe_n</code> - Returns the ranges of n that can be safely used.
</p>
<p><code>getTSStype</code> - Returns the types of the TSS, i.e., whether they are
balance or imbalance indices, or simple tree shape statistics.
</p>
<p><code>getTSSonly_bin</code> - Returns TRUE/FALSE vector: TRUE if TSS is only for
binary trees and FALSE otherwise.
</p>
<p><code>getAllTSS</code> - Returns the short names of all TSS that are safe to
use for the specified <code>n</code>, have one of the specified <code>types</code> and
can be applied to (non-)binary trees (<code>not_only_bin</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTSSnames(tss_shorts)

getTSSsimple(tss_shorts)

getTSScolors(tss_shorts)

getTSSsafe_n(tss_shorts)

getTSStype(tss_shorts)

getTSSonly_bin(tss_shorts)

getAllTSS(n = NULL, not_only_bin = FALSE, types = c("tss", "bali", "imbali"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTSSnames_+3A_tss_shorts">tss_shorts</code></td>
<td>
<p>Vector of short names (characters) of TSS contained in
<code>tssInfo</code>.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_n">n</code></td>
<td>
<p>Integer value or vector of integer values, that
specifies the number(s) of leaves.
If NULL (default), then <code>getAllSafeTSS</code> returns the short names of all
TSS contained in <code>tssInfo</code>.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_not_only_bin">not_only_bin</code></td>
<td>
<p>Select TRUE if you also want to analyze non-binary trees
and therefore want to filter out any TSS that only work on binary trees.
Otherwise, select FALSE (default) if all TSS are applicable.</p>
</td></tr>
<tr><td><code id="getTSSnames_+3A_types">types</code></td>
<td>
<p>Character vector, that specifies all permissible TSS types. The
vector may contain a subset of <code>c("tss", "bali", "imbali")</code> to indicate
if balance indices, imbalance indices or mere TSS should be included. By
default all types are permissible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getTSSnames</code> Vector of characters/expressions.
</p>
<p><code>getTSSsimple</code> Vector of characters/expressions.
</p>
<p><code>getTSScolors</code> Vector of characters (color names).
</p>
<p><code>getTSSsafe_n</code> Numeric matrix, one row per TSS and two columns
with lower and upper limit.
</p>
<p><code>getTSStype</code> Vector of characters (types as factors).
</p>
<p><code>getTSSonly_bin</code> Logical vector.
</p>
<p><code>getAllTSS</code> Character vector of short names of TSS
contained in <code>tssInfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTSSnames(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSsimple(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSScolors(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSsafe_n(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSStype(tss_shorts = c("Sackin", "Colless", "B1I"))
getTSSonly_bin(tss_shorts = c("Sackin", "Colless", "B1I"))
getAllTSS(n = c(3,30))
</code></pre>

<hr>
<h2 id='plot.poweRbal_data'>Plot method for poweRbal_data objects</h2><span id='topic+plot.poweRbal_data'></span>

<h3>Description</h3>

<p>This function generates a plot for an object of class <code>poweRbal_data</code>.
Creates a bar plot if <code>alt_model_params</code> and <code>x$alt_model_params</code>
= NULL and a line plot otherwise if this information is given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poweRbal_data'
plot(
  x,
  tss_names = NULL,
  tss_colors = NULL,
  sig_lvl = NULL,
  legend_pos = "topright",
  alt_model_names = NULL,
  alt_model_params = NULL,
  tss_ltys = NULL,
  alt_model_family = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.poweRbal_data_+3A_x">x</code></td>
<td>
<p>An object of class <code>poweRbal_data</code>, which is a list containing
one mandatory element, <code>power</code>, and several optional elements:<br />
</p>

<ul>
<li> <p><code>power</code>: A numeric matrix containing the power values (one row per
TSS and one column per alternative model).<br />
</p>
</li>
<li> <p><code>accept_regions</code>: A numeric matrix containing information on the
region of acceptance (one row per TSS and four columns).<br />
</p>
</li>
<li> <p><code>CIradius</code>: A numeric matrix containing the confidence interval
radii (one row per TSS and one column per alternative model).<br />
</p>
</li>
<li> <p><code>actual_sample_sizes</code>: A numeric vector containing the actual sample
sizes under each alternative model, as some models do not always
successfully generate trees.<br />
</p>
</li>
<li> <p><code>alt_model_params</code>: A numeric vector (one element per alternative
model) containing the values of a tree model parameter. This is only
suitable if the alternative models all belong to the same tree model
family and differ only in one parameter.<br />
</p>
</li>
<li><p> Other input data from the <code>powerComp()</code> function, such as <code>tss</code>,
<code>null_model</code>, <code>alt_models</code>, <code>n</code>, <code>distribs</code>,
<code>N_null</code>, <code>N_alt</code>, <code>test_type</code>, <code>correction</code>, and
<code>sig_lvl</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_tss_names">tss_names</code></td>
<td>
<p>Vector of characters/expression of the TSS names (default
= NULL). If none are provided, <code>x$tss</code> is used for the names
of the TSS if existent and otherwise the row names of <code>x$power</code>
are used.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_tss_colors">tss_colors</code></td>
<td>
<p>Vector of colors for the TSS (default = NULL).</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1)
depicted as a dashed horizontal line. Not depicted if set to NULL.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_legend_pos">legend_pos</code></td>
<td>
<p>Character specifying where the legend is displayed
(default = &quot;topright&quot;). No legend is displayed if set to NULL.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_alt_model_names">alt_model_names</code></td>
<td>
<p>Vector of characters/expression of the model names
(default = NULL). If none are provided, the column names of
<code>x$power</code> are used as names for the models.<br />
Only used if <code>alt_model_params</code> and <code>x$alt_model_params</code> = NULL.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_alt_model_params">alt_model_params</code></td>
<td>
<p>Numeric vector containing the parameter
values of the representatives of the tree model (default = NULL). If none
are provided, <code>x$alt_model_params</code> is used if existent.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_tss_ltys">tss_ltys</code></td>
<td>
<p>Vector of line types for the TSS (default = NULL).<br />
Not used if <code>alt_model_params</code> and <code>x$alt_model_params</code> = NULL.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_alt_model_family">alt_model_family</code></td>
<td>
<p>Vector of characters/expressions of the name of the
tree model family and of the parameter (default = NULL), e.g.
<code>c("Aldous\'", expression(beta))</code>.
If none is provided, the first column name of <code>x$power</code> is used.<br />
Not used if <code>alt_model_params</code> and <code>x$alt_model_params</code> = NULL.</p>
</td></tr>
<tr><td><code id="plot.poweRbal_data_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>plot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot.poweRbal_data</code> No return value, as the primary purpose
of this function is the side effect (plotting).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plotting a 'poweRbal_data' object:
pc1 &lt;- powerComp(tss = c("Sackin", "Colless", "B1I"),
                 alt_models = list(list("aldous",-1), "pda", "etm"),
                 n = 8L, N_null = 40L, N_alt = 20L)
plot(pc1)
# Plotting a power comparison with a tree model family
pc2 &lt;- powerComp(tss = c("Sackin", "Colless", "B1I"),
               alt_models = list(list("aldous", -1.5),
                                 list("aldous", -1),list("aldous", -0.5),
                                 list("aldous", 0),list("aldous", 0.5)),
               n=20L, N_null = 20L, N_alt = 10L, distribs = "sampled")
# Create a bar plot or ...
plot(pc2)
# ... a line plot by specifying 'alt_model_params'.
plot(pc2, alt_model_params = c(-1.5,-1,-0.5,0,0.5),
     tss_names = getTSSnames(c("Sackin", "Colless", "B1I")),
     tss_colors = getTSScolors(c("Sackin", "Colless", "B1I")),
     alt_model_family = c("Aldous\'", expression(beta)),
     ylim = c(0,1))
</code></pre>

<hr>
<h2 id='powerComp'>Comparison of the power of TSS under different models</h2><span id='topic+powerComp'></span><span id='topic+powerComp_RegAcc'></span>

<h3>Description</h3>

<p><code>powerComp</code> - Compare the power of a set of TSS to identify trees
generated under different alternative models given a null model.
</p>
<p><code>powerComp_RegAcc</code> - Compare the power of a set of TSS to identify trees
generated under different alternative models given a the region(s) of
acceptance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerComp(
  tss,
  null_model = "yule",
  alt_models,
  n,
  distribs = "exact_if_possible",
  N_null = 10000L,
  N_alt = 1000L,
  test_type = "two-tailed",
  correction = "small-sample",
  sig_lvl = 0.05
)

powerComp_RegAcc(
  tss,
  accept_regions,
  null_model,
  alt_models,
  n,
  distribs = "exact_if_possible",
  N_null = 10000L,
  N_alt = 1000L,
  test_type = "two-tailed",
  correction = "small-sample",
  sig_lvl = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerComp_+3A_tss">tss</code></td>
<td>
<p>Vector containing the names (as character) of the tree shape
statistics that should be compared. You may either use the short names
provided in <code>tssInfo</code> to use the already included TSS, or use the
name of a list object containing similar information as the entries in
<code>tssInfo</code>. Example:<br />
Use <code>"new_tss"</code> as the name for the list object
<code>new_tss</code> containing at least the function
<code>new_tss$func = function(tree){...}</code>,
and optionally also the information <code>new_tss$short</code>,
<code>new_tss$simple</code>, <code>new_tss$name</code>, <code>new_tss$type</code>,
<code>new_tss$only_binary</code>, and <code>new_tss$safe_n</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_null_model">null_model</code></td>
<td>
<p>The null model that is to be used to determine the power
of the tree shape statistics. In general, it must be a function that
produces rooted binary trees in <code>phylo</code> format. <br />
If the respective model is included in this
package, then specify the model and its parameters by using a character
or list. Available are all options listed under parameter <code>tm</code> in
the documentation of function <code>genTrees</code> (type <code>?genTrees</code>).<br />
If you want to include your own tree model, then use the
name of a list object containing the function (dependent on one parameter
<code>n</code>). Example: <br />
Use <code>"new_tm"</code> for the list object <br />
<code>new_tm &lt;- list(func = function(n, Ntrees){...})</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_alt_models">alt_models</code></td>
<td>
<p>List containing the alternative models that are to be
used to determine the power of the tree shape statistics. Functions that
produce rooted binary trees in <code>phylo</code> format. The information of each
single model must be in the format described for <code>null_model</code>.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_n">n</code></td>
<td>
<p>Integer value that specifies the desired number of leaves, i.e.,
vertices with in-degree 1 and out-degree 0.</p>
</td></tr>
<tr><td><code id="powerComp_+3A_distribs">distribs</code></td>
<td>
<p>Determines how the distributions (and with that the
bounds of the critical region) are computed. Available are: <br />
</p>

<ul>
<li><p> &quot;exact_if_possible&quot; (default): Tries to compute the exact distribution
under the null model if possible. Currently, this is only implemented for
<code>null_model = "yule"</code>, <code>"pda"</code>, or <code>"etm"</code>, and
<code>n</code>&lt;=20. In all other cases the distribution is approximated
by sampling <code>N_null</code> many trees under the null model as in the
option &quot;sampled&quot; below. <br />
</p>
</li>
<li><p> &quot;sampled&quot;: <code>N_null</code> many trees are sampled under the
null model to approximate the distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerComp_+3A_n_null">N_null</code></td>
<td>
<p>Sample size (integer &gt;=10) if distributions are sampled
(default = 10000L).</p>
</td></tr>
<tr><td><code id="powerComp_+3A_n_alt">N_alt</code></td>
<td>
<p>Sample size (integer &gt;=10) for the alternative models to
estimate the power (default = 1000L).</p>
</td></tr>
<tr><td><code id="powerComp_+3A_test_type">test_type</code></td>
<td>
<p>Determines the method. Available are: <br />
</p>

<ul>
<li><p> &quot;two-tailed&quot; (default): The lower and upper bound of the region of
acceptance are determined based on the (empirical) distribution function
such that P(TSS &lt; lower bound) &lt;= <code>sig_lvl</code>/2 and
P(TSS &gt; upper bound) &lt;= <code>sig_lvl</code>/2. See parameter <code>correction</code>
for specifying how conservative the test should be: the null
hypothesis can either be rejected only if the values are strictly outside of
this region of acceptance (can be too conservative) or it can also be
rejected (with certain probabilities) if the value equals the lower or
upper bound.<br />
</p>
</li>
<li><p> &quot;two-tailed-unbiased&quot;: Experimental - Use with caution!<br />
The region of acceptance is optimized to yield an unbiased test, i.e., a test
that identifies non-null models with a probability of at least
<code>sig_lvl</code>.
The region of acceptance is determined similar to the default method.
However, it need not be symmetrical, i.e., not necessarily
cutting off <code>sig_lvl</code>/2 on both sides. Also see parameter
<code>correction</code> for specifying how conservative the test should be.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerComp_+3A_correction">correction</code></td>
<td>
<p>Specifies the desired correction method.
Available are: <br />
</p>

<ul>
<li><p> &quot;small-sample&quot; (default): This method tries to ensure that the critical
region, i.e. the range of values for which the null hypothesis is rejected,
is as close to <code>sig_lvl</code> as possible (compared with &quot;none&quot; below, which
can be too conservative). The idea is that the null hypothesis is also
rejected with certain probabilities if the value matches the value of a
quantile. <br />
</p>
</li>
<li><p> &quot;none&quot;: No correction method is applied. With that the test might be
slightly too conservative as the null hypothesis is maintained if the values
is &gt;= the lower and &lt;= the upper quantile.
</p>
</li></ul>
</td></tr>
<tr><td><code id="powerComp_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default = 0.05, must be &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="powerComp_+3A_accept_regions">accept_regions</code></td>
<td>
<p>Numeric matrix (one row per TSS) with two or four
columns: The first two columns contain the interval limits of the region
of acceptance, i.e., we reject the null hypothesis for values strictly
outside of this interval. The third and fourth columns contain the
probabilities to reject the null hypothesis if values equal the lower or
upper bound, respectively. If the last two columns are missing they are
interpreted as zeroes. See return value of <code>getAccRegion()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>powerComp</code>  Returns an object of class 'poweRbal_data' which
is a list containing the following objects:<br />
</p>

<ul>
<li><p> power: Numeric matrix containing the power values (one row per TSS and one
column per alternative model).<br />
</p>
</li>
<li><p> accept_regions: Numeric matrix containing the information on the region of
acceptance (one row per TSS and four columns).<br />
</p>
</li>
<li><p> CIradius: Numeric matrix containing the confidence interval radii (one row
per TSS and one column per alternative model).<br />
</p>
</li>
<li><p> actual_sample_sizes: Numeric vector containing the actual sample sizes
under each alternative model as some models do not always successfully
generate trees. <br />
</p>
</li>
<li><p> other input data.
</p>
</li></ul>

<p><code>powerComp_RegAcc</code> Returns an object of class 'poweRbal_data'
similar to <code>powerComp</code>.
</p>


<h3>References</h3>


<ul>
<li><p> S. J. Kersting, K. Wicke, and M. Fischer. Tree balance in phylogenetic models.
arXiv:2406.05185, 2024.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>powerComp(tss = c("Sackin", "Colless", "B1I"),
          alt_models = list(list("aldous",-1), "pda", "etm"), n = 10L,
          distribs = "sampled", N_null = 40L, N_alt = 20L)
powerComp_RegAcc(tss = c("Sackin", "Colless", "B1I"),
          accept_regions = getAccRegion(tss = c("Sackin", "Colless", "B1I"),
                                        n = 6L, null_model = "etm",
                                        N_null = 20L, distribs = "sampled"),
          null_model = "etm", distribs = "sampled",
          alt_models = list(list("aldous",-1), "pda", "yule"), n = 6L,
          N_null = 20L, N_alt = 20L)
</code></pre>

<hr>
<h2 id='print.poweRbal_data'>Print and summary method for poweRbal_data objects</h2><span id='topic+print.poweRbal_data'></span><span id='topic+summary.poweRbal_data'></span>

<h3>Description</h3>

<p>This function prints the contents of an object of class <code>poweRbal_data</code>.
It provides a brief summary of the object structure and its contents.
</p>
<p>This function provides a summary of an object of class <code>poweRbal_data</code>.
It offers a high-level overview of the contents and their structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poweRbal_data'
print(x, ...)

## S3 method for class 'poweRbal_data'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.poweRbal_data_+3A_x">x</code></td>
<td>
<p>An object of class <code>poweRbal_data</code>, which is a list containing
one mandatory element, <code>power</code>, and several optional elements:<br />
</p>

<ul>
<li> <p><code>power</code>: A numeric matrix containing the power values (one row per
TSS and one column per alternative model).<br />
</p>
</li>
<li> <p><code>accept_regions</code>: A numeric matrix containing information on the
region of acceptance (one row per TSS and four columns).<br />
</p>
</li>
<li> <p><code>CIradius</code>: A numeric matrix containing the confidence interval
radii (one row per TSS and one column per alternative model).<br />
</p>
</li>
<li> <p><code>actual_sample_sizes</code>: A numeric vector containing the actual sample
sizes under each alternative model, as some models do not always
successfully generate trees.<br />
</p>
</li>
<li> <p><code>alt_model_params</code>: A numeric vector (one element per alternative
model) containing the values of a tree model parameter. This is only
suitable if the alternative models all belong to the same tree model
family and differ only in one parameter.<br />
</p>
</li>
<li><p> Other input data from the <code>powerComp()</code> function, such as <code>tss</code>,
<code>null_model</code>, <code>alt_models</code>, <code>n</code>, <code>distribs</code>,
<code>N_null</code>, <code>N_alt</code>, <code>test_type</code>, <code>correction</code>, and
<code>sig_lvl</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="print.poweRbal_data_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>print</code> or <code>summary</code>
function.</p>
</td></tr>
<tr><td><code id="print.poweRbal_data_+3A_object">object</code></td>
<td>
<p>An object of class <code>poweRbal_data</code> (see <code>x</code> for
more details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.poweRbal_data</code> No return value, as the primary purpose
of this function is the side effect (printing).
</p>
<p><code>summary.poweRbal_data</code> No return value, as the primary purpose
of this function is the side effect (printing summary).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Printing a 'poweRbal_data' object:
pc1 &lt;- powerComp(tss = c("Sackin", "Colless", "B1I"),
                 alt_models = list(list("aldous",-1), "pda", "etm"),
                 n = 8L, N_null = 40L, N_alt = 20L)
pc1
# Summary of a 'poweRbal_data' object:
summary(pc1)
</code></pre>

<hr>
<h2 id='showTSSdata'>Function for displaying TSS distributions</h2><span id='topic+showTSSdata'></span>

<h3>Description</h3>

<p><code>showTSSdata</code> - This function plots histograms of TSS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showTSSdata(tss_data, main = NULL, xlab = NULL, sig_lvl = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showTSSdata_+3A_tss_data">tss_data</code></td>
<td>
<p>Numeric matrix of TSS values (one row per TSS). The row names
are used as names for the TSS.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_main">main</code></td>
<td>
<p>Title (default = NULL). A generic title is created by default.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis (default = NULL). A generic label is created
by default.</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_sig_lvl">sig_lvl</code></td>
<td>
<p>Level of significance (default=0.05, must be &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="showTSSdata_+3A_...">...</code></td>
<td>
<p>Add further specifications for <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>showTSSdata</code> No return value, called for side effects
(plotting).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showTSSdata(tss_data = getTSSdata_trees(tss = c("Colless", "Sackin"),
                treeList = lapply(1:20L, function(x) genYuleTree(10))),
                breaks=15)
</code></pre>

<hr>
<h2 id='tssInfo'>Tree shape statistics</h2><span id='topic+tssInfo'></span>

<h3>Description</h3>

<p><code>tssInfo</code> - List that provides information on available tree shape
statistics (TSS) from the package 'treebalance'.
Most of them are either balance or imbalance indices. The indices are grouped
by their families and otherwise sorted alphabetically by their full names.<br />
The following information is provided: <br />
</p>

<ul>
<li><p> short: Abbreviation of the name (plain characters). <br />
</p>
</li>
<li><p> simple: Simplified full name (plain characters). <br />
</p>
</li>
<li><p> name: Full name (partly expressions as some names use special symbols).<br />
</p>
</li>
<li><p> func: Function of the TSS. <br />
</p>
</li>
<li><p> type: Either &quot;tss&quot;, &quot;bali&quot;, or &quot;imbali&quot; expressing what type of tree shape
statistic it is. <br />
</p>
</li>
<li><p> only_binary: TRUE if TSS is suitable only for binary trees, FALSE if also
applicable to arbitrary rooted trees. <br />
</p>
</li>
<li><p> safe_n : Integer vector with two entries specifying the range of leaf
numbers <code>n</code> for which the TSS can be (safely) used, without
warnings for too few leaves or values reaching Inf for too many
leaves.<br />
c(4,800), for example means that this TSS should only be applied
on trees with 4 to 800 leaves. 'Inf' as the second entry means
that there is no specific upper limit, but that the size of the
tree itself and the computation time are the limiting factors.<br />
</p>
</li>
<li><p> col: Color for the TSS (related TSS have similar colors).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tssInfo
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 29.
</p>


<h3>References</h3>


<ul>
<li><p> M. Fischer, L.Herbst, S. J. Kersting, L. Kühn, and K. Wicke,
Tree Balance Indices - A Comprehensive Survey. Springer, 2023.
ISBN: 978-3-031-39799-8
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tssInfo$ALD$name
tssInfo$ALD$func(genYuleTree(6))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
