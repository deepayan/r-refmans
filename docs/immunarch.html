<!DOCTYPE html><html lang="en"><head><title>Help for package immunarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {immunarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.quant_column_choice'><p>Get a column's name using the input alias</p></a></li>
<li><a href='#aa_properties'><p>Tables with amino acid properties</p></a></li>
<li><a href='#aa_table'><p>Amino acid / codon table</p></a></li>
<li><a href='#add_class'><p>Add a new class attribute</p></a></li>
<li><a href='#apply_symm'><p>Apply function to each pair of data frames from a list.</p></a></li>
<li><a href='#bcrdata'><p>BCR dataset</p></a></li>
<li><a href='#bunch_translate'><p>Nucleotide to amino acid sequence translation</p></a></li>
<li><a href='#check_distribution'><p>Check and normalise distributions</p></a></li>
<li><a href='#coding'><p>Filter out coding and non-coding clonotype sequences</p></a></li>
<li><a href='#dbAnnotate'><p>Annotate clonotypes in immune repertoires using clonotype databases such as VDJDB and MCPAS</p></a></li>
<li><a href='#dbLoad'><p>Load clonotype databases such as VDJDB and McPAS into the R workspace</p></a></li>
<li><a href='#entropy'><p>Information measures</p></a></li>
<li><a href='#fixVis'><p>Manipulate ggplot plots and create publication-ready plots</p></a></li>
<li><a href='#gene_segments'><p>Gene segments table</p></a></li>
<li><a href='#gene_stats'><p>WIP</p></a></li>
<li><a href='#geneUsage'><p>Main function for estimation of V-gene and J-gene statistics</p></a></li>
<li><a href='#geneUsageAnalysis'><p>Post-analysis of V-gene and J-gene statistics: PCA, clustering, etc.</p></a></li>
<li><a href='#getKmers'><p>Calculate the k-mer statistics of immune repertoires</p></a></li>
<li><a href='#group_from_metadata'><p>Get a character vector of samples' groups from the input metadata file</p></a></li>
<li><a href='#has_class'><p>Check for the specific class</p></a></li>
<li><a href='#immdata'><p>Single chain immune repertoire dataset</p></a></li>
<li><a href='#immunr_data_format'><p>Specification of the data format used by immunarch dataframes</p></a></li>
<li><a href='#immunr_hclust'><p>Clustering of objects or distance matrices</p></a></li>
<li><a href='#immunr_pca'><p>Dimensionality reduction</p></a></li>
<li><a href='#inc_overlap'><p>Incremental counting of repertoire similarity</p></a></li>
<li><a href='#matrixdiagcopy'><p>Copy the upper matrix triangle to the lower one</p></a></li>
<li><a href='#public_matrix'><p>Get a matrix with public clonotype frequencies</p></a></li>
<li><a href='#pubRep'><p>Create a repertoire of public clonotypes</p></a></li>
<li><a href='#pubRepApply'><p>Apply transformations to public repertoires</p></a></li>
<li><a href='#pubRepFilter'><p>Filter out clonotypes from public repertoires</p></a></li>
<li><a href='#pubRepStatistics'><p>Statistics of number of public clonotypes for each possible combinations of repertoires</p></a></li>
<li><a href='#repAlignLineage'><p>Aligns all sequences incliding germline within each clonal lineage within each cluster</p></a></li>
<li><a href='#repClonalFamily'><p>Builds a phylogenetic tree using the sequences of a clonal lineage</p></a></li>
<li><a href='#repClonality'><p>Clonality analysis of immune repertoires</p></a></li>
<li><a href='#repDiversity'><p>The main function for immune repertoire diversity estimation</p></a></li>
<li><a href='#repExplore'><p>Main function for exploratory data analysis: compute the distribution of lengths, clones, etc.</p></a></li>
<li><a href='#repFilter'><p>Main function for data filtering</p></a></li>
<li><a href='#repGermline'><p>Creates germlines for clonal lineages</p></a></li>
<li><a href='#repLoad'><p>Load immune repertoire files into the R workspace</p></a></li>
<li><a href='#repOverlap'><p>Main function for public clonotype statistics calculations</p></a></li>
<li><a href='#repOverlapAnalysis'><p>Post-analysis of public clonotype statistics: PCA, clustering, etc.</p></a></li>
<li><a href='#repSample'><p>Downsampling and resampling of immune repertoires</p></a></li>
<li><a href='#repSave'><p>Save immune repertoires to the disk</p></a></li>
<li><a href='#repSomaticHypermutation'><p>Calculates number of mutations against the germline for each clonotype</p></a></li>
<li><a href='#scdata'><p>Paired chain immune repertoire dataset</p></a></li>
<li><a href='#select_barcodes'><p>Select specific clonotypes using barcodes from single-cell metadata</p></a></li>
<li><a href='#select_clusters'><p>Split the immune repertoire data to clusters from single-cell barcodes</p></a></li>
<li><a href='#seqCluster'><p>Function for assigning clusters based on sequences similarity</p></a></li>
<li><a href='#seqDist'><p>Function for computing distance for sequences</p></a></li>
<li><a href='#set_pb'><p>Set and update progress bars</p></a></li>
<li><a href='#spectratype'><p>Immune repertoire spectratyping</p></a></li>
<li><a href='#split_to_kmers'><p>Analysis immune repertoire kmer statistics: sequence profiles, etc.</p></a></li>
<li><a href='#switch_type'><p>Return a column's name</p></a></li>
<li><a href='#top'><p>Get the N most abundant clonotypes</p></a></li>
<li><a href='#trackClonotypes'><p>Track clonotypes across time and data points</p></a></li>
<li><a href='#vis'><p>One function to visualise them all</p></a></li>
<li><a href='#vis_bar'><p>Bar plots</p></a></li>
<li><a href='#vis_box'><p>Flexible box-plots for visualisation of distributions</p></a></li>
<li><a href='#vis_circos'><p>Visualisation of matrices using circos plots</p></a></li>
<li><a href='#vis_heatmap'><p>Visualisation of matrices and data frames using ggplo2-based heatmaps</p></a></li>
<li><a href='#vis_heatmap2'><p>Visualisation of matrices using pheatmap-based heatmaps</p></a></li>
<li><a href='#vis_hist'><p>Visualisation of distributions using histograms</p></a></li>
<li><a href='#vis_immunr_kmer_profile_main'><p>Visualise kmer profiles</p></a></li>
<li><a href='#vis_public_clonotypes'><p>Visualisation of public clonotypes</p></a></li>
<li><a href='#vis_public_frequencies'><p>Public repertoire visualisation</p></a></li>
<li><a href='#vis_textlogo'><p>Sequence logo plots for amino acid profiles.</p></a></li>
<li><a href='#vis.clonal_family'><p>Visualise clonal family tree: wrapper for calling on the entire repClonalFamily output</p></a></li>
<li><a href='#vis.clonal_family_tree'><p>Visualise clonal family tree</p></a></li>
<li><a href='#vis.immunr_chao1'><p>Visualise diversity.</p></a></li>
<li><a href='#vis.immunr_clonal_prop'><p>Visualise results of the clonality analysis</p></a></li>
<li><a href='#vis.immunr_dynamics'><p>Visualise clonotype dynamics</p></a></li>
<li><a href='#vis.immunr_exp_vol'><p>Visualise results of the exploratory analysis</p></a></li>
<li><a href='#vis.immunr_gene_usage'><p>Histograms and boxplots (general case / gene usage)</p></a></li>
<li><a href='#vis.immunr_hclust'><p>Visualisation of hierarchical clustering</p></a></li>
<li><a href='#vis.immunr_inc_overlap'><p>Visualise incremental overlaps</p></a></li>
<li><a href='#vis.immunr_kmeans'><p>Visualisation of K-means and DBSCAN clustering</p></a></li>
<li><a href='#vis.immunr_kmer_table'><p>Most frequent kmers visualisation.</p></a></li>
<li><a href='#vis.immunr_mds'><p>PCA / MDS / tSNE visualisation (mainly overlap / gene usage)</p></a></li>
<li><a href='#vis.immunr_ov_matrix'><p>Repertoire overlap and gene usage visualisations</p></a></li>
<li><a href='#vis.immunr_public_repertoire'><p>Public repertoire visualisation</p></a></li>
<li><a href='#vis.immunr_public_statistics'><p>Visualise sharing of clonotypes among samples</p></a></li>
<li><a href='#vis.step_failure_ignored'><p>Handler for .nofail argument of pipeline steps that prevents examples from crashing</p>
on computers where certain dependencies are not installed</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bioinformatics Analysis of T-Cell and B-Cell Immune Repertoires</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Contact:</td>
<td>support@immunomind.io</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive framework for bioinformatics exploratory analysis of bulk and single-cell
    T-cell receptor and antibody repertoires. It provides seamless data loading, analysis and
    visualisation for AIRR (Adaptive Immune Receptor Repertoire) data, both bulk immunosequencing (RepSeq)
    and single-cell sequencing (scRNAseq). Immunarch implements most of the widely used AIRR analysis methods,
    such as: clonality analysis, estimation of repertoire similarities in distribution of clonotypes
    and gene segments, repertoire diversity analysis, annotation of clonotypes using external immune receptor
    databases and clonotype tracking in vaccination and cancer studies. A successor to our
    previously published 'tcR' immunoinformatics package (Nazarov 2015) &lt;<a href="https://doi.org/10.1186%2Fs12859-015-0613-1">doi:10.1186/s12859-015-0613-1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://immunarch.com/">https://immunarch.com/</a>, <a href="https://github.com/immunomind/immunarch">https://github.com/immunomind/immunarch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/immunomind/immunarch/issues">https://github.com/immunomind/immunarch/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>factoextra (&ge; 1.0.4), fpc, UpSetR (&ge; 1.4.0), pheatmap (&ge;
1.0.12), ggrepel (&ge; 0.8.0), reshape2 (&ge; 1.4.2), circlize,
MASS (&ge; 7.3), Rtsne (&ge; 0.15), readxl (&ge; 1.3.1), shiny (&ge;
1.4.0), shinythemes, airr, ggseqlogo, ggalluvial (&ge; 0.10.0),
Rcpp (&ge; 1.0), magrittr, methods, scales, ggpubr (&ge; 0.2),
rlang (&ge; 0.4), plyr, purrr, stringdist, jsonlite, readr,
stringr, tibble, tidyselect, tidyr, igraph, ape, doParallel,
rlist, utils, glue, phangorn, uuid, stringi, ggraph</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ggplot2 (&ge; 3.1.0), dplyr (&ge; 0.8.0), dtplyr (&ge;
1.0.0), data.table (&ge; 1.12.6), patchwork</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.8), roxygen2 (&ge; 3.0.0), testthat (&ge; 2.1.0),
pkgdown (&ge; 0.1.0), assertthat, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 18:22:17 UTC; vdn</td>
</tr>
<tr>
<td>Author:</td>
<td>Vadim I. Nazarov [aut, cre],
  Vasily O. Tsvetkov [aut],
  Siarhei Fiadziushchanka [aut],
  Eugene Rumynskiy [aut],
  Aleksandr A. Popov [aut],
  Ivan Balashov [aut],
  Maria Samokhina [aut],
  Anna Lorenc [ctb],
  Daniel J. Moore [ctb],
  Victor Greiff [ctb],
  ImmunoMind [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vadim I. Nazarov &lt;support@immunomind.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 19:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='.quant_column_choice'>Get a column's name using the input alias</h2><span id='topic+.quant_column_choice'></span>

<h3>Description</h3>

<p>Get a column's name using the input alias
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.quant_column_choice(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".quant_column_choice_+3A_x">x</code></td>
<td>
<p>Character vector of length 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the column name.
</p>


<h3>Developer Examples</h3>

<p>immunarch:::.quant_column_choice(&quot;count&quot;)
immunarch:::.quant_column_choice(&quot;freq&quot;)
</p>

<hr>
<h2 id='aa_properties'>Tables with amino acid properties</h2><span id='topic+aa_properties'></span><span id='topic+properties'></span><span id='topic+kidera'></span><span id='topic+KIDERA'></span><span id='topic+aa_prop'></span><span id='topic+AA_PROP'></span><span id='topic+atchley'></span><span id='topic+ATCHLEY'></span>

<h3>Description</h3>

<p>Tables with amino acid properties
</p>

<hr>
<h2 id='aa_table'>Amino acid / codon table</h2><span id='topic+aa_table'></span><span id='topic+AA_TABLE'></span><span id='topic+AA_TABLE_REVERSED'></span>

<h3>Description</h3>

<p>Amino acid / codon table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AA_TABLE
</code></pre>


<h3>Format</h3>

<p>An object of class <code>table</code> of length 65.
</p>

<hr>
<h2 id='add_class'>Add a new class attribute</h2><span id='topic+add_class'></span>

<h3>Description</h3>

<p>Add a new class attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_class(.obj, .class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_class_+3A_.obj">.obj</code></td>
<td>
<p>R object.</p>
</td></tr>
<tr><td><code id="add_class_+3A_.class">.class</code></td>
<td>
<p>String with the desired class name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input object with additional class <code>.class</code>.
</p>


<h3>Developer Examples</h3>

<p>tmp &lt;- &quot;abc&quot;
class(tmp)
tmp &lt;- immunarch:::add_class(tmp, &quot;new_class&quot;)
class(tmp)
</p>

<hr>
<h2 id='apply_symm'>Apply function to each pair of data frames from a list.</h2><span id='topic+apply_symm'></span><span id='topic+apply_asymm'></span>

<h3>Description</h3>

<p>Apply the given function to every pair in the given datalist. Function either
symmetrical (i.e. fun(x,y) == fun(y,x)) or assymmetrical (i.e. fun(x,y) != fun(y,x)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_symm(.datalist, .fun, ..., .diag = NA, .verbose = TRUE)

apply_asymm(.datalist, .fun, ..., .diag = NA, .verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_symm_+3A_.datalist">.datalist</code></td>
<td>
<p>List with some data.frames.</p>
</td></tr>
<tr><td><code id="apply_symm_+3A_.fun">.fun</code></td>
<td>
<p>Function to apply, which return basic class value.</p>
</td></tr>
<tr><td><code id="apply_symm_+3A_...">...</code></td>
<td>
<p>Arguments passsed to .fun.</p>
</td></tr>
<tr><td><code id="apply_symm_+3A_.diag">.diag</code></td>
<td>
<p>Either NA for NA or something else != NULL for .fun(x,x).</p>
</td></tr>
<tr><td><code id="apply_symm_+3A_.verbose">.verbose</code></td>
<td>
<p>if TRUE then output a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with values M[i,j] = fun(datalist[i], datalist[j])
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
apply_symm(immdata$data, function(x, y) {
  nrow(x) + nrow(y)
})
</code></pre>

<hr>
<h2 id='bcrdata'>BCR dataset</h2><span id='topic+bcrdata'></span>

<h3>Description</h3>

<p>A dataset with BCR data for testing and examplatory purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcrdata
</code></pre>


<h3>Format</h3>

<p>A list of two elements. The first element (&quot;data&quot;) is a list of 1 element named &quot;full_clones&quot;
that contains immune repertoire data frame.
The second element (&quot;meta&quot;) is empty metadata table.
</p>

<dl>
<dt>data</dt><dd><p>List of immune repertoire data frames.</p>
</dd>
<dt>meta</dt><dd><p>Metadata</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='bunch_translate'>Nucleotide to amino acid sequence translation</h2><span id='topic+bunch_translate'></span><span id='topic+translate_bunch'></span>

<h3>Description</h3>

<p>Nucleotide to amino acid sequence translation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bunch_translate(.seq, .two.way = TRUE, .ignore.n = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bunch_translate_+3A_.seq">.seq</code></td>
<td>
<p>Vector or list of strings.</p>
</td></tr>
<tr><td><code id="bunch_translate_+3A_.two.way">.two.way</code></td>
<td>
<p>Logical. If TRUE (default) then translate from the both ends (like MIXCR).</p>
</td></tr>
<tr><td><code id="bunch_translate_+3A_.ignore.n">.ignore.n</code></td>
<td>
<p>Logical. If FALSE (default) then return NA for sequences that have N, else parse triplets with N as ~</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of translated input sequences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
head(bunch_translate(immdata$data[[1]]$CDR3.nt))
</code></pre>

<hr>
<h2 id='check_distribution'>Check and normalise distributions</h2><span id='topic+check_distribution'></span>

<h3>Description</h3>

<p>Check if the given .data is a distribution and normalise it if necessary with an optional Laplace correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_distribution(
  .data,
  .do.norm = NA,
  .laplace = 1,
  .na.val = 0,
  .warn.zero = FALSE,
  .warn.sum = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_distribution_+3A_.data">.data</code></td>
<td>
<p>Numeric vector of values.</p>
</td></tr>
<tr><td><code id="check_distribution_+3A_.do.norm">.do.norm</code></td>
<td>
<p>One of the three values - NA, TRUE or FALSE. If NA then checks for distrubution (sum(.data) == 1)
and normalises if needed with the given laplace correction value. if TRUE then does the normalisation and laplace
correction. If FALSE then doesn't do either normalisaton or laplace correction.</p>
</td></tr>
<tr><td><code id="check_distribution_+3A_.laplace">.laplace</code></td>
<td>
<p>Value for the laplace correction.</p>
</td></tr>
<tr><td><code id="check_distribution_+3A_.na.val">.na.val</code></td>
<td>
<p>Replace all NAs with this value.</p>
</td></tr>
<tr><td><code id="check_distribution_+3A_.warn.zero">.warn.zero</code></td>
<td>
<p>if TRUE then the function checks if in the resulted vector (after normalisation)
are any zeros, and prints a warning message if there are some.</p>
</td></tr>
<tr><td><code id="check_distribution_+3A_.warn.sum">.warn.sum</code></td>
<td>
<p>if TRUE then the function checks if the sum of resulted vector (after normalisation)
is equal to one, and prints a warning message if not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Developer Examples</h3>

<p>immunarch:::check_distribution(c(1, 2, 3))
immunarch:::check_distribution(c(1, 2, 3), TRUE)
immunarch:::check_distribution(c(1, 2, 3), FALSE)
</p>

<hr>
<h2 id='coding'>Filter out coding and non-coding clonotype sequences</h2><span id='topic+coding'></span><span id='topic+noncoding'></span><span id='topic+inframes'></span><span id='topic+outofframes'></span>

<h3>Description</h3>

<p>Filter out clonotypes with non-coding, coding, in-frame or out-of-frame CDR3 sequences:
</p>
<p>'coding()' - remove all non-coding sequences (i.e., remove all sequences with stop codons and frame shifts);
</p>
<p>'noncoding()' - remove all coding sequences (i.e., leave sequences with stop codons and frame shifts only);
</p>
<p>'inframes()' - remove all out-of-frame sequences (i.e., remove all sequences with frame shifts);
</p>
<p>'outofframes()' - remove all in-frame sequences (i.e., leave sequences with frame shifts only).
</p>
<p>Note: the function will remove all clonotypes sequences with NAs in the CDR3 amino acid column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coding(.data)

noncoding(.data)

inframes(.data)

outofframes(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coding_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata_cod &lt;- coding(immdata$data)
immdata_cod1 &lt;- coding(immdata$data[[1]])
</code></pre>

<hr>
<h2 id='dbAnnotate'>Annotate clonotypes in immune repertoires using clonotype databases such as VDJDB and MCPAS</h2><span id='topic+dbAnnotate'></span>

<h3>Description</h3>

<p>Annotate clonotypes using immune receptor databases with known condition-associated receptors.
Before using this function, you need to download database files first.
For more details see the tutorial <a href="https://immunarch.com/articles/web_only/v11_db.html">https://immunarch.com/articles/web_only/v11_db.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbAnnotate(.data, .db, .data.col, .db.col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbAnnotate_+3A_.data">.data</code></td>
<td>
<p>The data to process. It can be a <a href="base.html#topic+data.frame">data.frame</a>, a
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="dbAnnotate_+3A_.db">.db</code></td>
<td>
<p>A data frame or a data table with an immune receptor database. See <a href="#topic+dbLoad">dbLoad</a> on how to load databases into R.</p>
</td></tr>
<tr><td><code id="dbAnnotate_+3A_.data.col">.data.col</code></td>
<td>
<p>Character vector. Vector of columns in the input repertoires to use for clonotype search. E.g., '&quot;CDR3.aa&quot;' or 'c(&quot;CDR3.aa&quot;, &quot;V.name&quot;)'.</p>
</td></tr>
<tr><td><code id="dbAnnotate_+3A_.db.col">.db.col</code></td>
<td>
<p>Character vector. Vector of columns in the database to use for clonotype search. The order must match the order of &quot;.data.col&quot;.
E.g., if &quot;.data.col&quot; is 'c(&quot;CDR3.aa&quot;, &quot;V.name&quot;)', then &quot;.db.col&quot; must have the exact order of columns. i.e., the first column must correspond
to CDR3 amino acid sequences, and the second column must correspond to V gene segment names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with input sequences and counts or proportions for each of the input repertoire.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

#' # Example file path
file_path &lt;- paste0(system.file(package = "immunarch"), "/extdata/db/vdjdb.example.txt")

# Load the database with human-only TRB-only receptors for all known antigens
db &lt;- dbLoad(file_path, "vdjdb", "HomoSapiens", "TRB")

res &lt;- dbAnnotate(immdata$data, db, "CDR3.aa", "cdr3")
res
</code></pre>

<hr>
<h2 id='dbLoad'>Load clonotype databases such as VDJDB and McPAS into the R workspace</h2><span id='topic+dbLoad'></span>

<h3>Description</h3>

<p>The function automatically detects the database format and loads it into R.
Additionally, the function provides a general query interface to databases that allows
filtering by species, chain types (i.e., locus) and pathology (i.e., antigen species).
</p>
<p>Currently we support three popular databases:
</p>
<p>VDJDB - <a href="https://github.com/antigenomics/vdjdb-db">https://github.com/antigenomics/vdjdb-db</a>
</p>
<p>McPAS-TCR - <a href="http://friedmanlab.weizmann.ac.il/McPAS-TCR/">http://friedmanlab.weizmann.ac.il/McPAS-TCR/</a>
</p>
<p>TBAdb from PIRD - <a href="https://db.cngb.org/pird/">https://db.cngb.org/pird/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbLoad(.path, .db, .species = NA, .chain = NA, .pathology = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbLoad_+3A_.path">.path</code></td>
<td>
<p>Character. A path to the database file, e.g., &quot;/Users/researcher/Downloads/McPAS-TCR.csv&quot;.</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_.db">.db</code></td>
<td>
<p>Character. A database type: either &quot;vdjdb&quot;, &quot;vdjdb-search&quot;, &quot;mcpas&quot; or &quot;tbadb&quot;.
</p>
<p>&quot;vdjdb&quot; for VDJDB; &quot;vdjdb-search&quot; for search table obtained from the web interface of VDJDB;
&quot;mcpas&quot; for McPAS-TCR; &quot;tbadb&quot; for PIRD TBAdb.</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_.species">.species</code></td>
<td>
<p>Character. A string or a vector of strings specifying which species need to be in the database, e.g., &quot;HomoSapiens&quot;.
Pass NA (by default) to load all available species.</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_.chain">.chain</code></td>
<td>
<p>Character. A string or a vector of strings specifying which chains need to be in the database, e.g., &quot;TRB&quot;.
Pass NA (by default) to load all available chains.</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_.pathology">.pathology</code></td>
<td>
<p>Character. A string or a vector of strings specifying which disease, virus, bacteria or any condition
needs to be in the database, e.g., &quot;CMV&quot;.
Pass NA (by default) to load all available conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the input database records.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example file path
file_path &lt;- paste0(system.file(package = "immunarch"), "/extdata/db/vdjdb.example.txt")

# Load the database with human-only TRB-only receptors for all known antigens
db &lt;- dbLoad(file_path, "vdjdb", "HomoSapiens", "TRB")
db
</code></pre>

<hr>
<h2 id='entropy'>Information measures</h2><span id='topic+entropy'></span><span id='topic+kl_div'></span><span id='topic+js_div'></span><span id='topic+cross_entropy'></span>

<h3>Description</h3>

<p>Compute information-based estimates and distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(.data, .base = 2, .norm = FALSE, .do.norm = NA, .laplace = 1e-12)

kl_div(.alpha, .beta, .base = 2, .do.norm = NA, .laplace = 1e-12)

js_div(.alpha, .beta, .base = 2, .do.norm = NA, .laplace = 1e-12, .norm.entropy = FALSE)

cross_entropy(.alpha, .beta, .base = 2, .do.norm = NA,
              .laplace = 1e-12, .norm.entropy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy_+3A_.data">.data</code></td>
<td>
<p>Numeric vector. Any distribution.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.base">.base</code></td>
<td>
<p>Numeric. A base of logarithm.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.norm">.norm</code></td>
<td>
<p>Logical. If TRUE then normalises the entropy by the maximal value of the entropy.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.do.norm">.do.norm</code></td>
<td>
<p>If TRUE then normalises the input distributions to make them sum up to 1.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.laplace">.laplace</code></td>
<td>
<p>Numeric. A value for the laplace correction.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.alpha">.alpha</code></td>
<td>
<p>Numeric vector. A distribution of some random value.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.beta">.beta</code></td>
<td>
<p>Numeric vector. A distribution of some random value.</p>
</td></tr>
<tr><td><code id="entropy_+3A_.norm.entropy">.norm.entropy</code></td>
<td>
<p>Logical. If TRUE then normalises the resulting value by the average entropy of input distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- abs(rnorm(10))
Q &lt;- abs(rnorm(10))
entropy(P)
kl_div(P, Q)
js_div(P, Q)
cross_entropy(P, Q)
</code></pre>

<hr>
<h2 id='fixVis'>Manipulate ggplot plots and create publication-ready plots</h2><span id='topic+fixVis'></span>

<h3>Description</h3>

<p>The <code>fixVis</code> is a built-in software tool for the manipulation
of plots, such as adjusting title text font and size, axes, and more. It is a powerful
tool designed to produce publication-ready plots with minimal amount of coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixVis(.plot = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixVis_+3A_.plot">.plot</code></td>
<td>
<p>A ggplot2 plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value because it is an application.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # Compute gene usage, visualise it and tweak via fixVis
  data(immdata) # load test data
  gu &lt;- geneUsage(immdata$data)
  p &lt;- vis(gu)
  fixVis(p)
}
</code></pre>

<hr>
<h2 id='gene_segments'>Gene segments table</h2><span id='topic+gene_segments'></span><span id='topic+genes'></span><span id='topic+segments'></span><span id='topic+GENE_SEGMENTS'></span>

<h3>Description</h3>

<p>Gene segments table
</p>

<hr>
<h2 id='gene_stats'>WIP</h2><span id='topic+gene_stats'></span>

<h3>Description</h3>

<p>WIP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gene_stats()
</code></pre>


<h3>Value</h3>

<p><code>gene_stats</code> returns all segment gene statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene_stats()
get_genes("hs.trbv", "segment")
</code></pre>

<hr>
<h2 id='geneUsage'>Main function for estimation of V-gene and J-gene statistics</h2><span id='topic+geneUsage'></span><span id='topic+get_aliases'></span><span id='topic+get_genes'></span>

<h3>Description</h3>

<p>An utility function to analyse the immune receptor gene usage
(IGHD, IGHJ, IDHV, IGIJ, IGKJ, IGKV, IGLJ, IGLV, TRAJ, TRAV, TRBD, etc.)
and statistics. For gene details run <code>gene_stats()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneUsage(
  .data,
  .gene = c("hs.trbv", "HomoSapiens.TRBJ", "macmul.IGHV"),
  .quant = c(NA, "count"),
  .ambig = c("inc", "exc", "maj"),
  .type = c("segment", "allele", "family"),
  .norm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geneUsage_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="geneUsage_+3A_.gene">.gene</code></td>
<td>
<p>A character vector of length one with the name of the gene you want
to analyse of the specific species. If you provide a vector of different length, only the first element
will be used. The string should also contain the species of interest, for example, valid &quot;.gene&quot; arguments
are &quot;hs.trbv&quot;, &quot;HomoSapiens.TRBJ&quot; or &quot;macmul.IGHV&quot;. For details run <code>gene_stats()</code>.</p>
</td></tr>
<tr><td><code id="geneUsage_+3A_.quant">.quant</code></td>
<td>
<p>Selects the column with data to evaluate.
Pass NA if you want to compute gene statistics at the clonotype level without re-weighting.
Pass &quot;count&quot; to use the &quot;Clones&quot; column to weight genes by abundance of their corresponding clonotypes.</p>
</td></tr>
<tr><td><code id="geneUsage_+3A_.ambig">.ambig</code></td>
<td>
<p>An option to handle ambiguous gene assigments, e.g., &quot;TRAV1,TRAV2&quot;.
</p>
<p>- Pass &quot;inc&quot; to include all possible gene segments, so &quot;TRAV1,TRAV2&quot; is counted as a different gene segment.
</p>
<p>- Pass &quot;exc&quot; to exclude all ambiguous gene assignments, so &quot;TRAV1,TRAV2&quot; is excluded from the resultant gene table.
</p>
<p>We recommend to turn it on by passing &quot;inc&quot; (turned on by default).
You can exclude data for the cases where
there is no clear match for gene, include it for every supplied gene,
or pick only first from the set. Set it to &quot;exc&quot;, &quot;inc&quot; or &quot;maj&quot;, respectively.</p>
</td></tr>
<tr><td><code id="geneUsage_+3A_.type">.type</code></td>
<td>
<p>Set the type of data to evaluate: &quot;segment&quot;, &quot;allele&quot;, or &quot;family&quot;.</p>
</td></tr>
<tr><td><code id="geneUsage_+3A_.norm">.norm</code></td>
<td>
<p>If TRUE then return proportions of genes. If FALSE then return counts of genes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with rows corresponding to gene segments and columns corresponding to the input samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
gu &lt;- geneUsage(immdata$data)
vis(gu)
</code></pre>

<hr>
<h2 id='geneUsageAnalysis'>Post-analysis of V-gene and J-gene statistics: PCA, clustering, etc.</h2><span id='topic+geneUsageAnalysis'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a></code> function deploys several
data analysis methods, including PCA, multidimensional scaling,
Jensen-Shannon divergence, k-means, hierarchical clustering, DBscan, and different
correlation coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneUsageAnalysis(
  .data,
  .method = c("js+hclust", "pca+kmeans", "anova", "js+pca+kmeans"),
  .base = 2,
  .norm.entropy = FALSE,
  .cor = c("pearson", "kendall", "spearman"),
  .do.norm = TRUE,
  .laplace = 1e-12,
  .verbose = TRUE,
  .k = 2,
  .eps = 0.01,
  .perp = 1,
  .theta = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geneUsageAnalysis_+3A_.data">.data</code></td>
<td>
<p>The <code><a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a></code> function runs on the output from
<code><a href="#topic+geneUsage">geneUsage</a></code>.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.method">.method</code></td>
<td>
<p>A string that defines the type of analysis to perform. Can be &quot;pca&quot;,
&quot;mds&quot;, &quot;js&quot;, &quot;kmeans&quot;, &quot;hclust&quot;, &quot;dbscan&quot; or &quot;cor&quot; if you want to calculate
correlation coefficient. In the latter case you have to provide <code>.cor</code> argument.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.base">.base</code></td>
<td>
<p>A numerical value that defines the logarithm base for Jensen-Shannon
divergence.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.norm.entropy">.norm.entropy</code></td>
<td>
<p>A logical value. Set TRUE to normalise your data if you haven't
done it already.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.cor">.cor</code></td>
<td>
<p>A string that defines the correlation coefficient for analysis. Can be
&quot;pearson&quot;, &quot;kendall&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.do.norm">.do.norm</code></td>
<td>
<p>A logical value. If TRUE it forces Laplace smoothing, if NA it checks
if smoothing is necessary, if FALSE does nothing.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.laplace">.laplace</code></td>
<td>
<p>The numeric value, which is used as a pseudocount for Laplace
smoothing.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.verbose">.verbose</code></td>
<td>
<p>A logical value.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.k">.k</code></td>
<td>
<p>The number of clusters to create, passed as <code>k</code> to <a href="factoextra.html#topic+hcut">hcut</a> or as <code>centers</code> to <a href="stats.html#topic+kmeans">kmeans</a>.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.eps">.eps</code></td>
<td>
<p>A numerical value, DBscan epsylon parameter, see
<code><a href="#topic+immunr_dbscan">immunr_dbscan</a></code>.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.perp">.perp</code></td>
<td>
<p>A numerical value, t-SNE perplexity, see <code><a href="#topic+immunr_tsne">immunr_tsne</a></code>.</p>
</td></tr>
<tr><td><code id="geneUsageAnalysis_+3A_.theta">.theta</code></td>
<td>
<p>A numerical value, t-SNE theta parameter, see <code><a href="#topic+immunr_tsne">immunr_tsne</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the last element in the <code>.method</code> string. See <a href="#topic+immunr_tsne">immunr_tsne</a> for more info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
gu &lt;- geneUsage(immdata$data, .norm = TRUE)
geneUsageAnalysis(gu, "js+hclust", .verbose = FALSE) %&gt;% vis()
</code></pre>

<hr>
<h2 id='getKmers'>Calculate the k-mer statistics of immune repertoires</h2><span id='topic+getKmers'></span><span id='topic+get.kmers'></span><span id='topic+makeKmerTable'></span>

<h3>Description</h3>

<p>Calculate the k-mer statistics of immune repertoires
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKmers(.data, .k, .col = c("aa", "nt"), .coding = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getKmers_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="getKmers_+3A_.k">.k</code></td>
<td>
<p>Integer. Length of k-mers.</p>
</td></tr>
<tr><td><code id="getKmers_+3A_.col">.col</code></td>
<td>
<p>Character. Which column to use, pass &quot;aa&quot; (by default) for CDR3 amino acid sequence,
pass &quot;nt&quot; for CDR3 nucleotide sequences.</p>
</td></tr>
<tr><td><code id="getKmers_+3A_.coding">.coding</code></td>
<td>
<p>Logical. If TRUE (by default) then removes all non-coding sequences from input data first.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with two columns (k-mers and their counts).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
kmers &lt;- getKmers(immdata$data[[1]], 5)
kmers %&gt;% vis()
</code></pre>

<hr>
<h2 id='group_from_metadata'>Get a character vector of samples' groups from the input metadata file</h2><span id='topic+group_from_metadata'></span>

<h3>Description</h3>

<p>Get a character vector of samples' groups from the input metadata file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_from_metadata(.by, .metadata, .sep = "; ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_from_metadata_+3A_.by">.by</code></td>
<td>
<p>Character vector. Specify a column or columns in the input metadata to group by.</p>
</td></tr>
<tr><td><code id="group_from_metadata_+3A_.metadata">.metadata</code></td>
<td>
<p>Metadata object.</p>
</td></tr>
<tr><td><code id="group_from_metadata_+3A_.sep">.sep</code></td>
<td>
<p>Character vector. Defines a separator between groups if more than one group passed in <code>.by</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with group names.
</p>


<h3>Developer Examples</h3>

<p>immunarch:::group_from_metadata(&quot;Status&quot;, data.frame(Status = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;)))
</p>

<hr>
<h2 id='has_class'>Check for the specific class</h2><span id='topic+has_class'></span>

<h3>Description</h3>

<p>A function to check if an input object has a specific class name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_class(.data, .class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_class_+3A_.data">.data</code></td>
<td>
<p>Any R object.</p>
</td></tr>
<tr><td><code id="has_class_+3A_.class">.class</code></td>
<td>
<p>Character vector. Specifies a class name to check against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value.
</p>


<h3>Developer Examples</h3>

<p>tmp &lt;- &quot;abc&quot;
immunarch:::has_class(tmp, &quot;new_class&quot;)
tmp &lt;- immunarch:::add_class(tmp, &quot;new_class&quot;)
immunarch:::has_class(tmp, &quot;new_class&quot;)
</p>

<hr>
<h2 id='immdata'>Single chain immune repertoire dataset</h2><span id='topic+immdata'></span>

<h3>Description</h3>

<p>A dataset with single chain TCR data for testing and examplatory purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immdata
</code></pre>


<h3>Format</h3>

<p>A list of two elements. The first element (&quot;data&quot;) is a list with data frames with clonotype tables.
The second element (&quot;meta&quot;) is a metadata table.
</p>

<dl>
<dt>data</dt><dd><p>List of immune repertoire data frames.</p>
</dd>
<dt>meta</dt><dd><p>Metadata</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='immunr_data_format'>Specification of the data format used by immunarch dataframes</h2><span id='topic+immunr_data_format'></span><span id='topic+immunarch_data_format'></span>

<h3>Description</h3>

<p>- &quot;Clones&quot; - number of barcodes (events, UMIs) or reads;
</p>
<p>- &quot;Proportion&quot; - proportion of barcodes (events, UMIs) or reads;
</p>
<p>- &quot;CDR3.nt&quot; - CDR3 nucleotide sequence;
</p>
<p>- &quot;CDR3.aa&quot; - CDR3 amino acid sequence;
</p>
<p>- &quot;V.name&quot; - names of aligned Variable gene segments;
</p>
<p>- &quot;D.name&quot; - names of aligned Diversity gene segments or NA;
</p>
<p>- &quot;J.name&quot; - names of aligned Joining gene segments;
</p>
<p>- &quot;V.end&quot; - last positions of aligned V gene segments (1-based);
</p>
<p>- &quot;D.start&quot; - positions of D'5 end of aligned D gene segments (1-based);
</p>
<p>- &quot;D.end&quot; - positions of D'3 end of aligned D gene segments (1-based);
</p>
<p>- &quot;J.start&quot; - first positions of aligned J gene segments (1-based);
</p>
<p>- &quot;VJ.ins&quot; - number of inserted nucleotides (N-nucleotides) at V-J junction (-1 for receptors with VDJ recombination);
</p>
<p>- &quot;VD.ins&quot; - number of inserted nucleotides (N-nucleotides) at V-D junction (-1 for receptors with VJ recombination);
</p>
<p>- &quot;DJ.ins&quot; - number of inserted nucleotides (N-nucleotides) at D-J junction (-1 for receptors with VJ recombination);
</p>
<p>- &quot;Sequence&quot; - full nucleotide sequence.
</p>

<hr>
<h2 id='immunr_hclust'>Clustering of objects or distance matrices</h2><span id='topic+immunr_hclust'></span><span id='topic+immunr_kmeans'></span><span id='topic+immunr_dbscan'></span>

<h3>Description</h3>

<p>Clusters the data with one of the following methods:
</p>
<p>- <code>immunr_hclust</code> clusters the data using the hierarchical clustering from <a href="factoextra.html#topic+hcut">hcut</a>;
</p>
<p>- <code>immunr_kmeans</code> clusters the data using the K-means algorithm from <a href="stats.html#topic+kmeans">kmeans</a>;
</p>
<p>- <code>immunr_dbscan</code> clusters the data using the DBSCAN algorithm from <a href="fpc.html#topic+dbscan">dbscan</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immunr_hclust(.data, .k = 2, .k.max = nrow(.data) - 1, .method = "complete", .dist = TRUE)

immunr_kmeans(.data, .k = 2, .k.max = as.integer(sqrt(nrow(.data))) + 1,
.method = c("silhouette", "gap_stat"))

immunr_dbscan(.data, .eps, .dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="immunr_hclust_+3A_.data">.data</code></td>
<td>
<p>Matrix or data frame with features, distance matrix or output from <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a> or <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a> functions.</p>
</td></tr>
<tr><td><code id="immunr_hclust_+3A_.k">.k</code></td>
<td>
<p>The number of clusters to create, defined as <code>k</code> to <a href="factoextra.html#topic+hcut">hcut</a> or as <code>centers</code> to <a href="stats.html#topic+kmeans">kmeans</a>.</p>
</td></tr>
<tr><td><code id="immunr_hclust_+3A_.k.max">.k.max</code></td>
<td>
<p>Limits the maximum number of clusters. It is passed as <code>k.max</code> to <a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a> for <code>immunr_hclust</code> and <code>immunr_kmeans</code>.</p>
</td></tr>
<tr><td><code id="immunr_hclust_+3A_.method">.method</code></td>
<td>
<p>Passed to <a href="factoextra.html#topic+hcut">hcut</a> or as <a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a>.
</p>
<p>In case of <a href="factoextra.html#topic+hcut">hcut</a> the agglomeration method is going to be used (argument <code>hc_method</code>).
</p>
<p>In case of <a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a> it is the method to be used for estimating the optimal number of clusters (argument <code>method</code>).</p>
</td></tr>
<tr><td><code id="immunr_hclust_+3A_.dist">.dist</code></td>
<td>
<p>If TRUE then &quot;.data&quot; is expected to be a distance matrix. If FALSE then the euclidean distance is computed for the input objects.</p>
</td></tr>
<tr><td><code id="immunr_hclust_+3A_.eps">.eps</code></td>
<td>
<p>Local radius for expanding clusters, minimal distance between points to expand clusters. Passed as <code>eps</code> to <a href="fpc.html#topic+dbscan">dbscan</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>immunr_hclust</code> - list with two elements. The first element is an output from <a href="factoextra.html#topic+hcut">hcut</a>.
The second element is an output from <a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a>
</p>
<p><code>immunr_kmeans</code> - list with three elements. The first element is an output from <a href="stats.html#topic+kmeans">kmeans</a>.
The second element is an output from <a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a>.
The third element is the input dataset <code>.data</code>.
</p>
<p><code>immunr_dbscan</code> - list with two elements. The first element is an output from <a href="fpc.html#topic+dbscan">dbscan</a>.
The second element is the input dataset <code>.data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
gu &lt;- geneUsage(immdata$data, .norm = TRUE)
immunr_hclust(t(as.matrix(gu[, -1])), .dist = FALSE)

gu[is.na(gu)] &lt;- 0
immunr_kmeans(t(as.matrix(gu[, -1])))
</code></pre>

<hr>
<h2 id='immunr_pca'>Dimensionality reduction</h2><span id='topic+immunr_pca'></span><span id='topic+immunr_mds'></span><span id='topic+immunr_tsne'></span>

<h3>Description</h3>

<p>Collects a set of principal variables, reducing the number of not important variables
to analyse. Dimensionality reduction makes data analysis algorithms work faster and
sometimes more accurate, since it also reduces noise in the data. Currently available
methods are:
</p>
<p>- <code>immunr_pca</code> performs PCA (Principal Component Analysis) using <a href="stats.html#topic+prcomp">prcomp</a>;
</p>
<p>- <code>immunr_mds</code> performs MDS (Multi-Dimensional Scaling) using <a href="MASS.html#topic+isoMDS">isoMDS</a>;
</p>
<p>- <code>immunr_tsne</code> performs tSNE (t-Distributed Stochastic Neighbour Embedding) using <a href="Rtsne.html#topic+Rtsne">Rtsne</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immunr_pca(.data, .scale = default_scale_fun, .raw = TRUE, .orig = FALSE, .dist = FALSE)

immunr_mds(.data, .scale = default_scale_fun, .raw = TRUE, .orig = FALSE, .dist = TRUE)

immunr_tsne(.data, .perp = 1, .dist = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="immunr_pca_+3A_.data">.data</code></td>
<td>
<p>A matrix or a data frame with features, distance matrix or output from <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a> or <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a> functions.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_.scale">.scale</code></td>
<td>
<p>A function to apply to your data before passing it to any of
dimensionality reduction algorithms. There is no scaling by default.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_.raw">.raw</code></td>
<td>
<p>If TRUE then returns the non-processed output from dimensionality reduction
algorithms. Pass FALSE if you want to visualise results.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_.orig">.orig</code></td>
<td>
<p>If TRUE then returns the original result from algorithms. Pass FALSE
if you want to visualise results.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_.dist">.dist</code></td>
<td>
<p>If TRUE then assumes that &quot;.data&quot; is a distance matrix.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_.perp">.perp</code></td>
<td>
<p>The perplexity parameter for <a href="Rtsne.html#topic+Rtsne">Rtsne</a>. Sepcifies the number
of neighbours each data point must have in the resulting plot.</p>
</td></tr>
<tr><td><code id="immunr_pca_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <a href="Rtsne.html#topic+Rtsne">Rtsne</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>immunr_pca</code> - an output from <a href="stats.html#topic+prcomp">prcomp</a>.
</p>
<p><code>immunr_mds</code> - an output from <a href="MASS.html#topic+isoMDS">isoMDS</a>.
</p>
<p><code>immunr_tsne</code> - an output from <a href="Rtsne.html#topic+Rtsne">Rtsne</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis.immunr_pca">vis.immunr_pca</a> for visualisations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
gu &lt;- geneUsage(immdata$data)
gu[is.na(gu)] &lt;- 0
gu &lt;- t(as.matrix(gu[, -1]))
immunr_pca(gu)
immunr_mds(dist(gu))
immunr_tsne(dist(gu))
</code></pre>

<hr>
<h2 id='inc_overlap'>Incremental counting of repertoire similarity</h2><span id='topic+inc_overlap'></span>

<h3>Description</h3>

<p>For reference please look up https://www.pnas.org/content/111/16/5980 (Fig. 4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc_overlap(
  .data,
  .fun,
  .step = 1000,
  .n.steps = 10,
  .downsample = FALSE,
  .bootstrap = NA,
  .verbose.inc = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inc_overlap_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.fun">.fun</code></td>
<td>
<p>Function to compute overlaps. e.g., <code>morisita_index</code>.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.step">.step</code></td>
<td>
<p>Either an integer or a numeric vector.
</p>
<p>In the first case, the integer defines the step of incremental overlap.
</p>
<p>In the second case, the vector encodes all repertoire sampling depths.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.n.steps">.n.steps</code></td>
<td>
<p>Integer. Number of steps if <code>.step</code> is a single integer.
Skipped if &quot;.step&quot; is a numeric vector.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.downsample">.downsample</code></td>
<td>
<p>If TRUE then performs downsampling to N clonotypes at each step instead of choosing the
top N clonotypes.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.bootstrap">.bootstrap</code></td>
<td>
<p>Set NA to turn off any bootstrapping, set a number to perform bootstrapping with this number of tries.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_.verbose.inc">.verbose.inc</code></td>
<td>
<p>Logical. If TRUE then shows the output from the computation process.</p>
</td></tr>
<tr><td><code id="inc_overlap_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with overlap matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data, "inc+overlap", .step = 100, .verbose.inc = FALSE, .verbose = FALSE)
vis(ov)
</code></pre>

<hr>
<h2 id='matrixdiagcopy'>Copy the upper matrix triangle to the lower one</h2><span id='topic+matrixdiagcopy'></span>

<h3>Description</h3>

<p>Copy the upper matrix triangle to the lower one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixdiagcopy(.mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrixdiagcopy_+3A_.mat">.mat</code></td>
<td>
<p>Matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with its upper tri part copied to the lower tri part.
</p>


<h3>Developer Examples</h3>

<p>mat &lt;- matrix(0, 3, 3)
mat
mat[1, 3] &lt;- 1
mat &lt;- immunarch:::matrixdiagcopy(mat)
mat
</p>

<hr>
<h2 id='public_matrix'>Get a matrix with public clonotype frequencies</h2><span id='topic+public_matrix'></span>

<h3>Description</h3>

<p>Get a matrix with public clonotype frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>public_matrix(.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="public_matrix_+3A_.data">.data</code></td>
<td>
<p>Public repertoire, an output from <a href="#topic+pubRep">pubRep</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with per-sample clonotype counts / proportions only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
pr.mat &lt;- public_matrix(pr)
dim(pr.mat)
head(pr.mat)
</code></pre>

<hr>
<h2 id='pubRep'>Create a repertoire of public clonotypes</h2><span id='topic+pubRep'></span><span id='topic+publicRepertoire'></span>

<h3>Description</h3>

<p>Create a repertoire of public clonotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pubRep(
  .data,
  .col = "aa+v",
  .quant = c("count", "prop"),
  .coding = TRUE,
  .min.samples = 1,
  .max.samples = NA,
  .verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pubRep_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column(s) to be processed. Outputs one of the
following strings, separated by the plus sign: &quot;nt&quot; for nucleotide sequences,
&quot;aa&quot; for amino acid sequences, &quot;v&quot; for V gene segments, &quot;j&quot; for J gene segments. E.g.,
pass &quot;aa+v&quot; to compute overlaps on CDR3 amino acid sequences paired with V gene segments, i.e.,
in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.quant">.quant</code></td>
<td>
<p>A string that specifies the column to be processed. Set &quot;count&quot; to see
public clonotype sharing with the number of clones, set &quot;prop&quot; to see proportions.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.coding">.coding</code></td>
<td>
<p>Logical. If TRUE then preprocesses the data to filter out non-coding sequences.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.min.samples">.min.samples</code></td>
<td>
<p>Integer. A minimal number of samples a clonotype must have to be included
in the public repertoire table.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.max.samples">.max.samples</code></td>
<td>
<p>Integer. A maxminal number of samples a clonotype must have to be included
in the public repertoire table. Set NA (by default) to have the maximal amount of samples.</p>
</td></tr>
<tr><td><code id="pubRep_+3A_.verbose">.verbose</code></td>
<td>
<p>Logical. If TRUE then outputs the progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table with columns for:
</p>
<p>- Clonotypes (e.g., CDR3 sequence, or two columns for CDR3 sequence and V gene)
</p>
<p>- Incidence of clonotypes
</p>
<p>- Per-sample proportions or counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset the data to make the example faster to run
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
vis(pr, "clonotypes", 1, 2)
</code></pre>

<hr>
<h2 id='pubRepApply'>Apply transformations to public repertoires</h2><span id='topic+pubRepApply'></span><span id='topic+publicRepertoireApply'></span>

<h3>Description</h3>

<p>Work In Progress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pubRepApply(.pr1, .pr2, .fun = function(x) log10(x[1])/log10(x[2]))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pubRepApply_+3A_.pr1">.pr1</code></td>
<td>
<p>First public repertoire.</p>
</td></tr>
<tr><td><code id="pubRepApply_+3A_.pr2">.pr2</code></td>
<td>
<p>Second public repertoire.</p>
</td></tr>
<tr><td><code id="pubRepApply_+3A_.fun">.fun</code></td>
<td>
<p>A function to apply to pairs of frequencies of same clonotypes from &quot;pr1&quot; and &quot;pr2&quot;.
By default - <code>log(X) / log(Y)</code> where <code>X,Y</code> - frequencies of the same clonotype,
found in both public repertoires.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Work in progress.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
pr1 &lt;- pubRepFilter(pr, immdata$meta, .by = c(Status = "MS"))
pr2 &lt;- pubRepFilter(pr, immdata$meta, .by = c(Status = "C"))
prapp &lt;- pubRepApply(pr1, pr2)
head(prapp)
</code></pre>

<hr>
<h2 id='pubRepFilter'>Filter out clonotypes from public repertoires</h2><span id='topic+pubRepFilter'></span><span id='topic+publicRepertoireFilter'></span>

<h3>Description</h3>

<p>Filter our clonotypes with low incidence in a specific group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pubRepFilter(.pr, .meta, .by, .min.samples = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pubRepFilter_+3A_.pr">.pr</code></td>
<td>
<p>Public repertoires, an output from <a href="#topic+pubRep">pubRep</a>.</p>
</td></tr>
<tr><td><code id="pubRepFilter_+3A_.meta">.meta</code></td>
<td>
<p>Metadata file.</p>
</td></tr>
<tr><td><code id="pubRepFilter_+3A_.by">.by</code></td>
<td>
<p>Named character vector. Names of the group to filter by.</p>
</td></tr>
<tr><td><code id="pubRepFilter_+3A_.min.samples">.min.samples</code></td>
<td>
<p>Integer. Filters out clonotypes with the number of samples below than this number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with filtered clonotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
pr1 &lt;- pubRepFilter(pr, immdata$meta, .by = c(Status = "MS"))
head(pr1)
</code></pre>

<hr>
<h2 id='pubRepStatistics'>Statistics of number of public clonotypes for each possible combinations of repertoires</h2><span id='topic+pubRepStatistics'></span>

<h3>Description</h3>

<p>Statistics of number of public clonotypes for each possible combinations of repertoires
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pubRepStatistics(.data, .by = NA, .meta = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pubRepStatistics_+3A_.data">.data</code></td>
<td>
<p>Public repertoire, an output from the <a href="#topic+pubRep">pubRep</a> function.</p>
</td></tr>
<tr><td><code id="pubRepStatistics_+3A_.by">.by</code></td>
<td>
<p>Work in Progress.</p>
</td></tr>
<tr><td><code id="pubRepStatistics_+3A_.meta">.meta</code></td>
<td>
<p>Work in Progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with incidence statistics per sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
pubRepStatistics(pr) %&gt;% vis()
</code></pre>

<hr>
<h2 id='repAlignLineage'>Aligns all sequences incliding germline within each clonal lineage within each cluster</h2><span id='topic+repAlignLineage'></span>

<h3>Description</h3>

<p>This function aligns all sequences (incliding germline) that belong to one clonal
lineage and one cluster. After clustering and building the clonal lineage and germline, the next
step is to analyze the degree of mutation and maturity of each clonal lineage. This allows for
finding high mature cells and cells with a large number of offspring. The phylogenetic analysis
will find mutations that increase the affinity of BCR. Making alignment of the sequence
is the first step towards sequence analysis including BCR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repAlignLineage(.data, .min_lineage_sequences, .prepare_threads, .align_threads, .nofail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repAlignLineage_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>, <a href="data.table.html#topic+data.table">data.table</a>
or a list of these objects.</p>
</td></tr>
<tr><td><code id="repAlignLineage_+3A_.min_lineage_sequences">.min_lineage_sequences</code></td>
<td>
<p>If number of sequences in the same clonal lineage and the same
cluster (not including germline) is lower than this threshold, this group of sequences
will be filtered out from the dataframe; so only large enough lineages will be included.</p>
</td></tr>
<tr><td><code id="repAlignLineage_+3A_.prepare_threads">.prepare_threads</code></td>
<td>
<p>Number of threads to prepare results table.
Please note that high number can cause heavy memory usage!</p>
</td></tr>
<tr><td><code id="repAlignLineage_+3A_.align_threads">.align_threads</code></td>
<td>
<p>Number of threads for lineage alignment.
</p>
<p>It must have columns in the immunarch compatible format <a href="#topic+immunarch_data_format">immunarch_data_format</a>, and also
must contain 'Cluster' column, which is added by seqCluster() function, and 'Germline.sequence'
column, which is added by repGermline() function.</p>
</td></tr>
<tr><td><code id="repAlignLineage_+3A_.nofail">.nofail</code></td>
<td>
<p>Will return NA instead of stopping if Clustal W is not installed.
Used to avoid raising errors in examples on computers where Clustal W is not installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe or list of dataframes (if input is a list with multiple samples).
The dataframe has these columns:
* Cluster: cluster name
* Germline: germline sequence
* Alignment: DNAbin object with alignment
* Sequences: nested dataframe containing all sequences for this combination
of cluster and germline; it has columns
* Sequence, CDR1.nt, CDR2.nt, CDR3.nt, FR1.nt, FR2.nt, FR3.nt, FR4.nt, V.allele, J.allele,
V.aa, J.aa: all values taken from the input dataframe
* Clone.ID: taken from the input dataframe, or created (filled with row numbers) if missing
* Clones: taken from the input dataframe, or created (filled with '1' values) if missing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bcrdata)
bcr_data &lt;- bcrdata$data

bcr_data %&gt;%
  seqCluster(seqDist(bcr_data), .fixed_threshold = 3) %&gt;%
  repGermline(.threads = 1) %&gt;%
  repAlignLineage(.min_lineage_sequences = 2, .align_threads = 2, .nofail = TRUE)
</code></pre>

<hr>
<h2 id='repClonalFamily'>Builds a phylogenetic tree using the sequences of a clonal lineage</h2><span id='topic+repClonalFamily'></span>

<h3>Description</h3>

<p>This function uses the PHYLIP package to make phylogenetic analysis.
For making trees it uses maximum parsimony methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repClonalFamily(.data, .vis_groups, .threads, .nofail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repClonalFamily_+3A_.data">.data</code></td>
<td>
<p>The data to be processed, output of repAlignLineage() function.</p>
</td></tr>
<tr><td><code id="repClonalFamily_+3A_.vis_groups">.vis_groups</code></td>
<td>
<p>Groups for visualization, used to annotate specific clones on chart
and display them in different colors. This is a named list, where names are for the chart legend,
and list items are clone IDs that belong to the groups. It's not necessary to assign groups to
all clonotypes; unassigned ones will be displayed on the chart as &quot;Clonotype&quot; category.
It's also possible to assign multiple clonotypes to the same group by providing nested lists
or vectors of clone IDs instead of single clone IDs.
Example: .vis_groups = list(A = 817, B = 201, C = list(303, 42))</p>
</td></tr>
<tr><td><code id="repClonalFamily_+3A_.threads">.threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="repClonalFamily_+3A_.nofail">.nofail</code></td>
<td>
<p>Returns NA instead of stopping if PHYLIP is not installed.
Used to avoid raising errors in examples on computers where PHYLIP is not installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe or list of dataframes (if input is a list with multiple samples).
The dataframe has these columns:
* Cluster: cluster name
* Germline.Input: germline sequence, like it was in the input; not aligned
* Germline.Output: germline sequence, parsed from PHYLIP dnapars function output;
it contains difference of germline from the common ancestor; &quot;.&quot; characters mean
matching letters
* Common.Ancestor: common ancestor sequence, parsed from PHYLIP dnapars function output
* Trunk.Length: mean trunk length, representing the distance between the most recent
common ancestor and germline sequence as a measure of the maturity of a lineage
* Tree: output tree in &quot;phylo&quot; format, loaded from by PHYLIP dnapars function output
* TreeStats: nested dataframe containing data about tree nodes, needed for visualization
* Sequences: nested dataframe containing all sequences for this combination of cluster
and germline; it contains regions from original sequences, saved for
repSomaticHypermutation() calculation, and also data needed for visualizations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bcrdata)
bcr_data &lt;- bcrdata$data

bcr_data %&gt;%
  seqCluster(seqDist(bcr_data), .fixed_threshold = 3) %&gt;%
  repGermline(.threads = 1) %&gt;%
  repAlignLineage(.min_lineage_sequences = 2, .align_threads = 2, .nofail = TRUE) %&gt;%
  repClonalFamily(.threads = 1, .nofail = TRUE)
</code></pre>

<hr>
<h2 id='repClonality'>Clonality analysis of immune repertoires</h2><span id='topic+repClonality'></span><span id='topic+clonality'></span><span id='topic+clonal.prop'></span><span id='topic+clonal_proportion'></span><span id='topic+top_proportion'></span><span id='topic+rare_proportion'></span><span id='topic+clonal_space_homeostasis'></span>

<h3>Description</h3>

<p><code>repClonality</code> function encompasses several methods to measure
clonal proportions in a given repertoire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repClonality(
  .data,
  .method = c("clonal.prop", "homeo", "top", "rare"),
  .perc = 10,
  .clone.types = c(Rare = 1e-05, Small = 1e-04, Medium = 0.001, Large = 0.01,
    Hyperexpanded = 1),
  .head = c(10, 100, 1000, 3000, 10000, 30000, 1e+05),
  .bound = c(1, 3, 10, 30, 100)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repClonality_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="repClonality_+3A_.method">.method</code></td>
<td>
<p>A String with one of the following options: <code>"clonal.prop"</code>,
<code>"homeo"</code>, <code>"top"</code> or <code>"rare"</code>.
</p>
<p>Set <code>"clonal.prop"</code> to compute clonal proportions or in other words
percentage of clonotypes required to occupy specified by <code>.perc</code> percent
of the total immune repertoire.
</p>
<p>Set <code>"homeo"</code> to analyse relative abundance (also known as clonal space homeostasis), which is defined as the
proportion of repertoire occupied by clonal groups with specific abundances..
</p>
<p>Set <code>"top"</code> to estimate relative abundance for the groups of top clonotypes in
repertoire, e.g., ten most abundant clonotypes. Use <code>".head"</code> to define index intervals,
such as 10, 100 and so on.
</p>
<p>Set <code>"rare"</code> to estimate relative abundance for the groups of rare clonotypes
with low counts. Use <code>".bound"</code> to define the threshold of clonotype groups.</p>
</td></tr>
<tr><td><code id="repClonality_+3A_.perc">.perc</code></td>
<td>
<p>A single numerical value ranging from 0 to 100.</p>
</td></tr>
<tr><td><code id="repClonality_+3A_.clone.types">.clone.types</code></td>
<td>
<p>A named numerical vector with the threshold of the half-closed
intervals that mark off clonal groups.</p>
</td></tr>
<tr><td><code id="repClonality_+3A_.head">.head</code></td>
<td>
<p>A numerical vector with ranges of the top clonotypes.</p>
</td></tr>
<tr><td><code id="repClonality_+3A_.bound">.bound</code></td>
<td>
<p>A numerical vector with ranges of abundance for the rare clonotypes in
the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clonal proportion assessment is a different approach to estimate
repertoire diversity. When visualised, it allows for thorough examination of
immune repertoire structure and composition.
</p>
<p>In its core this type of analysis is similar to the relative species abundance
concept in ecology. Relative abundance is the percent composition of an organism
of a particular kind relative to the total number of organisms in the area.
</p>
<p>A stacked barplot of relative clonotype abundances can be therefore viewed as
a non-parametric approach to comparing their underlying distributions.
</p>


<h3>Value</h3>

<p>If input data is a single immune repertoire, then the function returns a numeric vector
with clonality statistics.
</p>
<p>Otherwise, it returns a numeric matrix with clonality statistics for all input repertoires.
</p>


<h3>See Also</h3>

<p><a href="#topic+repDiversity">repDiversity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data
data(immdata)

imm_pr &lt;- repClonality(immdata$data, .method = "clonal.prop")
vis(imm_pr)

imm_top &lt;- repClonality(immdata$data, .method = "top", .head = c(10, 100, 1000, 3000, 10000))
vis(imm_top)

imm_rare &lt;- repClonality(immdata$data, .method = "rare")
vis(imm_rare)

imm_hom &lt;- repClonality(immdata$data, .method = "homeo")
vis(imm_hom)
</code></pre>

<hr>
<h2 id='repDiversity'>The main function for immune repertoire diversity estimation</h2><span id='topic+repDiversity'></span><span id='topic+chao1'></span><span id='topic+hill_numbers'></span><span id='topic+diversity_eco'></span><span id='topic+gini_simpson'></span><span id='topic+inverse_simpson'></span><span id='topic+gini_coef'></span><span id='topic+rarefaction'></span>

<h3>Description</h3>

<p>This is a utility function to estimate the diversity of species or objects in the given distribution.
</p>
<p>Note: functions will check if .data is a distribution of a random variable (sum == 1) or not.
To force normalisation and / or to prevent this, set .do.norm to TRUE (do normalisation)
or FALSE (don't do normalisation), respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repDiversity(
  .data,
  .method = "chao1",
  .col = "aa",
  .max.q = 6,
  .min.q = 1,
  .q = 5,
  .step = NA,
  .quantile = c(0.025, 0.975),
  .extrapolation = NA,
  .perc = 50,
  .norm = TRUE,
  .verbose = TRUE,
  .do.norm = NA,
  .laplace = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repDiversity_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.method">.method</code></td>
<td>
<p>Picks a method used for estimation out of a following list: chao1,
hill, div, gini.simp, inv.simp, gini, raref, d50, dxx.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column(s) to be processed. Pass one of the
following strings, separated by the plus sign: &quot;nt&quot; for nucleotide sequences,
&quot;aa&quot; for amino acid sequences, &quot;v&quot; for V gene segments, &quot;j&quot; for J gene segments. E.g.,
pass &quot;aa+v&quot; to compute diversity estimations on CDR3 amino acid sequences paired with V gene segments, i.e.,
in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment.
Clonal counts of equal clonotypes will be summed up.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.max.q">.max.q</code></td>
<td>
<p>The max hill number to calculate (default: 5).</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.min.q">.min.q</code></td>
<td>
<p>Function calculates several hill numbers. Set the min (default: 1).</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.q">.q</code></td>
<td>
<p>q-parameter for the Diversity index.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.step">.step</code></td>
<td>
<p>Rarefaction step's size.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.quantile">.quantile</code></td>
<td>
<p>Numeric vector with quantiles for confidence intervals.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.extrapolation">.extrapolation</code></td>
<td>
<p>An integer. An upper limit for the number of clones to extrapolate to.
Pass 0 (zero) to turn extrapolation subroutines off.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.perc">.perc</code></td>
<td>
<p>Set the percent to dXX index measurement.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.norm">.norm</code></td>
<td>
<p>Normalises rarefaction curves.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.verbose">.verbose</code></td>
<td>
<p>If TRUE then outputs progress.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.do.norm">.do.norm</code></td>
<td>
<p>One of the three values - NA, TRUE or FALSE. If NA then checks for distrubution (sum(.data) == 1)
and normalises if needed with the given laplace correction value. if TRUE then does normalisation and laplace
correction. If FALSE then doesn't do neither normalisaton nor laplace correction.</p>
</td></tr>
<tr><td><code id="repDiversity_+3A_.laplace">.laplace</code></td>
<td>
<p>A numeric value, which is used as a pseudocount for Laplace
smoothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- True diversity, or the effective number of types, refers to the number
of equally-abundant types needed for the average proportional abundance
of the types to equal that observed in the dataset of interest
where all types may not be equally abundant.
</p>
<p>- Inverse Simpson index is the effective number of types that is obtained when
the weighted arithmetic mean is used to quantify average
proportional abundance of types in the dataset of interest.
</p>
<p>- The Gini coefficient measures the inequality among values
of a frequency distribution (for example levels of income). A Gini coefficient of zero
expresses perfect equality, where all values are the same (for example, where everyone
has the same income). A Gini coefficient of one (or 100 percents ) expresses maximal inequality
among values (for example where only one person has all the income).
</p>
<p>- The Gini-Simpson index is the probability of interspecific encounter, i.e., probability that two entities
represent different types.
</p>
<p>- Chao1 estimator is a nonparameteric asymptotic estimator of species richness (number of species in a population).
</p>
<p>- Rarefaction is a technique to assess species richness from the results of sampling through extrapolation.
</p>
<p>- Hill numbers are a mathematically  unified family of  diversity indices (differing among themselves
only by an exponent q).
</p>
<p>- d50 is a recently developed immune diversity estimate. It calculates the minimum number of distinct clonotypes
amounting to greater than or equal to 50 percent of a total of sequencing reads obtained
following amplification and sequencing
</p>
<p>- dXX is a similar to d50 index where XX corresponds to desirable percent of total sequencing reads.
</p>


<h3>Value</h3>

<p>div, gini, gini.simp, inv.simp, raref return numeric vector of length 1
with value.
</p>
<p>chao1 returns 4 values: estimated number of species, standart deviation of
this number and two 95
</p>
<p>hill returns a vector of specified length <code>.max.q - .min.q</code>
</p>
<p>For most methods, if input data is a single immune repertoire, then the function returns a numeric vector
with diversity statistics.
</p>
<p>Otherwise, it returns a numeric matrix with diversity statistics for all input repertoires.
</p>
<p>For Chao1 the function returns a matrix with diversity estimations.
</p>
<p>For rarefaction the function returns either a matrix with diversity estimatinos
on different step of the simulaiton process or a list with such matrices.
</p>


<h3>See Also</h3>

<p><a href="#topic+repOverlap">repOverlap</a>, <a href="#topic+entropy">entropy</a>, <a href="#topic+repClonality">repClonality</a>
Rarefaction wiki
<a href="https://en.wikipedia.org/wiki/Rarefaction_(ecology)">https://en.wikipedia.org/wiki/Rarefaction_(ecology)</a>
Hill numbers paper
<a href="https://www.uvm.edu/~ngotelli/manuscriptpdfs/ChaoHill.pdf">https://www.uvm.edu/~ngotelli/manuscriptpdfs/ChaoHill.pdf</a>
Diversity wiki
<a href="https://en.wikipedia.org/wiki/Measurement_of_biodiversity">https://en.wikipedia.org/wiki/Measurement_of_biodiversity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

# Make data smaller for testing purposes
immdata$data &lt;- top(immdata$data, 4000)

# chao1
repDiversity(.data = immdata$data, .method = "chao1") %&gt;% vis()

# Hill numbers
repDiversity(
  .data = immdata$data, .method = "hill", .max.q = 6,
  .min.q = 1, .do.norm = NA, .laplace = 0
) %&gt;% vis()

# diversity
repDiversity(.data = immdata$data, .method = "div", .q = 5, .do.norm = NA, .laplace = 0) %&gt;%
  vis()

# Gini-Simpson
repDiversity(.data = immdata$data, .method = "gini.simp", .q = 5, .do.norm = NA, .laplace = 0) %&gt;%
  vis()

# inverse Simpson
repDiversity(.data = immdata$data, .method = "inv.simp", .do.norm = NA, .laplace = 0) %&gt;% vis()

# Gini coefficient
repDiversity(.data = immdata$data, .method = "gini", .do.norm = NA, .laplace = 0)

# d50
repDiversity(.data = immdata$data, .method = "d50") %&gt;% vis()
</code></pre>

<hr>
<h2 id='repExplore'>Main function for exploratory data analysis: compute the distribution of lengths, clones, etc.</h2><span id='topic+repExplore'></span>

<h3>Description</h3>

<p>The <code>repExplore</code> function calculates the basic statistics of
repertoire: the number of unique immune receptor clonotypes, their relative abundances,
and sequence length distribution across the input dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repExplore(
  .data,
  .method = c("volume", "count", "len", "clones"),
  .col = c("nt", "aa"),
  .coding = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repExplore_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="repExplore_+3A_.method">.method</code></td>
<td>
<p>A string that specifies the method of analysis. It can be
either &quot;volume&quot;, &quot;count&quot;, &quot;len&quot; or &quot;clones&quot;.
</p>
<p>When .method is set to &quot;volume&quot; the repExplore calculates the number of unique
clonotypes in the input data.
</p>
<p>When .method is set to &quot;count&quot; the repExplore calculates the distribution of
clonotype abundances, i.e., how frequent receptors with different abundances are.
</p>
<p>When .method is set to &quot;len&quot; the repExplore calculates the distribution of
CDR3 sequence lengths.
</p>
<p>When .method is set to &quot;clones&quot; the repExplore returns the number of clones (i.e., cells)
per input repertoire.</p>
</td></tr>
<tr><td><code id="repExplore_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column to be processed. Pass &quot;nt&quot; for
nucleotide sequence or &quot;aa&quot; for amino acid sequence.</p>
</td></tr>
<tr><td><code id="repExplore_+3A_.coding">.coding</code></td>
<td>
<p>If <code>TRUE</code>, then only coding sequences will be analysed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If input data is a single immune repertoire, then the function returns a numeric vector
with exploratory analysis statistics.
</p>
<p>Otherwise, it returns a numeric matrix with exploratory analysis statistics for all input repertoires.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis.immunr_exp_vol">vis.immunr_exp_vol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

# Calculate statistics and generate a visual output with vis()
repExplore(immdata$data, .method = "volume") %&gt;% vis()

repExplore(immdata$data, .method = "count") %&gt;% vis()

repExplore(immdata$data, .method = "len") %&gt;% vis()
</code></pre>

<hr>
<h2 id='repFilter'>Main function for data filtering</h2><span id='topic+repFilter'></span><span id='topic+include'></span><span id='topic+exclude'></span><span id='topic+lessthan'></span><span id='topic+morethan'></span><span id='topic+interval'></span>

<h3>Description</h3>

<p>Main function for data filtering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repFilter(
  .data,
  .method = "by.clonotype",
  .query = list(CDR3.aa = exclude("partial", "out_of_frame")),
  .match = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repFilter_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Must be the list of 2 elements:
a data table and a metadata table.</p>
</td></tr>
<tr><td><code id="repFilter_+3A_.method">.method</code></td>
<td>
<p>Method of filtering. Implemented methods:
by.meta, by.repertoire (by.rep), by.clonotype (by.cl)
Default value: 'by.clonotype'.</p>
</td></tr>
<tr><td><code id="repFilter_+3A_.query">.query</code></td>
<td>
<p>Filtering query. It's a named list of filters that will be applied
to data.
Possible values for names in this list are dependent on filter methods:
- by.meta: filters by metadata. Names in the named list are metadata column headers.
- by.repertoire: filters by the number of clonotypes or total number of clones in sample.
Possible names in the named list are &quot;n_clonotypes&quot; and &quot;n_clones&quot;.
- by.clonotype: filters by data in all samples. Names in the named list are
data column headers.
Elements of the named list for each of the filters are filtering options.
Possible values for filtering options:
- include(&quot;STR1&quot;, &quot;STR2&quot;, ...): keeps only rows with matching values.
Available for methods: &quot;by.meta&quot;, &quot;by.clonotype&quot;.
- exclude(&quot;STR1&quot;, &quot;STR2&quot;, ...): removes rows with matching values.
Available for methods: &quot;by.meta&quot;, &quot;by.clonotype&quot;.
- lessthan(value): keeps rows/samples with numeric values less than specified.
Available for methods: &quot;by.meta&quot;, &quot;by.repertoire&quot;, &quot;by.clonotype&quot;.
- morethan(value): keeps rows/samples with numeric values more than specified.
Available for methods: &quot;by.meta&quot;, &quot;by.repertoire&quot;, &quot;by.clonotype&quot;.
- interval(from, to): keeps rows/samples with numeric values that fits in this interval.
from is inclusive, to is exclusive.
Available for methods: &quot;by.meta&quot;, &quot;by.repertoire&quot;, &quot;by.clonotype&quot;.
Default value: 'list(CDR3.aa = exclude(&quot;partial&quot;, &quot;out_of_frame&quot;))'.</p>
</td></tr>
<tr><td><code id="repFilter_+3A_.match">.match</code></td>
<td>
<p>Matching method for &quot;include&quot; and &quot;exclude&quot; options in query.
Possible values:
- exact: matches only the exact specified string;
- startswith: matches all strings starting with the specified substring;
- substring: matches all strings containing the specified substring.
Default value: 'exact'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

# Select samples with status "MS"
repFilter(immdata, "by.meta", list(Status = include("MS")))

# Select samples without status "MS"
repFilter(immdata, "by.meta", list(Status = exclude("MS")))

# Select samples from lanes "A" and "B" with age &gt; 15
repFilter(immdata, "by.meta", list(Lane = include("A", "B"), Age = morethan(15)))

# Select samples that are not from lanes "A" and "B"
repFilter(immdata, "by.meta", list(Lane = exclude("A", "B")))

# Select samples with a number of clonotypes from 1000 to 5000
repFilter(immdata, "by.repertoire", list(n_clonotypes = interval(1000, 5000)))

# Select clonotypes in all samples with alpha chains
repFilter(immdata, "by.clonotype",
  list(V.name = include("AV"), J.name = include("AJ")),
  .match = "substring"
)
</code></pre>

<hr>
<h2 id='repGermline'>Creates germlines for clonal lineages</h2><span id='topic+repGermline'></span>

<h3>Description</h3>

<p>This function creates germlines for clonal lineages. B cell clonal lineage
represents a set of B cells that presumably have a common origin (arising from the same VDJ
rearrangement event) and a common ancestor. Each clonal lineage has its own germline sequence
that represents the ancestral sequence for each BCR in clonal lineage. In other words,
germline sequence is a sequence of B-cells immediately after VDJ recombination, before
B-cell maturation and hypermutation process. Germline sequence is useful for assessing
the degree of mutation and maturity of the repertoire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repGermline(.data, .species, .min_nuc_outside_cdr3, .threads)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repGermline_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>, <a href="data.table.html#topic+data.table">data.table</a>
or a list of these objects.
</p>
<p>It must have columns in the immunarch compatible format <a href="#topic+immunarch_data_format">immunarch_data_format</a>.</p>
</td></tr>
<tr><td><code id="repGermline_+3A_.species">.species</code></td>
<td>
<p>Species from which the data was acquired. Available options:
&quot;HomoSapiens&quot; (default), &quot;MusMusculus&quot;, &quot;BosTaurus&quot;, &quot;CamelusDromedarius&quot;,
&quot;CanisLupusFamiliaris&quot;, &quot;DanioRerio&quot;, &quot;MacacaMulatta&quot;, &quot;MusMusculusDomesticus&quot;,
&quot;MusMusculusCastaneus&quot;, &quot;MusMusculusMolossinus&quot;, &quot;MusMusculusMusculus&quot;, &quot;MusSpretus&quot;,
&quot;OncorhynchusMykiss&quot;, &quot;OrnithorhynchusAnatinus&quot;, &quot;OryctolagusCuniculus&quot;, &quot;RattusNorvegicus&quot;,
&quot;SusScrofa&quot;.</p>
</td></tr>
<tr><td><code id="repGermline_+3A_.min_nuc_outside_cdr3">.min_nuc_outside_cdr3</code></td>
<td>
<p>This parameter sets how many nucleotides should have V or J chain
outside of CDR3 to be considered good for further alignment.</p>
</td></tr>
<tr><td><code id="repGermline_+3A_.threads">.threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data with added columns:
* Sequence (FR1+CDR1+FR2+CDR2+FR3+CDR3+FR4 in nucleotides; the column will be replaced if exists)
* V.allele, J.allele (chosen alleles of V and J genes),
* V.aa, J.aa (V and J sequences from original clonotype, outside CDR3, converted to amino acids)
* Germline.sequence (combined germline nucleotide sequence)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bcrdata)

bcrdata$data %&gt;%
  top(5) %&gt;%
  repGermline()
</code></pre>

<hr>
<h2 id='repLoad'>Load immune repertoire files into the R workspace</h2><span id='topic+repLoad'></span>

<h3>Description</h3>

<p>The <code>repLoad</code> function loads repertoire files
into R workspace in the immunarch format where you can immediately use them for
the analysis. <code>repLoad</code> automatically detects the right format for
your files, so all you need is simply provide the path to your files.
</p>
<p>See &quot;Details&quot; for more information on supported formats. See &quot;Examples&quot; for
diving right into it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repLoad(.path, .mode = "paired", .coding = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repLoad_+3A_.path">.path</code></td>
<td>
<p>A character string specifying the path to the input data.
Input data can be one of the following:
</p>
<p>- a single repertoire file.
In this case <code>repLoad</code> returns an R <a href="base.html#topic+data.frame">data.frame</a>;
</p>
<p>- a vector of paths to repertoire files.
Same as in the case with no metadata file presented in the next section below;
</p>
<p>- a path to the folder with repertoire files and, if available, metadata file &quot;metadata.txt&quot;.
If the metadata file if presented, then the <code>repLoad</code> returns a list with two elements &quot;data&quot; and &quot;meta&quot;.
&quot;data&quot; is an another list with repertoire R <a href="base.html#topic+data.frame">data.frame</a>s. &quot;meta&quot; is a data frame with the metadata.
If the metadata file &quot;metadata.txt&quot; is not presented, then the <code>repLoad</code> creates a dummy metadata file with
sample names and returns a list with two elements &quot;data&quot; and &quot;meta&quot;.
If input data has multiple chains or cell types stored in the same file
(for example, like in 10xGenomics repertoire files), such repertoire files will be splitted to different
R data frames with only one type of chain and cell presented. The metadata file will have additional columns specifying
cell and chain types for different samples.</p>
</td></tr>
<tr><td><code id="repLoad_+3A_.mode">.mode</code></td>
<td>
<p>Either &quot;single&quot; for single chain data or &quot;paired&quot; for paired chain data.
</p>
<p>Currently &quot;single&quot; works for every format, and &quot;paired&quot; works only for 10X Genomics data.
</p>
<p>By default, 10X Genomics data will be loaded as paired chain data, and other files will be loaded as single chain data.</p>
</td></tr>
<tr><td><code id="repLoad_+3A_.coding">.coding</code></td>
<td>
<p>A logical value. Set TRUE to get coding-only clonotypes (by defaul). Set FALSE to get all clonotypes.</p>
</td></tr>
<tr><td><code id="repLoad_+3A_...">...</code></td>
<td>
<p>Extra arguments for parsing functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metadata has to be a tab delimited file with first column named &quot;Sample&quot;.
It can have any number of additional columns with arbitrary names.
The first column should contain base names of files without extensions in
your folder. Example:
</p>

<table>
<tr>
 <td style="text-align: left;">
 Sample </td><td style="text-align: left;"> Sex </td><td style="text-align: left;"> Age </td><td style="text-align: left;"> Status</td>
</tr>
<tr>
 <td style="text-align: left;">
 immunoseq_1 </td><td style="text-align: left;"> M </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> C</td>
</tr>
<tr>
 <td style="text-align: left;">
 immunoseq_2 </td><td style="text-align: left;"> M </td><td style="text-align: left;"> 2 </td><td style="text-align: left;"> C</td>
</tr>
<tr>
 <td style="text-align: left;">
 immunoseq_3 </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> 3 </td><td style="text-align: left;"> A
</td>
</tr>

</table>

<p>Currently, Immunarch support the following formats:
</p>
<p>- &quot;immunoseq&quot; - ImmunoSEQ of any version. http://www.adaptivebiotech.com/immunoseq
</p>
<p>- &quot;mitcr&quot; - MiTCR. https://github.com/milaboratory/mitcr
</p>
<p>- &quot;mixcr&quot; - MiXCR (the &quot;all&quot; files) of any version. https://github.com/milaboratory/mixcr
</p>
<p>- &quot;migec&quot; - MiGEC. http://migec.readthedocs.io/en/latest/
</p>
<p>- &quot;migmap&quot; - For parsing IgBLAST results postprocessed with MigMap. https://github.com/mikessh/migmap
</p>
<p>- &quot;tcr&quot; - tcR, our previous package. https://imminfo.github.io/tcr/
</p>
<p>- &quot;vdjtools&quot; - VDJtools of any version. http://vdjtools-doc.readthedocs.io/en/latest/
</p>
<p>- &quot;imgt&quot; - IMGT HighV-QUEST. http://www.imgt.org/HighV-QUEST/
</p>
<p>- &quot;airr&quot; - adaptive immune receptor repertoire (AIRR) data format. http://docs.airr-community.org/en/latest/datarep/overview.html
</p>
<p>- &quot;10x&quot; - 10XGenomics clonotype annotations tables. https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/output/annotation
</p>
<p>- &quot;archer&quot; - ArcherDX clonotype tables. https://archerdx.com/
</p>


<h3>Value</h3>

<p>A list with two named elements:
</p>
<p>- &quot;data&quot; is a list of input samples;
</p>
<p>- &quot;meta&quot; is a data frame with sample metadata.
</p>


<h3>See Also</h3>

<p><a href="#topic+immunr_data_format">immunr_data_format</a> for immunarch data format; <a href="#topic+repSave">repSave</a> for file saving;
<a href="#topic+repOverlap">repOverlap</a>, <a href="#topic+geneUsage">geneUsage</a> and <a href="#topic+repDiversity">repDiversity</a> for starting with immune repertoires basic statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To load the data from a single file (note that you don't need to specify the data format):
file_path &lt;- paste0(system.file(package = "immunarch"), "/extdata/io/Sample1.tsv.gz")
immdata &lt;- repLoad(file_path)

# Suppose you have a following structure in your folder:
# &gt;_ ls
# immunoseq1.txt
# immunoseq2.txt
# immunoseq3.txt
# metadata.txt

# To load the whole folder with every file in it type:
file_path &lt;- paste0(system.file(package = "immunarch"), "/extdata/io/")
immdata &lt;- repLoad(file_path)
print(names(immdata))

# We recommend creating a metadata file named "metadata.txt" in the folder.

# In that case, when you load your data you will see:
# &gt; immdata &lt;- repLoad("path/to/your/folder/")
# &gt; names(immdata)
# [1] "data" "meta"

# If you do not have "metadata.txt", you will see the same output,
# but your metadata will be almost empty:
# &gt; immdata &lt;- repLoad("path/to/your/folder/")
# &gt; names(immdata)
# [1] "data" "meta"
</code></pre>

<hr>
<h2 id='repOverlap'>Main function for public clonotype statistics calculations</h2><span id='topic+repOverlap'></span>

<h3>Description</h3>

<p>The <code>repOverlap</code> function is designed to analyse the overlap between
two or more repertoires. It contains a number of methods to compare immune receptor
sequences that are shared between individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repOverlap(
  .data,
  .method = c("public", "overlap", "jaccard", "tversky", "cosine", "morisita",
    "inc+public", "inc+morisita"),
  .col = "aa",
  .a = 0.5,
  .b = 0.5,
  .verbose = TRUE,
  .step = 1000,
  .n.steps = 10,
  .downsample = FALSE,
  .bootstrap = NA,
  .verbose.inc = NA,
  .force.matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repOverlap_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.method">.method</code></td>
<td>
<p>A string that specifies the method of analysis or a combination of
methods. The <code>repOverlap</code> function supports following basic methods:
&quot;public&quot;, &quot;overlap&quot;, &quot;jaccard&quot;, &quot;tversky&quot;, &quot;cosine&quot;, &quot;morisita&quot;.
If vector of multiple methods is given for this parameter, the first method will be used.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column(s) to be processed. Pass one of the
following strings, separated by the plus sign: &quot;nt&quot; for nucleotide sequences,
&quot;aa&quot; for amino acid sequences, &quot;v&quot; for V gene segments, &quot;j&quot; for J gene segments. E.g.,
pass &quot;aa+v&quot; to compute overlaps on CDR3 amino acid sequences paired with V gene segments, i.e.,
in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment.
Clonal counts of equal clonotypes will be summed up.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.a">.a</code>, <code id="repOverlap_+3A_.b">.b</code></td>
<td>
<p>Alpha and beta parameters for Tversky Index. Default values give
the Jaccard index measure.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.verbose">.verbose</code></td>
<td>
<p>if TRUE then output the progress.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.step">.step</code></td>
<td>
<p>Either an integer or a numeric vector.
</p>
<p>In the first case, the integer defines the step of incremental overlap.
</p>
<p>In the second case, the vector encodes all repertoire sampling depths.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.n.steps">.n.steps</code></td>
<td>
<p>Skipped if &quot;.step&quot; is a numeric vector.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.downsample">.downsample</code></td>
<td>
<p>If TRUE then performs downsampling to N clonotypes at each step instead of choosing the
top N clonotypes in incremental overlaps. Change nothing of you are using conventional methods.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.bootstrap">.bootstrap</code></td>
<td>
<p>Set NA to turn off any bootstrapping, set a number to perform bootstrapping with this number of tries.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.verbose.inc">.verbose.inc</code></td>
<td>
<p>Logical. If TRUE then shows output from the computation process.</p>
</td></tr>
<tr><td><code id="repOverlap_+3A_.force.matrix">.force.matrix</code></td>
<td>
<p>Logical. If TRUE then always forces the matrix output even in case of two input repertoires.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;public&quot; and &quot;shared&quot; are synonyms that exist
for the convenience of researchers.
</p>
<p>The &quot;overlap&quot; coefficient is a similarity measure that measures the overlap between two finite sets.
</p>
<p>The &quot;jaccard&quot; index is conceptually a percentage of how many objects two sets
have in common out of how many objects they have total.
</p>
<p>The &quot;tversky&quot; index is an asymmetric similarity measure on sets that
compares a variant to a prototype.
</p>
<p>The &quot;cosine&quot; index is a measure of similarity between two non-zero vectors
of an inner product space that measures the cosine of the angle between them.
</p>
<p>The &quot;morisita&quot; index measures how many times it is more likely to randomly
select two sampled points from the same quadrat (the dataset is covered by a
regular grid of changing size) then it would be in the case of a random
distribution generated from a Poisson process. Duplicate objects are merged
with their counts are summed up.
</p>


<h3>Value</h3>

<p>In most cases the return value is a matrix with overlap values for each pair of repertoires.
</p>
<p>If only two repertoires were provided, return value is single numeric value.
</p>
<p>If one of the incremental method is chosen, return list of overlap matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+inc_overlap">inc_overlap</a>, <a href="#topic+vis">vis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

# Make data smaller for testing purposes
immdata$data &lt;- top(immdata$data, 4000)

ov &lt;- repOverlap(immdata$data, .verbose = FALSE)
vis(ov)

ov &lt;- repOverlap(immdata$data, "jaccard", .verbose = FALSE)
vis(ov, "heatmap2")
</code></pre>

<hr>
<h2 id='repOverlapAnalysis'>Post-analysis of public clonotype statistics: PCA, clustering, etc.</h2><span id='topic+repOverlapAnalysis'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a></code> function contains advanced data
analysis methods. You can use several clustering and dimensionality reduction
techniques in order to investigate further the difference between repertoires
provided.
</p>
<p>To cluster a subset of similar data with <code><a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a></code> you can
perform hierarchical clustering, k-means or dbscan ('hclust', 'kmeans', 'dbscan'
respectively).
</p>
<p>To reduce dimensions, for example, to select features for subsequent analysis,
you can execute the multidimensional scaling or t-sne algorithms ('mds' and 'tsne'
respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repOverlapAnalysis(
  .data,
  .method = ("hclust"),
  .scale = default_scale_fun,
  .raw = TRUE,
  .perp = 1,
  .theta = 0.1,
  .eps = 0.01,
  .k = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repOverlapAnalysis_+3A_.data">.data</code></td>
<td>
<p>Any distance matrix between pairs of repertoires. You can also pass your
output from <code><a href="#topic+repOverlap">repOverlap</a></code>.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.method">.method</code></td>
<td>
<p>A string that defines the type of analysis to perform.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.scale">.scale</code></td>
<td>
<p>A function to scale the data before passing it to the MDS algorithm.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.raw">.raw</code></td>
<td>
<p>A logical value. Set TRUE if you want to receive raw output of clustering
or dimensionality reduction function of choice. Set FALSE if you want to receive
processed output that can be subjected to visualisation with <code><a href="#topic+vis">vis</a></code> function.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.perp">.perp</code></td>
<td>
<p>A numerical value, t-SNE parameter, see <code><a href="#topic+immunr_tsne">immunr_tsne</a></code>.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.theta">.theta</code></td>
<td>
<p>A numerical value, t-SNE parameter, see <code><a href="#topic+immunr_tsne">immunr_tsne</a></code>.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.eps">.eps</code></td>
<td>
<p>A numerical value, DBscan epsylon parameter, see <code><a href="#topic+immunr_dbscan">immunr_dbscan</a></code>.</p>
</td></tr>
<tr><td><code id="repOverlapAnalysis_+3A_.k">.k</code></td>
<td>
<p>The number of clusters to create, passed as <code>k</code> to <a href="factoextra.html#topic+hcut">hcut</a> or as <code>centers</code> to <a href="stats.html#topic+kmeans">kmeans</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the last element in the <code>.method</code> string. See <a href="#topic+immunr_tsne">immunr_tsne</a> for more info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
repOverlapAnalysis(ov, "mds+hclust") %&gt;% vis()
</code></pre>

<hr>
<h2 id='repSample'>Downsampling and resampling of immune repertoires</h2><span id='topic+repSample'></span>

<h3>Description</h3>

<p>Sample (downsample) repertoires using different approches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repSample(
  .data,
  .method = c("downsample", "resample", "sample"),
  .n = NA,
  .prob = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repSample_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="repSample_+3A_.method">.method</code></td>
<td>
<p>Character. Name of a sampling method. See &quot;Details&quot; for more details. Default value is &quot;downsample&quot;
that downsamples the repertoires to the number of clones (i.e., reads / UMIs) that the smallest repertoire has, if user
doesn't set any value to the &quot;.n&quot; argument.</p>
</td></tr>
<tr><td><code id="repSample_+3A_.n">.n</code></td>
<td>
<p>Integer. Number of clones / clonotypes / reads / UMIs to choose, depending on the method. Set NA to sample
repertoires to the size of the smallest repertoire in the &quot;.data&quot;.</p>
</td></tr>
<tr><td><code id="repSample_+3A_.prob">.prob</code></td>
<td>
<p>Logical. If TRUE then samples the clonotypes with probability weights equal to their number of clones. Used only if
&quot;.method&quot; is &quot;sample&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>.method</code> is &quot;downsample&quot; then <code>repSample</code> chooses <code>.n</code> clones (not clonotypes!) from the input repertoires without any probabilistic simulation,
but exactly computing each choosed clones. Such approach is is more consistent and biologically pleasant than
an output from the function if <code>.method</code> is &quot;resample&quot;.
</p>
<p>If <code>.method</code> is &quot;resample&quot; then <code>repSample</code> uses multinomial distribution to compute the number of occurences for each cloneset.
then it removes zero-number clonotypes and return the resulting data frame. Probabilities for <code>rmultinom</code> for each cloneset
is a percentage of this cloneset in the &quot;Proportion&quot; column. It's a some sort of simulation of how clonotypes are chosen from the organisms.
</p>
<p>if <code>.method</code> is &quot;sample&quot; then <code>repSample</code> chooses <code>.n</code> clonotypes (not clones!) randomly. Depending on the
<code>.prob</code> argument, the function chooses clonotypes either according to their size (if <code>.prob</code> is TRUE, by default),
or each clonotype has an equal chance to be choosed (if <code>.prob</code> is FALSE). Note that sampling is done without replacing.
</p>


<h3>Value</h3>

<p>Subsampled immune repertoire or a list of subsampled immune repertoires.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+rmultinom">rmultinom</a>, <a href="#topic+clonal_proportion">clonal_proportion</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
# Downsampling to 1000 clones (not clonotypes!)
tmp &lt;- repSample(immdata$data[[1]], .n = 1000)
sum(tmp$Clones)

# Downsampling to 1000 clonotypes
tmp &lt;- repSample(immdata$data[[1]], "sample", .n = 1000)
nrow(tmp)

# Downsampling to the smallest repertoire by clones (not clonotypes!)
tmp &lt;- repSample(immdata$data[c(1, 2)])
sum(tmp[[1]]$Clones)
sum(tmp[[2]]$Clones)

# Downsampling to the smallest repertoire by clonotypes
tmp &lt;- repSample(immdata$data[c(1, 2)], "sample")
nrow(tmp[[1]]$Clones)
nrow(tmp[[2]]$Clones)
</code></pre>

<hr>
<h2 id='repSave'>Save immune repertoires to the disk</h2><span id='topic+repSave'></span>

<h3>Description</h3>

<p>The <code>repSave</code> function is deigned to save your data to the disk
in desirable format. Currently supports &quot;immunarch&quot; and &quot;vdjtools&quot; file formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repSave(.data, .path, .format = c("immunarch", "vdjtools"), .compress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repSave_+3A_.data">.data</code></td>
<td>
<p>An R dataframe, a list of R dataframes or a list with <code>data</code> and
<code>meta</code> where first element is a list of dataframes and the latter is a dataframe
with metadata.</p>
</td></tr>
<tr><td><code id="repSave_+3A_.path">.path</code></td>
<td>
<p>A string with the path to the output directory. It should include file
name if a single dataframe is provided to .data argument.</p>
</td></tr>
<tr><td><code id="repSave_+3A_.format">.format</code></td>
<td>
<p>A string with desirable format specification. Current options are
&quot;immunarch&quot; and &quot;vdjtools&quot;.</p>
</td></tr>
<tr><td><code id="repSave_+3A_.compress">.compress</code></td>
<td>
<p>A boolean value. Defines whether the output will be compressed or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not necessary to create directories beforehand. If the provided directory
does not exist it will be created automatically.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
# Reduce data to save time on examples
immdata$data &lt;- purrr::map(immdata$data, ~ .x %&gt;% head(10))
dirpath &lt;- tempdir()
# Save the list of repertoires
repSave(immdata, dirpath)
# Load it and check if it is the same
new_immdata &lt;- repLoad(dirpath)
# sum(immdata$data[[1]] != new_immdata$data[[1]], na.rm = TRUE)
# sum(immdata$data[[2]] != new_immdata$data[[2]], na.rm = TRUE)
# sum(immdata$meta != new_immdata$meta, na.rm = TRUE)
</code></pre>

<hr>
<h2 id='repSomaticHypermutation'>Calculates number of mutations against the germline for each clonotype</h2><span id='topic+repSomaticHypermutation'></span>

<h3>Description</h3>

<p>This function aligns V and J genes from the germline in each cluster
with corresponding genes in each clonotype, saves the alignments for purpose of visualization,
and calculates number of mutations for each clonotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repSomaticHypermutation(.data, .threads, .nofail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repSomaticHypermutation_+3A_.data">.data</code></td>
<td>
<p>The data to be processed: an output of repClonalFamily();
variants with one sample and list of samples are both supported.</p>
</td></tr>
<tr><td><code id="repSomaticHypermutation_+3A_.threads">.threads</code></td>
<td>
<p>Number of threads to use.</p>
</td></tr>
<tr><td><code id="repSomaticHypermutation_+3A_.nofail">.nofail</code></td>
<td>
<p>Will return NA instead of stopping if Clustal W is not installed.
Used to avoid raising errors in examples on computers where Clustal W is not installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe or list of dataframes (if input is a list with multiple samples).
The dataframe has all the columns from repClonalFamily() output dataframe, with Sequence
column unnested: the resulting dataframe has one line per clonotype. Clone.ID column
contains original IDs for clonotypes, and can be used as dataframe key.
New columns are added:
* Germline.Alignment.V: contains V gene alignment of current clonotype with the germline
* Germline.Alignment.J: contains J gene alignment of current clonotype with the germline
* Substitutions: contains number of substitutions in the alignment (summary for V and J)
* Insertions: contains number of insertions in the clonotype relative to germline
(summary for V and J)
* Deletions: contains number of deletions in the clonotype relative to germline
(summary for V and J)
* Mutations: contains total number of mutations in the alignment (summary for V and J)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bcrdata)
bcr_data &lt;- bcrdata$data

bcr_data %&gt;%
  seqCluster(seqDist(bcr_data), .fixed_threshold = 3) %&gt;%
  repGermline(.threads = 1) %&gt;%
  repAlignLineage(.min_lineage_sequences = 2, .align_threads = 2, .nofail = TRUE) %&gt;%
  repClonalFamily(.threads = 1, .nofail = TRUE) %&gt;%
  repSomaticHypermutation(.threads = 1, .nofail = TRUE)
</code></pre>

<hr>
<h2 id='scdata'>Paired chain immune repertoire dataset</h2><span id='topic+scdata'></span>

<h3>Description</h3>

<p>A dataset with paired chain IG data for testing and examplatory purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdata
</code></pre>


<h3>Format</h3>

<p>A list of four elements:
&quot;data&quot; is a list with data frames with clonotype tables.
&quot;meta&quot; is a metadata table.
&quot;bc_patients&quot; is a list of barcodes corresponding to specific patients.
&quot;bc_clusters&quot; is a list of barcodes corresponding to specific cell clusters.
</p>

<dl>
<dt>data</dt><dd><p>List of immune repertoire data frames.</p>
</dd>
<dt>meta</dt><dd><p>Metadata</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='select_barcodes'>Select specific clonotypes using barcodes from single-cell metadata</h2><span id='topic+select_barcodes'></span>

<h3>Description</h3>

<p>Subsets the input immune repertoire by barcodes. Creates a vector of
barcodes to subset or a vector cluster IDs and corresponding barcodes to
get a list of immune repertoires corresponding to cluster IDs.
Columns with clonotype counts
and proportions are changed accordingly to the filtered barcodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_barcodes(.data, .barcodes, .force.list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_barcodes_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="select_barcodes_+3A_.barcodes">.barcodes</code></td>
<td>
<p>Either a character vector with barcodes or a named character/factor vector with
barcodes as names and cluster IDs a vector elements. The output of Seurat's <code>Idents</code> function works.</p>
</td></tr>
<tr><td><code id="select_barcodes_+3A_.force.list">.force.list</code></td>
<td>
<p>Logical. If TRUE then always returns a list, even if the result is one data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An immune repertoire (if &quot;.barcodes&quot; is a barcode vector) or a list of immune repertoires
(if &quot;.barcodes&quot; is named vector or an output from Seurat::Idents()). Each element is an immune repertoire
with clonotype barcodes corresponding to the input barcodes. The output list names are cluster names
in the &quot;.barcode&quot; argument (Seurat::Idents() case only).
</p>


<h3>See Also</h3>

<p><a href="#topic+select_clusters">select_clusters</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(immdata)
# Create a fake single-cell data
df &lt;- immdata$data[[1]]
df$Barcode &lt;- "AAAAACCCCC"
df$Barcode[51:nrow(df)] &lt;- "GGGGGCCCCC"
barcodes &lt;- "AAAAACCCCC"
df &lt;- select_barcodes(df, barcodes)
nrow(df)

## End(Not run)
</code></pre>

<hr>
<h2 id='select_clusters'>Split the immune repertoire data to clusters from single-cell barcodes</h2><span id='topic+select_clusters'></span>

<h3>Description</h3>

<p>Given the vector of barcodes from Seurat, splits the input repertoires
to separate subsets following the barcodes' assigned IDs. Useful in case you want to
split immune repertoires by patients or clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_clusters(.data, .clusters, .field = "Cluster")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_clusters_+3A_.data">.data</code></td>
<td>
<p>List of two elements &quot;data&quot; and &quot;meta&quot;, with &quot;data&quot; being a list of
immune repertoires, and &quot;meta&quot; being a metadata table.</p>
</td></tr>
<tr><td><code id="select_clusters_+3A_.clusters">.clusters</code></td>
<td>
<p>Factor vector with barcodes as vector names and cluster IDs as vector elements.
The output of the Seurat <code>Idents</code> function works.</p>
</td></tr>
<tr><td><code id="select_clusters_+3A_.field">.field</code></td>
<td>
<p>A string specifying the name of the field in the input metadata. New immune
repertoire subsets will have cluster IDs in this field.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements &quot;data&quot; and &quot;meta&quot; with updated immune repertoire tables and
metadata.
</p>


<h3>See Also</h3>

<p><a href="#topic+select_barcodes">select_barcodes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Seurat)
Idents(pbmc_small)
new_cluster_ids &lt;- c("A", "B", "C")
new_cluster_ids &lt;- levels(pbmc_small)
new_cluster_ids
pbmc_small &lt;- RenameIdents(pbmc_small, new_cluster_ids)

## End(Not run)
</code></pre>

<hr>
<h2 id='seqCluster'>Function for assigning clusters based on sequences similarity</h2><span id='topic+seqCluster'></span>

<h3>Description</h3>

<p>Graph clustering based on distances between sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqCluster(.data, .dist, .perc_similarity, .nt_similarity, .fixed_threshold)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqCluster_+3A_.data">.data</code></td>
<td>
<p>The data which was used to caluculate .dist object. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format <a href="#topic+immunarch_data_format">immunarch_data_format</a></p>
</td></tr>
<tr><td><code id="seqCluster_+3A_.dist">.dist</code></td>
<td>
<p>List of distance objects produced with <a href="#topic+seqDist">seqDist</a> function.</p>
</td></tr>
<tr><td><code id="seqCluster_+3A_.perc_similarity">.perc_similarity</code></td>
<td>
<p>Numeric value between 0 and 1 specifying the maximum acceptable weight of an edge in a graph.
This threshold depends on the length of sequences.</p>
</td></tr>
<tr><td><code id="seqCluster_+3A_.nt_similarity">.nt_similarity</code></td>
<td>
<p>Numeric between 0-sequence length specifying
the threshold of allowing a 1 in n nucleotides mismatch in sequencies.</p>
</td></tr>
<tr><td><code id="seqCluster_+3A_.fixed_threshold">.fixed_threshold</code></td>
<td>
<p>Numeric specifying the threshold on the maximum weight of an edge in a graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Immdata data format object. Same as .data, but with extra 'Cluster' column with clusters assigned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(immdata)
# In this example, we will use only 2 samples with 500 clonotypes in each for time saving
input_data &lt;- lapply(immdata$data[1:2], head, 500)
dist_result &lt;- seqDist(input_data)
cluster_result &lt;- seqCluster(input_data, dist_result, .fixed_threshold = 1)
</code></pre>

<hr>
<h2 id='seqDist'>Function for computing distance for sequences</h2><span id='topic+seqDist'></span>

<h3>Description</h3>

<p>Computing sequential distances between clonotypes from two repertoires:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqDist(.data, .col = 'CDR3.nt', .method = 'hamming',
 .group_by = c("V.name", "J.name"), .group_by_seqLength = TRUE, .trim_genes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqDist_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format <a href="#topic+immunarch_data_format">immunarch_data_format</a></p>
</td></tr>
<tr><td><code id="seqDist_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column name to be processed. The default value is 'CDR3.nt'.</p>
</td></tr>
<tr><td><code id="seqDist_+3A_.method">.method</code></td>
<td>
<p>Character value or user-defined function.</p>
</td></tr>
<tr><td><code id="seqDist_+3A_.group_by">.group_by</code></td>
<td>
<p>Character vector of column names to group sequence by. The default value is c(&quot;V.first&quot;, &quot;J.first&quot;). Columns &quot;V.first&quot; and &quot;J.first&quot; containing first genes without allele suffixes are calculated automatically from &quot;V.name&quot; and &quot;J.name&quot; if absent in the data. Pass NA for no grouping options.</p>
</td></tr>
<tr><td><code id="seqDist_+3A_.group_by_seqlength">.group_by_seqLength</code></td>
<td>
<p>If TRUE  - adds grouping by sequence length of .col argument</p>
</td></tr>
<tr><td><code id="seqDist_+3A_.trim_genes">.trim_genes</code></td>
<td>
<p>If TRUE   - use only general gene values (e.g. &quot;IGHV1-18&quot;) of .group_by columns for clustering; if FALSE - can cause very small clusters in case of high resolution genotyping</p>
</td></tr>
<tr><td><code id="seqDist_+3A_...">...</code></td>
<td>
<p>Extra arguments for user-defined function.
</p>
<p>The default value is <code>'hamming'</code> for Hamming distance which counts the number of character substitutions that turns b into a.
If a and b have different number of characters the distance is Inf.
</p>
<p>Other possible values are:
</p>
<p><code>'lv'</code> for Levenshtein distance which counts the number of deletions, insertions and substitutions necessary to turn b into a.
</p>
<p><code>'lcs'</code> for longest common substring is defined as the longest string can be obtained by pairing characters from a and b while keeping the order of characters intact.
</p>
<p>In case of user-defined function, it should take x and y parameters as input and return <a href="stats.html#topic+dist">dist</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of list with <a href="stats.html#topic+dist">dist</a> objects for given repertoires for each combination of .group_by variable(s) and/or sequence length of .col.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(immdata)
# Reducing data to save time on examples
immdata$data &lt;- purrr::map(immdata$data, ~ .x %&gt;% head(10))
# Computing hamming distance for the first two repertoires in \code{'immdata'}
seqDist(immdata$data[1:2])

# Here we define a custom distance function
# that will count the difference in number of characters in sequences.

f &lt;- function(x, y) {
  res &lt;- matrix(nrow = length(x), ncol = length(y))
  for (i in 1:length(x)) {
    res[i, ] &lt;- abs(nchar(x[i]) - nchar(y))
  }
  dimnames(res) &lt;- list(x, y)
  return(as.dist(res))
}

seqDist(immdata$data[1:2], .method = f, .group_by_seqLength = FALSE)
</code></pre>

<hr>
<h2 id='set_pb'>Set and update progress bars</h2><span id='topic+set_pb'></span><span id='topic+add_pb'></span>

<h3>Description</h3>

<p>Set and update progress bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_pb(.max)

add_pb(.pb, .value = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_pb_+3A_.max">.max</code></td>
<td>
<p>Integer. Maximal value of the progress bar.</p>
</td></tr>
<tr><td><code id="set_pb_+3A_.pb">.pb</code></td>
<td>
<p>Progress bar object from <code>set_pb</code>.</p>
</td></tr>
<tr><td><code id="set_pb_+3A_.value">.value</code></td>
<td>
<p>Numeric. Value to add to the progress bar at each step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated progress bar.
</p>


<h3>Developer Examples</h3>

<p>pb &lt;- immunarch:::set_pb(100)
immunarch:::add_pb(pb, 25)
immunarch:::add_pb(pb, 25)
immunarch:::add_pb(pb, 25)
immunarch:::add_pb(pb, 25)
close(pb)
</p>

<hr>
<h2 id='spectratype'>Immune repertoire spectratyping</h2><span id='topic+spectratype'></span>

<h3>Description</h3>

<p>Immune repertoire spectratyping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectratype(.data, .quant = c("id", "count"), .col = "nt")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectratype_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="spectratype_+3A_.quant">.quant</code></td>
<td>
<p>Select the column with clonal counts to evaluate. Set to &quot;id&quot; to count every clonotype once.
Set to &quot;count&quot; to take into the account number of clones per clonotype.</p>
</td></tr>
<tr><td><code id="spectratype_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column(s) to be processed. The output is one of the
following strings, separated by the plus sign: &quot;nt&quot; for nucleotide sequences,
&quot;aa&quot; for amino acid sequences, &quot;v&quot; for V gene segments, &quot;j&quot; for J gene segments. E.g.,
pass &quot;aa+v&quot; for spectratyping on CDR3 amino acid sequences paired with V gene segments, i.e.,
in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment.
Clonal counts of equal clonotypes will be summed up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with distributions of clonotypes per CDR3 length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data
data(immdata)
sp &lt;- spectratype(immdata$data[[1]], .col = "aa+v")
vis(sp)
</code></pre>

<hr>
<h2 id='split_to_kmers'>Analysis immune repertoire kmer statistics: sequence profiles, etc.</h2><span id='topic+split_to_kmers'></span><span id='topic+kmer_profile'></span>

<h3>Description</h3>

<p>Analysis immune repertoire kmer statistics: sequence profiles, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_to_kmers(.data, .k)

kmer_profile(.data, .method = c("freq", "prob", "wei", "self"), .remove.stop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_to_kmers_+3A_.data">.data</code></td>
<td>
<p>Character vector or the output from <code>getKmers</code>.</p>
</td></tr>
<tr><td><code id="split_to_kmers_+3A_.k">.k</code></td>
<td>
<p>Integer. Size of k-mers.</p>
</td></tr>
<tr><td><code id="split_to_kmers_+3A_.method">.method</code></td>
<td>
<p>Character vector of length one. If &quot;freq&quot; then returns a position frequency matrix (PFM) -
a matrix with occurences of each amino acid in each position.
</p>
<p>If &quot;prob&quot; then returns a position probability matrix (PPM) - a matrix with probabilities of occurences of
each amino acid in each position. This is a traditional representation of sequence motifs.
</p>
<p>If &quot;wei&quot; then returns a position weight matrix (PWM) - a matrix with log likelihoods of PPM elements.
</p>
<p>If &quot;self&quot; then returns a matrix with self-information of elements in PWM.
</p>
<p>For more information see https://en.wikipedia.org/wiki/Position_weight_matrix.</p>
</td></tr>
<tr><td><code id="split_to_kmers_+3A_.remove.stop">.remove.stop</code></td>
<td>
<p>Logical. If TRUE (by default) remove stop codons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>split_to_kmers</code> - Data frame with two columns (k-mers and their counts).
</p>
<p><code>kmer_profile</code> - a matrix with per-position amino acid statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
kmers &lt;- getKmers(immdata$data[[1]], 5)
kmer_profile(kmers) %&gt;% vis()
</code></pre>

<hr>
<h2 id='switch_type'>Return a column's name</h2><span id='topic+switch_type'></span><span id='topic+process_col_argument'></span>

<h3>Description</h3>

<p>Return a column's name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_type(type)

process_col_argument(.col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="switch_type_+3A_type">type</code></td>
<td>
<p>Character. Specifies the column to choose:
&quot;nt&quot; chooses the CDR3 nucleotide column,
&quot;aa&quot; chooses the CDR3 amino acid column,
&quot;v&quot; chooses the V gene segment column,
&quot;j&quot; chooses the J gene segment column.</p>
</td></tr>
<tr><td><code id="switch_type_+3A_.col">.col</code></td>
<td>
<p>A string that specifies the column(s) to be processed. Select one of the
following strings, separated by the plus sign: &quot;nt&quot; for nucleotide sequences,
&quot;aa&quot; for amino acid sequences, &quot;v&quot; for V gene segments, &quot;j&quot; for J gene segments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column's name.
</p>


<h3>Developer Examples</h3>

<p>immunarch:::switch_type(&quot;nuc&quot;)
immunarch:::switch_type(&quot;v&quot;)
</p>

<hr>
<h2 id='top'>Get the N most abundant clonotypes</h2><span id='topic+top'></span>

<h3>Description</h3>

<p>Get the N most abundant clonotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top(.data, .n = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="top_+3A_.data">.data</code></td>
<td>
<p>The data to be processed. Can be <a href="base.html#topic+data.frame">data.frame</a>,
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="top_+3A_.n">.n</code></td>
<td>
<p>Numeric. Number of the most abundant clonotypes to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the <code>.n</code> most abundant clonotypes only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
top(immdata$data)
top(immdata$data[[1]])
</code></pre>

<hr>
<h2 id='trackClonotypes'>Track clonotypes across time and data points</h2><span id='topic+trackClonotypes'></span>

<h3>Description</h3>

<p>Tracks the temporal dynamics of clonotypes in repertoires. For example, tracking across multiple
time points after vaccination.
</p>
<p>Note: duplicated clonotypes are merged and their counts are summed up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trackClonotypes(.data, .which = list(1, 15), .col = "aa", .norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trackClonotypes_+3A_.data">.data</code></td>
<td>
<p>The data to process. It can be a <a href="base.html#topic+data.frame">data.frame</a>, a
<a href="data.table.html#topic+data.table">data.table</a>, or a list of these objects.
</p>
<p>Every object must have columns in the immunarch compatible format.
<a href="#topic+immunarch_data_format">immunarch_data_format</a>
</p>
<p>Competent users may provide advanced data representations:
DBI database connections, Apache Spark DataFrame from <a href="dplyr.html#topic+copy_to">copy_to</a> or a list
of these objects. They are supported with the same limitations as basic objects.
</p>
<p>Note: each connection must represent a separate repertoire.</p>
</td></tr>
<tr><td><code id="trackClonotypes_+3A_.which">.which</code></td>
<td>
<p>An argument that regulates which clonotypes to choose for tracking. There are three options for this argument:
</p>
<p>1) passes a list with two elements <code>list(X, Y)</code>, where <code>X</code> is the name or the index of a target repertoire from &quot;.data&quot;, and
<code>Y</code> is the number of the most abundant clonotypes to take from <code>X</code>.
</p>
<p>2) passes a character vector of sequences to take from all data frames;
</p>
<p>3) passes a data frame (data table, database) with one or more columns - first for sequences, and other for gene segments (if applicable).
</p>
<p>See the &quot;Examples&quot; below with examples for each option.</p>
</td></tr>
<tr><td><code id="trackClonotypes_+3A_.col">.col</code></td>
<td>
<p>A character vector of length 1. Specifies an identifier for a column, from which the function
chooses clonotype sequences. Specify &quot;nt&quot; for nucleotide sequences, &quot;aa&quot; for amino acid sequences,
&quot;aa+v&quot; for amino acid sequences and Variable genes, &quot;nt+j&quot; for nucleotide
sequences with Joining genes, or any combination of the above.
Used only if &quot;.which&quot; has option 1) or option 2).</p>
</td></tr>
<tr><td><code id="trackClonotypes_+3A_.norm">.norm</code></td>
<td>
<p>Logical. If TRUE then uses Proportion instead of the number of Clones per clonotype to store
in the function output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with input sequences and counts or proportions for each of the input repertoire.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load an example data that comes with immunarch
data(immdata)

# Make the data smaller in order to speed up the examples
immdata$data &lt;- immdata$data[c(1, 2, 3, 7, 8, 9)]
immdata$meta &lt;- immdata$meta[c(1, 2, 3, 7, 8, 9), ]

# Option 1
# Choose the first 10 amino acid clonotype sequences
# from the first repertoire to track
tc &lt;- trackClonotypes(immdata$data, list(1, 10), .col = "aa")
# Choose the first 20 nucleotide clonotype sequences
# and their V genes from the "MS1" repertoire to track
tc &lt;- trackClonotypes(immdata$data, list("MS1", 20), .col = "nt+v")

# Option 2
# Choose clonotypes with amino acid sequences "CASRGLITDTQYF" or "CSASRGSPNEQYF"
tc &lt;- trackClonotypes(immdata$data, c("CASRGLITDTQYF", "CSASRGSPNEQYF"), .col = "aa")

# Option 3
# Choose the first 10 clonotypes from the first repertoire
# with amino acid sequences and V segments
target &lt;- immdata$data[[1]] %&gt;%
  select(CDR3.aa, V.name) %&gt;%
  head(10)
tc &lt;- trackClonotypes(immdata$data, target)

# Visualise the output regardless of the chosen option
# Therea are three way to visualise it, regulated by the .plot argument
vis(tc, .plot = "smooth")
vis(tc, .plot = "area")
vis(tc, .plot = "line")

# Visualising timepoints
# First, we create an additional column in the metadata with randomly choosen timepoints:
immdata$meta$Timepoint &lt;- sample(1:length(immdata$data))
immdata$meta
# Next, we create a vector with samples in the right order,
# according to the "Timepoint" column (from smallest to greatest):
sample_order &lt;- order(immdata$meta$Timepoint)
# Sanity check: timepoints are following the right order:
immdata$meta$Timepoint[sample_order]
# Samples, sorted by the timepoints:
immdata$meta$Sample[sample_order]
# And finally, we visualise the data:
vis(tc, .order = sample_order)
</code></pre>

<hr>
<h2 id='vis'>One function to visualise them all</h2><span id='topic+vis'></span>

<h3>Description</h3>

<p>Output from every function in immunarch can be visualised with a
single function - <code>vis</code>. The <code>vis</code> automatically detects
the type of the data and draws a proper visualisation. For example, output
from the <code>repOverlap</code> function will be identified as repertoire overlap values
and respective visualisation will be chosen without any additional arguments.
See &quot;Details&quot; for the list of available visualisations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_+3A_.data">.data</code></td>
<td>
<p>Pass the output from any immunarch analysis tool to <code>vis()</code>.</p>
</td></tr>
<tr><td><code id="vis_+3A_...">...</code></td>
<td>
<p>Any other arguments, see the &quot;Details&quot; section for specific visualisation functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List of available visualisations for different kinds of data.
</p>
<p>Basic analysis:
</p>
<p>- Exploratory analysis results (from <a href="#topic+repExplore">repExplore</a>) - see <a href="#topic+vis.immunr_exp_vol">vis.immunr_exp_vol</a>;
</p>
<p>- Clonality statistics (from <a href="#topic+repClonality">repClonality</a>) - see <a href="#topic+vis.immunr_homeo">vis.immunr_homeo</a>.
</p>
<p>Overlaps and public clonotypes:
</p>
<p>- Overlaps (from <a href="#topic+repOverlap">repOverlap</a>) using heatmaps, circos plots, polar area plots - see <a href="#topic+vis.immunr_ov_matrix">vis.immunr_ov_matrix</a>;
</p>
<p>-  Overlap clustering (from <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a>) - see <a href="#topic+vis.immunr_hclust">vis.immunr_hclust</a>;
</p>
<p>- Repertoire incremental overlaps (from <a href="#topic+repOverlap">repOverlap</a>) - see <a href="#topic+vis.immunr_inc_overlap">vis.immunr_inc_overlap</a>;
</p>
<p>- Public repertoire abundance (from <a href="#topic+pubRep">pubRep</a>) - vis <a href="#topic+vis.immunr_public_repertoire">vis.immunr_public_repertoire</a>.
</p>
<p>Gene usage:
</p>
<p>- Gene usage statistics (from <a href="#topic+geneUsage">geneUsage</a>) using bar plots, box plots - see <a href="#topic+vis.immunr_gene_usage">vis.immunr_gene_usage</a>;
</p>
<p>- Gene usage distances (from <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>) using heatmaps, circos plots, polar area plots - see <a href="#topic+vis.immunr_ov_matrix">vis.immunr_ov_matrix</a>;
</p>
<p>- Gene usage clustering (from <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>) - see <a href="#topic+vis.immunr_hclust">vis.immunr_hclust</a>.
</p>
<p>Diversity estimation:
</p>
<p>- Diversity estimations (from <a href="#topic+repDiversity">repDiversity</a>) - see <a href="#topic+vis.immunr_chao1">vis.immunr_chao1</a>.
</p>
<p>BCR analysis:
</p>
<p>- Clonal tree (from <a href="#topic+repClonalFamily">repClonalFamily</a>) - see <a href="#topic+vis.clonal_family">vis.clonal_family</a> and <a href="#topic+vis.clonal_family_tree">vis.clonal_family_tree</a>.
</p>
<p>Advanced analysis:
</p>
<p>- Repertoire dynamics (from <a href="#topic+trackClonotypes">trackClonotypes</a>) - see <a href="#topic+vis.immunr_dynamics">vis.immunr_dynamics</a>;
</p>
<p>- Sequence logo plots of amino acid distributions (from <a href="#topic+kmer_profile">kmer_profile</a>) - see <a href="#topic+vis_seqlogo">vis_seqlogo</a>;
</p>
<p>- Kmers distributions (from <a href="#topic+getKmers">getKmers</a>) - see <a href="#topic+vis.immunr_kmer_table">vis.immunr_kmer_table</a>;
</p>
<p>- Mutation networks (from mutationNetwork) - Work In Progress on vis.immunr_mutation_network;
</p>
<p>- CDR3 amino acid properties, e.g., biophysical (from cdrProp) - Work In Progress on vis.immunr_cdr_prop.
</p>
<p>Additionaly, we provide a wrapper functions for visualisations of common data types:
</p>
<p>- Any data frames or matrices using heatmaps - see <a href="#topic+vis_heatmap">vis_heatmap</a> and <a href="#topic+vis_heatmap2">vis_heatmap2</a>;
</p>
<p>- Any data frames or matrices using circos plots - see <a href="#topic+vis_circos">vis_circos</a>.
</p>


<h3>Value</h3>

<p>A ggplot2, pheatmap or circlize object.
</p>


<h3>See Also</h3>

<p><a href="#topic+fixVis">fixVis</a> for precise manipulation of plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the test data
data(immdata)

# Compute and visualise:
ov &lt;- repOverlap(immdata$data)
vis(ov)

gu &lt;- geneUsage(immdata$data)
vis(gu)

dv &lt;- repDiversity(immdata$data)
vis(dv)
</code></pre>

<hr>
<h2 id='vis_bar'>Bar plots</h2><span id='topic+vis_bar'></span>

<h3>Description</h3>

<p>Bar plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_bar(
  .data,
  .by = NA,
  .meta = NA,
  .errorbars = c(0.025, 0.975),
  .errorbars.off = FALSE,
  .stack = FALSE,
  .points = TRUE,
  .test = TRUE,
  .signif.label.size = 3.5,
  .errorbar.width = 0.2,
  .defgroupby = "Sample",
  .grouping.var = "Group",
  .labs = c("X", "Y"),
  .title = "Barplot (.title argument)",
  .subtitle = "Subtitle (.subtitle argument)",
  .legend = NA,
  .leg.title = "Legend (.leg.title argument)",
  .legend.pos = "right",
  .rotate_x = 90
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_bar_+3A_.data">.data</code></td>
<td>
<p>Data to visualise.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.errorbars">.errorbars</code></td>
<td>
<p>A numeric vector of length two with quantiles for error bars
on sectors. Disabled if &quot;.errorbars.off&quot; is TRUE.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.errorbars.off">.errorbars.off</code></td>
<td>
<p>If TRUE then plot CI bars for distances between each group.
Disabled if no group passed to the &quot;.by&quot; argument.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.stack">.stack</code></td>
<td>
<p>If TRUE and .errorbars.off is TRUE then plot stacked bar plots for each Group or Sample</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.signif.label.size">.signif.label.size</code></td>
<td>
<p>An integer value defining the size of text for p-value.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.errorbar.width">.errorbar.width</code></td>
<td>
<p>Numeric. Width for error bars.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.defgroupby">.defgroupby</code></td>
<td>
<p>A name for the column with sample names.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.grouping.var">.grouping.var</code></td>
<td>
<p>A name for the column to group by.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.labs">.labs</code></td>
<td>
<p>A character vector of length two specifying names for x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.title">.title</code></td>
<td>
<p>The text for the plot's title.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.subtitle">.subtitle</code></td>
<td>
<p>The text for the plot's subtitle.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.legend">.legend</code></td>
<td>
<p>If TRUE then displays a legend, otherwise removes legend from the plot.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.leg.title">.leg.title</code></td>
<td>
<p>The text for the plots's legend. Provide NULL to remove the legend's title completely.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.legend.pos">.legend.pos</code></td>
<td>
<p>Positions of the legend: either &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot; or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="vis_bar_+3A_.rotate_x">.rotate_x</code></td>
<td>
<p>How much the x tick text should be rotated? In angles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vis_bar(data.frame(Sample = c("A", "B", "C"), Value = c(1, 2, 3)))
</code></pre>

<hr>
<h2 id='vis_box'>Flexible box-plots for visualisation of distributions</h2><span id='topic+vis_box'></span>

<h3>Description</h3>

<p>Visualisation of distributions using ggplot2-based boxplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_box(
  .data,
  .by = NA,
  .meta = NA,
  .melt = TRUE,
  .points = TRUE,
  .test = TRUE,
  .signif.label.size = 3.5,
  .defgroupby = "Sample",
  .grouping.var = "Group",
  .labs = c("X", "Y"),
  .title = "Boxplot (.title argument)",
  .subtitle = "Subtitle (.subtitle argument)",
  .legend = NA,
  .leg.title = "Legend (.leg.title argument)",
  .legend.pos = "right"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_box_+3A_.data">.data</code></td>
<td>
<p>Input matrix or data frame.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.melt">.melt</code></td>
<td>
<p>If TRUE then apply <a href="data.table.html#topic+melt">melt</a> to the &quot;.data&quot; before plotting.
In this case &quot;.data&quot; is supposed to be a data frame with the first character column reserved
for names of genes and other numeric columns reserved to counts or frequencies of genes.
Each numeric column should be associated with a specific repertoire sample.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.signif.label.size">.signif.label.size</code></td>
<td>
<p>An integer value defining the size of text for p-value.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.defgroupby">.defgroupby</code></td>
<td>
<p>A name for the column with sample names.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.grouping.var">.grouping.var</code></td>
<td>
<p>A name for the column to group by.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.labs">.labs</code></td>
<td>
<p>Character vector of length two with names for x-axis and y-axis, respectively.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.title">.title</code></td>
<td>
<p>The text for the title of the plot.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.subtitle">.subtitle</code></td>
<td>
<p>The The text for the plot's subtitle.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.legend">.legend</code></td>
<td>
<p>If TRUE then displays a legend, otherwise removes legend from the plot.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.leg.title">.leg.title</code></td>
<td>
<p>The The text for the plots's legend. Provide NULL to remove the legend's title completely.</p>
</td></tr>
<tr><td><code id="vis_box_+3A_.legend.pos">.legend.pos</code></td>
<td>
<p>Positions of the legend: either &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot; or &quot;right&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis.immunr_gene_usage">vis.immunr_gene_usage</a>, <a href="#topic+geneUsage">geneUsage</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vis_box(data.frame(Sample = sample(c("A", "B", "C"), 100, TRUE), Value = rnorm(100)), .melt = FALSE)
</code></pre>

<hr>
<h2 id='vis_circos'>Visualisation of matrices using circos plots</h2><span id='topic+vis_circos'></span>

<h3>Description</h3>

<p>Visualise matrices with the <a href="circlize.html#topic+chordDiagram">chordDiagram</a> function
from the circlize package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_circos(.data, .title = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_circos_+3A_.data">.data</code></td>
<td>
<p>Input matrix.</p>
</td></tr>
<tr><td><code id="vis_circos_+3A_.title">.title</code></td>
<td>
<p>The The text for the title of the plot.</p>
</td></tr>
<tr><td><code id="vis_circos_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="circlize.html#topic+chordDiagram">chordDiagram</a> from the 'circlize' package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A circlize object.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis">vis</a>, <a href="#topic+repOverlap">repOverlap</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
vis(ov, .plot = "circos")
</code></pre>

<hr>
<h2 id='vis_heatmap'>Visualisation of matrices and data frames using ggplo2-based heatmaps</h2><span id='topic+vis_heatmap'></span>

<h3>Description</h3>

<p>Fast and easy visualisations of matrices or data frames
with functions based on the ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_heatmap(
  .data,
  .text = TRUE,
  .scientific = FALSE,
  .signif.digits = 2,
  .text.size = 4,
  .axis.text.size = NULL,
  .labs = c("Sample", "Sample"),
  .title = "Overlap",
  .leg.title = "Overlap values",
  .legend = TRUE,
  .na.value = NA,
  .transpose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_heatmap_+3A_.data">.data</code></td>
<td>
<p>Input object: a matrix or a data frame.
</p>
<p>If matrix: column names and row names (if presented) will be used as names for labs.
</p>
<p>If data frame: the first column will be used for row names and removed from the data.
Other columns will be used for values in the heatmap.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.text">.text</code></td>
<td>
<p>If TRUE then plots values in the heatmap cells. If FALSE does not plot values,
just plot coloured cells instead.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.scientific">.scientific</code></td>
<td>
<p>If TRUE then uses the scientific notation for numbers (e.g., &quot;2.0e+2&quot;).</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.signif.digits">.signif.digits</code></td>
<td>
<p>Number of significant digits to display on plot.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.text.size">.text.size</code></td>
<td>
<p>Size of text in the cells of heatmap.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.axis.text.size">.axis.text.size</code></td>
<td>
<p>Size of text on the axis labels.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.labs">.labs</code></td>
<td>
<p>A character vector of length two with names for x-axis and y-axis, respectively.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.title">.title</code></td>
<td>
<p>The The text for the plot's title.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.leg.title">.leg.title</code></td>
<td>
<p>The The text for the plots's legend. Provide NULL to remove the legend's title completely.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.legend">.legend</code></td>
<td>
<p>If TRUE then displays a legend, otherwise removes the legend from the plot.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.na.value">.na.value</code></td>
<td>
<p>Replace NA values with this value. By default they remain NA.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_.transpose">.transpose</code></td>
<td>
<p>Logical. If TRUE then switch rows and columns.</p>
</td></tr>
<tr><td><code id="vis_heatmap_+3A_...">...</code></td>
<td>
<p>Other passed arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis">vis</a>, <a href="#topic+repOverlap">repOverlap</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
vis_heatmap(ov)
gu &lt;- geneUsage(immdata$data, "hs.trbj")
vis_heatmap(gu)
</code></pre>

<hr>
<h2 id='vis_heatmap2'>Visualisation of matrices using pheatmap-based heatmaps</h2><span id='topic+vis_heatmap2'></span>

<h3>Description</h3>

<p>Visualise matrices with the functions based on the <a href="pheatmap.html#topic+pheatmap">pheatmap</a>
package with minimum amount of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_heatmap2(
  .data,
  .meta = NA,
  .by = NA,
  .title = NA,
  .color = colorRampPalette(c("#67001f", "#d6604d", "#f7f7f7", "#4393c3",
    "#053061"))(1024),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_heatmap2_+3A_.data">.data</code></td>
<td>
<p>Input matrix. Column names and row names (if presented) will be used as names for labs.</p>
</td></tr>
<tr><td><code id="vis_heatmap2_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis_heatmap2_+3A_.by">.by</code></td>
<td>
<p>Set NA if you want to plot samples without grouping.</p>
</td></tr>
<tr><td><code id="vis_heatmap2_+3A_.title">.title</code></td>
<td>
<p>The text for the plot's title (same as the &quot;main&quot; argument in <a href="pheatmap.html#topic+pheatmap">pheatmap</a>).</p>
</td></tr>
<tr><td><code id="vis_heatmap2_+3A_.color">.color</code></td>
<td>
<p>A vector specifying the colors (same as the &quot;color&quot; argument in <a href="pheatmap.html#topic+pheatmap">pheatmap</a>).
Pass NA to use the default pheatmap colors.</p>
</td></tr>
<tr><td><code id="vis_heatmap2_+3A_...">...</code></td>
<td>
<p>Other arguments for the <a href="pheatmap.html#topic+pheatmap">pheatmap</a> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pheatmap object.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis">vis</a>, <a href="#topic+repOverlap">repOverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
vis_heatmap2(ov)
</code></pre>

<hr>
<h2 id='vis_hist'>Visualisation of distributions using histograms</h2><span id='topic+vis_hist'></span>

<h3>Description</h3>

<p>Visualisation of distributions using ggplot2-based histograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_hist(
  .data,
  .by = NA,
  .meta = NA,
  .title = "Gene usage",
  .ncol = NA,
  .points = TRUE,
  .test = TRUE,
  .coord.flip = FALSE,
  .grid = FALSE,
  .labs = c("Gene", NA),
  .melt = TRUE,
  .legend = NA,
  .add.layer = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_hist_+3A_.data">.data</code></td>
<td>
<p>Input matrix or data frame.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.title">.title</code></td>
<td>
<p>The text for the title of the plot.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.ncol">.ncol</code></td>
<td>
<p>A number of columns to display. Provide NA (by default) if you want the function
to automatically detect the optimal number of columns.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.coord.flip">.coord.flip</code></td>
<td>
<p>If TRUE then swap x- and y-axes.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.grid">.grid</code></td>
<td>
<p>If TRUE then plot separate visualisations for each sample.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.labs">.labs</code></td>
<td>
<p>A character vector of length two with names for x-axis and y-axis, respectively.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.melt">.melt</code></td>
<td>
<p>If TRUE then apply <a href="data.table.html#topic+melt">melt</a> to the &quot;.data&quot; before plotting.
In this case &quot;.data&quot; is supposed to be a data frame with the first character column reserved
for names of genes and other numeric columns reserved to counts or frequencies of genes.
Each numeric column should be associated with a specific repertoire sample.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.legend">.legend</code></td>
<td>
<p>If TRUE then plots the legend. If FALSE removes the legend from the plot.
If NA automatically detects the best way to display legend.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_.add.layer">.add.layer</code></td>
<td>
<p>Addditional ggplot2 layers, that added to each plot in the output plot or grid of plots.</p>
</td></tr>
<tr><td><code id="vis_hist_+3A_...">...</code></td>
<td>
<p>Is not used here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is grouped, then statistical tests for comparing means of groups will be performed, unless <code>.test = FALSE</code> is supplied.
In case there are only two groups, the Wilcoxon rank sum test (https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test) is performed
(R function <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> with an argument <code>exact = FALSE</code>) for testing if there is a difference in mean rank values between two groups.
In case there more than two groups, the Kruskal-Wallis test (https://en.wikipedia.org/wiki/Kruskal
A significant Kruskal-Wallis test indicates that at least one sample stochastically dominates one other sample.
Adjusted for multiple comparisons P-values are plotted on the top of groups.
P-value adjusting is done using the Holm method (https://en.wikipedia.org/wiki/Holm
You can execute the command <code>?p.adjust</code> in the R console to see more.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis.immunr_gene_usage">vis.immunr_gene_usage</a>, <a href="#topic+geneUsage">geneUsage</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
imm_gu &lt;- geneUsage(immdata$data[[1]])
vis(imm_gu,
  .plot = "hist", .add.layer =
    theme(axis.text.x = element_text(angle = 75, vjust = 1))
)
imm_gu &lt;- geneUsage(immdata$data[1:4])
vis(imm_gu,
  .plot = "hist", .grid = TRUE, .add.layer =
    theme(axis.text.x = element_text(angle = 75, vjust = 1))
)
</code></pre>

<hr>
<h2 id='vis_immunr_kmer_profile_main'>Visualise kmer profiles</h2><span id='topic+vis_immunr_kmer_profile_main'></span>

<h3>Description</h3>

<p>Visualise kmer profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_immunr_kmer_profile_main(.data, .plot, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_immunr_kmer_profile_main_+3A_.data">.data</code></td>
<td>
<p>Kmer data, an output from <a href="#topic+kmer_profile">kmer_profile</a>.</p>
</td></tr>
<tr><td><code id="vis_immunr_kmer_profile_main_+3A_.plot">.plot</code></td>
<td>
<p>String specifying the plot type:
</p>
<p>- &quot;seqlogo&quot; for traditional sequence logo plots using <a href="#topic+vis_seqlogo">vis_seqlogo</a>;
</p>
<p>- &quot;textlogo&quot; for modified approach to sequence logo plots via text labels using <a href="#topic+vis_textlogo">vis_textlogo</a>;</p>
</td></tr>
<tr><td><code id="vis_immunr_kmer_profile_main_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <a href="#topic+vis_textlogo">vis_textlogo</a> or <a href="#topic+vis_seqlogo">vis_seqlogo</a>, depending
on the &quot;.plot&quot; argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
getKmers(immdata$data[[1]], 5) %&gt;%
  kmer_profile() %&gt;%
  vis("seqlogo")
</code></pre>

<hr>
<h2 id='vis_public_clonotypes'>Visualisation of public clonotypes</h2><span id='topic+vis_public_clonotypes'></span>

<h3>Description</h3>

<p>Visualise correlation of public clonotype frequencies in pairs of repertoires.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_public_clonotypes(
  .data,
  .x.rep = NA,
  .y.rep = NA,
  .title = NA,
  .ncol = 3,
  .point.size.modif = 1,
  .cut.axes = TRUE,
  .density = TRUE,
  .lm = TRUE,
  .radj.size = 3.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_public_clonotypes_+3A_.data">.data</code></td>
<td>
<p>Public repertoire data - an output from the <a href="#topic+pubRep">pubRep</a> function.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.x.rep">.x.rep</code></td>
<td>
<p>Either indices of samples or character vector of sample names
for the x-axis. Must be of the same length as &quot;.y.rep&quot;.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.y.rep">.y.rep</code></td>
<td>
<p>Either indices of samples or character vector of sample names
for the y-axis. Must be of the same length as &quot;.x.rep&quot;.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.title">.title</code></td>
<td>
<p>The text for the title of the plot.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.ncol">.ncol</code></td>
<td>
<p>An integer number of columns to print in the grid of pairs of repertoires.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.point.size.modif">.point.size.modif</code></td>
<td>
<p>An integer value that is a modifier of the point size.
The larger the number, the larger the points.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.cut.axes">.cut.axes</code></td>
<td>
<p>If TRUE then axes limits become shorter.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.density">.density</code></td>
<td>
<p>If TRUE then displays density plot for distributions of clonotypes
for each sample. If FALSE then removes density plot from the visualisation.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.lm">.lm</code></td>
<td>
<p>If TRUE then fit a linear model and displays an R adjusted coefficient
that shows how similar samples are in terms of shared clonotypes.</p>
</td></tr>
<tr><td><code id="vis_public_clonotypes_+3A_.radj.size">.radj.size</code></td>
<td>
<p>An integer value, that defines the size of the The text
for the R adjusted coefficient.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+pubRep">pubRep</a>, <a href="#topic+vis.immunr_public_repertoire">vis.immunr_public_repertoire</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
vis(pr, "clonotypes", 1, 2)
</code></pre>

<hr>
<h2 id='vis_public_frequencies'>Public repertoire visualisation</h2><span id='topic+vis_public_frequencies'></span>

<h3>Description</h3>

<p>Visualise public clonotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_public_frequencies(
  .data,
  .by = NA,
  .meta = NA,
  .type = c("boxplot", "none", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_public_frequencies_+3A_.data">.data</code></td>
<td>
<p>Public repertoire - an output from the <a href="#topic+pubRep">pubRep</a> function.</p>
</td></tr>
<tr><td><code id="vis_public_frequencies_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis_public_frequencies_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis_public_frequencies_+3A_.type">.type</code></td>
<td>
<p>Character. Either &quot;boxplot&quot; for plotting distributions of frequencies,
&quot;none&quot; for plotting everything, or &quot;mean&quot; for plotting average values only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 500)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
vis(pr, "freq", .type = "boxplot")
vis(pr, "freq", .type = "none")
vis(pr, "freq", .type = "mean")
vis(pr, "freq", .by = "Status", .meta = immdata$meta)
</code></pre>

<hr>
<h2 id='vis_textlogo'>Sequence logo plots for amino acid profiles.</h2><span id='topic+vis_textlogo'></span><span id='topic+vis_seqlogo'></span>

<h3>Description</h3>

<p>Plot sequence logo plots for visualising of amino acid motif sequences / profiles.
</p>
<p>'vis_textlogo' plots sequences in a text format - each letter has the same height. Useful when there
are no big differences between occurences of amino acids in the motif.
</p>
<p>'vis_seqlogo' is a traditional sequence logo plots. Useful when there are one or two amino acids
with clear differences in their occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_textlogo(.data, .replace.zero.with.na = TRUE, .width = 0.1, ...)

vis_seqlogo(.data, .scheme = "chemistry", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis_textlogo_+3A_.data">.data</code></td>
<td>
<p>Output from the <code>kmer.profile</code> function.</p>
</td></tr>
<tr><td><code id="vis_textlogo_+3A_.replace.zero.with.na">.replace.zero.with.na</code></td>
<td>
<p>if TRUE then replace all zeros with NAs, therefore letters with
zero frequency wont appear at the plot.</p>
</td></tr>
<tr><td><code id="vis_textlogo_+3A_.width">.width</code></td>
<td>
<p>Width for jitter, i.e., how much points will scatter around the verical line. Pass 0 (zero)
to plot points on the straight vertical line for each position.</p>
</td></tr>
<tr><td><code id="vis_textlogo_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
<tr><td><code id="vis_textlogo_+3A_.scheme">.scheme</code></td>
<td>
<p>Character. An argumentt passed to <a href="ggseqlogo.html#topic+geom_logo">geom_logo</a> specifying how to colour symbols.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+getKmers">getKmers</a>, <a href="#topic+kmer_profile">kmer_profile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
kmers &lt;- getKmers(immdata$data[[1]], 5)
ppm &lt;- kmer_profile(kmers, "prob")
vis(ppm, .plot = "text")
vis(ppm, .plot = "seq")

d &lt;- kmer_profile(c("CASLL", "CASSQ", "CASGL"))
vis_textlogo(d)
vis_seqlogo(d)
</code></pre>

<hr>
<h2 id='vis.clonal_family'>Visualise clonal family tree: wrapper for calling on the entire repClonalFamily output</h2><span id='topic+vis.clonal_family'></span>

<h3>Description</h3>

<p>Visualise clonal family tree: wrapper for calling on the entire repClonalFamily output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clonal_family'
vis(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.clonal_family_+3A_.data">.data</code></td>
<td>
<p>Clonal families from 1 or multiple samples: <code><a href="#topic+repClonalFamily">repClonalFamily</a></code> output.</p>
</td></tr>
<tr><td><code id="vis.clonal_family_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggraph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcrdata)
bcr_data &lt;- bcrdata$data

clonal_family &lt;- bcr_data %&gt;%
  seqCluster(seqDist(bcr_data), .fixed_threshold = 3) %&gt;%
  repGermline(.threads = 1) %&gt;%
  repAlignLineage(.min_lineage_sequences = 2, .align_threads = 2, .nofail = TRUE) %&gt;%
  repClonalFamily(.threads = 1, .nofail = TRUE) %&gt;%
  vis()
</code></pre>

<hr>
<h2 id='vis.clonal_family_tree'>Visualise clonal family tree</h2><span id='topic+vis.clonal_family_tree'></span>

<h3>Description</h3>

<p>Visualise clonal family tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clonal_family_tree'
vis(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.clonal_family_tree_+3A_.data">.data</code></td>
<td>
<p>Single clonal family tree data from 1 cluster: 1 element from TreeStats column from <code><a href="#topic+repClonalFamily">repClonalFamily</a></code> output.</p>
</td></tr>
<tr><td><code id="vis.clonal_family_tree_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggraph object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bcrdata)
bcr_data &lt;- bcrdata$data

clonal_family &lt;- bcr_data %&gt;%
  seqCluster(seqDist(bcr_data), .fixed_threshold = 3) %&gt;%
  repGermline(.threads = 1) %&gt;%
  repAlignLineage(.min_lineage_sequences = 2, .align_threads = 2, .nofail = TRUE) %&gt;%
  repClonalFamily(.threads = 1, .nofail = TRUE)

# This condition can be omitted; it prevents the example from crashing
# when ClustalW or PHYLIP are not installed
if (!("step_failure_ignored" %in% class(clonal_family))) {
  vis(clonal_family[["full_clones"]][["TreeStats"]][[2]])
}
</code></pre>

<hr>
<h2 id='vis.immunr_chao1'>Visualise diversity.</h2><span id='topic+vis.immunr_chao1'></span><span id='topic+vis.immunr_dxx'></span><span id='topic+vis.immunr_rarefaction'></span><span id='topic+vis.immunr_div'></span><span id='topic+vis.immunr_ginisimp'></span><span id='topic+vis.immunr_invsimp'></span><span id='topic+vis.immunr_hill'></span>

<h3>Description</h3>

<p>An utility function to visualise the output from <code><a href="#topic+repDiversity">repDiversity</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_chao1'
vis(
  .data,
  .by = NA,
  .meta = NA,
  .errorbars = c(0.025, 0.975),
  .errorbars.off = FALSE,
  .points = TRUE,
  .test = TRUE,
  .signif.label.size = 3.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_chao1_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+repDiversity">repDiversity</a></code>.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.errorbars">.errorbars</code></td>
<td>
<p>A numeric vector of length two with quantiles for error bars
on sectors. Disabled if &quot;.errorbars.off&quot; is TRUE.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.errorbars.off">.errorbars.off</code></td>
<td>
<p>If TRUE then plot CI bars for distances between each group.
Disabled if no group passed to the &quot;.by&quot; argument.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_.signif.label.size">.signif.label.size</code></td>
<td>
<p>An integer value defining the size of text for p-value.</p>
</td></tr>
<tr><td><code id="vis.immunr_chao1_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is grouped, then statistical tests for comparing means of groups will be performed, unless <code>.test = FALSE</code> is supplied.
In case there are only two groups, the Wilcoxon rank sum test (https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test) is performed
(R function <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> with an argument <code>exact = FALSE</code>) for testing if there is a difference in mean rank values between two groups.
In case there more than two groups, the Kruskal-Wallis test (https://en.wikipedia.org/wiki/Kruskal
A significant Kruskal-Wallis test indicates that at least one sample stochastically dominates one other sample.
Adjusted for multiple comparisons P-values are plotted on the top of groups.
P-value adjusting is done using the Holm method (https://en.wikipedia.org/wiki/Holm
You can execute the command <code>?p.adjust</code> in the R console to see more.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+repDiversity">repDiversity</a> <a href="#topic+vis">vis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
dv &lt;- repDiversity(immdata$data, "chao1")
vis(dv)
</code></pre>

<hr>
<h2 id='vis.immunr_clonal_prop'>Visualise results of the clonality analysis</h2><span id='topic+vis.immunr_clonal_prop'></span><span id='topic+vis.immunr_homeo'></span><span id='topic+vis.immunr_top_prop'></span><span id='topic+vis.immunr_tail_prop'></span>

<h3>Description</h3>

<p>An utility function to visualise the output from <code><a href="#topic+repClonality">repClonality</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_clonal_prop'
vis(
  .data,
  .by = NA,
  .meta = NA,
  .errorbars = c(0.025, 0.975),
  .errorbars.off = FALSE,
  .points = TRUE,
  .test = TRUE,
  .signif.label.size = 3.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_clonal_prop_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+repClonality">repClonality</a></code>.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.errorbars">.errorbars</code></td>
<td>
<p>A numeric vector of length two with quantiles for error bars
on sectors. Disabled if &quot;.errorbars.off&quot; is TRUE.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.errorbars.off">.errorbars.off</code></td>
<td>
<p>If TRUE then plot CI bars for distances between each group.
Disabled if no group passed to the &quot;.by&quot; argument.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_.signif.label.size">.signif.label.size</code></td>
<td>
<p>An integer value defining the size of text for p-value.</p>
</td></tr>
<tr><td><code id="vis.immunr_clonal_prop_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is grouped, then statistical tests for comparing means of groups will be performed, unless <code>.test = FALSE</code> is supplied.
In case there are only two groups, the Wilcoxon rank sum test (https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test) is performed
(R function <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> with an argument <code>exact = FALSE</code>) for testing if there is a difference in mean rank values between two groups.
In case there more than two groups, the Kruskal-Wallis test (https://en.wikipedia.org/wiki/Kruskal
A significant Kruskal-Wallis test indicates that at least one sample stochastically dominates one other sample.
Adjusted for multiple comparisons P-values are plotted on the top of groups.
P-value adjusting is done using the Holm method (https://en.wikipedia.org/wiki/Holm
You can execute the command <code>?p.adjust</code> in the R console to see more.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+repClonality">repClonality</a> <a href="#topic+vis">vis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
clp &lt;- repClonality(immdata$data, "clonal.prop")
vis(clp)

hom &lt;- repClonality(immdata$data, "homeo")
# Remove p values and points from the plot
vis(hom, .by = "Status", .meta = immdata$meta, .test = FALSE, .points = FALSE)
</code></pre>

<hr>
<h2 id='vis.immunr_dynamics'>Visualise clonotype dynamics</h2><span id='topic+vis.immunr_dynamics'></span>

<h3>Description</h3>

<p>Visualise clonotype dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_dynamics'
vis(.data, .plot = c("smooth", "area", "line"), .order = NA, .log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_dynamics_+3A_.data">.data</code></td>
<td>
<p>Output from the <a href="#topic+trackClonotypes">trackClonotypes</a> function.</p>
</td></tr>
<tr><td><code id="vis.immunr_dynamics_+3A_.plot">.plot</code></td>
<td>
<p>Character. Either &quot;smooth&quot;, &quot;area&quot; or &quot;line&quot;. Each specifies a type of plot for visualisation of clonotype dynamics.</p>
</td></tr>
<tr><td><code id="vis.immunr_dynamics_+3A_.order">.order</code></td>
<td>
<p>Numeric or character vector. Specifies the order to samples, e.g., it used for ordering samples
by timepoints. Either See &quot;Examples&quot; below for more details.</p>
</td></tr>
<tr><td><code id="vis.immunr_dynamics_+3A_.log">.log</code></td>
<td>
<p>Logical. If TRUE then use log-scale for the frequency axis.</p>
</td></tr>
<tr><td><code id="vis.immunr_dynamics_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load an example data that comes with immunarch
data(immdata)

# Make the data smaller in order to speed up the examples
immdata$data &lt;- immdata$data[c(1, 2, 3, 7, 8, 9)]
immdata$meta &lt;- immdata$meta[c(1, 2, 3, 7, 8, 9), ]

# Option 1
# Choose the first 10 amino acid clonotype sequences
# from the first repertoire to track
tc &lt;- trackClonotypes(immdata$data, list(1, 10), .col = "aa")
# Choose the first 20 nucleotide clonotype sequences
# and their V genes from the "MS1" repertoire to track
tc &lt;- trackClonotypes(immdata$data, list("MS1", 20), .col = "nt+v")

# Option 2
# Choose clonotypes with amino acid sequences "CASRGLITDTQYF" or "CSASRGSPNEQYF"
tc &lt;- trackClonotypes(immdata$data, c("CASRGLITDTQYF", "CSASRGSPNEQYF"), .col = "aa")

# Option 3
# Choose the first 10 clonotypes from the first repertoire
# with amino acid sequences and V segments
target &lt;- immdata$data[[1]] %&gt;%
  select(CDR3.aa, V.name) %&gt;%
  head(10)
tc &lt;- trackClonotypes(immdata$data, target)

# Visualise the output regardless of the chosen option
# Therea are three way to visualise it, regulated by the .plot argument
vis(tc, .plot = "smooth")
vis(tc, .plot = "area")
vis(tc, .plot = "line")

# Visualising timepoints
# First, we create an additional column in the metadata with randomly choosen timepoints:
immdata$meta$Timepoint &lt;- sample(1:length(immdata$data))
immdata$meta
# Next, we create a vector with samples in the right order,
# according to the "Timepoint" column (from smallest to greatest):
sample_order &lt;- order(immdata$meta$Timepoint)
# Sanity check: timepoints are following the right order:
immdata$meta$Timepoint[sample_order]
# Samples, sorted by the timepoints:
immdata$meta$Sample[sample_order]
# And finally, we visualise the data:
vis(tc, .order = sample_order)
</code></pre>

<hr>
<h2 id='vis.immunr_exp_vol'>Visualise results of the exploratory analysis</h2><span id='topic+vis.immunr_exp_vol'></span><span id='topic+vis.immunr_exp_count'></span><span id='topic+vis.immunr_exp_len'></span><span id='topic+vis.immunr_exp_clones'></span>

<h3>Description</h3>

<p>An utility function to visualise the output from <code><a href="#topic+repExplore">repExplore</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_exp_vol'
vis(
  .data,
  .by = NA,
  .meta = NA,
  .errorbars = c(0.025, 0.975),
  .errorbars.off = FALSE,
  .points = TRUE,
  .test = TRUE,
  .signif.label.size = 3.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_exp_vol_+3A_.data">.data</code></td>
<td>
<p>Output from <code><a href="#topic+repExplore">repExplore</a></code>.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.errorbars">.errorbars</code></td>
<td>
<p>A numeric vector of length two with quantiles for error bars
on sectors. Disabled if &quot;.errorbars.off&quot; is TRUE.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.errorbars.off">.errorbars.off</code></td>
<td>
<p>If TRUE then plot CI bars for distances between each group.
Disabled if no group passed to the &quot;.by&quot; argument.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.points">.points</code></td>
<td>
<p>A logical value defining whether points will be visualised or not.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.test">.test</code></td>
<td>
<p>A logical vector whether statistical tests should be applied. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_.signif.label.size">.signif.label.size</code></td>
<td>
<p>An integer value defining the size of text for p-value.</p>
</td></tr>
<tr><td><code id="vis.immunr_exp_vol_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is grouped, then statistical tests for comparing means of groups will be performed, unless <code>.test = FALSE</code> is supplied.
In case there are only two groups, the Wilcoxon rank sum test (https://en.wikipedia.org/wiki/Wilcoxon_signed-rank_test) is performed
(R function <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> with an argument <code>exact = FALSE</code>) for testing if there is a difference in mean rank values between two groups.
In case there more than two groups, the Kruskal-Wallis test (https://en.wikipedia.org/wiki/Kruskal
A significant Kruskal-Wallis test indicates that at least one sample stochastically dominates one other sample.
Adjusted for multiple comparisons P-values are plotted on the top of groups.
P-value adjusting is done using the Holm method (https://en.wikipedia.org/wiki/Holm
You can execute the command <code>?p.adjust</code> in the R console to see more.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+repExplore">repExplore</a> <a href="#topic+vis">vis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
repExplore(immdata$data, "volume") %&gt;% vis()
repExplore(immdata$data, "count") %&gt;% vis()
repExplore(immdata$data, "len") %&gt;% vis()
repExplore(immdata$data, "clones") %&gt;% vis()
</code></pre>

<hr>
<h2 id='vis.immunr_gene_usage'>Histograms and boxplots (general case / gene usage)</h2><span id='topic+vis.immunr_gene_usage'></span>

<h3>Description</h3>

<p>Visualise distributions of genes using heatmaps or other plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_gene_usage'
vis(.data, .plot = c("hist", "box", "heatmap", "heatmap2", "circos"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_gene_usage_+3A_.data">.data</code></td>
<td>
<p>Output from the <a href="#topic+geneUsage">geneUsage</a> function.</p>
</td></tr>
<tr><td><code id="vis.immunr_gene_usage_+3A_.plot">.plot</code></td>
<td>
<p>String specifying the plot type:
</p>
<p>- &quot;hist&quot; for histograms using <a href="#topic+vis_hist">vis_hist</a>;
</p>
<p>- &quot;heatmap&quot; for heatmaps using <a href="#topic+vis_heatmap">vis_heatmap</a>;
</p>
<p>- &quot;heatmap2&quot; for heatmaps using <a href="#topic+vis_heatmap2">vis_heatmap2</a>;
</p>
<p>- &quot;circos&quot; for circos plots using <a href="#topic+vis_circos">vis_circos</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_gene_usage_+3A_...">...</code></td>
<td>
<p>Other arguments passed to corresponding functions depending on the plot type:
</p>
<p>- &quot;hist&quot; - passes arguments to <a href="#topic+vis_hist">vis_hist</a>;
</p>
<p>- &quot;box&quot; - passes arguments to <a href="#topic+vis_box">vis_box</a>;
</p>
<p>- &quot;heatmap&quot; - passes arguments to <a href="#topic+vis_heatmap">vis_heatmap</a>;
</p>
<p>- &quot;heatmap2&quot; - passes arguments to <a href="#topic+vis_heatmap2">vis_heatmap2</a> and <a href="stats.html#topic+heatmap">heatmap</a> from the &quot;pheatmap&quot; package;
</p>
<p>- &quot;circos&quot; - passes arguments to <a href="#topic+vis_circos">vis_circos</a> and <a href="circlize.html#topic+chordDiagram">chordDiagram</a> from the &quot;circlize&quot; package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object, pheatmap or circlize object.
</p>


<h3>See Also</h3>

<p><a href="#topic+geneUsage">geneUsage</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)

gu &lt;- geneUsage(immdata$data[[1]])
vis(gu)

gu &lt;- geneUsage(immdata$data)
vis(gu, .by = "Status", .meta = immdata$meta)
vis(gu, "box", .by = "Status", .meta = immdata$meta)
</code></pre>

<hr>
<h2 id='vis.immunr_hclust'>Visualisation of hierarchical clustering</h2><span id='topic+vis.immunr_hclust'></span>

<h3>Description</h3>

<p>Visualisation of the results of hierarchical clustering.
For other clustering visualisations see <a href="#topic+vis.immunr_kmeans">vis.immunr_kmeans</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_hclust'
vis(.data, .rect = FALSE, .plot = c("clust", "best"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_hclust_+3A_.data">.data</code></td>
<td>
<p>Clustering results from <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a> or <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_hclust_+3A_.rect">.rect</code></td>
<td>
<p>Passed to <a href="factoextra.html#topic+fviz_dend">fviz_dend</a> - whether to add a rectangle around groups.</p>
</td></tr>
<tr><td><code id="vis.immunr_hclust_+3A_.plot">.plot</code></td>
<td>
<p>A character vector of length one or two specifying which plots to visualise.
If &quot;clust&quot; then plot only the clustering. If &quot;best&quot; then plot the number of optimal clusters.
If both then plot both.</p>
</td></tr>
<tr><td><code id="vis.immunr_hclust_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ggplot2 objects inside the patchwork container.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis">vis</a>, <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a>, <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
repOverlapAnalysis(ov, "mds+hclust") %&gt;% vis()
</code></pre>

<hr>
<h2 id='vis.immunr_inc_overlap'>Visualise incremental overlaps</h2><span id='topic+vis.immunr_inc_overlap'></span>

<h3>Description</h3>

<p>Visualise incremental overlaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_inc_overlap'
vis(.data, .target = 1, .grid = FALSE, .ncol = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_inc_overlap_+3A_.data">.data</code></td>
<td>
<p>Output from the <a href="#topic+repOverlap">repOverlap</a> function that uses &quot;top&quot; methods.</p>
</td></tr>
<tr><td><code id="vis.immunr_inc_overlap_+3A_.target">.target</code></td>
<td>
<p>Index of a repertoire to plot. Omitted if .grid is TRUE.</p>
</td></tr>
<tr><td><code id="vis.immunr_inc_overlap_+3A_.grid">.grid</code></td>
<td>
<p>Logical. If TRUE then plot all similarities in a grid.</p>
</td></tr>
<tr><td><code id="vis.immunr_inc_overlap_+3A_.ncol">.ncol</code></td>
<td>
<p>Numeric. Number of columns in the resulting grid.</p>
</td></tr>
<tr><td><code id="vis.immunr_inc_overlap_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><a href="#topic+repOverlap">repOverlap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
tmp &lt;- repOverlap(immdata$data[1:4], "inc+overlap", .verbose.inc = FALSE, .verbose = FALSE)
vis(tmp, .target = 1)
vis(tmp, .grid = TRUE)
</code></pre>

<hr>
<h2 id='vis.immunr_kmeans'>Visualisation of K-means and DBSCAN clustering</h2><span id='topic+vis.immunr_kmeans'></span><span id='topic+vis.immunr_dbscan'></span>

<h3>Description</h3>

<p>Visualisation of the results of K-means and DBSCAN clustering.
For hierarhical clustering visualisations see <a href="#topic+vis.immunr_hclust">vis.immunr_hclust</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_kmeans'
vis(
  .data,
  .point = TRUE,
  .text = TRUE,
  .ellipse = TRUE,
  .point.size = 2,
  .text.size = 10,
  .plot = c("clust", "best"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_kmeans_+3A_.data">.data</code></td>
<td>
<p>Clustering results from <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a> or <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.point">.point</code></td>
<td>
<p>If TRUE then plot sample points. Passed to <a href="factoextra.html#topic+fviz_cluster">fviz_cluster</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.text">.text</code></td>
<td>
<p>If TRUE then plot text labels. Passed to <a href="factoextra.html#topic+fviz_cluster">fviz_cluster</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.ellipse">.ellipse</code></td>
<td>
<p>If TRUE then plot ellipses around all samples. Passed to &quot;ellipse&quot; from <a href="factoextra.html#topic+fviz_cluster">fviz_cluster</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.point.size">.point.size</code></td>
<td>
<p>Size of points, passed to &quot;pointsize&quot; from <a href="factoextra.html#topic+fviz_cluster">fviz_cluster</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.text.size">.text.size</code></td>
<td>
<p>Size of text labels, passed to labelsize from <a href="factoextra.html#topic+fviz_cluster">fviz_cluster</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_.plot">.plot</code></td>
<td>
<p>A character vector of length one or two specifying which plots to visualise.
If &quot;clust&quot; then plot only the clustering. If &quot;best&quot; then plot the number of optimal clusters.
If both then plot both.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmeans_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ggplot2 objects inside the pathwork container.
</p>


<h3>See Also</h3>

<p><a href="#topic+vis">vis</a>, <a href="#topic+repOverlapAnalysis">repOverlapAnalysis</a>, <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
repOverlapAnalysis(ov, "mds+kmeans") %&gt;% vis()
</code></pre>

<hr>
<h2 id='vis.immunr_kmer_table'>Most frequent kmers visualisation.</h2><span id='topic+vis.immunr_kmer_table'></span>

<h3>Description</h3>

<p>Plot a distribution (bar plot) of the most frequent kmers in a data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_kmer_table'
vis(
  .data,
  .head = 100,
  .position = c("stack", "dodge", "fill"),
  .log = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_kmer_table_+3A_.data">.data</code></td>
<td>
<p>Data frame with two columns &quot;Kmers&quot; and &quot;Count&quot; or a list with such data frames. See Examples.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmer_table_+3A_.head">.head</code></td>
<td>
<p>Number of the most frequent kmers to choose for plotting from each data frame.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmer_table_+3A_.position">.position</code></td>
<td>
<p>Character vector of length 1. Position of bars for each kmers. Value for the <code>ggplot2</code> argument <code>position</code>.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmer_table_+3A_.log">.log</code></td>
<td>
<p>Logical. If TRUE then plot log-scaled plots.</p>
</td></tr>
<tr><td><code id="vis.immunr_kmer_table_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>See Also</h3>

<p><code>get.kmers</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load necessary data and package.
data(immdata)
# Get 5-mers.
imm.km &lt;- getKmers(immdata$data[[1]], 5)
# Plots for kmer proportions in each data frame in immdata.
p1 &lt;- vis(imm.km, .position = "stack")
p2 &lt;- vis(imm.km, .position = "fill")
p1 + p2
</code></pre>

<hr>
<h2 id='vis.immunr_mds'>PCA / MDS / tSNE visualisation (mainly overlap / gene usage)</h2><span id='topic+vis.immunr_mds'></span><span id='topic+vis.immunr_pca'></span><span id='topic+vis.immunr_tsne'></span>

<h3>Description</h3>

<p>PCA / MDS / tSNE visualisation (mainly overlap / gene usage)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_mds'
vis(
  .data,
  .by = NA,
  .meta = NA,
  .point = TRUE,
  .text = TRUE,
  .ellipse = TRUE,
  .point.size = 2,
  .text.size = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_mds_+3A_.data">.data</code></td>
<td>
<p>Output from analysis functions such as <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a> or
<a href="#topic+immunr_pca">immunr_pca</a>, <a href="#topic+immunr_mds">immunr_mds</a> or <a href="#topic+immunr_tsne">immunr_tsne</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.by">.by</code></td>
<td>
<p>Pass NA if you want to plot samples without grouping.
</p>
<p>You can pass a character vector with one or several column names from &quot;.meta&quot;
to group your data before plotting. In this case you should provide &quot;.meta&quot;.
</p>
<p>You can pass a character vector that exactly matches the number of samples in
your data, each value should correspond to a sample's property. It will be used
to group data based on the values provided. Note that in this case you should
pass NA to &quot;.meta&quot;.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.meta">.meta</code></td>
<td>
<p>A metadata object. An R dataframe with sample names and their properties,
such as age, serostatus or hla.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.point">.point</code></td>
<td>
<p>Logical. If TRUE then plot points corresponding to objects.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.text">.text</code></td>
<td>
<p>Logical. If TRUE then plot sample names.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.ellipse">.ellipse</code></td>
<td>
<p>Logical. If TRUE then plot ellipses around clusters of grouped samples.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.point.size">.point.size</code></td>
<td>
<p>Numeric. A size of points to plot.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_.text.size">.text.size</code></td>
<td>
<p>Numeric. A size of sample names' labels.</p>
</td></tr>
<tr><td><code id="vis.immunr_mds_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other visualisation methods:
</p>
<p>- PCA - <a href="#topic+vis.immunr_pca">vis.immunr_pca</a>
</p>
<p>- MDS - <a href="#topic+vis.immunr_mds">vis.immunr_mds</a>
</p>
<p>- tSNE - <a href="#topic+vis.immunr_tsne">vis.immunr_tsne</a>
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
repOverlapAnalysis(ov, "mds") %&gt;% vis()
</code></pre>

<hr>
<h2 id='vis.immunr_ov_matrix'>Repertoire overlap and gene usage visualisations</h2><span id='topic+vis.immunr_ov_matrix'></span><span id='topic+vis.immunr_gu_matrix'></span>

<h3>Description</h3>

<p>Visualises matrices with overlap values or gene usage distances among samples.
For details see the links below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_ov_matrix'
vis(.data, .plot = c("heatmap", "heatmap2", "circos"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_ov_matrix_+3A_.data">.data</code></td>
<td>
<p>Output from <a href="#topic+repOverlap">repOverlap</a> or <a href="#topic+geneUsageAnalysis">geneUsageAnalysis</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_ov_matrix_+3A_.plot">.plot</code></td>
<td>
<p>A string specifying the plot type:
</p>
<p>- &quot;heatmap&quot; for heatmaps using <a href="#topic+vis_heatmap">vis_heatmap</a>;
</p>
<p>- &quot;heatmap2&quot; for heatmaps using <a href="#topic+vis_heatmap2">vis_heatmap2</a>;
</p>
<p>- &quot;circos&quot; for circos plots using <a href="#topic+vis_circos">vis_circos</a>;</p>
</td></tr>
<tr><td><code id="vis.immunr_ov_matrix_+3A_...">...</code></td>
<td>
<p>Other arguments are passed through to the underlying plotting function:
</p>
<p>- &quot;heatmap&quot; - passes arguments to <a href="#topic+vis_heatmap">vis_heatmap</a>;
</p>
<p>- &quot;heatmap2&quot; - passes arguments to <a href="#topic+vis_heatmap2">vis_heatmap2</a> and <a href="stats.html#topic+heatmap">heatmap</a> from the &quot;pheatmap&quot; package;
</p>
<p>- &quot;circos&quot; - passes arguments to <a href="#topic+vis_circos">vis_circos</a> and <a href="circlize.html#topic+chordDiagram">chordDiagram</a> from the &quot;circlize&quot; package;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2, pheatmap or circlize object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
ov &lt;- repOverlap(immdata$data)
vis(ov)
vis(ov, "heatmap")
vis(ov, "heatmap2")
vis(ov, "circos")
</code></pre>

<hr>
<h2 id='vis.immunr_public_repertoire'>Public repertoire visualisation</h2><span id='topic+vis.immunr_public_repertoire'></span>

<h3>Description</h3>

<p>Public repertoire visualisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_public_repertoire'
vis(.data, .plot = c("freq", "clonotypes"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_public_repertoire_+3A_.data">.data</code></td>
<td>
<p>Public repertoire, an output from <a href="#topic+pubRep">pubRep</a>.</p>
</td></tr>
<tr><td><code id="vis.immunr_public_repertoire_+3A_.plot">.plot</code></td>
<td>
<p>A string specifying the plot type:
</p>
<p>- &quot;freq&quot; for visualisation of the distribution of occurrences of clonotypes
and their frequencies using <a href="#topic+vis_public_frequencies">vis_public_frequencies</a>.
</p>
<p>- &quot;clonotypes&quot; for visualisation of public clonotype frequenciy correlations between pairs of
samples using <a href="#topic+vis_public_clonotypes">vis_public_clonotypes</a></p>
</td></tr>
<tr><td><code id="vis.immunr_public_repertoire_+3A_...">...</code></td>
<td>
<p>Further arguments passed <a href="#topic+vis_public_frequencies">vis_public_frequencies</a> or <a href="#topic+vis_public_clonotypes">vis_public_clonotypes</a>,
depending on the &quot;.plot&quot; argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 300)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
vis(pr, "freq")
vis(pr, "freq", .type = "none")

vis(pr, "clonotypes", 1, 2)
</code></pre>

<hr>
<h2 id='vis.immunr_public_statistics'>Visualise sharing of clonotypes among samples</h2><span id='topic+vis.immunr_public_statistics'></span>

<h3>Description</h3>

<p>Visualise public clonotype frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'immunr_public_statistics'
vis(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.immunr_public_statistics_+3A_.data">.data</code></td>
<td>
<p>Public repertoire - an output from the <a href="#topic+pubRep">pubRep</a> function.</p>
</td></tr>
<tr><td><code id="vis.immunr_public_statistics_+3A_...">...</code></td>
<td>
<p>Other arguments passsed directly to <a href="UpSetR.html#topic+upset">upset</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immdata)
immdata$data &lt;- lapply(immdata$data, head, 2000)
pr &lt;- pubRep(immdata$data, .verbose = FALSE)
pubRepStatistics(pr) %&gt;% vis()
</code></pre>

<hr>
<h2 id='vis.step_failure_ignored'>Handler for .nofail argument of pipeline steps that prevents examples from crashing
on computers where certain dependencies are not installed</h2><span id='topic+vis.step_failure_ignored'></span>

<h3>Description</h3>

<p>Handler for .nofail argument of pipeline steps that prevents examples from crashing
on computers where certain dependencies are not installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_failure_ignored'
vis(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vis.step_failure_ignored_+3A_.data">.data</code></td>
<td>
<p>Not used here.</p>
</td></tr>
<tr><td><code id="vis.step_failure_ignored_+3A_...">...</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty object with &quot;step_failure_ignored&quot; class.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
