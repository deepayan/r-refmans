<!DOCTYPE html><html lang="en"><head><title>Help for package bsnsing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bsnsing}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bsnsing-package'><p>bsnsing: Build Decision Trees with Optimal Multivariate Splits</p></a></li>
<li><a href='#auto'><p>auto</p></a></li>
<li><a href='#binarize'><p>Create Binary Variables by the Classification Target</p></a></li>
<li><a href='#binarize.factor'><p>Create Binary Features based on a Factor Vector</p></a></li>
<li><a href='#binarize.numeric'><p>Create Binary Features based on a Numeric Vector</p></a></li>
<li><a href='#binarize.y'><p>Recode a Variable with Two Unique Values into an 0/1 Vector</p></a></li>
<li><a href='#BreastCancer'><p>BreastCancer</p></a></li>
<li><a href='#bscontrol'><p>Define Parameters for the <code>bsnsing</code> Fit</p></a></li>
<li><a href='#bslearn'><p>Find the Optimal Boolean Rule for Binary Classification</p></a></li>
<li><a href='#bsnsing'><p>Learn a Classification Tree using Boolean Sensing</p></a></li>
<li><a href='#bsnsing.default'><p>Learn a Classification Tree with Boolean Sensing</p></a></li>
<li><a href='#bsnsing.formula'><p>Learn a Classification Tree using Boolean Sensing</p></a></li>
<li><a href='#GlaucomaMVF'><p>GlaucomaMVF</p></a></li>
<li><a href='#import_external_rules'><p>Import split rules from other packages</p></a></li>
<li><a href='#iris'><p>iris</p></a></li>
<li><a href='#mbsnsing-class'><p>A class that contains multi-class classification model built by bsnsing. Can be used in summary and predict functions.</p></a></li>
<li><a href='#plot.bsnsing'><p>Generate latex code for plotting a bsnsing tree</p></a></li>
<li><a href='#plot.mbsnsing'><p>Generate latex code for plotting an mbsnsing tree</p></a></li>
<li><a href='#predict.bsnsing'><p>Make Predictions with a Fitted <code>bsnsing</code> Model</p></a></li>
<li><a href='#predict.mbsnsing'><p>Make Predictions with a <code>bsnsing</code> Model</p></a></li>
<li><a href='#print.bscontrol'><p>Print the Object of Class <code>bscontrol</code></p></a></li>
<li><a href='#print.bsnsing'><p>Print the Object of Class <code>bsnsing</code></p></a></li>
<li><a href='#print.mbsnsing'><p>Print the Object of Class <code>mbsnsing</code></p></a></li>
<li><a href='#print.summary.bsnsing'><p>Print the Summary of <code>bsnsing</code> Model</p></a></li>
<li><a href='#print.summary.mbsnsing'><p>Print the summary of <code>mbsnsing</code> model fits</p></a></li>
<li><a href='#rcpp_bslearn'><p>C implementation of the bslearn function</p></a></li>
<li><a href='#ROC_func'><p>Plot the ROC curve and calculate the AUC</p></a></li>
<li><a href='#summary.bsnsing'><p>Summarize the bsnsing Model Fits</p></a></li>
<li><a href='#summary.mbsnsing'><p>Summarize mbsnsing Model Fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Build Decision Trees with Optimal Multivariate Splits</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Yanchao Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yanchao Liu &lt;yanchaoliu@wayne.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for training an optimal decision tree classifier, making predictions and generating latex code for plotting. Works for two-class and multi-class classification problems. The algorithm seeks the optimal Boolean rule consisting of multiple variables to split a node, resulting in shorter trees. Use bsnsing() to build a tree, predict() to make predictions and plot() to plot the tree into latex and PDF. See Yanchao Liu (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2205.15263">doi:10.48550/arXiv.2205.15263</a>&gt; for technical details. Source code and more data sets are at <a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>C50, party, rpart, tree</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-03 15:16:04 UTC; gn0061</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-03 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bsnsing-package'>bsnsing: Build Decision Trees with Optimal Multivariate Splits</h2><span id='topic+bsnsing-package'></span>

<h3>Description</h3>

<p>The bsnsing package provides functions for building a decision tree classifier and making predictions. It solves a mixed-integer programming (MIP) model to maximize the Gini reduction at each node split, and each node split rule can utilize multiple input variables. Benchmarking experiments on 75 open data sets suggest that bsnsing trees are the most capable of discriminating new cases compared to trees trained by other decision tree codes including the rpart, C50, party and tree packages in R. Compared to other optimal decision tree packages, including DL8.5, OSDT, GOSDT and indirectly more, bsnsing stands out in its training speed, ease of use and broader applicability without losing in prediction accuracy. For more information, please check out the paper <a href="https://arxiv.org/abs/2205.15263">https://arxiv.org/abs/2205.15263</a>, to be published in INFORMS Journal on Computing.
</p>


<h3>The ENUM algorithm</h3>

<p>In this package, the MIP model is solved using the implicit enumeration (ENUM) algorithm. The experimental version at <a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a> is able to use external solvers such as GUROBI, CPLEX and lpSolve (via specifying the opt.solver option in the <code><a href="#topic+bsnsing">bsnsing</a></code> function). All benchmarking experiments were run using the C implementation of the ENUM algorithm, i.e., opt.solver = 'enum_c', which is the default setting.
</p>


<h3>More data sets</h3>

<p>Several data frames (i.e., <code><a href="#topic+auto">auto</a></code>, <code><a href="#topic+iris">iris</a></code>, <code><a href="#topic+GlaucomaMVF">GlaucomaMVF</a></code> and <code><a href="#topic+BreastCancer">BreastCancer</a></code>) used in the example code are included in this package. More two-class and multi-class classification data sets can be found at <a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>.
</p>


<h3>Learn functions</h3>

<p>The learn (train) functions include <code><a href="#topic+bsnsing">bsnsing</a></code>, <code><a href="#topic+bsnsing.formula">bsnsing.formula</a></code> and <code><a href="#topic+bsnsing.default">bsnsing.default</a></code>.
</p>


<h3>Predict functions</h3>

<p>The predict functions include: <code><a href="#topic+predict.bsnsing">predict.bsnsing</a></code> and <code><a href="#topic+predict.mbsnsing">predict.mbsnsing</a></code>.
</p>


<h3>Plot functions</h3>

<p>A <code><a href="#topic+bsnsing">bsnsing</a></code> object (tree) can be plotted into a PDF file, or in the form of latex code, by the function <code><a href="#topic+plot.bsnsing">plot.bsnsing</a></code>. The ROC curve can be plotted using the function <code><a href="#topic+ROC_func">ROC_func</a></code>.
</p>


<h3>Auxilliary functions</h3>

<p>Here is a list of internal functions of the package that are open for end users.
<code><a href="#topic+summary.bsnsing">summary.bsnsing</a></code>
<code><a href="#topic+summary.mbsnsing">summary.mbsnsing</a></code>,
<code><a href="#topic+binarize">binarize</a></code>,
<code><a href="#topic+binarize.numeric">binarize.numeric</a></code>,
<code><a href="#topic+binarize.factor">binarize.factor</a></code>,
<code><a href="#topic+binarize.y">binarize.y</a></code>,
<code><a href="#topic+bslearn">bslearn</a></code>,
<code><a href="#topic+bscontrol">bscontrol</a></code>
</p>


<h3>Author(s)</h3>

<p>Yanchao Liu
</p>

<hr>
<h2 id='auto'>auto</h2><span id='topic+auto'></span>

<h3>Description</h3>

<p>A test data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto
</code></pre>


<h3>Format</h3>

<p>A data frame with 392 rows and 8 variables
</p>


<h3>Source</h3>

<p><a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>
</p>

<hr>
<h2 id='binarize'>Create Binary Variables by the Classification Target</h2><span id='topic+binarize'></span>

<h3>Description</h3>

<p>Create a set of variables (columns) with binary values for each column in the input data. For a variable with values of 0 and 1, the column is retained and no new column is created. For a numeric variable, the function <code>binarize.numeric</code> is called. For a factor column, the function <code>binarize.factor</code> is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(
  x,
  y,
  target = stop("'target' (0 or 1) must be provided"),
  control = bscontrol()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize_+3A_x">x</code></td>
<td>
<p>a data frame or matrix to be binarized.</p>
</td></tr>
<tr><td><code id="binarize_+3A_y">y</code></td>
<td>
<p>a vector with two unique values (0 and 1). It is the response variable that guides the optimal discretization of variables in <code>x</code>.</p>
</td></tr>
<tr><td><code id="binarize_+3A_target">target</code></td>
<td>
<p>the level of y (0 or 1) which indicates the boolean rule target</p>
</td></tr>
<tr><td><code id="binarize_+3A_control">control</code></td>
<td>
<p>a list or a <code>bscontrol()</code> object. The list should contain the following three attributes: <em>nseg.numeric</em>, a positive integer indicating the maximum number of segments used in discretizing a numeric variable, <em>nseg.factor</em>, a positive integer indicating the maximum number of levels allowed for a factor variable, and <em>bin.size</em>, a positive integer indicating the minimum number of observations to fall in a segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing binary variables, or a character string describing the rule that perfectly split the target.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and prepare data
x &lt;- auto[, c('mpg', 'cylinders', 'displacement')]
x$cylinders &lt;- as.factor(x$cylinders)
y &lt;- ifelse(auto$origin == 'USA', 1L, 0L)
# binarize x by y = 1
bx1 &lt;- binarize(x, y, target = 1)
head(bx1)
# binarize x by y = 0
bx0 &lt;- binarize(x, y, target = 0)
head(bx0)
# when selecting only one column from a data frame, use drop = FALSE to maintain structure
binarize(auto[,'mpg', drop = FALSE], y, target = 1)

</code></pre>

<hr>
<h2 id='binarize.factor'>Create Binary Features based on a Factor Vector</h2><span id='topic+binarize.factor'></span>

<h3>Description</h3>

<p>Create binary dummy variables based on a factor variable. This function is used internally by <code><a href="#topic+binarize">binarize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize.factor(x, name, y, segments = 10, bin.size = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize.factor_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="binarize.factor_+3A_name">name</code></td>
<td>
<p>a character string, the variable name of <code>x</code>.</p>
</td></tr>
<tr><td><code id="binarize.factor_+3A_y">y</code></td>
<td>
<p>a numeric or integer vector of the same length as <code>x</code>, consisting of two unique values: 0 and 1.</p>
</td></tr>
<tr><td><code id="binarize.factor_+3A_segments">segments</code></td>
<td>
<p>a positive integer indicating the maximum number of levels allowed in the factor variable.</p>
</td></tr>
<tr><td><code id="binarize.factor_+3A_bin.size">bin.size</code></td>
<td>
<p>a positive integer. It is the minimum number of observations required to fall into each bin.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with binary (0 and 1) entries. The column names are indicative of the conditions used to form the corresponding columns.
</p>

<hr>
<h2 id='binarize.numeric'>Create Binary Features based on a Numeric Vector</h2><span id='topic+binarize.numeric'></span>

<h3>Description</h3>

<p>Discretize a continuous variable <code>x</code> by splitting its range at a sequence of cutpoints. The cutpoints are determined so as to effectively split the binary target <code>y</code>. This function is used internally by <code><a href="#topic+binarize">binarize</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize.numeric(
  x,
  name,
  y,
  target = stop("Must provide a target, 0 or 1"),
  segments = 10,
  bin.size = 5,
  node.size = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize.numeric_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_name">name</code></td>
<td>
<p>a character string, the variable name of <code>x</code>.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_y">y</code></td>
<td>
<p>a numeric or integer vector of the same length as <code>x</code>, consisting of two unique values: 0 and 1.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_target">target</code></td>
<td>
<p>a scalar, valued 0 or 1, indicating the target level of <code>y</code>.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_segments">segments</code></td>
<td>
<p>a positive integer, any value below 3 is set to 3. It is the maximum number of segments the range of <code>x</code> is divided into.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_bin.size">bin.size</code></td>
<td>
<p>a positive integer. It is the minimum number of observations required to fall into each bin.</p>
</td></tr>
<tr><td><code id="binarize.numeric_+3A_node.size">node.size</code></td>
<td>
<p>a positive integer. If either child node is smaller than the node.size, do not return the perfect rule.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with binary (0 and 1) entries, or a character string describing the rule that perfectly splits <code>y</code>. If a data frame is returned, the column names are indicative of the conditions used to form the corresponding columns.
</p>

<hr>
<h2 id='binarize.y'>Recode a Variable with Two Unique Values into an 0/1 Vector</h2><span id='topic+binarize.y'></span>

<h3>Description</h3>

<p>Recode a Variable with Two Unique Values into an 0/1 Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize.y(y, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize.y_+3A_y">y</code></td>
<td>
<p>a vector, must contain two unique values.</p>
</td></tr>
<tr><td><code id="binarize.y_+3A_verbose">verbose</code></td>
<td>
<p>a logical value, TRUE or FALSE, indicating whehter details are to be printed on the screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with three elements: <code>y</code>, a vector of the same length as <code>y</code>, whose entries are coded to 0 and 1, <code>coding.scheme</code>, a character string describing the map from the original coding to 0/1 coding, and <code>ycode</code>, a character vector containing the original level names of <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- factor(c('good', 'bad', 'good', 'good', 'bad'))
(yb &lt;- binarize.y(y))
y &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE)
(yb &lt;- binarize.y(y))
y &lt;- c(1, 2, 2, 1, 2)
(yb &lt;- binarize.y(y))
</code></pre>

<hr>
<h2 id='BreastCancer'>BreastCancer</h2><span id='topic+BreastCancer'></span>

<h3>Description</h3>

<p>A test data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BreastCancer
</code></pre>


<h3>Format</h3>

<p>A data frame with 699 rows and 10 variables.
</p>


<h3>Source</h3>

<p><a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>
</p>

<hr>
<h2 id='bscontrol'>Define Parameters for the <code><a href="#topic+bsnsing">bsnsing</a></code> Fit</h2><span id='topic+bscontrol'></span>

<h3>Description</h3>

<p>Define Parameters for the <code><a href="#topic+bsnsing">bsnsing</a></code> Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bscontrol(
  bin.size = 5,
  nseg.numeric = 20,
  nseg.factor = 20,
  num2factor = 10,
  node.size = 0,
  stop.prob = 0.9999,
  opt.solver = c("enum_c", "enum"),
  solver.timelimit = 180,
  max.rules = 2,
  opt.model = c("gini", "error"),
  greedy.level = 0.9,
  import.external = TRUE,
  suppress.internal = FALSE,
  no.same.gender.children = FALSE,
  n0n1.cap = 40000,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bscontrol_+3A_bin.size">bin.size</code></td>
<td>
<p>the minimum number of observations required in a binarization bucket.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_nseg.numeric">nseg.numeric</code></td>
<td>
<p>the maximum number of segments the range of a numeric variable is divided into for each inequality direction.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_nseg.factor">nseg.factor</code></td>
<td>
<p>the maximum number of unique levels allowed in a factor variable.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_num2factor">num2factor</code></td>
<td>
<p>an equality binarization rule will be created for each unique value of a numeric variable (in addition to the inequality binarization attempt), if the number of unique values of the numeric variable is less than <code>num2factor</code>.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_node.size">node.size</code></td>
<td>
<p>if the number of training cases falling into a tree node is fewer than <code>node.size</code>, the node will become a leaf and no further split will be attempted on it; in addition, do not split a node if either child node that would result from the split contains fewer than <code>node.size</code> observation. Default is 0, which indicates that the node.size will be set automatically according to this formula: floor(sqrt(Number of training cases)).</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_stop.prob">stop.prob</code></td>
<td>
<p>if the proportion of the majority class in a tree node is greater than <code>stop.prob</code>, the node will become a leaf and no further split will be attempted on it.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_opt.solver">opt.solver</code></td>
<td>
<p>a character string in the set 'enum', 'enum_c', 'gurobi', 'cplex', 'lpSolve', 'greedy' indicating the optimization solver to be used in the program. The choice of 'cplex' requires the package <code>cplexAPI</code>, 'gurobi' requires the package <code>gurobi</code>, and 'lpSolve' requires the package <code>lpSolve</code>. These solver options are only available in the full version at <a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>. The default (and the best) is 'enum_c'.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_solver.timelimit">solver.timelimit</code></td>
<td>
<p>the solver time limit in seconds. Note that this limits the time it takes to optimize each node split.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_max.rules">max.rules</code></td>
<td>
<p>the maximum number of features allowed to enter an OR-clause split rule. A small max.rules reduces the search space and regulates model complexity. Default is 2.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_opt.model">opt.model</code></td>
<td>
<p>a character string in the set 'gini','error' indicating the optimization model to solve in the program. The default is 'gini'. The 'error' option is not available in the current version.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_greedy.level">greedy.level</code></td>
<td>
<p>a proportion value between 0 and 1, applicable only when opt.solver is 'greedy'. In the greedy forward selection process of split rules, a candidate rule is added to the OR-clause only if the split performance (gini reduction or accuracy) after the addition multiplied by greedy.level would still be greater than the split performance before the addition. A higher value of greedy.level tend to more aggressively produce multi-variable splits. Only available in the full version.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_import.external">import.external</code></td>
<td>
<p>logical value indicating whether or not to try importing candidate split rules from other decision tree packages. Default is True.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_suppress.internal">suppress.internal</code></td>
<td>
<p>logical value indicating whether or not to suppress the feature binarization process that creates the pool of binary features. If it is set to True, then only the features imported from external methods (if import.external is True) will be used in the optimal rule selection model. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_no.same.gender.children">no.same.gender.children</code></td>
<td>
<p>logical value indicating whether or not to suppress splits that would result in both children having the same majority class. Default is FASLE.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_n0n1.cap">n0n1.cap</code></td>
<td>
<p>a positive integer. It is applicable only when the opt.solver is 'hybrid' and the opt.model is 'gini'. When the bslearn function is called, if the product of the number of negative cases (n0) and the number of positive cases (n1) is greater than this number, 'enum' solver will be used; otherwise, gurobi solver will be used. Only available in the full version.</p>
</td></tr>
<tr><td><code id="bscontrol_+3A_verbose">verbose</code></td>
<td>
<p>a logical value (TRUE or FALSE) indicating whether the solution details are to be printed on the screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bscontrol">bscontrol</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bscontrol()  # display the default parameters
bsc &lt;- bscontrol(stop.prob = 0.8, nseg.numeric = 10, verbose = TRUE)
bsc
</code></pre>

<hr>
<h2 id='bslearn'>Find the Optimal Boolean Rule for Binary Classification</h2><span id='topic+bslearn'></span>

<h3>Description</h3>

<p>The function solves a mixed integer program (MIP) to maximize the Gini reduction (opt.model = 'gini') or minimize the number of misclassified cases (opt.model = 'error').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bslearn(bx, y, control = bscontrol())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bslearn_+3A_bx">bx</code></td>
<td>
<p>a data frame with binary (0 and 1) entries.</p>
</td></tr>
<tr><td><code id="bslearn_+3A_y">y</code></td>
<td>
<p>an integer vector with binary entries.</p>
</td></tr>
<tr><td><code id="bslearn_+3A_control">control</code></td>
<td>
<p>an object of class <code>bscontrol()</code>, specifying the algorithmic parameters. The list should contain the following attributes: <em>opt.model</em>, a character string in <code>'gini','error'</code> indicating the optimization model to solve, <em>opt.solver</em>, a character string in <code>'enum_c', 'enum'</code> indicating the algorithm to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the splitting solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- auto[, c('mpg', 'cylinders', 'displacement')]
y &lt;- ifelse(auto$origin == 'USA', 1L, 0L)
# binarize x by y = 1
bx &lt;- binarize(x, y, target = 1)
# learn the optimal Boolean rule
bssol &lt;- bslearn(bx, y, bscontrol(opt.solver = 'enum'))
cat(paste("Optimal rule:" , bssol$rules, "\n"))
</code></pre>

<hr>
<h2 id='bsnsing'>Learn a Classification Tree using Boolean Sensing</h2><span id='topic+bsnsing'></span>

<h3>Description</h3>

<p>Depending on the arguments provided, either <code><a href="#topic+bsnsing.default">bsnsing.default</a></code> or <code><a href="#topic+bsnsing.formula">bsnsing.formula</a></code> will be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsnsing(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsnsing_+3A_x">x</code></td>
<td>
<p>a data frame or a <code><a href="stats.html#topic+formula">formula</a></code> object.</p>
</td></tr>
<tr><td><code id="bsnsing_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+bsnsing.default">bsnsing.default</a></code> or <code><a href="#topic+bsnsing.formula">bsnsing.formula</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>bsnsing</code> for a two-class problem or an object of class <code>mbsnsing</code> for a multi-class problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the formula format
bs &lt;- bsnsing(Class~., data = BreastCancer)
summary(bs)
# For multi-class classification
bs &lt;- bsnsing(Species ~ ., data = iris)
summary(bs)
summary(bs[[1]])  # display the tree for the first class
summary(bs[[2]])  # display the tree for the second class
summary(bs[[3]])  # display the tree for the third class
predict(bs, type = 'class')  # the fitted class membership
predict(bs, type = 'prob')  # the fitted probabilities

# Use the (x, y) format, y must have two levels
y &lt;- ifelse(iris$Species == 'setosa', 1L, 0L)
x &lt;- iris[, c('Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width')]
bs &lt;- bsnsing(x, y, verbose = TRUE)
summary(bs)

</code></pre>

<hr>
<h2 id='bsnsing.default'>Learn a Classification Tree with Boolean Sensing</h2><span id='topic+bsnsing.default'></span>

<h3>Description</h3>

<p>This is the default method for <code>bsnsing</code> and handles binary classification only. <code><a href="#topic+bsnsing.formula">bsnsing.formula</a></code>, which calls <code>bsnsing.default</code> as the basic tree builder, can handle multiclass classification problems. Missing values in numeric variables are imputed as the median of the non-missing ones, and missing values in factor variables are treated as a separate level named 'NA'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
bsnsing(x, y, controls = bscontrol(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsnsing.default_+3A_x">x</code></td>
<td>
<p>a data frame containing independent variables. Columns can be of numeric, integer, factor and logical types. The column names must be proper identifiers (e.g., must start with a letter, cannot contain special characters and spaces, etc.).</p>
</td></tr>
<tr><td><code id="bsnsing.default_+3A_y">y</code></td>
<td>
<p>a vector of the response variable. The response variable can be of an integer, numeric, logical or factor type, but must have only two unique values. Typical coding of a binary response variable is 0 (for negative case) and 1 (for positive cases).</p>
</td></tr>
<tr><td><code id="bsnsing.default_+3A_controls">controls</code></td>
<td>
<p>an object of class <code><a href="#topic+bscontrol">bscontrol</a></code>.</p>
</td></tr>
<tr><td><code id="bsnsing.default_+3A_...">...</code></td>
<td>
<p>further argument to be passed to bsnsing.default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>bsnsing</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ifelse(iris$Species == 'setosa', 1L, 0L)
x &lt;- iris[, c('Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width')]
bs &lt;- bsnsing(x, y, verbose = TRUE)
summary(bs)
</code></pre>

<hr>
<h2 id='bsnsing.formula'>Learn a Classification Tree using Boolean Sensing</h2><span id='topic+bsnsing.formula'></span>

<h3>Description</h3>

<p>The program builds a binary classification tree for each unique value in the response variable. Each tree classifies a target value against all the other values (internally coded as 'all.other') in the response variable. If the response variable is a numeric type, the number of unique values must not exceed 30. There is no programmatic restriction on the number of unique levels for a factor response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
bsnsing(formula, data, subset, na.action = stats::na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsnsing.formula_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot;: a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="bsnsing.formula_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in the model. If not found in <code>data</code>, the variables are taken from <code>environment(formula)</code>, typically the environment from which <code>bsnsing.formula</code> is called.</p>
</td></tr>
<tr><td><code id="bsnsing.formula_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset (in terms of index numbers, not actual data) of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="bsnsing.formula_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. If <code>na.pass</code> is used, <code>bsnsing</code> will still apply an internal NA treatment logic, as follows: missing values in numeric variables will be replaced by the median of the non-missing values of the variable; missing values in factor variables will be treated as a spearate level named 'NA'.</p>
</td></tr>
<tr><td><code id="bsnsing.formula_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level fitting functions, e.g., elements in the <code><a href="#topic+bscontrol">bscontrol</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of <code><a href="#topic+bsnsing">bsnsing</a></code> for a two-class problem or an object of <code><a href="#topic+mbsnsing">mbsnsing</a></code> for a multi-class problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Multi-class classification
bs &lt;- bsnsing(Species ~ ., data = iris)
summary(bs)
summary(bs[[1]])  # display the tree for the first class
summary(bs[[2]])  # display the tree for the second class
summary(bs[[3]])  # display the tree for the third class

# Two-class classification
bs &lt;- bsnsing(origin ~ mpg + displacement + horsepower + weight, data = auto, verbose = TRUE)
summary(bs)
</code></pre>

<hr>
<h2 id='GlaucomaMVF'>GlaucomaMVF</h2><span id='topic+GlaucomaMVF'></span>

<h3>Description</h3>

<p>A test dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GlaucomaMVF
</code></pre>


<h3>Format</h3>

<p>A data frame with 170 rows and 67 variables:
</p>


<h3>Source</h3>

<p><a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>
</p>

<hr>
<h2 id='import_external_rules'>Import split rules from other packages</h2><span id='topic+import_external_rules'></span>

<h3>Description</h3>

<p>Run other decision tree functions available in the system and collect the node split rules for optimal selection in bsnsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_external_rules(x, y, verbose)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_external_rules_+3A_x">x</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="import_external_rules_+3A_y">y</code></td>
<td>
<p>a binary vector.</p>
</td></tr>
<tr><td><code id="import_external_rules_+3A_verbose">verbose</code></td>
<td>
<p>a logical value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of character strings.
</p>

<hr>
<h2 id='iris'>iris</h2><span id='topic+iris'></span>

<h3>Description</h3>

<p>A test data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iris
</code></pre>


<h3>Format</h3>

<p>A data frame with 150 rows and 5 variables.
</p>


<h3>Source</h3>

<p><a href="https://github.com/profyliu/bsnsing/">https://github.com/profyliu/bsnsing/</a>
</p>

<hr>
<h2 id='mbsnsing-class'>A class that contains multi-class classification model built by bsnsing. Can be used in summary and predict functions.</h2><span id='topic+mbsnsing-class'></span><span id='topic+mbsnsing'></span>

<h3>Description</h3>

<p>A class that contains multi-class classification model built by bsnsing. Can be used in summary and predict functions.
</p>

<hr>
<h2 id='plot.bsnsing'>Generate latex code for plotting a bsnsing tree</h2><span id='topic+plot.bsnsing'></span>

<h3>Description</h3>

<p>If the file argument is supplied, this function will invoke the external programs latex, dvips and ps2pdf. If these programs are not available, only the latex code will be generated. If the file argument is left empty, the latex code will be written to the console screen. The latex code utilizes the following  packages: pstricks, pst-node, pst-tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsnsing'
plot(
  x,
  file = "",
  class_labels = c(),
  class_colors = c("red", "green"),
  rule_font = c("footnotesize", "scriptsize", "tiny", "normalsize", "small"),
  rule_color = "blue",
  footnote = FALSE,
  landscape = FALSE,
  papersize = c("a0paper", "a1paper", "a2paper", "a3paper", "a4paper", "a5paper",
    "a6paper", "b0paper", "b1paper", "b2paper", "b3paper", "b4paper", "b5paper",
    "b6paper", "c0paper", "c1paper", "c2paper", "c3paper", "c4paper", "c5paper",
    "c6paper", "b0j", "b1j", "b2j", "b3j", "b4j", "b5j", "b6j", "ansiapaper",
    "ansibpaper", "ansicpaper", "ansidpaper", "ansiepaper", "letterpaper",
    "executivepaper", "legalpaper"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+bsnsing">bsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_file">file</code></td>
<td>
<p>a writable connection or a character string naming the file to write to. If not supplied, the output will be written to the console.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_class_labels">class_labels</code></td>
<td>
<p>a character vector of two elements for leaf node label (for 0 and 1). If empty, the labels will be read from the bsnsing object.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_class_colors">class_colors</code></td>
<td>
<p>a character vector of two elements for leaf node color (for 0 and 1)</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_rule_font">rule_font</code></td>
<td>
<p>a string specifying the font size of the split rule at each non-leaf node</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_rule_color">rule_color</code></td>
<td>
<p>a string specifying the color of the split rule and node, e.g., blue, gray, black, etc. For a list of all usable colors, see https://en.wikibooks.org/wiki/LaTeX/Colors</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_footnote">footnote</code></td>
<td>
<p>a boolean value indicating whether to add annotation text to the PDF page. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_landscape">landscape</code></td>
<td>
<p>a boolean value indicating if the PDF page should be in landscape layout. The default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_papersize">papersize</code></td>
<td>
<p>a string specifying the PDF paper size. The default is 'a0paper'.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_verbose">verbose</code></td>
<td>
<p>a logical value, default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.bsnsing_+3A_...">...</code></td>
<td>
<p>further parameters to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bs &lt;- bsnsing(Class ~ ., data = GlaucomaMVF)
plot(bs)
## Not run: 
plot(bs, file = 'GlaucomaMVF_tree.pdf')
plot(bs, file = 'GlaucomaMVF_tree_letterpaper.pdf', paper='letterpaper')

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mbsnsing'>Generate latex code for plotting an mbsnsing tree</h2><span id='topic+plot.mbsnsing'></span>

<h3>Description</h3>

<p>Users are advised to plot each bsnsing tree separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbsnsing'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mbsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+mbsnsing">mbsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mbsnsing_+3A_...">...</code></td>
<td>
<p>further arguments to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='predict.bsnsing'>Make Predictions with a Fitted <code><a href="#topic+bsnsing">bsnsing</a></code> Model</h2><span id='topic+predict.bsnsing'></span>

<h3>Description</h3>

<p>Implements the generic <code>predict</code> function to make predictions on new data using a trained <code><a href="#topic+bsnsing">bsnsing</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsnsing'
predict(object, newdata = NULL, type = c("prob", "class"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.bsnsing_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+bsnsing">bsnsing</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.bsnsing_+3A_newdata">newdata</code></td>
<td>
<p>a optional data frame in which to look for variables for prediction. If omitted, the fitted class or probability will be returned.</p>
</td></tr>
<tr><td><code id="predict.bsnsing_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of prediction. <em>'prob'</em> predicts the probability of being a positive case (i.e., y = 1), and <em>'class'</em> predicts the class membership.</p>
</td></tr>
<tr><td><code id="predict.bsnsing_+3A_...">...</code></td>
<td>
<p>further arguments to predict.bsnsing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
n &lt;- nrow(GlaucomaMVF)
train_index = sample(1:n, round(0.5*n))
test_index = setdiff(1:n, train_index)
# Fit a model using training set
bs &lt;- bsnsing(Class ~ ., data = GlaucomaMVF, subset = train_index)
# Make predictions on the test set
pred &lt;- predict(bs, GlaucomaMVF[test_index, ], type = 'class')
# Display the confusion matrix
table(pred, actual = GlaucomaMVF[test_index, 'Class'])
</code></pre>

<hr>
<h2 id='predict.mbsnsing'>Make Predictions with a <code><a href="#topic+bsnsing">bsnsing</a></code> Model</h2><span id='topic+predict.mbsnsing'></span>

<h3>Description</h3>

<p>Make Predictions with a <code><a href="#topic+bsnsing">bsnsing</a></code> Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbsnsing'
predict(object, newdata = NULL, type = c("prob", "class"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mbsnsing_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+mbsnsing">mbsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="predict.mbsnsing_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame in which to look for variables for prediction. If omitted, the fitted class or probability will be returned.</p>
</td></tr>
<tr><td><code id="predict.mbsnsing_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of prediction. <em>'prob'</em> predicts the probability of being in each class, and <em>'class'</em> predicts the class membership.</p>
</td></tr>
<tr><td><code id="predict.mbsnsing_+3A_...">...</code></td>
<td>
<p>further arguments to predict.mbsnsing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(iris)
train_index &lt;- sample(1:n, round(0.5*n))
test_index &lt;- setdiff(1:n, train_index)
# Fit a model on the training set
bs &lt;- bsnsing(Species ~ ., data = iris, subset = train_index)
# Make predictions on the test set
pred &lt;- predict(bs, iris[test_index, ], type = 'class')
# Display the confusion matrix
table(pred, actual = iris[test_index, 'Species'])
# Predict the probabilities
predprob &lt;- predict(bs, iris[test_index, ], type = 'prob')
head(predprob)
</code></pre>

<hr>
<h2 id='print.bscontrol'>Print the Object of Class <code><a href="#topic+bscontrol">bscontrol</a></code></h2><span id='topic+print.bscontrol'></span>

<h3>Description</h3>

<p>Print the Object of Class <code><a href="#topic+bscontrol">bscontrol</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bscontrol'
print(x = bscontrol(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bscontrol_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+bscontrol">bscontrol</a></code>.</p>
</td></tr>
<tr><td><code id="print.bscontrol_+3A_...">...</code></td>
<td>
<p>further arguments to the print function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='print.bsnsing'>Print the Object of Class <code><a href="#topic+bsnsing">bsnsing</a></code></h2><span id='topic+print.bsnsing'></span>

<h3>Description</h3>

<p>Print the Object of Class <code><a href="#topic+bsnsing">bsnsing</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsnsing'
print(x, print.call = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+bsnsing">bsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="print.bsnsing_+3A_print.call">print.call</code></td>
<td>
<p>print out the function called, default TRUE.</p>
</td></tr>
<tr><td><code id="print.bsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='print.mbsnsing'>Print the Object of Class <code><a href="#topic+mbsnsing">mbsnsing</a></code></h2><span id='topic+print.mbsnsing'></span>

<h3>Description</h3>

<p>Print the Object of Class <code><a href="#topic+mbsnsing">mbsnsing</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbsnsing'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mbsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+mbsnsing">mbsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="print.mbsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='print.summary.bsnsing'>Print the Summary of <code><a href="#topic+bsnsing">bsnsing</a></code> Model</h2><span id='topic+print.summary.bsnsing'></span>

<h3>Description</h3>

<p>Print the Summary of <code><a href="#topic+bsnsing">bsnsing</a></code> Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.bsnsing'
print(x, print.call = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.bsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+summary.bsnsing">summary.bsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.bsnsing_+3A_print.call">print.call</code></td>
<td>
<p>a logical value, print out the function called if TRUE.</p>
</td></tr>
<tr><td><code id="print.summary.bsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='print.summary.mbsnsing'>Print the summary of <code><a href="#topic+mbsnsing">mbsnsing</a></code> model fits</h2><span id='topic+print.summary.mbsnsing'></span>

<h3>Description</h3>

<p>Print the summary of <code><a href="#topic+mbsnsing">mbsnsing</a></code> model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mbsnsing'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.mbsnsing_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+summary.mbsnsing">summary.mbsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.mbsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='rcpp_bslearn'>C implementation of the bslearn function</h2><span id='topic+rcpp_bslearn'></span>

<h3>Description</h3>

<p>C implementation of the bslearn function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_bslearn(
  nrows,
  ncols,
  input_y,
  input_x,
  grp,
  max_rules,
  max_time,
  node_size,
  no_same_gender_children,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcpp_bslearn_+3A_nrows">nrows</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_ncols">ncols</code></td>
<td>
<p>number of columns</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_input_y">input_y</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_input_x">input_x</code></td>
<td>
<p>Integer matrix</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_grp">grp</code></td>
<td>
<p>group membership indices</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_max_rules">max_rules</code></td>
<td>
<p>max number of rules</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_max_time">max_time</code></td>
<td>
<p>max running time in seconds</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_node_size">node_size</code></td>
<td>
<p>minimum node size</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_no_same_gender_children">no_same_gender_children</code></td>
<td>
<p>if TRUE child nodes must be of different predicted classes</p>
</td></tr>
<tr><td><code id="rcpp_bslearn_+3A_verbose">verbose</code></td>
<td>
<p>verbose level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing four elements
</p>

<hr>
<h2 id='ROC_func'>Plot the ROC curve and calculate the AUC</h2><span id='topic+ROC_func'></span>

<h3>Description</h3>

<p>This is a general utility function, not part of the bsnsing functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROC_func(
  df,
  label_colnum,
  score_colnum,
  pos.label = "1",
  plot.ROC = FALSE,
  add_on = FALSE,
  color = "black",
  lty = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROC_func_+3A_df">df</code></td>
<td>
<p>a data frame which must contain at least these two columns: the prediction scores (numeric values, not necessarily be between 0 and 1) and the true class labels.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_label_colnum">label_colnum</code></td>
<td>
<p>the column index of the scores column in df.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_score_colnum">score_colnum</code></td>
<td>
<p>the column index of the true class labels column in df.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_pos.label">pos.label</code></td>
<td>
<p>a character string matching the positive class label used in the class labels column.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_plot.roc">plot.ROC</code></td>
<td>
<p>a logical value indicating whether the ROC curve should be plotted.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_add_on">add_on</code></td>
<td>
<p>a logical value indicating whether the ROC curve should be added to an existing plot.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_color">color</code></td>
<td>
<p>a character string specifying the color of the ROC curve in the plot.</p>
</td></tr>
<tr><td><code id="ROC_func_+3A_lty">lty</code></td>
<td>
<p>line type used in the plot, 1 solid, 2 dashed, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value representing the area under the ROC curve (AUC).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- nrow(BreastCancer)
trainset &lt;- sample(1:n, 0.7*n)  # randomly sample 70% for training
testset &lt;- setdiff(1:n, trainset)  # the remaining is for testing
# Build a tree to predict Class, using all default options
bs &lt;- bsnsing(Class~., data = BreastCancer[trainset,])
summary(bs)  # display the tree structure
pred &lt;- predict(bs, BreastCancer[testset,], type='class')
actual &lt;- BreastCancer[testset, 'Class']
table(pred, actual)  # display the confusion matrix
# Plot the ROC curve and display the AUC
ROC_func(data.frame(predict(bs, BreastCancer[testset,]), 
                    BreastCancer[testset,'Class']), 
         2, 1, pos.label = 'malignant', plot.ROC=TRUE)
</code></pre>

<hr>
<h2 id='summary.bsnsing'>Summarize the bsnsing Model Fits</h2><span id='topic+summary.bsnsing'></span>

<h3>Description</h3>

<p>Summarize the bsnsing Model Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bsnsing'
summary(object = stop("no 'object' arg"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bsnsing_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+bsnsing">bsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of detailed information in the given <code>object</code>.
</p>

<hr>
<h2 id='summary.mbsnsing'>Summarize mbsnsing Model Fits</h2><span id='topic+summary.mbsnsing'></span>

<h3>Description</h3>

<p>Summarize mbsnsing Model Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbsnsing'
summary(object = stop("no 'object' arg"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mbsnsing_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+mbsnsing">mbsnsing</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mbsnsing_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of detailed information in the given <code>object</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
