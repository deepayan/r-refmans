<!DOCTYPE html><html lang="en"><head><title>Help for package Rborist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rborist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#expandfe'><p>Expands forest values into front-end readable vectors.</p></a></li>
<li><a href='#Export'><p>Exportation Format for rfArb Training Output</p></a></li>
<li><a href='#forestWeight'><p>Meinshausen forest weights</p></a></li>
<li><a href='#predict.arbTrain'><p>predict method for arbTrain result</p></a></li>
<li><a href='#predict.rfArb'><p>predict method for rfArb result</p></a></li>
<li><a href='#preformat'><p>Preformatting for Training with Warm Starts</p></a></li>
<li><a href='#presample'><p>Forest-wide Observation Sampling</p></a></li>
<li><a href='#Rborist'><p>Rapid Decision Tree Construction and Evaluation</p></a></li>
<li><a href='#RboristNews'><p>NEWS Displayer for Rborist</p></a></li>
<li><a href='#rfArb'><p>Rapid Decision Tree Construction and Evaluation</p></a></li>
<li><a href='#rfTrain'><p>Rapid Decision Tree Training</p></a></li>
<li><a href='#Streamline.rfArb'><p>Reducing Memory Footprint of Trained Decision Forest</p></a></li>
<li><a href='#validate'><p>Separate Validation of Trained Decision Forest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extensible, Parallelizable Implementation of the Random Forest
Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-2-2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Seligman &lt;mseligman@suiji.org&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/suiji/Arborist/issues">https://github.com/suiji/Arborist/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Scalable implementation of classification and regression forests, as described by Breiman (2001), &lt;<a href="https://doi.org/10.1023%2FA%3A1010933404324">doi:10.1023/A:1010933404324</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/suiji/Rborist.CRAN">https://github.com/suiji/Rborist.CRAN</a>,
<a href="https://github.com/suiji/Arborist">https://github.com/suiji/Arborist</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL version 2.0</a> | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE [expanded from: MPL (&ge; 2) | GPL (&ge; 2) | file LICENSE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.2), data.table (&ge; 1.9.8), digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-02 20:41:06 UTC; mseligman</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Seligman [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-02 23:10:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='expandfe'>Expands forest values into front-end readable vectors.</h2><span id='topic+expandfe'></span><span id='topic+expandfe.default'></span>

<h3>Description</h3>

<p>Formats training output into a form suitable for illustration of
feature contributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## Default S3 method:
expandfe(arbOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandfe_+3A_arbout">arbOut</code></td>
<td>
<p>an object of type <code>rfTrain</code> produced by training.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>ExpandReg</code> or <code>ExpandCtg</code> containing
human-readable representations of the trained forest.
</p>


<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    data(iris)
    rb &lt;- Rborist(iris[,-5], iris[,5])
    ffe &lt;- expandfe(rb)

    # An rfTrain counterpart is NYI.
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Export'>Exportation Format for rfArb Training Output</h2><span id='topic+Export'></span><span id='topic+Export.default'></span>

<h3>Description</h3>

<p>Formats training output into a form suitable for illustration of
feature contributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## Default S3 method:
Export(arbOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Export_+3A_arbout">arbOut</code></td>
<td>
<p>an object of type <code>Rborist</code> produced by training.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>Export</code>.
</p>


<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    data(iris)
    rb &lt;- Rborist(iris[,-5], iris[,5])
    ffe &lt;- Export(rb)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='forestWeight'>Meinshausen forest weights</h2><span id='topic+forestWeight'></span><span id='topic+forestWeight.default'></span>

<h3>Description</h3>

<p>Normalized observation counts across a prediction set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
forestWeight(objTrain, prediction, sampler=objTrain$sampler,
nThread=0, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forestWeight_+3A_objtrain">objTrain</code></td>
<td>
<p>an object of class <code>rfArb</code>, created from a
previous invocation of the command <code>Rborist</code> or <code>rfArb</code> to train.</p>
</td></tr>
<tr><td><code id="forestWeight_+3A_prediction">prediction</code></td>
<td>
<p>an object of class <code>SummaryReg</code> or
<code>SummaryCtg</code> obtained from prediction using <code>objTrain</code> and
argument <code>indexing=TRUE</code>.</p>
</td></tr>
<tr><td><code id="forestWeight_+3A_sampler">sampler</code></td>
<td>
<p>an object of class <code>Sampler</code>, as documented for
command of the same name.</p>
</td></tr>
<tr><td><code id="forestWeight_+3A_nthread">nThread</code></td>
<td>
<p>specifies a prefered thread count.</p>
</td></tr>
<tr><td><code id="forestWeight_+3A_verbose">verbose</code></td>
<td>
<p>whether to output progress of weighting.</p>
</td></tr>
<tr><td><code id="forestWeight_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix having rows equal to the Meinshausen weight of each new datum.</p>


<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>References</h3>

<p>Meinshausen, N. (2016) Quantile Random Forests. Journal of Machine
Learning Research 17(1), 1-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rborist">Rborist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.
  rb &lt;- Rborist(x,y)


  newdata &lt;- data.frame(replace(6, rnorm(nRow)))

  # Performs separate prediction on new data, saving indices:
  pred &lt;- predict(rb, newdata, indexing=TRUE)
  weights &lt;- forestWeight(rb, pred)

  obsIdx &lt;- 215 # Arbitrary observation index (zero-based row number)

  # Inner product should equal prediction, modulo numerical vagaries:
  yPredApprox &lt;- weights[obsIdx,] %*% y
  print((yPredApprox - pred$yPred[obsIdx])/yPredApprox) 

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.arbTrain'>predict method for arbTrain result</h2><span id='topic+predict.arbTrain'></span>

<h3>Description</h3>

<p>Prediction and test using Rborist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arbTrain'
predict(object, newdata, sampler, yTest=NULL,
keyedFrame = FALSE, quantVec=numeric(0), quantiles = length(quantVec) &gt; 0,
ctgCensus = "votes", indexing = FALSE, trapUnobserved = FALSE,
bagging = FALSE, nThread = 0, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.arbTrain_+3A_object">object</code></td>
<td>
<p>an object of class <code>arbTrain</code>, created from a
previous invocation of the command <code>rfArb</code>, <code>Rborist</code>
or <code>rfTrain</code> to train.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_newdata">newdata</code></td>
<td>
<p>a design frame or matrix containing new data, with the
same signature of predictors as in the training command.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_sampler">sampler</code></td>
<td>
<p>an object of class <code>Sampler</code> used in the
command.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_ytest">yTest</code></td>
<td>
<p>a response vector against which to test the new
predictions.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_keyedframe">keyedFrame</code></td>
<td>
<p>whether the columns of <code>newdata</code> may appear in
arbitrary order or as a superset of the predictors used to train.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_quantvec">quantVec</code></td>
<td>
<p>a vector of quantiles to predict.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_quantiles">quantiles</code></td>
<td>
<p>whether to predict quantiles.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_ctgcensus">ctgCensus</code></td>
<td>
<p>whether/how to summarize per-category predictions.
&quot;votes&quot; specifies the number of trees predicting a given class.
&quot;prob&quot; specifies a normalized, probabilistic summary.
&quot;probSample&quot; specifies sample-weighted probabilities, similar to
quantile histogramming.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_indexing">indexing</code></td>
<td>
<p>whether to record the final node index, typically
terminal, of tree traversal.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_trapunobserved">trapUnobserved</code></td>
<td>
<p>reports score for nonterminal upon encountering
values not observed during training, such as missing data.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_bagging">bagging</code></td>
<td>
<p>whether prediction is restricted to out-of-bag samples.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_nthread">nThread</code></td>
<td>
<p>suggests ans OpenMP-style thread count.  Zero denotes
default processor setting.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_verbose">verbose</code></td>
<td>
<p>whether to output progress of prediction.</p>
</td></tr>
<tr><td><code id="predict.arbTrain_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of one of two classes:
</p>

<ul>
<li> <p><code>SummaryReg</code> summarizing regression, consisting of:
</p>

<ul>
<li> <p><code>prediction</code> an object of class <code>PredictReg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> the estimated numerical response.
</p>
</li>
<li> <p><code>qPred</code> quantiles of prediction, if requested.
</p>
</li>
<li> <p><code>qEst</code> quantile of the estimate, if quantiles requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li></ul>

</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidReg</code> consisting of:
</p>

<ul>
<li> <p><code>mse</code> the mean-squared error of the estimate.
</p>
</li>
<li> <p><code>rsq</code> the r-squared statistic of the estimate.
</p>
</li>
<li> <p><code>mae</code> the mean absolute error of the estimate.
</p>
</li></ul>

</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceReg</code>, containing multiple instances of:
</p>

<ul>
<li> <p><code>names</code> the predictor names.
</p>
</li>
<li> <p><code>mse</code> the per-predictor mean-squared error, under permutation.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>SummaryCtg</code> summarizing classification, consisting of:
</p>

<ul>
<li> <p><code>PredictCtg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> estimated categorical response.
</p>
</li>
<li> <p><code>census</code> factor-valued matrix of the estimate, by category, if requested.
</p>
</li>
<li> <p><code>prob</code> matrix of estimate probabilities, by category, if requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li></ul>

</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidCtg</code> consisting of:
</p>

<ul>
<li> <p><code>confusion</code> the confusion matrix.
</p>
</li>
<li> <p><code>misprediction</code> the misprediction rate.
</p>
</li>
<li> <p><code>oobError</code> the out-of-bag error.
</p>
</li></ul>

</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceCtg</code>, consisting of:
</p>

<ul>
<li> <p><code>mispred</code> the misprediction rate, by predictor.
</p>
</li>
<li> <p><code>oobErr</code> the out-of-bag error, by predictor.
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfTrain">rfTrain</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  pf &lt;- preformat(x)
  sp &lt;- presample(y)
  rb &lt;- arbTrain(pf, sp, y)


  # Performs separate prediction on new data:
  xx &lt;- data.frame(replace(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  rb &lt;- Rborist(x,y)

  # Performs separate prediction on new data:
  xx &lt;- data.frame(replacate(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  # As above, but also records final indices of each tree walk:
  #
  pred &lt;- predict(rb, xx, indexing=TRUE)
  print(pred$indices[c(1:2), ])


  # As above, but predicts over \code{newdata} with unobserved values.
  # In the case of numerical data, only missing values are considered
  # unobserved.  Missing values are encoded as \code{NaN}, which are
  # incomparable, precipitating \code{false} on every test.  Prediction
  # therefore takes the \code{false} branch when encountering missing
  # values:
  #
  xxMissing &lt;- xx
  xxMissing[6, c(15, 32, 87, 101)] &lt;- NA
  pred &lt;- predict(rb, xxMissing)
  

  # As above, but returns a nonterminal score upon encountering
  # unobserved values. Neither the true nor the false branch from the
  # testing node is taken.  Instead, the score returned is derived
  # from all leaf nodes (terminals) reached by the testing
  # (nonterminal) node.
  #
  pred &lt;- predict(rb, xxMissing, trapUnobserved = TRUE)


  # Performs separate prediction, using original response as test
  # vector:
  pred &lt;- predict(rb, xx, y)
  mse &lt;- pred$mse
  rsq &lt;- pred$rsq


  # Performs separate prediction with (default) quantiles:
  pred &lt;- predict(rb, xx, quantiles="TRUE")
  qPred &lt;- pred$qPred


  # Performs separate prediction with deciles:
  pred &lt;- predict(rb, xx, quantVec = seq(0.1, 1.0, by = 0.10))
  qPred &lt;- pred$qPred


  # Classification examples:
  data(iris)
  rb &lt;- Rborist(iris[-5], iris[5])


  # Generic prediction using training set.
  # Census as (default) votes:
  pred &lt;- predict(rb, iris[-5])
  yPred &lt;- pred$yPred
  census &lt;- pred$census

  # Using the \code{keyedFrame} option allows the columns of
  # \code{newdata} to appear in arbitrary order, so long as the
  # columns present during training appear as a subset:
  #
  pred &lt;- predict(rb, iris[c(2, 4, 3, 1)], keyedFrame=TRUE)


  # As above, but validation census to report class probabilities:
  pred &lt;- predict(rb, iris[-5], ctgCensus="prob")
  prob &lt;- pred$prob


  # As above, but with training reponse as test vector:
  pred &lt;- predict(rb, iris[-5], iris[5], ctgCensus = "prob")
  prob &lt;- pred$prob
  conf &lt;- pred$confusion
  misPred &lt;- pred$misPred

  # As above, but predicts nonterminal when encountering categories
  # not observed during training.  That is, prediction returns a score
  # derived from all terminal nodes (leaves) reached from the
  # (nonterminal) testing node.
  #
  # In this case, "unobserved" refers to categories not present in
  # the subpartition over which a splitting is performed.  As training
  # partitions the data into smaller and smaller regions, a given
  # category becomes less likely to appear in a region.
  #
  # More generally, unobserved data can include missing predictors as
  # well as categories appearing in \code{newdata} which were not
  # present during training.
  #
  pred &lt;- predict(rb, trapUnobserved=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.rfArb'>predict method for rfArb result</h2><span id='topic+predict.rfArb'></span>

<h3>Description</h3>

<p>Prediction and test using Rborist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfArb'
predict(object, newdata, sampler, yTest=NULL,
keyedFrame = FALSE, quantVec=numeric(0), quantiles = length(quantVec) &gt; 0,
ctgCensus = "votes", indexing = FALSE, trapUnobserved = FALSE,
bagging = FALSE, nThread = 0, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.rfArb_+3A_object">object</code></td>
<td>
<p>an object of class <code>rfArb</code>, created from a
previous invocation of the command <code>rfArb</code> or <code>Rborist</code>
to train.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_newdata">newdata</code></td>
<td>
<p>a design frame or matrix containing new data, with the
same signature of predictors as in the training command.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_sampler">sampler</code></td>
<td>
<p>an object of class <code>Sampler</code> used in the
command.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_ytest">yTest</code></td>
<td>
<p>a response vector against which to test the new
predictions.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_keyedframe">keyedFrame</code></td>
<td>
<p>whether the columns of <code>newdata</code> may appear in
arbitrary order or as a superset of the predictors used to train.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_quantvec">quantVec</code></td>
<td>
<p>a vector of quantiles to predict.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_quantiles">quantiles</code></td>
<td>
<p>whether to predict quantiles.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_ctgcensus">ctgCensus</code></td>
<td>
<p>whether/how to summarize per-category predictions.
&quot;votes&quot; specifies the number of trees predicting a given class.
&quot;prob&quot; specifies a normalized, probabilistic summary.
&quot;probSample&quot; specifies sample-weighted probabilities, similar to
quantile histogramming.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_indexing">indexing</code></td>
<td>
<p>whether to record the final node index, typically
terminal, of tree traversal.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_trapunobserved">trapUnobserved</code></td>
<td>
<p>reports score for nonterminal upon encountering
values not observed during training, such as missing data.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_bagging">bagging</code></td>
<td>
<p>whether prediction is restricted to out-of-bag samples.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_nthread">nThread</code></td>
<td>
<p>suggests ans OpenMP-style thread count.  Zero denotes
default processor setting.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_verbose">verbose</code></td>
<td>
<p>whether to output progress of prediction.</p>
</td></tr>
<tr><td><code id="predict.rfArb_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of one of two classes:
</p>

<ul>
<li> <p><code>SummaryReg</code> summarizing regression, consisting of:
</p>

<ul>
<li> <p><code>prediction</code> an object of class <code>PredictReg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> the estimated numerical response.
</p>
</li>
<li> <p><code>qPred</code> quantiles of prediction, if requested.
</p>
</li>
<li> <p><code>qEst</code> quantile of the estimate, if quantiles requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li></ul>

</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidReg</code> consisting of:
</p>

<ul>
<li> <p><code>mse</code> the mean-squared error of the estimate.
</p>
</li>
<li> <p><code>rsq</code> the r-squared statistic of the estimate.
</p>
</li>
<li> <p><code>mae</code> the mean absolute error of the estimate.
</p>
</li></ul>

</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceReg</code>, containing multiple instances of:
</p>

<ul>
<li> <p><code>names</code> the predictor names.
</p>
</li>
<li> <p><code>mse</code> the per-predictor mean-squared error, under permutation.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>SummaryCtg</code> summarizing classification, consisting of:
</p>

<ul>
<li> <p><code>PredictCtg</code> consisting of:
</p>

<ul>
<li> <p><code>yPred</code> estimated categorical response.
</p>
</li>
<li> <p><code>census</code> factor-valued matrix of the estimate, by category, if requested.
</p>
</li>
<li> <p><code>prob</code> matrix of estimate probabilities, by category, if requested.
</p>
</li>
<li> <p><code>indices</code> final index of prediction, if requested.
</p>
</li></ul>

</li>
<li> <p><code>validation</code> if validation requested, an object of class <code>ValidCtg</code> consisting of:
</p>

<ul>
<li> <p><code>confusion</code> the confusion matrix.
</p>
</li>
<li> <p><code>misprediction</code> the misprediction rate.
</p>
</li>
<li> <p><code>oobError</code> the out-of-bag error.
</p>
</li></ul>

</li>
<li> <p><code>importance</code> if permution importance requested, an object of class <code>importanceCtg</code>, consisting of:
</p>

<ul>
<li> <p><code>mispred</code> the misprediction rate, by predictor.
</p>
</li>
<li> <p><code>oobErr</code> the out-of-bag error, by predictor.
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfTrain">rfTrain</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  pf &lt;- preformat(x)
  sp &lt;- presample(y)
  rb &lt;- rfArb(pf, sp, y)


  # Performs separate prediction on new data:
  xx &lt;- data.frame(replace(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  rb &lt;- Rborist(x,y)

  # Performs separate prediction on new data:
  xx &lt;- data.frame(replacate(6, rnorm(nRow)))
  pred &lt;- predict(rb, xx)
  yPred &lt;- pred$yPred

  # As above, but also records final indices of each tree walk:
  #
  pred &lt;- predict(rb, xx, indexing=TRUE)
  print(pred$indices[c(1:2), ])


  # As above, but predicts over \code{newdata} with unobserved values.
  # In the case of numerical data, only missing values are considered
  # unobserved.  Missing values are encoded as \code{NaN}, which are
  # incomparable, precipitating \code{false} on every test.  Prediction
  # therefore takes the \code{false} branch when encountering missing
  # values:
  #
  xxMissing &lt;- xx
  xxMissing[6, c(15, 32, 87, 101)] &lt;- NA
  pred &lt;- predict(rb, xxMissing)
  

  # As above, but returns a nonterminal score upon encountering
  # unobserved values. Neither the true nor the false branch from the
  # testing node is taken.  Instead, the score returned is derived
  # from all leaf nodes (terminals) reached by the testing
  # (nonterminal) node.
  #
  pred &lt;- predict(rb, xxMissing, trapUnobserved = TRUE)


  # Performs separate prediction, using original response as test
  # vector:
  pred &lt;- predict(rb, xx, y)
  mse &lt;- pred$mse
  rsq &lt;- pred$rsq


  # Performs separate prediction with (default) quantiles:
  pred &lt;- predict(rb, xx, quantiles="TRUE")
  qPred &lt;- pred$qPred


  # Performs separate prediction with deciles:
  pred &lt;- predict(rb, xx, quantVec = seq(0.1, 1.0, by = 0.10))
  qPred &lt;- pred$qPred


  # Classification examples:
  data(iris)
  rb &lt;- Rborist(iris[-5], iris[5])


  # Generic prediction using training set.
  # Census as (default) votes:
  pred &lt;- predict(rb, iris[-5])
  yPred &lt;- pred$yPred
  census &lt;- pred$census

  # Using the \code{keyedFrame} option allows the columns of
  # \code{newdata} to appear in arbitrary order, so long as the
  # columns present during training appear as a subset:
  #
  pred &lt;- predict(rb, iris[c(2, 4, 3, 1)], keyedFrame=TRUE)


  # As above, but validation census to report class probabilities:
  pred &lt;- predict(rb, iris[-5], ctgCensus="prob")
  prob &lt;- pred$prob


  # As above, but with training reponse as test vector:
  pred &lt;- predict(rb, iris[-5], iris[5], ctgCensus = "prob")
  prob &lt;- pred$prob
  conf &lt;- pred$confusion
  misPred &lt;- pred$misPred

  # As above, but predicts nonterminal when encountering categories
  # not observed during training.  That is, prediction returns a score
  # derived from all terminal nodes (leaves) reached from the
  # (nonterminal) testing node.
  #
  # In this case, "unobserved" refers to categories not present in
  # the subpartition over which a splitting is performed.  As training
  # partitions the data into smaller and smaller regions, a given
  # category becomes less likely to appear in a region.
  #
  # More generally, unobserved data can include missing predictors as
  # well as categories appearing in \code{newdata} which were not
  # present during training.
  #
  pred &lt;- predict(rb, trapUnobserved=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='preformat'>Preformatting for Training with Warm Starts</h2><span id='topic+preformat'></span><span id='topic+preformat.default'></span>

<h3>Description</h3>

<p>Presorts and formats training frame into a form suitable for
subsequent training by <code>rfArb</code> caller or <code>rfTrain</code>
command.  Wraps this form to spare unnecessary recomputation when
iteratively retraining, for example, under parameter sweep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
preformat(x,
		   nThread = 0,
                   verbose=FALSE,
                   ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preformat_+3A_x">x</code></td>
<td>
<p>the design frame expressed as either a <code>data.frame</code>
object with numeric and/or <code>factor</code> columns or as a numeric
or factor-valued matrix.</p>
</td></tr>
<tr><td><code id="preformat_+3A_nthread">nThread</code></td>
<td>
<p>number of cores to run in parallel, if available.</p>
</td></tr>
<tr><td><code id="preformat_+3A_verbose">verbose</code></td>
<td>
<p>indicates whether to output progress of
preformatting.</p>
</td></tr>
<tr><td><code id="preformat_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>Deframe</code> consisting of:
</p>

<ul>
<li> <p><code>rleFrame</code> run-length encoded representation of class <code>RLEFrame</code> consisting of:
</p>

<ul>
<li> <p><code>rankedFrame</code> run-length encoded representation of class <code>RankedFrame</code> consisting of:
</p>

<ul>
<li> <p><code>nRow</code> the number of observations encoded.
</p>
</li>
<li> <p><code>runVal</code> the run-length encoded values.
</p>
</li>
<li> <p><code>runRow</code> the corresponding row indices.
</p>
</li>
<li> <p><code>rleHeight</code> the number of encodings, per predictor.
</p>
</li>
<li> <p><code>topIdx</code> the accumulated end index, per predictor.
</p>
</li></ul>

</li>
<li> <p><code>numRanked</code> packed representation of sorted numerical values of class <code>NumRanked</code> consisting of:
</p>

<ul>
<li> <p><code>numVal</code> distinct numerical values.
</p>
</li>
<li> <p><code>numHeight</code> value offset per predictor.
</p>
</li></ul>

</li>
<li> <p><code>facRanked</code> packed representation of sorted factor
values of class <code>FacRanked</code> consisting of:
</p>

<ul>
<li> <p><code>facVal</code> distinct factor values, zero-based.
</p>
</li>
<li> <p><code>facHeight</code> value offset per predictor.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>nRow</code> the number of training observations.
</p>
</li>
<li> <p><code>signature</code> an object of type <code>Signature</code> consisting of:
</p>

<ul>
<li> <p><code>predForm</code> predictor class names.
</p>
</li>
<li> <p><code>level</code> per-predictor levels, regardless whether realized.
</p>
</li>
<li> <p><code>factor</code> per-predictor realized levels.
</p>
</li>
<li> <p><code>colNames</code> predictor names.
</p>
</li>
<li> <p><code>rowNames</code> observation names.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    data(iris)
    pt &lt;- preformat(iris[,-5])

    ppTry &lt;- seq(0.2, 0.5, by= 0.3/10)
    nIter &lt;- length(ppTry)
    rsq &lt;- numeric(nIter)
    for (i in 1:nIter) {
      rb &lt;- Rborist(pt, iris[,5], predProb=ppTry[i])
      rsq[i] = rb$validiation$rsq
    }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='presample'>Forest-wide Observation Sampling</h2><span id='topic+presample'></span><span id='topic+presample.default'></span>

<h3>Description</h3>

<p>Observations sampled for each tree to be trained.  In the case of the
Random Forest algorithm, this is the bag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
presample(y,
                            samplingWeight = numeric(0),
                            nSamp = 0,
                            nRep = 500,
                            withRepl =  TRUE,
                            nHoldout = 0,
                            nFold = 1,
                            verbose = FALSE,
                            nTree = 0,
                            ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="presample_+3A_y">y</code></td>
<td>
<p>A vector to be sampled, typically the response.</p>
</td></tr>
<tr><td><code id="presample_+3A_samplingweight">samplingWeight</code></td>
<td>
<p>Per-observation sampling weights.  Default is
uniform.</p>
</td></tr>
<tr><td><code id="presample_+3A_nsamp">nSamp</code></td>
<td>
<p>Size of sample draw.  Default draws <code>y</code> length.</p>
</td></tr>
<tr><td><code id="presample_+3A_nrep">nRep</code></td>
<td>
<p>Number of samples to draw.  Replaces deprecated <code>nTree</code>.</p>
</td></tr>
<tr><td><code id="presample_+3A_withrepl">withRepl</code></td>
<td>
<p>true iff sampling is with replacement.</p>
</td></tr>
<tr><td><code id="presample_+3A_nholdout">nHoldout</code></td>
<td>
<p>Number of observations to omit from sampling.
Augmented by unobserved response values.</p>
</td></tr>
<tr><td><code id="presample_+3A_nfold">nFold</code></td>
<td>
<p>Number of collections into which to partition the
respone.</p>
</td></tr>
<tr><td><code id="presample_+3A_verbose">verbose</code></td>
<td>
<p>true iff tracing execution.</p>
</td></tr>
<tr><td><code id="presample_+3A_ntree">nTree</code></td>
<td>
<p>Number of samples to draw.  Deprecated.</p>
</td></tr>
<tr><td><code id="presample_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>Sampler</code> consisting of:
</p>

<ul>
<li> <p><code>yTrain</code> the sampled vector.
</p>
</li>
<li> <p><code>nSamp</code> the sample sizes drawn.
</p>
</li>
<li> <p><code>nRep</code> the number of independent samples.
</p>
</li>
<li> <p><code>nTree</code> synonymous with <code>nRep</code>.  Deprecated.
</p>
</li>
<li> <p><code>samples</code> a packed data structure encoding the observation
index and corresponding sample count.
</p>
</li>
<li> <p><code>hash</code> a hashed digest of the data items.
</p>
</li></ul>



<h3>References</h3>

<p>Tille, Yves. Sampling algorithms. Springer New York, 2006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
    y &lt;- runif(1000)

    # Samples with replacement, 500 vectors of length 1000:
    ps &lt;- presample(y)

    # Samples, as above, with 63 observations held out:
    ps &lt;- presample(y, nHoldout = 63)

    # Samples without replacement, 250 vectors of length 500:
    ps2 &lt;- presample(y, nTree=250, nSamp=500, withRepl = FALSE)


  
## End(Not run)
</code></pre>

<hr>
<h2 id='Rborist'>Rapid Decision Tree Construction and Evaluation</h2><span id='topic+Rborist'></span><span id='topic+Rborist.default'></span>

<h3>Description</h3>

<p>Legacy entry for accelerated implementation of the
Random Forest (trademarked name) algorithm.  Calls the suggested
entry, <code>rfArb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
 Rborist(x,
              y,
              ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rborist_+3A_x">x</code></td>
<td>
<p> the design matrix expressed as a <code>PreFormat</code> object, as a
<code>data.frame</code> object with numeric and/or <code>factor</code> columns or
as a numeric matrix.</p>
</td></tr>
<tr><td><code id="Rborist_+3A_y">y</code></td>
<td>
<p> the response (outcome) vector, either numerical or
categorical.  Row count must conform with <code>x</code>.</p>
</td></tr>
<tr><td><code id="Rborist_+3A_...">...</code></td>
<td>
<p>specific to <code>rfArb</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rfArb</code>, as documented in command of the
same name.</p>


<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  # Classification example:
  data(iris)

  # Generic invocation:
  rb &lt;- Rborist(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='RboristNews'>NEWS Displayer for Rborist</h2><span id='topic+RboristNews'></span>

<h3>Description</h3>

<p>Displays NEWS associated with Rborist releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RboristNews()
</code></pre>


<h3>Value</h3>

<p>None.
</p>

<hr>
<h2 id='rfArb'>Rapid Decision Tree Construction and Evaluation</h2><span id='topic+rfArb'></span><span id='topic+rfArb.default'></span>

<h3>Description</h3>

<p>Accelerated implementation of the Random Forest (trademarked name)
algorithm.  Tuned for multicore and GPU hardware.  Bindable with most
numerical front-end languages in addtion to R.  Invocation is
similar to that provided by <em>randomForest</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
 rfArb(x,
                  y,
                autoCompress = 0.25,              
                ctgCensus = "votes",
                classWeight = numeric(0),
                discardState = FALSE,
                impPermute = 0,
                indexing = FALSE,
                maxLeaf = 0,
                minInfo = 0.01,
                minNode = if (is.factor(y)) 2 else 3,
                nHoldout = 0,
                nLevel = 0,
                nSamp = 0,
                nThread = 0,
                nTree = 500,
                noValidate = FALSE,
                predFixed = 0,
                predProb = 0.0,
                predWeight = numeric(0),
                quantVec = numeric(0),
                quantiles = length(quantVec) &gt; 0,
                regMono = numeric(0),
                rowWeight = numeric(0),
                samplingWeight = numeric(0),
                splitQuant = numeric(0),
                streamline = FALSE,
                thinLeaves = streamline || (is.factor(y) &amp;&amp; !indexing),
                trapUnobserved = FALSE,
                treeBlock = 1,
                verbose = FALSE,
                withRepl = TRUE,
                ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfArb_+3A_x">x</code></td>
<td>
<p> the design matrix expressed as a <code>PreFormat</code> object, as a
<code>data.frame</code> object with numeric and/or <code>factor</code> columns or
as a numeric matrix.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_y">y</code></td>
<td>
<p> the response (outcome) vector, either numerical or
categorical.  Row count must conform with <code>x</code>.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_autocompress">autoCompress</code></td>
<td>
<p>plurality above which to compress predictor values.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_ctgcensus">ctgCensus</code></td>
<td>
<p>report categorical validation by vote or by probability.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_classweight">classWeight</code></td>
<td>
<p>proportional weighting of classification
categories.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_discardstate">discardState</code></td>
<td>
<p>minimizes storage by discarding primary training
output.  Useful for parameter sweeps and cross-validation, in which
only validation may be of interest.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_imppermute">impPermute</code></td>
<td>
<p>number of importance permutations:  0 or 1.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_indexing">indexing</code></td>
<td>
<p>whether to report final index, typically terminal, of
validation tree traversal.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_maxleaf">maxLeaf</code></td>
<td>
<p>maximum number of leaves in a tree.  Zero denotes no limit.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_mininfo">minInfo</code></td>
<td>
<p>information ratio with parent below which node does not split.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_minnode">minNode</code></td>
<td>
<p>minimum number of distinct row references to split a
node.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_nholdout">nHoldout</code></td>
<td>
<p>number of observations to omit from sampling.
Augmented by missing response values.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_nlevel">nLevel</code></td>
<td>
<p>maximum number of tree levels to train, including
terminals (leaves).  Zero denotes no limit.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_nsamp">nSamp</code></td>
<td>
<p>number of rows to sample, per tree.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_nthread">nThread</code></td>
<td>
<p>suggests an OpenMP-style thread count.  Zero denotes
the default processor setting.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_ntree">nTree</code></td>
<td>
<p> the number of trees to train.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_novalidate">noValidate</code></td>
<td>
<p>whether to train without validation.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_predfixed">predFixed</code></td>
<td>
<p>number of trial predictors for a split (<code>mtry</code>).</p>
</td></tr>
<tr><td><code id="rfArb_+3A_predprob">predProb</code></td>
<td>
<p>probability of selecting individual predictor as trial splitter.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_predweight">predWeight</code></td>
<td>
<p>relative weighting of individual predictors as trial
splitters.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_quantvec">quantVec</code></td>
<td>
<p>quantile levels to validate.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_quantiles">quantiles</code></td>
<td>
<p>whether to report quantiles at validation.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_regmono">regMono</code></td>
<td>
<p>signed probability constraint for monotonic
regression.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_rowweight">rowWeight</code></td>
<td>
<p>row weighting for initial sampling of tree.  Deprecated</p>
</td></tr>
<tr><td><code id="rfArb_+3A_samplingweight">samplingWeight</code></td>
<td>
<p>row weighting for initial sampling of tree.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_splitquant">splitQuant</code></td>
<td>
<p>(sub)quantile at which to place cut point for
numerical splits</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="rfArb_+3A_streamline">streamline</code></td>
<td>
<p>whether to streamline sampler contents to save space.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_thinleaves">thinLeaves</code></td>
<td>
<p>bypasses creation of leaf state in order to reduce
storage footprint.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_trapunobserved">trapUnobserved</code></td>
<td>
<p>reports score for nonterminal upon encountering
values not observed during training, such as missing data.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_treeblock">treeBlock</code></td>
<td>
<p>maximum number of trees to train during a single
level (e.g., coprocessor computing).</p>
</td></tr>
<tr><td><code id="rfArb_+3A_verbose">verbose</code></td>
<td>
<p>indicates whether to output progress of training.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_withrepl">withRepl</code></td>
<td>
<p>whether row sampling is by replacement.</p>
</td></tr>
<tr><td><code id="rfArb_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object sharing classes <code>rfArb</code>, a supplementary collection
consisting of the following items:
</p>

<ul>
<li> <p><code>sampler</code> an object of class <code>Sampler</code>, as described in the
documentation for the <code>presample</code> command, that summarizes the
bagging structure.
</p>
</li>
<li> <p><code>training</code> a list summarizing the training task, consisting of the following fields:
</p>

<ul>
<li> <p><code>call</code> the calling invocation.
</p>
</li>
<li> <p><code>info</code> a vector of forest-wide Gini (classification) or weighted variance (regression), by predictor.
</p>
</li>
<li> <p><code>version</code> the version of the <code>Rborist</code> package used to train.
</p>
</li>
<li> <p><code>diag</code> diagnostics accumulated over the training task.
</p>
</li>
<li> <p><code>samplerHash</code> hash value of the <code>Sampler</code> object used to train.  Recorded for consistency of subsequent commands.
</p>
</li></ul>

</li>
<li> <p><code>prediction</code> an object of class <code>PredictReg</code> or <code>PredictCtg</code>, as described by the documention for command <code>predict</code>.
</p>
</li>
<li> <p><code>validation</code> an object of class <code>ValidReg</code> or <code>ValidCtg</code>, as described by the documention for command<code>validate</code>, if validation is requested.
</p>
</li>
<li> <p><code>importance</code> an object of class <code>ImportanceReg</code> or<code>ImportanceCtg</code>, as described by the documention for command	<code>predict</code>, if permutation performance has been requested.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>References</h3>

<p>Breiman, L. (2001) Random Forests, Machine Learning 45(1), 5-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rborist">Rborist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  # Classification example:
  data(iris)

  # Generic invocation:
  rb &lt;- rfArb(x, y)


  # Causes 300 trees to be trained:
  rb &lt;- rfArb(x, y, nTree = 300)


  # Causes rows to be sampled without replacement:
  rb &lt;- rfArb(x, y, withRepl=FALSE)


  # Causes validation census to report class probabilities:
  rb &lt;- rfArb(iris[-5], iris[5], ctgCensus="prob")


  # Applies table-weighting to classification categories:
  rb &lt;- rfArb(iris[-5], iris[5], classWeight = "balance")


  # Weights first category twice as heavily as remaining two:
  rb &lt;- rfArb(iris[-5], iris[5], classWeight = c(2.0, 1.0, 1.0))


  # Does not split nodes when doing so yields less than a 2% gain in
  # information over the parent node:
  rb &lt;- rfArb(x, y, minInfo=0.02)


  # Does not split nodes representing fewer than 10 unique samples:
  rb &lt;- rfArb(x, y, minNode=10)


  # Trains a maximum of 20 levels:
  rb &lt;- rfArb(x, y, nLevel = 20)


  # Trains, but does not perform subsequent validation:
  rb &lt;- rfArb(x, y, noValidate=TRUE)


  # Chooses 500 rows (with replacement) to root each tree.
  rb &lt;- rfArb(x, y, nSamp=500)


  # Chooses 2 predictors as splitting candidates at each node (or
  # fewer, when choices exhausted):
  rb &lt;- rfArb(x, y, predFixed = 2)  


  # Causes each predictor to be selected as a splitting candidate with
  # distribution Bernoulli(0.3):
  rb &lt;- rfArb(x, y, predProb = 0.3) 


  # Causes first three predictors to be selected as splitting candidates
  # twice as often as the other two:
  rb &lt;- rfArb(x, y, predWeight=c(2.0, 2.0, 2.0, 1.0, 1.0))


  # Causes (default) quantiles to be computed at validation:
  rb &lt;- rfArb(x, y, quantiles=TRUE)
  qPred &lt;- rb$validation$qPred


  # Causes specfied quantiles (deciles) to be computed at validation:
  rb &lt;- rfArb(x, y, quantVec = seq(0.1, 1.0, by = 0.10))
  qPred &lt;- rb$validation$qPred


  # Constrains modelled response to be increasing with respect to X1
  # and decreasing with respect to X5.
  rb &lt;- rfArb(x, y, regMono=c(1.0, 0, 0, 0, -1.0, 0))


  # Causes rows to be sampled with random weighting:
  rb &lt;- rfArb(x, y, samplingWeight=runif(nRow))


  # Suppresses creation of detailed leaf information needed for
  # quantile prediction and external tools.
  rb &lt;- rfArb(x, y, thinLeaves = TRUE)

  # Directs prediction to take a random branch on encountering
  # values not observed during training, such as NA or an
  # unrecognized category.

  predict(rb, trapUnobserved = FALSE)

  # Directs prediction to silently trap unobserved values, reporting a
  # score associated with the current nonterminal tree node.

  predict(rb, trapUnobserved = TRUE)

  # Sets splitting position for predictor 0 to far left and predictor
  # 1 to far right, others to default (median) position.

  spq &lt;- rep(0.5, ncol(x))
  spq[0] &lt;- 0.0
  spq[1] &lt;- 1.0
  rb &lt;- rfArb(x, y, splitQuant = spq)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='rfTrain'>Rapid Decision Tree Training</h2><span id='topic+rfTrain'></span><span id='topic+rfTrain.default'></span>

<h3>Description</h3>

<p>Accelerated training using the Random Forest (trademarked name)
algorithm.  Tuned for multicore and GPU hardware.  Bindable with most
numerical front-end languages in addtion to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
rfTrain(preFormat,
                 sampler,
                 y,
                autoCompress = 0.25,
                ctgCensus = "votes",
                classWeight = numeric(0),
                maxLeaf = 0,
                minInfo = 0.01,
                minNode = if (is.factor(y)) 2 else 3,
                nLevel = 0,
                nThread = 0,
                predFixed = 0,
                predProb = 0.0,
                predWeight = numeric(0),
                regMono = numeric(0),
                splitQuant = numeric(0),
                thinLeaves = FALSE,
                treeBlock = 1,
                verbose = FALSE,
                ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfTrain_+3A_y">y</code></td>
<td>
<p> the response (outcome) vector, either numerical or
categorical.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_preformat">preFormat</code></td>
<td>
<p>Compressed, presorted representation of the predictor
values. Row count must conform with <code>y</code>.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_sampler">sampler</code></td>
<td>
<p>Compressed representation of the sampled response.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_autocompress">autoCompress</code></td>
<td>
<p>plurality above which to compress predictor values.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_ctgcensus">ctgCensus</code></td>
<td>
<p>report categorical validation by vote or by probability.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_classweight">classWeight</code></td>
<td>
<p>proportional weighting of classification
categories.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_maxleaf">maxLeaf</code></td>
<td>
<p>maximum number of leaves in a tree.  Zero denotes no limit.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_mininfo">minInfo</code></td>
<td>
<p>information ratio with parent below which node does not split.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_minnode">minNode</code></td>
<td>
<p>minimum number of distinct row references to split a node.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_nlevel">nLevel</code></td>
<td>
<p>maximum number of tree levels to train, including
terminals (leaves).  Zero denotes no limit.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_nthread">nThread</code></td>
<td>
<p>suggests an <code>OpenMP</code>-style thread count.  Zero denotes
the default processor setting.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_predfixed">predFixed</code></td>
<td>
<p>number of trial predictors for a split (<code>mtry</code>).</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_predprob">predProb</code></td>
<td>
<p>probability of selecting individual predictor as trial splitter.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_predweight">predWeight</code></td>
<td>
<p>relative weighting of individual predictors as trial
splitters.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_regmono">regMono</code></td>
<td>
<p>signed probability constraint for monotonic
regression.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_splitquant">splitQuant</code></td>
<td>
<p>(sub)quantile at which to place cut point for
numerical splits</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code id="rfTrain_+3A_thinleaves">thinLeaves</code></td>
<td>
<p>bypasses creation of leaf state in order to reduce
memory footprint.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_treeblock">treeBlock</code></td>
<td>
<p>maximum number of trees to train during a single
level (e.g., coprocessor computing).</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_verbose">verbose</code></td>
<td>
<p>indicates whether to output progress of training.</p>
</td></tr>
<tr><td><code id="rfTrain_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>arbTrain</code>, containing:
</p>

<ul>
<li> <p><code>version</code> the version of the <code>Rborist</code> package used to train.
</p>
</li>
<li> <p><code>samplerHash</code> hash value of the <code>Sampler</code> object used to train.  Recorded for consistency of subsequent commands.
</p>
</li>
<li> <p><code>predInfo</code> a vector of forest-wide Gini (classification) or weighted
variance (regression), by predictor.
</p>
</li>
<li> <p><code>forest</code> an object of class <code>Forest</code> containing:
</p>

<ul>
<li> <p><code>nTree</code> the number of trees trained.
</p>
</li>
<li> <p><code>node</code> an object of class <code>Node</code> consisting of:
</p>

<ul>
<li> <p><code>treeNode</code> forest-wide vector of packed node representations.
</p>
</li>
<li> <p><code>extent</code> per-tree node counts.
</p>
</li>
<li> <p><code>scores</code> numeric vector of scores, for all terminals and nonterminals.
</p>
</li>
<li> <p><code>factor</code> an object of class <code>Factor</code> consisting of:
</p>

<ul>
<li> <p><code>facSplit</code> forest-wide vector of packed factor bits.
</p>
</li>
<li> <p><code>extent</code> per-tree extent of factor bits.
</p>
</li>
<li> <p><code>observed</code> forest-wide vector of observed factor bits.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>Leaf</code> an object of class <code>Leaf</code> containing:
</p>

<ul>
<li> <p><code>extent</code> forest-wide vector of leaf populations, i.e., counts of unique samples.
</p>
</li>
<li> <p><code>index</code> forest-wide vector of sample indices.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>diag</code> diagnostics accumulated over the training task.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rborist">Rborist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Regression example:
  nRow &lt;- 5000
  x &lt;- data.frame(replicate(6, rnorm(nRow)))
  y &lt;- with(x, X1^2 + sin(X2) + X3 * X4) # courtesy of S. Welling.

  # Classification example:
  data(iris)

  # Generic invocation:
  rt &lt;- rfTrain(y)


  # Causes 300 trees to be trained:
  rt &lt;- rfTrain(y, nTree = 300)


  # Causes validation census to report class probabilities:
  rt &lt;- rfTrain(iris[-5], iris[5], ctgCensus="prob")


  # Applies table-weighting to classification categories:
  rt &lt;- rfTrain(iris[-5], iris[5], classWeight = "balance")


  # Weights first category twice as heavily as remaining two:
  rt &lt;- rfTrain(iris[-5], iris[5], classWeight = c(2.0, 1.0, 1.0))


  # Does not split nodes when doing so yields less than a 2% gain in
  # information over the parent node:
  rt &lt;- rfTrain(y, preFormat, sampler, minInfo=0.02)


  # Does not split nodes representing fewer than 10 unique samples:
  rt &lt;- rfTrain(y, preFormat, sampler, minNode=10)


  # Trains a maximum of 20 levels:
  rt &lt;- rfTrain(y, preFormat, sampler, nLevel = 20)


  # Trains, but does not perform subsequent validation:
  rt &lt;- rfTrain(y, preFormat, sampler, noValidate=TRUE)


  # Chooses 500 rows (with replacement) to root each tree.
  rt &lt;- rfTrain(y, preFormat, sampler, nSamp=500)


  # Chooses 2 predictors as splitting candidates at each node (or
  # fewer, when choices exhausted):
  rt &lt;- rfTrain(y, preFormat, sampler, predFixed = 2)  


  # Causes each predictor to be selected as a splitting candidate with
  # distribution Bernoulli(0.3):
  rt &lt;- rfTrain(y, preFormat, sampler, predProb = 0.3) 


  # Causes first three predictors to be selected as splitting candidates
  # twice as often as the other two:
  rt &lt;- rfTrain(y, preFormat, sampler, predWeight=c(2.0, 2.0, 2.0, 1.0, 1.0))


  # Constrains modelled response to be increasing with respect to X1
  # and decreasing with respect to X5.
  rt &lt;- rfTrain(x, y, preFormat, sampler, regMono=c(1.0, 0, 0, 0, -1.0, 0))


  # Suppresses creation of detailed leaf information needed for
  # quantile prediction and external tools.
  rt &lt;- rfTrain(y, preFormat, sampler, thinLeaves = TRUE)

  spq &lt;- rep(0.5, ncol(x))
  spq[0] &lt;- 0.0
  spq[1] &lt;- 1.0
  rt &lt;- rfTrain(y, preFormat, sampler, splitQuant = spq)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Streamline.rfArb'>Reducing Memory Footprint of Trained Decision Forest</h2><span id='topic+Streamline.rfArb'></span><span id='topic+Streamline'></span>

<h3>Description</h3>

<p>Clears fields deemed no longer useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rfArb'
Streamline(arbOut)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Streamline.rfArb_+3A_arbout">arbOut</code></td>
<td>
<p>Trained forest object of class <code>rfArb</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rfArb</code> with sample data cleared.
</p>


<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    ## Trains.
    rs &lt;- Rborist(x, y)
    ...
    ## Replaces trained object with streamlined copy.
    rs &lt;- Streamline(rs)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='validate'>Separate Validation of Trained Decision Forest</h2><span id='topic+validate'></span><span id='topic+validate.default'></span>

<h3>Description</h3>

<p>Permits trained decision forest to be validated separately from training.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
validate(train, preFormat, sampler = NULL,  ctgCensus
= "votes", impPermute = 0, quantVec = numeric(0), quantiles =
length(quantVec) &gt; 0, indexing = FALSE, trapUnobserved = FALSE, nThread = 0, verbose =
FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_+3A_train">train</code></td>
<td>
<p>an object of class <code>Rborist</code> obtained from previous
training.</p>
</td></tr>
<tr><td><code id="validate_+3A_sampler">sampler</code></td>
<td>
<p>summarizes the response and its per-tree samplgin.</p>
</td></tr>
<tr><td><code id="validate_+3A_preformat">preFormat</code></td>
<td>
<p>internal representation of the design matrix, of
class <code>PreFormat</code></p>
</td></tr>
<tr><td><code id="validate_+3A_ctgcensus">ctgCensus</code></td>
<td>
<p>report categorical validation by vote or by probability.</p>
</td></tr>
<tr><td><code id="validate_+3A_imppermute">impPermute</code></td>
<td>
<p>specifies the number of importance permutations:  0
or 1.</p>
</td></tr>
<tr><td><code id="validate_+3A_quantvec">quantVec</code></td>
<td>
<p>quantile levels to validate.</p>
</td></tr>
<tr><td><code id="validate_+3A_quantiles">quantiles</code></td>
<td>
<p>whether to report quantiles at validation.</p>
</td></tr>
<tr><td><code id="validate_+3A_indexing">indexing</code></td>
<td>
<p>whether to report final index, typically terminal, of
tree traversal.</p>
</td></tr>
<tr><td><code id="validate_+3A_trapunobserved">trapUnobserved</code></td>
<td>
<p>indicates whether to return a nonterminal for
values unobserved during training, such as missing data.</p>
</td></tr>
<tr><td><code id="validate_+3A_nthread">nThread</code></td>
<td>
<p>suggests an OpenMP-style thread count.  Zero denotes
the default processor setting.</p>
</td></tr>
<tr><td><code id="validate_+3A_verbose">verbose</code></td>
<td>
<p>indicates whether to output progress of validation.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either of two pairs of objects:
</p>

<ul>
<li> <p><code>SummaryReg</code> summarizing regression, as documented with the
command <code>predict.arbTrain</code>.
</p>
</li>
<li> <p><code>validation</code> an object of class <code>ValidReg</code> consisting of:
</p>

<ul>
<li> <p><code>mse</code> the mean-square error of the estimate.
</p>
</li>
<li> <p><code>rsq</code> the r-squared statistic of the estimate.
</p>
</li>
<li> <p><code>mae</code> the mean absolute error of the estimate.
</p>
</li></ul>

</li></ul>


<ul>
<li> <p><code>SummaryCtg</code> summarizing classification, as documented with the
command <code>predict.arbTrain</code>.
</p>
</li>
<li> <p><code>validation</code> an object of class <code>ValidCtg</code> consisting of:
</p>

<ul>
<li> <p><code>confusion</code> the confusion matrix.
</p>
</li>
<li> <p><code>misprediction</code> the misprediction rate.
</p>
</li>
<li> <p><code>oobError</code> the out-of-bag error.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Mark Seligman at Suiji.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    ## Trains without validation.
    rb &lt;- Rborist(x, y, novalidate=TRUE)
    ...
    ## Delayed validation using a preformatted object.
    pf &lt;- preformat(x)
    v &lt;- validate(rb, pf)
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
