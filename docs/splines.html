<!DOCTYPE html><html><head><title>Help for package splines</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splines}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#splines-package'>
<p>Regression Spline Functions and Classes</p></a></li>
<li><a href='#asVector'><p>Coerce an Object to a Vector</p></a></li>
<li><a href='#backSpline'><p>Monotone Inverse Spline</p></a></li>
<li><a href='#bs'><p>B-Spline Basis for Polynomial Splines</p></a></li>
<li><a href='#interpSpline'><p>Create an Interpolation Spline</p></a></li>
<li><a href='#ns'><p>Generate a Basis Matrix for Natural Cubic Splines</p></a></li>
<li><a href='#periodicSpline'><p>Create a Periodic Interpolation Spline</p></a></li>
<li><a href='#polySpline'><p>Piecewise Polynomial Spline Representation</p></a></li>
<li><a href='#predict.bs'><p>Evaluate a Spline Basis</p></a></li>
<li><a href='#predict.bSpline'><p>Evaluate a Spline at New Values of x</p></a></li>
<li><a href='#splineDesign'><p>Design Matrix for B-splines</p></a></li>
<li><a href='#splineKnots'><p>Knot Vector from a Spline</p></a></li>
<li><a href='#splineOrder'><p>Determine the Order of a Spline</p></a></li>
<li><a href='#xyVector'><p>Construct an <code>xyVector</code> Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.5.0</td>
</tr>
<tr>
<td>Priority:</td>
<td>base</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Spline Functions and Classes</td>
</tr>
<tr>
<td>Author:</td>
<td>Douglas M. Bates &lt;bates@stat.wisc.edu&gt; and
 William N. Venables &lt;Bill.Venables@csiro.au&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R Core Team &lt;do-use-Contact-address@r-project.org&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>R-help mailing list &lt;r-help@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Regression spline functions and classes.</td>
</tr>
<tr>
<td>License:</td>
<td>Part of R 4.5.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.5.0; x86_64-pc-linux-gnu; 2024-04-11 08:10:00 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='splines-package'>
Regression Spline Functions and Classes
</h2><span id='topic+splines-package'></span><span id='topic+splines'></span>

<h3>Description</h3>

<p>Regression spline functions and classes.
</p>


<h3>Details</h3>

<p>This package provides functions for working with regression
splines using the B-spline basis, <code><a href="#topic+bs">bs</a></code>, and the
natural cubic spline basis, <code><a href="#topic+ns">ns</a></code>.
</p>
<p>For a complete list of functions, use <code>library(help = "splines")</code>.
</p>


<h3>Author(s)</h3>

<p>Douglas M. Bates <a href="mailto:bates@stat.wisc.edu">bates@stat.wisc.edu</a> and William N. Venables
<a href="mailto:Bill.Venables@csiro.au">Bill.Venables@csiro.au</a>
</p>
<p>Maintainer: R Core Team <a href="mailto:R-core@r-project.org">R-core@r-project.org</a>
</p>

<hr>
<h2 id='asVector'>Coerce an Object to a Vector</h2><span id='topic+asVector'></span>

<h3>Description</h3>

<p>This is a generic function.  Methods for this function coerce objects
of given classes to vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asVector(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asVector_+3A_object">object</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods for vector coercion in new classes must be created for the
<code>asVector</code> generic instead of <code>as.vector</code>.  The
<code>as.vector</code> function is internal and not easily extended.
Currently the only class with an <code>asVector</code> method is the
<code>xyVector</code> class.
</p>


<h3>Value</h3>

<p>a vector
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyVector">xyVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
ispl &lt;- interpSpline( weight ~ height,  women )
pred &lt;- predict(ispl)
class(pred)
utils::str(pred)
asVector(pred)
</code></pre>

<hr>
<h2 id='backSpline'>Monotone Inverse Spline</h2><span id='topic+backSpline'></span>

<h3>Description</h3>

<p>Create a monotone inverse of a monotone natural spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backSpline(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backSpline_+3A_object">object</code></td>
<td>
<p>an object that inherits from class <code>nbSpline</code> or
<code>npolySpline</code>.  That is, the object must represent a natural
interpolation spline but it can be either in the B-spline
representation or the piecewise polynomial one.  The spline is
checked to see if it represents a monotone function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>polySpline</code> that contains the piecewise
polynomial representation of a function that has the appropriate
values and derivatives at the knot positions to be an inverse of the
spline represented by <code>object</code>.  Technically this object is not a
spline because the second derivative is not constrained to be
continuous at the knot positions.  However, it is often a much better
approximation to the inverse than fitting an interpolation spline to
the y/x pairs.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpSpline">interpSpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
ispl &lt;- interpSpline( women$height, women$weight )
bspl &lt;- backSpline( ispl )
plot( bspl )                   # plots over the range of the knots
points( women$weight, women$height )
</code></pre>

<hr>
<h2 id='bs'>B-Spline Basis for Polynomial Splines</h2><span id='topic+bs'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for a polynomial spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs(x, df = NULL, knots = NULL, degree = 3, intercept = FALSE,
   Boundary.knots = range(x), warn.outside = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bs_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="bs_+3A_df">df</code></td>
<td>
<p>degrees of freedom; one can specify <code>df</code> rather than
<code>knots</code>; <code>bs()</code> then chooses <code>df-degree</code> (minus one
if there is an intercept) knots at suitable quantiles of <code>x</code>
(which will ignore missing values).  The default, <code>NULL</code>,
takes the number of inner knots as <code>length(knots)</code>.  If that is
zero as per default, that corresponds to <code>df = degree - intercept</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_knots">knots</code></td>
<td>
<p>the <em>internal</em> breakpoints that define the
spline.  The default is <code>NULL</code>, which results in a basis for
ordinary polynomial regression.  Typical values are the mean or
median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial&mdash;default is <code>3</code> for
cubic splines.</p>
</td></tr>
<tr><td><code id="bs_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to anchor the B-spline
basis (default the range of the non-<code><a href="base.html#topic+NA">NA</a></code> data).  If both
<code>knots</code> and <code>Boundary.knots</code> are supplied, the basis
parameters do not depend on <code>x</code>.  Data can extend beyond
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="bs_+3A_warn.outside">warn.outside</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if a
<code><a href="base.html#topic+warning">warning</a></code> should be signalled in case some <code>x</code> values
are outside the boundary knots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bs</code> is based on the function <code><a href="#topic+splineDesign">splineDesign</a></code>.
It generates a basis matrix for
representing the family of piecewise polynomials with the specified
interior knots and degree, evaluated at the values of <code>x</code>.  A
primary use is in modeling formulas to directly specify a piecewise
polynomial term in a model.
</p>
<p>When <code>Boundary.knots</code> are set <em>inside</em> <code>range(x)</code>,
<code>bs()</code> now uses a &lsquo;pivot&rsquo; inside the respective boundary
knot which is important for derivative evaluation.  In <span class="rlang"><b>R</b></span> versions
<code class="reqn">\le</code> 3.2.2, the boundary knot itself had been used as
pivot, which lead to somewhat wrong extrapolations.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>c(length(x), df)</code>, where either <code>df</code>
was supplied or if <code>knots</code> were supplied, <code>df =
  length(knots) + degree</code> plus one if there is an intercept.  Attributes
are returned that correspond to the arguments to <code>bs</code>, and
explicitly give the <code>knots</code>, <code>Boundary.knots</code> etc for use by
<code>predict.bs()</code>.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables.  Tweaks by R Core, and a patch
fixing extrapolation &ldquo;outside&rdquo; <code>Boundary.knots</code> by Trevor
Hastie.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992)
Generalized additive models.
Chapter 7 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ns">ns</a></code>, <code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="#topic+predict.bs">predict.bs</a></code>, <code><a href="stats.html#topic+SafePrediction">SafePrediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics)
bs(women$height, df = 5)
summary(fm1 &lt;- lm(weight ~ bs(height, df = 5), data = women))

## example of safe prediction
plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
ht &lt;- seq(57, 73, length.out = 200)
lines(ht, predict(fm1, data.frame(height = ht)))
</code></pre>

<hr>
<h2 id='interpSpline'>Create an Interpolation Spline</h2><span id='topic+interpSpline'></span>

<h3>Description</h3>

<p>Create an interpolation spline, either from <code>x</code> and <code>y</code>
vectors (<code>default</code> method), or from a <code>formula</code> / <code>data.frame</code>
combination (<code>formula</code> method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpSpline(obj1, obj2, bSpline = FALSE, period = NULL,
             ord = 4L,
             na.action = na.fail, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpSpline_+3A_obj1">obj1</code></td>
<td>
<p>either a numeric vector of <code>x</code> values or a formula.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_obj2">obj2</code></td>
<td>
<p>if <code>obj1</code> is numeric this should be a numeric vector
of the same length.  If <code>obj1</code> is a formula this can be an
optional data frame in which to evaluate the names in the formula.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_bspline">bSpline</code></td>
<td>
<p>if <code>TRUE</code> the b-spline representation is returned,
otherwise the piecewise polynomial representation is returned.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_period">period</code></td>
<td>
<p>an optional positive numeric value giving a period for a
periodic interpolation spline.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_ord">ord</code></td>
<td>
<p>an integer specifying the spline <em>order</em>, the number of
coefficients per interval.  <code class="reqn">ord = d+1</code> where <code class="reqn">d</code> is the
<em>degree</em> polynomial degree.  Currently, only cubic splines
(<code>ord = 4</code>) are implemented.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_na.action">na.action</code></td>
<td>
<p>a optional function which indicates what should happen
when the data contain <code>NA</code>s.  The default action
(<code>na.omit</code>) is to omit any incomplete observations.  The
alternative action <code>na.fail</code> causes <code>interpSpline</code> to print
an error message and terminate if there are any incomplete
observations.</p>
</td></tr>
<tr><td><code id="interpSpline_+3A_sparse">sparse</code></td>
<td>
<p>logical passed to the underlying
<code><a href="#topic+splineDesign">splineDesign</a></code>.  If true, saves memory and is faster when
there are more than a few hundred points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that inherits from (S3) class <code>spline</code>. The object can be in
the B-spline representation, in which case it will be of class
<code>nbSpline</code> for natural B-spline, or in the piecewise polynomial
representation, in which case it will be of class <code>npolySpline</code>.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+splineKnots">splineKnots</a></code>,
<code><a href="#topic+splineOrder">splineOrder</a></code>,
<code><a href="#topic+periodicSpline">periodicSpline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(graphics); require(stats)
ispl &lt;- interpSpline( women$height, women$weight )
ispl2 &lt;- interpSpline( weight ~ height,  women )
# ispl and ispl2 should be the same
plot( predict( ispl, seq( 55, 75, length.out = 51 ) ), type = "l" )
points( women$height, women$weight )
plot( ispl )    # plots over the range of the knots
points( women$height, women$weight )
splineKnots( ispl )
</code></pre>

<hr>
<h2 id='ns'>Generate a Basis Matrix for Natural Cubic Splines</h2><span id='topic+ns'></span>

<h3>Description</h3>

<p>Generate the B-spline basis matrix for a natural cubic spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ns(x, df = NULL, knots = NULL, intercept = FALSE,
   Boundary.knots = range(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ns_+3A_x">x</code></td>
<td>
<p>the predictor variable.  Missing values are allowed.</p>
</td></tr>
<tr><td><code id="ns_+3A_df">df</code></td>
<td>
<p>degrees of freedom.  One can supply <code>df</code> rather than
knots; <code>ns()</code> then chooses <code>df - 1 - intercept</code> knots at
suitably chosen quantiles of <code>x</code> (which will ignore missing
values).  The default, <code>df = NULL</code>, sets the number of
inner knots as <code>length(knots)</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_knots">knots</code></td>
<td>
<p>breakpoints that define the spline.  The default is no
knots; together with the natural boundary conditions this results in
a basis for linear regression on <code>x</code>.  Typical values are the
mean or median for one knot, quantiles for more knots.  See also
<code>Boundary.knots</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_intercept">intercept</code></td>
<td>
<p>if <code>TRUE</code>, an intercept is included in the
basis; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ns_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to impose the natural
boundary conditions and anchor the B-spline basis (default the range
of the data).  If both <code>knots</code> and <code>Boundary.knots</code> are
supplied, the basis parameters do not depend on <code>x</code>. Data can
extend beyond <code>Boundary.knots</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ns</code> is based on the function <code><a href="#topic+splineDesign">splineDesign</a></code>.  It
generates a basis matrix for representing the family of
piecewise-cubic splines with the specified sequence of
interior knots, and the natural boundary conditions.  These enforce
the constraint that the function is linear beyond the boundary knots,
which can either be supplied or default to the extremes of the
data.
</p>
<p>A primary use is in modeling formula to directly specify a
natural spline term in a model: see the examples.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>length(x) * df</code> where either <code>df</code> was
supplied or if <code>knots</code> were supplied,
<code>df = length(knots) + 1 + intercept</code>.
Attributes are returned that correspond to the arguments to <code>ns</code>,
and explicitly give the <code>knots</code>, <code>Boundary.knots</code> etc for
use by <code>predict.ns()</code>.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992)
Generalized additive models.
Chapter 7 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bs">bs</a></code>, <code><a href="#topic+predict.ns">predict.ns</a></code>, <code><a href="stats.html#topic+SafePrediction">SafePrediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics)
ns(women$height, df = 5)
summary(fm1 &lt;- lm(weight ~ ns(height, df = 5), data = women))

## To see what knots were selected
attr(terms(fm1), "predvars")

## example of safe prediction
plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
ht &lt;- seq(57, 73, length.out = 200) ; nD &lt;- data.frame(height = ht)
lines(ht, p1 &lt;- predict(fm1, nD))
stopifnot(all.equal(p1, predict(update(fm1, . ~
                            splines::ns(height, df=5)), nD)))
          # not true in R &lt; 3.5.0

</code></pre>

<hr>
<h2 id='periodicSpline'>Create a Periodic Interpolation Spline</h2><span id='topic+periodicSpline'></span>

<h3>Description</h3>

<p>Create a periodic interpolation spline, either from <code>x</code> and
<code>y</code> vectors, or from a formula/data.frame combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodicSpline(obj1, obj2, knots, period = 2*pi, ord = 4L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodicSpline_+3A_obj1">obj1</code></td>
<td>
<p>either a numeric vector of <code>x</code> values or a formula.</p>
</td></tr>
<tr><td><code id="periodicSpline_+3A_obj2">obj2</code></td>
<td>
<p>if <code>obj1</code> is numeric this should be a numeric vector
of the same length.  If <code>obj1</code> is a formula this can be an
optional data frame in which to evaluate the names in the formula.</p>
</td></tr>
<tr><td><code id="periodicSpline_+3A_knots">knots</code></td>
<td>
<p>optional numeric vector of knot positions.</p>
</td></tr>
<tr><td><code id="periodicSpline_+3A_period">period</code></td>
<td>
<p>positive numeric value giving the period for the
periodic spline.  Defaults to <code>2 * pi</code>.</p>
</td></tr>
<tr><td><code id="periodicSpline_+3A_ord">ord</code></td>
<td>
<p>integer giving the order of the spline, at least 2.  Defaults
to 4.  See <code><a href="#topic+splineOrder">splineOrder</a></code> for a definition of the order of
a spline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that inherits from class <code>spline</code>.  The object can be in
the B-spline representation, in which case it will be a
<code>pbSpline</code> object, or in the piecewise polynomial representation
(a <code>ppolySpline</code> object).
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+splineKnots">splineKnots</a></code>,
<code><a href="#topic+interpSpline">interpSpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics); require(stats)
xx &lt;- seq( -pi, pi, length.out = 16 )[-1]
yy &lt;- sin( xx )
frm &lt;- data.frame( xx, yy )
pispl &lt;- periodicSpline( xx, yy, period = 2 * pi)
pispl
pispl2 &lt;- periodicSpline( yy ~ xx, frm, period = 2 * pi )
stopifnot(all.equal(pispl, pispl2))  # pispl and pispl2 are the same

plot( pispl )          # displays over one period
points( yy ~ xx, col = "brown")
plot( predict( pispl, seq(-3*pi, 3*pi, length.out = 101) ), type = "l" )
</code></pre>

<hr>
<h2 id='polySpline'>Piecewise Polynomial Spline Representation</h2><span id='topic+polySpline'></span><span id='topic+as.polySpline'></span>

<h3>Description</h3>

<p>Create the piecewise polynomial representation of a spline object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polySpline(object, ...)
as.polySpline(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polySpline_+3A_object">object</code></td>
<td>
<p>An object that inherits from class <code>spline</code>.</p>
</td></tr>
<tr><td><code id="polySpline_+3A_...">...</code></td>
<td>
<p>Optional additional arguments.  At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object that inherits from class <code>polySpline</code>.  This is the
piecewise polynomial representation of a univariate spline function.
It is defined by a set of distinct numeric values called knots.  The
spline function is a polynomial function between each successive pair
of knots.  At each interior knot the polynomial segments on each side
are constrained to have the same value of the function and some of its
derivatives.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+interpSpline">interpSpline</a></code>,
<code><a href="#topic+periodicSpline">periodicSpline</a></code>,
<code><a href="#topic+splineKnots">splineKnots</a></code>,
<code><a href="#topic+splineOrder">splineOrder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
ispl &lt;- polySpline(interpSpline( weight ~ height,  women, bSpline = TRUE))

print( ispl )   # print the piecewise polynomial representation

plot( ispl )    # plots over the range of the knots
points( women$height, women$weight )
</code></pre>

<hr>
<h2 id='predict.bs'>Evaluate a Spline Basis</h2><span id='topic+predict.bs'></span><span id='topic+predict.ns'></span>

<h3>Description</h3>

<p>Evaluate a predefined spline basis at given values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bs'
predict(object, newx, ...)

## S3 method for class 'ns'
predict(object, newx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bs_+3A_object">object</code></td>
<td>
<p>the result of a call to <code><a href="#topic+bs">bs</a></code> or
<code><a href="#topic+ns">ns</a></code> having attributes describing <code>knots</code>,
<code>degree</code>, etc.</p>
</td></tr>
<tr><td><code id="predict.bs_+3A_newx">newx</code></td>
<td>
<p>the <code>x</code> values at which evaluations are required.</p>
</td></tr>
<tr><td><code id="predict.bs_+3A_...">...</code></td>
<td>
<p>Optional additional arguments.  At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object just like <code>object</code>, except evaluated at the new values
of <code>x</code>.
</p>
<p>These are methods for the generic function <code><a href="stats.html#topic+predict">predict</a></code> for
objects inheriting from classes <code>"bs"</code> or <code>"ns"</code>.  See
<code><a href="stats.html#topic+predict">predict</a></code> for the general behavior of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bs">bs</a></code>, <code><a href="#topic+ns">ns</a></code>, <code><a href="stats.html#topic+poly">poly</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
basis &lt;- ns(women$height, df = 5)
newX &lt;- seq(58, 72, length.out = 51)
# evaluate the basis at the new data
predict(basis, newX)
</code></pre>

<hr>
<h2 id='predict.bSpline'>Evaluate a Spline at New Values of x</h2><span id='topic+predict.bSpline'></span><span id='topic+predict.nbSpline'></span><span id='topic+predict.pbSpline'></span><span id='topic+predict.npolySpline'></span><span id='topic+predict.ppolySpline'></span>

<h3>Description</h3>

<p>The <code>predict</code> methods for the classes that inherit from the
virtual classes <code>bSpline</code> and <code>polySpline</code> are used to
evaluate the spline or its derivatives.  The <code>plot</code> method for a
spline object first evaluates <code>predict</code> with the <code>x</code>
argument missing, then plots the resulting <code>xyVector</code> with
<code>type = "l"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bSpline'
predict(object, x, nseg = 50, deriv = 0, ...)
## S3 method for class 'nbSpline'
predict(object, x, nseg = 50, deriv = 0, ...)
## S3 method for class 'pbSpline'
predict(object, x, nseg = 50, deriv = 0, ...)
## S3 method for class 'npolySpline'
predict(object, x, nseg = 50, deriv = 0, ...)
## S3 method for class 'ppolySpline'
predict(object, x, nseg = 50, deriv = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bSpline_+3A_object">object</code></td>
<td>
<p>An object that inherits from the <code>bSpline</code> or the
<code>polySpline</code> class.</p>
</td></tr>
<tr><td><code id="predict.bSpline_+3A_x">x</code></td>
<td>
<p>A numeric vector of <code>x</code> values at which to evaluate the
spline.  If this argument is missing a suitable set of <code>x</code>
values is generated as a sequence of <code>nseq</code> segments spanning
the range of the knots.</p>
</td></tr>
<tr><td><code id="predict.bSpline_+3A_nseg">nseg</code></td>
<td>
<p>A positive integer giving the number of segments in a set
of equally-spaced <code>x</code> values spanning the range of the knots
in <code>object</code>.  This value is only used if <code>x</code> is missing.</p>
</td></tr>
<tr><td><code id="predict.bSpline_+3A_deriv">deriv</code></td>
<td>
<p>An integer between 0 and <code>splineOrder(object) - 1</code>
specifying the derivative to evaluate.</p>
</td></tr>
<tr><td><code id="predict.bSpline_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>xyVector</code> with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the supplied or inferred numeric vector of <code>x</code> values</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the value of the spline (or its <code>deriv</code>'th derivative)
at the <code>x</code> vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyVector">xyVector</a></code>,
<code><a href="#topic+interpSpline">interpSpline</a></code>,
<code><a href="#topic+periodicSpline">periodicSpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics); require(stats)
ispl &lt;- interpSpline( weight ~ height,  women )
opar &lt;- par(mfrow = c(2, 2), las = 1)
plot(predict(ispl, nseg = 201),     # plots over the range of the knots
     main = "Original data with interpolating spline", type = "l",
     xlab = "height", ylab = "weight")
points(women$height, women$weight, col = 4)
plot(predict(ispl, nseg = 201, deriv = 1),
     main = "First derivative of interpolating spline", type = "l",
     xlab = "height", ylab = "weight")
plot(predict(ispl, nseg = 201, deriv = 2),
     main = "Second derivative of interpolating spline", type = "l",
     xlab = "height", ylab = "weight")
plot(predict(ispl, nseg = 401, deriv = 3),
     main = "Third derivative of interpolating spline", type = "l",
     xlab = "height", ylab = "weight")
par(opar)
</code></pre>

<hr>
<h2 id='splineDesign'>Design Matrix for B-splines</h2><span id='topic+splineDesign'></span><span id='topic+spline.des'></span>

<h3>Description</h3>

<p>Evaluate the design matrix for the B-splines defined by <code>knots</code>
at the values in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineDesign(knots, x, ord = 4, derivs, outer.ok = FALSE,
             sparse = FALSE)
spline.des  (knots, x, ord = 4, derivs, outer.ok = FALSE,
             sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineDesign_+3A_knots">knots</code></td>
<td>
<p>a numeric vector of knot positions (which will be sorted
increasingly if needed).</p>
</td></tr>
<tr><td><code id="splineDesign_+3A_x">x</code></td>
<td>
<p>a numeric vector of values at which to evaluate the B-spline
functions or derivatives.  Unless <code>outer.ok</code> is true, the
values in <code>x</code> must be between the &ldquo;inner&rdquo; knots
<code>knots[ord]</code> and <code>knots[ length(knots) - (ord-1)]</code>.</p>
</td></tr>
<tr><td><code id="splineDesign_+3A_ord">ord</code></td>
<td>
<p>a positive integer giving the order of the spline function.
This is the number of coefficients in each piecewise polynomial
segment, thus a cubic spline has order 4.  Defaults to 4.</p>
</td></tr>
<tr><td><code id="splineDesign_+3A_derivs">derivs</code></td>
<td>
<p>an integer vector with values between <code>0</code> and
<code>ord - 1</code>, conceptually recycled to the length of <code>x</code>.
The derivative of the given order is evaluated at the <code>x</code>
positions.  Defaults to zero (or a vector of zeroes of the same
length as <code>x</code>).</p>
</td></tr>
<tr><td><code id="splineDesign_+3A_outer.ok">outer.ok</code></td>
<td>
<p>logical indicating if <code>x</code> should be allowed
outside the <em>inner</em> knots, see the <code>x</code> argument.</p>
</td></tr>
<tr><td><code id="splineDesign_+3A_sparse">sparse</code></td>
<td>
<p>logical indicating if the result should inherit from class
<code>"<a href="Matrix.html#topic+sparseMatrix-class">sparseMatrix</a>"</code> (from package <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>length(x)</code> rows and <code>length(knots) - ord</code>
columns.  The i-th row of the matrix contains the coefficients of the
B-splines (or the indicated derivative of the B-splines) defined by
the <code>knot</code> vector and evaluated at the i-th value of <code>x</code>.
Each B-spline is defined by a set of <code>ord</code> successive knots so
the total number of B-splines is <code>length(knots) - ord</code>.
</p>


<h3>Note</h3>

<p>The older <code>spline.des</code> function takes the same arguments but
returns a list with several components including <code>knots</code>,
<code>ord</code>, <code>derivs</code>, and <code>design</code>.  The <code>design</code>
component is the same as the value of the <code>splineDesign</code>
function.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)
splineDesign(knots = 1:10, x = 4:7)
splineDesign(knots = 1:10, x = 4:7, derivs = 1)
## visualize band structure
Matrix::drop0(zapsmall(6*splineDesign(knots = 1:40, x = 4:37, sparse = TRUE)))

knots &lt;- c(1,1.8,3:5,6.5,7,8.1,9.2,10)  # 10 =&gt; 10-4 = 6 Basis splines
x &lt;- seq(min(knots)-1, max(knots)+1, length.out = 501)
bb &lt;- splineDesign(knots, x = x, outer.ok = TRUE)

plot(range(x), c(0,1), type = "n", xlab = "x", ylab = "",
     main =  "B-splines - sum to 1 inside inner knots")
mtext(expression(B[j](x) *"  and "* sum(B[j](x), j == 1, 6)), adj = 0)
abline(v = knots, lty = 3, col = "light gray")
abline(v = knots[c(4,length(knots)-3)], lty = 3, col = "gray10")
lines(x, rowSums(bb), col = "gray", lwd = 2)
matlines(x, bb, ylim = c(0,1), lty = 1)
</code></pre>

<hr>
<h2 id='splineKnots'>Knot Vector from a Spline</h2><span id='topic+splineKnots'></span>

<h3>Description</h3>

<p>Return the knot vector corresponding to a spline object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineKnots(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineKnots_+3A_object">object</code></td>
<td>
<p>an object that inherits from class <code>"spline"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A non-decreasing numeric vector of knot positions.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>Examples</h3>

<pre><code class='language-R'>ispl &lt;- interpSpline( weight ~ height, women )
splineKnots( ispl )
</code></pre>

<hr>
<h2 id='splineOrder'>Determine the Order of a Spline</h2><span id='topic+splineOrder'></span>

<h3>Description</h3>

<p>Return the order of a spline object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineOrder(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineOrder_+3A_object">object</code></td>
<td>
<p>An object that inherits from class <code>"spline"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of a spline is the number of coefficients in each piece of
the piecewise polynomial representation.  Thus a cubic spline has
order 4.
</p>


<h3>Value</h3>

<p>A positive integer.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>See Also</h3>

<p><code><a href="#topic+splineKnots">splineKnots</a></code>,
<code><a href="#topic+interpSpline">interpSpline</a></code>,
<code><a href="#topic+periodicSpline">periodicSpline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splineOrder( interpSpline( weight ~ height, women ) )
</code></pre>

<hr>
<h2 id='xyVector'>Construct an <code>xyVector</code> Object</h2><span id='topic+xyVector'></span>

<h3>Description</h3>

<p>Create an object to represent a set of x-y pairs.  The resulting
object can be treated as a matrix or as a data frame or as a vector.
When treated as a vector it reduces to the <code>y</code> component only.
</p>
<p>The result of functions such as <code>predict.spline</code> is returned as
an <code>xyVector</code> object so the x-values used to generate the
y-positions are retained, say for purposes of generating plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyVector(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyVector_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="xyVector_+3A_y">y</code></td>
<td>
<p>a numeric vector of the same length as <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>xyVector</code> with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a numeric vector of the same length as <code>x</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Douglas Bates and Bill Venables</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats); require(graphics)
ispl &lt;- interpSpline( weight ~ height, women )
weights &lt;- predict( ispl, seq( 55, 75, length.out = 51 ))
class( weights )
plot( weights, type = "l", xlab = "height", ylab = "weight" )
points( women$height, women$weight )
weights
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
