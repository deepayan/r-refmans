<!DOCTYPE html><html lang="en"><head><title>Help for package hexView</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hexView}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.character.rawBlock'><p> Convert Block of Binary Data into Strings</p></a></li>
<li><a href='#as.character.rawFormat'><p> Convert Binary File Format into Strings</p></a></li>
<li><a href='#atomicBlock'><p> Create an atomicBlock Object</p></a></li>
<li><a href='#blockValue'><p> Extract the Value of a Binary Block</p></a></li>
<li><a href='#hexViewFile'><p> Specify an Example File</p></a></li>
<li><a href='#markedBlock'><p> Create a markedBlock Object</p></a></li>
<li><a href='#memBlock'><p> Create a memBlock Object</p></a></li>
<li><a href='#memFormat'><p> Create a memFormat Object</p></a></li>
<li><a href='#mixedBlock'><p> Create a mixedBlock Object</p></a></li>
<li><a href='#print.rawBlock'><p> Print Method for Block of Binary Data</p></a></li>
<li><a href='#print.rawFormat'><p> Print Method for Binary File Format</p></a></li>
<li><a href='#readEViews'><p> Read an Eviews File</p></a></li>
<li><a href='#readFormat'><p> Read a Binary File</p></a></li>
<li><a href='#readRaw'><p>Read the Raw Binary Content of a File</p></a></li>
<li><a href='#vectorBlock'><p> Create a vectorBlock Object</p></a></li>
<li><a href='#viewFormat'><p> View a Binary File</p></a></li>
<li><a href='#viewRaw'><p>View the Raw Binary Content of a File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-4</td>
</tr>
<tr>
<td>Title:</td>
<td>Viewing Binary Files</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to view files in raw binary form like in a hex editor.  Additional functions to specify and read arbitrary binary formats.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-13 01:16:15 UTC; pmur002</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Murrell [aut, cre],
  Chao Bian [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Murrell &lt;paul@stat.auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-13 06:20:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.character.rawBlock'> Convert Block of Binary Data into Strings </h2><span id='topic+as.character.rawBlock'></span>

<h3>Description</h3>

<p>This function takes a <code>"rawBlock"</code> object and
generates human-readable strings for displaying the block.
Each string contains a binary offset, the binary data
in a raw machine format, and an interpretation of
the data in a human-readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rawBlock'
as.character(x, width = NULL, machine = NULL,
             sep1 = "  :  ", sep2 = "  |  ",
             showOffset = TRUE, showHuman = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.rawBlock_+3A_x">x</code></td>
<td>
<p> A <code>"rawBlock"</code> object. </p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_width">width</code></td>
<td>
<p> The number of bytes to display per string. </p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_machine">machine</code></td>
<td>
<p> The machine format to display;
either <code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_sep1">sep1</code></td>
<td>
<p> A separator to insert between the block offset
and the machine format.</p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_sep2">sep2</code></td>
<td>
<p> A separator to insert between the machine format
and the human-readable format.</p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_showoffset">showOffset</code></td>
<td>
<p> If <code>FALSE</code>, the column of offsets is
not included in the strings.</p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_showhuman">showHuman</code></td>
<td>
<p> If <code>FALSE</code>, the column of human-readable format is
not included in the strings.</p>
</td></tr>
<tr><td><code id="as.character.rawBlock_+3A_...">...</code></td>
<td>
<p> Other arguments to <code>as.character</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>width</code> or <code>machine</code> is <code>NULL</code>,
the relevant value is taken from the
<code>"rawBlock"</code> object.  The human-readable format is
taken from the <code>"rawBlock"</code> object.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+readRaw">readRaw</a></code>
<code><a href="#topic+print.rawBlock">print.rawBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileBlock &lt;- readRaw(hexViewFile("rawTest.txt"), width=8)
as.character(fileBlock)
</code></pre>

<hr>
<h2 id='as.character.rawFormat'> Convert Binary File Format into Strings </h2><span id='topic+as.character.rawFormat'></span>

<h3>Description</h3>

<p>This function takes a <code>"rawFormat"</code> object and
generates human-readable strings for displaying the format.
Each string contains a binary offset, the binary data
in a raw machine format, and an interpretation of
the data in a human-readable format.  The format
consists of one or more sub-blocks and a heading line
is added for each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rawFormat'
as.character(x, sep1 = "  :  ", sep2 = "  |  ",
                blockHead = TRUE, blockChar = "=", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.rawFormat_+3A_x">x</code></td>
<td>
<p> A <code>"rawFormat"</code> object. </p>
</td></tr>
<tr><td><code id="as.character.rawFormat_+3A_sep1">sep1</code></td>
<td>
<p> A separator to insert between the format offset
and the machine format.</p>
</td></tr>
<tr><td><code id="as.character.rawFormat_+3A_sep2">sep2</code></td>
<td>
<p> A separator to insert between the machine format
and the human-readable format.</p>
</td></tr>
<tr><td><code id="as.character.rawFormat_+3A_blockhead">blockHead</code></td>
<td>
<p> A logical indicating whether to print
a header between blocks of the format. </p>
</td></tr>
<tr><td><code id="as.character.rawFormat_+3A_blockchar">blockChar</code></td>
<td>
<p> The character used as a prefix to
the block names for printing headers between blocks. </p>
</td></tr>
<tr><td><code id="as.character.rawFormat_+3A_...">...</code></td>
<td>
<p> Other arguments to <code>as.character</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information on the number of bytes on each line, the machine representation
of each byte and the human-readable format are all taken from the
taken from the <code>"rawBlock"</code> elements of the <code>"rawFormat"</code>
object.   Consequently each block can have a quite different
appearance.  Considerable effort is made to line up the separators
across all blocks within the format.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+print.rawFormat">print.rawFormat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileFormat &lt;- readFormat(hexViewFile("rawTest.int"),
                         memFormat(int1=integer4, int2=integer4))
as.character(fileFormat)
</code></pre>

<hr>
<h2 id='atomicBlock'> Create an atomicBlock Object </h2><span id='topic+atomicBlock'></span><span id='topic+ASCIIchar'></span><span id='topic+integer1'></span><span id='topic+integer2'></span><span id='topic+integer3'></span><span id='topic+integer4'></span><span id='topic+integer8'></span><span id='topic+real4'></span><span id='topic+real8'></span>

<h3>Description</h3>

<p>This function creates an <code>"atomicBlock"</code> object, which is
a description of a block of binary data.  This can be used
as part of a description of a binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atomicBlock(type = "char", width = NULL, machine = "hex",
            size = switch(type, char = 1, int = 4, real = 8),
            endian = "little", signed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="atomicBlock_+3A_type">type</code></td>
<td>
<p> How the block of binary data will be interpreted.
either <code>"char"</code> (an ASCII character),
<code>"int"</code> (an integer), or <code>"real"</code> (a floating point number).</p>
</td></tr>
<tr><td><code id="atomicBlock_+3A_width">width</code></td>
<td>
<p>The number of bytes to print per row when displaying the block.</p>
</td></tr>
<tr><td><code id="atomicBlock_+3A_machine">machine</code></td>
<td>
<p>How to print each byte when displaying; either
<code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="atomicBlock_+3A_size">size</code></td>
<td>
<p>The number of bytes used to generate each value
when interpreting the raw binary as character or numeric data.</p>
</td></tr>
<tr><td><code id="atomicBlock_+3A_endian">endian</code></td>
<td>
<p>The endianness of the binary data;  used when
interpreting bytes as numeric values.</p>
</td></tr>
<tr><td><code id="atomicBlock_+3A_signed">signed</code></td>
<td>
<p>Whether the bytes should be interpreted as a
signed numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>"atomicBlock"</code> object describes a binary block
representing a single value.
</p>
<p>Several standard binary types are predefined (with common
C type equivalents in brackets):
<code>ASCIIchar</code> (char),
<code>integer1</code> (signed char),
<code>integer2</code> (short),
<code>integer3</code>,
<code>integer4</code> (int, long),
<code>integer8</code> (long long),
<code>real4</code> (float),
<code>real8</code> (double).
</p>


<h3>Value</h3>

<p>An <code>"atomicBlock"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+memBlock">memBlock</a></code>
<code><a href="#topic+vectorBlock">vectorBlock</a></code>
<code><a href="#topic+lengthBlock">lengthBlock</a></code>
<code><a href="#topic+mixedBlock">mixedBlock</a></code>
<code><a href="#topic+markedBlock">markedBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A C long
atomicBlock("int", size=4)
integer4
</code></pre>

<hr>
<h2 id='blockValue'> Extract the Value of a Binary Block </h2><span id='topic+blockValue'></span><span id='topic+blockString'></span>

<h3>Description</h3>

<p>The <code>blockValue</code> function returns the interpreted value of a block
of binary data (a <code>"rawBlock"</code> object).
</p>
<p>The <code>blockString</code> function returns a null-terminated string
from a block
of binary data that is interpreted as a character data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockValue(block)

blockString(block)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockValue_+3A_block">block</code></td>
<td>
<p> A <code>"rawBlock"</code> object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type
of the value returned is determined when the binary
block is created (e.g., by <code>readRaw</code>)
<em>not</em> when the value is extracted
by the <code>blockValue</code> function.
</p>
<p>The <code>blockString</code> function is useful for extracting
a value from a binary block which is a string padded with
null characters.
</p>
<p>The <code>blockString</code> function throws an error if the
block is not interpreted as a character value.
</p>


<h3>Value</h3>

<p>Either a character, or numeric vector depending on how the
binary block should be interpreted.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readRaw">readRaw</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>charBlock &lt;- readRaw(hexViewFile("rawTest.txt"), width=8)
blockValue(charBlock)
blockString(charBlock)

intBlock &lt;- readRaw(hexViewFile("rawTest.int"), human="int")
blockValue(intBlock)
</code></pre>

<hr>
<h2 id='hexViewFile'> Specify an Example File </h2><span id='topic+hexViewFile'></span>

<h3>Description</h3>

<p>This is just a convenience function for specifying
one of the example files contained in the hexView package.
It is used in examples in hexView help pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexViewFile(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hexViewFile_+3A_filename">filename</code></td>
<td>
<p> The name of the example file. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full path to the appropriate example file.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'>hexViewFile("rawTest.txt")
</code></pre>

<hr>
<h2 id='markedBlock'> Create a markedBlock Object </h2><span id='topic+markedBlock'></span>

<h3>Description</h3>

<p>This function creates a <code>"markedBlock"</code> object, which is
a description of a block of binary data.  This can be used
as part of a description of a binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markedBlock(marker=integer4,
            switch=function(marker) { ASCIIchar },
            markerLabel="marker", blockLabel="block")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markedBlock_+3A_marker">marker</code></td>
<td>
<p> A <code>"memBlock"</code> object. </p>
</td></tr>
<tr><td><code id="markedBlock_+3A_switch">switch</code></td>
<td>
<p> A function that returns a <code>"memBlock"</code> object,
or <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="markedBlock_+3A_markerlabel">markerLabel</code></td>
<td>
<p> A label to name the marker component of the
<code>"markedBlock"</code> object.</p>
</td></tr>
<tr><td><code id="markedBlock_+3A_blocklabel">blockLabel</code></td>
<td>
<p> A label to name the component that is read
after the marker component of the
<code>"markedBlock"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>"markedBlock"</code> object describes a block of binary data that consists
of a &ldquo;marker&rdquo; block containing information on further blocks.
The <code>marker</code> block is read first, then this block is passed
to the <code>switch</code> function.  The <code>switch</code> function
can look at the contents of the <code>marker</code> block and decide
what sort of block should be read next (the <code>blockValue()</code>
function may be useful here).  The result of the
<code>switch</code> function is read from the end of the <code>marker</code>
block.  The <code>marker</code> block and the result of the <code>switch</code>
function can be any type
of <code>"memBlock"</code> object.  If the result of the <code>switch()</code>
function is <code>NULL</code> then only the <code>marker</code> block is returned
(no further memory is read).
</p>


<h3>Value</h3>

<p>A <code>"markedBlock"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+memBlock">memBlock</a></code>
<code><a href="#topic+atomicBlock">atomicBlock</a></code>
<code><a href="#topic+vectorBlock">vectorBlock</a></code>
<code><a href="#topic+lengthBlock">lengthBlock</a></code>
<code><a href="#topic+mixedBlock">mixedBlock</a></code>
<code><a href="#topic+blockValue">blockValue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single-byte integer which dictates how many
# subsequent four-byte reals to read
markedBlock(integer1,
            function(marker) {
              lengthBlock(real4, blockValue(marker))
            })
</code></pre>

<hr>
<h2 id='memBlock'> Create a memBlock Object </h2><span id='topic+memBlock'></span>

<h3>Description</h3>

<p>This function creates a <code>"memBlock"</code> object, which is
a description of a block of binary data.  This can be used
as part of a description of a binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memBlock(nbytes = 1, width = NULL, machine = "hex")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="memBlock_+3A_nbytes">nbytes</code></td>
<td>
<p> The number of bytes in the block. </p>
</td></tr>
<tr><td><code id="memBlock_+3A_width">width</code></td>
<td>
<p>The number of bytes to print per row when displaying the block.</p>
</td></tr>
<tr><td><code id="memBlock_+3A_machine">machine</code></td>
<td>
<p>How to print each byte when displaying; either
<code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary block that is read in from a file using this description
is interpreted as <code>nbytes</code> single-byte characters.
</p>
<p>The description includes parameters controlling how a block of data
should be displayed if this description is used to read in a block
of binary data.
</p>


<h3>Value</h3>

<p>A  <code>"memBlock"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+atomicBlock">atomicBlock</a></code>
<code><a href="#topic+vectorBlock">vectorBlock</a></code>
<code><a href="#topic+lengthBlock">lengthBlock</a></code>
<code><a href="#topic+mixedBlock">mixedBlock</a></code>
<code><a href="#topic+markedBlock">markedBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  memBlock(8)
</code></pre>

<hr>
<h2 id='memFormat'> Create a memFormat Object </h2><span id='topic+memFormat'></span>

<h3>Description</h3>

<p>This function creates a <code>"memFormat"</code> object which is
a description of a binary file format.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memFormat(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="memFormat_+3A_...">...</code></td>
<td>
<p> One or more <code>"memBlock"</code> objects. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>"memFormat"</code> object is made up of one or more
<code>"memBlock"</code> objects.
</p>


<h3>Value</h3>

<p>A <code>"memFormat"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+memBlock">memBlock</a></code>
<code><a href="#topic+atomicBlock">atomicBlock</a></code>
<code><a href="#topic+vectorBlock">vectorBlock</a></code>
<code><a href="#topic+lengthBlock">lengthBlock</a></code>
<code><a href="#topic+mixedBlock">mixedBlock</a></code>
<code><a href="#topic+markedBlock">markedBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>memFormat(int1=integer4, int2=integer4)
</code></pre>

<hr>
<h2 id='mixedBlock'> Create a mixedBlock Object </h2><span id='topic+mixedBlock'></span>

<h3>Description</h3>

<p>This function creates a <code>"mixedBlock"</code> object, which is
a description of a block of binary data.  This can be used
as part of a description of a binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixedBlock(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixedBlock_+3A_...">...</code></td>
<td>
<p> One or more <code>"memBlock"</code> objects. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>"mixedBlock"</code> object describes a block of binary data that consists
of a series of sub-blocks.  Each sub-block can be any type
of <code>"memBlock"</code> object.
</p>


<h3>Value</h3>

<p>A <code>"mixedBlock"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+memBlock">memBlock</a></code>
<code><a href="#topic+atomicBlock">atomicBlock</a></code>
<code><a href="#topic+vectorBlock">vectorBlock</a></code>
<code><a href="#topic+lengthBlock">lengthBlock</a></code>
<code><a href="#topic+markedBlock">markedBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A line of text followed by a four-byte integer
mixedBlock(ASCIIline, integer4)
</code></pre>

<hr>
<h2 id='print.rawBlock'> Print Method for Block of Binary Data </h2><span id='topic+print.rawBlock'></span>

<h3>Description</h3>

<p>This function displays a <code>"rawBlock"</code> object.
Each line of output contains a binary offset, the binary data
in a raw machine format, and an interpretation of
the data in a human-readable format.
The object contains parameters controlling the format
of the display, some of which may be overridden in
the call to <code>print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rawBlock'
print(x, width = NULL, machine = NULL,
      sep1 = "  :  ", sep2 = "  |  ",
      showOffset = TRUE, showHuman = TRUE, 
      page = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rawBlock_+3A_x">x</code></td>
<td>
<p> A <code>"rawBlock"</code> object. </p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_width">width</code></td>
<td>
<p> The number of bytes to display per line of output. </p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_machine">machine</code></td>
<td>
<p> The machine format to display;
either <code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_sep1">sep1</code></td>
<td>
<p> A separator to insert between the block offset
and the machine format.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_sep2">sep2</code></td>
<td>
<p> A separator to insert between the machine format
and the human-readable format.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_showoffset">showOffset</code></td>
<td>
<p> If <code>FALSE</code>, the column of offsets is
not printed.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_showhuman">showHuman</code></td>
<td>
<p> If <code>FALSE</code>, the column of human-readable format is
not printed.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_page">page</code></td>
<td>
<p> If <code>TRUE</code> the output is sent to the
file viewer specified by <code>getOption("pager")</code>.</p>
</td></tr>
<tr><td><code id="print.rawBlock_+3A_...">...</code></td>
<td>
<p> Other arguments to <code>print</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If either <code>width</code> or <code>machine</code> is <code>NULL</code>,
the relevant value is taken from the
<code>"rawBlock"</code> object.  The human-readable format is
taken from the <code>"rawBlock"</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readRaw">readRaw</a></code>
<code><a href="#topic+as.character.rawBlock">as.character.rawBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileBlock &lt;- readRaw(hexViewFile("rawTest.txt"))
print(fileBlock)
print(fileBlock, width=8)
print(fileBlock, machine="binary", width=4)
</code></pre>

<hr>
<h2 id='print.rawFormat'> Print Method for Binary File Format </h2><span id='topic+print.rawFormat'></span>

<h3>Description</h3>

<p>This function displays a <code>"rawFormat"</code> object.
Each line of output contains a binary offset, the binary data
in a raw machine format, and an interpretation of
the data in a human-readable format. The format
consists of one or more sub-blocks and a heading line
is added for each block.
The object contains parameters controlling the format
of the display, some of which may be overridden in
the call to <code>print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rawFormat'
print(x, sep1 = "  :  ", sep2 = "  |  ",
                  blockHead = TRUE, blockChar = "=", page = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rawFormat_+3A_x">x</code></td>
<td>
<p> A <code>"rawFormat"</code> object. </p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_sep1">sep1</code></td>
<td>
<p> A separator to insert between the format offset
and the machine format.</p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_sep2">sep2</code></td>
<td>
<p> A separator to insert between the machine format
and the human-readable format.</p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_blockhead">blockHead</code></td>
<td>
<p> A logical indicating whether to print
a header between blocks of the format. </p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_blockchar">blockChar</code></td>
<td>
<p> The character used as a prefix to
the block names for printing headers between blocks. </p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_page">page</code></td>
<td>
<p> If <code>TRUE</code> the output is sent to the
file viewer specified by <code>getOption("pager")</code>.</p>
</td></tr>
<tr><td><code id="print.rawFormat_+3A_...">...</code></td>
<td>
<p> Other arguments to <code>print</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information on the number of bytes on each line, the machine representation
of each byte and the human-readable format are all taken from the
taken from the <code>"rawBlock"</code> elements of the <code>"rawFormat"</code>
object.   Consequently each block can have a quite different
appearance.  Considerable effort is made to line up the separators
across all blocks within the format.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+as.character.rawFormat">as.character.rawFormat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileFormat &lt;- readFormat(hexViewFile("rawTest.int"),
                         memFormat(int1=integer4, int2=integer4))
print(fileFormat)
print(fileFormat, sep2=":")
</code></pre>

<hr>
<h2 id='readEViews'> Read an Eviews File </h2><span id='topic+readEViews'></span>

<h3>Description</h3>

<p>This function reads a file in Eviews format (Eviews is
an econometrics package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readEViews(filename, time.stamp=TRUE, as.data.frame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readEViews_+3A_filename">filename</code></td>
<td>
<p> The name of the file. </p>
</td></tr>
<tr><td><code id="readEViews_+3A_time.stamp">time.stamp</code></td>
<td>
<p> A logical indicating whether to include a
<code>Date</code> column in the result. </p>
</td></tr>
<tr><td><code id="readEViews_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p> If <code>TRUE</code> the result is a data frame;
otherwise a list of variables is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a demonstration of how the functions in
this package can be used to read a complex binary format.  It has
been tested on a few sample files (and works), but there is no
guarantee it will work for all Eviews files (this is not helped
by the fact that it is based on reverse-engineering information
about the Eviews format, NOT an official description of the format.
</p>


<h3>Value</h3>

<p>Either a data frame or a list of variables.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>References</h3>

 <p><a href="http://www.eviews.com/">http://www.eviews.com/</a> and
<a href="http://www.ecn.wfu.edu/~cottrell/eviews_format/">http://www.ecn.wfu.edu/~cottrell/eviews_format/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>readEViews(hexViewFile("data4-1.wf1"))
</code></pre>

<hr>
<h2 id='readFormat'> Read a Binary File </h2><span id='topic+readFormat'></span>

<h3>Description</h3>

<p>Read the raw binary content of a file using a description
of the binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFormat(file, format, width = NULL, offset = 0, machine = "hex",
           flatten = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readFormat_+3A_file">file</code></td>
<td>
<p>The name of a file or a connection.</p>
</td></tr>
<tr><td><code id="readFormat_+3A_format">format</code></td>
<td>
<p> A <code>"memFormat"</code> object. </p>
</td></tr>
<tr><td><code id="readFormat_+3A_width">width</code></td>
<td>
<p>The number of bytes to print per row when displaying the
file. </p>
</td></tr>
<tr><td><code id="readFormat_+3A_offset">offset</code></td>
<td>
<p>An offset within the file to start reading.</p>
</td></tr>
<tr><td><code id="readFormat_+3A_machine">machine</code></td>
<td>
<p>How to print each byte when displaying the file; either
<code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="readFormat_+3A_flatten">flatten</code></td>
<td>
<p>If <code>TRUE</code> the list of blocks created from the
<code>"memFormat"</code> description are flattened to a list of depth 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a <code>"memFormat"</code> description to
read the raw binary content of a file and interpret
sub-blocks of the file as distinct (blocks of) values.
</p>
<p>The <code>"memFormat"</code> can described a nested structure of
blocks.  The <code>flatten</code> argument is used to convert
nested format structures to a flat (depth of one) structure.
</p>
<p>The format is always flattened for display, but extracting
</p>


<h3>Value</h3>

<p>A <code>"rawFormat"</code> object, which is a list:
</p>
<table role = "presentation">
<tr><td><code>blocks</code></td>
<td>
<p>A list (of lists) of <code>"rawBlock"</code> objects. </p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>The offset in the file where reading began.</p>
</td></tr>
<tr><td><code>nbytes</code></td>
<td>
<p>The number of bytes read from the file.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+viewFormat">viewFormat</a></code>
<code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+as.character.rawFormat">as.character.rawFormat</a></code>
<code><a href="#topic+print.rawFormat">print.rawFormat</a></code>
<code><a href="#topic+readRaw">readRaw</a></code>
<code><a href="base.html#topic+readBin">readBin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileFormat &lt;- readFormat(hexViewFile("rawTest.int"),
                         memFormat(int1=integer4, int2=integer4))
blockValue(fileFormat$blocks$int2)

fileFormat &lt;- readFormat(hexViewFile("rawTest.int"),
                         memFormat(integers=vectorBlock(integer4, 20)))
blockValue(fileFormat$blocks$integers)
</code></pre>

<hr>
<h2 id='readRaw'>Read the Raw Binary Content of a File</h2><span id='topic+readRaw'></span>

<h3>Description</h3>

<p>Read the contents of a file as bytes and create an object
containing the raw data, plus
optionally an interpretation of the bytes as numeric values,
plus parameters controlling how to display the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readRaw(file, width = NULL, offset = 0, nbytes = NULL,
        machine = "hex", human = "char",
        size = switch(human, char = 1, int = 4, real = 8),
        endian = .Platform$endian, signed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readRaw_+3A_file">file</code></td>
<td>
<p>The name of a file or a connection.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_width">width</code></td>
<td>
<p>The number of bytes to print per row when displaying the data.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_offset">offset</code></td>
<td>
<p>An offset within the file to start reading.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_nbytes">nbytes</code></td>
<td>
<p>The number of bytes to read from the file.
<code>NULL</code> means read the whole file.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_machine">machine</code></td>
<td>
<p>How to print each byte when displaying; either
<code>"hex"</code> or <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_human">human</code></td>
<td>
<p>How to print a human-readable form of the data;
either <code>"char"</code> (an ASCII character),
<code>"int"</code> (an integer), or <code>"real"</code> (a floating point number).</p>
</td></tr>
<tr><td><code id="readRaw_+3A_size">size</code></td>
<td>
<p>The number of bytes used to generate each value
when interpreting the raw binary as character or numeric data.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_endian">endian</code></td>
<td>
<p>The endianness of the binary data;  used when
interpreting bytes as numeric values.</p>
</td></tr>
<tr><td><code id="readRaw_+3A_signed">signed</code></td>
<td>
<p>Whether the bytes should be interpreted as a
signed numeric value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each individual byte is printed in the appropriate <code>machine</code>
format, but there is only one value printed in the appropriate
<code>human</code> format for every <code>size</code> bytes.  Consequently,
the <code>width</code>
must be a multiple of the <code>size</code>.  
</p>


<h3>Value</h3>

<p>An object of class <code>"rawBlock"</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+viewRaw">viewRaw</a></code>
<code><a href="base.html#topic+readBin">readBin</a></code>
<code><a href="#topic+as.character.rawBlock">as.character.rawBlock</a></code>
<code><a href="#topic+print.rawBlock">print.rawBlock</a></code>
<code><a href="#topic+blockValue">blockValue</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readLines(hexViewFile("rawTest.txt"))

fileBlock &lt;- readRaw(hexViewFile("rawTest.txt"), width=8)
blockValue(fileBlock)

fileBlock &lt;- readRaw(hexViewFile("rawTest.int"), human="int")
blockValue(fileBlock)
</code></pre>

<hr>
<h2 id='vectorBlock'> Create a vectorBlock Object </h2><span id='topic+vectorBlock'></span><span id='topic+lengthBlock'></span><span id='topic+ASCIIline'></span>

<h3>Description</h3>

<p>These functions create a <code>"vectorBlock"</code> or
<code>lengthBlock</code> object, which are
a descriptions of a block of binary data.  These can be used
as part of a description of a binary format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorBlock(block = ASCIIchar, length = 1)
lengthBlock(length = integer4, block = ASCIIchar, blockLabel = "block")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vectorBlock_+3A_block">block</code></td>
<td>
<p> An object derived from the <code>"memBlock"</code>
class, e.g., an <code>"atomicBlock"</code> object. </p>
</td></tr>
<tr><td><code id="vectorBlock_+3A_length">length</code></td>
<td>
<p> The number of <code>block</code> objects in
the overall binary block. </p>
</td></tr>
<tr><td><code id="vectorBlock_+3A_blocklabel">blockLabel</code></td>
<td>
<p> A label to name the block component of the
<code>"lengthBlock"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These objects describe a block of binary data that consists
of a repeating sub-block.  The sub-block can be any type
of <code>"memBlock"</code> object.
</p>
<p>There is also a predefined <code>ASCIIline</code> block, which is
a block of single-byte characters terminated by a newline
character.
</p>


<h3>Value</h3>

<p>A <code>"vectorBlock"</code> or
<code>lengthBlock</code> object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+memFormat">memFormat</a></code>
<code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+memBlock">memBlock</a></code>
<code><a href="#topic+atomicBlock">atomicBlock</a></code>
<code><a href="#topic+mixedBlock">mixedBlock</a></code>
<code><a href="#topic+markedBlock">markedBlock</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A block of 20 four-byte blocks
# which are interpreted as integer values
vectorBlock(integer4, 20)
</code></pre>

<hr>
<h2 id='viewFormat'> View a Binary File </h2><span id='topic+viewFormat'></span>

<h3>Description</h3>

<p>Displays the raw bytes of a file like a hex editor, showing
offsets within the file, raw bytes in binary or hexadecimal form,
and a human-readable representation of the bytes as either
ASCII characters, integers, or real values.  The file
is broken up into blocks according to a supplied file format
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewFormat(..., page = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewFormat_+3A_...">...</code></td>
<td>
<p> Arguments passed to the function <code>readFormat</code>,
most importantly, a <code>"memFormat"</code> describing the file format.</p>
</td></tr>
<tr><td><code id="viewFormat_+3A_page">page</code></td>
<td>
<p>If <code>TRUE</code>, the output is sent to the application
set up to display text files as per <code>getOption("pager")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only called for its side-effect, which is
to display the file.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readFormat">readFormat</a></code>
<code><a href="#topic+viewRaw">viewRaw</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>viewFormat(hexViewFile("rawTest.int"),
           memFormat(int1=integer4, int2=integer4))
viewFormat(hexViewFile("rawTest.int"),
           memFormat(integers=vectorBlock(integer4, 20)))
</code></pre>

<hr>
<h2 id='viewRaw'>View the Raw Binary Content of a File</h2><span id='topic+viewRaw'></span>

<h3>Description</h3>

<p>Displays the raw bytes of a file like a hex editor, showing
offsets within the file, raw bytes in binary or hexadecimal form,
and a human-readable representation of the bytes as either
ASCII characters, integers, or real values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewRaw(..., page = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewRaw_+3A_...">...</code></td>
<td>
<p>Arguments passed to the function <code>readRaw</code>.</p>
</td></tr>
<tr><td><code id="viewRaw_+3A_page">page</code></td>
<td>
<p>If <code>TRUE</code>, the output is sent to the application
set up to display text files as per <code>getOption("pager")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only called for its side-effect, which is
to display the file.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+readRaw">readRaw</a></code>
<code><a href="#topic+viewFormat">viewFormat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>viewRaw(hexViewFile("rawTest.txt"), width=8)
viewRaw(hexViewFile("rawTest.txt"), machine="binary", width=4)

# UNICODE text
# rawTest.unicode created using Notepad on Windows
viewRaw(hexViewFile("rawTest.unicode"), width=8)

viewRaw(hexViewFile("rawTest.int"), human="int")
viewRaw(hexViewFile("rawTest.real"), human="real", width=8, endian="big")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
